{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Add build UUID\n\nDescription: Recent macOS versions require user permissions to access the local network. This can only be granted for binaries which have a LC_UUID load command. Go 1.24 adds the UUID by default, but the fix was backported to Go 1.22.9 and 1.23 where it requires passing `-B gobuildid` to the linker.\r\n\r\ncloudflared uses Cloudflare's Go fork which is based on Go 1.22.5 and doesn't have the backport. Because of this, cloudflared can't talk to any machine on the local network (no route to host) when it's runnning as a non-root user.\r\n\r\nThis workaround updates the Go fork to go1.22.12-devel-cf and adds `-B gobuildid` so that the binary now has a UUID:\r\n\r\n```\r\n\u276f dwarfdump --uuid /opt/homebrew/bin/cloudflared\r\nUUID: F2088E17-03A1-34B1-F12C-0DF01F00BA32 (arm64) /opt/homebrew/bin/cloudflared\r\n```\r\n\r\nFixes #1460\n\nCode Diff:\n.teamcity/install-cloudflare-go.sh\n@@ -3,6 +3,6 @@\n cd /tmp\n git clone -q https://github.com/cloudflare/go\n cd go/src\n-# https://github.com/cloudflare/go/tree/af19da5605ca11f85776ef7af3384a02a315a52b is version go1.22.5-devel-cf\n-git checkout -q af19da5605ca11f85776ef7af3384a02a315a52b\n+# https://github.com/cloudflare/go/tree/37bc41c6ff79507200a315b72834fce6ca427a7e is version go1.22.12-devel-cf\n+git checkout -q 37bc41c6ff79507200a315b72834fce6ca427a7e\n ./make.bash\n---\nMakefile\n@@ -42,7 +42,7 @@ ifeq ($(FIPS), true)\n \tVERSION_FLAGS := $(VERSION_FLAGS) -X \"main.BuildType=FIPS\"\n endif\n \n[[MASK]]\n---\n\n"}], "ideal": ".teamcity/install-cloudflare-go.sh\n@@ -3,6 +3,6 @@\n cd /tmp\n git clone -q https://github.com/cloudflare/go\n cd go/src\n-# https://github.com/cloudflare/go/tree/af19da5605ca11f85776ef7af3384a02a315a52b is version go1.22.5-devel-cf\n-git checkout -q af19da5605ca11f85776ef7af3384a02a315a52b\n+# https://github.com/cloudflare/go/tree/37bc41c6ff79507200a315b72834fce6ca427a7e is version go1.22.12-devel-cf\n+git checkout -q 37bc41c6ff79507200a315b72834fce6ca427a7e\n ./make.bash\n---\nMakefile\n@@ -42,7 +42,7 @@ ifeq ($(FIPS), true)\n \tVERSION_FLAGS := $(VERSION_FLAGS) -X \"main.BuildType=FIPS\"\n endif\n \n-LDFLAGS := -ldflags='$(VERSION_FLAGS) $(LINK_FLAGS)'\n+LDFLAGS := -ldflags='$(VERSION_FLAGS) $(LINK_FLAGS) -B gobuildid'\n ifneq ($(GO_BUILD_TAGS),)\n \tGO_BUILD_TAGS := -tags \"$(GO_BUILD_TAGS)\"\n endif\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Bump to Go 1.24.2\n\nDescription: Fixes https://github.com/cloudflare/cloudflared/issues/1460.\r\n\r\nThis required fixing new `go vet` findings:\r\n\r\n```\r\ntunnelrpc/pogs/configuration_manager.go:99:22: non-constant format string in call to fmt.Errorf\r\ntunnelrpc/pogs/session_manager.go:130:22: non-constant format string in call to fmt.Errorf\r\ningress/ingress.go:116:20: non-constant format string in call to (*github.com/rs/zerolog.Event).Msgf\r\ningress/origin_proxy.go:77:21: non-constant format string in call to (*github.com/rs/zerolog.Event).Msgf\r\ncmd/cloudflared/tunnel/subcommands.go:764:31: non-constant format string in call to github.com/cloudflare/cloudflared/cmd/cloudflared/cliutil.UsageError\r\n```\n\nCode Diff:\ncmd/cloudflared/tunnel/subcommands.go\n@@ -761,7 +761,7 @@ func runCommand(c *cli.Context) error {\n \t\tif tokenFile := c.String(TunnelTokenFileFlag); tokenFile != \"\" {\n \t\t\tdata, err := os.ReadFile(tokenFile)\n \t\t\tif err != nil {\n-\t\t\t\treturn cliutil.UsageError(\"Failed to read token file: \" + err.Error())\n+\t\t\t\treturn cliutil.UsageError(\"Failed to read token file: %s\", err.Error())\n \t\t\t}\n \t\t\ttokenStr = strings.TrimSpace(string(data))\n \t\t}\n---\ngo.mod\n@@ -1,6 +1,6 @@\n module github.com/cloudflare/cloudflared\n \n-go 1.22\n+go 1.24.2\n \n require (\n \tgithub.com/coredns/coredns v1.11.3\n---\ningress/ingress.go\n@@ -113,7 +113,7 @@ func ParseIngressFromConfigAndCLI(conf *config.Configuration, c *cli.Context, lo\n \t\t// If no token is provided, the probability of NOT being a remotely managed tunnel is higher.\n \t\t// So, we should warn the user that no ingress rules were found, because remote configuration will most likely not exist.\n \t\tif !c.IsSet(\"token\") {\n-\t\t\tlog.Warn().Msgf(ErrNoIngressRulesCLI.Error())\n+\t\t\tlog.Warn().Msg(ErrNoIngressRulesCLI.Error())\n \t\t}\n \t\treturn newDefaultOrigin(c, log), nil\n \t}\n---\ningress/origin_proxy.go\n@@ -74,7 +74,7 @@ func (o *httpService) SetOriginServerName(req *http.Request) {\n \n func (o *statusCode) RoundTrip(_ *http.Request) (*http.Response, error) {\n[[MASK]]\n \t\tStatusCode: o.code,\n---\ntunnelrpc/pogs/configuration_manager.go\n@@ -2,7 +2,7 @@ package pogs\n \n import (\n \t\"context\"\n-\t\"fmt\"\n+\t\"errors\"\n \n \tcapnp \"zombiezen.com/go/capnproto2\"\n \t\"zombiezen.com/go/capnproto2/rpc\"\n@@ -96,7 +96,7 @@ func (p *UpdateConfigurationResponse) Unmarshal(s proto.UpdateConfigurationRespo\n \t\treturn err\n \t}\n \tif respErr != \"\" {\n-\t\tp.Err = fmt.Errorf(respErr)\n+\t\tp.Err = errors.New(respErr)\n \t}\n \treturn nil\n }\n---\ntunnelrpc/pogs/session_manager.go\n@@ -2,6 +2,7 @@ package pogs\n \n import (\n \t\"context\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"net\"\n \t\"time\"\n@@ -127,7 +128,7 @@ func (p *RegisterUdpSessionResponse) Unmarshal(s proto.RegisterUdpSessionRespons\n \t\treturn err\n \t}\n \tif respErr != \"\" {\n-\t\tp.Err = fmt.Errorf(respErr)\n+\t\tp.Err = errors.New(respErr)\n \t}\n \tp.Spans, err = s.Spans()\n \tif err != nil {\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/subcommands.go\n@@ -761,7 +761,7 @@ func runCommand(c *cli.Context) error {\n \t\tif tokenFile := c.String(TunnelTokenFileFlag); tokenFile != \"\" {\n \t\t\tdata, err := os.ReadFile(tokenFile)\n \t\t\tif err != nil {\n-\t\t\t\treturn cliutil.UsageError(\"Failed to read token file: \" + err.Error())\n+\t\t\t\treturn cliutil.UsageError(\"Failed to read token file: %s\", err.Error())\n \t\t\t}\n \t\t\ttokenStr = strings.TrimSpace(string(data))\n \t\t}\n---\ngo.mod\n@@ -1,6 +1,6 @@\n module github.com/cloudflare/cloudflared\n \n-go 1.22\n+go 1.24.2\n \n require (\n \tgithub.com/coredns/coredns v1.11.3\n---\ningress/ingress.go\n@@ -113,7 +113,7 @@ func ParseIngressFromConfigAndCLI(conf *config.Configuration, c *cli.Context, lo\n \t\t// If no token is provided, the probability of NOT being a remotely managed tunnel is higher.\n \t\t// So, we should warn the user that no ingress rules were found, because remote configuration will most likely not exist.\n \t\tif !c.IsSet(\"token\") {\n-\t\t\tlog.Warn().Msgf(ErrNoIngressRulesCLI.Error())\n+\t\t\tlog.Warn().Msg(ErrNoIngressRulesCLI.Error())\n \t\t}\n \t\treturn newDefaultOrigin(c, log), nil\n \t}\n---\ningress/origin_proxy.go\n@@ -74,7 +74,7 @@ func (o *httpService) SetOriginServerName(req *http.Request) {\n \n func (o *statusCode) RoundTrip(_ *http.Request) (*http.Response, error) {\n \tif o.defaultResp {\n-\t\to.log.Warn().Msgf(ErrNoIngressRulesCLI.Error())\n+\t\to.log.Warn().Msg(ErrNoIngressRulesCLI.Error())\n \t}\n \tresp := &http.Response{\n \t\tStatusCode: o.code,\n---\ntunnelrpc/pogs/configuration_manager.go\n@@ -2,7 +2,7 @@ package pogs\n \n import (\n \t\"context\"\n-\t\"fmt\"\n+\t\"errors\"\n \n \tcapnp \"zombiezen.com/go/capnproto2\"\n \t\"zombiezen.com/go/capnproto2/rpc\"\n@@ -96,7 +96,7 @@ func (p *UpdateConfigurationResponse) Unmarshal(s proto.UpdateConfigurationRespo\n \t\treturn err\n \t}\n \tif respErr != \"\" {\n-\t\tp.Err = fmt.Errorf(respErr)\n+\t\tp.Err = errors.New(respErr)\n \t}\n \treturn nil\n }\n---\ntunnelrpc/pogs/session_manager.go\n@@ -2,6 +2,7 @@ package pogs\n \n import (\n \t\"context\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"net\"\n \t\"time\"\n@@ -127,7 +128,7 @@ func (p *RegisterUdpSessionResponse) Unmarshal(s proto.RegisterUdpSessionRespons\n \t\treturn err\n \t}\n \tif respErr != \"\" {\n-\t\tp.Err = fmt.Errorf(respErr)\n+\t\tp.Err = errors.New(respErr)\n \t}\n \tp.Spans, err = s.Spans()\n \tif err != nil {\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: fix: expand home directory for credentials file\n\nDescription: ## Issue\r\n\r\nThe [documentation for creating a tunnel's configuration file](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/get-started/create-local-tunnel/#4-create-a-configuration-file) does not specify that the `credentials-file` field in `config.yml` needs to be an absolute path.\r\n\r\nA user (E.G. me \ud83e\udd26) might add a path like `~/.cloudflared/<uuid>.json` and wonder why the `cloudflared tunnel run` command is throwing a credentials file not found error. Although one might consider it intuitive, it's not a fair assumption as a lot of CLI tools allow file paths with `~` for specifying files.\r\n\r\nP.S. The tunnel ID in the following snippet is not a real tunnel ID, I just generated it.\r\n```\r\nurl: http://localhost:8000\r\ntunnel: 958a1ef6-ff8c-4455-825a-5aed91242135\r\ncredentials-file: ~/.cloudflared/958a1ef6-ff8c-4455-825a-5aed91242135.json\r\n```\r\n\r\nFurthermore, the error has a confusing message for the user as the file at the logged path actually exists, it is just that `os.Stat` failed because it could not expand the `~`.\r\n\r\n## Solution\r\n\r\nThis commit fixes the above issue by running a `homedir.Expand` on the `credentials-file` path in the `credentialFinder` function.\n\nCode Diff:\ncmd/cloudflared/tunnel/subcommand_context.go\n@@ -9,6 +9,7 @@ import (\n[[MASK]]\n \t\"github.com/rs/zerolog\"\n \t\"github.com/urfave/cli/v2\"\n@@ -54,7 +55,12 @@ func newSubcommandContext(c *cli.Context) (*subcommandContext, error) {\n // Returns something that can find the given tunnel's credentials file.\n func (sc *subcommandContext) credentialFinder(tunnelID uuid.UUID) CredFinder {\n \tif path := sc.c.String(CredFileFlag); path != \"\" {\n-\t\treturn newStaticPath(path, sc.fs)\n+\t\t// Expand path if CredFileFlag contains `~`\n+\t\tabsPath, err := homedir.Expand(path)\n+\t\tif err != nil {\n+\t\t\treturn newStaticPath(path, sc.fs)\n+\t\t}\n+\t\treturn newStaticPath(absPath, sc.fs)\n \t}\n \treturn newSearchByID(tunnelID, sc.c, sc.log, sc.fs)\n }\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/subcommand_context.go\n@@ -9,6 +9,7 @@ import (\n \t\"strings\"\n \n \t\"github.com/google/uuid\"\n+\t\"github.com/mitchellh/go-homedir\"\n \t\"github.com/pkg/errors\"\n \t\"github.com/rs/zerolog\"\n \t\"github.com/urfave/cli/v2\"\n@@ -54,7 +55,12 @@ func newSubcommandContext(c *cli.Context) (*subcommandContext, error) {\n // Returns something that can find the given tunnel's credentials file.\n func (sc *subcommandContext) credentialFinder(tunnelID uuid.UUID) CredFinder {\n \tif path := sc.c.String(CredFileFlag); path != \"\" {\n-\t\treturn newStaticPath(path, sc.fs)\n+\t\t// Expand path if CredFileFlag contains `~`\n+\t\tabsPath, err := homedir.Expand(path)\n+\t\tif err != nil {\n+\t\t\treturn newStaticPath(path, sc.fs)\n+\t\t}\n+\t\treturn newStaticPath(absPath, sc.fs)\n \t}\n \treturn newSearchByID(tunnelID, sc.c, sc.log, sc.fs)\n }\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: feat(Makefile): add support for arch mips\n\nDescription: Usage:\r\n```sh\r\nTARGET_OS=linux GOARCH=mipsle TARGET_MIPS=softfloat make cloudflared\r\n```\n\nCode Diff:\nMakefile\n@@ -119,6 +119,11 @@ else\n \tPACKAGE_ARCH := $(TARGET_ARCH)\n endif\n \n+#basically for GOMIPS=softfloat\n+ifneq ($(TARGET_MIPS), )\n+\tMIPS_COMMAND := GOMIPS=$(TARGET_MIPS)\n+endif\n+\n #for FIPS compliance, FPM defaults to MD5.\n RPM_DIGEST := --rpm-digest sha256\n \n@@ -134,7 +139,7 @@ cloudflared:\n ifeq ($(FIPS), true)\n \t$(info Building cloudflared with go-fips)\n endif\n-\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) $(ARM_COMMAND) go build -mod=vendor $(GO_BUILD_TAGS) $(LDFLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) $(ARM_COMMAND) $(MIPS_COMMAND) go build -mod=vendor $(GO_BUILD_TAGS) $(LDFLAGS) $(IMPORT_PATH)/cmd/cloudflared\n ifeq ($(FIPS), true)\n \t./check-fips.sh cloudflared\n endif\n[[MASK]]\n \n-linuxArchs=(\"386\" \"amd64\" \"arm\" \"armhf\" \"arm64\")\n+linuxArchs=(\"386\" \"amd64\" \"arm\" \"armhf\" \"arm64\" \"mipsle\")\n export TARGET_OS=linux\n for arch in ${linuxArchs[@]}; do\n     unset TARGET_ARM\n@@ -27,6 +27,11 @@ for arch in ${linuxArchs[@]}; do\n         export TARGET_ARCH=arm\n         export TARGET_ARM=7 \n     fi\n+\n+    ## Support for softmips builds \n+    if [[ $arch == mipsle ]] ; then\n+        export GOMIPS=softfloat\n+    fi\n     \n     make cloudflared-deb\n     mv cloudflared\\_$VERSION\\_$arch.deb $ARTIFACT_DIR/cloudflared-linux-$arch.deb\n---\n\n"}], "ideal": "Makefile\n@@ -119,6 +119,11 @@ else\n \tPACKAGE_ARCH := $(TARGET_ARCH)\n endif\n \n+#basically for GOMIPS=softfloat\n+ifneq ($(TARGET_MIPS), )\n+\tMIPS_COMMAND := GOMIPS=$(TARGET_MIPS)\n+endif\n+\n #for FIPS compliance, FPM defaults to MD5.\n RPM_DIGEST := --rpm-digest sha256\n \n@@ -134,7 +139,7 @@ cloudflared:\n ifeq ($(FIPS), true)\n \t$(info Building cloudflared with go-fips)\n endif\n-\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) $(ARM_COMMAND) go build -mod=vendor $(GO_BUILD_TAGS) $(LDFLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) $(ARM_COMMAND) $(MIPS_COMMAND) go build -mod=vendor $(GO_BUILD_TAGS) $(LDFLAGS) $(IMPORT_PATH)/cmd/cloudflared\n ifeq ($(FIPS), true)\n \t./check-fips.sh cloudflared\n endif\n---\nbuild-packages.sh\n@@ -10,7 +10,7 @@ export CGO_ENABLED=0\n export ARTIFACT_DIR=artifacts/\n mkdir -p $ARTIFACT_DIR\n \n-linuxArchs=(\"386\" \"amd64\" \"arm\" \"armhf\" \"arm64\")\n+linuxArchs=(\"386\" \"amd64\" \"arm\" \"armhf\" \"arm64\" \"mipsle\")\n export TARGET_OS=linux\n for arch in ${linuxArchs[@]}; do\n     unset TARGET_ARM\n@@ -27,6 +27,11 @@ for arch in ${linuxArchs[@]}; do\n         export TARGET_ARCH=arm\n         export TARGET_ARM=7 \n     fi\n+\n+    ## Support for softmips builds \n+    if [[ $arch == mipsle ]] ; then\n+        export GOMIPS=softfloat\n+    fi\n     \n     make cloudflared-deb\n     mv cloudflared\\_$VERSION\\_$arch.deb $ARTIFACT_DIR/cloudflared-linux-$arch.deb\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Use path and filepath operation appropriately.\n\nDescription: Using path package methods can cause errors on windows machines.\r\n\r\npath methods are used for url operations and unix specific operation.\r\n\r\nfilepath methods are used for file system paths and its cross platform. \r\n\r\nRemove strings.HasSuffix and use filepath.Ext and path.Ext for file and url extenstions respectively.\r\n\n\nCode Diff:\ncmd/cloudflared/service_template.go\n@@ -7,7 +7,7 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"os/exec\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"text/template\"\n \n \thomedir \"github.com/mitchellh/go-homedir\"\n@@ -57,7 +57,7 @@ func (st *ServiceTemplate) Generate(args *ServiceTemplateArgs) error {\n \t\tfileMode = st.FileMode\n \t}\n \n-\tplistFolder := path.Dir(resolvedPath)\n+\tplistFolder := filepath.Dir(resolvedPath)\n \terr = os.MkdirAll(plistFolder, 0o755)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"error creating %s: %v\", plistFolder, err)\n---\ncmd/cloudflared/tunnel/subcommand_context.go\n@@ -112,7 +112,7 @@ func (sc *subcommandContext) readTunnelCredentials(credFinder CredFinder) (conne\n \n \tvar credentials connection.Credentials\n \tif err = json.Unmarshal(body, &credentials); err != nil {\n-\t\tif strings.HasSuffix(filePath, \".pem\") {\n+\t\tif filepath.Ext(filePath) == \".pem\" {\n \t\t\treturn connection.Credentials{}, fmt.Errorf(\"The tunnel credentials file should be .json but you gave a .pem. \" +\n \t\t\t\t\"The tunnel credentials file was originally created by `cloudflared tunnel create`. \" +\n \t\t\t\t\"You may have accidentally used the filepath to cert.pem, which is generated by `cloudflared tunnel \" +\n---\ncmd/cloudflared/updater/workers_update.go\n@@ -10,9 +10,9 @@ import (\n \t\"net/url\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n-\t\"strings\"\n \t\"text/template\"\n \t\"time\"\n \n@@ -198,15 +198,15 @@ func download(url, filepath string, isCompressed bool) error {\n \n // isCompressedFile is a really simple file extension check to see if this is a macos tar and gzipped\n func isCompressedFile(urlstring string) bool {\n-\tif strings.HasSuffix(urlstring, \".tgz\") {\n+\tif path.Ext(urlstring) == \".tgz\" {\n \t\treturn true\n \t}\n \n \tu, err := url.Parse(urlstring)\n \tif err != nil {\n \t\treturn false\n \t}\n-\treturn strings.HasSuffix(u.Path, \".tgz\")\n+\treturn path.Ext(u.Path) == \".tgz\"\n }\n \n // writeBatchFile writes a batch file out to disk\n---\ncredentials/credentials_test.go\n@@ -3,7 +3,7 @@ package credentials\n import (\n \t\"io/fs\"\n \t\"os\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"testing\"\n \n \t\"github.com/stretchr/testify/require\"\n@@ -13,7 +13,7 @@ func TestCredentialsRead(t *testing.T) {\n \tfile, err := os.ReadFile(\"test-cloudflare-tunnel-cert-json.pem\")\n \trequire.NoError(t, err)\n \tdir := t.TempDir()\n-\tcertPath := path.Join(dir, originCertFile)\n+\tcertPath := filepath.Join(dir, originCertFile)\n \tos.WriteFile(certPath, file, fs.ModePerm)\n \tuser, err := Read(certPath, &nopLog)\n \trequire.NoError(t, err)\n---\ncredentials/origin_cert_test.go\n@@ -4,7 +4,7 @@ import (\n \t\"fmt\"\n \t\"io/fs\"\n \t\"os\"\n-\t\"path\"\n+\t\"path/filepath\"\n[[MASK]]\n \trequire.NoError(t, err)\n \tdir := t.TempDir()\n-\tcertPath := path.Join(dir, originCertFile)\n+\tcertPath := filepath.Join(dir, originCertFile)\n \t_ = os.WriteFile(certPath, file, fs.ModePerm)\n \tpath, err := FindOriginCert(certPath, &nopLog)\n \trequire.NoError(t, err)\n@@ -72,7 +72,7 @@ func TestFindOriginCert_Valid(t *testing.T) {\n \n func TestFindOriginCert_Missing(t *testing.T) {\n \tdir := t.TempDir()\n-\tcertPath := path.Join(dir, originCertFile)\n+\tcertPath := filepath.Join(dir, originCertFile)\n \t_, err := FindOriginCert(certPath, &nopLog)\n \trequire.Error(t, err)\n }\n---\nlogger/create.go\n@@ -4,7 +4,6 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n-\t\"path\"\n \t\"path/filepath\"\n \t\"sync\"\n \t\"time\"\n@@ -249,7 +248,7 @@ func createRollingLogger(config RollingConfig) (io.Writer, error) {\n \t\t}\n \n \t\trotatingFileInit.writer = &lumberjack.Logger{\n-\t\t\tFilename:   path.Join(config.Dirname, config.Filename),\n+\t\t\tFilename:   filepath.Join(config.Dirname, config.Filename),\n \t\t\tMaxBackups: config.maxBackups,\n \t\t\tMaxSize:    config.maxSize,\n \t\t\tMaxAge:     config.maxAge,\n---\n\n"}], "ideal": "cmd/cloudflared/service_template.go\n@@ -7,7 +7,7 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"os/exec\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"text/template\"\n \n \thomedir \"github.com/mitchellh/go-homedir\"\n@@ -57,7 +57,7 @@ func (st *ServiceTemplate) Generate(args *ServiceTemplateArgs) error {\n \t\tfileMode = st.FileMode\n \t}\n \n-\tplistFolder := path.Dir(resolvedPath)\n+\tplistFolder := filepath.Dir(resolvedPath)\n \terr = os.MkdirAll(plistFolder, 0o755)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"error creating %s: %v\", plistFolder, err)\n---\ncmd/cloudflared/tunnel/subcommand_context.go\n@@ -112,7 +112,7 @@ func (sc *subcommandContext) readTunnelCredentials(credFinder CredFinder) (conne\n \n \tvar credentials connection.Credentials\n \tif err = json.Unmarshal(body, &credentials); err != nil {\n-\t\tif strings.HasSuffix(filePath, \".pem\") {\n+\t\tif filepath.Ext(filePath) == \".pem\" {\n \t\t\treturn connection.Credentials{}, fmt.Errorf(\"The tunnel credentials file should be .json but you gave a .pem. \" +\n \t\t\t\t\"The tunnel credentials file was originally created by `cloudflared tunnel create`. \" +\n \t\t\t\t\"You may have accidentally used the filepath to cert.pem, which is generated by `cloudflared tunnel \" +\n---\ncmd/cloudflared/updater/workers_update.go\n@@ -10,9 +10,9 @@ import (\n \t\"net/url\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n-\t\"strings\"\n \t\"text/template\"\n \t\"time\"\n \n@@ -198,15 +198,15 @@ func download(url, filepath string, isCompressed bool) error {\n \n // isCompressedFile is a really simple file extension check to see if this is a macos tar and gzipped\n func isCompressedFile(urlstring string) bool {\n-\tif strings.HasSuffix(urlstring, \".tgz\") {\n+\tif path.Ext(urlstring) == \".tgz\" {\n \t\treturn true\n \t}\n \n \tu, err := url.Parse(urlstring)\n \tif err != nil {\n \t\treturn false\n \t}\n-\treturn strings.HasSuffix(u.Path, \".tgz\")\n+\treturn path.Ext(u.Path) == \".tgz\"\n }\n \n // writeBatchFile writes a batch file out to disk\n---\ncredentials/credentials_test.go\n@@ -3,7 +3,7 @@ package credentials\n import (\n \t\"io/fs\"\n \t\"os\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"testing\"\n \n \t\"github.com/stretchr/testify/require\"\n@@ -13,7 +13,7 @@ func TestCredentialsRead(t *testing.T) {\n \tfile, err := os.ReadFile(\"test-cloudflare-tunnel-cert-json.pem\")\n \trequire.NoError(t, err)\n \tdir := t.TempDir()\n-\tcertPath := path.Join(dir, originCertFile)\n+\tcertPath := filepath.Join(dir, originCertFile)\n \tos.WriteFile(certPath, file, fs.ModePerm)\n \tuser, err := Read(certPath, &nopLog)\n \trequire.NoError(t, err)\n---\ncredentials/origin_cert_test.go\n@@ -4,7 +4,7 @@ import (\n \t\"fmt\"\n \t\"io/fs\"\n \t\"os\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"testing\"\n \n \t\"github.com/rs/zerolog\"\n@@ -63,7 +63,7 @@ func TestFindOriginCert_Valid(t *testing.T) {\n \tfile, err := os.ReadFile(\"test-cloudflare-tunnel-cert-json.pem\")\n \trequire.NoError(t, err)\n \tdir := t.TempDir()\n-\tcertPath := path.Join(dir, originCertFile)\n+\tcertPath := filepath.Join(dir, originCertFile)\n \t_ = os.WriteFile(certPath, file, fs.ModePerm)\n \tpath, err := FindOriginCert(certPath, &nopLog)\n \trequire.NoError(t, err)\n@@ -72,7 +72,7 @@ func TestFindOriginCert_Valid(t *testing.T) {\n \n func TestFindOriginCert_Missing(t *testing.T) {\n \tdir := t.TempDir()\n-\tcertPath := path.Join(dir, originCertFile)\n+\tcertPath := filepath.Join(dir, originCertFile)\n \t_, err := FindOriginCert(certPath, &nopLog)\n \trequire.Error(t, err)\n }\n---\nlogger/create.go\n@@ -4,7 +4,6 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n-\t\"path\"\n \t\"path/filepath\"\n \t\"sync\"\n \t\"time\"\n@@ -249,7 +248,7 @@ func createRollingLogger(config RollingConfig) (io.Writer, error) {\n \t\t}\n \n \t\trotatingFileInit.writer = &lumberjack.Logger{\n-\t\t\tFilename:   path.Join(config.Dirname, config.Filename),\n+\t\t\tFilename:   filepath.Join(config.Dirname, config.Filename),\n \t\t\tMaxBackups: config.maxBackups,\n \t\t\tMaxSize:    config.maxSize,\n \t\t\tMaxAge:     config.maxAge,\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Fix FreeBSD Compile Problems\n\nDescription: Since a new network diagnostic was introduced at the end of November 2024, it has not been possible to build `cloudflared` for FreeBSD.\r\n\r\nThe changes included here correct this oversight while also including a FreeBSD-centric change from https://github.com/cloudflare/cloudflared/pull/1291, correcting an issue in its proposed change (forgetting to import \"github.com/cloudflare/cloudflared/cmd/cloudflared/cliutil\").\r\n\r\nThis likely fixes other *bsd flavors, but testing was only carried out on FreeBSD 14.1, amd64.\r\nA nearly final build is available for testing, attached to the last commit that still included the workflow definition. \r\n\r\nhttps://github.com/kjake/cloudflared/actions/runs/12876426294\n\nCode Diff:\ncmd/cloudflared/generic_service.go\n@@ -3,11 +3,38 @@\n package main\n \n import (\n+\t\"fmt\"\n \t\"os\"\n \n \tcli \"github.com/urfave/cli/v2\"\n+\n+\t\"github.com/cloudflare/cloudflared/cmd/cloudflared/cliutil\"\n )\n \n func runApp(app *cli.App, graceShutdownC chan struct{}) {\n+\tapp.Commands = append(app.Commands, &cli.Command{\n+\t\tName:  \"service\",\n+\t\tUsage: \"Manages the cloudflared system service (not supported on this operating system)\",\n+\t\tSubcommands: []*cli.Command{\n+\t\t\t{\n+\t\t\t\tName:   \"install\",\n+\t\t\t\tUsage:  \"Install cloudflared as a system service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(installGenericService),\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:   \"uninstall\",\n+\t\t\t\tUsage:  \"Uninstall the cloudflared service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(uninstallGenericService),\n+\t\t\t},\n+\t\t},\n+\t})\n \tapp.Run(os.Args)\n }\n+\n+func installGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service installation is not supported on this operating system\")\n+}\n+\n+func uninstallGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service uninstallation is not supported on this operating system\")\n+}\n\\ No newline at end of file\n---\ndiagnostic/network/collector_unix.go\n@@ -1,4 +1,4 @@\n-//go:build darwin || linux\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n \n package diagnostic\n \n---\ndiagnostic/network/collector_unix_test.go\n@@ -1,4 +1,4 @@\n-//go:build darwin || linux\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n \n package diagnostic_test\n \n---\ndiagnostic/system_collector_unix.go\n@@ -0,0 +1,168 @@\n+//go:build !windows && !darwin && !linux\n+\n+package diagnostic\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+type SystemCollectorImpl struct {\n+\tversion string\n+}\n+\n+func NewSystemCollectorImpl(\n+\tversion string,\n+) *SystemCollectorImpl {\n+\treturn &SystemCollectorImpl{\n+\t\tversion,\n+\t}\n+}\n+\n+func (collector *SystemCollectorImpl) Collect(ctx context.Context) (*SystemInformation, error) {\n+\tmemoryInfo, memoryInfoRaw, memoryInfoErr := collectMemoryInformation(ctx)\n+\tfdInfo, fdInfoRaw, fdInfoErr := collectFileDescriptorInformation(ctx)\n+\tdisks, disksRaw, diskErr := collectDiskVolumeInformationUnix(ctx)\n+\tosInfo, osInfoRaw, osInfoErr := collectOSInformationUnix(ctx)\n+\n+\tvar memoryMaximum, memoryCurrent, fileDescriptorMaximum, fileDescriptorCurrent uint64\n+\tvar osSystem, name, osVersion, osRelease, architecture string\n+\tgerror := SystemInformationGeneralError{}\n+\n+\tif memoryInfoErr != nil {\n+\t\tgerror.MemoryInformationError = SystemInformationError{\n+\t\t\tErr:     memoryInfoErr,\n+\t\t\tRawInfo: memoryInfoRaw,\n+\t\t}\n+\t} else {\n+\t\tmemoryMaximum = memoryInfo.MemoryMaximum\n+\t\tmemoryCurrent = memoryInfo.MemoryCurrent\n+\t}\n+\n+\tif fdInfoErr != nil {\n+\t\tgerror.FileDescriptorsInformationError = SystemInformationError{\n+\t\t\tErr:     fdInfoErr,\n+\t\t\tRawInfo: fdInfoRaw,\n+\t\t}\n+\t} else {\n+\t\tfileDescriptorMaximum = fdInfo.FileDescriptorMaximum\n+\t\tfileDescriptorCurrent = fdInfo.FileDescriptorCurrent\n+\t}\n+\n+\tif diskErr != nil {\n+\t\tgerror.DiskVolumeInformationError = SystemInformationError{\n+\t\t\tErr:     diskErr,\n+\t\t\tRawInfo: disksRaw,\n+\t\t}\n+\t}\n+\n+\tif osInfoErr != nil {\n+\t\tgerror.OperatingSystemInformationError = SystemInformationError{\n+\t\t\tErr:     osInfoErr,\n+\t\t\tRawInfo: osInfoRaw,\n+\t\t}\n+\t} else {\n+\t\tosSystem = osInfo.OsSystem\n+\t\tname = osInfo.Name\n+\t\tosVersion = osInfo.OsVersion\n+\t\tosRelease = osInfo.OsRelease\n+\t\tarchitecture = osInfo.Architecture\n+\t}\n+\n+\tcloudflaredVersion := collector.version\n+\tinfo := NewSystemInformation(\n+\t\tmemoryMaximum,\n+\t\tmemoryCurrent,\n+\t\tfileDescriptorMaximum,\n+\t\tfileDescriptorCurrent,\n+\t\tosSystem,\n+\t\tname,\n+\t\tosVersion,\n+\t\tosRelease,\n+\t\tarchitecture,\n+\t\tcloudflaredVersion,\n+\t\truntime.Version(),\n+\t\truntime.GOARCH,\n+\t\tdisks,\n+\t)\n+\n+\treturn info, gerror\n+}\n+\n+func collectMemoryInformation(ctx context.Context) (*MemoryInformation, string, error) {\n+\t// FreeBSD uses `sysctl` to retrieve memory information.\n+\tconst (\n+\t\tmemTotalKey     = \"hw.physmem\"\n+\t\tmemAvailableKey = \"vm.stats.vm.v_free_count\"\n+\t)\n+\n+\tcommand := exec.CommandContext(ctx, \"sysctl\", \"-n\", memTotalKey)\n+\ttotalOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\tcommand = exec.CommandContext(ctx, \"sysctl\", \"-n\", memAvailableKey)\n+\tavailableOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\ttotal, err := strconv.ParseUint(strings.TrimSpace(string(totalOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(totalOutput), fmt.Errorf(\"error parsing memory total: %w\", err)\n+\t}\n+\n+\tavailable, err := strconv.ParseUint(strings.TrimSpace(string(availableOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(availableOutput), fmt.Errorf(\"error parsing memory available: %w\", err)\n+\t}\n+\n+\tmemoryInfo := &MemoryInformation{\n[[MASK]]\n+}\n+\n+func collectFileDescriptorInformation(ctx context.Context) (*FileDescriptorInformation, string, error) {\n+\t// FreeBSD uses `sysctl` for file descriptor limits.\n+\tconst (\n+\t\tfdMaxKey = \"kern.maxfiles\"\n+\t\tfdCurrentKey = \"kern.openfiles\"\n+\t)\n+\n+\tcommand := exec.CommandContext(ctx, \"sysctl\", \"-n\", fdMaxKey)\n+\tmaxOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\tcommand = exec.CommandContext(ctx, \"sysctl\", \"-n\", fdCurrentKey)\n+\tcurrentOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\tmax, err := strconv.ParseUint(strings.TrimSpace(string(maxOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(maxOutput), fmt.Errorf(\"error parsing max file descriptors: %w\", err)\n+\t}\n+\n+\tcurrent, err := strconv.ParseUint(strings.TrimSpace(string(currentOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(currentOutput), fmt.Errorf(\"error parsing current file descriptors: %w\", err)\n+\t}\n+\n+\tfdInfo := &FileDescriptorInformation{\n+\t\tFileDescriptorMaximum: max,\n+\t\tFileDescriptorCurrent: current,\n+\t}\n+\n+\treturn fdInfo, fmt.Sprintf(\"Max: %s, Current: %s\", maxOutput, currentOutput), nil\n+}\n---\ningress/icmp_posix.go\n@@ -1,5 +1,4 @@\n-//go:build darwin || linux\n-\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n package ingress\n \n // This file extracts logic shared by Linux and Darwin implementation if ICMPProxy.\n---\ningress/icmp_posix_test.go\n@@ -1,4 +1,4 @@\n-//go:build darwin || linux\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n \n package ingress\n \n---\n\n"}], "ideal": "cmd/cloudflared/generic_service.go\n@@ -3,11 +3,38 @@\n package main\n \n import (\n+\t\"fmt\"\n \t\"os\"\n \n \tcli \"github.com/urfave/cli/v2\"\n+\n+\t\"github.com/cloudflare/cloudflared/cmd/cloudflared/cliutil\"\n )\n \n func runApp(app *cli.App, graceShutdownC chan struct{}) {\n+\tapp.Commands = append(app.Commands, &cli.Command{\n+\t\tName:  \"service\",\n+\t\tUsage: \"Manages the cloudflared system service (not supported on this operating system)\",\n+\t\tSubcommands: []*cli.Command{\n+\t\t\t{\n+\t\t\t\tName:   \"install\",\n+\t\t\t\tUsage:  \"Install cloudflared as a system service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(installGenericService),\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:   \"uninstall\",\n+\t\t\t\tUsage:  \"Uninstall the cloudflared service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(uninstallGenericService),\n+\t\t\t},\n+\t\t},\n+\t})\n \tapp.Run(os.Args)\n }\n+\n+func installGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service installation is not supported on this operating system\")\n+}\n+\n+func uninstallGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service uninstallation is not supported on this operating system\")\n+}\n\\ No newline at end of file\n---\ndiagnostic/network/collector_unix.go\n@@ -1,4 +1,4 @@\n-//go:build darwin || linux\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n \n package diagnostic\n \n---\ndiagnostic/network/collector_unix_test.go\n@@ -1,4 +1,4 @@\n-//go:build darwin || linux\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n \n package diagnostic_test\n \n---\ndiagnostic/system_collector_unix.go\n@@ -0,0 +1,168 @@\n+//go:build !windows && !darwin && !linux\n+\n+package diagnostic\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+type SystemCollectorImpl struct {\n+\tversion string\n+}\n+\n+func NewSystemCollectorImpl(\n+\tversion string,\n+) *SystemCollectorImpl {\n+\treturn &SystemCollectorImpl{\n+\t\tversion,\n+\t}\n+}\n+\n+func (collector *SystemCollectorImpl) Collect(ctx context.Context) (*SystemInformation, error) {\n+\tmemoryInfo, memoryInfoRaw, memoryInfoErr := collectMemoryInformation(ctx)\n+\tfdInfo, fdInfoRaw, fdInfoErr := collectFileDescriptorInformation(ctx)\n+\tdisks, disksRaw, diskErr := collectDiskVolumeInformationUnix(ctx)\n+\tosInfo, osInfoRaw, osInfoErr := collectOSInformationUnix(ctx)\n+\n+\tvar memoryMaximum, memoryCurrent, fileDescriptorMaximum, fileDescriptorCurrent uint64\n+\tvar osSystem, name, osVersion, osRelease, architecture string\n+\tgerror := SystemInformationGeneralError{}\n+\n+\tif memoryInfoErr != nil {\n+\t\tgerror.MemoryInformationError = SystemInformationError{\n+\t\t\tErr:     memoryInfoErr,\n+\t\t\tRawInfo: memoryInfoRaw,\n+\t\t}\n+\t} else {\n+\t\tmemoryMaximum = memoryInfo.MemoryMaximum\n+\t\tmemoryCurrent = memoryInfo.MemoryCurrent\n+\t}\n+\n+\tif fdInfoErr != nil {\n+\t\tgerror.FileDescriptorsInformationError = SystemInformationError{\n+\t\t\tErr:     fdInfoErr,\n+\t\t\tRawInfo: fdInfoRaw,\n+\t\t}\n+\t} else {\n+\t\tfileDescriptorMaximum = fdInfo.FileDescriptorMaximum\n+\t\tfileDescriptorCurrent = fdInfo.FileDescriptorCurrent\n+\t}\n+\n+\tif diskErr != nil {\n+\t\tgerror.DiskVolumeInformationError = SystemInformationError{\n+\t\t\tErr:     diskErr,\n+\t\t\tRawInfo: disksRaw,\n+\t\t}\n+\t}\n+\n+\tif osInfoErr != nil {\n+\t\tgerror.OperatingSystemInformationError = SystemInformationError{\n+\t\t\tErr:     osInfoErr,\n+\t\t\tRawInfo: osInfoRaw,\n+\t\t}\n+\t} else {\n+\t\tosSystem = osInfo.OsSystem\n+\t\tname = osInfo.Name\n+\t\tosVersion = osInfo.OsVersion\n+\t\tosRelease = osInfo.OsRelease\n+\t\tarchitecture = osInfo.Architecture\n+\t}\n+\n+\tcloudflaredVersion := collector.version\n+\tinfo := NewSystemInformation(\n+\t\tmemoryMaximum,\n+\t\tmemoryCurrent,\n+\t\tfileDescriptorMaximum,\n+\t\tfileDescriptorCurrent,\n+\t\tosSystem,\n+\t\tname,\n+\t\tosVersion,\n+\t\tosRelease,\n+\t\tarchitecture,\n+\t\tcloudflaredVersion,\n+\t\truntime.Version(),\n+\t\truntime.GOARCH,\n+\t\tdisks,\n+\t)\n+\n+\treturn info, gerror\n+}\n+\n+func collectMemoryInformation(ctx context.Context) (*MemoryInformation, string, error) {\n+\t// FreeBSD uses `sysctl` to retrieve memory information.\n+\tconst (\n+\t\tmemTotalKey     = \"hw.physmem\"\n+\t\tmemAvailableKey = \"vm.stats.vm.v_free_count\"\n+\t)\n+\n+\tcommand := exec.CommandContext(ctx, \"sysctl\", \"-n\", memTotalKey)\n+\ttotalOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\tcommand = exec.CommandContext(ctx, \"sysctl\", \"-n\", memAvailableKey)\n+\tavailableOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\ttotal, err := strconv.ParseUint(strings.TrimSpace(string(totalOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(totalOutput), fmt.Errorf(\"error parsing memory total: %w\", err)\n+\t}\n+\n+\tavailable, err := strconv.ParseUint(strings.TrimSpace(string(availableOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(availableOutput), fmt.Errorf(\"error parsing memory available: %w\", err)\n+\t}\n+\n+\tmemoryInfo := &MemoryInformation{\n+\t\tMemoryMaximum: total,\n+\t\tMemoryCurrent: available * 4096, // FreeBSD reports pages; multiply by page size (4K).\n+\t}\n+\n+\treturn memoryInfo, fmt.Sprintf(\"Total: %s, Available: %s\", totalOutput, availableOutput), nil\n+}\n+\n+func collectFileDescriptorInformation(ctx context.Context) (*FileDescriptorInformation, string, error) {\n+\t// FreeBSD uses `sysctl` for file descriptor limits.\n+\tconst (\n+\t\tfdMaxKey = \"kern.maxfiles\"\n+\t\tfdCurrentKey = \"kern.openfiles\"\n+\t)\n+\n+\tcommand := exec.CommandContext(ctx, \"sysctl\", \"-n\", fdMaxKey)\n+\tmaxOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\tcommand = exec.CommandContext(ctx, \"sysctl\", \"-n\", fdCurrentKey)\n+\tcurrentOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\tmax, err := strconv.ParseUint(strings.TrimSpace(string(maxOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(maxOutput), fmt.Errorf(\"error parsing max file descriptors: %w\", err)\n+\t}\n+\n+\tcurrent, err := strconv.ParseUint(strings.TrimSpace(string(currentOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(currentOutput), fmt.Errorf(\"error parsing current file descriptors: %w\", err)\n+\t}\n+\n+\tfdInfo := &FileDescriptorInformation{\n+\t\tFileDescriptorMaximum: max,\n+\t\tFileDescriptorCurrent: current,\n+\t}\n+\n+\treturn fdInfo, fmt.Sprintf(\"Max: %s, Current: %s\", maxOutput, currentOutput), nil\n+}\n---\ningress/icmp_posix.go\n@@ -1,5 +1,4 @@\n-//go:build darwin || linux\n-\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n package ingress\n \n // This file extracts logic shared by Linux and Darwin implementation if ICMPProxy.\n---\ningress/icmp_posix_test.go\n@@ -1,4 +1,4 @@\n-//go:build darwin || linux\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n \n package ingress\n \n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Improve `http_status` validation\n\nDescription: Currently, the validation of the http status input is a numeric range, so an invalid status code can be entered. Change to check if the http status code exists or not.\r\nrelated to https://github.com/cloudflare/cloudflared/issues/1389 .\r\n\r\n![2024-12-24-11 09 30@2x](https://github.com/user-attachments/assets/38cbe955-0aae-4abb-a53b-bc0807f3b502)\r\n\r\nEven if this validation were added, it is still possible to set it from the Web UI( https://one.dash.cloudflare.com/ ), so that needs to be modified as well.\r\n\r\nThose that exist as http status but are not normally used can be registered, but I think this should be handled by the web UI. \r\n(Personally, I don't see a problem with using the joke status code because it's funny.)\r\n![image(1)](https://github.com/user-attachments/assets/5f0551fd-a6a9-45f8-bb4f-42d2506a83e4)\r\n![2024-12-24-11 03 22](https://github.com/user-attachments/assets/9a0c6885-4089-4c64-bb5d-bd36c64da4b0)\r\n\n\nCode Diff:\ningress/ingress.go\n@@ -3,6 +3,7 @@ package ingress\n import (\n \t\"fmt\"\n \t\"net\"\n+\t\"net/http\"\n \t\"net/url\"\n \t\"regexp\"\n[[MASK]]\n-\t\t\tif statusCode < 100 || statusCode > 999 {\n+\t\t\tif http.StatusText(statusCode) == \"\" {\n \t\t\t\treturn Ingress{}, fmt.Errorf(\"invalid HTTP status code: %d\", statusCode)\n \t\t\t}\n \t\t\tsrv := newStatusCode(statusCode)\n---\ningress/ingress_test.go\n@@ -247,10 +247,18 @@ ingress:\n \t\t\twantErr: true,\n \t\t},\n \t\t{\n-\t\t\tname: \"Invalid HTTP status code\",\n+\t\t\tname: \"Invalid HTTP status code(8080)\",\n \t\t\targs: args{rawYAML: `\n ingress:\n  - service: http_status:8080\n+`},\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Invalid HTTP status code(666)\",\n+\t\t\targs: args{rawYAML: `\n+ingress:\n+ - service: http_status:666\n `},\n \t\t\twantErr: true,\n \t\t},\n---\n\n"}], "ideal": "ingress/ingress.go\n@@ -3,6 +3,7 @@ package ingress\n import (\n \t\"fmt\"\n \t\"net\"\n+\t\"net/http\"\n \t\"net/url\"\n \t\"regexp\"\n \t\"strconv\"\n@@ -260,7 +261,7 @@ func validateIngress(ingress []config.UnvalidatedIngressRule, defaults OriginReq\n \t\t\tif err != nil {\n \t\t\t\treturn Ingress{}, errors.Wrap(err, \"invalid HTTP status code\")\n \t\t\t}\n-\t\t\tif statusCode < 100 || statusCode > 999 {\n+\t\t\tif http.StatusText(statusCode) == \"\" {\n \t\t\t\treturn Ingress{}, fmt.Errorf(\"invalid HTTP status code: %d\", statusCode)\n \t\t\t}\n \t\t\tsrv := newStatusCode(statusCode)\n---\ningress/ingress_test.go\n@@ -247,10 +247,18 @@ ingress:\n \t\t\twantErr: true,\n \t\t},\n \t\t{\n-\t\t\tname: \"Invalid HTTP status code\",\n+\t\t\tname: \"Invalid HTTP status code(8080)\",\n \t\t\targs: args{rawYAML: `\n ingress:\n  - service: http_status:8080\n+`},\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Invalid HTTP status code(666)\",\n+\t\t\targs: args{rawYAML: `\n+ingress:\n+ - service: http_status:666\n `},\n \t\t\twantErr: true,\n \t\t},\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Introduce a custom header which servers can return to request cloudflared to not buffer the response.\n\nDescription: cloudflared currently only supports bypassing its response buffering through the Content-Type. This PR adds support for a custom header `cf-cloudflared-flush-response` which when present and having a value of `yes`, disables response buffering as well.\n\nCode Diff:\nconnection/connection.go\n@@ -29,6 +29,8 @@ const (\n \tcontentTypeHeader = \"content-type\"\n \tsseContentType    = \"text/event-stream\"\n \tgrpcContentType   = \"application/grpc\"\n+\n+\tFlushResponseHeader  = \"cf-cloudflared-flush-response\"\n )\n \n var (\n@@ -270,6 +272,10 @@ type ConnectedFuse interface {\n // Helper method to let the caller know what content-types should require a flush on every\n // write to a ResponseWriter.\n func shouldFlush(headers http.Header) bool {\n+\tif headers.Get(FlushResponseHeader) == \"yes\" {\n+\t\treturn true\n+\t}\n[[MASK]]\n\n"}], "ideal": "connection/connection.go\n@@ -29,6 +29,8 @@ const (\n \tcontentTypeHeader = \"content-type\"\n \tsseContentType    = \"text/event-stream\"\n \tgrpcContentType   = \"application/grpc\"\n+\n+\tFlushResponseHeader  = \"cf-cloudflared-flush-response\"\n )\n \n var (\n@@ -270,6 +272,10 @@ type ConnectedFuse interface {\n // Helper method to let the caller know what content-types should require a flush on every\n // write to a ResponseWriter.\n func shouldFlush(headers http.Header) bool {\n+\tif headers.Get(FlushResponseHeader) == \"yes\" {\n+\t\treturn true\n+\t}\n+\n \tif contentType := headers.Get(contentTypeHeader); contentType != \"\" {\n \t\tcontentType = strings.ToLower(contentType)\n \t\tfor _, c := range flushableContentTypes {\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: add: new go-fuzz targets\n\nDescription: Some new go-fuzz targets.\r\n\r\nThese are the same test targets that I used for my HackerOne report.\n\nCode Diff:\nMakefile\n@@ -165,6 +165,18 @@ cover:\n \t# Generate the HTML report that can be viewed from the browser in CI.\n \t$Q go tool cover -html \".cover/c.out\" -o .cover/all.html\n \n+.PHONY: fuzz\n+fuzz:\n+\t@go test -fuzz=FuzzIPDecoder -fuzztime=600s ./packet\n+\t@go test -fuzz=FuzzICMPDecoder -fuzztime=600s ./packet\n+\t@go test -fuzz=FuzzSessionWrite -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzSessionServe -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzRegistrationDatagram -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzPayloadDatagram -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzRegistrationResponseDatagram -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzNewIdentity -fuzztime=600s ./tracing\n+\t@go test -fuzz=FuzzNewAccessValidator -fuzztime=600s ./validation\n+\n .PHONY: install-go\n install-go:\n \trm -rf ${CF_GO_PATH}\n---\npacket/decoder_test.go\n@@ -254,3 +254,18 @@ func (u *UDP) EncodeLayers() ([]gopacket.SerializableLayer, error) {\n \tudpLayer.SetNetworkLayerForChecksum(ipLayers[0].(gopacket.NetworkLayer))\n \treturn append(ipLayers, &udpLayer), nil\n }\n+\n+func FuzzIPDecoder(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tipDecoder := NewIPDecoder()\n+\t\tipDecoder.Decode(RawPacket{Data: data})\n+\n+\t})\n+}\n+\n+func FuzzICMPDecoder(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\ticmpDecoder := NewICMPDecoder()\n+\t\ticmpDecoder.Decode(RawPacket{Data: data})\n+\t})\n+}\n---\nquic/v3/datagram_test.go\n@@ -350,3 +350,30 @@ func compareRegistrationDatagrams(t *testing.T, l *v3.UDPSessionRegistrationData\n \t\tl.IdleDurationHint == r.IdleDurationHint &&\n \t\tl.Traced == r.Traced\n }\n+\n+func FuzzRegistrationDatagram(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tunmarshaled := v3.UDPSessionRegistrationDatagram{}\n+\t\terr := unmarshaled.UnmarshalBinary(data)\n+\t\tif err == nil {\n+\t\t\t_, _ = unmarshaled.MarshalBinary()\n+\t\t}\n+\t})\n+}\n+\n+func FuzzPayloadDatagram(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tunmarshaled := v3.UDPSessionPayloadDatagram{}\n[[MASK]]\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tunmarshaled := v3.UDPSessionRegistrationResponseDatagram{}\n+\t\terr := unmarshaled.UnmarshalBinary(data)\n+\t\tif err == nil {\n+\t\t\t_, _ = unmarshaled.MarshalBinary()\n+\t\t}\n+\t})\n+}\n---\ntracing/tracing_test.go\n@@ -72,3 +72,9 @@ func TestAddingSpansWithNilMap(t *testing.T) {\n \t// a panic shouldn't occur\n \ttr.AddSpans(nil)\n }\n+\n+func FuzzNewIdentity(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, trace string) {\n+\t\t_, _ = NewIdentity(trace)\n+\t})\n+}\n---\nvalidation/validation_test.go\n@@ -197,3 +197,10 @@ func createSecureMockServerAndClient(handler http.Handler) (*httptest.Server, *h\n \n \treturn server, client, nil\n }\n+\n+func FuzzNewAccessValidator(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, domain string, issuer string, applicationAUD string) {\n+\t\tctx := context.Background()\n+\t\t_, _ = NewAccessValidator(ctx, domain, issuer, applicationAUD)\n+\t})\n+}\n---\n\n"}], "ideal": "Makefile\n@@ -165,6 +165,18 @@ cover:\n \t# Generate the HTML report that can be viewed from the browser in CI.\n \t$Q go tool cover -html \".cover/c.out\" -o .cover/all.html\n \n+.PHONY: fuzz\n+fuzz:\n+\t@go test -fuzz=FuzzIPDecoder -fuzztime=600s ./packet\n+\t@go test -fuzz=FuzzICMPDecoder -fuzztime=600s ./packet\n+\t@go test -fuzz=FuzzSessionWrite -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzSessionServe -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzRegistrationDatagram -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzPayloadDatagram -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzRegistrationResponseDatagram -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzNewIdentity -fuzztime=600s ./tracing\n+\t@go test -fuzz=FuzzNewAccessValidator -fuzztime=600s ./validation\n+\n .PHONY: install-go\n install-go:\n \trm -rf ${CF_GO_PATH}\n---\npacket/decoder_test.go\n@@ -254,3 +254,18 @@ func (u *UDP) EncodeLayers() ([]gopacket.SerializableLayer, error) {\n \tudpLayer.SetNetworkLayerForChecksum(ipLayers[0].(gopacket.NetworkLayer))\n \treturn append(ipLayers, &udpLayer), nil\n }\n+\n+func FuzzIPDecoder(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tipDecoder := NewIPDecoder()\n+\t\tipDecoder.Decode(RawPacket{Data: data})\n+\n+\t})\n+}\n+\n+func FuzzICMPDecoder(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\ticmpDecoder := NewICMPDecoder()\n+\t\ticmpDecoder.Decode(RawPacket{Data: data})\n+\t})\n+}\n---\nquic/v3/datagram_test.go\n@@ -350,3 +350,30 @@ func compareRegistrationDatagrams(t *testing.T, l *v3.UDPSessionRegistrationData\n \t\tl.IdleDurationHint == r.IdleDurationHint &&\n \t\tl.Traced == r.Traced\n }\n+\n+func FuzzRegistrationDatagram(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tunmarshaled := v3.UDPSessionRegistrationDatagram{}\n+\t\terr := unmarshaled.UnmarshalBinary(data)\n+\t\tif err == nil {\n+\t\t\t_, _ = unmarshaled.MarshalBinary()\n+\t\t}\n+\t})\n+}\n+\n+func FuzzPayloadDatagram(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tunmarshaled := v3.UDPSessionPayloadDatagram{}\n+\t\t_ = unmarshaled.UnmarshalBinary(data)\n+\t})\n+}\n+\n+func FuzzRegistrationResponseDatagram(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tunmarshaled := v3.UDPSessionRegistrationResponseDatagram{}\n+\t\terr := unmarshaled.UnmarshalBinary(data)\n+\t\tif err == nil {\n+\t\t\t_, _ = unmarshaled.MarshalBinary()\n+\t\t}\n+\t})\n+}\n---\ntracing/tracing_test.go\n@@ -72,3 +72,9 @@ func TestAddingSpansWithNilMap(t *testing.T) {\n \t// a panic shouldn't occur\n \ttr.AddSpans(nil)\n }\n+\n+func FuzzNewIdentity(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, trace string) {\n+\t\t_, _ = NewIdentity(trace)\n+\t})\n+}\n---\nvalidation/validation_test.go\n@@ -197,3 +197,10 @@ func createSecureMockServerAndClient(handler http.Handler) (*httptest.Server, *h\n \n \treturn server, client, nil\n }\n+\n+func FuzzNewAccessValidator(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, domain string, issuer string, applicationAUD string) {\n+\t\tctx := context.Background()\n+\t\t_, _ = NewAccessValidator(ctx, domain, issuer, applicationAUD)\n+\t})\n+}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Restore ability to relay POST requests with empty bodies\n\nDescription: It appears that the commit in the latest release (https://github.com/cloudflare/cloudflared/commit/e2064c820f32802f58baa027903043fe0ed052e0) was designed to check for specific request methods: `\"GET\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"PROPFIND\", \"SEARCH\"`. If the request matched one of these methods, the request body would be set to empty. If it didn\u2019t match, the body wouldn\u2019t be modified. However, it seems the commit didn\u2019t account for requests like POST, which can also have an empty body. Since POST wasn\u2019t included in the predefined list, the request body wasn\u2019t being set to empty when necessary.\r\n\r\nCloses: https://github.com/cloudflare/cloudflared/issues/1337\n\nCode Diff:\nconnection/quic.go\n@@ -550,15 +550,6 @@ func isTransferEncodingChunked(req *http.Request) bool {\n \treturn strings.Contains(strings.ToLower(transferEncodingVal), \"chunked\")\n }\n \n-// Borrowed from https://github.com/golang/go/blob/go1.22.6/src/net/http/request.go#L1541\n-func requestMethodUsuallyLacksBody(req *http.Request) bool {\n-\tswitch strings.ToUpper(req.Method) {\n-\tcase \"GET\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"PROPFIND\", \"SEARCH\":\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n func shouldSetRequestBodyToEmpty(connectRequest *pogs.ConnectRequest, metadata map[string]string, req *http.Request) bool {\n \tswitch metadata[HTTPRequestBodyHintKey] {\n \tcase RequestBodyHintEmpty.String():\n@@ -576,7 +567,7 @@ func shouldSetRequestBodyToEmpty(connectRequest *pogs.ConnectRequest, metadata m\n \t//   * there is no transfer-encoding=chunked already set.\n \t// So, if transfer cannot be chunked and content length is 0, we dont set a request body.\n \t// Reference: https://github.com/golang/go/blob/go1.22.2/src/net/http/transfer.go#L192-L206\n-\treturn !isWebsocket && requestMethodUsuallyLacksBody(req) && !isTransferEncodingChunked(req) && req.ContentLength == 0\n+\treturn !isWebsocket && !isTransferEncodingChunked(req) && req.ContentLength == 0\n }\n \n // A helper struct that guarantees a call to close only affects read side, but not write side.\n---\nconnection/quic_test.go\n@@ -566,43 +566,6 @@ func TestBuildHTTPRequest(t *testing.T) {\n \t\t\t},\n \t\t\tbody: io.NopCloser(&bytes.Buffer{}),\n \t\t},\n-\t\t{\n-\t\t\tname: \"if the http method usually has body, don't set body to empty\",\n[[MASK]]\n-\t\t\t\t\t\tVal: \"Misc\",\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tKey: \"HttpHost\",\n-\t\t\t\t\t\tVal: \"cf.host\",\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tKey: \"HttpMethod\",\n-\t\t\t\t\t\tVal: \"post\",\n-\t\t\t\t\t},\n-\t\t\t\t},\n-\t\t\t},\n-\t\t\treq: &http.Request{\n-\t\t\t\tMethod: \"post\",\n-\t\t\t\tURL: &url.URL{\n-\t\t\t\t\tScheme: \"http\",\n-\t\t\t\t\tHost:   \"test.com\",\n-\t\t\t\t},\n-\t\t\t\tProto:      \"HTTP/1.1\",\n-\t\t\t\tProtoMajor: 1,\n-\t\t\t\tProtoMinor: 1,\n-\t\t\t\tHeader: http.Header{\n-\t\t\t\t\t\"Another-Header\": []string{\"Misc\"},\n-\t\t\t\t},\n-\t\t\t\tContentLength: 0,\n-\t\t\t\tHost:          \"cf.host\",\n-\t\t\t\tBody:          io.NopCloser(&bytes.Buffer{}),\n-\t\t\t},\n-\t\t\tbody: io.NopCloser(&bytes.Buffer{}),\n-\t\t},\n \t}\n \n \tlog := zerolog.Nop()\n---\n\n"}], "ideal": "connection/quic.go\n@@ -550,15 +550,6 @@ func isTransferEncodingChunked(req *http.Request) bool {\n \treturn strings.Contains(strings.ToLower(transferEncodingVal), \"chunked\")\n }\n \n-// Borrowed from https://github.com/golang/go/blob/go1.22.6/src/net/http/request.go#L1541\n-func requestMethodUsuallyLacksBody(req *http.Request) bool {\n-\tswitch strings.ToUpper(req.Method) {\n-\tcase \"GET\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"PROPFIND\", \"SEARCH\":\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n func shouldSetRequestBodyToEmpty(connectRequest *pogs.ConnectRequest, metadata map[string]string, req *http.Request) bool {\n \tswitch metadata[HTTPRequestBodyHintKey] {\n \tcase RequestBodyHintEmpty.String():\n@@ -576,7 +567,7 @@ func shouldSetRequestBodyToEmpty(connectRequest *pogs.ConnectRequest, metadata m\n \t//   * there is no transfer-encoding=chunked already set.\n \t// So, if transfer cannot be chunked and content length is 0, we dont set a request body.\n \t// Reference: https://github.com/golang/go/blob/go1.22.2/src/net/http/transfer.go#L192-L206\n-\treturn !isWebsocket && requestMethodUsuallyLacksBody(req) && !isTransferEncodingChunked(req) && req.ContentLength == 0\n+\treturn !isWebsocket && !isTransferEncodingChunked(req) && req.ContentLength == 0\n }\n \n // A helper struct that guarantees a call to close only affects read side, but not write side.\n---\nconnection/quic_test.go\n@@ -566,43 +566,6 @@ func TestBuildHTTPRequest(t *testing.T) {\n \t\t\t},\n \t\t\tbody: io.NopCloser(&bytes.Buffer{}),\n \t\t},\n-\t\t{\n-\t\t\tname: \"if the http method usually has body, don't set body to empty\",\n-\t\t\tconnectRequest: &pogs.ConnectRequest{\n-\t\t\t\tDest: \"http://test.com\",\n-\t\t\t\tMetadata: []pogs.Metadata{\n-\t\t\t\t\t{\n-\t\t\t\t\t\tKey: \"HttpHeader:Another-Header\",\n-\t\t\t\t\t\tVal: \"Misc\",\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tKey: \"HttpHost\",\n-\t\t\t\t\t\tVal: \"cf.host\",\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tKey: \"HttpMethod\",\n-\t\t\t\t\t\tVal: \"post\",\n-\t\t\t\t\t},\n-\t\t\t\t},\n-\t\t\t},\n-\t\t\treq: &http.Request{\n-\t\t\t\tMethod: \"post\",\n-\t\t\t\tURL: &url.URL{\n-\t\t\t\t\tScheme: \"http\",\n-\t\t\t\t\tHost:   \"test.com\",\n-\t\t\t\t},\n-\t\t\t\tProto:      \"HTTP/1.1\",\n-\t\t\t\tProtoMajor: 1,\n-\t\t\t\tProtoMinor: 1,\n-\t\t\t\tHeader: http.Header{\n-\t\t\t\t\t\"Another-Header\": []string{\"Misc\"},\n-\t\t\t\t},\n-\t\t\t\tContentLength: 0,\n-\t\t\t\tHost:          \"cf.host\",\n-\t\t\t\tBody:          io.NopCloser(&bytes.Buffer{}),\n-\t\t\t},\n-\t\t\tbody: io.NopCloser(&bytes.Buffer{}),\n-\t\t},\n \t}\n \n \tlog := zerolog.Nop()\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Update semgrep.yml\n\nDescription: Updating Semgrep.yml file - Semgrep is a tool that will be used to scan Cloudflare's public repos for Supply chain, code and secrets. This work is part of Application & Product Security team's initiative to onboard Semgrep onto all of Cloudflare's public repos.\r\n\r\nIn case of any questions, please reach out to \"Hrushikesh Deshpande\" on cf internal chat.\n\nCode Diff:\n[[MASK]]\n   workflow_dispatch: {}\n@@ -12,14 +11,14 @@ name: Semgrep config\n jobs:\n   semgrep:\n     name: semgrep/ci\n-    runs-on: ubuntu-20.04\n+    runs-on: ubuntu-latest\n     env:\n       SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}\n       SEMGREP_URL: https://cloudflare.semgrep.dev\n       SEMGREP_APP_URL: https://cloudflare.semgrep.dev\n       SEMGREP_VERSION_CHECK_URL: https://cloudflare.semgrep.dev/api/check-version\n     container:\n-      image: returntocorp/semgrep\n+      image: semgrep/semgrep\n     steps:\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n       - run: semgrep ci\n---\n\n"}], "ideal": ".github/workflows/semgrep.yml\n@@ -1,4 +1,3 @@\n-\n on:\n   pull_request: {}\n   workflow_dispatch: {}\n@@ -12,14 +11,14 @@ name: Semgrep config\n jobs:\n   semgrep:\n     name: semgrep/ci\n-    runs-on: ubuntu-20.04\n+    runs-on: ubuntu-latest\n     env:\n       SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}\n       SEMGREP_URL: https://cloudflare.semgrep.dev\n       SEMGREP_APP_URL: https://cloudflare.semgrep.dev\n       SEMGREP_VERSION_CHECK_URL: https://cloudflare.semgrep.dev/api/check-version\n     container:\n-      image: returntocorp/semgrep\n+      image: semgrep/semgrep\n     steps:\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n       - run: semgrep ci\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Bumped distroless/base-debian12\n\nDescription: Needed to fix bug related to glibc - see https://github.com/GoogleContainerTools/distroless/issues/1342\n\nCode Diff:\nDockerfile\n@@ -18,7 +18,7 @@ RUN .teamcity/install-cloudflare-go.sh\n RUN PATH=\"/tmp/go/bin:$PATH\" make cloudflared\n \n[[MASK]]\n \n---\nDockerfile.amd64\n@@ -14,7 +14,7 @@ RUN .teamcity/install-cloudflare-go.sh\n RUN GOOS=linux GOARCH=amd64 PATH=\"/tmp/go/bin:$PATH\" make cloudflared\n \n # use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian11:nonroot\n+FROM gcr.io/distroless/base-debian12:nonroot\n \n LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n \n---\nDockerfile.arm64\n@@ -14,7 +14,7 @@ RUN .teamcity/install-cloudflare-go.sh\n RUN GOOS=linux GOARCH=arm64 PATH=\"/tmp/go/bin:$PATH\" make cloudflared\n \n # use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian11:nonroot-arm64\n+FROM gcr.io/distroless/base-debian12:nonroot-arm64\n \n LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n \n---\n\n"}], "ideal": "Dockerfile\n@@ -18,7 +18,7 @@ RUN .teamcity/install-cloudflare-go.sh\n RUN PATH=\"/tmp/go/bin:$PATH\" make cloudflared\n \n # use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian11:nonroot\n+FROM gcr.io/distroless/base-debian12:nonroot\n \n LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n \n---\nDockerfile.amd64\n@@ -14,7 +14,7 @@ RUN .teamcity/install-cloudflare-go.sh\n RUN GOOS=linux GOARCH=amd64 PATH=\"/tmp/go/bin:$PATH\" make cloudflared\n \n # use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian11:nonroot\n+FROM gcr.io/distroless/base-debian12:nonroot\n \n LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n \n---\nDockerfile.arm64\n@@ -14,7 +14,7 @@ RUN .teamcity/install-cloudflare-go.sh\n RUN GOOS=linux GOARCH=arm64 PATH=\"/tmp/go/bin:$PATH\" make cloudflared\n \n # use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian11:nonroot-arm64\n+FROM gcr.io/distroless/base-debian12:nonroot-arm64\n \n LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n \n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Adds a new command line for tunnel run for token file\n\nDescription: Adds a new command line flag for `tunnel run` which allows a file to be read for the token. I've left the token command line argument with priority. \r\n\r\nWould resolve #645 \n\nCode Diff:\ncmd/cloudflared/tunnel/subcommands.go\n@@ -39,6 +39,7 @@ const (\n \tCredFileFlag            = \"credentials-file\"\n \tCredContentsFlag        = \"credentials-contents\"\n \tTunnelTokenFlag         = \"token\"\n+\tTunnelTokenFileFlag     = \"token-file\"\n \toverwriteDNSFlagName    = \"overwrite-dns\"\n \tnoDiagLogsFlagName      = \"no-diag-logs\"\n \tnoDiagMetricsFlagName   = \"no-diag-metrics\"\n@@ -125,9 +126,14 @@ var (\n \t})\n \ttunnelTokenFlag = altsrc.NewStringFlag(&cli.StringFlag{\n \t\tName:    TunnelTokenFlag,\n-\t\tUsage:   \"The Tunnel token. When provided along with credentials, this will take precedence.\",\n+\t\tUsage:   \"The Tunnel token. When provided along with credentials, this will take precedence. Also takes precedence over token-file\",\n \t\tEnvVars: []string{\"TUNNEL_TOKEN\"},\n \t})\n+\ttunnelTokenFileFlag = altsrc.NewStringFlag(&cli.StringFlag{\n+\t\tName:    TunnelTokenFileFlag,\n+\t\tUsage:   \"Filepath at which to read the tunnel token. When provided along with credentials, this will take precedence.\",\n+\t\tEnvVars: []string{\"TUNNEL_TOKEN_FILE\"},\n[[MASK]]\n \t\tselectProtocolFlag,\n \t\tfeaturesFlag,\n \t\ttunnelTokenFlag,\n+\t\ttunnelTokenFileFlag,\n \t\ticmpv4SrcFlag,\n \t\ticmpv6SrcFlag,\n \t}\n@@ -736,12 +743,22 @@ func runCommand(c *cli.Context) error {\n \t\t\t\"your origin will not be reachable. You should remove the `hostname` property to avoid this warning.\")\n \t}\n \n+\ttokenStr := c.String(TunnelTokenFlag)\n+\t// Check if tokenStr is blank before checking for tokenFile\n+\tif tokenStr == \"\" {\n+\t\tif tokenFile := c.String(TunnelTokenFileFlag); tokenFile != \"\" {\n+\t\t\tdata, err := os.ReadFile(tokenFile)\n+\t\t\tif err != nil {\n+\t\t\t\treturn cliutil.UsageError(\"Failed to read token file: \" + err.Error())\n+\t\t\t}\n+\t\t\ttokenStr = strings.TrimSpace(string(data))\n+\t\t}\n+\t}\n \t// Check if token is provided and if not use default tunnelID flag method\n-\tif tokenStr := c.String(TunnelTokenFlag); tokenStr != \"\" {\n+\tif tokenStr != \"\" {\n \t\tif token, err := ParseToken(tokenStr); err == nil {\n \t\t\treturn sc.runWithCredentials(token.Credentials())\n \t\t}\n-\n \t\treturn cliutil.UsageError(\"Provided Tunnel token is not valid.\")\n \t} else {\n \t\ttunnelRef := c.Args().First()\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/subcommands.go\n@@ -39,6 +39,7 @@ const (\n \tCredFileFlag            = \"credentials-file\"\n \tCredContentsFlag        = \"credentials-contents\"\n \tTunnelTokenFlag         = \"token\"\n+\tTunnelTokenFileFlag     = \"token-file\"\n \toverwriteDNSFlagName    = \"overwrite-dns\"\n \tnoDiagLogsFlagName      = \"no-diag-logs\"\n \tnoDiagMetricsFlagName   = \"no-diag-metrics\"\n@@ -125,9 +126,14 @@ var (\n \t})\n \ttunnelTokenFlag = altsrc.NewStringFlag(&cli.StringFlag{\n \t\tName:    TunnelTokenFlag,\n-\t\tUsage:   \"The Tunnel token. When provided along with credentials, this will take precedence.\",\n+\t\tUsage:   \"The Tunnel token. When provided along with credentials, this will take precedence. Also takes precedence over token-file\",\n \t\tEnvVars: []string{\"TUNNEL_TOKEN\"},\n \t})\n+\ttunnelTokenFileFlag = altsrc.NewStringFlag(&cli.StringFlag{\n+\t\tName:    TunnelTokenFileFlag,\n+\t\tUsage:   \"Filepath at which to read the tunnel token. When provided along with credentials, this will take precedence.\",\n+\t\tEnvVars: []string{\"TUNNEL_TOKEN_FILE\"},\n+\t})\n \tforceDeleteFlag = &cli.BoolFlag{\n \t\tName:    \"force\",\n \t\tAliases: []string{\"f\"},\n@@ -697,6 +703,7 @@ func buildRunCommand() *cli.Command {\n \t\tselectProtocolFlag,\n \t\tfeaturesFlag,\n \t\ttunnelTokenFlag,\n+\t\ttunnelTokenFileFlag,\n \t\ticmpv4SrcFlag,\n \t\ticmpv6SrcFlag,\n \t}\n@@ -736,12 +743,22 @@ func runCommand(c *cli.Context) error {\n \t\t\t\"your origin will not be reachable. You should remove the `hostname` property to avoid this warning.\")\n \t}\n \n+\ttokenStr := c.String(TunnelTokenFlag)\n+\t// Check if tokenStr is blank before checking for tokenFile\n+\tif tokenStr == \"\" {\n+\t\tif tokenFile := c.String(TunnelTokenFileFlag); tokenFile != \"\" {\n+\t\t\tdata, err := os.ReadFile(tokenFile)\n+\t\t\tif err != nil {\n+\t\t\t\treturn cliutil.UsageError(\"Failed to read token file: \" + err.Error())\n+\t\t\t}\n+\t\t\ttokenStr = strings.TrimSpace(string(data))\n+\t\t}\n+\t}\n \t// Check if token is provided and if not use default tunnelID flag method\n-\tif tokenStr := c.String(TunnelTokenFlag); tokenStr != \"\" {\n+\tif tokenStr != \"\" {\n \t\tif token, err := ParseToken(tokenStr); err == nil {\n \t\t\treturn sc.runWithCredentials(token.Credentials())\n \t\t}\n-\n \t\treturn cliutil.UsageError(\"Provided Tunnel token is not valid.\")\n \t} else {\n \t\ttunnelRef := c.Args().First()\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: AUTH-4699 adds an iat to the lockfile for orgs and apps to know if th\u2026\n\nDescription: \u2026ey are stale or not\n\nCode Diff:\ntoken/token.go\n@@ -63,6 +63,10 @@ type jwtPayload struct {\n \tSubt  string   `json:\"sub\"`\n }\n \n+type lockFile struct {\n+\tPid int `json:\"pid\"`\n+}\n+\n type transferServiceResponse struct {\n \tAppToken string `json:\"app_token\"`\n \tOrgToken string `json:\"org_token\"`\n@@ -125,14 +129,36 @@ func (l *lock) Acquire() error {\n \t\t}\n \t}\n \n+\t// Create a lock file with the process ID\n+\tlockInfo := lockFile{\n+\t\tPid: os.Getpid(),\n+\t}\n+\n+\tlockData, err := json.Marshal(lockInfo)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \t// Create a lock file so other processes won't also try to get the token at\n \t// the same time\n-\tif err := os.WriteFile(l.lockFilePath, []byte{}, 0600); err != nil {\n+\tif err := os.WriteFile(l.lockFilePath, lockData, 0600); err != nil {\n \t\treturn err\n \t}\n+\n \treturn nil\n }\n \n+// processExists checks if a process with a given PID is still running\n+func processExists(pid int) bool {\n+\tprocess, err := os.FindProcess(pid)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\n+\terr = process.Signal(syscall.Signal(0))\n+\treturn err == nil\n+}\n+\n func (l *lock) deleteLockFile() error {\n \tif err := os.Remove(l.lockFilePath); err != nil && !os.IsNotExist(err) {\n \t\treturn errDeleteTokenFailed(l.lockFilePath)\n@@ -148,6 +174,29 @@ func (l *lock) Release() error {\n // isTokenLocked checks to see if there is another process attempting to get the token already\n func isTokenLocked(lockFilePath string) bool {\n \texists, err := config.FileExists(lockFilePath)\n+\tif exists && err == nil {\n+\t\tcontent, err := os.ReadFile(lockFilePath)\n+\t\tif err != nil {\n+\t\t\treturn true\n+\t\t}\n+\n+\t\tvar payload lockFile\n+\t\terr = json.Unmarshal(content, &payload)\n+\t\tif err != nil {\n+\t\t\t// if the lockfile did not contain a payload that means it was issued by an older version of cloudflared and should be deleted\n+\t\t\treturn false\n+\t\t}\n+\n+\t\t// Check if the process that created the lock is still running\n+\t\tif processExists(payload.Pid) {\n+\t\t\treturn true\n+\t\t}\n+\n+\t\t// If the process is not running, delete the stale lock file\n+\t\t_ = os.Remove(lockFilePath)\n[[MASK]]\n \n---\n\n"}], "ideal": "token/token.go\n@@ -63,6 +63,10 @@ type jwtPayload struct {\n \tSubt  string   `json:\"sub\"`\n }\n \n+type lockFile struct {\n+\tPid int `json:\"pid\"`\n+}\n+\n type transferServiceResponse struct {\n \tAppToken string `json:\"app_token\"`\n \tOrgToken string `json:\"org_token\"`\n@@ -125,14 +129,36 @@ func (l *lock) Acquire() error {\n \t\t}\n \t}\n \n+\t// Create a lock file with the process ID\n+\tlockInfo := lockFile{\n+\t\tPid: os.Getpid(),\n+\t}\n+\n+\tlockData, err := json.Marshal(lockInfo)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \t// Create a lock file so other processes won't also try to get the token at\n \t// the same time\n-\tif err := os.WriteFile(l.lockFilePath, []byte{}, 0600); err != nil {\n+\tif err := os.WriteFile(l.lockFilePath, lockData, 0600); err != nil {\n \t\treturn err\n \t}\n+\n \treturn nil\n }\n \n+// processExists checks if a process with a given PID is still running\n+func processExists(pid int) bool {\n+\tprocess, err := os.FindProcess(pid)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\n+\terr = process.Signal(syscall.Signal(0))\n+\treturn err == nil\n+}\n+\n func (l *lock) deleteLockFile() error {\n \tif err := os.Remove(l.lockFilePath); err != nil && !os.IsNotExist(err) {\n \t\treturn errDeleteTokenFailed(l.lockFilePath)\n@@ -148,6 +174,29 @@ func (l *lock) Release() error {\n // isTokenLocked checks to see if there is another process attempting to get the token already\n func isTokenLocked(lockFilePath string) bool {\n \texists, err := config.FileExists(lockFilePath)\n+\tif exists && err == nil {\n+\t\tcontent, err := os.ReadFile(lockFilePath)\n+\t\tif err != nil {\n+\t\t\treturn true\n+\t\t}\n+\n+\t\tvar payload lockFile\n+\t\terr = json.Unmarshal(content, &payload)\n+\t\tif err != nil {\n+\t\t\t// if the lockfile did not contain a payload that means it was issued by an older version of cloudflared and should be deleted\n+\t\t\treturn false\n+\t\t}\n+\n+\t\t// Check if the process that created the lock is still running\n+\t\tif processExists(payload.Pid) {\n+\t\t\treturn true\n+\t\t}\n+\n+\t\t// If the process is not running, delete the stale lock file\n+\t\t_ = os.Remove(lockFilePath)\n+\t\treturn false\n+\t}\n+\n \treturn exists && err == nil\n }\n \n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Update README.md\n\nDescription: minor fixes to readme\n\nCode Diff:\nREADME.md\n@@ -1,10 +1,10 @@\n # Cloudflare Tunnel client\n \n Contains the command-line client for Cloudflare Tunnel, a tunneling daemon that proxies traffic from the Cloudflare network to your origins.\n-This daemon sits between Cloudflare network and your origin (e.g. a webserver). Cloudflare attracts client requests and sends them to you\n[[MASK]]\n+All usages related to proxying to your origins are available under `cloudflared tunnel help`.\n \n You can also use `cloudflared` to access Tunnel origins (that are protected with `cloudflared tunnel`) for TCP traffic\n at Layer 4 (i.e., not HTTP/websocket), which is relevant for use cases such as SSH, RDP, etc.\n@@ -18,7 +18,7 @@ to access private origins behind Tunnels for Layer 4 traffic without requiring `\n \n Before you use Cloudflare Tunnel, you'll need to complete a few steps in the Cloudflare dashboard: you need to add a\n website to your Cloudflare account. Note that today it is possible to use Tunnel without a website (e.g. for private\n-routing), but for legacy reasons this requirement is still necessary:\n+routing), but for legacy reasons, this requirement is still necessary:\n 1. [Add a website to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/201720164-Creating-a-Cloudflare-account-and-adding-a-website)\n 2. [Change your domain nameservers to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/205195708)\n \n---\n\n"}], "ideal": "README.md\n@@ -1,10 +1,10 @@\n # Cloudflare Tunnel client\n \n Contains the command-line client for Cloudflare Tunnel, a tunneling daemon that proxies traffic from the Cloudflare network to your origins.\n-This daemon sits between Cloudflare network and your origin (e.g. a webserver). Cloudflare attracts client requests and sends them to you\n-via this daemon, without requiring you to poke holes on your firewall --- your origin can remain as closed as possible.\n+This daemon sits between Cloudflared network and your origin (e.g. a webserver). Cloudflare attracts client requests and sends them to you\n+via this daemon, without requiring you to poke holes in your firewall --- your origin can remain as closed as possible.\n Extensive documentation can be found in the [Cloudflare Tunnel section](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps) of the Cloudflare Docs.\n-All usages related with proxying to your origins are available under `cloudflared tunnel help`.\n+All usages related to proxying to your origins are available under `cloudflared tunnel help`.\n \n You can also use `cloudflared` to access Tunnel origins (that are protected with `cloudflared tunnel`) for TCP traffic\n at Layer 4 (i.e., not HTTP/websocket), which is relevant for use cases such as SSH, RDP, etc.\n@@ -18,7 +18,7 @@ to access private origins behind Tunnels for Layer 4 traffic without requiring `\n \n Before you use Cloudflare Tunnel, you'll need to complete a few steps in the Cloudflare dashboard: you need to add a\n website to your Cloudflare account. Note that today it is possible to use Tunnel without a website (e.g. for private\n-routing), but for legacy reasons this requirement is still necessary:\n+routing), but for legacy reasons, this requirement is still necessary:\n 1. [Add a website to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/201720164-Creating-a-Cloudflare-account-and-adding-a-website)\n 2. [Change your domain nameservers to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/205195708)\n \n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Refactor tunneldns dnsserver configuration\n\nDescription: Refactored the tunneldns package's dnsserver listener configuration.  This provides a path to disabling response caching as needed to fix #745 \n\nCode Diff:\ntunneldns/tunnel.go\n@@ -4,6 +4,7 @@ import (\n \t\"net\"\n \t\"strconv\"\n \t\"sync\"\n+\t\"os\"\n \n \t\"github.com/coredns/coredns/core/dnsserver\"\n \t\"github.com/coredns/coredns/plugin\"\n@@ -90,20 +91,37 @@ func CreateListener(address string, port uint16, upstreams []string, bootstraps\n \t\tupstreamList = append(upstreamList, upstream)\n \t}\n \n-\t// Create a local cache with HTTPS proxy plugin\n-\tchain := cache.New()\n-\tchain.Next = ProxyPlugin{\n-\t\tUpstreams: upstreamList,\n-\t}\n-\n \t// Format an endpoint\n \tendpoint := \"dns://\" + net.JoinHostPort(address, strconv.FormatUint(uint64(port), 10))\n \n+\t// get middlewares for DNS Server\n+\tmiddlewares := getMiddlewares(upstreamList)\n+\tchain := NewMetricsPlugin(middlewares)\n+\n \t// Create the actual middleware server\n-\tserver, err := dnsserver.NewServer(endpoint, []*dnsserver.Config{createConfig(address, port, NewMetricsPlugin(chain))})\n+\tserver, err := dnsserver.NewServer(endpoint, []*dnsserver.Config{createConfig(address, port, chain)})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\t\n[[MASK]]\n+// \n+// Middleware includes features like...\n+// * Response Cache\n+// * HTTP Proxy Settings\n+func getMiddlewares(upstreamList []Upstream) plugin.Handler { \n+\tproxyPlugin := ProxyPlugin{\n+\t\tUpstreams: upstreamList,\n+\t}\n+\tcachePlugin := cache.New()\n+\tcachePlugin.Next = proxyPlugin\n+\n+\tif os.Getenv(\"DISABLE_TUNNELDNS_CACHE\") == \"true\" { \n+\t\treturn cachePlugin \n+\t} \n+\treturn proxyPlugin\n+}\n\\ No newline at end of file\n---\n\n"}], "ideal": "tunneldns/tunnel.go\n@@ -4,6 +4,7 @@ import (\n \t\"net\"\n \t\"strconv\"\n \t\"sync\"\n+\t\"os\"\n \n \t\"github.com/coredns/coredns/core/dnsserver\"\n \t\"github.com/coredns/coredns/plugin\"\n@@ -90,20 +91,37 @@ func CreateListener(address string, port uint16, upstreams []string, bootstraps\n \t\tupstreamList = append(upstreamList, upstream)\n \t}\n \n-\t// Create a local cache with HTTPS proxy plugin\n-\tchain := cache.New()\n-\tchain.Next = ProxyPlugin{\n-\t\tUpstreams: upstreamList,\n-\t}\n-\n \t// Format an endpoint\n \tendpoint := \"dns://\" + net.JoinHostPort(address, strconv.FormatUint(uint64(port), 10))\n \n+\t// get middlewares for DNS Server\n+\tmiddlewares := getMiddlewares(upstreamList)\n+\tchain := NewMetricsPlugin(middlewares)\n+\n \t// Create the actual middleware server\n-\tserver, err := dnsserver.NewServer(endpoint, []*dnsserver.Config{createConfig(address, port, NewMetricsPlugin(chain))})\n+\tserver, err := dnsserver.NewServer(endpoint, []*dnsserver.Config{createConfig(address, port, chain)})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\t\n \n \treturn &Listener{server: server, log: log}, nil\n }\n+\n+// getMiddlewares() returns the middleware chain for DNS Server\n+// \n+// Middleware includes features like...\n+// * Response Cache\n+// * HTTP Proxy Settings\n+func getMiddlewares(upstreamList []Upstream) plugin.Handler { \n+\tproxyPlugin := ProxyPlugin{\n+\t\tUpstreams: upstreamList,\n+\t}\n+\tcachePlugin := cache.New()\n+\tcachePlugin.Next = proxyPlugin\n+\n+\tif os.Getenv(\"DISABLE_TUNNELDNS_CACHE\") == \"true\" { \n+\t\treturn cachePlugin \n+\t} \n+\treturn proxyPlugin\n+}\n\\ No newline at end of file\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: feat: emit explicit errors for the `service` command on unsupported OSes\n\nDescription: Per the contribution guidelines, this seemed to me like a small enough change to not warrant an issue before creating this pull request. Let me know if you'd like me to create one anyway.\r\n\r\n## Background\r\n\r\nWhile working with `cloudflared` on FreeBSD recently, I noticed that there's an inconsistency with the available CLI commands on that OS versus others \u2014 namely that the `service` command doesn't exist at all for operating systems other than Linux, macOS, and Windows.\r\n\r\nContrast `cloudflared --help` output on macOS versus FreeBSD (truncated to focus on the `COMMANDS` section):\r\n\r\n- Current help output on macOS:\r\n\r\n  ```text\r\n  COMMANDS:\r\n     update     Update the agent if a new version exists\r\n     version    Print the version\r\n     proxy-dns  Run a DNS over HTTPS proxy server.\r\n     tail       Stream logs from a remote cloudflared\r\n     service    Manages the cloudflared launch agent\r\n     help, h    Shows a list of commands or help for one command\r\n     Access:\r\n       access, forward  access <subcommand>\r\n     Tunnel:\r\n       tunnel  Use Cloudflare Tunnel to expose private services to the Internet or to   Cloudflare connected private users.\r\n  ```\r\n- Current help output on FreeBSD:\r\n  ```text\r\n  COMMANDS:\r\n     update     Update the agent if a new version exists\r\n     version    Print the version\r\n     proxy-dns  Run a DNS over HTTPS proxy server.\r\n     tail       Stream logs from a remote cloudflared\r\n     help, h    Shows a list of commands or help for one command\r\n     Access:\r\n       access, forward  access <subcommand>\r\n     Tunnel:\r\n       tunnel  Use Cloudflare Tunnel to expose private services to the Internet or to   Cloudflare connected private users.\r\n  ```\r\n\r\nThis omission has caused confusion for users (including me), especially since the provided command in the Cloudflare Zero Trust dashboard returns a seemingly-unrelated error message:\r\n\r\n```console\r\n$ sudo cloudflared service install ...\r\nYou did not specify any valid additional argument to the cloudflared tunnel command.\r\n\r\nIf you are trying to run a Quick Tunnel then you need to explicitly pass the --url flag.\r\nEg. cloudflared tunnel --url localhost:8080/.\r\n\r\nPlease note that Quick Tunnels are meant to be ephemeral and should only be used for testing purposes.\r\nFor production usage, we recommend creating Named Tunnels. (https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/)\r\n```\r\n\r\n## Contribution\r\n\r\nThis pull request adds a \"stub\" `service` command (including the usual subcommands available on other OSes) to explicitly declare it as unsupported on the operating system.\r\n\r\nNew help output on FreeBSD (and other operating systems where service management is unsupported):\r\n\r\n```text\r\nCOMMANDS:\r\n   update     Update the agent if a new version exists\r\n   version    Print the version\r\n   proxy-dns  Run a DNS over HTTPS proxy server.\r\n   tail       Stream logs from a remote cloudflared\r\n   service    Manages the cloudflared system service (not supported on this operating system)\r\n   help, h    Shows a list of commands or help for one command\r\n   Access:\r\n     access, forward  access <subcommand>\r\n   Tunnel:\r\n     tunnel  Use Cloudflare Tunnel to expose private services to the Internet or to   Cloudflare connected private users.\r\n```\r\n\r\nNew outputs when running the service management subcommands:\r\n\r\n```console\r\n$ sudo cloudflared service install ...\r\nservice installation is not supported on this operating system\r\n```\r\n\r\n```console\r\n$ sudo cloudflared service uninstall ...\r\nservice uninstallation is not supported on this operating system\r\n```\r\n\r\nThis keeps the available commands consistent until proper service management support can be added for these otherwise-supported operating systems.\r\n\r\nI'm more than happy to make any adjustments to the pull request \u2014 just let me know!\n\nCode Diff:\ncmd/cloudflared/generic_service.go\n@@ -3,11 +3,36 @@\n package main\n \n import (\n+\t\"fmt\"\n \t\"os\"\n \n \tcli \"github.com/urfave/cli/v2\"\n )\n \n func runApp(app *cli.App, graceShutdownC chan struct{}) {\n+\tapp.Commands = append(app.Commands, &cli.Command{\n+\t\tName:  \"service\",\n+\t\tUsage: \"Manages the cloudflared system service (not supported on this operating system)\",\n+\t\tSubcommands: []*cli.Command{\n+\t\t\t{\n+\t\t\t\tName:   \"install\",\n+\t\t\t\tUsage:  \"Install cloudflared as a system service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(installGenericService),\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:   \"uninstall\",\n+\t\t\t\tUsage:  \"Uninstall the cloudflared service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(uninstallGenericService),\n+\t\t\t},\n+\t\t},\n+\t})\n \tapp.Run(os.Args)\n }\n[[MASK]]\n+func uninstallGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service uninstallation is not supported on this operating system\")\n+}\n---\n\n"}], "ideal": "cmd/cloudflared/generic_service.go\n@@ -3,11 +3,36 @@\n package main\n \n import (\n+\t\"fmt\"\n \t\"os\"\n \n \tcli \"github.com/urfave/cli/v2\"\n )\n \n func runApp(app *cli.App, graceShutdownC chan struct{}) {\n+\tapp.Commands = append(app.Commands, &cli.Command{\n+\t\tName:  \"service\",\n+\t\tUsage: \"Manages the cloudflared system service (not supported on this operating system)\",\n+\t\tSubcommands: []*cli.Command{\n+\t\t\t{\n+\t\t\t\tName:   \"install\",\n+\t\t\t\tUsage:  \"Install cloudflared as a system service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(installGenericService),\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:   \"uninstall\",\n+\t\t\t\tUsage:  \"Uninstall the cloudflared service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(uninstallGenericService),\n+\t\t\t},\n+\t\t},\n+\t})\n \tapp.Run(os.Args)\n }\n+\n+func installGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service installation is not supported on this operating system\")\n+}\n+\n+func uninstallGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service uninstallation is not supported on this operating system\")\n+}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Fixes GOAWAY frames not handled correctly with http2\n\nDescription: Fixes cloudflare/cloudflared#1273\r\n\r\nAllows http2 requests to be retried only when a GOAWAY frame is received. \r\n\r\nGOAWAY spec: https://datatracker.ietf.org/doc/html/rfc7540#section-6.8\r\nHow GetBody is handled: https://github.com/golang/net/blob/master/http2/transport.go#L664\n\nCode Diff:\nproxy/proxy.go\n@@ -199,6 +199,16 @@ func (p *Proxy) proxyHTTPRequest(\n \t\troundTripReq.Header.Set(\"Connection\", \"keep-alive\")\n \t}\n \n+    // Handle GOAWAY frame to correctly retry a request\n+    if roundTripReq.Body != nil {\n[[MASK]]\n+        }\n+    }\n+\n \t// Set the User-Agent as an empty string if not provided to avoid inserting golang default UA\n \tif roundTripReq.Header.Get(\"User-Agent\") == \"\" {\n \t\troundTripReq.Header.Set(\"User-Agent\", \"\")\n---\n\n"}], "ideal": "proxy/proxy.go\n@@ -199,6 +199,16 @@ func (p *Proxy) proxyHTTPRequest(\n \t\troundTripReq.Header.Set(\"Connection\", \"keep-alive\")\n \t}\n \n+    // Handle GOAWAY frame to correctly retry a request\n+    if roundTripReq.Body != nil {\n+        roundTripReq.GetBody = func() (io.ReadCloser, err error) {\n+            if err.Error() == \"http2: Transport received Server's graceful shutdown GOAWAY\" {\n+                return roundTripReq.Body, nil\n+            }\n+            return nil, err\n+        }\n+    }\n+\n \t// Set the User-Agent as an empty string if not provided to avoid inserting golang default UA\n \tif roundTripReq.Header.Get(\"User-Agent\") == \"\" {\n \t\troundTripReq.Header.Set(\"User-Agent\", \"\")\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: remove repetitive words\n\nDescription: The same as closed https://github.com/cloudflare/cloudflared/pull/1197\r\n\r\nPlease review\n\nCode Diff:\nmanagement/events.go\n@@ -129,7 +129,7 @@ func (e *LogEventType) UnmarshalJSON(data []byte) error {\n \n // LogLevel corresponds to the zerolog logging levels\n[[MASK]]\n const (\n---\nretry/backoffhandler.go\n@@ -99,7 +99,7 @@ func (b *BackoffHandler) Backoff(ctx context.Context) bool {\n \t}\n }\n \n-// Sets a grace period within which the the backoff timer is maintained. After the grace\n+// Sets a grace period within which the backoff timer is maintained. After the grace\n // period expires, the number of retries & backoff duration is reset.\n func (b *BackoffHandler) SetGracePeriod() time.Duration {\n \tmaxTimeToWait := b.GetBaseTime() * 2 << (b.retries + 1)\n---\n\n"}], "ideal": "management/events.go\n@@ -129,7 +129,7 @@ func (e *LogEventType) UnmarshalJSON(data []byte) error {\n \n // LogLevel corresponds to the zerolog logging levels\n // \"panic\", \"fatal\", and \"trace\" are exempt from this list as they are rarely used and, at least\n-// the the first two are limited to failure conditions that lead to cloudflared shutting down.\n+// the first two are limited to failure conditions that lead to cloudflared shutting down.\n type LogLevel int8\n \n const (\n---\nretry/backoffhandler.go\n@@ -99,7 +99,7 @@ func (b *BackoffHandler) Backoff(ctx context.Context) bool {\n \t}\n }\n \n-// Sets a grace period within which the the backoff timer is maintained. After the grace\n+// Sets a grace period within which the backoff timer is maintained. After the grace\n // period expires, the number of retries & backoff duration is reset.\n func (b *BackoffHandler) SetGracePeriod() time.Duration {\n \tmaxTimeToWait := b.GetBaseTime() * 2 << (b.retries + 1)\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Fix broken links in `cmd/cloudflared/*.go` related to running tunnel as a service\n\nDescription: This PR updates 3 broken links to document [run tunnel as a service](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/configure-tunnels/local-management/as-a-service/).\r\n\r\nThe one in [cmd/cloudflared/updater/update.go](https://github.com/cloudflare/cloudflared/compare/master...BWsix:cloudflared:master#diff-41cdc7fdfeb545f23c0990d2e13c4c34df74cfbdb2369b321b1e8688d98bde62) can be found by running `cloudflared tunnel run`:\r\n```bash\r\n> cloudflared tunnel run xxxx\r\n2024-03-27T18:21:58Z INF Starting tunnel tunnelID=xxxx\r\n2024-03-27T18:21:58Z INF Version 2024.3.0\r\n2024-03-27T18:21:58Z INF GOOS: linux, GOVersion: go1.21.5-devel-cf, GoArch: amd64\r\n2024-03-27T18:21:58Z INF Settings: xxxx\r\n2024-03-27T18:21:58Z INF cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/as-a-service/\r\n^ the broken link is at the end of this line\r\n```\r\nThe other two were found by manually grepping `developers.cloudflare.com` in the project.\n\nCode Diff:\ncmd/cloudflared/macos_service.go\n@@ -119,7 +119,7 @@ func installLaunchd(c *cli.Context) error {\n \t\tlog.Info().Msg(\"Installing cloudflared client as an user launch agent. \" +\n \t\t\t\"Note that cloudflared client will only run when the user is logged in. \" +\n \t\t\t\"If you want to run cloudflared client at boot, install with root permission. \" +\n-\t\t\t\"For more information, visit https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/run-as-service\")\n+\t\t\t\"For more information, visit https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/configure-tunnels/local-management/as-a-service/macos/\")\n \t}\n \tetPath, err := os.Executable()\n \tif err != nil {\n---\ncmd/cloudflared/updater/update.go\n@@ -20,7 +20,7 @@ import (\n \n const (\n \tDefaultCheckUpdateFreq        = time.Hour * 24\n[[MASK]]\n---\ncmd/cloudflared/windows_service.go\n@@ -26,7 +26,7 @@ import (\n const (\n \twindowsServiceName        = \"Cloudflared\"\n \twindowsServiceDescription = \"Cloudflared agent\"\n-\twindowsServiceUrl         = \"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/as-a-service/windows/\"\n+\twindowsServiceUrl         = \"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configure-tunnels/local-management/as-a-service/windows/\"\n \n \trecoverActionDelay      = time.Second * 20\n \tfailureCountResetPeriod = time.Hour * 24\n---\n\n"}], "ideal": "cmd/cloudflared/macos_service.go\n@@ -119,7 +119,7 @@ func installLaunchd(c *cli.Context) error {\n \t\tlog.Info().Msg(\"Installing cloudflared client as an user launch agent. \" +\n \t\t\t\"Note that cloudflared client will only run when the user is logged in. \" +\n \t\t\t\"If you want to run cloudflared client at boot, install with root permission. \" +\n-\t\t\t\"For more information, visit https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/run-as-service\")\n+\t\t\t\"For more information, visit https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/configure-tunnels/local-management/as-a-service/macos/\")\n \t}\n \tetPath, err := os.Executable()\n \tif err != nil {\n---\ncmd/cloudflared/updater/update.go\n@@ -20,7 +20,7 @@ import (\n \n const (\n \tDefaultCheckUpdateFreq        = time.Hour * 24\n-\tnoUpdateInShellMessage        = \"cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/as-a-service/\"\n+\tnoUpdateInShellMessage        = \"cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configure-tunnels/local-management/as-a-service/\"\n \tnoUpdateOnWindowsMessage      = \"cloudflared will not automatically update on Windows systems.\"\n \tnoUpdateManagedPackageMessage = \"cloudflared will not automatically update if installed by a package manager.\"\n \tisManagedInstallFile          = \".installedFromPackageManager\"\n---\ncmd/cloudflared/windows_service.go\n@@ -26,7 +26,7 @@ import (\n const (\n \twindowsServiceName        = \"Cloudflared\"\n \twindowsServiceDescription = \"Cloudflared agent\"\n-\twindowsServiceUrl         = \"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/as-a-service/windows/\"\n+\twindowsServiceUrl         = \"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configure-tunnels/local-management/as-a-service/windows/\"\n \n \trecoverActionDelay      = time.Second * 20\n \tfailureCountResetPeriod = time.Hour * 24\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: feat: provide short version\n\nDescription: #1179 proposal\n\nCode Diff:\ncmd/cloudflared/main.go\n@@ -134,11 +134,22 @@ To determine if an update happened in a script, check for error code 11.`,\n \t\t{\n \t\t\tName: \"version\",\n \t\t\tAction: func(c *cli.Context) (err error) {\n+\t\t\t\tif c.Bool(\"short\") {\n+\t\t\t\t\tfmt.Println(strings.Split(c.App.Version, \" \")[0])\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n \t\t\t\tversion(c)\n[[MASK]]\n+\t\t\t\t&cli.BoolFlag{\n+\t\t\t\t\tName:    \"short\",\n+\t\t\t\t\tAliases: []string{\"s\"},\n+\t\t\t\t\tUsage:   \"print just the version number\",\n+\t\t\t\t},\n+\t\t\t},\n \t\t},\n \t}\n \tcmds = append(cmds, tunnel.Commands()...)\n---\n\n"}], "ideal": "cmd/cloudflared/main.go\n@@ -134,11 +134,22 @@ To determine if an update happened in a script, check for error code 11.`,\n \t\t{\n \t\t\tName: \"version\",\n \t\t\tAction: func(c *cli.Context) (err error) {\n+\t\t\t\tif c.Bool(\"short\") {\n+\t\t\t\t\tfmt.Println(strings.Split(c.App.Version, \" \")[0])\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n \t\t\t\tversion(c)\n \t\t\t\treturn nil\n \t\t\t},\n \t\t\tUsage:       versionText,\n \t\t\tDescription: versionText,\n+\t\t\tFlags: []cli.Flag{\n+\t\t\t\t&cli.BoolFlag{\n+\t\t\t\t\tName:    \"short\",\n+\t\t\t\t\tAliases: []string{\"s\"},\n+\t\t\t\t\tUsage:   \"print just the version number\",\n+\t\t\t\t},\n+\t\t\t},\n \t\t},\n \t}\n \tcmds = append(cmds, tunnel.Commands()...)\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Add cloudflared tunnel ready command\n\nDescription: This would make it possible to have a Docker image without wget and curl, and still make docker healthchecking in docker possible\r\n\r\ncloses #1126 \n\nCode Diff:\ncmd/cloudflared/tunnel/cmd.go\n@@ -139,6 +139,7 @@ func Commands() []*cli.Command {\n \t\tbuildVirtualNetworkSubcommand(false),\n \t\tbuildRunCommand(),\n \t\tbuildListCommand(),\n+\t\tbuildReadyCommand(),\n \t\tbuildInfoCommand(),\n \t\tbuildIngressSubcommand(),\n \t\tbuildDeleteCommand(),\n---\ncmd/cloudflared/tunnel/subcommands.go\n@@ -5,6 +5,8 @@ import (\n \t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"regexp\"\n[[MASK]]\n+\treturn &cli.Command{\n+\t\tName:               \"ready\",\n+\t\tAction:             cliutil.ConfiguredAction(readyCommand),\n+\t\tUsage:              \"Call /ready endpoint and return proper exit code\",\n+\t\tUsageText:          \"cloudflared tunnel [tunnel command options] ready [subcommand options]\",\n+\t\tDescription:        \"cloudflared tunnel ready will return proper exit code based on the /ready endpoint\",\n+\t\tFlags:              []cli.Flag{},\n+\t\tCustomHelpTemplate: commandHelpTemplate(),\n+\t}\n+}\n+\n+func readyCommand(c *cli.Context) error {\n+\tmetricsOpts := c.String(\"metrics\")\n+\tif !c.IsSet(\"metrics\") {\n+\t\treturn fmt.Errorf(\"--metrics has to be provided\")\n+\t}\n+\n+\trequestURL := fmt.Sprintf(\"http://%s/ready\", metricsOpts)\n+\tres, err := http.Get(requestURL)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif res.StatusCode != 200 {\n+\t\tbody, err := io.ReadAll(res.Body)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\treturn fmt.Errorf(\"http://%s/ready endpoint returned status code %d\\n%s\", metricsOpts, res.StatusCode, body)\n+\t}\n+\treturn nil\n+}\n+\n func buildInfoCommand() *cli.Command {\n \treturn &cli.Command{\n \t\tName:        \"info\",\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/cmd.go\n@@ -139,6 +139,7 @@ func Commands() []*cli.Command {\n \t\tbuildVirtualNetworkSubcommand(false),\n \t\tbuildRunCommand(),\n \t\tbuildListCommand(),\n+\t\tbuildReadyCommand(),\n \t\tbuildInfoCommand(),\n \t\tbuildIngressSubcommand(),\n \t\tbuildDeleteCommand(),\n---\ncmd/cloudflared/tunnel/subcommands.go\n@@ -5,6 +5,8 @@ import (\n \t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"regexp\"\n@@ -397,6 +399,39 @@ func fmtConnections(connections []cfapi.Connection, showRecentlyDisconnected boo\n \treturn strings.Join(output, \", \")\n }\n \n+func buildReadyCommand() *cli.Command {\n+\treturn &cli.Command{\n+\t\tName:               \"ready\",\n+\t\tAction:             cliutil.ConfiguredAction(readyCommand),\n+\t\tUsage:              \"Call /ready endpoint and return proper exit code\",\n+\t\tUsageText:          \"cloudflared tunnel [tunnel command options] ready [subcommand options]\",\n+\t\tDescription:        \"cloudflared tunnel ready will return proper exit code based on the /ready endpoint\",\n+\t\tFlags:              []cli.Flag{},\n+\t\tCustomHelpTemplate: commandHelpTemplate(),\n+\t}\n+}\n+\n+func readyCommand(c *cli.Context) error {\n+\tmetricsOpts := c.String(\"metrics\")\n+\tif !c.IsSet(\"metrics\") {\n+\t\treturn fmt.Errorf(\"--metrics has to be provided\")\n+\t}\n+\n+\trequestURL := fmt.Sprintf(\"http://%s/ready\", metricsOpts)\n+\tres, err := http.Get(requestURL)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif res.StatusCode != 200 {\n+\t\tbody, err := io.ReadAll(res.Body)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\treturn fmt.Errorf(\"http://%s/ready endpoint returned status code %d\\n%s\", metricsOpts, res.StatusCode, body)\n+\t}\n+\treturn nil\n+}\n+\n func buildInfoCommand() *cli.Command {\n \treturn &cli.Command{\n \t\tName:        \"info\",\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Don't logs errors, when all possible errors are already returned for others to handle\n\nDescription: I don't see the point in logging errors here, when errors are already returned properly.\r\n\r\ncloses #1037 \n\nCode Diff:\ncredentials/origin_cert.go\n@@ -7,10 +7,8 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \n-\t\"github.com/mitchellh/go-homedir\"\n-\t\"github.com/rs/zerolog\"\n-\n \t\"github.com/cloudflare/cloudflared/config\"\n+\t\"github.com/mitchellh/go-homedir\"\n )\n \n const (\n@@ -91,29 +89,18 @@ func readOriginCert(originCertPath string) ([]byte, error) {\n }\n \n // FindOriginCert will check to make sure that the certificate exists at the specified file path.\n-func FindOriginCert(originCertPath string, log *zerolog.Logger) (string, error) {\n+func FindOriginCert(originCertPath string) (string, error) {\n \tif originCertPath == \"\" {\n-\t\tlog.Error().Msgf(\"Cannot determine default origin certificate path. No file %s in %v. You need to specify the origin certificate path by specifying the origincert option in the configuration file, or set TUNNEL_ORIGIN_CERT environment variable\", DefaultCredentialFile, config.DefaultConfigSearchDirectories())\n \t\treturn \"\", fmt.Errorf(\"client didn't specify origincert path\")\n \t}\n \tvar err error\n \toriginCertPath, err = homedir.Expand(originCertPath)\n \tif err != nil {\n-\t\tlog.Err(err).Msgf(\"Cannot resolve origin certificate path\")\n \t\treturn \"\", fmt.Errorf(\"cannot resolve path %s\", originCertPath)\n \t}\n \t// Check that the user has acquired a certificate using the login command\n \tok := fileExists(originCertPath)\n \tif !ok {\n-\t\tlog.Error().Msgf(`Cannot find a valid certificate for your origin at the path:\n-\n-    %s\n-\n[[MASK]]\n \t\treturn \"\", fmt.Errorf(\"cannot find a valid certificate at the path %s\", originCertPath)\n \t}\n \n---\n\n"}], "ideal": "credentials/origin_cert.go\n@@ -7,10 +7,8 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \n-\t\"github.com/mitchellh/go-homedir\"\n-\t\"github.com/rs/zerolog\"\n-\n \t\"github.com/cloudflare/cloudflared/config\"\n+\t\"github.com/mitchellh/go-homedir\"\n )\n \n const (\n@@ -91,29 +89,18 @@ func readOriginCert(originCertPath string) ([]byte, error) {\n }\n \n // FindOriginCert will check to make sure that the certificate exists at the specified file path.\n-func FindOriginCert(originCertPath string, log *zerolog.Logger) (string, error) {\n+func FindOriginCert(originCertPath string) (string, error) {\n \tif originCertPath == \"\" {\n-\t\tlog.Error().Msgf(\"Cannot determine default origin certificate path. No file %s in %v. You need to specify the origin certificate path by specifying the origincert option in the configuration file, or set TUNNEL_ORIGIN_CERT environment variable\", DefaultCredentialFile, config.DefaultConfigSearchDirectories())\n \t\treturn \"\", fmt.Errorf(\"client didn't specify origincert path\")\n \t}\n \tvar err error\n \toriginCertPath, err = homedir.Expand(originCertPath)\n \tif err != nil {\n-\t\tlog.Err(err).Msgf(\"Cannot resolve origin certificate path\")\n \t\treturn \"\", fmt.Errorf(\"cannot resolve path %s\", originCertPath)\n \t}\n \t// Check that the user has acquired a certificate using the login command\n \tok := fileExists(originCertPath)\n \tif !ok {\n-\t\tlog.Error().Msgf(`Cannot find a valid certificate for your origin at the path:\n-\n-    %s\n-\n-If the path above is wrong, specify the path with the -origincert option.\n-If you don't have a certificate signed by Cloudflare, run the command:\n-\n-\tcloudflared login\n-`, originCertPath)\n \t\treturn \"\", fmt.Errorf(\"cannot find a valid certificate at the path %s\", originCertPath)\n \t}\n \n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: fix checkInPingGroup bugs\n\nDescription: - Must check for the *effective* GID. \r\n- Must allow range from  0 to 4294967294 in current kernels.\r\n- fixes #1127\n\nCode Diff:\ningress/icmp_linux.go\n@@ -78,19 +78,19 @@ func checkInPingGroup() error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tgroupID := os.Getgid()\n+\tgroupID := uint64(os.Getegid())\n \t// Example content: 999\t   59999\n \tfound := findGroupIDRegex.FindAll(file, 2)\n \tif len(found) == 2 {\n-\t\tgroupMin, err := strconv.ParseInt(string(found[0]), 10, 32)\n+\t\tgroupMin, err := strconv.ParseUint(string(found[0]), 10, 32)\n \t\tif err != nil {\n \t\t\treturn errors.Wrapf(err, \"failed to determine minimum ping group ID\")\n[[MASK]]\n+\t\t\treturn errors.Wrapf(err, \"failed to determine maximum ping group ID\")\n \t\t}\n-\t\tif groupID < int(groupMin) || groupID > int(groupMax) {\n+\t\tif groupID < groupMin || groupID > groupMax {\n \t\t\treturn fmt.Errorf(\"Group ID %d is not between ping group %d to %d\", groupID, groupMin, groupMax)\n \t\t}\n \t\treturn nil\n---\n\n"}], "ideal": "ingress/icmp_linux.go\n@@ -78,19 +78,19 @@ func checkInPingGroup() error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tgroupID := os.Getgid()\n+\tgroupID := uint64(os.Getegid())\n \t// Example content: 999\t   59999\n \tfound := findGroupIDRegex.FindAll(file, 2)\n \tif len(found) == 2 {\n-\t\tgroupMin, err := strconv.ParseInt(string(found[0]), 10, 32)\n+\t\tgroupMin, err := strconv.ParseUint(string(found[0]), 10, 32)\n \t\tif err != nil {\n \t\t\treturn errors.Wrapf(err, \"failed to determine minimum ping group ID\")\n \t\t}\n-\t\tgroupMax, err := strconv.ParseInt(string(found[1]), 10, 32)\n+\t\tgroupMax, err := strconv.ParseUint(string(found[1]), 10, 32)\n \t\tif err != nil {\n-\t\t\treturn errors.Wrapf(err, \"failed to determine minimum ping group ID\")\n+\t\t\treturn errors.Wrapf(err, \"failed to determine maximum ping group ID\")\n \t\t}\n-\t\tif groupID < int(groupMin) || groupID > int(groupMax) {\n+\t\tif groupID < groupMin || groupID > groupMax {\n \t\t\treturn fmt.Errorf(\"Group ID %d is not between ping group %d to %d\", groupID, groupMin, groupMax)\n \t\t}\n \t\treturn nil\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Fix service fail to start due to network not ready on boot\n\nDescription: Fix service fail to start due to unavaliable network\r\nSee: https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/\n\nCode Diff:\ncmd/cloudflared/linux_service.go\n@@ -55,7 +55,8 @@ var systemdAllTemplates = map[string]ServiceTemplate{\n[[MASK]]\n+Wants=network-online.target\n \n [Service]\n TimeoutStartSec=0\n@@ -72,7 +73,8 @@ WantedBy=multi-user.target\n \t\tPath: fmt.Sprintf(\"/etc/systemd/system/%s\", cloudflaredUpdateService),\n \t\tContent: `[Unit]\n Description=Update cloudflared\n-After=network.target\n+After=network-online.target\n+Wants=network-online.target\n \n [Service]\n ExecStart=/bin/bash -c '{{ .Path }} update; code=$?; if [ $code -eq 11 ]; then systemctl restart cloudflared; exit 0; fi; exit $code'\n---\n\n"}], "ideal": "cmd/cloudflared/linux_service.go\n@@ -55,7 +55,8 @@ var systemdAllTemplates = map[string]ServiceTemplate{\n \t\tPath: fmt.Sprintf(\"/etc/systemd/system/%s\", cloudflaredService),\n \t\tContent: `[Unit]\n Description=cloudflared\n-After=network.target\n+After=network-online.target\n+Wants=network-online.target\n \n [Service]\n TimeoutStartSec=0\n@@ -72,7 +73,8 @@ WantedBy=multi-user.target\n \t\tPath: fmt.Sprintf(\"/etc/systemd/system/%s\", cloudflaredUpdateService),\n \t\tContent: `[Unit]\n Description=Update cloudflared\n-After=network.target\n+After=network-online.target\n+Wants=network-online.target\n \n [Service]\n ExecStart=/bin/bash -c '{{ .Path }} update; code=$?; if [ $code -eq 11 ]; then systemctl restart cloudflared; exit 0; fi; exit $code'\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: [access] Add environment variables for TCP tunnel hostname / destination / URL.\n\nDescription: This PR adds the remaining environment variables to `cloudflared access tcp`, so it can be configured solely via environment variable. \r\n\r\n\n\nCode Diff:\ncmd/cloudflared/access/cmd.go\n@@ -132,15 +132,18 @@ func Commands() []*cli.Command {\n \t\t\t\t\t\t\tName:    sshHostnameFlag,\n \t\t\t\t\t\t\tAliases: []string{\"tunnel-host\", \"T\"},\n \t\t\t\t\t\t\tUsage:   \"specify the hostname of your application.\",\n+\t\t\t\t\t\t\tEnvVars: []string{\"TUNNEL_SERVICE_HOSTNAME\"},\n[[MASK]]\n \t\t\t\t\t\t},\n \t\t\t\t\t\t&cli.StringFlag{\n \t\t\t\t\t\t\tName:    sshURLFlag,\n \t\t\t\t\t\t\tAliases: []string{\"listener\", \"L\"},\n \t\t\t\t\t\t\tUsage:   \"specify the host:port to forward data to Cloudflare edge.\",\n+\t\t\t\t\t\t\tEnvVars: []string{\"TUNNEL_SERVICE_URL\"},\n \t\t\t\t\t\t},\n \t\t\t\t\t\t&cli.StringSliceFlag{\n \t\t\t\t\t\t\tName:    sshHeaderFlag,\n---\n\n"}], "ideal": "cmd/cloudflared/access/cmd.go\n@@ -132,15 +132,18 @@ func Commands() []*cli.Command {\n \t\t\t\t\t\t\tName:    sshHostnameFlag,\n \t\t\t\t\t\t\tAliases: []string{\"tunnel-host\", \"T\"},\n \t\t\t\t\t\t\tUsage:   \"specify the hostname of your application.\",\n+\t\t\t\t\t\t\tEnvVars: []string{\"TUNNEL_SERVICE_HOSTNAME\"},\n \t\t\t\t\t\t},\n \t\t\t\t\t\t&cli.StringFlag{\n \t\t\t\t\t\t\tName:  sshDestinationFlag,\n \t\t\t\t\t\t\tUsage: \"specify the destination address of your SSH server.\",\n+\t\t\t\t\t\t\tEnvVars: []string{\"TUNNEL_SERVICE_DESTINATION\"},\n \t\t\t\t\t\t},\n \t\t\t\t\t\t&cli.StringFlag{\n \t\t\t\t\t\t\tName:    sshURLFlag,\n \t\t\t\t\t\t\tAliases: []string{\"listener\", \"L\"},\n \t\t\t\t\t\t\tUsage:   \"specify the host:port to forward data to Cloudflare edge.\",\n+\t\t\t\t\t\t\tEnvVars: []string{\"TUNNEL_SERVICE_URL\"},\n \t\t\t\t\t\t},\n \t\t\t\t\t\t&cli.StringSliceFlag{\n \t\t\t\t\t\t\tName:    sshHeaderFlag,\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title:  Remove 'custom:' from hostnames (label)\n\nDescription: Remove 'custom:' from hostname/label value\r\n\n\nCode Diff:\ncomponent-tests/test_management.py\n@@ -40,7 +40,7 @@ def test_get_host_details(self, tmp_path, component_tests_config):\n             \n             # Assert response json.\n             assert resp.status_code == 200, \"Expected cloudflared to return 200 for host details\"\n-            assert resp.json()[\"hostname\"] == \"custom:test\", \"Expected cloudflared to return hostname\"\n+            assert resp.json()[\"hostname\"] == \"test\", \"Expected cloudflared to return hostname\"\n             assert resp.json()[\"ip\"] != \"\", \"Expected cloudflared to return ip\"\n             assert resp.json()[\"connector_id\"] == connector_id, \"Expected cloudflared to return connector_id\"\n     \n---\nmanagement/service.go\n@@ -134,7 +134,7 @@ func (m *ManagementService) getHostDetails(w http.ResponseWriter, r *http.Reques\n \n func (m *ManagementService) getLabel() string {\n[[MASK]]\n \t// If no label is provided we return the system hostname. This is not\n---\n\n"}], "ideal": "component-tests/test_management.py\n@@ -40,7 +40,7 @@ def test_get_host_details(self, tmp_path, component_tests_config):\n             \n             # Assert response json.\n             assert resp.status_code == 200, \"Expected cloudflared to return 200 for host details\"\n-            assert resp.json()[\"hostname\"] == \"custom:test\", \"Expected cloudflared to return hostname\"\n+            assert resp.json()[\"hostname\"] == \"test\", \"Expected cloudflared to return hostname\"\n             assert resp.json()[\"ip\"] != \"\", \"Expected cloudflared to return ip\"\n             assert resp.json()[\"connector_id\"] == connector_id, \"Expected cloudflared to return connector_id\"\n     \n---\nmanagement/service.go\n@@ -134,7 +134,7 @@ func (m *ManagementService) getHostDetails(w http.ResponseWriter, r *http.Reques\n \n func (m *ManagementService) getLabel() string {\n \tif m.label != \"\" {\n-\t\treturn fmt.Sprintf(\"custom:%s\", m.label)\n+\t\treturn fmt.Sprintf(\"%s\", m.label)\n \t}\n \n \t// If no label is provided we return the system hostname. This is not\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Remove custom: from hostnames (label)\n\nDescription: Remove additional length from custom connector labels and hostnames should only contain 'a-z', 'A-Z', '0-9', '-' and '.' \r\n\r\n\n\nCode Diff:\ncomponent-tests/test_management.py\n@@ -40,7 +40,7 @@ def test_get_host_details(self, tmp_path, component_tests_config):\n             \n             # Assert response json.\n[[MASK]]\n     \n---\nmanagement/service.go\n@@ -134,7 +134,7 @@ func (m *ManagementService) getHostDetails(w http.ResponseWriter, r *http.Reques\n \n func (m *ManagementService) getLabel() string {\n \tif m.label != \"\" {\n-\t\treturn fmt.Sprintf(\"custom:%s\", m.label)\n+\t\treturn fmt.Sprintf(\"%s\", m.label)\n \t}\n \n \t// If no label is provided we return the system hostname. This is not\n---\n\n"}], "ideal": "component-tests/test_management.py\n@@ -40,7 +40,7 @@ def test_get_host_details(self, tmp_path, component_tests_config):\n             \n             # Assert response json.\n             assert resp.status_code == 200, \"Expected cloudflared to return 200 for host details\"\n-            assert resp.json()[\"hostname\"] == \"custom:test\", \"Expected cloudflared to return hostname\"\n+            assert resp.json()[\"hostname\"] == \"test\", \"Expected cloudflared to return hostname\"\n             assert resp.json()[\"ip\"] != \"\", \"Expected cloudflared to return ip\"\n             assert resp.json()[\"connector_id\"] == connector_id, \"Expected cloudflared to return connector_id\"\n     \n---\nmanagement/service.go\n@@ -134,7 +134,7 @@ func (m *ManagementService) getHostDetails(w http.ResponseWriter, r *http.Reques\n \n func (m *ManagementService) getLabel() string {\n \tif m.label != \"\" {\n-\t\treturn fmt.Sprintf(\"custom:%s\", m.label)\n+\t\treturn fmt.Sprintf(\"%s\", m.label)\n \t}\n \n \t// If no label is provided we return the system hostname. This is not\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Added the functionality for sending email to a recipient every time a new quick tunnel is created, i.e. sending the URL of the created quick tunnel via email to the recipient.\n\nDescription: ## Why this added functionality ?\r\nThis added optional functionality is for you if you are like me and is too poor to buy a domain *\\*just kidding I know you make six-figures yearly ;)\\**.\r\n<br>\r\n*(I know about freenom, but as for now freenom is not allowing to register new free domains \ud83e\udd27\ud83e\udd27\ud83e\udd27\ud83e\udd27\ud83e\udd27)*\r\n<br>\r\nLet's consider my use case, my ISP charges a huge sum of money monthly for static IP, which is not feasable for me as a student, also my home server goes whereever I go, thats why static IP is of no use for me.\r\n<br>\r\nThen I stumpled upon **cloudflared**, \\*my dream come true scenerio\\*, but then comes the problem of buying & adding a domain in cloudflare if I want the tunnel URL to be persistent and known to me, which is also not feasible for me *(because why pay money when you know how to reverse engineer & edit opensource code \ud83d\ude0e\ud83d\ude0e \\*wallet sadness intensifies\\*)*\r\n<br>\r\nSo I finalized the decision of using cloudflare quick tunnels, but the link reset every time my cloudflared service restarts.\r\n<br>\r\nAnd to know the new link every time the cloudflared service restarts I make this change, that notifies the user via email the newly created quick tunnel link.\r\n<br>\r\nNow the user don't need to physically go into the system and fetch the quick tunnel link every time the cloudflared service restarts, you just get the link delivered to your mail box like a nerd \ud83d\ude0e\ud83d\ude0e.\r\n<br>\r\n**I hope, you find this feature useful**\r\n\r\n\r\n## Using cloudflared notification\r\n\r\n#### It uses gmail smtp for sending out mail as for now, other mail services will/can be added in future\r\n\r\n- To use this feature of notification functionality, you need to have a gmail account.\r\n\r\n+ Now create an app password for your gmail account, [read instructions here on how to create app password](https://support.google.com/accounts/answer/185833?hl=en)\r\n\r\n* Finally to take advantage of this notification functionality, run the cloudflared executable with this following command line arguments:\r\n\r\n\r\n```sh\r\ncloudflared tunnel --url http://localhost:6009 --notify receipeint@mailID --uname login@mailID --key 16-digit-app-password-for-login@mailID\r\n```\r\n\r\n\r\n**Tested on my Arch system (I use arch btw ;) ), it compiles (```make cloudflared```) & runs with no problem**\r\n\n\nCode Diff:\n[[MASK]]\n-\t\treturn RunQuickTunnel(sc)\n+\t\treturn RunQuickTunnel(sc, c)\n \t}\n \n \t// If user provides a config, check to see if they meant to use `tunnel run` instead\n@@ -843,6 +843,21 @@ func configureProxyFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_URL\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"notify\",\n+\t\t\tUsage:  \"Email address of the recipient to whom to send the quick tunnel URL notification.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"uname\",\n+\t\t\tUsage:  \"Username/Email-id of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"key\",\n+\t\t\tUsage:  \"Password/key of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n \t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n \t\t\tName:    ingress.HelloWorldFlag,\n \t\t\tValue:   false,\n---\ncmd/cloudflared/tunnel/quick_tunnel.go\n@@ -4,11 +4,13 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"net/http\"\n+\t\"net/smtp\"\n \t\"strings\"\n \t\"time\"\n \n \t\"github.com/google/uuid\"\n \t\"github.com/pkg/errors\"\n+\t\"github.com/urfave/cli/v2\"\n \n \t\"github.com/cloudflare/cloudflared/connection\"\n )\n@@ -20,10 +22,33 @@ const disclaimer = \"Thank you for trying Cloudflare Tunnel. Doing so, without a\n \t\"intend to use Tunnels in production you should use a pre-created named tunnel by following: \" +\n \t\"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps\"\n \n+func sendMail(body string, sc *subcommandContext, c *cli.Context) int {\n+\tfrom := c.String(\"uname\")\n+\tpass := c.String(\"key\")\n+\tto := c.String(\"notify\")\n+\n+\tmsg := \"From: \" + from + \"\\n\" +\n+\t\t\"To: \" + to + \"\\n\" +\n+\t\t\"Subject: Cloudflare Quick Tunnel URL\\n\\n\" +\n+\t\tbody\n+\n+\terr := smtp.SendMail(\"smtp.gmail.com:587\",\n+\t\tsmtp.PlainAuth(\"\", from, pass, \"smtp.gmail.com\"),\n+\t\tfrom, []string{to}, []byte(msg))\n+\n+\tif err != nil {\n+\t\tsc.log.Err(err).Msg(\"smtp error : Failed to send email\")\n+\t\treturn 1\n+\t}\n+\n+\tsc.log.Info().Msg(\"Email notification sent successfully to \" + c.String(\"notify\"))\n+\treturn 0\n+}\n+\n // RunQuickTunnel requests a tunnel from the specified service.\n // We use this to power quick tunnels on trycloudflare.com, but the\n // service is open-source and could be used by anyone.\n-func RunQuickTunnel(sc *subcommandContext) error {\n+func RunQuickTunnel(sc *subcommandContext, c *cli.Context) error {\n \tsc.log.Info().Msg(disclaimer)\n \tsc.log.Info().Msg(\"Requesting new quick Tunnel on trycloudflare.com...\")\n \n@@ -69,6 +94,22 @@ func RunQuickTunnel(sc *subcommandContext) error {\n \t\tsc.log.Info().Msg(line)\n \t}\n \n+\tif c.IsSet(\"notify\") && c.IsSet(\"uname\") && c.IsSet(\"key\") {\n+\t\tsendMail(url, sc, c)\n+\t} else if c.IsSet(\"notify\") || c.IsSet(\"uname\") || c.IsSet(\"key\") {\n+\t\tif !c.IsSet(\"uname\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --uname SMTP login username not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"key\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --key SMTP login password not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"notify\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --notify No recipient mail address specified\")\n+\t\t}\n+\t}\n+\n \tif !sc.c.IsSet(\"protocol\") {\n \t\tsc.c.Set(\"protocol\", \"quic\")\n \t}\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/cmd.go\n@@ -213,7 +213,7 @@ func TunnelCommand(c *cli.Context) error {\n \t// We don't support running proxy-dns and a quick tunnel at the same time as the same process\n \tshouldRunQuickTunnel := c.IsSet(\"url\") || c.IsSet(ingress.HelloWorldFlag)\n \tif !c.IsSet(\"proxy-dns\") && c.String(\"quick-service\") != \"\" && shouldRunQuickTunnel {\n-\t\treturn RunQuickTunnel(sc)\n+\t\treturn RunQuickTunnel(sc, c)\n \t}\n \n \t// If user provides a config, check to see if they meant to use `tunnel run` instead\n@@ -843,6 +843,21 @@ func configureProxyFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_URL\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"notify\",\n+\t\t\tUsage:  \"Email address of the recipient to whom to send the quick tunnel URL notification.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"uname\",\n+\t\t\tUsage:  \"Username/Email-id of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"key\",\n+\t\t\tUsage:  \"Password/key of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n \t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n \t\t\tName:    ingress.HelloWorldFlag,\n \t\t\tValue:   false,\n---\ncmd/cloudflared/tunnel/quick_tunnel.go\n@@ -4,11 +4,13 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"net/http\"\n+\t\"net/smtp\"\n \t\"strings\"\n \t\"time\"\n \n \t\"github.com/google/uuid\"\n \t\"github.com/pkg/errors\"\n+\t\"github.com/urfave/cli/v2\"\n \n \t\"github.com/cloudflare/cloudflared/connection\"\n )\n@@ -20,10 +22,33 @@ const disclaimer = \"Thank you for trying Cloudflare Tunnel. Doing so, without a\n \t\"intend to use Tunnels in production you should use a pre-created named tunnel by following: \" +\n \t\"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps\"\n \n+func sendMail(body string, sc *subcommandContext, c *cli.Context) int {\n+\tfrom := c.String(\"uname\")\n+\tpass := c.String(\"key\")\n+\tto := c.String(\"notify\")\n+\n+\tmsg := \"From: \" + from + \"\\n\" +\n+\t\t\"To: \" + to + \"\\n\" +\n+\t\t\"Subject: Cloudflare Quick Tunnel URL\\n\\n\" +\n+\t\tbody\n+\n+\terr := smtp.SendMail(\"smtp.gmail.com:587\",\n+\t\tsmtp.PlainAuth(\"\", from, pass, \"smtp.gmail.com\"),\n+\t\tfrom, []string{to}, []byte(msg))\n+\n+\tif err != nil {\n+\t\tsc.log.Err(err).Msg(\"smtp error : Failed to send email\")\n+\t\treturn 1\n+\t}\n+\n+\tsc.log.Info().Msg(\"Email notification sent successfully to \" + c.String(\"notify\"))\n+\treturn 0\n+}\n+\n // RunQuickTunnel requests a tunnel from the specified service.\n // We use this to power quick tunnels on trycloudflare.com, but the\n // service is open-source and could be used by anyone.\n-func RunQuickTunnel(sc *subcommandContext) error {\n+func RunQuickTunnel(sc *subcommandContext, c *cli.Context) error {\n \tsc.log.Info().Msg(disclaimer)\n \tsc.log.Info().Msg(\"Requesting new quick Tunnel on trycloudflare.com...\")\n \n@@ -69,6 +94,22 @@ func RunQuickTunnel(sc *subcommandContext) error {\n \t\tsc.log.Info().Msg(line)\n \t}\n \n+\tif c.IsSet(\"notify\") && c.IsSet(\"uname\") && c.IsSet(\"key\") {\n+\t\tsendMail(url, sc, c)\n+\t} else if c.IsSet(\"notify\") || c.IsSet(\"uname\") || c.IsSet(\"key\") {\n+\t\tif !c.IsSet(\"uname\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --uname SMTP login username not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"key\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --key SMTP login password not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"notify\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --notify No recipient mail address specified\")\n+\t\t}\n+\t}\n+\n \tif !sc.c.IsSet(\"protocol\") {\n \t\tsc.c.Set(\"protocol\", \"quic\")\n \t}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: email notification functionality\n\nDescription: Added the functionality of sending notification email of the url every time a new quick tunnel is created\n\nCode Diff:\ncmd/cloudflared/tunnel/cmd.go\n@@ -195,6 +195,7 @@ func TunnelCommand(c *cli.Context) error {\n[[MASK]]\n \t\thostname, err := validation.ValidateHostname(c.String(\"hostname\"))\n \t\tif err != nil {\n@@ -213,7 +214,7 @@ func TunnelCommand(c *cli.Context) error {\n \t// We don't support running proxy-dns and a quick tunnel at the same time as the same process\n \tshouldRunQuickTunnel := c.IsSet(\"url\") || c.IsSet(ingress.HelloWorldFlag)\n \tif !c.IsSet(\"proxy-dns\") && c.String(\"quick-service\") != \"\" && shouldRunQuickTunnel {\n-\t\treturn RunQuickTunnel(sc)\n+\t\treturn RunQuickTunnel(sc, c)\n \t}\n \n \t// If user provides a config, check to see if they meant to use `tunnel run` instead\n@@ -843,6 +844,21 @@ func configureProxyFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_URL\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"notify\",\n+\t\t\tUsage:  \"Email address to send the tunnel url notification.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"uname\",\n+\t\t\tUsage:  \"Username/Email-id of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"key\",\n+\t\t\tUsage:  \"Password/key of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n \t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n \t\t\tName:    ingress.HelloWorldFlag,\n \t\t\tValue:   false,\n---\ncmd/cloudflared/tunnel/quick_tunnel.go\n@@ -4,11 +4,13 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"net/http\"\n+\t\"net/smtp\"\n \t\"strings\"\n \t\"time\"\n \n \t\"github.com/google/uuid\"\n \t\"github.com/pkg/errors\"\n+\t\"github.com/urfave/cli/v2\"\n \n \t\"github.com/cloudflare/cloudflared/connection\"\n )\n@@ -20,10 +22,38 @@ const disclaimer = \"Thank you for trying Cloudflare Tunnel. Doing so, without a\n \t\"intend to use Tunnels in production you should use a pre-created named tunnel by following: \" +\n \t\"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps\"\n \n+func sendMail(body string, sc *subcommandContext, c *cli.Context) int {\n+\tfrom := c.String(\"uname\")\n+\tpass := c.String(\"key\")\n+\tto := c.String(\"notify\")\n+\n+\tmsg := \"From: \" + from + \"\\n\" +\n+\t\t\"To: \" + to + \"\\n\" +\n+\t\t\"Subject: `cloudflared-notify` Notification\\n\\n\" +\n+\t\tbody\n+\n+\terr := smtp.SendMail(\"smtp.gmail.com:587\",\n+\t\tsmtp.PlainAuth(\"\", from, pass, \"smtp.gmail.com\"),\n+\t\tfrom, []string{to}, []byte(msg))\n+\n+\tif err != nil {\n+\t\tsc.log.Err(err).Msg(\"smtp error : Failed to send email\")\n+\t\treturn 1\n+\t}\n+\n+\tsc.log.Info().Msg(\"Email notification sent successfully to \" + c.String(\"notify\"))\n+\treturn 0\n+}\n+\n // RunQuickTunnel requests a tunnel from the specified service.\n // We use this to power quick tunnels on trycloudflare.com, but the\n // service is open-source and could be used by anyone.\n-func RunQuickTunnel(sc *subcommandContext) error {\n+func RunQuickTunnel(sc *subcommandContext, c *cli.Context) error {\n+\n+\tfor _, line := range AsciiBox([]string{\"`cloudflared-notify` a fork of `cloudflared` by Anol Chakraborty\", \"Github: https://github.com/AnolChakraborty/cloudflared-notify\"}, 2) {\n+\t\tsc.log.Info().Msg(line)\n+\t}\n+\n \tsc.log.Info().Msg(disclaimer)\n \tsc.log.Info().Msg(\"Requesting new quick Tunnel on trycloudflare.com...\")\n \n@@ -62,13 +92,26 @@ func RunQuickTunnel(sc *subcommandContext) error {\n \t\turl = \"https://\" + url\n \t}\n \n-\tfor _, line := range AsciiBox([]string{\n-\t\t\"Your quick Tunnel has been created! Visit it at (it may take some time to be reachable):\",\n-\t\turl,\n-\t}, 2) {\n+\tfor _, line := range AsciiBox([]string{\"Your quick Tunnel has been created! Visit it at (it may take some time to be reachable):\", url}, 2) {\n \t\tsc.log.Info().Msg(line)\n \t}\n \n+\tif c.IsSet(\"notify\") && c.IsSet(\"uname\") && c.IsSet(\"key\") {\n+\t\tsendMail(url, sc, c)\n+\t} else {\n+\t\tif !c.IsSet(\"uname\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --uname SMTP login username not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"key\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --key SMTP login password not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"notify\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --notify No receipient mail address specified\")\n+\t\t}\n+\t}\n+\n \tif !sc.c.IsSet(\"protocol\") {\n \t\tsc.c.Set(\"protocol\", \"quic\")\n \t}\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/cmd.go\n@@ -195,6 +195,7 @@ func TunnelCommand(c *cli.Context) error {\n \t// --name required\n \t// --url or --hello-world required\n \t// --hostname optional\n+\n \tif name := c.String(\"name\"); name != \"\" {\n \t\thostname, err := validation.ValidateHostname(c.String(\"hostname\"))\n \t\tif err != nil {\n@@ -213,7 +214,7 @@ func TunnelCommand(c *cli.Context) error {\n \t// We don't support running proxy-dns and a quick tunnel at the same time as the same process\n \tshouldRunQuickTunnel := c.IsSet(\"url\") || c.IsSet(ingress.HelloWorldFlag)\n \tif !c.IsSet(\"proxy-dns\") && c.String(\"quick-service\") != \"\" && shouldRunQuickTunnel {\n-\t\treturn RunQuickTunnel(sc)\n+\t\treturn RunQuickTunnel(sc, c)\n \t}\n \n \t// If user provides a config, check to see if they meant to use `tunnel run` instead\n@@ -843,6 +844,21 @@ func configureProxyFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_URL\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"notify\",\n+\t\t\tUsage:  \"Email address to send the tunnel url notification.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"uname\",\n+\t\t\tUsage:  \"Username/Email-id of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"key\",\n+\t\t\tUsage:  \"Password/key of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n \t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n \t\t\tName:    ingress.HelloWorldFlag,\n \t\t\tValue:   false,\n---\ncmd/cloudflared/tunnel/quick_tunnel.go\n@@ -4,11 +4,13 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"net/http\"\n+\t\"net/smtp\"\n \t\"strings\"\n \t\"time\"\n \n \t\"github.com/google/uuid\"\n \t\"github.com/pkg/errors\"\n+\t\"github.com/urfave/cli/v2\"\n \n \t\"github.com/cloudflare/cloudflared/connection\"\n )\n@@ -20,10 +22,38 @@ const disclaimer = \"Thank you for trying Cloudflare Tunnel. Doing so, without a\n \t\"intend to use Tunnels in production you should use a pre-created named tunnel by following: \" +\n \t\"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps\"\n \n+func sendMail(body string, sc *subcommandContext, c *cli.Context) int {\n+\tfrom := c.String(\"uname\")\n+\tpass := c.String(\"key\")\n+\tto := c.String(\"notify\")\n+\n+\tmsg := \"From: \" + from + \"\\n\" +\n+\t\t\"To: \" + to + \"\\n\" +\n+\t\t\"Subject: `cloudflared-notify` Notification\\n\\n\" +\n+\t\tbody\n+\n+\terr := smtp.SendMail(\"smtp.gmail.com:587\",\n+\t\tsmtp.PlainAuth(\"\", from, pass, \"smtp.gmail.com\"),\n+\t\tfrom, []string{to}, []byte(msg))\n+\n+\tif err != nil {\n+\t\tsc.log.Err(err).Msg(\"smtp error : Failed to send email\")\n+\t\treturn 1\n+\t}\n+\n+\tsc.log.Info().Msg(\"Email notification sent successfully to \" + c.String(\"notify\"))\n+\treturn 0\n+}\n+\n // RunQuickTunnel requests a tunnel from the specified service.\n // We use this to power quick tunnels on trycloudflare.com, but the\n // service is open-source and could be used by anyone.\n-func RunQuickTunnel(sc *subcommandContext) error {\n+func RunQuickTunnel(sc *subcommandContext, c *cli.Context) error {\n+\n+\tfor _, line := range AsciiBox([]string{\"`cloudflared-notify` a fork of `cloudflared` by Anol Chakraborty\", \"Github: https://github.com/AnolChakraborty/cloudflared-notify\"}, 2) {\n+\t\tsc.log.Info().Msg(line)\n+\t}\n+\n \tsc.log.Info().Msg(disclaimer)\n \tsc.log.Info().Msg(\"Requesting new quick Tunnel on trycloudflare.com...\")\n \n@@ -62,13 +92,26 @@ func RunQuickTunnel(sc *subcommandContext) error {\n \t\turl = \"https://\" + url\n \t}\n \n-\tfor _, line := range AsciiBox([]string{\n-\t\t\"Your quick Tunnel has been created! Visit it at (it may take some time to be reachable):\",\n-\t\turl,\n-\t}, 2) {\n+\tfor _, line := range AsciiBox([]string{\"Your quick Tunnel has been created! Visit it at (it may take some time to be reachable):\", url}, 2) {\n \t\tsc.log.Info().Msg(line)\n \t}\n \n+\tif c.IsSet(\"notify\") && c.IsSet(\"uname\") && c.IsSet(\"key\") {\n+\t\tsendMail(url, sc, c)\n+\t} else {\n+\t\tif !c.IsSet(\"uname\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --uname SMTP login username not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"key\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --key SMTP login password not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"notify\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --notify No receipient mail address specified\")\n+\t\t}\n+\t}\n+\n \tif !sc.c.IsSet(\"protocol\") {\n \t\tsc.c.Set(\"protocol\", \"quic\")\n \t}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: GH-843: Add option to disable remote configuration\n\nDescription: Implements #843 \r\n\r\n- Add a new `--no-remote-config` global CLI option\r\n- When the option is enabled:\r\n    - Stop advertising `FeatureAllowRemoteConfig` in the `clientFeatures` passed to `tunnelpogs`\r\n    - Ignore incoming remote config updates in `Orchestrator`\r\n\r\n`cloudflared` seemed to behave correctly while testing locally:\r\n- On a migrated remotely-managed Tunnel, config from the Zero Trust dashboard was ignored, both at startup and when updating it, while the local config kept being enforced\r\n- Migrating an established locally-managed Tunnel to remote management doesn't disturb it, traffic continues to flow as if nothing had happened\r\n\r\nFor better UX, Cloudflare could implement an additional requirement on the ZT dashboard when `--no-remote-config` is enabled to prevent migration from local to remote management, or more generally a warning banner on the Tunnel configuration page (the option already gets displayed in the UI so I'd guess it's a small change).\r\n\r\nNot a Gopher, advice is very welcome!\n\nCode Diff:\ncmd/cloudflared/tunnel/cmd.go\n@@ -782,6 +782,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_MANAGEMENT_DIAGNOSTICS\"},\n \t\t\tValue:   false,\n \t\t}),\n+\t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n+\t\t\tName:    config.DisableRemoteConfigFlag,\n+\t\t\tUsage:   \"Disables remote configuration from the edge\",\n+\t\t\tEnvVars: []string{\"TUNNEL_NO_REMOTE_CONFIG\"},\n+\t\t\tValue:   false,\n+\t\t}),\n \t\tselectProtocolFlag,\n \t\toverwriteDNSFlag,\n \t}...)\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -39,7 +39,7 @@ var (\n \n \tsecretFlags = [2]*altsrc.StringFlag{credentialsContentsFlag, tunnelTokenFlag}\n \n-\tconfigFlags = []string{\"autoupdate-freq\", \"no-autoupdate\", \"retries\", \"protocol\", \"loglevel\", \"transport-loglevel\", \"origincert\", \"metrics\", \"metrics-update-freq\", \"edge-ip-version\", \"edge-bind-address\"}\n+\tconfigFlags = []string{\"autoupdate-freq\", \"no-autoupdate\", \"retries\", \"protocol\", \"loglevel\", \"transport-loglevel\", \"origincert\", \"metrics\", \"metrics-update-freq\", \"edge-ip-version\", \"edge-bind-address\", config.DisableRemoteConfigFlag}\n )\n \n func generateRandomClientID(log *zerolog.Logger) (string, error) {\n@@ -135,6 +135,15 @@ func prepareTunnelConfig(\n \ttransportProtocol := c.String(\"protocol\")\n \n \tclientFeatures := features.Dedup(append(c.StringSlice(\"features\"), features.DefaultFeatures...))\n+\tif c.Bool(config.DisableRemoteConfigFlag) {\n+\t\tlog.Info().Msg(\"Remote configuration disabled\")\n+\t\tfor i, feature := range clientFeatures {\n+\t\t\tif feature == features.FeatureAllowRemoteConfig {\n+\t\t\t\tclientFeatures = append(clientFeatures[:i], clientFeatures[i+1:]...)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n \n \tstaticFeatures := features.StaticFeatures{}\n \tif c.Bool(\"post-quantum\") {\n---\nconfig/configuration.go\n@@ -41,6 +41,9 @@ var (\n const (\n \t// BastionFlag is to enable bastion, or jump host, operation\n \tBastionFlag = \"bastion\"\n+\n+\t// DisableRemoteConfigFlag is to disable remote configuration\n+\tDisableRemoteConfigFlag = \"no-remote-config\"\n )\n \n // DefaultConfigDirectory returns the default directory of the config file\n---\norchestration/orchestrator.go\n@@ -17,6 +17,11 @@ import (\n \ttunnelpogs \"github.com/cloudflare/cloudflared/tunnelrpc/pogs\"\n )\n \n+const (\n+\t// Get disableRemoteConfigFlag const from cloudflared/config as the package is later shadowed by a variable\n+\tdisableRemoteConfigFlag = config.DisableRemoteConfigFlag\n+)\n+\n // Orchestrator manages configurations so they can be updatable during runtime\n // properties are static, so it can be read without lock\n // currentVersion and config are read/write infrequently, so their access are synchronized with RWMutex\n@@ -64,6 +69,15 @@ func (o *Orchestrator) UpdateConfig(version int32, config []byte) *tunnelpogs.Up\n \to.lock.Lock()\n \tdefer o.lock.Unlock()\n \n+\tif _, ok := o.config.ConfigurationFlags[disableRemoteConfigFlag]; ok {\n+\t\to.log.Warn().\n+\t\t\tInt32(\"version\", version).\n+\t\t\tMsg(\"Ignoring update because remote configuration is disabled\")\n+\t\treturn &tunnelpogs.UpdateConfigurationResponse{\n+\t\t\tLastAppliedVersion: o.currentVersion,\n+\t\t}\n+\t}\n+\n \tif o.currentVersion >= version {\n \t\to.log.Debug().\n \t\t\tInt32(\"current_version\", o.currentVersion).\n---\norchestration/orchestrator_test.go\n@@ -222,6 +222,32 @@ func TestUpdateConfiguration_WithoutIngressRule(t *testing.T) {\n \trequire.Len(t, orchestrator.config.Ingress.Rules, 1)\n }\n \n+// Validates that the configuration won't be updated if a locally managed tunnel with remote configuration disabled \n+// receives a configuration update from the remote.\n+func TestUpdateConfigurationWithRemoteConfigDisabled(t *testing.T) {\n[[MASK]]\n+\trequire.NoError(t, err)\n+\n+\tconfigJSONV1 := []byte(`\n+{\n+\t\"ingress\": [\n+\t\t{\n+\t\t\t\"service\": \"http_status:404\"\n+\t\t}\n+\t],\n+\t\"warp-routing\": {\n+\t}\n+}\n+`)\n+\tresp := orchestrator.UpdateConfig(1, configJSONV1)\n+\trequire.NoError(t, resp.Err)\n+\trequire.Equal(t, int32(-1), resp.LastAppliedVersion)\n+}\n+\n // TestConcurrentUpdateAndRead makes sure orchestrator can receive updates and return origin proxy concurrently\n func TestConcurrentUpdateAndRead(t *testing.T) {\n \tconst (\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/cmd.go\n@@ -782,6 +782,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_MANAGEMENT_DIAGNOSTICS\"},\n \t\t\tValue:   false,\n \t\t}),\n+\t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n+\t\t\tName:    config.DisableRemoteConfigFlag,\n+\t\t\tUsage:   \"Disables remote configuration from the edge\",\n+\t\t\tEnvVars: []string{\"TUNNEL_NO_REMOTE_CONFIG\"},\n+\t\t\tValue:   false,\n+\t\t}),\n \t\tselectProtocolFlag,\n \t\toverwriteDNSFlag,\n \t}...)\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -39,7 +39,7 @@ var (\n \n \tsecretFlags = [2]*altsrc.StringFlag{credentialsContentsFlag, tunnelTokenFlag}\n \n-\tconfigFlags = []string{\"autoupdate-freq\", \"no-autoupdate\", \"retries\", \"protocol\", \"loglevel\", \"transport-loglevel\", \"origincert\", \"metrics\", \"metrics-update-freq\", \"edge-ip-version\", \"edge-bind-address\"}\n+\tconfigFlags = []string{\"autoupdate-freq\", \"no-autoupdate\", \"retries\", \"protocol\", \"loglevel\", \"transport-loglevel\", \"origincert\", \"metrics\", \"metrics-update-freq\", \"edge-ip-version\", \"edge-bind-address\", config.DisableRemoteConfigFlag}\n )\n \n func generateRandomClientID(log *zerolog.Logger) (string, error) {\n@@ -135,6 +135,15 @@ func prepareTunnelConfig(\n \ttransportProtocol := c.String(\"protocol\")\n \n \tclientFeatures := features.Dedup(append(c.StringSlice(\"features\"), features.DefaultFeatures...))\n+\tif c.Bool(config.DisableRemoteConfigFlag) {\n+\t\tlog.Info().Msg(\"Remote configuration disabled\")\n+\t\tfor i, feature := range clientFeatures {\n+\t\t\tif feature == features.FeatureAllowRemoteConfig {\n+\t\t\t\tclientFeatures = append(clientFeatures[:i], clientFeatures[i+1:]...)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n \n \tstaticFeatures := features.StaticFeatures{}\n \tif c.Bool(\"post-quantum\") {\n---\nconfig/configuration.go\n@@ -41,6 +41,9 @@ var (\n const (\n \t// BastionFlag is to enable bastion, or jump host, operation\n \tBastionFlag = \"bastion\"\n+\n+\t// DisableRemoteConfigFlag is to disable remote configuration\n+\tDisableRemoteConfigFlag = \"no-remote-config\"\n )\n \n // DefaultConfigDirectory returns the default directory of the config file\n---\norchestration/orchestrator.go\n@@ -17,6 +17,11 @@ import (\n \ttunnelpogs \"github.com/cloudflare/cloudflared/tunnelrpc/pogs\"\n )\n \n+const (\n+\t// Get disableRemoteConfigFlag const from cloudflared/config as the package is later shadowed by a variable\n+\tdisableRemoteConfigFlag = config.DisableRemoteConfigFlag\n+)\n+\n // Orchestrator manages configurations so they can be updatable during runtime\n // properties are static, so it can be read without lock\n // currentVersion and config are read/write infrequently, so their access are synchronized with RWMutex\n@@ -64,6 +69,15 @@ func (o *Orchestrator) UpdateConfig(version int32, config []byte) *tunnelpogs.Up\n \to.lock.Lock()\n \tdefer o.lock.Unlock()\n \n+\tif _, ok := o.config.ConfigurationFlags[disableRemoteConfigFlag]; ok {\n+\t\to.log.Warn().\n+\t\t\tInt32(\"version\", version).\n+\t\t\tMsg(\"Ignoring update because remote configuration is disabled\")\n+\t\treturn &tunnelpogs.UpdateConfigurationResponse{\n+\t\t\tLastAppliedVersion: o.currentVersion,\n+\t\t}\n+\t}\n+\n \tif o.currentVersion >= version {\n \t\to.log.Debug().\n \t\t\tInt32(\"current_version\", o.currentVersion).\n---\norchestration/orchestrator_test.go\n@@ -222,6 +222,32 @@ func TestUpdateConfiguration_WithoutIngressRule(t *testing.T) {\n \trequire.Len(t, orchestrator.config.Ingress.Rules, 1)\n }\n \n+// Validates that the configuration won't be updated if a locally managed tunnel with remote configuration disabled \n+// receives a configuration update from the remote.\n+func TestUpdateConfigurationWithRemoteConfigDisabled(t *testing.T) {\n+\tinitConfig := &Config{\n+\t\tIngress: &ingress.Ingress{},\n+\t\tConfigurationFlags: map[string]string{config.DisableRemoteConfigFlag: \"true\"},\n+\t}\n+\torchestrator, err := NewOrchestrator(context.Background(), initConfig, testTags, []ingress.Rule{}, &testLogger)\n+\trequire.NoError(t, err)\n+\n+\tconfigJSONV1 := []byte(`\n+{\n+\t\"ingress\": [\n+\t\t{\n+\t\t\t\"service\": \"http_status:404\"\n+\t\t}\n+\t],\n+\t\"warp-routing\": {\n+\t}\n+}\n+`)\n+\tresp := orchestrator.UpdateConfig(1, configJSONV1)\n+\trequire.NoError(t, resp.Err)\n+\trequire.Equal(t, int32(-1), resp.LastAppliedVersion)\n+}\n+\n // TestConcurrentUpdateAndRead makes sure orchestrator can receive updates and return origin proxy concurrently\n func TestConcurrentUpdateAndRead(t *testing.T) {\n \tconst (\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Nil pointer dereference panic when passing \"null\" config json to `cloudflared tunnel ingress validate`\n\nDescription: Hi\r\n\r\nCalling `cloudflared tunnel ingress validate --json \"null\"` causes the `cloudflared` process to crash with the following error:\r\n\r\n```\r\n# ./cloudflared tunnel ingress validate --json \"null\"\r\nValidating rules from cmdline flag --json\r\npanic: runtime error: invalid memory address or nil pointer dereference\r\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x18 pc=0xf154b3]\r\n\r\ngoroutine 1 [running]:\r\ngithub.com/cloudflare/cloudflared/ingress.ParseIngress(_)\r\n        /workspaces/cloudflared/ingress/ingress.go:88 +0x53\r\ngithub.com/cloudflare/cloudflared/cmd/cloudflared/tunnel.validateIngressCommand(0x7cda9c?, {0x0, 0x0})\r\n        /workspaces/cloudflared/cmd/cloudflared/tunnel/ingress_subcommands.go:88 +0x78\r\ngithub.com/cloudflare/cloudflared/cmd/cloudflared/cliutil.ConfiguredActionWithWarnings.func1(0xc00061dba8?)\r\n        /workspaces/cloudflared/cmd/cloudflared/cliutil/handler.go:31 +0x51\r\ngithub.com/cloudflare/cloudflared/cmd/cloudflared/cliutil.WithErrorHandler.func1(0xc000645cc0)\r\n        /workspaces/cloudflared/cmd/cloudflared/cliutil/errors.go:27 +0x37\r\ngithub.com/urfave/cli/v2.(*Command).Run(0xc0002b7b00, 0xc000645b80)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/command.go:163 +0x476\r\ngithub.com/urfave/cli/v2.(*App).RunAsSubcommand(0xc000284b60, 0xc000645ac0)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/app.go:434 +0xb36\r\ngithub.com/urfave/cli/v2.(*Command).startApp(0xc0002b7d40, 0xc000645ac0)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/command.go:279 +0x753\r\ngithub.com/urfave/cli/v2.(*Command).Run(0xc0005faa80?, 0x59?)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/command.go:94 +0xaa\r\ngithub.com/urfave/cli/v2.(*App).RunAsSubcommand(0xc000284820, 0xc000644100)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/app.go:434 +0xb36\r\ngithub.com/urfave/cli/v2.(*Command).startApp(0xc000626480, 0xc000644100)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/command.go:279 +0x753\r\ngithub.com/urfave/cli/v2.(*Command).Run(0xc0005fa000?, 0x5a?)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/command.go:94 +0xaa\r\ngithub.com/urfave/cli/v2.(*App).RunContext(0xc0002844e0, {0x13e5f28?, 0xc0000c4000}, {0xc0000ca120, 0x6, 0x6})\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/app.go:313 +0x9c7\r\ngithub.com/urfave/cli/v2.(*App).Run(...)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/app.go:224\r\nmain.runApp(0xc0002844e0, 0xe?)\r\n        /workspaces/cloudflared/cmd/cloudflared/linux_service.go:38 +0x2e5\r\nmain.main()\r\n        /workspaces/cloudflared/cmd/cloudflared/main.go:94 +0x96b\r\n```\r\n\r\nThe same error is also able to be triggered through the Cloudflare REST API:\r\n\r\n```http\r\nPUT https://api.cloudflare.com/client/v4/accounts/{{accountId}}/cfd_tunnel/{{tunnelId}}/configurations\r\n{\r\n    \"config\": null\r\n}\r\n```\r\n\r\n```json\r\n{\r\n    \"success\": false,\r\n    \"errors\": [\r\n        {\r\n            \"code\": 1056,\r\n            \"message\": \"Bad Configuration: panic: runtime error: invalid memory address or nil pointer dereference\\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x18 pc=0xf0ab73]\\n\\ngoroutine 1 [running]:\\ngithub.com/cloudflare/cloudflared/ingress.ParseIngress(_)\\n\\t/cfsetup_build/ingress/ingress.go:88 ...\"\r\n        }\r\n    ],\r\n    \"messages\": [],\r\n    \"result\": null\r\n}\r\n```\r\n\r\nThis PR adds a `nil` check to the configuration in `ParseIngress`.\n\nCode Diff:\ningress/ingress.go\n@@ -85,7 +85,7 @@ type Ingress struct {\n \n[[MASK]]\n \t}\n \treturn validateIngress(conf.Ingress, originRequestFromConfig(conf.OriginRequest))\n---\ningress/ingress_test.go\n@@ -43,6 +43,11 @@ ingress:\n \trequire.Equal(t, \"https\", s.scheme)\n }\n \n+func TestParseIngressNilConfig(t *testing.T) {\n+\t_, err := ParseIngress(nil)\n+\trequire.Error(t, err)\n+}\n+\n func TestParseIngress(t *testing.T) {\n \tlocalhost8000 := MustParseURL(t, \"https://localhost:8000\")\n \tlocalhost8001 := MustParseURL(t, \"https://localhost:8001\")\n---\n\n"}], "ideal": "ingress/ingress.go\n@@ -85,7 +85,7 @@ type Ingress struct {\n \n // ParseIngress parses ingress rules, but does not send HTTP requests to the origins.\n func ParseIngress(conf *config.Configuration) (Ingress, error) {\n-\tif len(conf.Ingress) == 0 {\n+\tif conf == nil || len(conf.Ingress) == 0 {\n \t\treturn Ingress{}, ErrNoIngressRules\n \t}\n \treturn validateIngress(conf.Ingress, originRequestFromConfig(conf.OriginRequest))\n---\ningress/ingress_test.go\n@@ -43,6 +43,11 @@ ingress:\n \trequire.Equal(t, \"https\", s.scheme)\n }\n \n+func TestParseIngressNilConfig(t *testing.T) {\n+\t_, err := ParseIngress(nil)\n+\trequire.Error(t, err)\n+}\n+\n func TestParseIngress(t *testing.T) {\n \tlocalhost8000 := MustParseURL(t, \"https://localhost:8000\")\n \tlocalhost8001 := MustParseURL(t, \"https://localhost:8001\")\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Build with still supported Go 1.20\n\nDescription: Minimal changes to migrate everything from unsupported Go 1.19 to 1.20\r\n\r\nGo 1.20 compatibility was fixed since v2023.5.1 via [TUN-7227: Migrate to devincarr/quic-go](https://github.com/cloudflare/cloudflared/commit/9426b603082905d0af8a07bdac866bc1d9c37cba)\r\n\r\nRelated issues & PRs:\r\n* Fixes #1047\r\n* Closes #1027 (that one just bumps running checks to Go 1.20 and 0e0c286 is included in this PR )\r\n* Further work will be needed to support Go 1.21: #1043\n\nCode Diff:\n.github/workflows/check.yaml\n@@ -4,7 +4,7 @@ jobs:\n   check:\n     strategy:\n       matrix:\n-        go-version: [1.19.x]\n+        go-version: [1.20.x]\n         os: [ubuntu-latest, macos-latest, windows-latest]\n     runs-on: ${{ matrix.os }}\n     steps:\n---\nDockerfile\n@@ -1,7 +1,7 @@\n # use a builder image for building cloudflare\n ARG TARGET_GOOS\n ARG TARGET_GOARCH\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \\\n     TARGET_GOOS=${TARGET_GOOS} \\\n---\nDockerfile.amd64\n@@ -1,5 +1,5 @@\n # use a builder image for building cloudflare\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n[[MASK]]\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n---\ncfsetup.yaml\n@@ -1,5 +1,5 @@\n-pinned_go: &pinned_go go=1.19.6-1\n-pinned_go_fips: &pinned_go_fips go-boring=1.19.6-1\n+pinned_go: &pinned_go go=1.20.7-1\n+pinned_go_fips: &pinned_go_fips go-boring=1.20.7-1\n \n build_dir: &build_dir /cfsetup_build\n default-flavor: bullseye\n---\ndev.Dockerfile\n@@ -1,4 +1,4 @@\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n---\ngo.mod\n@@ -1,6 +1,6 @@\n module github.com/cloudflare/cloudflared\n \n-go 1.19\n+go 1.20\n \n require (\n \tgithub.com/cloudflare/brotli-go v0.0.0-20191101163834-d34379f7ff93\n---\n\n"}], "ideal": ".github/workflows/check.yaml\n@@ -4,7 +4,7 @@ jobs:\n   check:\n     strategy:\n       matrix:\n-        go-version: [1.19.x]\n+        go-version: [1.20.x]\n         os: [ubuntu-latest, macos-latest, windows-latest]\n     runs-on: ${{ matrix.os }}\n     steps:\n---\nDockerfile\n@@ -1,7 +1,7 @@\n # use a builder image for building cloudflare\n ARG TARGET_GOOS\n ARG TARGET_GOARCH\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \\\n     TARGET_GOOS=${TARGET_GOOS} \\\n---\nDockerfile.amd64\n@@ -1,5 +1,5 @@\n # use a builder image for building cloudflare\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n---\nDockerfile.arm64\n@@ -1,5 +1,5 @@\n # use a builder image for building cloudflare\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n---\ncfsetup.yaml\n@@ -1,5 +1,5 @@\n-pinned_go: &pinned_go go=1.19.6-1\n-pinned_go_fips: &pinned_go_fips go-boring=1.19.6-1\n+pinned_go: &pinned_go go=1.20.7-1\n+pinned_go_fips: &pinned_go_fips go-boring=1.20.7-1\n \n build_dir: &build_dir /cfsetup_build\n default-flavor: bullseye\n---\ndev.Dockerfile\n@@ -1,4 +1,4 @@\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n---\ngo.mod\n@@ -1,6 +1,6 @@\n module github.com/cloudflare/cloudflared\n \n-go 1.19\n+go 1.20\n \n require (\n \tgithub.com/cloudflare/brotli-go v0.0.0-20191101163834-d34379f7ff93\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: http2 tunnel support socks5 proxy from env all_proxy\n\nDescription: close #350 #1025\n\nCode Diff:\nedgediscovery/dial.go\n@@ -7,6 +7,7 @@ import (\n \t\"time\"\n \n \t\"github.com/pkg/errors\"\n+\t\"golang.org/x/net/proxy\"\n )\n[[MASK]]\n ) (net.Conn, error) {\n-\t// Inherit from parent context so we can cancel (Ctrl-C) while dialing\n-\tdialCtx, dialCancel := context.WithTimeout(ctx, timeout)\n-\tdefer dialCancel()\n-\n \tdialer := net.Dialer{}\n \tif localIP != nil {\n \t\tdialer.LocalAddr = &net.TCPAddr{IP: localIP, Port: 0}\n \t}\n-\tedgeConn, err := dialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\tproxyDialer := proxy.FromEnvironmentUsing(&dialer)\n+\n+\tvar edgeConn net.Conn\n+\tvar err error\n+\n+\tctxDialer, ok := proxyDialer.(interface {\n+\t\tDialContext(context.Context, string, string) (net.Conn, error)\n+\t})\n+\tif ok {\n+\t\t// Inherit from parent context so we can cancel (Ctrl-C) while dialing\n+\t\tdialCtx, dialCancel := context.WithTimeout(ctx, timeout)\n+\t\tdefer dialCancel()\n+\t\tedgeConn, err = ctxDialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\t} else {\n+\t\tedgeConn, err = proxyDialer.Dial(\"tcp\", edgeTCPAddr.String())\n+\t}\n \tif err != nil {\n \t\treturn nil, newDialError(err, \"DialContext error\")\n \t}\n---\n\n"}], "ideal": "edgediscovery/dial.go\n@@ -7,6 +7,7 @@ import (\n \t\"time\"\n \n \t\"github.com/pkg/errors\"\n+\t\"golang.org/x/net/proxy\"\n )\n \n // DialEdgeWithH2Mux makes a TLS connection to a Cloudflare edge node\n@@ -17,15 +18,26 @@ func DialEdge(\n \tedgeTCPAddr *net.TCPAddr,\n \tlocalIP net.IP,\n ) (net.Conn, error) {\n-\t// Inherit from parent context so we can cancel (Ctrl-C) while dialing\n-\tdialCtx, dialCancel := context.WithTimeout(ctx, timeout)\n-\tdefer dialCancel()\n-\n \tdialer := net.Dialer{}\n \tif localIP != nil {\n \t\tdialer.LocalAddr = &net.TCPAddr{IP: localIP, Port: 0}\n \t}\n-\tedgeConn, err := dialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\tproxyDialer := proxy.FromEnvironmentUsing(&dialer)\n+\n+\tvar edgeConn net.Conn\n+\tvar err error\n+\n+\tctxDialer, ok := proxyDialer.(interface {\n+\t\tDialContext(context.Context, string, string) (net.Conn, error)\n+\t})\n+\tif ok {\n+\t\t// Inherit from parent context so we can cancel (Ctrl-C) while dialing\n+\t\tdialCtx, dialCancel := context.WithTimeout(ctx, timeout)\n+\t\tdefer dialCancel()\n+\t\tedgeConn, err = ctxDialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\t} else {\n+\t\tedgeConn, err = proxyDialer.Dial(\"tcp\", edgeTCPAddr.String())\n+\t}\n \tif err != nil {\n \t\treturn nil, newDialError(err, \"DialContext error\")\n \t}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Add WARP routing flag\n\nDescription: Closes https://github.com/cloudflare/cloudflared/issues/1010.\n\nCode Diff:\ncmd/cloudflared/tunnel/cmd.go\n@@ -776,6 +776,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_POST_QUANTUM\"},\n \t\t\tHidden:  FipsEnabled,\n \t\t}),\n+\t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n+\t\t\tName:    \"warp-routing\",\n+\t\t\tUsage:   \"Enable WARP routing\",\n+\t\t\tEnvVars: []string{\"TUNNEL_WARP_ROUTING\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n \t\t\tName:    \"management-diagnostics\",\n \t\t\tUsage:   \"Enables the in-depth diagnostic routes to be made available over the management service (/debug/pprof, /metrics, etc.)\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -253,6 +253,9 @@ func prepareTunnelConfig(\n[[MASK]]\n+\t}\n \treturn tunnelConfig, orchestratorConfig, nil\n }\n \n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/cmd.go\n@@ -776,6 +776,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_POST_QUANTUM\"},\n \t\t\tHidden:  FipsEnabled,\n \t\t}),\n+\t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n+\t\t\tName:    \"warp-routing\",\n+\t\t\tUsage:   \"Enable WARP routing\",\n+\t\t\tEnvVars: []string{\"TUNNEL_WARP_ROUTING\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n \t\t\tName:    \"management-diagnostics\",\n \t\t\tUsage:   \"Enables the in-depth diagnostic routes to be made available over the management service (/debug/pprof, /metrics, etc.)\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -253,6 +253,9 @@ func prepareTunnelConfig(\n \t\tWarpRouting:        ingress.NewWarpRoutingConfig(&cfg.WarpRouting),\n \t\tConfigurationFlags: parseConfigFlags(c),\n \t}\n+\tif c.Bool(\"warp-routing\") {\n+\t\torchestratorConfig.WarpRouting.Enabled = true\n+\t}\n \treturn tunnelConfig, orchestratorConfig, nil\n }\n \n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: fix: erroneous error message for host validation\n\nDescription: when crafting an ingress YAML file by hand its easy to write the following by mistake:\r\n```yaml\r\ningress:\r\n  - hostname: https://example.com\r\n    service: http://localhost:50100\r\n  - service: http_status:404\r\n```\r\n\r\n`cloudflared` would report the error: `Hostname cannot contain a port`\r\n\r\nthis confused me for a few minutes before i compared two configs and saw my mistake. this change introduces a check prior to port splitting to see if the hostname contains a protocol and reports a relevant error\n\nCode Diff:\ningress/ingress.go\n@@ -24,6 +24,7 @@ var (\n \terrLastRuleNotCatchAll        = errors.New(\"The last ingress rule must match all URLs (i.e. it should not have a hostname or path filter)\")\n \terrBadWildcard                = errors.New(\"Hostname patterns can have at most one wildcard character (\\\"*\\\") and it can only be used for subdomains, e.g. \\\"*.example.com\\\"\")\n \terrHostnameContainsPort       = errors.New(\"Hostname cannot contain a port\")\n+\terrHostnameContainsScheme     = errors.New(\"Hostname cannot contain a scheme (e.g. http://, https://, etc.)\")\n \tErrURLIncompatibleWithIngress = errors.New(\"You can't set the --url flag (or $TUNNEL_URL) when using multiple-origin ingress rules\")\n[[MASK]]\n func validateHostname(r config.UnvalidatedIngressRule, ruleIndex, totalRules int) error {\n+\t// Ensure the hostname doesn't contain a scheme so a less confusing error is returned.\n+\tif u, e := url.Parse(r.Hostname); e == nil && isHTTPService(u) {\n+\t\treturn errHostnameContainsScheme\n+\t}\n \t// Ensure that the hostname doesn't contain port\n \t_, _, err := net.SplitHostPort(r.Hostname)\n \tif err == nil {\n---\n\n"}], "ideal": "ingress/ingress.go\n@@ -24,6 +24,7 @@ var (\n \terrLastRuleNotCatchAll        = errors.New(\"The last ingress rule must match all URLs (i.e. it should not have a hostname or path filter)\")\n \terrBadWildcard                = errors.New(\"Hostname patterns can have at most one wildcard character (\\\"*\\\") and it can only be used for subdomains, e.g. \\\"*.example.com\\\"\")\n \terrHostnameContainsPort       = errors.New(\"Hostname cannot contain a port\")\n+\terrHostnameContainsScheme     = errors.New(\"Hostname cannot contain a scheme (e.g. http://, https://, etc.)\")\n \tErrURLIncompatibleWithIngress = errors.New(\"You can't set the --url flag (or $TUNNEL_URL) when using multiple-origin ingress rules\")\n )\n \n@@ -359,6 +360,10 @@ func validateIngress(ingress []config.UnvalidatedIngressRule, defaults OriginReq\n }\n \n func validateHostname(r config.UnvalidatedIngressRule, ruleIndex, totalRules int) error {\n+\t// Ensure the hostname doesn't contain a scheme so a less confusing error is returned.\n+\tif u, e := url.Parse(r.Hostname); e == nil && isHTTPService(u) {\n+\t\treturn errHostnameContainsScheme\n+\t}\n \t// Ensure that the hostname doesn't contain port\n \t_, _, err := net.SplitHostPort(r.Hostname)\n \tif err == nil {\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: \u2795 Dockerfile.arm to support arm 32bit\n\nDescription: - [x] had to build it on my AllWinner H2 SoC which is running arm 32bit \r\n- [x] it is working with no issues\r\n- [x] it took some time to build dependencies \u2013 would be nice to have it accessible from docker registry cause it will require some effort when new version of cloudflared is out to rebuild....\n\nCode Diff:\n.docker-images\n@@ -10,3 +10,4 @@ images:\n     architectures:\n     - amd64\n[[MASK]]\n+# use a builder image for building cloudflare\n+FROM golang:1.20.6 as builder\n+ENV GO111MODULE=on \\\n+    CGO_ENABLED=0 \n+    \n+WORKDIR /go/src/github.com/cloudflare/cloudflared/\n+\n+# copy our sources into the builder image\n+COPY . .\n+\n+# compile cloudflared\n+RUN GOOS=linux GOARCH=arm make cloudflared\n+\n+# use a distroless base image with glibc\n+FROM gcr.io/distroless/base-debian11:nonroot-arm\n+\n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n+# copy our compiled binary\n+COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+\n+# run as non-privileged user\n+USER nonroot\n+\n+# command / entrypoint of container\n+ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n+CMD [\"version\"]\n---\n\n"}], "ideal": ".docker-images\n@@ -10,3 +10,4 @@ images:\n     architectures:\n     - amd64\n     - arm64\n+    - arm\n---\nDockerfile.arm\n@@ -0,0 +1,27 @@\n+# use a builder image for building cloudflare\n+FROM golang:1.20.6 as builder\n+ENV GO111MODULE=on \\\n+    CGO_ENABLED=0 \n+    \n+WORKDIR /go/src/github.com/cloudflare/cloudflared/\n+\n+# copy our sources into the builder image\n+COPY . .\n+\n+# compile cloudflared\n+RUN GOOS=linux GOARCH=arm make cloudflared\n+\n+# use a distroless base image with glibc\n+FROM gcr.io/distroless/base-debian11:nonroot-arm\n+\n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n+# copy our compiled binary\n+COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+\n+# run as non-privileged user\n+USER nonroot\n+\n+# command / entrypoint of container\n+ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n+CMD [\"version\"]\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: AUTH-4887 Add aud parameter to token transfer url\n\nDescription: This is an optional parameter that helps the /cdn-cgi/access/cli endpoint save some work figuring out which app it's doing the token transfer for. If not provided, it can figure that out on its own, like it currently does today.\n\nCode Diff:\ncmd/cloudflared/tunnel/login.go\n@@ -52,6 +52,7 @@ func login(c *cli.Context) error {\n \n \tresourceData, err := token.RunTransfer(\n \t\tloginURL,\n+\t\t\"\",\n \t\t\"cert\",\n \t\t\"callback\",\n \t\tcallbackStoreURL,\n---\ntoken/token.go\n@@ -214,19 +214,19 @@ func getToken(appURL *url.URL, appInfo *AppInfo, useHostOnly bool, log *zerolog.\n \t\t\treturn appToken, nil\n \t\t}\n \t}\n-\treturn getTokensFromEdge(appURL, appTokenPath, orgTokenPath, useHostOnly, log)\n+\treturn getTokensFromEdge(appURL, appInfo.AppAUD, appTokenPath, orgTokenPath, useHostOnly, log)\n \n }\n \n // getTokensFromEdge will attempt to use the transfer service to retrieve an app and org token, save them to disk,\n // and return the app token.\n-func getTokensFromEdge(appURL *url.URL, appTokenPath, orgTokenPath string, useHostOnly bool, log *zerolog.Logger) (string, error) {\n+func getTokensFromEdge(appURL *url.URL, appAUD, appTokenPath, orgTokenPath string, useHostOnly bool, log *zerolog.Logger) (string, error) {\n \t// If no org token exists or if it couldn't be exchanged for an app token, then run the transfer service flow.\n \n \t// this weird parameter is the resource name (token) and the key/value\n \t// we want to send to the transfer service. the key is token and the value\n \t// is blank (basically just the id generated in the transfer service)\n-\tresourceData, err := RunTransfer(appURL, keyName, keyName, \"\", true, useHostOnly, log)\n+\tresourceData, err := RunTransfer(appURL, appAUD, keyName, keyName, \"\", true, useHostOnly, log)\n \tif err != nil {\n \t\treturn \"\", errors.Wrap(err, \"failed to run transfer service\")\n \t}\n---\ntoken/transfer.go\n@@ -25,12 +25,12 @@ const (\n // The \"dance\" we refer to is building a HTTP request, opening that in a browser waiting for\n[[MASK]]\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\trequestURL, err := buildRequestURL(transferURL, key, value+encrypterClient.PublicKey(), shouldEncrypt, useHostOnly)\n+\trequestURL, err := buildRequestURL(transferURL, appAUD, key, value+encrypterClient.PublicKey(), shouldEncrypt, useHostOnly)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -76,9 +76,10 @@ func RunTransfer(transferURL *url.URL, resourceName, key, value string, shouldEn\n // BuildRequestURL creates a request suitable for a resource transfer.\n // it will return a constructed url based off the base url and query key/value provided.\n // cli will build a url for cli transfer request.\n-func buildRequestURL(baseURL *url.URL, key, value string, cli, useHostOnly bool) (string, error) {\n+func buildRequestURL(baseURL *url.URL, appAUD string, key, value string, cli, useHostOnly bool) (string, error) {\n \tq := baseURL.Query()\n \tq.Set(key, value)\n+\tq.Set(\"aud\", appAUD)\n \tbaseURL.RawQuery = q.Encode()\n \tif useHostOnly {\n \t\tbaseURL.Path = \"\"\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/login.go\n@@ -52,6 +52,7 @@ func login(c *cli.Context) error {\n \n \tresourceData, err := token.RunTransfer(\n \t\tloginURL,\n+\t\t\"\",\n \t\t\"cert\",\n \t\t\"callback\",\n \t\tcallbackStoreURL,\n---\ntoken/token.go\n@@ -214,19 +214,19 @@ func getToken(appURL *url.URL, appInfo *AppInfo, useHostOnly bool, log *zerolog.\n \t\t\treturn appToken, nil\n \t\t}\n \t}\n-\treturn getTokensFromEdge(appURL, appTokenPath, orgTokenPath, useHostOnly, log)\n+\treturn getTokensFromEdge(appURL, appInfo.AppAUD, appTokenPath, orgTokenPath, useHostOnly, log)\n \n }\n \n // getTokensFromEdge will attempt to use the transfer service to retrieve an app and org token, save them to disk,\n // and return the app token.\n-func getTokensFromEdge(appURL *url.URL, appTokenPath, orgTokenPath string, useHostOnly bool, log *zerolog.Logger) (string, error) {\n+func getTokensFromEdge(appURL *url.URL, appAUD, appTokenPath, orgTokenPath string, useHostOnly bool, log *zerolog.Logger) (string, error) {\n \t// If no org token exists or if it couldn't be exchanged for an app token, then run the transfer service flow.\n \n \t// this weird parameter is the resource name (token) and the key/value\n \t// we want to send to the transfer service. the key is token and the value\n \t// is blank (basically just the id generated in the transfer service)\n-\tresourceData, err := RunTransfer(appURL, keyName, keyName, \"\", true, useHostOnly, log)\n+\tresourceData, err := RunTransfer(appURL, appAUD, keyName, keyName, \"\", true, useHostOnly, log)\n \tif err != nil {\n \t\treturn \"\", errors.Wrap(err, \"failed to run transfer service\")\n \t}\n---\ntoken/transfer.go\n@@ -25,12 +25,12 @@ const (\n // The \"dance\" we refer to is building a HTTP request, opening that in a browser waiting for\n // the user to complete an action, while it long polls in the background waiting for an\n // action to be completed to download the resource.\n-func RunTransfer(transferURL *url.URL, resourceName, key, value string, shouldEncrypt bool, useHostOnly bool, log *zerolog.Logger) ([]byte, error) {\n+func RunTransfer(transferURL *url.URL, appAUD, resourceName, key, value string, shouldEncrypt bool, useHostOnly bool, log *zerolog.Logger) ([]byte, error) {\n \tencrypterClient, err := NewEncrypter(\"cloudflared_priv.pem\", \"cloudflared_pub.pem\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\trequestURL, err := buildRequestURL(transferURL, key, value+encrypterClient.PublicKey(), shouldEncrypt, useHostOnly)\n+\trequestURL, err := buildRequestURL(transferURL, appAUD, key, value+encrypterClient.PublicKey(), shouldEncrypt, useHostOnly)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -76,9 +76,10 @@ func RunTransfer(transferURL *url.URL, resourceName, key, value string, shouldEn\n // BuildRequestURL creates a request suitable for a resource transfer.\n // it will return a constructed url based off the base url and query key/value provided.\n // cli will build a url for cli transfer request.\n-func buildRequestURL(baseURL *url.URL, key, value string, cli, useHostOnly bool) (string, error) {\n+func buildRequestURL(baseURL *url.URL, appAUD string, key, value string, cli, useHostOnly bool) (string, error) {\n \tq := baseURL.Query()\n \tq.Set(key, value)\n+\tq.Set(\"aud\", appAUD)\n \tbaseURL.RawQuery = q.Encode()\n \tif useHostOnly {\n \t\tbaseURL.Path = \"\"\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Incoming request ended abruptly as debug message\n\nDescription: closes #908\n\nCode Diff:\nproxy/proxy.go\n@@ -33,6 +33,10 @@ const (\n \ttrailerHeaderName = \"Trailer\"\n )\n[[MASK]]\n // Proxy represents a means to Proxy between cloudflared and the origin services.\n type Proxy struct {\n \tingressRules ingress.Ingress\n@@ -123,7 +127,11 @@ func (p *Proxy) ProxyHTTP(\n \t\t\tlogFields,\n \t\t); err != nil {\n \t\t\trule, srv := ruleField(p.ingressRules, ruleNum)\n-\t\t\tp.logRequestError(err, cfRay, \"\", rule, srv)\n+\t\t\tif errors.Is(err, ErrRequestEndedAbruptly) {\n+\t\t\t\tp.log.Debug().Msg(err.Error())\n+\t\t\t} else {\n+\t\t\t\tp.logRequestError(err, cfRay, \"\", rule, srv)\n+\t\t\t}\n \t\t\treturn err\n \t\t}\n \t\treturn nil\n@@ -225,7 +233,7 @@ func (p *Proxy) proxyHTTPRequest(\n \tif err != nil {\n \t\ttracing.EndWithErrorStatus(ttfbSpan, err)\n \t\tif err := roundTripReq.Context().Err(); err != nil {\n-\t\t\treturn errors.Wrap(err, \"Incoming request ended abruptly\")\n+\t\t\treturn ErrRequestEndedAbruptly\n \t\t}\n \t\treturn errors.Wrap(err, \"Unable to reach the origin service. The service may be down or it may not be responding to traffic from cloudflared\")\n \t}\n---\n\n"}], "ideal": "proxy/proxy.go\n@@ -33,6 +33,10 @@ const (\n \ttrailerHeaderName = \"Trailer\"\n )\n \n+var (\n+\tErrRequestEndedAbruptly = errors.New(\"Incoming request ended abruptly\")\n+)\n+\n // Proxy represents a means to Proxy between cloudflared and the origin services.\n type Proxy struct {\n \tingressRules ingress.Ingress\n@@ -123,7 +127,11 @@ func (p *Proxy) ProxyHTTP(\n \t\t\tlogFields,\n \t\t); err != nil {\n \t\t\trule, srv := ruleField(p.ingressRules, ruleNum)\n-\t\t\tp.logRequestError(err, cfRay, \"\", rule, srv)\n+\t\t\tif errors.Is(err, ErrRequestEndedAbruptly) {\n+\t\t\t\tp.log.Debug().Msg(err.Error())\n+\t\t\t} else {\n+\t\t\t\tp.logRequestError(err, cfRay, \"\", rule, srv)\n+\t\t\t}\n \t\t\treturn err\n \t\t}\n \t\treturn nil\n@@ -225,7 +233,7 @@ func (p *Proxy) proxyHTTPRequest(\n \tif err != nil {\n \t\ttracing.EndWithErrorStatus(ttfbSpan, err)\n \t\tif err := roundTripReq.Context().Err(); err != nil {\n-\t\t\treturn errors.Wrap(err, \"Incoming request ended abruptly\")\n+\t\t\treturn ErrRequestEndedAbruptly\n \t\t}\n \t\treturn errors.Wrap(err, \"Unable to reach the origin service. The service may be down or it may not be responding to traffic from cloudflared\")\n \t}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: GH-484: Add MajorUpgrade element to msi build definition\n\nDescription: One commit is only whitespace, so please see changes in commit https://github.com/cloudflare/cloudflared/commit/28294be470aeb39aa7c58d776494d7aed9b6ff3c\r\n\r\nI also tried to build things but the build instructions link is dead on readme.md. So untested \ud83d\ude05 \r\n\r\n#484\r\n\r\n\n\nCode Diff:\ncloudflared.wxs\n@@ -2,61 +2,63 @@\n \n <?if $(var.Platform)=\"x86\"?>\n     <?define Program_Files=\"ProgramFilesFolder\"?>\n-<?else?>\n+<?else ?>\n     <?define Program_Files=\"ProgramFiles64Folder\"?>\n-<?endif?>\n+<?endif ?>\n <?ifndef var.Version?>\n     <?error Undefined Version variable?>\n-<?endif?>\n+<?endif ?>\n <?ifndef var.Path?>\n     <?error Undefined Path variable?>\n-<?endif?>\n+<?endif ?>\n \n <Wix xmlns=\"http://schemas.microsoft.com/wix/2006/wi\">\n-    <Product Id=\"35e5e858-9372-4449-bf73-1cd6f7267128\" \n+    <Product Id=\"*\"\n         UpgradeCode=\"23f90fdd-9328-47ea-ab52-5380855a4b12\"\n         Name=\"cloudflared\"\n         Version=\"$(var.Version)\"\n         Manufacturer=\"cloudflare\"\n         Language=\"1033\">\n \n-      <Package InstallerVersion=\"200\" Compressed=\"yes\" Comments=\"Windows Installer Package\" InstallScope=\"perMachine\"/>\n+        <Package InstallerVersion=\"200\" Compressed=\"yes\" Comments=\"Windows Installer Package\" InstallScope=\"perMachine\" />\n \n-      <Media Id=\"1\" Cabinet=\"product.cab\" EmbedCab=\"yes\"/>\n+        <Media Id=\"1\" Cabinet=\"product.cab\" EmbedCab=\"yes\" />\n \n-      <Upgrade Id=\"23f90fdd-9328-47ea-ab52-5380855a4b12\">\n-         <UpgradeVersion Minimum=\"$(var.Version)\" OnlyDetect=\"yes\" Property=\"NEWERVERSIONDETECTED\"/>\n-         <UpgradeVersion Minimum=\"2020.8.0\" Maximum=\"$(var.Version)\" IncludeMinimum=\"yes\" IncludeMaximum=\"no\"\n-                         Property=\"OLDERVERSIONBEINGUPGRADED\"/>\n-      </Upgrade>\n-      <Condition Message=\"A newer version of this software is already installed.\">NOT NEWERVERSIONDETECTED</Condition>\n+        <MajorUpgrade DowngradeErrorMessage=\"A later version of [ProductName] is already installed. Setup will now exit.\" />\n \n-    <Directory Id=\"TARGETDIR\" Name=\"SourceDir\">\n-        <!--This specifies where the cloudflared.exe is moved to in the windows Operation System-->\n-        <Directory Id=\"$(var.Program_Files)\">\n-            <Directory Id=\"INSTALLDIR\" Name=\"cloudflared\">\n-                <Component Id=\"ApplicationFiles\" Guid=\"35e5e858-9372-4449-bf73-1cd6f7267128\">\n-                    <File Id=\"ApplicationFile0\" Source=\"$(var.Path)\"/>\n-                </Component>\n+        <Upgrade Id=\"23f90fdd-9328-47ea-ab52-5380855a4b12\">\n+            <UpgradeVersion Minimum=\"$(var.Version)\" OnlyDetect=\"yes\" Property=\"NEWERVERSIONDETECTED\" />\n+            <UpgradeVersion Minimum=\"2020.8.0\" Maximum=\"$(var.Version)\" IncludeMinimum=\"yes\" IncludeMaximum=\"no\"\n+                Property=\"OLDERVERSIONBEINGUPGRADED\" />\n+        </Upgrade>\n+        <Condition Message=\"A newer version of this software is already installed.\">NOT NEWERVERSIONDETECTED</Condition>\n+\n+        <Directory Id=\"TARGETDIR\" Name=\"SourceDir\">\n+            <!--This specifies where the cloudflared.exe is moved to in the windows Operation System-->\n+            <Directory Id=\"$(var.Program_Files)\">\n+                <Directory Id=\"INSTALLDIR\" Name=\"cloudflared\">\n+                    <Component Id=\"ApplicationFiles\" Guid=\"35e5e858-9372-4449-bf73-1cd6f7267128\">\n+                        <File Id=\"ApplicationFile0\" Source=\"$(var.Path)\" />\n+                    </Component>\n+                </Directory>\n             </Directory>\n+            <Component Id=\"ENVS\" Guid=\"6bb74449-d10d-4f4a-933e-6fc9fa006eae\">\n+                <!--Set the cloudflared bin location to the Path Environment Variable-->\n+                <Environment Id=\"ENV0\"\n+                    Name=\"PATH\"\n+                    Value=\"[INSTALLDIR].\"\n+                    Permanent=\"no\"\n+                    Part=\"last\"\n+                    Action=\"create\"\n+                    System=\"yes\" />\n+            </Component>\n         </Directory>\n-        <Component Id=\"ENVS\" Guid=\"6bb74449-d10d-4f4a-933e-6fc9fa006eae\">\n-        <!--Set the cloudflared bin location to the Path Environment Variable-->\n-         <Environment Id=\"ENV0\"\n-           Name=\"PATH\"\n-           Value=\"[INSTALLDIR].\"\n[[MASK]]\n-    </Directory>\n-\n-\n-    <Feature Id='Complete' Level='1'>\n-      <ComponentRef Id=\"ENVS\"/>\n-      <ComponentRef Id='ApplicationFiles' />\n-    </Feature>\n+\n+\n+        <Feature Id='Complete' Level='1'>\n+            <ComponentRef Id=\"ENVS\" />\n+            <ComponentRef Id='ApplicationFiles' />\n+        </Feature>\n \n     </Product>\n </Wix>\n---\n\n"}], "ideal": "cloudflared.wxs\n@@ -2,61 +2,63 @@\n \n <?if $(var.Platform)=\"x86\"?>\n     <?define Program_Files=\"ProgramFilesFolder\"?>\n-<?else?>\n+<?else ?>\n     <?define Program_Files=\"ProgramFiles64Folder\"?>\n-<?endif?>\n+<?endif ?>\n <?ifndef var.Version?>\n     <?error Undefined Version variable?>\n-<?endif?>\n+<?endif ?>\n <?ifndef var.Path?>\n     <?error Undefined Path variable?>\n-<?endif?>\n+<?endif ?>\n \n <Wix xmlns=\"http://schemas.microsoft.com/wix/2006/wi\">\n-    <Product Id=\"35e5e858-9372-4449-bf73-1cd6f7267128\" \n+    <Product Id=\"*\"\n         UpgradeCode=\"23f90fdd-9328-47ea-ab52-5380855a4b12\"\n         Name=\"cloudflared\"\n         Version=\"$(var.Version)\"\n         Manufacturer=\"cloudflare\"\n         Language=\"1033\">\n \n-      <Package InstallerVersion=\"200\" Compressed=\"yes\" Comments=\"Windows Installer Package\" InstallScope=\"perMachine\"/>\n+        <Package InstallerVersion=\"200\" Compressed=\"yes\" Comments=\"Windows Installer Package\" InstallScope=\"perMachine\" />\n \n-      <Media Id=\"1\" Cabinet=\"product.cab\" EmbedCab=\"yes\"/>\n+        <Media Id=\"1\" Cabinet=\"product.cab\" EmbedCab=\"yes\" />\n \n-      <Upgrade Id=\"23f90fdd-9328-47ea-ab52-5380855a4b12\">\n-         <UpgradeVersion Minimum=\"$(var.Version)\" OnlyDetect=\"yes\" Property=\"NEWERVERSIONDETECTED\"/>\n-         <UpgradeVersion Minimum=\"2020.8.0\" Maximum=\"$(var.Version)\" IncludeMinimum=\"yes\" IncludeMaximum=\"no\"\n-                         Property=\"OLDERVERSIONBEINGUPGRADED\"/>\n-      </Upgrade>\n-      <Condition Message=\"A newer version of this software is already installed.\">NOT NEWERVERSIONDETECTED</Condition>\n+        <MajorUpgrade DowngradeErrorMessage=\"A later version of [ProductName] is already installed. Setup will now exit.\" />\n \n-    <Directory Id=\"TARGETDIR\" Name=\"SourceDir\">\n-        <!--This specifies where the cloudflared.exe is moved to in the windows Operation System-->\n-        <Directory Id=\"$(var.Program_Files)\">\n-            <Directory Id=\"INSTALLDIR\" Name=\"cloudflared\">\n-                <Component Id=\"ApplicationFiles\" Guid=\"35e5e858-9372-4449-bf73-1cd6f7267128\">\n-                    <File Id=\"ApplicationFile0\" Source=\"$(var.Path)\"/>\n-                </Component>\n+        <Upgrade Id=\"23f90fdd-9328-47ea-ab52-5380855a4b12\">\n+            <UpgradeVersion Minimum=\"$(var.Version)\" OnlyDetect=\"yes\" Property=\"NEWERVERSIONDETECTED\" />\n+            <UpgradeVersion Minimum=\"2020.8.0\" Maximum=\"$(var.Version)\" IncludeMinimum=\"yes\" IncludeMaximum=\"no\"\n+                Property=\"OLDERVERSIONBEINGUPGRADED\" />\n+        </Upgrade>\n+        <Condition Message=\"A newer version of this software is already installed.\">NOT NEWERVERSIONDETECTED</Condition>\n+\n+        <Directory Id=\"TARGETDIR\" Name=\"SourceDir\">\n+            <!--This specifies where the cloudflared.exe is moved to in the windows Operation System-->\n+            <Directory Id=\"$(var.Program_Files)\">\n+                <Directory Id=\"INSTALLDIR\" Name=\"cloudflared\">\n+                    <Component Id=\"ApplicationFiles\" Guid=\"35e5e858-9372-4449-bf73-1cd6f7267128\">\n+                        <File Id=\"ApplicationFile0\" Source=\"$(var.Path)\" />\n+                    </Component>\n+                </Directory>\n             </Directory>\n+            <Component Id=\"ENVS\" Guid=\"6bb74449-d10d-4f4a-933e-6fc9fa006eae\">\n+                <!--Set the cloudflared bin location to the Path Environment Variable-->\n+                <Environment Id=\"ENV0\"\n+                    Name=\"PATH\"\n+                    Value=\"[INSTALLDIR].\"\n+                    Permanent=\"no\"\n+                    Part=\"last\"\n+                    Action=\"create\"\n+                    System=\"yes\" />\n+            </Component>\n         </Directory>\n-        <Component Id=\"ENVS\" Guid=\"6bb74449-d10d-4f4a-933e-6fc9fa006eae\">\n-        <!--Set the cloudflared bin location to the Path Environment Variable-->\n-         <Environment Id=\"ENV0\"\n-           Name=\"PATH\"\n-           Value=\"[INSTALLDIR].\"\n-           Permanent=\"no\"\n-           Part=\"last\"\n-           Action=\"create\"\n-           System=\"yes\" />\n-        </Component>\n-    </Directory>\n-\n-\n-    <Feature Id='Complete' Level='1'>\n-      <ComponentRef Id=\"ENVS\"/>\n-      <ComponentRef Id='ApplicationFiles' />\n-    </Feature>\n+\n+\n+        <Feature Id='Complete' Level='1'>\n+            <ComponentRef Id=\"ENVS\" />\n+            <ComponentRef Id='ApplicationFiles' />\n+        </Feature>\n \n     </Product>\n </Wix>\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Added automatic systemd restart given binary changes\n\nDescription: Added a systemd [Path](https://www.freedesktop.org/software/systemd/man/systemd.path.html) that observes changes in the binary and restarts the cloudflared systemd service in that case.\r\n\r\nCloses #799 \n\nCode Diff:\ncmd/cloudflared/linux_service.go\n@@ -71,7 +71,7 @@ Description=Update cloudflared\n After=network.target\n \n [Service]\n-ExecStart=/bin/bash -c '{{ .Path }} update; code=$?; if [ $code -eq 11 ]; then systemctl restart cloudflared; exit 0; fi; exit $code'\n+ExecStart=/bin/bash -c '{{ .Path }} update'\n `,\n \t},\n \t{\n@@ -84,6 +84,22 @@ OnCalendar=daily\n \n [Install]\n WantedBy=timers.target\n+`,\n+\t},\n+\t{\n+\t\tPath: \"/etc/systemd/system/cloudflared-restart.path\",\n+\t\tContent: `[Path]\n+PathChanged=/usr/bin/cloudflared\n+\n+[Install]\n+WantedBy=multi-user.target\n+`,\n+\t},\n+\t{\n+\t\tPath: \"/etc/systemd/system/cloudflared-restart.service\",\n+\t\tContent: `[Service]\n+Type=oneshot\n+ExecStart=/usr/bin/systemctl restart cloudflared\n `,\n \t},\n }\n@@ -273,6 +289,14 @@ func installSystemd(templateArgs *ServiceTemplateArgs, log *zerolog.Logger) erro\n \t\tlog.Err(err).Msgf(\"systemctl enable %s error\", cloudflaredService)\n \t\treturn err\n \t}\n+\tif err := runCommand(\"systemctl\", \"enable\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl enable cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n+\tif err := runCommand(\"systemctl\", \"start\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl start cloudflared-restart.path error\")\n[[MASK]]\n@@ -335,6 +359,14 @@ func uninstallSystemd(log *zerolog.Logger) error {\n \t\tlog.Err(err).Msgf(\"systemctl stop %s error\", cloudflaredService)\n \t\treturn err\n \t}\n+\tif err := runCommand(\"systemctl\", \"disable\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl disable cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n+\tif err := runCommand(\"systemctl\", \"stop\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl stop cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n \tif err := runCommand(\"systemctl\", \"stop\", \"cloudflared-update.timer\"); err != nil {\n \t\tlog.Err(err).Msg(\"systemctl stop cloudflared-update.timer error\")\n \t\treturn err\n---\n\n"}], "ideal": "cmd/cloudflared/linux_service.go\n@@ -71,7 +71,7 @@ Description=Update cloudflared\n After=network.target\n \n [Service]\n-ExecStart=/bin/bash -c '{{ .Path }} update; code=$?; if [ $code -eq 11 ]; then systemctl restart cloudflared; exit 0; fi; exit $code'\n+ExecStart=/bin/bash -c '{{ .Path }} update'\n `,\n \t},\n \t{\n@@ -84,6 +84,22 @@ OnCalendar=daily\n \n [Install]\n WantedBy=timers.target\n+`,\n+\t},\n+\t{\n+\t\tPath: \"/etc/systemd/system/cloudflared-restart.path\",\n+\t\tContent: `[Path]\n+PathChanged=/usr/bin/cloudflared\n+\n+[Install]\n+WantedBy=multi-user.target\n+`,\n+\t},\n+\t{\n+\t\tPath: \"/etc/systemd/system/cloudflared-restart.service\",\n+\t\tContent: `[Service]\n+Type=oneshot\n+ExecStart=/usr/bin/systemctl restart cloudflared\n `,\n \t},\n }\n@@ -273,6 +289,14 @@ func installSystemd(templateArgs *ServiceTemplateArgs, log *zerolog.Logger) erro\n \t\tlog.Err(err).Msgf(\"systemctl enable %s error\", cloudflaredService)\n \t\treturn err\n \t}\n+\tif err := runCommand(\"systemctl\", \"enable\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl enable cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n+\tif err := runCommand(\"systemctl\", \"start\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl start cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n \tif err := runCommand(\"systemctl\", \"start\", \"cloudflared-update.timer\"); err != nil {\n \t\tlog.Err(err).Msg(\"systemctl start cloudflared-update.timer error\")\n \t\treturn err\n@@ -335,6 +359,14 @@ func uninstallSystemd(log *zerolog.Logger) error {\n \t\tlog.Err(err).Msgf(\"systemctl stop %s error\", cloudflaredService)\n \t\treturn err\n \t}\n+\tif err := runCommand(\"systemctl\", \"disable\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl disable cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n+\tif err := runCommand(\"systemctl\", \"stop\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl stop cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n \tif err := runCommand(\"systemctl\", \"stop\", \"cloudflared-update.timer\"); err != nil {\n \t\tlog.Err(err).Msg(\"systemctl stop cloudflared-update.timer error\")\n \t\treturn err\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: fix: add windows specific ssh-config\n\nDescription: This attempts to fix https://github.com/cloudflare/cloudflared/issues/753\r\n\r\nThe bug occurs because windows executable uses the current working directory to do its operations while the ssh-config being generated assumes that:\r\n\r\n1. the user uses a nix machine\r\n2. the nix executable follows a different installation directory than windows. Windows uses the relative path, the nix binary gets stored in `~/.cloudflared`\n\nCode Diff:\ncmd/cloudflared/access/cmd.go\n@@ -7,6 +7,7 @@ import (\n \t\"net/url\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"runtime\"\n \t\"strings\"\n \t\"text/template\"\n \t\"time\"\n@@ -38,10 +39,21 @@ const (\n Add to your {{.Home}}/.ssh/config:\n \n {{- if .ShortLivedCerts}}\n-Match host {{.Hostname}} exec \"{{.Cloudflared}} access ssh-gen --hostname %h\"\n+Host cfpipe-{{.Hostname}}\n+{{- if eq .OS \"windows\"}}\n+  ProxyCommand {{.Cloudflared}} access ssh-gen --hostname %h && ssh -tt %r@cfpipe-{{.Hostname}} >&2 <&1\n+{{- else}}\n+  ProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt %r@cfpipe-{{.Hostname}} >&2 <&1'\n+{{end}}\n+\n+Host cfpipe-{{.Hostname}}\n+  HostName {{.Hostname}}\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n-  IdentityFile ~/.cloudflared/%h-cf_key\n-  CertificateFile ~/.cloudflared/%h-cf_key-cert.pub\n+{{- if eq .OS \"windows\"}} IdentityFile {{.CurrWorkingDir}}/{{.Hostname}}-cf_key\n+  CertificateFile {{.CurrWorkingDir}}/{{.Hostname}}-cf_key-cert.pub\n+{{- else}} IdentityFile ~/.cloudflared/{{.Hostname}}-cf_key\n+  CertificateFile ~/.cloudflared/{{.Hostname}}-cf_key-cert.pub\n+{{end}}\n {{- else}}\n Host {{.Hostname}}\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n@@ -361,6 +373,10 @@ func generateToken(c *cli.Context) error {\n \n // sshConfig prints an example SSH config to stdout\n func sshConfig(c *cli.Context) error {\n+\tcurrWorkingDirectory, err := os.Getwd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tgenCertBool := c.Bool(sshGenCertFlag)\n \thostname := c.String(sshHostnameFlag)\n \tif hostname == \"\" {\n@@ -372,10 +388,23 @@ func sshConfig(c *cli.Context) error {\n \t\tShortLivedCerts bool\n[[MASK]]\n \n \tt := template.Must(template.New(\"sshConfig\").Parse(sshConfigTemplate))\n-\treturn t.Execute(os.Stdout, config{Home: os.Getenv(\"HOME\"), ShortLivedCerts: genCertBool, Hostname: hostname, Cloudflared: cloudflaredPath()})\n+\n+\treturn t.Execute(\n+\t\tos.Stdout,\n+\t\tconfig{\n+\t\t\tHome:            os.Getenv(\"HOME\"),\n+\t\t\tShortLivedCerts: genCertBool,\n+\t\t\tHostname:        hostname,\n+\t\t\tCloudflared:     cloudflaredPath(),\n+\t\t\tCurrWorkingDir:  currWorkingDirectory,\n+\t\t\tOS:              runtime.GOOS,\n+\t\t},\n+\t)\n }\n \n // sshGen generates a short lived certificate for provided hostname\n@@ -468,6 +497,10 @@ func processURL(s string) (*url.URL, error) {\n \n // cloudflaredPath pulls the full path of cloudflared on disk\n func cloudflaredPath() string {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tabsPath, _ := os.Executable()\n+\t\treturn absPath\n+\t}\n \tfor _, p := range strings.Split(os.Getenv(\"PATH\"), \":\") {\n \t\tpath := fmt.Sprintf(\"%s/%s\", p, \"cloudflared\")\n \t\tif isFileThere(path) {\n---\n\n"}], "ideal": "cmd/cloudflared/access/cmd.go\n@@ -7,6 +7,7 @@ import (\n \t\"net/url\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"runtime\"\n \t\"strings\"\n \t\"text/template\"\n \t\"time\"\n@@ -38,10 +39,21 @@ const (\n Add to your {{.Home}}/.ssh/config:\n \n {{- if .ShortLivedCerts}}\n-Match host {{.Hostname}} exec \"{{.Cloudflared}} access ssh-gen --hostname %h\"\n+Host cfpipe-{{.Hostname}}\n+{{- if eq .OS \"windows\"}}\n+  ProxyCommand {{.Cloudflared}} access ssh-gen --hostname %h && ssh -tt %r@cfpipe-{{.Hostname}} >&2 <&1\n+{{- else}}\n+  ProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt %r@cfpipe-{{.Hostname}} >&2 <&1'\n+{{end}}\n+\n+Host cfpipe-{{.Hostname}}\n+  HostName {{.Hostname}}\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n-  IdentityFile ~/.cloudflared/%h-cf_key\n-  CertificateFile ~/.cloudflared/%h-cf_key-cert.pub\n+{{- if eq .OS \"windows\"}} IdentityFile {{.CurrWorkingDir}}/{{.Hostname}}-cf_key\n+  CertificateFile {{.CurrWorkingDir}}/{{.Hostname}}-cf_key-cert.pub\n+{{- else}} IdentityFile ~/.cloudflared/{{.Hostname}}-cf_key\n+  CertificateFile ~/.cloudflared/{{.Hostname}}-cf_key-cert.pub\n+{{end}}\n {{- else}}\n Host {{.Hostname}}\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n@@ -361,6 +373,10 @@ func generateToken(c *cli.Context) error {\n \n // sshConfig prints an example SSH config to stdout\n func sshConfig(c *cli.Context) error {\n+\tcurrWorkingDirectory, err := os.Getwd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tgenCertBool := c.Bool(sshGenCertFlag)\n \thostname := c.String(sshHostnameFlag)\n \tif hostname == \"\" {\n@@ -372,10 +388,23 @@ func sshConfig(c *cli.Context) error {\n \t\tShortLivedCerts bool\n \t\tHostname        string\n \t\tCloudflared     string\n+\t\tCurrWorkingDir  string\n+\t\tOS              string\n \t}\n \n \tt := template.Must(template.New(\"sshConfig\").Parse(sshConfigTemplate))\n-\treturn t.Execute(os.Stdout, config{Home: os.Getenv(\"HOME\"), ShortLivedCerts: genCertBool, Hostname: hostname, Cloudflared: cloudflaredPath()})\n+\n+\treturn t.Execute(\n+\t\tos.Stdout,\n+\t\tconfig{\n+\t\t\tHome:            os.Getenv(\"HOME\"),\n+\t\t\tShortLivedCerts: genCertBool,\n+\t\t\tHostname:        hostname,\n+\t\t\tCloudflared:     cloudflaredPath(),\n+\t\t\tCurrWorkingDir:  currWorkingDirectory,\n+\t\t\tOS:              runtime.GOOS,\n+\t\t},\n+\t)\n }\n \n // sshGen generates a short lived certificate for provided hostname\n@@ -468,6 +497,10 @@ func processURL(s string) (*url.URL, error) {\n \n // cloudflaredPath pulls the full path of cloudflared on disk\n func cloudflaredPath() string {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tabsPath, _ := os.Executable()\n+\t\treturn absPath\n+\t}\n \tfor _, p := range strings.Split(os.Getenv(\"PATH\"), \":\") {\n \t\tpath := fmt.Sprintf(\"%s/%s\", p, \"cloudflared\")\n \t\tif isFileThere(path) {\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Update golang.org/x/text\n\nDescription: Related to #786 \n\nCode Diff:\ngo.mod\n@@ -37,7 +37,7 @@ require (\n \tgo.uber.org/automaxprocs v1.4.0\n \tgolang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa\n \tgolang.org/x/net v0.0.0-20220909164309-bea034e7d591\n-\tgolang.org/x/sync v0.0.0-20220601150217-0de741cfad7f\n+\tgolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4\n \tgolang.org/x/sys v0.0.0-20220808155132-1c4a2a72c664\n \tgolang.org/x/term v0.0.0-20210927222741-03fcf44c2211\n \tgoogle.golang.org/protobuf v1.28.0\n@@ -89,11 +89,10 @@ require (\n \tgithub.com/prometheus/common v0.32.1 // indirect\n \tgithub.com/prometheus/procfs v0.7.3 // indirect\n \tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n-\tgolang.org/x/mod v0.4.2 // indirect\n+\tgolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4 // indirect\n \tgolang.org/x/oauth2 v0.0.0-20220822191816-0ebed06d0094 // indirect\n-\tgolang.org/x/text v0.3.7 // indirect\n-\tgolang.org/x/tools v0.1.6-0.20210726203631-07bc1bf47fb2 // indirect\n-\tgolang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f // indirect\n+\tgolang.org/x/text v0.3.8 // indirect\n+\tgolang.org/x/tools v0.1.12 // indirect\n \tgoogle.golang.org/appengine v1.6.7 // indirect\n \tgoogle.golang.org/genproto v0.0.0-20220616135557-88e70c0c3a90 // indirect\n \tgoogle.golang.org/grpc v1.47.0 // indirect\n---\ngo.sum\n@@ -681,8 +681,9 @@ golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.4.1/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n-golang.org/x/mod v0.4.2 h1:Gz96sIWK3OalVv/I/qNygP42zyoKp3xptRVCWRFEBvo=\n golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n+golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4 h1:6zppjxzCulZykYSLyVDYbneBfbaBIQPYMevg0bEwv2s=\n+golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\n golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n golang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n@@ -780,8 +781,9 @@ golang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJ\n golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n-golang.org/x/sync v0.0.0-20220601150217-0de741cfad7f h1:Ax0t5p6N38Ga0dThY21weqDEyz2oklo4IvDkpigvkD8=\n golang.org/x/sync v0.0.0-20220601150217-0de741cfad7f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4 h1:uVc8UZUe6tr40fFVnUP5Oj+veunVezqYl9z7DYw9xzw=\n+golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n@@ -879,8 +881,9 @@ golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n golang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n golang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n-golang.org/x/text v0.3.7 h1:olpwvP2KacW1ZWvsR7uQhoyTYvKAupfQrRGBFM352Gk=\n golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\n+golang.org/x/text v0.3.8 h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=\n[[MASK]]\n golang.org/x/tools v0.1.3/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n golang.org/x/tools v0.1.4/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n golang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n-golang.org/x/tools v0.1.6-0.20210726203631-07bc1bf47fb2 h1:BonxutuHCTL0rBDnZlKjpGIQFTjyUVTexFOdWkB6Fg0=\n golang.org/x/tools v0.1.6-0.20210726203631-07bc1bf47fb2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n+golang.org/x/tools v0.1.12 h1:VveCTK38A2rkS8ZqFY25HIDFscX5X9OoEhJd3quQmXU=\n+golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\n golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20220411194840-2f41105eb62f/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20220517211312-f3a8303e98df/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\n-golang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f h1:uF6paiQQebLeSXkrTqHqz0MXhXXS1KgF41eUdBNvxK0=\n golang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\n google.golang.org/api v0.0.0-20180910000450-7ca32eb868bf/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\n google.golang.org/api v0.0.0-20181030000543-1d582fd0359e/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\n---\nvendor/modules.txt\n@@ -412,7 +412,7 @@ golang.org/x/sys/windows/svc/mgr\n # golang.org/x/term v0.0.0-20210927222741-03fcf44c2211\n ## explicit; go 1.17\n golang.org/x/term\n-# golang.org/x/text v0.3.7\n+# golang.org/x/text v0.3.8\n ## explicit; go 1.17\n golang.org/x/text/secure/bidirule\n golang.org/x/text/transform\n---\n\n"}], "ideal": "go.mod\n@@ -37,7 +37,7 @@ require (\n \tgo.uber.org/automaxprocs v1.4.0\n \tgolang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa\n \tgolang.org/x/net v0.0.0-20220909164309-bea034e7d591\n-\tgolang.org/x/sync v0.0.0-20220601150217-0de741cfad7f\n+\tgolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4\n \tgolang.org/x/sys v0.0.0-20220808155132-1c4a2a72c664\n \tgolang.org/x/term v0.0.0-20210927222741-03fcf44c2211\n \tgoogle.golang.org/protobuf v1.28.0\n@@ -89,11 +89,10 @@ require (\n \tgithub.com/prometheus/common v0.32.1 // indirect\n \tgithub.com/prometheus/procfs v0.7.3 // indirect\n \tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n-\tgolang.org/x/mod v0.4.2 // indirect\n+\tgolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4 // indirect\n \tgolang.org/x/oauth2 v0.0.0-20220822191816-0ebed06d0094 // indirect\n-\tgolang.org/x/text v0.3.7 // indirect\n-\tgolang.org/x/tools v0.1.6-0.20210726203631-07bc1bf47fb2 // indirect\n-\tgolang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f // indirect\n+\tgolang.org/x/text v0.3.8 // indirect\n+\tgolang.org/x/tools v0.1.12 // indirect\n \tgoogle.golang.org/appengine v1.6.7 // indirect\n \tgoogle.golang.org/genproto v0.0.0-20220616135557-88e70c0c3a90 // indirect\n \tgoogle.golang.org/grpc v1.47.0 // indirect\n---\ngo.sum\n@@ -681,8 +681,9 @@ golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.4.1/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n-golang.org/x/mod v0.4.2 h1:Gz96sIWK3OalVv/I/qNygP42zyoKp3xptRVCWRFEBvo=\n golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n+golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4 h1:6zppjxzCulZykYSLyVDYbneBfbaBIQPYMevg0bEwv2s=\n+golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\n golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n golang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n@@ -780,8 +781,9 @@ golang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJ\n golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n-golang.org/x/sync v0.0.0-20220601150217-0de741cfad7f h1:Ax0t5p6N38Ga0dThY21weqDEyz2oklo4IvDkpigvkD8=\n golang.org/x/sync v0.0.0-20220601150217-0de741cfad7f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4 h1:uVc8UZUe6tr40fFVnUP5Oj+veunVezqYl9z7DYw9xzw=\n+golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n@@ -879,8 +881,9 @@ golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n golang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n golang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n-golang.org/x/text v0.3.7 h1:olpwvP2KacW1ZWvsR7uQhoyTYvKAupfQrRGBFM352Gk=\n golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\n+golang.org/x/text v0.3.8 h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=\n+golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=\n golang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n@@ -945,15 +948,15 @@ golang.org/x/tools v0.1.2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n golang.org/x/tools v0.1.3/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n golang.org/x/tools v0.1.4/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n golang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n-golang.org/x/tools v0.1.6-0.20210726203631-07bc1bf47fb2 h1:BonxutuHCTL0rBDnZlKjpGIQFTjyUVTexFOdWkB6Fg0=\n golang.org/x/tools v0.1.6-0.20210726203631-07bc1bf47fb2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n+golang.org/x/tools v0.1.12 h1:VveCTK38A2rkS8ZqFY25HIDFscX5X9OoEhJd3quQmXU=\n+golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\n golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20220411194840-2f41105eb62f/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20220517211312-f3a8303e98df/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\n-golang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f h1:uF6paiQQebLeSXkrTqHqz0MXhXXS1KgF41eUdBNvxK0=\n golang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\n google.golang.org/api v0.0.0-20180910000450-7ca32eb868bf/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\n google.golang.org/api v0.0.0-20181030000543-1d582fd0359e/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\n---\nvendor/modules.txt\n@@ -412,7 +412,7 @@ golang.org/x/sys/windows/svc/mgr\n # golang.org/x/term v0.0.0-20210927222741-03fcf44c2211\n ## explicit; go 1.17\n golang.org/x/term\n-# golang.org/x/text v0.3.7\n+# golang.org/x/text v0.3.8\n ## explicit; go 1.17\n golang.org/x/text/secure/bidirule\n golang.org/x/text/transform\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Issue #574: Better ssh config for short-lived cert\n\nDescription: This PR is made using suggestion from #574. The pros for this config is that it will work both Windows and Linux (tested), as well as in VSCode, which normally can't be done with the current generated ssh config (refers to #734)\n\nCode Diff:\ncmd/cloudflared/access/cmd.go\n@@ -37,16 +37,13 @@ const (\n \tsshConfigTemplate  = `\n Add to your {{.Home}}/.ssh/config:\n \n-Host {{.Hostname}}\n {{- if .ShortLivedCerts}}\n-  ProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt %r@cfpipe-{{.Hostname}} >&2 <&1'\n-\n-Host cfpipe-{{.Hostname}}\n-  HostName {{.Hostname}}\n+Match host {{.Hostname}} exec \"{{.Cloudflared}} access ssh-gen --hostname %h\"\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n-  IdentityFile ~/.cloudflared/{{.Hostname}}-cf_key\n-  CertificateFile ~/.cloudflared/{{.Hostname}}-cf_key-cert.pub\n+  IdentityFile ~/.cloudflared/%h-cf_key\n+  CertificateFile ~/.cloudflared/%h-cf_key-cert.pub\n[[MASK]]\n---\n\n"}], "ideal": "cmd/cloudflared/access/cmd.go\n@@ -37,16 +37,13 @@ const (\n \tsshConfigTemplate  = `\n Add to your {{.Home}}/.ssh/config:\n \n-Host {{.Hostname}}\n {{- if .ShortLivedCerts}}\n-  ProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt %r@cfpipe-{{.Hostname}} >&2 <&1'\n-\n-Host cfpipe-{{.Hostname}}\n-  HostName {{.Hostname}}\n+Match host {{.Hostname}} exec \"{{.Cloudflared}} access ssh-gen --hostname %h\"\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n-  IdentityFile ~/.cloudflared/{{.Hostname}}-cf_key\n-  CertificateFile ~/.cloudflared/{{.Hostname}}-cf_key-cert.pub\n+  IdentityFile ~/.cloudflared/%h-cf_key\n+  CertificateFile ~/.cloudflared/%h-cf_key-cert.pub\n {{- else}}\n+Host {{.Hostname}}\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n {{end}}\n `\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Issue #672: Run cloudflared service without root\n\nDescription: Run the cloudflared service with `cloudflared` user\r\n\r\n* Create user `cloudflared` if it does not exist in `cloudflared service install`\r\n* Remove user `cloudflared` in `cloudflared service uninstall`\r\n* Add `User=cloudflared` in `/etc/systemd/system/cloudflared.service`\r\n\r\nNote: this only works for systemd.\r\n\r\nI tested it in our environment and it worked :)\r\n\r\n![cloudflared-service-up](https://user-images.githubusercontent.com/4235177/191044789-14e34ffc-bc2f-4b04-986e-b0a2804f5ac8.png)\r\n\r\nCloses #672 \n\nCode Diff:\ncmd/cloudflared/linux_service.go\n@@ -44,6 +44,7 @@ const (\n \tserviceCredentialFile = \"cert.pem\"\n \tserviceConfigPath     = serviceConfigDir + \"/\" + serviceConfigFile\n \tcloudflaredService    = \"cloudflared.service\"\n+\tcloudflaredUser       = \"cloudflared\"\n )\n \n var systemdTemplates = []ServiceTemplate{\n@@ -59,6 +60,7 @@ Type=notify\n ExecStart={{ .Path }} --no-autoupdate{{ range .ExtraArgs }} {{ . }}{{ end }}\n Restart=on-failure\n[[MASK]]\n@@ -194,6 +196,7 @@ func installLinuxService(c *cli.Context) error {\n \t}\n \ttemplateArgs := ServiceTemplateArgs{\n \t\tPath: etPath,\n+\t\tUser: cloudflaredUser,\n \t}\n \n \tvar extraArgsFunc func(c *cli.Context, log *zerolog.Logger) ([]string, error)\n@@ -269,6 +272,13 @@ func installSystemd(templateArgs *ServiceTemplateArgs, log *zerolog.Logger) erro\n \t\t\treturn err\n \t\t}\n \t}\n+\t// Create the cloudflared user if it does not exist\n+\tif err := runCommand(\"id\", cloudflaredUser); err != nil {\n+\t\tif err := runCommand(\"useradd\", \"--system\", \"--no-create-home\", \"--home-dir=/nonexistent\", \"--shell=/usr/sbin/nologin\", cloudflaredUser); err != nil {\n+\t\t\tlog.Err(err).Msgf(\"useradd %s error\", cloudflaredUser)\n+\t\t\treturn err\n+\t\t}\n+\t}\n \tif err := runCommand(\"systemctl\", \"enable\", cloudflaredService); err != nil {\n \t\tlog.Err(err).Msgf(\"systemctl enable %s error\", cloudflaredService)\n \t\treturn err\n@@ -339,6 +349,13 @@ func uninstallSystemd(log *zerolog.Logger) error {\n \t\tlog.Err(err).Msg(\"systemctl stop cloudflared-update.timer error\")\n \t\treturn err\n \t}\n+\t// Delete the cloudflared user if it exists\n+\tif err := runCommand(\"id\", cloudflaredUser); err == nil {\n+\t\tif err := runCommand(\"userdel\", cloudflaredUser); err != nil {\n+\t\t\tlog.Err(err).Msgf(\"userdel %s error\", cloudflaredUser)\n+\t\t\treturn err\n+\t\t}\n+\t}\n \tfor _, serviceTemplate := range systemdTemplates {\n \t\tif err := serviceTemplate.Remove(); err != nil {\n \t\t\tlog.Err(err).Msg(\"error removing service template\")\n---\ncmd/cloudflared/service_template.go\n@@ -25,6 +25,7 @@ type ServiceTemplate struct {\n type ServiceTemplateArgs struct {\n \tPath      string\n \tExtraArgs []string\n+\tUser string\n }\n \n func (st *ServiceTemplate) ResolvePath() (string, error) {\n---\n\n"}], "ideal": "cmd/cloudflared/linux_service.go\n@@ -44,6 +44,7 @@ const (\n \tserviceCredentialFile = \"cert.pem\"\n \tserviceConfigPath     = serviceConfigDir + \"/\" + serviceConfigFile\n \tcloudflaredService    = \"cloudflared.service\"\n+\tcloudflaredUser       = \"cloudflared\"\n )\n \n var systemdTemplates = []ServiceTemplate{\n@@ -59,6 +60,7 @@ Type=notify\n ExecStart={{ .Path }} --no-autoupdate{{ range .ExtraArgs }} {{ . }}{{ end }}\n Restart=on-failure\n RestartSec=5s\n+User={{ .User }}\n \n [Install]\n WantedBy=multi-user.target\n@@ -194,6 +196,7 @@ func installLinuxService(c *cli.Context) error {\n \t}\n \ttemplateArgs := ServiceTemplateArgs{\n \t\tPath: etPath,\n+\t\tUser: cloudflaredUser,\n \t}\n \n \tvar extraArgsFunc func(c *cli.Context, log *zerolog.Logger) ([]string, error)\n@@ -269,6 +272,13 @@ func installSystemd(templateArgs *ServiceTemplateArgs, log *zerolog.Logger) erro\n \t\t\treturn err\n \t\t}\n \t}\n+\t// Create the cloudflared user if it does not exist\n+\tif err := runCommand(\"id\", cloudflaredUser); err != nil {\n+\t\tif err := runCommand(\"useradd\", \"--system\", \"--no-create-home\", \"--home-dir=/nonexistent\", \"--shell=/usr/sbin/nologin\", cloudflaredUser); err != nil {\n+\t\t\tlog.Err(err).Msgf(\"useradd %s error\", cloudflaredUser)\n+\t\t\treturn err\n+\t\t}\n+\t}\n \tif err := runCommand(\"systemctl\", \"enable\", cloudflaredService); err != nil {\n \t\tlog.Err(err).Msgf(\"systemctl enable %s error\", cloudflaredService)\n \t\treturn err\n@@ -339,6 +349,13 @@ func uninstallSystemd(log *zerolog.Logger) error {\n \t\tlog.Err(err).Msg(\"systemctl stop cloudflared-update.timer error\")\n \t\treturn err\n \t}\n+\t// Delete the cloudflared user if it exists\n+\tif err := runCommand(\"id\", cloudflaredUser); err == nil {\n+\t\tif err := runCommand(\"userdel\", cloudflaredUser); err != nil {\n+\t\t\tlog.Err(err).Msgf(\"userdel %s error\", cloudflaredUser)\n+\t\t\treturn err\n+\t\t}\n+\t}\n \tfor _, serviceTemplate := range systemdTemplates {\n \t\tif err := serviceTemplate.Remove(); err != nil {\n \t\t\tlog.Err(err).Msg(\"error removing service template\")\n---\ncmd/cloudflared/service_template.go\n@@ -25,6 +25,7 @@ type ServiceTemplate struct {\n type ServiceTemplateArgs struct {\n \tPath      string\n \tExtraArgs []string\n+\tUser string\n }\n \n func (st *ServiceTemplate) ResolvePath() (string, error) {\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Label correct container\n\nDescription: Previous PR #655 added label to the build container, not the final container.\n\nCode Diff:\nDockerfile\n@@ -7,8 +7,6 @@ ENV GO111MODULE=on \\\n     TARGET_GOOS=${TARGET_GOOS} \\\n     TARGET_GOARCH=${TARGET_GOARCH}\n     \n-LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n-\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n # copy our sources into the builder image\n@@ -20,6 +18,8 @@ RUN make cloudflared\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian11:nonroot\n \n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n # copy our compiled binary\n COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n---\nDockerfile.amd64\n@@ -3,8 +3,6 @@ FROM golang:1.19 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n-LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n-\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n # copy our sources into the builder image\n@@ -16,6 +14,8 @@ RUN GOOS=linux GOARCH=amd64 make cloudflared\n[[MASK]]\n # copy our compiled binary\n COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n---\nDockerfile.arm64\n@@ -3,8 +3,6 @@ FROM golang:1.19 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n-LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n-\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n # copy our sources into the builder image\n@@ -16,6 +14,8 @@ RUN GOOS=linux GOARCH=arm64 make cloudflared\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian11:nonroot-arm64\n \n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n # copy our compiled binary\n COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n---\n\n"}], "ideal": "Dockerfile\n@@ -7,8 +7,6 @@ ENV GO111MODULE=on \\\n     TARGET_GOOS=${TARGET_GOOS} \\\n     TARGET_GOARCH=${TARGET_GOARCH}\n     \n-LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n-\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n # copy our sources into the builder image\n@@ -20,6 +18,8 @@ RUN make cloudflared\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian11:nonroot\n \n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n # copy our compiled binary\n COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n---\nDockerfile.amd64\n@@ -3,8 +3,6 @@ FROM golang:1.19 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n-LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n-\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n # copy our sources into the builder image\n@@ -16,6 +14,8 @@ RUN GOOS=linux GOARCH=amd64 make cloudflared\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian11:nonroot\n \n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n # copy our compiled binary\n COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n---\nDockerfile.arm64\n@@ -3,8 +3,6 @@ FROM golang:1.19 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n-LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n-\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n # copy our sources into the builder image\n@@ -16,6 +14,8 @@ RUN GOOS=linux GOARCH=arm64 make cloudflared\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian11:nonroot-arm64\n \n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n # copy our compiled binary\n COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: configuration: Follow XDG Base Directory standard for appropriate environments\n\nDescription: imlements: #119\r\n\r\n### What it does:\r\nFollows the XDG Base Directory standard for the user config dir.\r\nIt uses [github.com/adrg/xdg](https://github.com/adrg/xdg) to find the right dir. It will try to resolve the `$XDG_CONFIG_HOME` and revert to the platform specific default ones.\r\n\r\nPrior directories will still work (similar to the old windows `~/cloudflare-warp`).\r\nI've implemented it on all Platforms but don't know how used they are on OSX or Windows so if desired I'll only enable it on Linux.\r\n\r\n### What it doesn't:\r\nIt does not implement the xdg spec regarding `/etc/xdg/cloudflared` as It isn't commonly used, with the only big software using it on my system being systemd which symlinks back to /etc/systemd. Further the dir isn't used at all on any of my servers which I guess is the primary client of `/etc/cloudfalre`.\r\nAlso the issue did mention the cleanup of `$HOME`and not the full implementation of the spec ;)\r\n\r\n#### Links\r\n- https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\n\nCode Diff:\nconfig/configuration.go\n@@ -30,6 +30,17 @@ var (\n \t// DefaultUnixLogLocation is the primary location to find log files\n \tDefaultUnixLogLocation = \"/var/log/cloudflared\"\n \n+\t// Default paths and env to determin the correct user config dir\n+\tLinuxUserConfigDirEnv   = \"XDG_CONFIG_HOME\"\n+\tLinuxUserConfigDir      = \"~/.config\"\n+\tWindowsUserConfigDirEnv = \"%LOCALAPPDATA%\"\n+\tWindowsUserConfigDir    = \"~/AppData/Local\"\n+\tDarwinUserConfigDir     = \"~/Library/Application Support\"\n+\n+\t// App and Vendor ID used in the filepath\n+\tAppID    = \"cloudflared\"\n+\tVendorID = \"cloudflare\"\n+\n \t// Launchd doesn't set root env variables, so there is default\n \t// Windows default config dir was ~/cloudflare-warp in documentation; let's keep it compatible\n \tdefaultUserConfigDirs = []string{\"~/.cloudflared\", \"~/.cloudflare-warp\", \"~/cloudflare-warp\"}\n@@ -79,8 +90,31 @@ func DefaultConfigPath() string {\n \n // DefaultConfigSearchDirectories returns the default folder locations of the config\n func DefaultConfigSearchDirectories() []string {\n+\tvar defaultDir string\n+\t// Build the default filepath\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\tdefaultDir = os.Getenv(WindowsUserConfigDirEnv)\n[[MASK]]\n+\t\tdefaultDir = os.Getenv(LinuxUserConfigDirEnv)\n+\t\tif defaultDir == \"\" {\n+\t\t\tdefaultDir = LinuxUserConfigDir\n+\t\t}\n+\t\tdefaultDir = filepath.Join(defaultDir, AppID)\n+\tcase \"darwin\":\n+\t\tdefaultDir = filepath.Join(DarwinUserConfigDir, \"com.\"+VendorID+\".\"+AppID)\n+\t}\n+\n \tdirs := make([]string, len(defaultUserConfigDirs))\n \tcopy(dirs, defaultUserConfigDirs)\n+\tif defaultDir != \"\" {\n+\t\tdirs = append([]string{defaultDir}, dirs...)\n+\t}\n+\n \tif runtime.GOOS != \"windows\" {\n \t\tdirs = append(dirs, defaultNixConfigDirs...)\n \t}\n---\n\n"}], "ideal": "config/configuration.go\n@@ -30,6 +30,17 @@ var (\n \t// DefaultUnixLogLocation is the primary location to find log files\n \tDefaultUnixLogLocation = \"/var/log/cloudflared\"\n \n+\t// Default paths and env to determin the correct user config dir\n+\tLinuxUserConfigDirEnv   = \"XDG_CONFIG_HOME\"\n+\tLinuxUserConfigDir      = \"~/.config\"\n+\tWindowsUserConfigDirEnv = \"%LOCALAPPDATA%\"\n+\tWindowsUserConfigDir    = \"~/AppData/Local\"\n+\tDarwinUserConfigDir     = \"~/Library/Application Support\"\n+\n+\t// App and Vendor ID used in the filepath\n+\tAppID    = \"cloudflared\"\n+\tVendorID = \"cloudflare\"\n+\n \t// Launchd doesn't set root env variables, so there is default\n \t// Windows default config dir was ~/cloudflare-warp in documentation; let's keep it compatible\n \tdefaultUserConfigDirs = []string{\"~/.cloudflared\", \"~/.cloudflare-warp\", \"~/cloudflare-warp\"}\n@@ -79,8 +90,31 @@ func DefaultConfigPath() string {\n \n // DefaultConfigSearchDirectories returns the default folder locations of the config\n func DefaultConfigSearchDirectories() []string {\n+\tvar defaultDir string\n+\t// Build the default filepath\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\tdefaultDir = os.Getenv(WindowsUserConfigDirEnv)\n+\t\tif defaultDir == \"\" {\n+\t\t\tdefaultDir = WindowsUserConfigDir\n+\t\t}\n+\t\tdefaultDir = filepath.Join(defaultDir, VendorID, AppID)\n+\tcase \"linux\":\n+\t\tdefaultDir = os.Getenv(LinuxUserConfigDirEnv)\n+\t\tif defaultDir == \"\" {\n+\t\t\tdefaultDir = LinuxUserConfigDir\n+\t\t}\n+\t\tdefaultDir = filepath.Join(defaultDir, AppID)\n+\tcase \"darwin\":\n+\t\tdefaultDir = filepath.Join(DarwinUserConfigDir, \"com.\"+VendorID+\".\"+AppID)\n+\t}\n+\n \tdirs := make([]string, len(defaultUserConfigDirs))\n \tcopy(dirs, defaultUserConfigDirs)\n+\tif defaultDir != \"\" {\n+\t\tdirs = append([]string{defaultDir}, dirs...)\n+\t}\n+\n \tif runtime.GOOS != \"windows\" {\n \t\tdirs = append(dirs, defaultNixConfigDirs...)\n \t}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Regnaio/location\n\nDescription: as\n\nCode Diff:\nDockerfile\n@@ -27,3 +27,6 @@ USER nonroot\n # command / entrypoint of container\n ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n CMD [\"version\"]\n+\n+# expose metrics server\n+EXPOSE 2000\n---\nconfig/configuration.go\n@@ -177,10 +177,11 @@ func ValidateUrl(c *cli.Context, allowURLFromArgs bool) (*url.URL, error) {\n }\n \n type UnvalidatedIngressRule struct {\n-\tHostname      string              `json:\"hostname,omitempty\"`\n-\tPath          string              `json:\"path,omitempty\"`\n-\tService       string              `json:\"service,omitempty\"`\n-\tOriginRequest OriginRequestConfig `yaml:\"originRequest\" json:\"originRequest\"`\n+\tHostname      string              `yaml:\"hostname,omitempty\" json:\"hostname,omitempty\"`\n+\tPath          string              `yaml:\"path,omitempty\" json:\"path,omitempty\"`\n+\tService       string              `yaml:\"service,omitempty\" json:\"service,omitempty\"`\n+\tLocation      string              `yaml:\"location,omitempty\" json:\"location,omitempty\"`\n+\tOriginRequest OriginRequestConfig `yaml:\"originRequest,omitempty\" yaml:\"originRequest\" json:\"originRequest\"`\n }\n \n // OriginRequestConfig is a set of optional fields that users may set to\n@@ -192,41 +193,41 @@ type UnvalidatedIngressRule struct {\n // - To specify a time.Duration in json, use int64 of the nanoseconds\n type OriginRequestConfig struct {\n \t// HTTP proxy timeout for establishing a new connection\n-\tConnectTimeout *CustomDuration `yaml:\"connectTimeout\" json:\"connectTimeout,omitempty\"`\n+\tConnectTimeout *CustomDuration `yaml:\"connectTimeout,omitempty\" json:\"connectTimeout,omitempty\"`\n \t// HTTP proxy timeout for completing a TLS handshake\n-\tTLSTimeout *CustomDuration `yaml:\"tlsTimeout\" json:\"tlsTimeout,omitempty\"`\n+\tTLSTimeout *CustomDuration `yaml:\"tlsTimeout,omitempty\" json:\"tlsTimeout,omitempty\"`\n \t// HTTP proxy TCP keepalive duration\n-\tTCPKeepAlive *CustomDuration `yaml:\"tcpKeepAlive\" json:\"tcpKeepAlive,omitempty\"`\n+\tTCPKeepAlive *CustomDuration `yaml:\"tcpKeepAlive,omitempty\" json:\"tcpKeepAlive,omitempty\"`\n \t// HTTP proxy should disable \"happy eyeballs\" for IPv4/v6 fallback\n-\tNoHappyEyeballs *bool `yaml:\"noHappyEyeballs\" json:\"noHappyEyeballs,omitempty\"`\n+\tNoHappyEyeballs *bool `yaml:\"noHappyEyeballs,omitempty\" json:\"noHappyEyeballs,omitempty\"`\n \t// HTTP proxy maximum keepalive connection pool size\n-\tKeepAliveConnections *int `yaml:\"keepAliveConnections\" json:\"keepAliveConnections,omitempty\"`\n+\tKeepAliveConnections *int `yaml:\"keepAliveConnections,omitempty\" json:\"keepAliveConnections,omitempty\"`\n \t// HTTP proxy timeout for closing an idle connection\n-\tKeepAliveTimeout *CustomDuration `yaml:\"keepAliveTimeout\" json:\"keepAliveTimeout,omitempty\"`\n+\tKeepAliveTimeout *CustomDuration `yaml:\"keepAliveTimeout,omitempty\" json:\"keepAliveTimeout,omitempty\"`\n \t// Sets the HTTP Host header for the local webserver.\n-\tHTTPHostHeader *string `yaml:\"httpHostHeader\" json:\"httpHostHeader,omitempty\"`\n+\tHTTPHostHeader *string `yaml:\"httpHostHeader,omitempty\" json:\"httpHostHeader,omitempty\"`\n \t// Hostname on the origin server certificate.\n-\tOriginServerName *string `yaml:\"originServerName\" json:\"originServerName,omitempty\"`\n+\tOriginServerName *string `yaml:\"originServerName,omitempty\" json:\"originServerName,omitempty\"`\n \t// Path to the CA for the certificate of your origin.\n \t// This option should be used only if your certificate is not signed by Cloudflare.\n-\tCAPool *string `yaml:\"caPool\" json:\"caPool,omitempty\"`\n+\tCAPool *string `yaml:\"caPool,omitempty\" json:\"caPool,omitempty\"`\n \t// Disables TLS verification of the certificate presented by your origin.\n \t// Will allow any certificate from the origin to be accepted.\n \t// Note: The connection from your machine to Cloudflare's Edge is still encrypted.\n-\tNoTLSVerify *bool `yaml:\"noTLSVerify\" json:\"noTLSVerify,omitempty\"`\n+\tNoTLSVerify *bool `yaml:\"noTLSVerify,omitempty\" json:\"noTLSVerify,omitempty\"`\n \t// Disables chunked transfer encoding.\n \t// Useful if you are running a WSGI server.\n-\tDisableChunkedEncoding *bool `yaml:\"disableChunkedEncoding\" json:\"disableChunkedEncoding,omitempty\"`\n+\tDisableChunkedEncoding *bool `yaml:\"disableChunkedEncoding,omitempty\" json:\"disableChunkedEncoding,omitempty\"`\n \t// Runs as jump host\n-\tBastionMode *bool `yaml:\"bastionMode\" json:\"bastionMode,omitempty\"`\n+\tBastionMode *bool `yaml:\"bastionMode,omitempty\" json:\"bastionMode,omitempty\"`\n \t// Listen address for the proxy.\n-\tProxyAddress *string `yaml:\"proxyAddress\" json:\"proxyAddress,omitempty\"`\n+\tProxyAddress *string `yaml:\"proxyAddress,omitempty\" json:\"proxyAddress,omitempty\"`\n \t// Listen port for the proxy.\n-\tProxyPort *uint `yaml:\"proxyPort\" json:\"proxyPort,omitempty\"`\n+\tProxyPort *uint `yaml:\"proxyPort,omitempty\" json:\"proxyPort,omitempty\"`\n \t// Valid options are 'socks' or empty.\n-\tProxyType *string `yaml:\"proxyType\" json:\"proxyType,omitempty\"`\n+\tProxyType *string `yaml:\"proxyType,omitempty\" json:\"proxyType,omitempty\"`\n \t// IP rules for the proxy service\n-\tIPRules []IngressIPRule `yaml:\"ipRules\" json:\"ipRules,omitempty\"`\n+\tIPRules []IngressIPRule `yaml:\"ipRules,omitempty\" json:\"ipRules,omitempty\"`\n }\n \n type IngressIPRule struct {\n@@ -238,8 +239,8 @@ type IngressIPRule struct {\n type Configuration struct {\n \tTunnelID      string `yaml:\"tunnel\"`\n \tIngress       []UnvalidatedIngressRule\n-\tWarpRouting   WarpRoutingConfig   `yaml:\"warp-routing\"`\n-\tOriginRequest OriginRequestConfig `yaml:\"originRequest\"`\n+\tWarpRouting   WarpRoutingConfig   `yaml:\"warp-routing,omitempty\"`\n+\tOriginRequest OriginRequestConfig `yaml:\"originRequest,omitempty\"`\n \tsourceFile    string\n }\n \n---\ningress/ingress.go\n@@ -244,6 +244,7 @@ func validateIngress(ingress []config.UnvalidatedIngressRule, defaults OriginReq\n \t\t\tHostname: r.Hostname,\n \t\t\tService:  service,\n \t\t\tPath:     pathRegexp,\n+\t\t\tLocation: r.Location,\n \t\t\tConfig:   cfg,\n \t\t}\n \t}\n[[MASK]]\n \n+\t// Location is an optional string specifying the Service path, which\n+\t// replaces the first subdirectory of the Hostname path\n+\tLocation string `json:\"location\"`\n+\n \t// Configure the request cloudflared sends to this specific origin.\n \tConfig OriginRequestConfig `json:\"originRequest\"`\n }\n---\nproxy/proxy.go\n@@ -6,7 +6,9 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n+\t\"path\"\n \t\"strconv\"\n+\t\"strings\"\n \n \t\"github.com/pkg/errors\"\n \t\"github.com/rs/zerolog\"\n@@ -86,6 +88,20 @@ func (p *Proxy) ProxyHTTP(\n \truleSpan.SetAttributes(attribute.Int(\"rule-num\", ruleNum))\n \truleSpan.End()\n \n+\tif rule.Location != \"\" {\n+\t\tfmt.Println(fmt.Sprintf(\"before: req.URL.Path: %s\", req.URL.Path))\n+\n+\t\tparts := strings.Split(req.URL.Path, \"/\")\n+\t\t// fmt.Println(\"parts:\", parts)\n+\n+\t\tif len(parts) > 1 {\n+\t\t\tparts[1] = rule.Location\n+\t\t}\n+\n+\t\treq.URL.Path = path.Clean(strings.Join(parts, \"/\"))\n+\t\tfmt.Println(fmt.Sprintf(\"after: req.URL.Path: %s\", req.URL.Path))\n+\t}\n+\n \tswitch originProxy := rule.Service.(type) {\n \tcase ingress.HTTPOriginProxy:\n \t\tif err := p.proxyHTTPRequest(\n---\n\n"}], "ideal": "Dockerfile\n@@ -27,3 +27,6 @@ USER nonroot\n # command / entrypoint of container\n ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n CMD [\"version\"]\n+\n+# expose metrics server\n+EXPOSE 2000\n---\nconfig/configuration.go\n@@ -177,10 +177,11 @@ func ValidateUrl(c *cli.Context, allowURLFromArgs bool) (*url.URL, error) {\n }\n \n type UnvalidatedIngressRule struct {\n-\tHostname      string              `json:\"hostname,omitempty\"`\n-\tPath          string              `json:\"path,omitempty\"`\n-\tService       string              `json:\"service,omitempty\"`\n-\tOriginRequest OriginRequestConfig `yaml:\"originRequest\" json:\"originRequest\"`\n+\tHostname      string              `yaml:\"hostname,omitempty\" json:\"hostname,omitempty\"`\n+\tPath          string              `yaml:\"path,omitempty\" json:\"path,omitempty\"`\n+\tService       string              `yaml:\"service,omitempty\" json:\"service,omitempty\"`\n+\tLocation      string              `yaml:\"location,omitempty\" json:\"location,omitempty\"`\n+\tOriginRequest OriginRequestConfig `yaml:\"originRequest,omitempty\" yaml:\"originRequest\" json:\"originRequest\"`\n }\n \n // OriginRequestConfig is a set of optional fields that users may set to\n@@ -192,41 +193,41 @@ type UnvalidatedIngressRule struct {\n // - To specify a time.Duration in json, use int64 of the nanoseconds\n type OriginRequestConfig struct {\n \t// HTTP proxy timeout for establishing a new connection\n-\tConnectTimeout *CustomDuration `yaml:\"connectTimeout\" json:\"connectTimeout,omitempty\"`\n+\tConnectTimeout *CustomDuration `yaml:\"connectTimeout,omitempty\" json:\"connectTimeout,omitempty\"`\n \t// HTTP proxy timeout for completing a TLS handshake\n-\tTLSTimeout *CustomDuration `yaml:\"tlsTimeout\" json:\"tlsTimeout,omitempty\"`\n+\tTLSTimeout *CustomDuration `yaml:\"tlsTimeout,omitempty\" json:\"tlsTimeout,omitempty\"`\n \t// HTTP proxy TCP keepalive duration\n-\tTCPKeepAlive *CustomDuration `yaml:\"tcpKeepAlive\" json:\"tcpKeepAlive,omitempty\"`\n+\tTCPKeepAlive *CustomDuration `yaml:\"tcpKeepAlive,omitempty\" json:\"tcpKeepAlive,omitempty\"`\n \t// HTTP proxy should disable \"happy eyeballs\" for IPv4/v6 fallback\n-\tNoHappyEyeballs *bool `yaml:\"noHappyEyeballs\" json:\"noHappyEyeballs,omitempty\"`\n+\tNoHappyEyeballs *bool `yaml:\"noHappyEyeballs,omitempty\" json:\"noHappyEyeballs,omitempty\"`\n \t// HTTP proxy maximum keepalive connection pool size\n-\tKeepAliveConnections *int `yaml:\"keepAliveConnections\" json:\"keepAliveConnections,omitempty\"`\n+\tKeepAliveConnections *int `yaml:\"keepAliveConnections,omitempty\" json:\"keepAliveConnections,omitempty\"`\n \t// HTTP proxy timeout for closing an idle connection\n-\tKeepAliveTimeout *CustomDuration `yaml:\"keepAliveTimeout\" json:\"keepAliveTimeout,omitempty\"`\n+\tKeepAliveTimeout *CustomDuration `yaml:\"keepAliveTimeout,omitempty\" json:\"keepAliveTimeout,omitempty\"`\n \t// Sets the HTTP Host header for the local webserver.\n-\tHTTPHostHeader *string `yaml:\"httpHostHeader\" json:\"httpHostHeader,omitempty\"`\n+\tHTTPHostHeader *string `yaml:\"httpHostHeader,omitempty\" json:\"httpHostHeader,omitempty\"`\n \t// Hostname on the origin server certificate.\n-\tOriginServerName *string `yaml:\"originServerName\" json:\"originServerName,omitempty\"`\n+\tOriginServerName *string `yaml:\"originServerName,omitempty\" json:\"originServerName,omitempty\"`\n \t// Path to the CA for the certificate of your origin.\n \t// This option should be used only if your certificate is not signed by Cloudflare.\n-\tCAPool *string `yaml:\"caPool\" json:\"caPool,omitempty\"`\n+\tCAPool *string `yaml:\"caPool,omitempty\" json:\"caPool,omitempty\"`\n \t// Disables TLS verification of the certificate presented by your origin.\n \t// Will allow any certificate from the origin to be accepted.\n \t// Note: The connection from your machine to Cloudflare's Edge is still encrypted.\n-\tNoTLSVerify *bool `yaml:\"noTLSVerify\" json:\"noTLSVerify,omitempty\"`\n+\tNoTLSVerify *bool `yaml:\"noTLSVerify,omitempty\" json:\"noTLSVerify,omitempty\"`\n \t// Disables chunked transfer encoding.\n \t// Useful if you are running a WSGI server.\n-\tDisableChunkedEncoding *bool `yaml:\"disableChunkedEncoding\" json:\"disableChunkedEncoding,omitempty\"`\n+\tDisableChunkedEncoding *bool `yaml:\"disableChunkedEncoding,omitempty\" json:\"disableChunkedEncoding,omitempty\"`\n \t// Runs as jump host\n-\tBastionMode *bool `yaml:\"bastionMode\" json:\"bastionMode,omitempty\"`\n+\tBastionMode *bool `yaml:\"bastionMode,omitempty\" json:\"bastionMode,omitempty\"`\n \t// Listen address for the proxy.\n-\tProxyAddress *string `yaml:\"proxyAddress\" json:\"proxyAddress,omitempty\"`\n+\tProxyAddress *string `yaml:\"proxyAddress,omitempty\" json:\"proxyAddress,omitempty\"`\n \t// Listen port for the proxy.\n-\tProxyPort *uint `yaml:\"proxyPort\" json:\"proxyPort,omitempty\"`\n+\tProxyPort *uint `yaml:\"proxyPort,omitempty\" json:\"proxyPort,omitempty\"`\n \t// Valid options are 'socks' or empty.\n-\tProxyType *string `yaml:\"proxyType\" json:\"proxyType,omitempty\"`\n+\tProxyType *string `yaml:\"proxyType,omitempty\" json:\"proxyType,omitempty\"`\n \t// IP rules for the proxy service\n-\tIPRules []IngressIPRule `yaml:\"ipRules\" json:\"ipRules,omitempty\"`\n+\tIPRules []IngressIPRule `yaml:\"ipRules,omitempty\" json:\"ipRules,omitempty\"`\n }\n \n type IngressIPRule struct {\n@@ -238,8 +239,8 @@ type IngressIPRule struct {\n type Configuration struct {\n \tTunnelID      string `yaml:\"tunnel\"`\n \tIngress       []UnvalidatedIngressRule\n-\tWarpRouting   WarpRoutingConfig   `yaml:\"warp-routing\"`\n-\tOriginRequest OriginRequestConfig `yaml:\"originRequest\"`\n+\tWarpRouting   WarpRoutingConfig   `yaml:\"warp-routing,omitempty\"`\n+\tOriginRequest OriginRequestConfig `yaml:\"originRequest,omitempty\"`\n \tsourceFile    string\n }\n \n---\ningress/ingress.go\n@@ -244,6 +244,7 @@ func validateIngress(ingress []config.UnvalidatedIngressRule, defaults OriginReq\n \t\t\tHostname: r.Hostname,\n \t\t\tService:  service,\n \t\t\tPath:     pathRegexp,\n+\t\t\tLocation: r.Location,\n \t\t\tConfig:   cfg,\n \t\t}\n \t}\n---\ningress/rule.go\n@@ -20,6 +20,10 @@ type Rule struct {\n \t// address.\n \tService OriginService `json:\"service\"`\n \n+\t// Location is an optional string specifying the Service path, which\n+\t// replaces the first subdirectory of the Hostname path\n+\tLocation string `json:\"location\"`\n+\n \t// Configure the request cloudflared sends to this specific origin.\n \tConfig OriginRequestConfig `json:\"originRequest\"`\n }\n---\nproxy/proxy.go\n@@ -6,7 +6,9 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n+\t\"path\"\n \t\"strconv\"\n+\t\"strings\"\n \n \t\"github.com/pkg/errors\"\n \t\"github.com/rs/zerolog\"\n@@ -86,6 +88,20 @@ func (p *Proxy) ProxyHTTP(\n \truleSpan.SetAttributes(attribute.Int(\"rule-num\", ruleNum))\n \truleSpan.End()\n \n+\tif rule.Location != \"\" {\n+\t\tfmt.Println(fmt.Sprintf(\"before: req.URL.Path: %s\", req.URL.Path))\n+\n+\t\tparts := strings.Split(req.URL.Path, \"/\")\n+\t\t// fmt.Println(\"parts:\", parts)\n+\n+\t\tif len(parts) > 1 {\n+\t\t\tparts[1] = rule.Location\n+\t\t}\n+\n+\t\treq.URL.Path = path.Clean(strings.Join(parts, \"/\"))\n+\t\tfmt.Println(fmt.Sprintf(\"after: req.URL.Path: %s\", req.URL.Path))\n+\t}\n+\n \tswitch originProxy := rule.Service.(type) {\n \tcase ingress.HTTPOriginProxy:\n \t\tif err := p.proxyHTTPRequest(\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: feat(docker): build docker images with buildkit, add actions\n\nDescription: hello, I add docker build workflow for cloudflared. I am learning buildx near time, and I feel good.\r\n\r\nIt may also helpful in your bin distro.\r\n\r\nEdit docker `tags`, actions `user` `token` by your own.\r\n\r\nI found a problem, user can't run docker with `-it`, because image `FROM scratch`\r\nbut it's useful for cross-compiling.\r\n\r\nIt may need two kind Dockerfile\r\n\r\ncheck more usage from: \r\n- https://github.com/initdc/ssh-proxy-by-caddy-l4\r\n- https://hub.docker.com/r/initdc/cloudflared\n\nCode Diff:\n.github/workflows/docker-ci-test.yml\n@@ -0,0 +1,37 @@\n+name: push-images-test\n+\n+on:\n+  schedule:\n+      - cron: \"0 0 */3 * *\"\n+  workflow_dispatch:\n+\n+env:\n+  REGISTRY: docker.io\n+  IMAGE_NAME: initdc/cloudflared\n+\n+jobs:\n+  buildx:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout\n+        uses: actions/checkout@v2\n+      - name: Set up QEMU\n+        uses: docker/setup-qemu-action@v1\n[[MASK]]\n+          username: ${{ secrets.DOCKER_USERNAME }}\n+          password: ${{ secrets.DOCKER_TOKEN }}\n+      - name: Extract Docker metadata\n+        id: meta\n+        uses: docker/metadata-action@v3\n+        with:\n+          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n+      - name: Build and push Docker image\n+        run: |\n+          set -e\n+          docker buildx ls\n+          docker buildx build --platform linux/amd64,linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/386,linux/arm/v7,linux/arm/v6 -t initdc/cloudflared:v$(TZ=Asia/Shanghai date +%Y.%m.%d) . --push\n+          docker buildx build --platform linux/amd64,linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/386,linux/arm/v7,linux/arm/v6 -t initdc/cloudflared:latest . --push\n---\n.github/workflows/docker-ci.yml\n@@ -0,0 +1,47 @@\n+name: push-images\n+\n+on:\n+  workflow_dispatch:\n+\n+env:\n+  REGISTRY: docker.io\n+  IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/cloudflared\n+\n+jobs:\n+  buildx:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout\n+        uses: actions/checkout@v2\n+      - name: Set up QEMU\n+        uses: docker/setup-qemu-action@v1\n+      - name: Set up Docker Buildx\n+        uses: docker/setup-buildx-action@v1\n+      - name: Login to DockerHub\n+        uses: docker/login-action@v1\n+        with:\n+          username: ${{ secrets.DOCKER_USERNAME }}\n+          password: ${{ secrets.DOCKER_TOKEN }}\n+      - name: Extract Docker metadata\n+        id: meta\n+        uses: docker/metadata-action@v3\n+        with:\n+          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n+      - name: Build and push Docker image\n+        uses: docker/build-push-action@v2\n+        with:\n+          context: .\n+          platforms: |\n+            linux/amd64\n+            linux/arm64\n+            linux/riscv64\n+            linux/ppc64le\n+            linux/s390x\n+            linux/386\n+            linux/mips64le\n+            linux/mips64\n+            linux/arm/v7\n+            linux/arm/v6\n+          tags: |\n+            ${{ env.IMAGE_NAME }}:latest\n+          labels: ${{ steps.meta.outputs.labels }}\n---\nDockerfile\n@@ -1,29 +1,51 @@\n-# use a builder image for building cloudflare\n-ARG TARGET_GOOS\n-ARG TARGET_GOARCH\n-FROM golang:1.17.1 as builder\n+# syntax=docker/dockerfile:1\n+FROM --platform=$BUILDPLATFORM golang:1.17.5 as build\n+ARG TARGETPLATFORM\n+ARG BUILDPLATFORM\n+\n ENV GO111MODULE=on \\\n-    CGO_ENABLED=0 \\\n-    TARGET_GOOS=${TARGET_GOOS} \\\n-    TARGET_GOARCH=${TARGET_GOARCH}\n+    CGO_ENABLED=0 \n+\n+ENV FIPS=false\n \n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n-# copy our sources into the builder image\n+# build with github tags\n+#ADD https://github.com/cloudflare/cloudflared/archive/refs/tags/2022.4.0.zip\n+\n COPY . .\n \n # compile cloudflared\n-RUN make cloudflared\n+RUN set -e \\\n+    && echo \"Running on $BUILDPLATFORM, building for $TARGETPLATFORM\" \\\n+    && apt-get update \\\n+    && apt-get install --no-install-recommends -y ruby \\\n+    && ruby docker-env.rb\n+\n+FROM --platform=$TARGETPLATFORM alpine:edge\n+\n+# ref: https://github.com/crazy-max/docker-cloudflared/blob/master/Dockerfile#L25\n+ENV TUNNEL_METRICS=\"0.0.0.0:49312\" \n+    # TUNNEL_DNS_ADDRESS=\"0.0.0.0\" \\\n+    # TUNNEL_DNS_PORT=\"53\" \\\n+    # TUNNEL_DNS_UPSTREAM=\"https://1.1.1.1/dns-query,https://1.0.0.1/dns-query\"\n+\n+COPY --from=build /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/cloudflared\n+\n+# ref: https://pkgs.alpinelinux.org/contents?file=dig\n+RUN set -e \\\n+    && apk add --no-cache ca-certificates nano curl bind-tools\n \n-# use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian10:nonroot\n+WORKDIR /root\n \n-# copy our compiled binary\n-COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+# ref: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/dns-over-https-client/\n+EXPOSE 53/udp\n+# ref: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configuration/ports-and-ips/\n+EXPOSE 443\n+EXPOSE 7844\n+EXPOSE 7844/udp\n \n-# run as non-privileged user\n-USER nonroot\n+# Don't set entrypoint, user need edit config file\n+CMD [\"/bin/sh\"]\n \n-# command / entrypoint of container\n-ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n-CMD [\"version\"]\n+HEALTHCHECK CMD (curl --fail http://127.0.0.1:49312/ready || dig +short @127.0.0.1 -p 53 cloudflare.com A) || exit 1\n\\ No newline at end of file\n---\ndocker-env.rb\n@@ -0,0 +1,17 @@\n+#!/usr/bin/ruby -w\n+\n+TargetPlatform = ENV.fetch('TARGETPLATFORM')\n+TPArray = TargetPlatform.split('/')\n+\n+# ref: https://github.com/containerd/containerd/blob/v1.4.3/platforms/defaults.go\n+OS = TPArray[0]\n+Architecture = TPArray[1]\n+Variant = TPArray[2].to_s[1]\n+\n+puts \"GOOS=#{OS} GOARCH=#{Architecture} GOARM=#{Variant}\"\n+\n+if Variant == ''\n+    `GOOS=#{OS} GOARCH=#{Architecture} make cloudflared`\n+else\n+    `GOOS=#{OS} GOARCH=#{Architecture} GOARM=#{Variant}  make cloudflared`\n+end\n---\n\n"}], "ideal": ".github/workflows/docker-ci-test.yml\n@@ -0,0 +1,37 @@\n+name: push-images-test\n+\n+on:\n+  schedule:\n+      - cron: \"0 0 */3 * *\"\n+  workflow_dispatch:\n+\n+env:\n+  REGISTRY: docker.io\n+  IMAGE_NAME: initdc/cloudflared\n+\n+jobs:\n+  buildx:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout\n+        uses: actions/checkout@v2\n+      - name: Set up QEMU\n+        uses: docker/setup-qemu-action@v1\n+      - name: Set up Docker Buildx\n+        uses: docker/setup-buildx-action@v1\n+      - name: Login to DockerHub\n+        uses: docker/login-action@v1\n+        with:\n+          username: ${{ secrets.DOCKER_USERNAME }}\n+          password: ${{ secrets.DOCKER_TOKEN }}\n+      - name: Extract Docker metadata\n+        id: meta\n+        uses: docker/metadata-action@v3\n+        with:\n+          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n+      - name: Build and push Docker image\n+        run: |\n+          set -e\n+          docker buildx ls\n+          docker buildx build --platform linux/amd64,linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/386,linux/arm/v7,linux/arm/v6 -t initdc/cloudflared:v$(TZ=Asia/Shanghai date +%Y.%m.%d) . --push\n+          docker buildx build --platform linux/amd64,linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/386,linux/arm/v7,linux/arm/v6 -t initdc/cloudflared:latest . --push\n---\n.github/workflows/docker-ci.yml\n@@ -0,0 +1,47 @@\n+name: push-images\n+\n+on:\n+  workflow_dispatch:\n+\n+env:\n+  REGISTRY: docker.io\n+  IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/cloudflared\n+\n+jobs:\n+  buildx:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout\n+        uses: actions/checkout@v2\n+      - name: Set up QEMU\n+        uses: docker/setup-qemu-action@v1\n+      - name: Set up Docker Buildx\n+        uses: docker/setup-buildx-action@v1\n+      - name: Login to DockerHub\n+        uses: docker/login-action@v1\n+        with:\n+          username: ${{ secrets.DOCKER_USERNAME }}\n+          password: ${{ secrets.DOCKER_TOKEN }}\n+      - name: Extract Docker metadata\n+        id: meta\n+        uses: docker/metadata-action@v3\n+        with:\n+          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n+      - name: Build and push Docker image\n+        uses: docker/build-push-action@v2\n+        with:\n+          context: .\n+          platforms: |\n+            linux/amd64\n+            linux/arm64\n+            linux/riscv64\n+            linux/ppc64le\n+            linux/s390x\n+            linux/386\n+            linux/mips64le\n+            linux/mips64\n+            linux/arm/v7\n+            linux/arm/v6\n+          tags: |\n+            ${{ env.IMAGE_NAME }}:latest\n+          labels: ${{ steps.meta.outputs.labels }}\n---\nDockerfile\n@@ -1,29 +1,51 @@\n-# use a builder image for building cloudflare\n-ARG TARGET_GOOS\n-ARG TARGET_GOARCH\n-FROM golang:1.17.1 as builder\n+# syntax=docker/dockerfile:1\n+FROM --platform=$BUILDPLATFORM golang:1.17.5 as build\n+ARG TARGETPLATFORM\n+ARG BUILDPLATFORM\n+\n ENV GO111MODULE=on \\\n-    CGO_ENABLED=0 \\\n-    TARGET_GOOS=${TARGET_GOOS} \\\n-    TARGET_GOARCH=${TARGET_GOARCH}\n+    CGO_ENABLED=0 \n+\n+ENV FIPS=false\n \n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n-# copy our sources into the builder image\n+# build with github tags\n+#ADD https://github.com/cloudflare/cloudflared/archive/refs/tags/2022.4.0.zip\n+\n COPY . .\n \n # compile cloudflared\n-RUN make cloudflared\n+RUN set -e \\\n+    && echo \"Running on $BUILDPLATFORM, building for $TARGETPLATFORM\" \\\n+    && apt-get update \\\n+    && apt-get install --no-install-recommends -y ruby \\\n+    && ruby docker-env.rb\n+\n+FROM --platform=$TARGETPLATFORM alpine:edge\n+\n+# ref: https://github.com/crazy-max/docker-cloudflared/blob/master/Dockerfile#L25\n+ENV TUNNEL_METRICS=\"0.0.0.0:49312\" \n+    # TUNNEL_DNS_ADDRESS=\"0.0.0.0\" \\\n+    # TUNNEL_DNS_PORT=\"53\" \\\n+    # TUNNEL_DNS_UPSTREAM=\"https://1.1.1.1/dns-query,https://1.0.0.1/dns-query\"\n+\n+COPY --from=build /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/cloudflared\n+\n+# ref: https://pkgs.alpinelinux.org/contents?file=dig\n+RUN set -e \\\n+    && apk add --no-cache ca-certificates nano curl bind-tools\n \n-# use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian10:nonroot\n+WORKDIR /root\n \n-# copy our compiled binary\n-COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+# ref: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/dns-over-https-client/\n+EXPOSE 53/udp\n+# ref: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configuration/ports-and-ips/\n+EXPOSE 443\n+EXPOSE 7844\n+EXPOSE 7844/udp\n \n-# run as non-privileged user\n-USER nonroot\n+# Don't set entrypoint, user need edit config file\n+CMD [\"/bin/sh\"]\n \n-# command / entrypoint of container\n-ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n-CMD [\"version\"]\n+HEALTHCHECK CMD (curl --fail http://127.0.0.1:49312/ready || dig +short @127.0.0.1 -p 53 cloudflare.com A) || exit 1\n\\ No newline at end of file\n---\ndocker-env.rb\n@@ -0,0 +1,17 @@\n+#!/usr/bin/ruby -w\n+\n+TargetPlatform = ENV.fetch('TARGETPLATFORM')\n+TPArray = TargetPlatform.split('/')\n+\n+# ref: https://github.com/containerd/containerd/blob/v1.4.3/platforms/defaults.go\n+OS = TPArray[0]\n+Architecture = TPArray[1]\n+Variant = TPArray[2].to_s[1]\n+\n+puts \"GOOS=#{OS} GOARCH=#{Architecture} GOARM=#{Variant}\"\n+\n+if Variant == ''\n+    `GOOS=#{OS} GOARCH=#{Architecture} make cloudflared`\n+else\n+    `GOOS=#{OS} GOARCH=#{Architecture} GOARM=#{Variant}  make cloudflared`\n+end\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: carrier: fix dropped errors\n\nDescription: This fixes two dropped websocket errors in the `carrier` package.\n\nCode Diff:\ncarrier/websocket.go\n@@ -55,6 +55,9 @@ func createWebsocketStream(options *StartOptions, log *zerolog.Logger) (*cfwebso\n \t}\n \n \tdump, err := httputil.DumpRequest(req, false)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \tlog.Debug().Msgf(\"Websocket request: %s\", string(dump))\n[[MASK]]\n \tdump, err := httputil.DumpRequest(req, false)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n \tlog.Debug().Msgf(\"Access Websocket request: %s\", string(dump))\n \n \tconn, resp, err := clientConnect(req, nil)\n---\n\n"}], "ideal": "carrier/websocket.go\n@@ -55,6 +55,9 @@ func createWebsocketStream(options *StartOptions, log *zerolog.Logger) (*cfwebso\n \t}\n \n \tdump, err := httputil.DumpRequest(req, false)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \tlog.Debug().Msgf(\"Websocket request: %s\", string(dump))\n \n \tdialer := &websocket.Dialer{\n@@ -182,6 +185,9 @@ func createAccessWebSocketStream(options *StartOptions, log *zerolog.Logger) (*w\n \t}\n \n \tdump, err := httputil.DumpRequest(req, false)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n \tlog.Debug().Msgf(\"Access Websocket request: %s\", string(dump))\n \n \tconn, resp, err := clientConnect(req, nil)\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Addressing h2mux and session flaky tests\n\nDescription: Updating some tests to try and appease CI flaky tests.\r\n\r\n- Correct some h2mux tests on windows without CGO_ENABLED: Compression isn't supported without cgo on windows environments so the h2mux tests need to ignore compression.\r\n   - TestMultipleStreamsWithDictionaries, TestSampleSiteWithDictionaries, TestLongSiteWithDictionaries\r\n- TestReadFromDstSessionPreventClosed occasionally will fail because the session closes in the idle time. This might be because of all the tests running in parallel in separate goroutines and the 100ms time limit is exceeded. Bumping this idle time and execution window up may help reduce the flaky failures for these tests\n\nCode Diff:\ndatagramsession/session_test.go\n@@ -111,8 +111,8 @@ func TestReadFromDstSessionPreventClosed(t *testing.T) {\n }\n \n func testActiveSessionNotClosed(t *testing.T, readFromDst bool, writeToDst bool) {\n-\tconst closeAfterIdle = time.Millisecond * 100\n-\tconst activeTime = time.Millisecond * 500\n+\tconst closeAfterIdle = time.Millisecond * 500\n+\tconst activeTime = time.Millisecond * 1000\n \n \tsessionID := uuid.New()\n \tcfdConn, originConn := net.Pipe()\n@@ -129,8 +129,10 @@ func testActiveSessionNotClosed(t *testing.T, readFromDst bool, writeToDst bool)\n \tctx, cancel := context.WithCancel(context.Background())\n \terrGroup, ctx := errgroup.WithContext(ctx)\n \terrGroup.Go(func() error {\n-\t\tsession.Serve(ctx, closeAfterIdle)\n-\t\tif time.Now().Before(startTime.Add(activeTime)) {\n+\t\tclosed, err := session.Serve(ctx, closeAfterIdle)\n+\t\trequire.False(t, closed) // session not closed by remote\n+\t\trequire.EqualError(t, err, SessionIdleErr(closeAfterIdle).Error())\n+\t\tif time.Now().Before(activeUntil) {\n \t\t\treturn fmt.Errorf(\"session closed while it's still active\")\n \t\t}\n \t\treturn nil\n---\nh2mux/h2mux_test.go\n@@ -823,7 +823,7 @@ func TestMultipleStreamsWithDictionaries(t *testing.T) {\n \t\t}\n \n[[MASK]]\n \t}\n@@ -952,7 +952,7 @@ func TestSampleSiteWithDictionaries(t *testing.T) {\n \t\t}\n \n \t\toriginMuxMetrics := muxPair.OriginMux.Metrics()\n-\t\tif q > CompressionNone && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n+\t\tif q > CompressionNone && CompressionIsSupported() && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n \t\t\tt.Fatalf(\"Cross-stream compression is expected to give a better compression ratio\")\n \t\t}\n \t}\n@@ -985,7 +985,7 @@ func TestLongSiteWithDictionaries(t *testing.T) {\n \t\tassert.NoError(t, errGroup.Wait())\n \n \t\toriginMuxMetrics := muxPair.OriginMux.Metrics()\n-\t\tif q > CompressionNone && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n+\t\tif q > CompressionNone && CompressionIsSupported() && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n \t\t\tt.Fatalf(\"Cross-stream compression is expected to give a better compression ratio\")\n \t\t}\n \t}\n---\n\n"}], "ideal": "datagramsession/session_test.go\n@@ -111,8 +111,8 @@ func TestReadFromDstSessionPreventClosed(t *testing.T) {\n }\n \n func testActiveSessionNotClosed(t *testing.T, readFromDst bool, writeToDst bool) {\n-\tconst closeAfterIdle = time.Millisecond * 100\n-\tconst activeTime = time.Millisecond * 500\n+\tconst closeAfterIdle = time.Millisecond * 500\n+\tconst activeTime = time.Millisecond * 1000\n \n \tsessionID := uuid.New()\n \tcfdConn, originConn := net.Pipe()\n@@ -129,8 +129,10 @@ func testActiveSessionNotClosed(t *testing.T, readFromDst bool, writeToDst bool)\n \tctx, cancel := context.WithCancel(context.Background())\n \terrGroup, ctx := errgroup.WithContext(ctx)\n \terrGroup.Go(func() error {\n-\t\tsession.Serve(ctx, closeAfterIdle)\n-\t\tif time.Now().Before(startTime.Add(activeTime)) {\n+\t\tclosed, err := session.Serve(ctx, closeAfterIdle)\n+\t\trequire.False(t, closed) // session not closed by remote\n+\t\trequire.EqualError(t, err, SessionIdleErr(closeAfterIdle).Error())\n+\t\tif time.Now().Before(activeUntil) {\n \t\t\treturn fmt.Errorf(\"session closed while it's still active\")\n \t\t}\n \t\treturn nil\n---\nh2mux/h2mux_test.go\n@@ -823,7 +823,7 @@ func TestMultipleStreamsWithDictionaries(t *testing.T) {\n \t\t}\n \n \t\toriginMuxMetrics := muxPair.OriginMux.Metrics()\n-\t\tif q > CompressionNone && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n+\t\tif q > CompressionNone && CompressionIsSupported() && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n \t\t\tt.Fatalf(\"Cross-stream compression is expected to give a better compression ratio\")\n \t\t}\n \t}\n@@ -952,7 +952,7 @@ func TestSampleSiteWithDictionaries(t *testing.T) {\n \t\t}\n \n \t\toriginMuxMetrics := muxPair.OriginMux.Metrics()\n-\t\tif q > CompressionNone && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n+\t\tif q > CompressionNone && CompressionIsSupported() && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n \t\t\tt.Fatalf(\"Cross-stream compression is expected to give a better compression ratio\")\n \t\t}\n \t}\n@@ -985,7 +985,7 @@ func TestLongSiteWithDictionaries(t *testing.T) {\n \t\tassert.NoError(t, errGroup.Wait())\n \n \t\toriginMuxMetrics := muxPair.OriginMux.Metrics()\n-\t\tif q > CompressionNone && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n+\t\tif q > CompressionNone && CompressionIsSupported() && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n \t\t\tt.Fatalf(\"Cross-stream compression is expected to give a better compression ratio\")\n \t\t}\n \t}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Ensure service install directories are created before writing file\n\nDescription: Service install fails on a fresh macOS install\n\nCode Diff:\ncmd/cloudflared/service_template.go\n@@ -8,6 +8,7 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"path\"\n \t\"text/template\"\n \n \thomedir \"github.com/mitchellh/go-homedir\"\n@@ -52,10 +53,17 @@ func (st *ServiceTemplate) Generate(args *ServiceTemplateArgs) error {\n \tif err != nil {\n \t\treturn fmt.Errorf(\"error generating %s: %v\", st.Path, err)\n \t}\n-\tfileMode := os.FileMode(0644)\n+\tfileMode := os.FileMode(0o644)\n \tif st.FileMode != 0 {\n \t\tfileMode = st.FileMode\n \t}\n+\n+\tplistFolder := path.Dir(resolvedPath)\n+\terr = os.MkdirAll(plistFolder, 0o755)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"error creating %s: %v\", plistFolder, err)\n[[MASK]]\n---\n\n"}], "ideal": "cmd/cloudflared/service_template.go\n@@ -8,6 +8,7 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"path\"\n \t\"text/template\"\n \n \thomedir \"github.com/mitchellh/go-homedir\"\n@@ -52,10 +53,17 @@ func (st *ServiceTemplate) Generate(args *ServiceTemplateArgs) error {\n \tif err != nil {\n \t\treturn fmt.Errorf(\"error generating %s: %v\", st.Path, err)\n \t}\n-\tfileMode := os.FileMode(0644)\n+\tfileMode := os.FileMode(0o644)\n \tif st.FileMode != 0 {\n \t\tfileMode = st.FileMode\n \t}\n+\n+\tplistFolder := path.Dir(resolvedPath)\n+\terr = os.MkdirAll(plistFolder, 0o755)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"error creating %s: %v\", plistFolder, err)\n+\t}\n+\n \terr = ioutil.WriteFile(resolvedPath, buffer.Bytes(), fileMode)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"error writing %s: %v\", resolvedPath, err)\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Add X-Forwarded-Host for http proxy\n\nDescription: Adding [`X-Forwarded-Host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host) header to the http proxy.\r\n\r\nThis can be helpful in the case when the service in the ingress rule is another reverse proxy(call this 2nd reverse proxy), and the 2nd reverse proxy wants to pass original host to the backend application. So it becomes:\r\n\r\nOriginal request:\r\n\r\n```\r\nmydns.on.cloudflare <---- customer request\r\n        |\r\n        |\r\ncloudflared\r\n  - hostname: mydns.on.cloudflare\r\n    service: 2nd-proxy.some.internal\r\n```\r\n\r\nSo in the `2nd-proxy.some.internal`, it listens ` 2nd-proxy.some.internal` and can read `$http_x_forwarded_host` and pass it to the application.\r\n\r\nIf the idea makes sense, maybe we want to add a new config option, as well as tests/docs update.\n\nCode Diff:\ningress/origin_proxy.go\n@@ -40,6 +40,8 @@ func (o *httpService) RoundTrip(req *http.Request) (*http.Response, error) {\n \n \tif o.hostHeader != \"\" {\n \t\t// For incoming requests, the Host header is promoted to the Request.Host field and removed from the Header map.\n+\t\t// Pass the original Host header as X-Forwarded-Host.\n+\t\treq.Header.Set(\"X-Forwarded-Host\", req.Host)\n \t\treq.Host = o.hostHeader\n \t}\n \treturn o.transport.RoundTrip(req)\n---\ningress/origin_proxy_test.go\n@@ -3,6 +3,7 @@ package ingress\n import (\n \t\"context\"\n \t\"fmt\"\n+\t\"io/ioutil\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n[[MASK]]\n+\t\t// return the X-Forwarded-Host header for assertions\n+\t\t// as the httptest Server URL isn't available here yet\n+\t\tw.Write([]byte(r.Header.Get(\"X-Forwarded-Host\")))\n \t}\n \torigin := httptest.NewServer(http.HandlerFunc(handler))\n \tdefer origin.Close()\n@@ -141,6 +144,10 @@ func TestHTTPServiceHostHeaderOverride(t *testing.T) {\n \trequire.NoError(t, err)\n \trequire.Equal(t, http.StatusOK, resp.StatusCode)\n \n+\trespBody, err := ioutil.ReadAll(resp.Body)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, respBody, []byte(originURL.Host))\n+\n }\n \n func tcpListenRoutine(listener net.Listener, closeChan chan struct{}) {\n---\n\n"}], "ideal": "ingress/origin_proxy.go\n@@ -40,6 +40,8 @@ func (o *httpService) RoundTrip(req *http.Request) (*http.Response, error) {\n \n \tif o.hostHeader != \"\" {\n \t\t// For incoming requests, the Host header is promoted to the Request.Host field and removed from the Header map.\n+\t\t// Pass the original Host header as X-Forwarded-Host.\n+\t\treq.Header.Set(\"X-Forwarded-Host\", req.Host)\n \t\treq.Host = o.hostHeader\n \t}\n \treturn o.transport.RoundTrip(req)\n---\ningress/origin_proxy_test.go\n@@ -3,6 +3,7 @@ package ingress\n import (\n \t\"context\"\n \t\"fmt\"\n+\t\"io/ioutil\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n@@ -118,7 +119,9 @@ func TestHTTPServiceHostHeaderOverride(t *testing.T) {\n \t\t\tw.WriteHeader(http.StatusSwitchingProtocols)\n \t\t\treturn\n \t\t}\n-\t\tw.Write([]byte(\"ok\"))\n+\t\t// return the X-Forwarded-Host header for assertions\n+\t\t// as the httptest Server URL isn't available here yet\n+\t\tw.Write([]byte(r.Header.Get(\"X-Forwarded-Host\")))\n \t}\n \torigin := httptest.NewServer(http.HandlerFunc(handler))\n \tdefer origin.Close()\n@@ -141,6 +144,10 @@ func TestHTTPServiceHostHeaderOverride(t *testing.T) {\n \trequire.NoError(t, err)\n \trequire.Equal(t, http.StatusOK, resp.StatusCode)\n \n+\trespBody, err := ioutil.ReadAll(resp.Body)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, respBody, []byte(originURL.Host))\n+\n }\n \n func tcpListenRoutine(listener net.Listener, closeChan chan struct{}) {\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Add flag to 'tunnel create' subcommand to specify a base64-encoded secret\n\nDescription: This will help workflows where secrets are pre-provisioned. Running \"tunnel create\" manually and storing the generated secret isn't always practical. My use case is for automated tunnel provisioning without resorting to the API, which permits specifying a secret.\r\n\r\nhttps://api.cloudflare.com/#argo-tunnel-create-argo-tunnel\n\nCode Diff:\ncmd/cloudflared/tunnel/cmd.go\n@@ -181,7 +181,8 @@ func Init(ver string, gracefulShutdown chan struct{}) {\n func runAdhocNamedTunnel(sc *subcommandContext, name, credentialsOutputPath string) error {\n \ttunnel, ok, err := sc.tunnelActive(name)\n \tif err != nil || !ok {\n-\t\ttunnel, err = sc.create(name, credentialsOutputPath)\n+\t\t// pass empty string as secret to generate one\n+\t\ttunnel, err = sc.create(name, credentialsOutputPath, \"\")\n \t\tif err != nil {\n \t\t\treturn errors.Wrap(err, \"failed to create tunnel\")\n \t\t}\n[[MASK]]\n import (\n+\t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"os\"\n@@ -148,15 +149,27 @@ func (sc *subcommandContext) readTunnelCredentials(credFinder CredFinder) (conne\n \treturn credentials, nil\n }\n \n-func (sc *subcommandContext) create(name string, credentialsFilePath string) (*tunnelstore.Tunnel, error) {\n+func (sc *subcommandContext) create(name string, credentialsFilePath string, secret string) (*tunnelstore.Tunnel, error) {\n \tclient, err := sc.client()\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"couldn't create client to talk to Cloudflare Tunnel backend\")\n \t}\n \n-\ttunnelSecret, err := generateTunnelSecret()\n-\tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"couldn't generate the secret for your new tunnel\")\n+\tvar tunnelSecret []byte\n+\tif secret == \"\" {\n+\t\ttunnelSecret, err = generateTunnelSecret()\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrap(err, \"couldn't generate the secret for your new tunnel\")\n+\t\t}\n+\t} else {\n+\t\tdecodedSecret, err := base64.StdEncoding.DecodeString(secret)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrap(err, \"Couldn't decode tunnel secret from base64\")\n+\t\t}\n+\t\ttunnelSecret = []byte(decodedSecret)\n+\t\tif len(tunnelSecret) < 32 {\n+\t\t\treturn nil, errors.New(\"Decoded tunnel secret must be at least 32 bytes long\")\n+\t\t}\n \t}\n \n \ttunnel, err := client.CreateTunnel(name, tunnelSecret)\n---\ncmd/cloudflared/tunnel/subcommands.go\n@@ -156,6 +156,12 @@ var (\n \t\tUsage:   `Overwrites existing DNS records with this hostname`,\n \t\tEnvVars: []string{\"TUNNEL_FORCE_PROVISIONING_DNS\"},\n \t}\n+\tcreateSecretFlag = &cli.StringFlag{\n+\t\tName:    \"secret\",\n+\t\tAliases: []string{\"s\"},\n+\t\tUsage:   \"Base64 encoded secret to set for the tunnel. The decoded secret must be at least 32 bytes long. If not specified, a random 32-byte secret will be generated.\",\n+\t\tEnvVars: []string{\"TUNNEL_CREATE_SECRET\"},\n+\t}\n )\n \n func buildCreateCommand() *cli.Command {\n@@ -170,7 +176,7 @@ func buildCreateCommand() *cli.Command {\n   For example, to create a tunnel named 'my-tunnel' run:\n \n   $ cloudflared tunnel create my-tunnel`,\n-\t\tFlags:              []cli.Flag{outputFormatFlag, credentialsFileFlagCLIOnly},\n+\t\tFlags:              []cli.Flag{outputFormatFlag, credentialsFileFlagCLIOnly, createSecretFlag},\n \t\tCustomHelpTemplate: commandHelpTemplate(),\n \t}\n }\n@@ -196,7 +202,7 @@ func createCommand(c *cli.Context) error {\n \twarningChecker := updater.StartWarningCheck(c)\n \tdefer warningChecker.LogWarningIfAny(sc.log)\n \n-\t_, err = sc.create(name, c.String(CredFileFlag))\n+\t_, err = sc.create(name, c.String(CredFileFlag), c.String(createSecretFlag.Name))\n \treturn errors.Wrap(err, \"failed to create tunnel\")\n }\n \n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/cmd.go\n@@ -181,7 +181,8 @@ func Init(ver string, gracefulShutdown chan struct{}) {\n func runAdhocNamedTunnel(sc *subcommandContext, name, credentialsOutputPath string) error {\n \ttunnel, ok, err := sc.tunnelActive(name)\n \tif err != nil || !ok {\n-\t\ttunnel, err = sc.create(name, credentialsOutputPath)\n+\t\t// pass empty string as secret to generate one\n+\t\ttunnel, err = sc.create(name, credentialsOutputPath, \"\")\n \t\tif err != nil {\n \t\t\treturn errors.Wrap(err, \"failed to create tunnel\")\n \t\t}\n---\ncmd/cloudflared/tunnel/subcommand_context.go\n@@ -1,6 +1,7 @@\n package tunnel\n \n import (\n+\t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"os\"\n@@ -148,15 +149,27 @@ func (sc *subcommandContext) readTunnelCredentials(credFinder CredFinder) (conne\n \treturn credentials, nil\n }\n \n-func (sc *subcommandContext) create(name string, credentialsFilePath string) (*tunnelstore.Tunnel, error) {\n+func (sc *subcommandContext) create(name string, credentialsFilePath string, secret string) (*tunnelstore.Tunnel, error) {\n \tclient, err := sc.client()\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"couldn't create client to talk to Cloudflare Tunnel backend\")\n \t}\n \n-\ttunnelSecret, err := generateTunnelSecret()\n-\tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"couldn't generate the secret for your new tunnel\")\n+\tvar tunnelSecret []byte\n+\tif secret == \"\" {\n+\t\ttunnelSecret, err = generateTunnelSecret()\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrap(err, \"couldn't generate the secret for your new tunnel\")\n+\t\t}\n+\t} else {\n+\t\tdecodedSecret, err := base64.StdEncoding.DecodeString(secret)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrap(err, \"Couldn't decode tunnel secret from base64\")\n+\t\t}\n+\t\ttunnelSecret = []byte(decodedSecret)\n+\t\tif len(tunnelSecret) < 32 {\n+\t\t\treturn nil, errors.New(\"Decoded tunnel secret must be at least 32 bytes long\")\n+\t\t}\n \t}\n \n \ttunnel, err := client.CreateTunnel(name, tunnelSecret)\n---\ncmd/cloudflared/tunnel/subcommands.go\n@@ -156,6 +156,12 @@ var (\n \t\tUsage:   `Overwrites existing DNS records with this hostname`,\n \t\tEnvVars: []string{\"TUNNEL_FORCE_PROVISIONING_DNS\"},\n \t}\n+\tcreateSecretFlag = &cli.StringFlag{\n+\t\tName:    \"secret\",\n+\t\tAliases: []string{\"s\"},\n+\t\tUsage:   \"Base64 encoded secret to set for the tunnel. The decoded secret must be at least 32 bytes long. If not specified, a random 32-byte secret will be generated.\",\n+\t\tEnvVars: []string{\"TUNNEL_CREATE_SECRET\"},\n+\t}\n )\n \n func buildCreateCommand() *cli.Command {\n@@ -170,7 +176,7 @@ func buildCreateCommand() *cli.Command {\n   For example, to create a tunnel named 'my-tunnel' run:\n \n   $ cloudflared tunnel create my-tunnel`,\n-\t\tFlags:              []cli.Flag{outputFormatFlag, credentialsFileFlagCLIOnly},\n+\t\tFlags:              []cli.Flag{outputFormatFlag, credentialsFileFlagCLIOnly, createSecretFlag},\n \t\tCustomHelpTemplate: commandHelpTemplate(),\n \t}\n }\n@@ -196,7 +202,7 @@ func createCommand(c *cli.Context) error {\n \twarningChecker := updater.StartWarningCheck(c)\n \tdefer warningChecker.LogWarningIfAny(sc.log)\n \n-\t_, err = sc.create(name, c.String(CredFileFlag))\n+\t_, err = sc.create(name, c.String(CredFileFlag), c.String(createSecretFlag.Name))\n \treturn errors.Wrap(err, \"failed to create tunnel\")\n }\n \n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Add Docker Workflow\n\nDescription: This adds a docker workflow that will build and push the images to GHCR and DockerHub. There are a few things to consider\r\n\r\n1.  You will need to add `DOCKERHUB_USERNAME` and `DOCKERHUB_PASSWORD` consisting of your docker username and an authentication token to this repository's secrets\r\n2.  This will only run when pushes are to master branch or a release is made (this includes pre-releases)\r\n3. For docker tags, it uses either the tag (2021.9.0) or the git short sha. \r\n    a. This appears to be what's happening in the docker repo, so I tried replicating it. \r\n4. It will push to` ghcr.io/cloudflare/cloudflared` and `docker.io/cloudflare/cloudflared`\r\n     \r\n\r\n This Fixes #422 \n\nCode Diff:\n.github/workflows/docker-publish.yml\n@@ -0,0 +1,76 @@\n+name: Docker\n+\n+on:\n+  release:\n+    types: [published]\n+env:\n+  BUILD_VERSION: ${{ github.ref }}\n+  IMAGE_NAME: cloudflared\n+  DOCKER_CLI_EXPERIMENTAL: enabled\n+  REPOSITORY: ${{ github.repository }}\n[[MASK]]\n+    runs-on: ubuntu-latest\n+    if: ${{ github.event_name != 'pull_request' }}\n+    steps:\n+      - name: Source checkout\n+        uses: actions/checkout@v2.3.4 \n+ \n+      - name: Setup QEMU\n+        id: qemu\n+        uses: docker/setup-qemu-action@v1.2.0\n+      \n+      - name: Setup Buildx\n+        id: buildx\n+        uses: docker/setup-buildx-action@v1\n+\n+      - name: set version\n+        run : |\n+            VERSION=$(echo \"${{ github.ref }}\" | sed -e 's,.*/\\(.*\\),\\1,') #Get the tag or branch name (eg master or 2021.9.0)\n+            REPOSITORY=$(echo $REPOSITORY | tr '[A-Z]' '[a-z]') #make all lowercase\n+            # Strip \"v\" prefix from tag name or use short sha \n+            [[ \"${{ github.ref }}\" == \"refs/tags/\"* ]] && VERSION=$(echo $VERSION | sed -e 's/^v//') || VERSION=$(git rev-parse --short \"$GITHUB_SHA\")\n+            #Create a GA variable to use in other steps\n+            echo \"app_version=$VERSION\" >> $GITHUB_ENV\n+            echo \"REPOSITORY=$REPOSITORY\" >> $GITHUB_ENV\n+\n+      - name: Set Docker metadata\n+        id: docker_meta\n+        uses: docker/metadata-action@v3\n+        with:\n+          images: ${{ env.REPOSITORY }}\n+          labels: |\n+            org.opencontainers.image.version=${{env.app_version }}\n+            org.opencontainers.image.revision=${{ github.sha }}\n+            org.opencontainers.image.title=${{ env.REPOSITORY }}\n+\n+      - name: GitHub login\n+        if: ${{ github.event_name != 'pull_request' }}\n+        uses: docker/login-action@v1.10.0\n+        with:\n+          registry: ghcr.io\n+          username: ${{ github.actor }}\n+          password: ${{ secrets.GITHUB_TOKEN }}\n+      - name: DockerHub login\n+        if: ${{ github.event_name != 'pull_request' }}\n+        uses: docker/login-action@v1.10.0\n+        with:\n+          username: ${{ secrets.DOCKERHUB_USERNAME }}\n+          password: ${{ secrets.DOCKERHUB_PASSWORD }}      \n+      - name: Build and push\n+        uses: docker/build-push-action@v2.7.0\n+        with:\n+          push: ${{ github.event_name != 'pull_request' }}\n+          platforms: linux/amd64\n+          build-args: ${{ env.app_version }}\n+          cache-from: type=gha, scope=${{ github.workflow }}\n+          cache-to: type=gha, scope=${{ github.workflow }}\n+          labels: ${{ steps.docker_meta.outputs.labels }}\n+          tags: |\n+            ${{env.REPOSITORY}}:${{ env.app_version }}\n+            ${{env.REPOSITORY}}:latest\n+            ghcr.io/${{ env.REPOSITORY }}:${{ env.app_version }}\n+            ghcr.io/${{ env.REPOSITORY }}:latest\n---\n\n"}], "ideal": ".github/workflows/docker-publish.yml\n@@ -0,0 +1,76 @@\n+name: Docker\n+\n+on:\n+  release:\n+    types: [published]\n+env:\n+  BUILD_VERSION: ${{ github.ref }}\n+  IMAGE_NAME: cloudflared\n+  DOCKER_CLI_EXPERIMENTAL: enabled\n+  REPOSITORY: ${{ github.repository }}\n+\n+jobs:\n+  # Push image to GitHub Packages.\n+  # See also https://docs.docker.com/docker-hub/builds/\n+  push:\n+    runs-on: ubuntu-latest\n+    if: ${{ github.event_name != 'pull_request' }}\n+    steps:\n+      - name: Source checkout\n+        uses: actions/checkout@v2.3.4 \n+ \n+      - name: Setup QEMU\n+        id: qemu\n+        uses: docker/setup-qemu-action@v1.2.0\n+      \n+      - name: Setup Buildx\n+        id: buildx\n+        uses: docker/setup-buildx-action@v1\n+\n+      - name: set version\n+        run : |\n+            VERSION=$(echo \"${{ github.ref }}\" | sed -e 's,.*/\\(.*\\),\\1,') #Get the tag or branch name (eg master or 2021.9.0)\n+            REPOSITORY=$(echo $REPOSITORY | tr '[A-Z]' '[a-z]') #make all lowercase\n+            # Strip \"v\" prefix from tag name or use short sha \n+            [[ \"${{ github.ref }}\" == \"refs/tags/\"* ]] && VERSION=$(echo $VERSION | sed -e 's/^v//') || VERSION=$(git rev-parse --short \"$GITHUB_SHA\")\n+            #Create a GA variable to use in other steps\n+            echo \"app_version=$VERSION\" >> $GITHUB_ENV\n+            echo \"REPOSITORY=$REPOSITORY\" >> $GITHUB_ENV\n+\n+      - name: Set Docker metadata\n+        id: docker_meta\n+        uses: docker/metadata-action@v3\n+        with:\n+          images: ${{ env.REPOSITORY }}\n+          labels: |\n+            org.opencontainers.image.version=${{env.app_version }}\n+            org.opencontainers.image.revision=${{ github.sha }}\n+            org.opencontainers.image.title=${{ env.REPOSITORY }}\n+\n+      - name: GitHub login\n+        if: ${{ github.event_name != 'pull_request' }}\n+        uses: docker/login-action@v1.10.0\n+        with:\n+          registry: ghcr.io\n+          username: ${{ github.actor }}\n+          password: ${{ secrets.GITHUB_TOKEN }}\n+      - name: DockerHub login\n+        if: ${{ github.event_name != 'pull_request' }}\n+        uses: docker/login-action@v1.10.0\n+        with:\n+          username: ${{ secrets.DOCKERHUB_USERNAME }}\n+          password: ${{ secrets.DOCKERHUB_PASSWORD }}      \n+      - name: Build and push\n+        uses: docker/build-push-action@v2.7.0\n+        with:\n+          push: ${{ github.event_name != 'pull_request' }}\n+          platforms: linux/amd64\n+          build-args: ${{ env.app_version }}\n+          cache-from: type=gha, scope=${{ github.workflow }}\n+          cache-to: type=gha, scope=${{ github.workflow }}\n+          labels: ${{ steps.docker_meta.outputs.labels }}\n+          tags: |\n+            ${{env.REPOSITORY}}:${{ env.app_version }}\n+            ${{env.REPOSITORY}}:latest\n+            ghcr.io/${{ env.REPOSITORY }}:${{ env.app_version }}\n+            ghcr.io/${{ env.REPOSITORY }}:latest\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Add support for taking named tunnel credentials from an environment var\n\nDescription: # Description\r\nResolves #457.\r\n\r\nAdds a new flag, `credentials-contents`, to act as an alternative to `credentials-file`. This flag has an environment variable of `TUNNEL_CRED_CONTENTS` attached, allowing providing of named tunnel credentials via an environment variable. This flag, if provided, causes `subcommandContext.findCredentials` to load the credentials from the value of the flag, rather than trying to find a file on disk to load from.\r\n\r\n# Testing\r\n- I have added unit tests for the behaviour I implemented\r\n- I have tested locally by running the following:\r\n```bash\r\nmake cloudflared\r\nexport TUNNEL_CRED_CONTENTS=$(cat ~/.cloudflared/TUNNEL_UUID.json)\r\n./cloudflared tunnel run --url http://localhost:5000 TUNNEL_UUID\r\n``` \r\n- I have successfully gotten `cloudflared` running on Fargate in AWS ECS, and ensured it is functioning properly\r\n\r\n\n\nCode Diff:\ncmd/cloudflared/tunnel/subcommand_context.go\n@@ -261,8 +261,16 @@ func (sc *subcommandContext) delete(tunnelIDs []uuid.UUID) error {\n // and add the TunnelID into any old credentials (generated before TUN-3581 added the `TunnelID`\n // field to credentials files)\n func (sc *subcommandContext) findCredentials(tunnelID uuid.UUID) (connection.Credentials, error) {\n-\tcredFinder := sc.credentialFinder(tunnelID)\n-\tcredentials, err := sc.readTunnelCredentials(credFinder)\n+\tvar credentials connection.Credentials\n+\tvar err error\n+\tif credentialsContents := sc.c.String(CredContentsFlag); credentialsContents != \"\" {\n+\t\tif err = json.Unmarshal([]byte(credentialsContents), &credentials); err != nil {\n+\t\t\terr = errInvalidJSONCredential{path: \"TUNNEL_CRED_CONTENTS\", err: err}\n+\t\t}\n+\t} else {\n+\t\tcredFinder := sc.credentialFinder(tunnelID)\n+\t\tcredentials, err = sc.readTunnelCredentials(credFinder)\n+\t}\n \t// This line ensures backwards compatibility with credentials files generated before\n \t// TUN-3581. Those old credentials files don't have a TunnelID field, so we enrich the struct\n \t// with the ID, which we have already resolved from the user input.\n---\ncmd/cloudflared/tunnel/subcommand_context_test.go\n@@ -191,6 +191,51 @@ func Test_subcommandContext_findCredentials(t *testing.T) {\n \t\t\t\tTunnelName:   name,\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname: \"TUNNEL_CRED_CONTENTS given contains old credentials contents\",\n+\t\t\tfields: fields{\n+\t\t\t\tlog: &log,\n+\t\t\t\tfs:  fs,\n+\t\t\t\tc: func() *cli.Context {\n+\t\t\t\t\tflagSet := flag.NewFlagSet(\"test0\", flag.PanicOnError)\n+\t\t\t\t\tflagSet.String(CredContentsFlag, \"\", \"\")\n+\t\t\t\t\tc := cli.NewContext(cli.NewApp(), flagSet, nil)\n+\t\t\t\t\t_ = c.Set(CredContentsFlag, fmt.Sprintf(`{\"AccountTag\":\"%s\",\"TunnelSecret\":\"%s\"}`, accountTag, secretB64))\n+\t\t\t\t\treturn c\n+\t\t\t\t}(),\n+\t\t\t},\n+\t\t\targs: args{\n+\t\t\t\ttunnelID: tunnelID,\n+\t\t\t},\n+\t\t\twant: connection.Credentials{\n+\t\t\t\tAccountTag:   accountTag,\n+\t\t\t\tTunnelID:     tunnelID,\n+\t\t\t\tTunnelSecret: secret,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"TUNNEL_CRED_CONTENTS given contains new credentials contents\",\n+\t\t\tfields: fields{\n+\t\t\t\tlog: &log,\n+\t\t\t\tfs:  fs,\n+\t\t\t\tc: func() *cli.Context {\n+\t\t\t\t\tflagSet := flag.NewFlagSet(\"test0\", flag.PanicOnError)\n+\t\t\t\t\tflagSet.String(CredContentsFlag, \"\", \"\")\n+\t\t\t\t\tc := cli.NewContext(cli.NewApp(), flagSet, nil)\n+\t\t\t\t\t_ = c.Set(CredContentsFlag, fmt.Sprintf(`{\"AccountTag\":\"%s\",\"TunnelSecret\":\"%s\",\"TunnelID\":\"%s\",\"TunnelName\":\"%s\"}`, accountTag, secretB64, tunnelID, name))\n+\t\t\t\t\treturn c\n+\t\t\t\t}(),\n+\t\t\t},\n+\t\t\targs: args{\n+\t\t\t\ttunnelID: tunnelID,\n+\t\t\t},\n+\t\t\twant: connection.Credentials{\n+\t\t\t\tAccountTag:   accountTag,\n+\t\t\t\tTunnelID:     tunnelID,\n+\t\t\t\tTunnelSecret: secret,\n+\t\t\t\tTunnelName:   name,\n+\t\t\t},\n+\t\t},\n \t}\n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n---\ncmd/cloudflared/tunnel/subcommands.go\n@@ -33,6 +33,7 @@ const (\n \tconnsSortByOptions   = \"id, startedAt, numConnections, version\"\n \tCredFileFlagAlias    = \"cred-file\"\n \tCredFileFlag         = \"credentials-file\"\n+\tCredContentsFlag     = \"credentials-contents\"\n \toverwriteDNSFlagName = \"overwrite-dns\"\n \n \tLogFieldTunnelID = \"tunnelID\"\n@@ -111,8 +112,13 @@ var (\n \t\tUsage:   \"Filepath at which to read/write the tunnel credentials\",\n \t\tEnvVars: []string{\"TUNNEL_CRED_FILE\"},\n[[MASK]]\n+\t\tName:    CredContentsFlag,\n+\t\tUsage:   \"Contents of the tunnel credentials JSON file to use. When provided along with credentials-file, this will take precedence.\",\n+\t\tEnvVars: []string{\"TUNNEL_CRED_CONTENTS\"},\n+\t})\n+\tforceDeleteFlag = &cli.BoolFlag{\n \t\tName:    \"force\",\n \t\tAliases: []string{\"f\"},\n \t\tUsage: \"Cleans up any stale connections before the tunnel is deleted. cloudflared will not \" +\n@@ -579,6 +585,7 @@ func buildRunCommand() *cli.Command {\n \tflags := []cli.Flag{\n \t\tforceFlag,\n \t\tcredentialsFileFlag,\n+\t\tcredentialsContentsFlag,\n \t\tselectProtocolFlag,\n \t\tfeaturesFlag,\n \t}\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/subcommand_context.go\n@@ -261,8 +261,16 @@ func (sc *subcommandContext) delete(tunnelIDs []uuid.UUID) error {\n // and add the TunnelID into any old credentials (generated before TUN-3581 added the `TunnelID`\n // field to credentials files)\n func (sc *subcommandContext) findCredentials(tunnelID uuid.UUID) (connection.Credentials, error) {\n-\tcredFinder := sc.credentialFinder(tunnelID)\n-\tcredentials, err := sc.readTunnelCredentials(credFinder)\n+\tvar credentials connection.Credentials\n+\tvar err error\n+\tif credentialsContents := sc.c.String(CredContentsFlag); credentialsContents != \"\" {\n+\t\tif err = json.Unmarshal([]byte(credentialsContents), &credentials); err != nil {\n+\t\t\terr = errInvalidJSONCredential{path: \"TUNNEL_CRED_CONTENTS\", err: err}\n+\t\t}\n+\t} else {\n+\t\tcredFinder := sc.credentialFinder(tunnelID)\n+\t\tcredentials, err = sc.readTunnelCredentials(credFinder)\n+\t}\n \t// This line ensures backwards compatibility with credentials files generated before\n \t// TUN-3581. Those old credentials files don't have a TunnelID field, so we enrich the struct\n \t// with the ID, which we have already resolved from the user input.\n---\ncmd/cloudflared/tunnel/subcommand_context_test.go\n@@ -191,6 +191,51 @@ func Test_subcommandContext_findCredentials(t *testing.T) {\n \t\t\t\tTunnelName:   name,\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname: \"TUNNEL_CRED_CONTENTS given contains old credentials contents\",\n+\t\t\tfields: fields{\n+\t\t\t\tlog: &log,\n+\t\t\t\tfs:  fs,\n+\t\t\t\tc: func() *cli.Context {\n+\t\t\t\t\tflagSet := flag.NewFlagSet(\"test0\", flag.PanicOnError)\n+\t\t\t\t\tflagSet.String(CredContentsFlag, \"\", \"\")\n+\t\t\t\t\tc := cli.NewContext(cli.NewApp(), flagSet, nil)\n+\t\t\t\t\t_ = c.Set(CredContentsFlag, fmt.Sprintf(`{\"AccountTag\":\"%s\",\"TunnelSecret\":\"%s\"}`, accountTag, secretB64))\n+\t\t\t\t\treturn c\n+\t\t\t\t}(),\n+\t\t\t},\n+\t\t\targs: args{\n+\t\t\t\ttunnelID: tunnelID,\n+\t\t\t},\n+\t\t\twant: connection.Credentials{\n+\t\t\t\tAccountTag:   accountTag,\n+\t\t\t\tTunnelID:     tunnelID,\n+\t\t\t\tTunnelSecret: secret,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"TUNNEL_CRED_CONTENTS given contains new credentials contents\",\n+\t\t\tfields: fields{\n+\t\t\t\tlog: &log,\n+\t\t\t\tfs:  fs,\n+\t\t\t\tc: func() *cli.Context {\n+\t\t\t\t\tflagSet := flag.NewFlagSet(\"test0\", flag.PanicOnError)\n+\t\t\t\t\tflagSet.String(CredContentsFlag, \"\", \"\")\n+\t\t\t\t\tc := cli.NewContext(cli.NewApp(), flagSet, nil)\n+\t\t\t\t\t_ = c.Set(CredContentsFlag, fmt.Sprintf(`{\"AccountTag\":\"%s\",\"TunnelSecret\":\"%s\",\"TunnelID\":\"%s\",\"TunnelName\":\"%s\"}`, accountTag, secretB64, tunnelID, name))\n+\t\t\t\t\treturn c\n+\t\t\t\t}(),\n+\t\t\t},\n+\t\t\targs: args{\n+\t\t\t\ttunnelID: tunnelID,\n+\t\t\t},\n+\t\t\twant: connection.Credentials{\n+\t\t\t\tAccountTag:   accountTag,\n+\t\t\t\tTunnelID:     tunnelID,\n+\t\t\t\tTunnelSecret: secret,\n+\t\t\t\tTunnelName:   name,\n+\t\t\t},\n+\t\t},\n \t}\n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n---\ncmd/cloudflared/tunnel/subcommands.go\n@@ -33,6 +33,7 @@ const (\n \tconnsSortByOptions   = \"id, startedAt, numConnections, version\"\n \tCredFileFlagAlias    = \"cred-file\"\n \tCredFileFlag         = \"credentials-file\"\n+\tCredContentsFlag     = \"credentials-contents\"\n \toverwriteDNSFlagName = \"overwrite-dns\"\n \n \tLogFieldTunnelID = \"tunnelID\"\n@@ -111,8 +112,13 @@ var (\n \t\tUsage:   \"Filepath at which to read/write the tunnel credentials\",\n \t\tEnvVars: []string{\"TUNNEL_CRED_FILE\"},\n \t}\n-\tcredentialsFileFlag = altsrc.NewStringFlag(credentialsFileFlagCLIOnly)\n-\tforceDeleteFlag     = &cli.BoolFlag{\n+\tcredentialsFileFlag     = altsrc.NewStringFlag(credentialsFileFlagCLIOnly)\n+\tcredentialsContentsFlag = altsrc.NewStringFlag(&cli.StringFlag{\n+\t\tName:    CredContentsFlag,\n+\t\tUsage:   \"Contents of the tunnel credentials JSON file to use. When provided along with credentials-file, this will take precedence.\",\n+\t\tEnvVars: []string{\"TUNNEL_CRED_CONTENTS\"},\n+\t})\n+\tforceDeleteFlag = &cli.BoolFlag{\n \t\tName:    \"force\",\n \t\tAliases: []string{\"f\"},\n \t\tUsage: \"Cleans up any stale connections before the tunnel is deleted. cloudflared will not \" +\n@@ -579,6 +585,7 @@ func buildRunCommand() *cli.Command {\n \tflags := []cli.Flag{\n \t\tforceFlag,\n \t\tcredentialsFileFlag,\n+\t\tcredentialsContentsFlag,\n \t\tselectProtocolFlag,\n \t\tfeaturesFlag,\n \t}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: connect via proxy\n\nDescription: Fixes #350\r\nSigned-off-by: David J. M. Karlsen <david@davidkarlsen.com>\n\nCode Diff:\nedgediscovery/dial.go\n@@ -3,6 +3,7 @@ package edgediscovery\n[[MASK]]\n \t\"time\"\n \n@@ -20,8 +21,9 @@ func DialEdge(\n \tdialCtx, dialCancel := context.WithTimeout(ctx, timeout)\n \tdefer dialCancel()\n \n-\tdialer := net.Dialer{}\n-\tedgeConn, err := dialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\t//dialer := net.Dialer{}\n+\t//edgeConn, err := dialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\tedgeConn, err := proxy.Dial(dialCtx, \"tcp\", edgeTCPAddr.String())\n \tif err != nil {\n \t\treturn nil, newDialError(err, \"DialContext error\")\n \t}\n---\n\n"}], "ideal": "edgediscovery/dial.go\n@@ -3,6 +3,7 @@ package edgediscovery\n import (\n \t\"context\"\n \t\"crypto/tls\"\n+\t\"golang.org/x/net/proxy\"\n \t\"net\"\n \t\"time\"\n \n@@ -20,8 +21,9 @@ func DialEdge(\n \tdialCtx, dialCancel := context.WithTimeout(ctx, timeout)\n \tdefer dialCancel()\n \n-\tdialer := net.Dialer{}\n-\tedgeConn, err := dialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\t//dialer := net.Dialer{}\n+\t//edgeConn, err := dialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\tedgeConn, err := proxy.Dial(dialCtx, \"tcp\", edgeTCPAddr.String())\n \tif err != nil {\n \t\treturn nil, newDialError(err, \"DialContext error\")\n \t}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: 1.1.1.1File downloard\n\nDescription: Your states\n\nCode Diff:\nSECURITY.md\n@@ -0,0 +1,21 @@\n+# Security Policy\n+\n[[MASK]]\n+| Version | Supported          |\n+| ------- | ------------------ |\n+| 5.1.x   | :white_check_mark: |\n+| 5.0.x   | :x:                |\n+| 4.0.x   | :white_check_mark: |\n+| < 4.0   | :x:                |\n+\n+## Reporting a Vulnerability\n+\n+Use this section to tell people how to report a vulnerability.\n+\n+Tell them where to go, how often they can expect to get an update on a\n+reported vulnerability, what to expect if the vulnerability is accepted or\n+declined, etc.\n---\n\n"}], "ideal": "SECURITY.md\n@@ -0,0 +1,21 @@\n+# Security Policy\n+\n+## Supported Versions\n+\n+Use this section to tell people about which versions of your project are\n+currently being supported with security updates.\n+\n+| Version | Supported          |\n+| ------- | ------------------ |\n+| 5.1.x   | :white_check_mark: |\n+| 5.0.x   | :x:                |\n+| 4.0.x   | :white_check_mark: |\n+| < 4.0   | :x:                |\n+\n+## Reporting a Vulnerability\n+\n+Use this section to tell people how to report a vulnerability.\n+\n+Tell them where to go, how often they can expect to get an update on a\n+reported vulnerability, what to expect if the vulnerability is accepted or\n+declined, etc.\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Add Dependabot and CodeQL scanning\n\nDescription: This helps keeps dependencies up to date as well as identify any potential code issues.\n\nCode Diff:\n.github/dependabot.yml\n@@ -0,0 +1,14 @@\n+version: 2\n+\n+updates:\n+  # Maintain dependencies for GitHub Actions\n+  - package-ecosystem: \"github-actions\"\n[[MASK]]\n+  - package-ecosystem: \"gomod\"\n+    directory: \"/\"\n+    schedule:\n+      interval: \"daily\"\n---\n.github/workflows/codeql-analysis.yml\n@@ -0,0 +1,72 @@\n+# For most projects, this workflow file will not need changing; you simply need\n+# to commit it to your repository.\n+#\n+# You may wish to alter this file to override the set of languages analyzed,\n+# or to provide custom queries or build logic.\n+#\n+# ******** NOTE ********\n+# We have attempted to detect the languages in your repository. Please check\n+# the `language` matrix defined below to confirm you have the correct set of\n+# supported CodeQL languages.\n+#\n+name: \"CodeQL\"\n+\n+on:\n+  push:\n+    branches: [ master ]\n+  pull_request:\n+    # The branches below must be a subset of the branches above\n+    branches: [ master ]\n+  schedule:\n+    - cron: '19 9 * * 4'\n+\n+jobs:\n+  analyze:\n+    name: Analyze\n+    runs-on: ubuntu-latest\n+    permissions:\n+      actions: read\n+      contents: read\n+      security-events: write\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        language: [ 'go', 'javascript', 'python' ]\n+        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python' ]\n+        # Learn more:\n+        # https://docs.github.com/en/free-pro-team@latest/github/finding-security-vulnerabilities-and-errors-in-your-code/configuring-code-scanning#changing-the-languages-that-are-analyzed\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v2\n+\n+    # Initializes the CodeQL tools for scanning.\n+    - name: Initialize CodeQL\n+      uses: github/codeql-action/init@v1\n+      with:\n+        languages: ${{ matrix.language }}\n+        # If you wish to specify custom queries, you can do so here or in a config file.\n+        # By default, queries listed here will override any specified in a config file.\n+        # Prefix the list here with \"+\" to use these queries and those in the config file.\n+        # queries: ./path/to/local/query, your-org/your-repo/queries@main\n+        queries: security-and-quality\n+\n+    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n+    # If this step fails, then you should remove it and run the build manually (see below)\n+    - name: Autobuild\n+      uses: github/codeql-action/autobuild@v1\n+\n+    # \u2139\ufe0f Command-line programs to run using the OS shell.\n+    # \ud83d\udcda https://git.io/JvXDl\n+\n+    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n+    #    and modify them (or add more) to build your code if your project\n+    #    uses a compiled language\n+\n+    #- run: |\n+    #   make bootstrap\n+    #   make release\n+\n+    - name: Perform CodeQL Analysis\n+      uses: github/codeql-action/analyze@v1\n---\n\n"}], "ideal": ".github/dependabot.yml\n@@ -0,0 +1,14 @@\n+version: 2\n+\n+updates:\n+  # Maintain dependencies for GitHub Actions\n+  - package-ecosystem: \"github-actions\"\n+    directory: \"/\"\n+    schedule:\n+      interval: \"daily\"\n+      \n+  # Maintain dependencies for Go\n+  - package-ecosystem: \"gomod\"\n+    directory: \"/\"\n+    schedule:\n+      interval: \"daily\"\n---\n.github/workflows/codeql-analysis.yml\n@@ -0,0 +1,72 @@\n+# For most projects, this workflow file will not need changing; you simply need\n+# to commit it to your repository.\n+#\n+# You may wish to alter this file to override the set of languages analyzed,\n+# or to provide custom queries or build logic.\n+#\n+# ******** NOTE ********\n+# We have attempted to detect the languages in your repository. Please check\n+# the `language` matrix defined below to confirm you have the correct set of\n+# supported CodeQL languages.\n+#\n+name: \"CodeQL\"\n+\n+on:\n+  push:\n+    branches: [ master ]\n+  pull_request:\n+    # The branches below must be a subset of the branches above\n+    branches: [ master ]\n+  schedule:\n+    - cron: '19 9 * * 4'\n+\n+jobs:\n+  analyze:\n+    name: Analyze\n+    runs-on: ubuntu-latest\n+    permissions:\n+      actions: read\n+      contents: read\n+      security-events: write\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        language: [ 'go', 'javascript', 'python' ]\n+        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python' ]\n+        # Learn more:\n+        # https://docs.github.com/en/free-pro-team@latest/github/finding-security-vulnerabilities-and-errors-in-your-code/configuring-code-scanning#changing-the-languages-that-are-analyzed\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v2\n+\n+    # Initializes the CodeQL tools for scanning.\n+    - name: Initialize CodeQL\n+      uses: github/codeql-action/init@v1\n+      with:\n+        languages: ${{ matrix.language }}\n+        # If you wish to specify custom queries, you can do so here or in a config file.\n+        # By default, queries listed here will override any specified in a config file.\n+        # Prefix the list here with \"+\" to use these queries and those in the config file.\n+        # queries: ./path/to/local/query, your-org/your-repo/queries@main\n+        queries: security-and-quality\n+\n+    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n+    # If this step fails, then you should remove it and run the build manually (see below)\n+    - name: Autobuild\n+      uses: github/codeql-action/autobuild@v1\n+\n+    # \u2139\ufe0f Command-line programs to run using the OS shell.\n+    # \ud83d\udcda https://git.io/JvXDl\n+\n+    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n+    #    and modify them (or add more) to build your code if your project\n+    #    uses a compiled language\n+\n+    #- run: |\n+    #   make bootstrap\n+    #   make release\n+\n+    - name: Perform CodeQL Analysis\n+      uses: github/codeql-action/analyze@v1\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Allow partial reads from a GorillaConn; add SetDeadline (from net.Conn)\n\nDescription: The current implementation of GorillaConn will drop data if the\r\nwebsocket frame isn't read 100%. For example, if a websocket frame is\r\nsize=3, and Read() is called with a []byte of len=1, the 2 other bytes\r\nin the frame are lost forever.\r\n\r\nThis is currently masked by the fact that this is used primarily in\r\nio.Copy to another socket (in ingress.Stream) - as long as the read buffer\r\nused by io.Copy is big enough (it is 32*1024, so in theory we could see\r\nthis today?) then data is copied over to the other socket.\r\n\r\nThe client then can do partial reads just fine as the kernel will take\r\ncare of the buffer from here on out.\r\n\r\nI hit this by trying to create my own tunnel and avoiding\r\ningress.Stream, but this could be a real bug today I think if a\r\nwebsocket frame bigger than 32*1024 was received, although it is also\r\npossible that we are lucky and the upstream size which I haven't checked\r\nuses a smaller buffer than that always.\r\n\r\nThe test I added hangs before my change, succeeds after.\r\n\r\nAlso add SetDeadline so that GorillaConn fully implements net.Conn\n\nCode Diff:\nwebsocket/connection.go\n@@ -1,15 +1,16 @@\n package websocket\n \n import (\n+\t\"bytes\"\n \t\"context\"\n+\t\"fmt\"\n \t\"io\"\n \t\"time\"\n \n-\t\"github.com/rs/zerolog\"\n-\n \tgobwas \"github.com/gobwas/ws\"\n \t\"github.com/gobwas/ws/wsutil\"\n \t\"github.com/gorilla/websocket\"\n+\t\"github.com/rs/zerolog\"\n )\n \n const (\n@@ -27,17 +28,29 @@ const (\n // This is still used by access carrier\n type GorillaConn struct {\n \t*websocket.Conn\n-\tlog *zerolog.Logger\n+\tlog     *zerolog.Logger\n+\treadBuf bytes.Buffer\n }\n \n // Read will read messages from the websocket connection\n func (c *GorillaConn) Read(p []byte) (int, error) {\n+\t// Intermediate buffer may contain unread bytes from the last read, start there before blocking on a new frame\n+\tif c.readBuf.Len() > 0 {\n+\t\treturn c.readBuf.Read(p)\n+\t}\n+\n \t_, message, err := c.Conn.ReadMessage()\n \tif err != nil {\n \t\treturn 0, err\n \t}\n-\treturn copy(p, message), nil\n \n+\tcopied := copy(p, message)\n+\n+\t// Write unread bytes to readBuf; if everything was read this is a no-op\n+\t// Write returns a nil error always and grows the buffer; everything is always written or panic\n+\tc.readBuf.Write(message[copied:])\n+\n+\treturn copied, nil\n }\n \n // Write will write messages to the websocket connection\n@@ -49,6 +62,19 @@ func (c *GorillaConn) Write(p []byte) (int, error) {\n \treturn len(p), nil\n }\n \n+// SetDeadline sets both read and write deadlines, as per net.Conn interface docs:\n+// \"It is equivalent to calling both SetReadDeadline and SetWriteDeadline.\"\n+// Note there is no synchronization here, but the gorilla implementation isn't thread safe anyway\n+func (c *GorillaConn) SetDeadline(t time.Time) error {\n+\tif err := c.Conn.SetReadDeadline(t); err != nil {\n+\t\treturn fmt.Errorf(\"error setting read deadline: %w\", err)\n+\t}\n+\tif err := c.Conn.SetWriteDeadline(t); err != nil {\n+\t\treturn fmt.Errorf(\"error setting write deadline: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n // pinger simulates the websocket connection to keep it alive\n func (c *GorillaConn) pinger(ctx context.Context) {\n \tticker := time.NewTicker(pingPeriod)\n---\nwebsocket/websocket.go\n@@ -114,7 +114,7 @@ func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n \t}\n \t_ = conn.SetReadDeadline(time.Now().Add(pongWait))\n \tconn.SetPongHandler(func(string) error { _ = conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })\n-\tgorillaConn := &GorillaConn{conn, h.log}\n+\tgorillaConn := &GorillaConn{Conn: conn, log: h.log}\n \tgo gorillaConn.pinger(r.Context())\n \tdefer conn.Close()\n \n---\nwebsocket/websocket_test.go\n@@ -1,18 +1,23 @@\n package websocket\n \n import (\n+\t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n[[MASK]]\n \t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog\"\n \n \t\"github.com/cloudflare/cloudflared/hello\"\n \t\"github.com/cloudflare/cloudflared/tlsconfig\"\n \tgws \"github.com/gorilla/websocket\"\n \t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n \t\"golang.org/x/net/websocket\"\n )\n \n@@ -102,6 +107,51 @@ func TestServe(t *testing.T) {\n \t<-errC\n }\n \n+func TestWebsocketWrapper(t *testing.T) {\n+\n+\tlistener, err := hello.CreateTLSListener(\"localhost:0\")\n+\trequire.NoError(t, err)\n+\n+\tserverErrorChan := make(chan error)\n+\thelloSvrCtx, cancelHelloSvr := context.WithCancel(context.Background())\n+\tdefer func() { <-serverErrorChan }()\n+\tdefer cancelHelloSvr()\n+\tgo func() {\n+\t\tlog := zerolog.Nop()\n+\t\tserverErrorChan <- hello.StartHelloWorldServer(&log, listener, helloSvrCtx.Done())\n+\t}()\n+\n+\ttlsConfig := websocketClientTLSConfig(t)\n+\td := gws.Dialer{TLSClientConfig: tlsConfig, HandshakeTimeout: time.Minute}\n+\ttestAddr := fmt.Sprintf(\"https://%s/ws\", listener.Addr().String())\n+\treq := testRequest(t, testAddr, nil)\n+\tconn, resp, err := ClientConnect(req, &d)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, testSecWebsocketAccept, resp.Header.Get(\"Sec-WebSocket-Accept\"))\n+\n+\t// Websocket now connected to test server so lets check our wrapper\n+\twrapper := GorillaConn{Conn: conn}\n+\tbuf := make([]byte, 100)\n+\twrapper.Write([]byte(\"abc\"))\n+\tn, err := wrapper.Read(buf)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, n, 3)\n+\trequire.Equal(t, \"abc\", string(buf[:n]))\n+\n+\t// Test partial read, read 1 of 3 bytes in one read and the other 2 in another read\n+\twrapper.Write([]byte(\"abc\"))\n+\tbuf = buf[:1]\n+\tn, err = wrapper.Read(buf)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, n, 1)\n+\trequire.Equal(t, \"a\", string(buf[:n]))\n+\tbuf = buf[:cap(buf)]\n+\tn, err = wrapper.Read(buf)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, n, 2)\n+\trequire.Equal(t, \"bc\", string(buf[:n]))\n+}\n+\n // func TestStartProxyServer(t *testing.T) {\n // \tvar wg sync.WaitGroup\n // \tremoteAddress := \"localhost:1113\"\n---\n\n"}], "ideal": "websocket/connection.go\n@@ -1,15 +1,16 @@\n package websocket\n \n import (\n+\t\"bytes\"\n \t\"context\"\n+\t\"fmt\"\n \t\"io\"\n \t\"time\"\n \n-\t\"github.com/rs/zerolog\"\n-\n \tgobwas \"github.com/gobwas/ws\"\n \t\"github.com/gobwas/ws/wsutil\"\n \t\"github.com/gorilla/websocket\"\n+\t\"github.com/rs/zerolog\"\n )\n \n const (\n@@ -27,17 +28,29 @@ const (\n // This is still used by access carrier\n type GorillaConn struct {\n \t*websocket.Conn\n-\tlog *zerolog.Logger\n+\tlog     *zerolog.Logger\n+\treadBuf bytes.Buffer\n }\n \n // Read will read messages from the websocket connection\n func (c *GorillaConn) Read(p []byte) (int, error) {\n+\t// Intermediate buffer may contain unread bytes from the last read, start there before blocking on a new frame\n+\tif c.readBuf.Len() > 0 {\n+\t\treturn c.readBuf.Read(p)\n+\t}\n+\n \t_, message, err := c.Conn.ReadMessage()\n \tif err != nil {\n \t\treturn 0, err\n \t}\n-\treturn copy(p, message), nil\n \n+\tcopied := copy(p, message)\n+\n+\t// Write unread bytes to readBuf; if everything was read this is a no-op\n+\t// Write returns a nil error always and grows the buffer; everything is always written or panic\n+\tc.readBuf.Write(message[copied:])\n+\n+\treturn copied, nil\n }\n \n // Write will write messages to the websocket connection\n@@ -49,6 +62,19 @@ func (c *GorillaConn) Write(p []byte) (int, error) {\n \treturn len(p), nil\n }\n \n+// SetDeadline sets both read and write deadlines, as per net.Conn interface docs:\n+// \"It is equivalent to calling both SetReadDeadline and SetWriteDeadline.\"\n+// Note there is no synchronization here, but the gorilla implementation isn't thread safe anyway\n+func (c *GorillaConn) SetDeadline(t time.Time) error {\n+\tif err := c.Conn.SetReadDeadline(t); err != nil {\n+\t\treturn fmt.Errorf(\"error setting read deadline: %w\", err)\n+\t}\n+\tif err := c.Conn.SetWriteDeadline(t); err != nil {\n+\t\treturn fmt.Errorf(\"error setting write deadline: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n // pinger simulates the websocket connection to keep it alive\n func (c *GorillaConn) pinger(ctx context.Context) {\n \tticker := time.NewTicker(pingPeriod)\n---\nwebsocket/websocket.go\n@@ -114,7 +114,7 @@ func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n \t}\n \t_ = conn.SetReadDeadline(time.Now().Add(pongWait))\n \tconn.SetPongHandler(func(string) error { _ = conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })\n-\tgorillaConn := &GorillaConn{conn, h.log}\n+\tgorillaConn := &GorillaConn{Conn: conn, log: h.log}\n \tgo gorillaConn.pinger(r.Context())\n \tdefer conn.Close()\n \n---\nwebsocket/websocket_test.go\n@@ -1,18 +1,23 @@\n package websocket\n \n import (\n+\t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n-\t\"github.com/rs/zerolog\"\n+\t\"fmt\"\n \t\"io\"\n \t\"math/rand\"\n \t\"net/http\"\n \t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog\"\n \n \t\"github.com/cloudflare/cloudflared/hello\"\n \t\"github.com/cloudflare/cloudflared/tlsconfig\"\n \tgws \"github.com/gorilla/websocket\"\n \t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n \t\"golang.org/x/net/websocket\"\n )\n \n@@ -102,6 +107,51 @@ func TestServe(t *testing.T) {\n \t<-errC\n }\n \n+func TestWebsocketWrapper(t *testing.T) {\n+\n+\tlistener, err := hello.CreateTLSListener(\"localhost:0\")\n+\trequire.NoError(t, err)\n+\n+\tserverErrorChan := make(chan error)\n+\thelloSvrCtx, cancelHelloSvr := context.WithCancel(context.Background())\n+\tdefer func() { <-serverErrorChan }()\n+\tdefer cancelHelloSvr()\n+\tgo func() {\n+\t\tlog := zerolog.Nop()\n+\t\tserverErrorChan <- hello.StartHelloWorldServer(&log, listener, helloSvrCtx.Done())\n+\t}()\n+\n+\ttlsConfig := websocketClientTLSConfig(t)\n+\td := gws.Dialer{TLSClientConfig: tlsConfig, HandshakeTimeout: time.Minute}\n+\ttestAddr := fmt.Sprintf(\"https://%s/ws\", listener.Addr().String())\n+\treq := testRequest(t, testAddr, nil)\n+\tconn, resp, err := ClientConnect(req, &d)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, testSecWebsocketAccept, resp.Header.Get(\"Sec-WebSocket-Accept\"))\n+\n+\t// Websocket now connected to test server so lets check our wrapper\n+\twrapper := GorillaConn{Conn: conn}\n+\tbuf := make([]byte, 100)\n+\twrapper.Write([]byte(\"abc\"))\n+\tn, err := wrapper.Read(buf)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, n, 3)\n+\trequire.Equal(t, \"abc\", string(buf[:n]))\n+\n+\t// Test partial read, read 1 of 3 bytes in one read and the other 2 in another read\n+\twrapper.Write([]byte(\"abc\"))\n+\tbuf = buf[:1]\n+\tn, err = wrapper.Read(buf)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, n, 1)\n+\trequire.Equal(t, \"a\", string(buf[:n]))\n+\tbuf = buf[:cap(buf)]\n+\tn, err = wrapper.Read(buf)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, n, 2)\n+\trequire.Equal(t, \"bc\", string(buf[:n]))\n+}\n+\n // func TestStartProxyServer(t *testing.T) {\n // \tvar wg sync.WaitGroup\n // \tremoteAddress := \"localhost:1113\"\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Issue #285 - Makefile does not detect TARGET_ARCH correctly on FreeBSD \n\nDescription: Simple Makefile fix for Issue #285 (Makefile does not detect TARGET_ARCH correctly on FreeBSD )\r\n\r\nBuild / runs tests cleanly on FreeBSD 12.2 (see [gmake.log](https://github.com/cloudflare/cloudflared/files/6055307/gmake.log))\r\n\r\n(Note I added a note to the comment to the `make vet` target not to run `go get github.com/BurntSushi/go-sumtype` in the build dir as this causes a bunch of vendoring issues)\r\n \r\n(Note - Issue discussion suggested @Michael9127 as reviewer but don't think I have permissions to assign this)\n\nCode Diff:\nMakefile\n@@ -34,6 +34,8 @@ ifneq ($(GOARCH),)\n     TARGET_ARCH ?= $(GOARCH)\n else ifeq ($(LOCAL_ARCH),x86_64)\n     TARGET_ARCH ?= amd64\n+else ifeq ($(LOCAL_ARCH),amd64)\n+    TARGET_ARCH ?= amd64\n else ifeq ($(LOCAL_ARCH),i686)\n     TARGET_ARCH ?= amd64\n else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 5),armv8)\n@@ -236,7 +238,7 @@ tunnelrpc/tunnelrpc.capnp.go: tunnelrpc/tunnelrpc.capnp\n .PHONY: vet\n vet:\n \tgo vet -mod=vendor ./...\n-\twhich go-sumtype  # go get github.com/BurntSushi/go-sumtype\n[[MASK]]\n\n"}], "ideal": "Makefile\n@@ -34,6 +34,8 @@ ifneq ($(GOARCH),)\n     TARGET_ARCH ?= $(GOARCH)\n else ifeq ($(LOCAL_ARCH),x86_64)\n     TARGET_ARCH ?= amd64\n+else ifeq ($(LOCAL_ARCH),amd64)\n+    TARGET_ARCH ?= amd64\n else ifeq ($(LOCAL_ARCH),i686)\n     TARGET_ARCH ?= amd64\n else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 5),armv8)\n@@ -236,7 +238,7 @@ tunnelrpc/tunnelrpc.capnp.go: tunnelrpc/tunnelrpc.capnp\n .PHONY: vet\n vet:\n \tgo vet -mod=vendor ./...\n-\twhich go-sumtype  # go get github.com/BurntSushi/go-sumtype\n+\twhich go-sumtype  # go get github.com/BurntSushi/go-sumtype (don't do this in build directory or this will cause vendor issues)\n \tgo-sumtype $$(go list -mod=vendor ./...)\n \n .PHONY: msi\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Update README.md links\n\nDescription: Updates to the new Cloudflare documentation links\n\nCode Diff:\nREADME.md\n@@ -1,6 +1,6 @@\n # Argo Tunnel client\n \n-Contains the command-line client for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network. Extensive documentation can be found in the [Argo Tunnel section](https://developers.cloudflare.com/argo-tunnel/) of the Cloudflare Docs.\n+Contains the command-line client for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network. Extensive documentation can be found in the [Argo Tunnel section](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps) of the Cloudflare Docs.\n \n ## Before you get started\n \n@@ -13,29 +13,29 @@ Before you use Argo Tunnel, you'll need to complete a few steps in the Cloudflar\n \n Downloads are available as standalone binaries, a Docker image, and Debian, RPM, and Homebrew packages. You can also find releases here on the `cloudflared` GitHub repository.\n \n-* You can [install on macOS](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#macos) via Homebrew or by downloading the [latest Darwin amd64 release](https://github.com/cloudflare/cloudflared/releases)\n-* Binaries, Debian, and RPM packages for Linux [can be found here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#linux)\n+* You can [install on macOS](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#macos) via Homebrew or by downloading the [latest Darwin amd64 release](https://github.com/cloudflare/cloudflared/releases)\n+* Binaries, Debian, and RPM packages for Linux [can be found here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#linux)\n * A Docker image of `cloudflared` is [available on DockerHub](https://hub.docker.com/r/cloudflare/cloudflared)\n-* You can install on Windows machines with the [steps here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#windows)\n+* You can install on Windows machines with the [steps here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#windows)\n \n-User documentation for Argo Tunnel can be found at https://developers.cloudflare.com/argo-tunnel/\n+User documentation for Argo Tunnel can be found at https://developers.cloudflare.com/cloudflare-one/connections/connect-apps\n \n ## Creating Tunnels and routing traffic\n[[MASK]]\n+* Create a Tunnel with [these instructions](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/create-tunnel)\n+* Route traffic to that Tunnel with [DNS records in Cloudflare](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/routing-to-tunnel/dns) or with a [Cloudflare Load Balancer](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/routing-to-tunnel/lb)\n \n ## TryCloudflare\n \n-Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/argo-tunnel/learning/trycloudflare).\n+Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/trycloudflare).\n \n ## Deprecated versions\n \n Cloudflare currently supports all versions of `cloudflared`. Starting on March 20, 2021, Cloudflare will no longer support versions released prior to 2020.5.1.\n \n-All features available in versions released prior to 2020.5.1 are available in current versions. Breaking changes unrelated to feature availability may be introduced that will impact versions released prior to 2020.5.1. You can read more about upgrading `cloudflared` in our [developer documentation](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#updating-cloudflared).\n+All features available in versions released prior to 2020.5.1 are available in current versions. Breaking changes unrelated to feature availability may be introduced that will impact versions released prior to 2020.5.1. You can read more about upgrading `cloudflared` in our [developer documentation](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#updating-cloudflared).\n \n | Version(s) | Deprecation status |\n |---|---|\n---\n\n"}], "ideal": "README.md\n@@ -1,6 +1,6 @@\n # Argo Tunnel client\n \n-Contains the command-line client for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network. Extensive documentation can be found in the [Argo Tunnel section](https://developers.cloudflare.com/argo-tunnel/) of the Cloudflare Docs.\n+Contains the command-line client for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network. Extensive documentation can be found in the [Argo Tunnel section](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps) of the Cloudflare Docs.\n \n ## Before you get started\n \n@@ -13,29 +13,29 @@ Before you use Argo Tunnel, you'll need to complete a few steps in the Cloudflar\n \n Downloads are available as standalone binaries, a Docker image, and Debian, RPM, and Homebrew packages. You can also find releases here on the `cloudflared` GitHub repository.\n \n-* You can [install on macOS](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#macos) via Homebrew or by downloading the [latest Darwin amd64 release](https://github.com/cloudflare/cloudflared/releases)\n-* Binaries, Debian, and RPM packages for Linux [can be found here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#linux)\n+* You can [install on macOS](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#macos) via Homebrew or by downloading the [latest Darwin amd64 release](https://github.com/cloudflare/cloudflared/releases)\n+* Binaries, Debian, and RPM packages for Linux [can be found here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#linux)\n * A Docker image of `cloudflared` is [available on DockerHub](https://hub.docker.com/r/cloudflare/cloudflared)\n-* You can install on Windows machines with the [steps here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#windows)\n+* You can install on Windows machines with the [steps here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#windows)\n \n-User documentation for Argo Tunnel can be found at https://developers.cloudflare.com/argo-tunnel/\n+User documentation for Argo Tunnel can be found at https://developers.cloudflare.com/cloudflare-one/connections/connect-apps\n \n ## Creating Tunnels and routing traffic\n \n Once installed, you can authenticate `cloudflared` into your Cloudflare account and begin creating Tunnels that serve traffic for hostnames in your account.\n \n-* Create a Tunnel with [these instructions](https://developers.cloudflare.com/argo-tunnel/create-tunnel)\n-* Route traffic to that Tunnel with [DNS records in Cloudflare](https://developers.cloudflare.com/argo-tunnel/routing-to-tunnel/dns) or with a [Cloudflare Load Balancer](https://developers.cloudflare.com/argo-tunnel/routing-to-tunnel/lb)\n+* Create a Tunnel with [these instructions](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/create-tunnel)\n+* Route traffic to that Tunnel with [DNS records in Cloudflare](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/routing-to-tunnel/dns) or with a [Cloudflare Load Balancer](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/routing-to-tunnel/lb)\n \n ## TryCloudflare\n \n-Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/argo-tunnel/learning/trycloudflare).\n+Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/trycloudflare).\n \n ## Deprecated versions\n \n Cloudflare currently supports all versions of `cloudflared`. Starting on March 20, 2021, Cloudflare will no longer support versions released prior to 2020.5.1.\n \n-All features available in versions released prior to 2020.5.1 are available in current versions. Breaking changes unrelated to feature availability may be introduced that will impact versions released prior to 2020.5.1. You can read more about upgrading `cloudflared` in our [developer documentation](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#updating-cloudflared).\n+All features available in versions released prior to 2020.5.1 are available in current versions. Breaking changes unrelated to feature availability may be introduced that will impact versions released prior to 2020.5.1. You can read more about upgrading `cloudflared` in our [developer documentation](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#updating-cloudflared).\n \n | Version(s) | Deprecation status |\n |---|---|\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: feat(tunnel): add TUNNEL_ORIGIN_CERT_CONTENT env\n\nDescription: This PR adds support for specifying the origin certificate content\r\nas an environment variable.\r\nThis is useful when deploying cloudflared in environments where writing\r\na file is not possible, ex: Heroku\r\n\r\nThe cert must be base64 encoded.\n\nCode Diff:\ncmd/cloudflared/tunnel/configuration.go\n@@ -2,6 +2,7 @@ package tunnel\n \n import (\n \t\"crypto/tls\"\n+\t\"encoding/base64\"\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -35,6 +36,11 @@ var (\n \targumentsUrl    = developerPortal + \"/reference/arguments/\"\n[[MASK]]\n+)\n+\n // returns the first path that contains a cert.pem file. If none of the DefaultConfigSearchDirectories\n // contains a cert.pem file, return empty string\n func findDefaultOriginCertPath() string {\n@@ -95,7 +101,7 @@ func dnsProxyStandAlone(c *cli.Context) bool {\n \n func findOriginCert(c *cli.Context, logger logger.Service) (string, error) {\n \toriginCertPath := c.String(\"origincert\")\n-\tif originCertPath == \"\" {\n+\tif originCertPath == \"\" && os.Getenv(encodedOriginCert) == \"\" {\n \t\tlogger.Infof(\"Cannot determine default origin certificate path. No file %s in %v\", config.DefaultCredentialFile, config.DefaultConfigSearchDirectories())\n \t\tif isRunningFromTerminal() {\n \t\t\tlogger.Errorf(\"You need to specify the origin certificate path with --origincert option, or set TUNNEL_ORIGIN_CERT environment variable. See %s for more information.\", argumentsUrl)\n@@ -146,6 +152,11 @@ func readOriginCert(originCertPath string, logger logger.Service) ([]byte, error\n }\n \n func getOriginCert(c *cli.Context, logger logger.Service) ([]byte, error) {\n+\t// check if cert is present as a base64 encoded ENV\n+\tcertContent := os.Getenv(encodedOriginCert)\n+\tif certContent != \"\" {\n+\t\treturn base64.StdEncoding.DecodeString(certContent)\n+\t}\n \tif originCertPath, err := findOriginCert(c, logger); err != nil {\n \t\treturn nil, err\n \t} else {\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/configuration.go\n@@ -2,6 +2,7 @@ package tunnel\n \n import (\n \t\"crypto/tls\"\n+\t\"encoding/base64\"\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -35,6 +36,11 @@ var (\n \targumentsUrl    = developerPortal + \"/reference/arguments/\"\n )\n \n+const (\n+\t// name of the environment variable that contains the base64 encoded origin cert\n+\tencodedOriginCert = \"TUNNEL_ORIGIN_CERT_CONTENT\"\n+)\n+\n // returns the first path that contains a cert.pem file. If none of the DefaultConfigSearchDirectories\n // contains a cert.pem file, return empty string\n func findDefaultOriginCertPath() string {\n@@ -95,7 +101,7 @@ func dnsProxyStandAlone(c *cli.Context) bool {\n \n func findOriginCert(c *cli.Context, logger logger.Service) (string, error) {\n \toriginCertPath := c.String(\"origincert\")\n-\tif originCertPath == \"\" {\n+\tif originCertPath == \"\" && os.Getenv(encodedOriginCert) == \"\" {\n \t\tlogger.Infof(\"Cannot determine default origin certificate path. No file %s in %v\", config.DefaultCredentialFile, config.DefaultConfigSearchDirectories())\n \t\tif isRunningFromTerminal() {\n \t\t\tlogger.Errorf(\"You need to specify the origin certificate path with --origincert option, or set TUNNEL_ORIGIN_CERT environment variable. See %s for more information.\", argumentsUrl)\n@@ -146,6 +152,11 @@ func readOriginCert(originCertPath string, logger logger.Service) ([]byte, error\n }\n \n func getOriginCert(c *cli.Context, logger logger.Service) ([]byte, error) {\n+\t// check if cert is present as a base64 encoded ENV\n+\tcertContent := os.Getenv(encodedOriginCert)\n+\tif certContent != \"\" {\n+\t\treturn base64.StdEncoding.DecodeString(certContent)\n+\t}\n \tif originCertPath, err := findOriginCert(c, logger); err != nil {\n \t\treturn nil, err\n \t} else {\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Update link to documentation for running as a service.\n\nDescription: When you run cloudflared in Linux, it'll say:\r\n\r\n```\r\ncloudflared will not automatically update when run from the shell.\r\nTo enable auto-updates, run cloudflared as a service:\r\nhttps://developers.cloudflare.com/argo-tunnel/reference/service/\r\n```\r\n\r\nThis documentation seems to be out of date, however, and [causing some confusion](https://github.com/cloudflare/cloudflared/issues/251).  There also doesn't seem to be a way to actually navigate to this page from the [Argo Tunnel docs](https://developers.cloudflare.com/argo-tunnel/).  Note that when you visit the link above, none of the sections in the table of contents on the left side of the page are expanded.\r\n\r\nSo, this PR replaces this link with what seems to be more up-to-date documentation at https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service.\r\n\n\nCode Diff:\nREADME.md\n@@ -1,9 +1,32 @@\n # Argo Tunnel client\n \n-Contains the command-line client and its libraries for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network.\n+Contains the command-line client for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network. Extensive documentation can be found in the [Argo Tunnel section](https://developers.cloudflare.com/argo-tunnel/) of the Cloudflare Docs.\n \n-## Getting started\n+## Before you get started\n \n-    go install github.com/cloudflare/cloudflared/cmd/cloudflared\n+Before you use Argo Tunnel, you'll need to complete a few steps in the Cloudflare dashboard. The website you add to Cloudflare will be used to route traffic to your Tunnel.\n+\n+1. [Add a website to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/201720164-Creating-a-Cloudflare-account-and-adding-a-website)\n+2. [Change your domain nameservers to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/205195708)\n+\n+## Installing `cloudflared`\n+\n+Downloads are available as standalone binaries, a Docker image, and Debian, RPM, and Homebrew packages. You can also find releases here on the `cloudflared` GitHub repository.\n+\n+* You can [install on macOS](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#macos) via Homebrew or by downloading the [latest Darwin amd64 release](https://github.com/cloudflare/cloudflared/releases)\n+* Binaries, Debian, and RPM packages for Linux [can be found here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#linux)\n+* A Docker image of `cloudflared` is [available on DockerHub](https://hub.docker.com/r/cloudflare/cloudflared)\n+* You can install on Windows machines with the [steps here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#windows)\n \n User documentation for Argo Tunnel can be found at https://developers.cloudflare.com/argo-tunnel/\n+\n+## Creating Tunnels and routing traffic\n+\n+Once installed, you can authenticate `cloudflared` into your Cloudflare account and begin creating Tunnels that serve traffic for hostnames in your account.\n+\n+* Create a Tunnel with [these instructions](https://developers.cloudflare.com/argo-tunnel/create-tunnel)\n+* Route traffic to that Tunnel with [DNS records in Cloudflare](https://developers.cloudflare.com/argo-tunnel/routing-to-tunnel/dns) or with a [Cloudflare Load Balancer](https://developers.cloudflare.com/argo-tunnel/routing-to-tunnel/lb)\n+\n+## TryCloudflare\n+\n+Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/argo-tunnel/learning/trycloudflare).\n---\ncmd/cloudflared/macos_service.go\n@@ -119,7 +119,7 @@ func installLaunchd(c *cli.Context) error {\n \t\tlogger.Infof(\"Installing Argo Tunnel client as an user launch agent. \" +\n \t\t\t\"Note that Argo Tunnel client will only run when the user is logged in. \" +\n \t\t\t\"If you want to run Argo Tunnel client at boot, install with root permission. \" +\n-\t\t\t\"For more information, visit https://developers.cloudflare.com/argo-tunnel/reference/service/\")\n+\t\t\t\"For more information, visit https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service\")\n \t}\n \tetPath, err := os.Executable()\n \tif err != nil {\n---\ncmd/cloudflared/updater/update.go\n[[MASK]]\n+\tnoUpdateInShellMessage        = \"cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service\"\n \tnoUpdateOnWindowsMessage      = \"cloudflared will not automatically update on Windows systems.\"\n \tnoUpdateManagedPackageMessage = \"cloudflared will not automatically update if installed by a package manager.\"\n \tisManagedInstallFile          = \".installedFromPackageManager\"\n---\ncmd/cloudflared/windows_service.go\n@@ -25,7 +25,7 @@ import (\n const (\n \twindowsServiceName        = \"Cloudflared\"\n \twindowsServiceDescription = \"Argo Tunnel agent\"\n-\twindowsServiceUrl         = \"https://developers.cloudflare.com/argo-tunnel/reference/service/\"\n+\twindowsServiceUrl         = \"https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service\"\n \n \trecoverActionDelay      = time.Second * 20\n \tfailureCountResetPeriod = time.Hour * 24\n---\n\n"}], "ideal": "README.md\n@@ -1,9 +1,32 @@\n # Argo Tunnel client\n \n-Contains the command-line client and its libraries for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network.\n+Contains the command-line client for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network. Extensive documentation can be found in the [Argo Tunnel section](https://developers.cloudflare.com/argo-tunnel/) of the Cloudflare Docs.\n \n-## Getting started\n+## Before you get started\n \n-    go install github.com/cloudflare/cloudflared/cmd/cloudflared\n+Before you use Argo Tunnel, you'll need to complete a few steps in the Cloudflare dashboard. The website you add to Cloudflare will be used to route traffic to your Tunnel.\n+\n+1. [Add a website to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/201720164-Creating-a-Cloudflare-account-and-adding-a-website)\n+2. [Change your domain nameservers to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/205195708)\n+\n+## Installing `cloudflared`\n+\n+Downloads are available as standalone binaries, a Docker image, and Debian, RPM, and Homebrew packages. You can also find releases here on the `cloudflared` GitHub repository.\n+\n+* You can [install on macOS](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#macos) via Homebrew or by downloading the [latest Darwin amd64 release](https://github.com/cloudflare/cloudflared/releases)\n+* Binaries, Debian, and RPM packages for Linux [can be found here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#linux)\n+* A Docker image of `cloudflared` is [available on DockerHub](https://hub.docker.com/r/cloudflare/cloudflared)\n+* You can install on Windows machines with the [steps here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#windows)\n \n User documentation for Argo Tunnel can be found at https://developers.cloudflare.com/argo-tunnel/\n+\n+## Creating Tunnels and routing traffic\n+\n+Once installed, you can authenticate `cloudflared` into your Cloudflare account and begin creating Tunnels that serve traffic for hostnames in your account.\n+\n+* Create a Tunnel with [these instructions](https://developers.cloudflare.com/argo-tunnel/create-tunnel)\n+* Route traffic to that Tunnel with [DNS records in Cloudflare](https://developers.cloudflare.com/argo-tunnel/routing-to-tunnel/dns) or with a [Cloudflare Load Balancer](https://developers.cloudflare.com/argo-tunnel/routing-to-tunnel/lb)\n+\n+## TryCloudflare\n+\n+Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/argo-tunnel/learning/trycloudflare).\n---\ncmd/cloudflared/macos_service.go\n@@ -119,7 +119,7 @@ func installLaunchd(c *cli.Context) error {\n \t\tlogger.Infof(\"Installing Argo Tunnel client as an user launch agent. \" +\n \t\t\t\"Note that Argo Tunnel client will only run when the user is logged in. \" +\n \t\t\t\"If you want to run Argo Tunnel client at boot, install with root permission. \" +\n-\t\t\t\"For more information, visit https://developers.cloudflare.com/argo-tunnel/reference/service/\")\n+\t\t\t\"For more information, visit https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service\")\n \t}\n \tetPath, err := os.Executable()\n \tif err != nil {\n---\ncmd/cloudflared/updater/update.go\n@@ -20,7 +20,7 @@ import (\n const (\n \tDefaultCheckUpdateFreq        = time.Hour * 24\n \tappID                         = \"app_idCzgxYerVD\"\n-\tnoUpdateInShellMessage        = \"cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/argo-tunnel/reference/service/\"\n+\tnoUpdateInShellMessage        = \"cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service\"\n \tnoUpdateOnWindowsMessage      = \"cloudflared will not automatically update on Windows systems.\"\n \tnoUpdateManagedPackageMessage = \"cloudflared will not automatically update if installed by a package manager.\"\n \tisManagedInstallFile          = \".installedFromPackageManager\"\n---\ncmd/cloudflared/windows_service.go\n@@ -25,7 +25,7 @@ import (\n const (\n \twindowsServiceName        = \"Cloudflared\"\n \twindowsServiceDescription = \"Argo Tunnel agent\"\n-\twindowsServiceUrl         = \"https://developers.cloudflare.com/argo-tunnel/reference/service/\"\n+\twindowsServiceUrl         = \"https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service\"\n \n \trecoverActionDelay      = time.Second * 20\n \tfailureCountResetPeriod = time.Hour * 24\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: refactor: rename hostnameFromURI to hostFromURI\n\nDescription: since host=hostname+port\r\n\r\nreuse the url variable\n\nCode Diff:\ncmd/cloudflared/tunnel/cmd.go\n@@ -422,7 +422,7 @@ func StartServer(c *cli.Context, version string, shutdownC, graceShutdownC chan\n \t\treturn fmt.Errorf(errText)\n \t}\n \n-\tif staticHost := hostnameFromURI(c.String(\"url\")); isProxyDestinationConfigured(staticHost, c) {\n+\tif staticHost := hostFromURI(url); isProxyDestinationConfigured(staticHost, c) {\n \t\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:\")\n \t\tif err != nil {\n \t\t\tlogger.Errorf(\"Cannot start Websocket Proxy Server: %s\", err)\n@@ -570,7 +570,7 @@ func writePidFile(waitForSignal *signal.Signal, pidFile string, logger logger.Se\n \tfmt.Fprintf(file, \"%d\", os.Getpid())\n[[MASK]]\n \tif err != nil {\n \t\treturn \"\"\n---\ncmd/cloudflared/tunnel/cmd_test.go\n@@ -6,12 +6,12 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n )\n \n-func TestHostnameFromURI(t *testing.T) {\n-\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostnameFromURI(\"ssh://awesome.warptunnels.horse:22\"))\n-\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostnameFromURI(\"ssh://awesome.warptunnels.horse\"))\n-\tassert.Equal(t, \"awesome.warptunnels.horse:2222\", hostnameFromURI(\"ssh://awesome.warptunnels.horse:2222\"))\n-\tassert.Equal(t, \"localhost:3389\", hostnameFromURI(\"rdp://localhost\"))\n-\tassert.Equal(t, \"localhost:3390\", hostnameFromURI(\"rdp://localhost:3390\"))\n-\tassert.Equal(t, \"\", hostnameFromURI(\"trash\"))\n-\tassert.Equal(t, \"\", hostnameFromURI(\"https://awesomesauce.com\"))\n+func TestHostFromURI(t *testing.T) {\n+\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostFromURI(\"ssh://awesome.warptunnels.horse:22\"))\n+\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostFromURI(\"ssh://awesome.warptunnels.horse\"))\n+\tassert.Equal(t, \"awesome.warptunnels.horse:2222\", hostFromURI(\"ssh://awesome.warptunnels.horse:2222\"))\n+\tassert.Equal(t, \"localhost:3389\", hostFromURI(\"rdp://localhost\"))\n+\tassert.Equal(t, \"localhost:3390\", hostFromURI(\"rdp://localhost:3390\"))\n+\tassert.Equal(t, \"\", hostFromURI(\"trash\"))\n+\tassert.Equal(t, \"\", hostFromURI(\"https://awesomesauce.com\"))\n }\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/cmd.go\n@@ -422,7 +422,7 @@ func StartServer(c *cli.Context, version string, shutdownC, graceShutdownC chan\n \t\treturn fmt.Errorf(errText)\n \t}\n \n-\tif staticHost := hostnameFromURI(c.String(\"url\")); isProxyDestinationConfigured(staticHost, c) {\n+\tif staticHost := hostFromURI(url); isProxyDestinationConfigured(staticHost, c) {\n \t\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:\")\n \t\tif err != nil {\n \t\t\tlogger.Errorf(\"Cannot start Websocket Proxy Server: %s\", err)\n@@ -570,7 +570,7 @@ func writePidFile(waitForSignal *signal.Signal, pidFile string, logger logger.Se\n \tfmt.Fprintf(file, \"%d\", os.Getpid())\n }\n \n-func hostnameFromURI(uri string) string {\n+func hostFromURI(uri string) string {\n \tu, err := url.Parse(uri)\n \tif err != nil {\n \t\treturn \"\"\n---\ncmd/cloudflared/tunnel/cmd_test.go\n@@ -6,12 +6,12 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n )\n \n-func TestHostnameFromURI(t *testing.T) {\n-\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostnameFromURI(\"ssh://awesome.warptunnels.horse:22\"))\n-\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostnameFromURI(\"ssh://awesome.warptunnels.horse\"))\n-\tassert.Equal(t, \"awesome.warptunnels.horse:2222\", hostnameFromURI(\"ssh://awesome.warptunnels.horse:2222\"))\n-\tassert.Equal(t, \"localhost:3389\", hostnameFromURI(\"rdp://localhost\"))\n-\tassert.Equal(t, \"localhost:3390\", hostnameFromURI(\"rdp://localhost:3390\"))\n-\tassert.Equal(t, \"\", hostnameFromURI(\"trash\"))\n-\tassert.Equal(t, \"\", hostnameFromURI(\"https://awesomesauce.com\"))\n+func TestHostFromURI(t *testing.T) {\n+\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostFromURI(\"ssh://awesome.warptunnels.horse:22\"))\n+\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostFromURI(\"ssh://awesome.warptunnels.horse\"))\n+\tassert.Equal(t, \"awesome.warptunnels.horse:2222\", hostFromURI(\"ssh://awesome.warptunnels.horse:2222\"))\n+\tassert.Equal(t, \"localhost:3389\", hostFromURI(\"rdp://localhost\"))\n+\tassert.Equal(t, \"localhost:3390\", hostFromURI(\"rdp://localhost:3390\"))\n+\tassert.Equal(t, \"\", hostFromURI(\"trash\"))\n+\tassert.Equal(t, \"\", hostFromURI(\"https://awesomesauce.com\"))\n }\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: added option to map multiple cname hosts to multiple local origins\n\nDescription: This add support for multiple local origin through a single cloudflared process.\r\nConfig file example to use it is as follows:\r\n\r\n```\r\nhostname: public.opus.ai\r\n # default url that will use any requests not coming through cname hosts\r\nurl: http://192.168.3.10:8080\r\nlogfile: ./cloudflared.log\r\norigincert: ./cert.pem\r\nno-autoupdate: true\r\nhost-to-origin:\r\n    # first service cnamed to public.example.com\r\n    - service1.opus.ai=http://localhost:8080\r\n    # second service cnamed to public.example.com\r\n    - service2.opus.ai=http://192.168.3.10:8080\r\n   .... # and so on\r\n```\r\n\r\n\r\nNote that each service still needs to be cnamed manually in cloudflare panel. It should be possible to use the api through the service itself but I haven't explored it yet.\r\n\n\nCode Diff:\ncmd/cloudflared/tunnel/cmd.go\n@@ -768,6 +768,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_HOSTNAME\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringSliceFlag(&cli.StringSliceFlag{\n+\t\t\tName:    \"host-to-origin\",\n+\t\t\tUsage:   \"Decalre a direct host to origin mapping i.e. host1.example.com=http://localhost:8080. This takes precedence over the single url mapping.\",\n+\t\t\tEnvVars: []string{\"HOST_TO_ORIGIN\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewStringFlag(&cli.StringFlag{\n \t\t\tName:    \"http-host-header\",\n \t\t\tUsage:   \"Sets the HTTP Host header for the local webserver.\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -71,7 +71,7 @@ func logClientOptions(c *cli.Context) {\n \t\tflags[flag] = c.Generic(flag)\n \t}\n \n-\tsliceFlags := []string{\"header\", \"tag\", \"proxy-dns-upstream\", \"upstream\", \"edge\"}\n+\tsliceFlags := []string{\"header\", \"tag\", \"proxy-dns-upstream\", \"upstream\", \"edge\", \"host-to-origin\"}\n \tfor _, sliceFlag := range sliceFlags {\n \t\tif len(c.StringSlice(sliceFlag)) > 0 {\n \t\t\tflags[sliceFlag] = strings.Join(c.StringSlice(sliceFlag), \", \")\n@@ -179,6 +179,15 @@ func prepareTunnelConfig(\n \t\treturn nil, errors.Wrap(err, \"Error validating origin URL\")\n \t}\n \n+\thostToOriginUrls := make(map[string]string)\n+\thostToOrigins := c.StringSlice(\"host-to-origin\")\n+\tfor _, hostToOrigin := range hostToOrigins {\n+\t\thostToOriginArr := strings.Split(hostToOrigin, \"=\")\n+\t\tif len(hostToOriginArr) == 2 {\n+\t\t\thostToOriginUrls[hostToOriginArr[0]] = hostToOriginArr[1]\n+\t\t}\n+\t}\n+\n \tvar originCert []byte\n \tif !isFreeTunnel {\n \t\toriginCert, err = getOriginCert(c)\n@@ -268,6 +277,7 @@ func prepareTunnelConfig(\n \t\tNoChunkedEncoding:    c.Bool(\"no-chunked-encoding\"),\n \t\tOriginCert:           originCert,\n \t\tOriginUrl:            originURL,\n+\t\tHostToOriginUrls:     hostToOriginUrls,\n \t\tReportedVersion:      version,\n \t\tRetries:              c.Uint(\"retries\"),\n \t\tRunFromTerminal:      isRunningFromTerminal(),\n---\norigin/tunnel.go\n@@ -85,6 +85,8 @@ type TunnelConfig struct {\n \t// OriginUrl may not be used if a user specifies a unix socket.\n \tOriginUrl string\n \n+\t// Optional mapping to enable routing to multiple OriginUrls based on Host header.\n+\tHostToOriginUrls map[string]string\n \t// feature-flag to use new edge reconnect tokens\n \tUseReconnectToken bool\n \t// feature-flag for using ConnectionDigest\n@@ -540,6 +542,7 @@ func LogServerInfo(\n \n type TunnelHandler struct {\n \toriginUrl      string\n+\thostToOriginUrls map[string]string\n \thttpHostHeader string\n \tmuxer          *h2mux.Muxer\n \thttpClient     http.RoundTripper\n@@ -565,8 +568,16 @@ func NewTunnelHandler(ctx context.Context,\n \tif err != nil {\n \t\treturn nil, \"\", fmt.Errorf(\"unable to parse origin URL %#v\", originURL)\n \t}\n+\tfor k, _ := range config.HostToOriginUrls {\n+\t\thostOriginURL, err := validation.ValidateUrl(config.HostToOriginUrls[k])\n+\t\tif err != nil {\n+\t\t\treturn nil, \"\", fmt.Errorf(\"unable to parse origin URL %#v\", hostOriginURL)\n+\t\t}\n+\t\tconfig.HostToOriginUrls[k] = hostOriginURL\n+\t}\n \th := &TunnelHandler{\n \t\toriginUrl:         originURL,\n+\t\thostToOriginUrls:  config.HostToOriginUrls,\n \t\thttpHostHeader:    config.HTTPHostHeader,\n \t\thttpClient:        config.HTTPTransport,\n \t\ttlsConfig:         config.ClientTlsConfig,\n@@ -629,8 +640,27 @@ func (h *TunnelHandler) ServeStream(stream *h2mux.MuxedStream) error {\n \treturn nil\n }\n \n+func getOriginUrlForHost(h2 []h2mux.Header, hostToOriginUrls map[string]string) (string, string) {\n+\thost := \"\"\n+\tfor _, header := range h2 {\n[[MASK]]\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn host, \"\"\n+}\n+\n func (h *TunnelHandler) createRequest(stream *h2mux.MuxedStream) (*http.Request, error) {\n-\treq, err := http.NewRequest(\"GET\", h.originUrl, h2mux.MuxedStreamReader{MuxedStream: stream})\n+\thost, origin := getOriginUrlForHost(stream.Headers, h.hostToOriginUrls)\n+\n+\tif host == \"\" {\n+\t\torigin = h.originUrl\n+\t}\n+\treq, err := http.NewRequest(\"GET\", origin, h2mux.MuxedStreamReader{MuxedStream: stream})\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"Unexpected error from http.NewRequest\")\n \t}\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/cmd.go\n@@ -768,6 +768,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_HOSTNAME\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringSliceFlag(&cli.StringSliceFlag{\n+\t\t\tName:    \"host-to-origin\",\n+\t\t\tUsage:   \"Decalre a direct host to origin mapping i.e. host1.example.com=http://localhost:8080. This takes precedence over the single url mapping.\",\n+\t\t\tEnvVars: []string{\"HOST_TO_ORIGIN\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewStringFlag(&cli.StringFlag{\n \t\t\tName:    \"http-host-header\",\n \t\t\tUsage:   \"Sets the HTTP Host header for the local webserver.\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -71,7 +71,7 @@ func logClientOptions(c *cli.Context) {\n \t\tflags[flag] = c.Generic(flag)\n \t}\n \n-\tsliceFlags := []string{\"header\", \"tag\", \"proxy-dns-upstream\", \"upstream\", \"edge\"}\n+\tsliceFlags := []string{\"header\", \"tag\", \"proxy-dns-upstream\", \"upstream\", \"edge\", \"host-to-origin\"}\n \tfor _, sliceFlag := range sliceFlags {\n \t\tif len(c.StringSlice(sliceFlag)) > 0 {\n \t\t\tflags[sliceFlag] = strings.Join(c.StringSlice(sliceFlag), \", \")\n@@ -179,6 +179,15 @@ func prepareTunnelConfig(\n \t\treturn nil, errors.Wrap(err, \"Error validating origin URL\")\n \t}\n \n+\thostToOriginUrls := make(map[string]string)\n+\thostToOrigins := c.StringSlice(\"host-to-origin\")\n+\tfor _, hostToOrigin := range hostToOrigins {\n+\t\thostToOriginArr := strings.Split(hostToOrigin, \"=\")\n+\t\tif len(hostToOriginArr) == 2 {\n+\t\t\thostToOriginUrls[hostToOriginArr[0]] = hostToOriginArr[1]\n+\t\t}\n+\t}\n+\n \tvar originCert []byte\n \tif !isFreeTunnel {\n \t\toriginCert, err = getOriginCert(c)\n@@ -268,6 +277,7 @@ func prepareTunnelConfig(\n \t\tNoChunkedEncoding:    c.Bool(\"no-chunked-encoding\"),\n \t\tOriginCert:           originCert,\n \t\tOriginUrl:            originURL,\n+\t\tHostToOriginUrls:     hostToOriginUrls,\n \t\tReportedVersion:      version,\n \t\tRetries:              c.Uint(\"retries\"),\n \t\tRunFromTerminal:      isRunningFromTerminal(),\n---\norigin/tunnel.go\n@@ -85,6 +85,8 @@ type TunnelConfig struct {\n \t// OriginUrl may not be used if a user specifies a unix socket.\n \tOriginUrl string\n \n+\t// Optional mapping to enable routing to multiple OriginUrls based on Host header.\n+\tHostToOriginUrls map[string]string\n \t// feature-flag to use new edge reconnect tokens\n \tUseReconnectToken bool\n \t// feature-flag for using ConnectionDigest\n@@ -540,6 +542,7 @@ func LogServerInfo(\n \n type TunnelHandler struct {\n \toriginUrl      string\n+\thostToOriginUrls map[string]string\n \thttpHostHeader string\n \tmuxer          *h2mux.Muxer\n \thttpClient     http.RoundTripper\n@@ -565,8 +568,16 @@ func NewTunnelHandler(ctx context.Context,\n \tif err != nil {\n \t\treturn nil, \"\", fmt.Errorf(\"unable to parse origin URL %#v\", originURL)\n \t}\n+\tfor k, _ := range config.HostToOriginUrls {\n+\t\thostOriginURL, err := validation.ValidateUrl(config.HostToOriginUrls[k])\n+\t\tif err != nil {\n+\t\t\treturn nil, \"\", fmt.Errorf(\"unable to parse origin URL %#v\", hostOriginURL)\n+\t\t}\n+\t\tconfig.HostToOriginUrls[k] = hostOriginURL\n+\t}\n \th := &TunnelHandler{\n \t\toriginUrl:         originURL,\n+\t\thostToOriginUrls:  config.HostToOriginUrls,\n \t\thttpHostHeader:    config.HTTPHostHeader,\n \t\thttpClient:        config.HTTPTransport,\n \t\ttlsConfig:         config.ClientTlsConfig,\n@@ -629,8 +640,27 @@ func (h *TunnelHandler) ServeStream(stream *h2mux.MuxedStream) error {\n \treturn nil\n }\n \n+func getOriginUrlForHost(h2 []h2mux.Header, hostToOriginUrls map[string]string) (string, string) {\n+\thost := \"\"\n+\tfor _, header := range h2 {\n+\t\tswitch strings.ToLower(header.Name) {\n+\t\tcase \":authority\":\n+\t\t\thost := header.Value\n+\t\t\tif val, ok := hostToOriginUrls[header.Value]; ok {\n+\t\t\t    return host, val\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn host, \"\"\n+}\n+\n func (h *TunnelHandler) createRequest(stream *h2mux.MuxedStream) (*http.Request, error) {\n-\treq, err := http.NewRequest(\"GET\", h.originUrl, h2mux.MuxedStreamReader{MuxedStream: stream})\n+\thost, origin := getOriginUrlForHost(stream.Headers, h.hostToOriginUrls)\n+\n+\tif host == \"\" {\n+\t\torigin = h.originUrl\n+\t}\n+\treq, err := http.NewRequest(\"GET\", origin, h2mux.MuxedStreamReader{MuxedStream: stream})\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"Unexpected error from http.NewRequest\")\n \t}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Adding support for multi-architecture images and binaries\n\nDescription: Fixes: \r\n- #140 \r\n- #115 \r\n- #60 \r\n\r\nNote: Should also consider consolidating the following pull request if you wish to support releasing the binary.\r\n- #173 \n\nCode Diff:\nDockerfile\n@@ -1,8 +1,11 @@\n # use a builder image for building cloudflare\n+ARG TARGET_GOOS\n+ARG TARGET_GOARCH\n FROM golang:1.13.3 as builder\n-ENV GO111MODULE=on\n-ENV CGO_ENABLED=0\n-ENV GOOS=linux\n+ENV GO111MODULE=on \\\n+    CGO_ENABLED=0 \\\n+    TARGET_GOOS=${TARGET_GOOS} \\\n+    TARGET_GOARCH=${TARGET_GOARCH}\n \n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n@@ -12,8 +15,6 @@ COPY . .\n # compile cloudflared\n RUN make cloudflared\n \n-# ---\n-\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian10:nonroot\n \n---\nMakefile\n@@ -7,17 +7,35 @@ PACKAGE_DIR   := $(CURDIR)/packaging\n INSTALL_BINDIR := usr/local/bin\n \n EQUINOX_FLAGS = --version=\"$(VERSION)\" \\\n-\t\t\t\t --platforms=\"$(EQUINOX_BUILD_PLATFORMS)\" \\\n-\t\t\t\t --app=\"$(EQUINOX_APP_ID)\" \\\n-\t\t\t\t --token=\"$(EQUINOX_TOKEN)\" \\\n-\t\t\t\t --channel=\"$(EQUINOX_CHANNEL)\"\n+\t--platforms=\"$(EQUINOX_BUILD_PLATFORMS)\" \\\n+\t--app=\"$(EQUINOX_APP_ID)\" \\\n+\t--token=\"$(EQUINOX_TOKEN)\" \\\n+\t--channel=\"$(EQUINOX_CHANNEL)\"\n \n ifeq ($(EQUINOX_IS_DRAFT), true)\n \tEQUINOX_FLAGS := --draft $(EQUINOX_FLAGS)\n endif\n \n-ifeq ($(GOARCH),)\n-\tGOARCH := amd64\n+LOCAL_ARCH ?= $(shell uname -m)\n+ifeq ($(LOCAL_ARCH),x86_64)\n+    TARGET_ARCH ?= amd64\n+else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 5),armv8)\n+    TARGET_ARCH ?= arm64\n+else ifeq ($(LOCAL_ARCH),aarch64)\n+    TARGET_ARCH ?= arm64\n+else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 4),armv)\n+    TARGET_ARCH ?= arm\n+else\n+    $(error This system's architecture $(LOCAL_ARCH) isn't supported)\n+endif\n+\n+LOCAL_OS ?= $(shell go env GOOS)\n+ifeq ($(LOCAL_OS),linux)\n[[MASK]]\n endif\n \n .PHONY: all\n@@ -29,11 +47,11 @@ clean:\n \n .PHONY: cloudflared\n cloudflared: tunnel-deps\n-\tgo build -v -mod=vendor $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) go build -v -mod=vendor $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n \n .PHONY: container\n container:\n-\tdocker build -t cloudflare/cloudflared:\"$(VERSION)\" .\n+\tdocker build --build-arg=TARGET_ARCH=$(TARGET_ARCH) --build-arg=TARGET_OS=$(TARGET_OS) -t cloudflare/cloudflared-$(TARGET_OS)-$(TARGET_ARCH):\"$(VERSION)\" .\n \n .PHONY: test\n test: vet\n@@ -48,7 +66,7 @@ cloudflared-deb: cloudflared\n \tmkdir -p $(PACKAGE_DIR)\n \tcp cloudflared $(PACKAGE_DIR)/cloudflared\n \tfakeroot fpm -C $(PACKAGE_DIR) -s dir -t deb --deb-compression bzip2 \\\n-\t\t-a $(GOARCH) -v $(VERSION) -n cloudflared cloudflared=/usr/local/bin/\n+\t\t-a $(TARGET_ARCH) -v $(VERSION) -n cloudflared cloudflared=/usr/local/bin/\n \n .PHONY: cloudflared-darwin-amd64.tgz\n cloudflared-darwin-amd64.tgz: cloudflared\n---\ncmd/cloudflared/windows_service.go\n@@ -16,7 +16,6 @@ import (\n \t\"github.com/pkg/errors\"\n \tcli \"gopkg.in/urfave/cli.v2\"\n \n-\t\"github.com/pkg/errors\"\n \t\"golang.org/x/sys/windows\"\n \t\"golang.org/x/sys/windows/svc\"\n \t\"golang.org/x/sys/windows/svc/eventlog\"\n---\n\n"}], "ideal": "Dockerfile\n@@ -1,8 +1,11 @@\n # use a builder image for building cloudflare\n+ARG TARGET_GOOS\n+ARG TARGET_GOARCH\n FROM golang:1.13.3 as builder\n-ENV GO111MODULE=on\n-ENV CGO_ENABLED=0\n-ENV GOOS=linux\n+ENV GO111MODULE=on \\\n+    CGO_ENABLED=0 \\\n+    TARGET_GOOS=${TARGET_GOOS} \\\n+    TARGET_GOARCH=${TARGET_GOARCH}\n \n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n@@ -12,8 +15,6 @@ COPY . .\n # compile cloudflared\n RUN make cloudflared\n \n-# ---\n-\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian10:nonroot\n \n---\nMakefile\n@@ -7,17 +7,35 @@ PACKAGE_DIR   := $(CURDIR)/packaging\n INSTALL_BINDIR := usr/local/bin\n \n EQUINOX_FLAGS = --version=\"$(VERSION)\" \\\n-\t\t\t\t --platforms=\"$(EQUINOX_BUILD_PLATFORMS)\" \\\n-\t\t\t\t --app=\"$(EQUINOX_APP_ID)\" \\\n-\t\t\t\t --token=\"$(EQUINOX_TOKEN)\" \\\n-\t\t\t\t --channel=\"$(EQUINOX_CHANNEL)\"\n+\t--platforms=\"$(EQUINOX_BUILD_PLATFORMS)\" \\\n+\t--app=\"$(EQUINOX_APP_ID)\" \\\n+\t--token=\"$(EQUINOX_TOKEN)\" \\\n+\t--channel=\"$(EQUINOX_CHANNEL)\"\n \n ifeq ($(EQUINOX_IS_DRAFT), true)\n \tEQUINOX_FLAGS := --draft $(EQUINOX_FLAGS)\n endif\n \n-ifeq ($(GOARCH),)\n-\tGOARCH := amd64\n+LOCAL_ARCH ?= $(shell uname -m)\n+ifeq ($(LOCAL_ARCH),x86_64)\n+    TARGET_ARCH ?= amd64\n+else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 5),armv8)\n+    TARGET_ARCH ?= arm64\n+else ifeq ($(LOCAL_ARCH),aarch64)\n+    TARGET_ARCH ?= arm64\n+else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 4),armv)\n+    TARGET_ARCH ?= arm\n+else\n+    $(error This system's architecture $(LOCAL_ARCH) isn't supported)\n+endif\n+\n+LOCAL_OS ?= $(shell go env GOOS)\n+ifeq ($(LOCAL_OS),linux)\n+    TARGET_OS ?= linux\n+else ifeq ($(LOCAL_OS),darwin)\n+    TARGET_OS ?= darwin\n+else\n+    $(error This system's OS $(LOCAL_OS) isn't supported)\n endif\n \n .PHONY: all\n@@ -29,11 +47,11 @@ clean:\n \n .PHONY: cloudflared\n cloudflared: tunnel-deps\n-\tgo build -v -mod=vendor $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) go build -v -mod=vendor $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n \n .PHONY: container\n container:\n-\tdocker build -t cloudflare/cloudflared:\"$(VERSION)\" .\n+\tdocker build --build-arg=TARGET_ARCH=$(TARGET_ARCH) --build-arg=TARGET_OS=$(TARGET_OS) -t cloudflare/cloudflared-$(TARGET_OS)-$(TARGET_ARCH):\"$(VERSION)\" .\n \n .PHONY: test\n test: vet\n@@ -48,7 +66,7 @@ cloudflared-deb: cloudflared\n \tmkdir -p $(PACKAGE_DIR)\n \tcp cloudflared $(PACKAGE_DIR)/cloudflared\n \tfakeroot fpm -C $(PACKAGE_DIR) -s dir -t deb --deb-compression bzip2 \\\n-\t\t-a $(GOARCH) -v $(VERSION) -n cloudflared cloudflared=/usr/local/bin/\n+\t\t-a $(TARGET_ARCH) -v $(VERSION) -n cloudflared cloudflared=/usr/local/bin/\n \n .PHONY: cloudflared-darwin-amd64.tgz\n cloudflared-darwin-amd64.tgz: cloudflared\n---\ncmd/cloudflared/windows_service.go\n@@ -16,7 +16,6 @@ import (\n \t\"github.com/pkg/errors\"\n \tcli \"gopkg.in/urfave/cli.v2\"\n \n-\t\"github.com/pkg/errors\"\n \t\"golang.org/x/sys/windows\"\n \t\"golang.org/x/sys/windows/svc\"\n \t\"golang.org/x/sys/windows/svc/eventlog\"\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: proxy-dns: Allow setting the Host header via url hash\n\nDescription: Some DoH providers (namely Google) won't accept IP addresses in the Host header of DoH requests.\r\n\r\nAs I mentioned in #113, using dns.google with cloudflared currently requires using the url `https://dns.google/dns-query`. This however causes a bootstrapping issue if cloudflared has been set as the system's only resolver, as dns.google can't be resolved. dns.google therefore needs to be added to the system's host file. Even then, this solution is not ideal, as the host file can only define one IP address per hostname.\r\n\r\nThis PR allows the HTTP Host header and TLS verification name to be overridden by adding a hash/anchor/fragment to the end of the URL. In normal HTTP implementations, the segment of the URL after the hash is not sent to the server, and in DoH specifically, it serves no purpose.\r\n\r\nAfter the implementation of this change, services that require a specific Host header like dns.google could be used with upstream settings like this:\r\n\r\n```\r\nproxy-dns-upstream:\r\n - https://8.8.8.8/dns-query#dns.google\r\n - https://8.8.4.4/dns-query#dns.google\r\n - https://[2001:4860:4860::8888]/dns-query#dns.google\r\n - https://[2001:4860:4860::8844]/dns-query#dns.google\r\n```\r\n\r\nI also added Cloudflare DNS's IPv6 addresses to the default DoH configuration while I was editing the argument list, as IPv6 support was fixed in #168.\r\n\r\nFixes #113 \n\nCode Diff:\ncmd/cloudflared/tunnel/cmd.go\n@@ -129,8 +129,8 @@ func Commands() []*cli.Command {\n \t\t\t\t},\n \t\t\t\t&cli.StringSliceFlag{\n \t\t\t\t\tName:    \"upstream\",\n-\t\t\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy.\",\n-\t\t\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://1.0.0.1/dns-query\"),\n+\t\t\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy. If required, the Host header can be manually set by appending a hash to the URL.\",\n+\t\t\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://[2606:4700:4700::1111]/dns-query\", \"https://1.0.0.1/dns-query\", \"https://[2606:4700:4700::1001]/dns-query\"),\n \t\t\t\t\tEnvVars: []string{\"TUNNEL_DNS_UPSTREAM\"},\n \t\t\t\t},\n \t\t\t},\n@@ -934,8 +934,8 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t}),\n \t\taltsrc.NewStringSliceFlag(&cli.StringSliceFlag{\n \t\t\tName:    \"proxy-dns-upstream\",\n-\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy.\",\n-\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://1.0.0.1/dns-query\"),\n[[MASK]]\n---\ntunneldns/https_upstream.go\n@@ -35,6 +35,10 @@ func NewUpstreamHTTPS(endpoint string) (Upstream, error) {\n \n \t// Update TLS and HTTP client configuration\n \ttls := &tls.Config{ServerName: u.Hostname()}\n+\tif u.Fragment != \"\" {\n+\t\t// Allow server name override via anchor on the url\n+\t\ttls.ServerName = u.Fragment\n+\t}\n \ttransport := &http.Transport{\n \t\tTLSClientConfig:    tls,\n \t\tDisableCompression: true,\n@@ -84,6 +88,10 @@ func (u *UpstreamHTTPS) exchangeWireformat(msg []byte) ([]byte, error) {\n \n \treq.Header.Add(\"Content-Type\", \"application/dns-message\")\n \treq.Host = u.endpoint.Host\n+\tif u.endpoint.Fragment != \"\" {\n+\t\t// Allow server name override via anchor on the url\n+\t\treq.Host = u.endpoint.Fragment\n+\t}\n \n \tresp, err := u.client.Do(req)\n \tif err != nil {\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/cmd.go\n@@ -129,8 +129,8 @@ func Commands() []*cli.Command {\n \t\t\t\t},\n \t\t\t\t&cli.StringSliceFlag{\n \t\t\t\t\tName:    \"upstream\",\n-\t\t\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy.\",\n-\t\t\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://1.0.0.1/dns-query\"),\n+\t\t\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy. If required, the Host header can be manually set by appending a hash to the URL.\",\n+\t\t\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://[2606:4700:4700::1111]/dns-query\", \"https://1.0.0.1/dns-query\", \"https://[2606:4700:4700::1001]/dns-query\"),\n \t\t\t\t\tEnvVars: []string{\"TUNNEL_DNS_UPSTREAM\"},\n \t\t\t\t},\n \t\t\t},\n@@ -934,8 +934,8 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t}),\n \t\taltsrc.NewStringSliceFlag(&cli.StringSliceFlag{\n \t\t\tName:    \"proxy-dns-upstream\",\n-\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy.\",\n-\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://1.0.0.1/dns-query\"),\n+\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy. If required, the Host header can be manually set by appending a hash to the URL.\",\n+\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://[2606:4700:4700::1111]/dns-query\", \"https://1.0.0.1/dns-query\", \"https://[2606:4700:4700::1001]/dns-query\"),\n \t\t\tEnvVars: []string{\"TUNNEL_DNS_UPSTREAM\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n---\ntunneldns/https_upstream.go\n@@ -35,6 +35,10 @@ func NewUpstreamHTTPS(endpoint string) (Upstream, error) {\n \n \t// Update TLS and HTTP client configuration\n \ttls := &tls.Config{ServerName: u.Hostname()}\n+\tif u.Fragment != \"\" {\n+\t\t// Allow server name override via anchor on the url\n+\t\ttls.ServerName = u.Fragment\n+\t}\n \ttransport := &http.Transport{\n \t\tTLSClientConfig:    tls,\n \t\tDisableCompression: true,\n@@ -84,6 +88,10 @@ func (u *UpstreamHTTPS) exchangeWireformat(msg []byte) ([]byte, error) {\n \n \treq.Header.Add(\"Content-Type\", \"application/dns-message\")\n \treq.Host = u.endpoint.Host\n+\tif u.endpoint.Fragment != \"\" {\n+\t\t// Allow server name override via anchor on the url\n+\t\treq.Host = u.endpoint.Fragment\n+\t}\n \n \tresp, err := u.client.Do(req)\n \tif err != nil {\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Assorted typo fixes\n\nDescription: BTW I left the vendor folder untouched since I assume that's third-party code.\n\nCode Diff:\nRELEASE_NOTES\n@@ -112,7 +112,7 @@\n 2019.9.0\n - 2019-09-05 TUN-2279: Revert path encoding fix\n - 2019-08-30 AUTH-2021 - check error for failing tests\n-- 2019-08-29 AUTH-2030: Support both authorized_key and short lived cert authentication simultaniously without specifiying at start time\n+- 2019-08-29 AUTH-2030: Support both authorized_key and short lived cert authentication simultaneously without specifying at start time\n - 2019-08-29 AUTH-2026: Adds support for non-pty sessions and inline command exec\n - 2019-08-26 AUTH-1943: Adds session logging\n - 2019-08-26 TUN-2162: Decomplect OpenStream to allow finer-grained timeouts\n---\ncmd/cloudflared/config/configuration.go\n@@ -67,7 +67,7 @@ func FindDefaultConfigPath() string {\n // i.e. it fails if a user specifies both --url and --unix-socket\n func ValidateUnixSocket(c *cli.Context) (string, error) {\n \tif c.IsSet(\"unix-socket\") && (c.IsSet(\"url\") || c.NArg() > 0) {\n-\t\treturn \"\", errors.New(\"--unix-socket must be used exclusivly.\")\n+\t\treturn \"\", errors.New(\"--unix-socket must be used exclusively.\")\n \t}\n \treturn c.String(\"unix-socket\"), nil\n }\n---\ncmd/cloudflared/tunnel/signal.go\n@@ -28,7 +28,7 @@ func waitForSignal(errC chan error, shutdownC chan struct{}) error {\n \n // waitForSignalWithGraceShutdown notifies all routines to shutdown immediately\n // by closing the shutdownC when one of the routines in main exits.\n-// When this process recieves SIGTERM/SIGINT, it closes the graceShutdownC to\n+// When this process receives SIGTERM/SIGINT, it closes the graceShutdownC to\n // notify certain routines to start graceful shutdown. When grace period is over,\n // or when some routine exits, it notifies the rest of the routines to shutdown\n // immediately by closing shutdownC.\n---\ndbconnect/cmd.go\n@@ -149,7 +149,7 @@ func CmdAction(c *cli.Context) error {\n \t\t}\n \t}()\n \n-\t// Block until the the Proxy is online, retreive its address, and change the url to point to it.\n+\t// Block until the the Proxy is online, retrieve its address, and change the url to point to it.\n \t// This is effectively \"handing over\" control to the tunnel package so it can run the tunnel daemon.\n \tc.Set(\"url\", \"https://\"+(<-listenerC).Addr().String())\n \n---\ndbconnect/proxy.go\n@@ -98,7 +98,7 @@ func (proxy *Proxy) IsAllowed(r *http.Request, verbose ...bool) bool {\n \n // Start the Proxy at a given address and notify the listener channel when the server is online.\n func (proxy *Proxy) Start(ctx context.Context, addr string, listenerC chan<- net.Listener) error {\n-\t// STOR-611: use a seperate listener and consider web socket support.\n+\t// STOR-611: use a separate listener and consider web socket support.\n \thttpListener, err := hello.CreateTLSListener(addr)\n \tif err != nil {\n \t\treturn errors.Wrapf(err, \"could not create listener at %s\", addr)\n@@ -217,7 +217,7 @@ func (proxy *Proxy) httpSubmit() http.HandlerFunc {\n func (proxy *Proxy) httpRespond(w http.ResponseWriter, r *http.Request, status int, message string) {\n \tw.WriteHeader(status)\n \n-\t// Only expose the message detail of the reponse if the request is not HEAD\n+\t// Only expose the message detail of the response if the request is not HEAD\n \t// and the user is authenticated. For example, this prevents an unauthenticated\n \t// failed health check from accidentally leaking sensitive information about the Client.\n \tif r.Method != http.MethodHead && proxy.IsAllowed(r) {\n---\ndbconnect/sql.go\n@@ -278,10 +278,10 @@ func sqlRows(rows *sql.Rows) ([]map[string]interface{}, error) {\n[[MASK]]\n-\t\tif json.Unmarshal(bytes, &embeded) == nil {\n-\t\t\treturn embeded\n+\t\t// Opportunistically check for embedded JSON and convert it to a first-class object.\n+\t\tvar embedded interface{}\n+\t\tif json.Unmarshal(bytes, &embedded) == nil {\n+\t\t\treturn embedded\n \t\t}\n \n \t\t// STOR-604: investigate a way to coerce PostgreSQL arrays '{a, b, ...}' into JSON.\n---\nh2mux/h2_dictionaries.go\n@@ -468,7 +468,7 @@ func assignDictToStream(s *MuxedStream, p []byte) bool {\n \t\t}\n \t} else {\n \t\t// Use the overflow dictionary as last resort\n-\t\t// If slots are availabe generate new dictioanries for path and content-type\n+\t\t// If slots are available generate new dictionaries for path and content-type\n \t\tuseID, _ = h2d.getGenericDictID()\n \t\tpathID, pathFound = h2d.getNextDictID()\n \t\tif pathFound {\n---\nh2mux/h2mux.go\n@@ -273,7 +273,7 @@ func (m *Muxer) readPeerSettings(magic uint32) error {\n \t\tm.compressionQuality = compressionPresets[CompressionNone]\n \t\treturn nil\n \t}\n-\t// Values used for compression are the mimimum between the two peers\n+\t// Values used for compression are the minimum between the two peers\n \tif sz < m.compressionQuality.dictSize {\n \t\tm.compressionQuality.dictSize = sz\n \t}\n---\noriginservice/originservice_test.go\n@@ -39,7 +39,7 @@ func TestIsEventStream(t *testing.T) {\n \t\t\t// Content-Type and text/event-stream are case-insensitive. text/event-stream can be followed by OWS parameter\n \t\t\tresp: &http.Response{\n \t\t\t\tHeader: http.Header{\n-\t\t\t\t\t\"content-type\": []string{\"appication/json\", \"text/html\", \"Text/event-stream;charset=utf-8\"},\n+\t\t\t\t\t\"content-type\": []string{\"application/json\", \"text/html\", \"Text/event-stream;charset=utf-8\"},\n \t\t\t\t},\n \t\t\t},\n \t\t\tisEventStream: true,\n---\ntunnelrpc/tunnelrpc.capnp\n@@ -100,7 +100,7 @@ struct ClientConfig {\n     # supervisorConfig  is configuration for supervisor, the component that manages connection manager,\n     # autoupdater and metrics server\n     supervisorConfig @1 :SupervisorConfig;\n-    # edgeConnectionConfig is configuration for connection manager, the componenet that manages connections with the edge\n+    # edgeConnectionConfig is the configuration for the connection manager, the component that manages connections with the edge\n     edgeConnectionConfig @2 :EdgeConnectionConfig;\n     # Configuration for cloudflared to run as a DNS-over-HTTPS proxy.\n     # cloudflared CLI option: `proxy-dns`\n---\nvalidation/validation.go\n@@ -74,7 +74,7 @@ func ValidateUrl(originUrl string) (string, error) {\n \tif net.ParseIP(originUrl) != nil {\n \t\treturn validateIP(\"\", originUrl, \"\")\n \t} else if strings.HasPrefix(originUrl, \"[\") && strings.HasSuffix(originUrl, \"]\") {\n-\t\t// ParseIP doesn't recoginze [::1]\n+\t\t// ParseIP doesn't recognize [::1]\n \t\treturn validateIP(\"\", originUrl[1:len(originUrl)-1], \"\")\n \t}\n \n---\n\n"}], "ideal": "RELEASE_NOTES\n@@ -112,7 +112,7 @@\n 2019.9.0\n - 2019-09-05 TUN-2279: Revert path encoding fix\n - 2019-08-30 AUTH-2021 - check error for failing tests\n-- 2019-08-29 AUTH-2030: Support both authorized_key and short lived cert authentication simultaniously without specifiying at start time\n+- 2019-08-29 AUTH-2030: Support both authorized_key and short lived cert authentication simultaneously without specifying at start time\n - 2019-08-29 AUTH-2026: Adds support for non-pty sessions and inline command exec\n - 2019-08-26 AUTH-1943: Adds session logging\n - 2019-08-26 TUN-2162: Decomplect OpenStream to allow finer-grained timeouts\n---\ncmd/cloudflared/config/configuration.go\n@@ -67,7 +67,7 @@ func FindDefaultConfigPath() string {\n // i.e. it fails if a user specifies both --url and --unix-socket\n func ValidateUnixSocket(c *cli.Context) (string, error) {\n \tif c.IsSet(\"unix-socket\") && (c.IsSet(\"url\") || c.NArg() > 0) {\n-\t\treturn \"\", errors.New(\"--unix-socket must be used exclusivly.\")\n+\t\treturn \"\", errors.New(\"--unix-socket must be used exclusively.\")\n \t}\n \treturn c.String(\"unix-socket\"), nil\n }\n---\ncmd/cloudflared/tunnel/signal.go\n@@ -28,7 +28,7 @@ func waitForSignal(errC chan error, shutdownC chan struct{}) error {\n \n // waitForSignalWithGraceShutdown notifies all routines to shutdown immediately\n // by closing the shutdownC when one of the routines in main exits.\n-// When this process recieves SIGTERM/SIGINT, it closes the graceShutdownC to\n+// When this process receives SIGTERM/SIGINT, it closes the graceShutdownC to\n // notify certain routines to start graceful shutdown. When grace period is over,\n // or when some routine exits, it notifies the rest of the routines to shutdown\n // immediately by closing shutdownC.\n---\ndbconnect/cmd.go\n@@ -149,7 +149,7 @@ func CmdAction(c *cli.Context) error {\n \t\t}\n \t}()\n \n-\t// Block until the the Proxy is online, retreive its address, and change the url to point to it.\n+\t// Block until the the Proxy is online, retrieve its address, and change the url to point to it.\n \t// This is effectively \"handing over\" control to the tunnel package so it can run the tunnel daemon.\n \tc.Set(\"url\", \"https://\"+(<-listenerC).Addr().String())\n \n---\ndbconnect/proxy.go\n@@ -98,7 +98,7 @@ func (proxy *Proxy) IsAllowed(r *http.Request, verbose ...bool) bool {\n \n // Start the Proxy at a given address and notify the listener channel when the server is online.\n func (proxy *Proxy) Start(ctx context.Context, addr string, listenerC chan<- net.Listener) error {\n-\t// STOR-611: use a seperate listener and consider web socket support.\n+\t// STOR-611: use a separate listener and consider web socket support.\n \thttpListener, err := hello.CreateTLSListener(addr)\n \tif err != nil {\n \t\treturn errors.Wrapf(err, \"could not create listener at %s\", addr)\n@@ -217,7 +217,7 @@ func (proxy *Proxy) httpSubmit() http.HandlerFunc {\n func (proxy *Proxy) httpRespond(w http.ResponseWriter, r *http.Request, status int, message string) {\n \tw.WriteHeader(status)\n \n-\t// Only expose the message detail of the reponse if the request is not HEAD\n+\t// Only expose the message detail of the response if the request is not HEAD\n \t// and the user is authenticated. For example, this prevents an unauthenticated\n \t// failed health check from accidentally leaking sensitive information about the Client.\n \tif r.Method != http.MethodHead && proxy.IsAllowed(r) {\n---\ndbconnect/sql.go\n@@ -278,10 +278,10 @@ func sqlRows(rows *sql.Rows) ([]map[string]interface{}, error) {\n func sqlValue(val interface{}, col *sql.ColumnType) interface{} {\n \tbytes, ok := val.([]byte)\n \tif ok {\n-\t\t// Opportunistically check for embeded JSON and convert it to a first-class object.\n-\t\tvar embeded interface{}\n-\t\tif json.Unmarshal(bytes, &embeded) == nil {\n-\t\t\treturn embeded\n+\t\t// Opportunistically check for embedded JSON and convert it to a first-class object.\n+\t\tvar embedded interface{}\n+\t\tif json.Unmarshal(bytes, &embedded) == nil {\n+\t\t\treturn embedded\n \t\t}\n \n \t\t// STOR-604: investigate a way to coerce PostgreSQL arrays '{a, b, ...}' into JSON.\n---\nh2mux/h2_dictionaries.go\n@@ -468,7 +468,7 @@ func assignDictToStream(s *MuxedStream, p []byte) bool {\n \t\t}\n \t} else {\n \t\t// Use the overflow dictionary as last resort\n-\t\t// If slots are availabe generate new dictioanries for path and content-type\n+\t\t// If slots are available generate new dictionaries for path and content-type\n \t\tuseID, _ = h2d.getGenericDictID()\n \t\tpathID, pathFound = h2d.getNextDictID()\n \t\tif pathFound {\n---\nh2mux/h2mux.go\n@@ -273,7 +273,7 @@ func (m *Muxer) readPeerSettings(magic uint32) error {\n \t\tm.compressionQuality = compressionPresets[CompressionNone]\n \t\treturn nil\n \t}\n-\t// Values used for compression are the mimimum between the two peers\n+\t// Values used for compression are the minimum between the two peers\n \tif sz < m.compressionQuality.dictSize {\n \t\tm.compressionQuality.dictSize = sz\n \t}\n---\noriginservice/originservice_test.go\n@@ -39,7 +39,7 @@ func TestIsEventStream(t *testing.T) {\n \t\t\t// Content-Type and text/event-stream are case-insensitive. text/event-stream can be followed by OWS parameter\n \t\t\tresp: &http.Response{\n \t\t\t\tHeader: http.Header{\n-\t\t\t\t\t\"content-type\": []string{\"appication/json\", \"text/html\", \"Text/event-stream;charset=utf-8\"},\n+\t\t\t\t\t\"content-type\": []string{\"application/json\", \"text/html\", \"Text/event-stream;charset=utf-8\"},\n \t\t\t\t},\n \t\t\t},\n \t\t\tisEventStream: true,\n---\ntunnelrpc/tunnelrpc.capnp\n@@ -100,7 +100,7 @@ struct ClientConfig {\n     # supervisorConfig  is configuration for supervisor, the component that manages connection manager,\n     # autoupdater and metrics server\n     supervisorConfig @1 :SupervisorConfig;\n-    # edgeConnectionConfig is configuration for connection manager, the componenet that manages connections with the edge\n+    # edgeConnectionConfig is the configuration for the connection manager, the component that manages connections with the edge\n     edgeConnectionConfig @2 :EdgeConnectionConfig;\n     # Configuration for cloudflared to run as a DNS-over-HTTPS proxy.\n     # cloudflared CLI option: `proxy-dns`\n---\nvalidation/validation.go\n@@ -74,7 +74,7 @@ func ValidateUrl(originUrl string) (string, error) {\n \tif net.ParseIP(originUrl) != nil {\n \t\treturn validateIP(\"\", originUrl, \"\")\n \t} else if strings.HasPrefix(originUrl, \"[\") && strings.HasSuffix(originUrl, \"]\") {\n-\t\t// ParseIP doesn't recoginze [::1]\n+\t\t// ParseIP doesn't recognize [::1]\n \t\treturn validateIP(\"\", originUrl[1:len(originUrl)-1], \"\")\n \t}\n \n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: add arm64 support\n\nDescription: ubuntu official supports Raspberry Pi\r\n\r\nhttps://ubuntu.com/download/raspberry-pi\r\nhttps://wiki.ubuntu.com/ARM/RaspberryPi\r\n> Note that the information on this page currently only applies to the (ARMv7 and ARMv8) Raspberry Pis: 2B, 3B, 3A+, 3B+, 4B, Compute Module 3, and Compute Module 3+. The original (ARMv6) based Raspberry Pis, including the A, B, B+, 0 and 0W, are not supported under Ubuntu.\r\n\r\nit will be nice to have an arm64 build\r\n\r\ntry to fix #60  #115  #140  \n\nCode Diff:\ncfsetup.yaml\n@@ -54,6 +54,17 @@ stretch: &stretch\n       - export GOARCH=arm\n       - export CC=arm-linux-gnueabihf-gcc\n       - make release\n+  release-linux-arm64:\n+    build_dir: *build_dir\n+    builddeps:\n+      - *pinned_go\n+      - build-essential\n+      - gcc-aarch64-linux-gnu\n+    post-cache:\n+      - export GOOS=linux\n[[MASK]]\n     builddeps:\n---\n\n"}], "ideal": "cfsetup.yaml\n@@ -54,6 +54,17 @@ stretch: &stretch\n       - export GOARCH=arm\n       - export CC=arm-linux-gnueabihf-gcc\n       - make release\n+  release-linux-arm64:\n+    build_dir: *build_dir\n+    builddeps:\n+      - *pinned_go\n+      - build-essential\n+      - gcc-aarch64-linux-gnu\n+    post-cache:\n+      - export GOOS=linux\n+      - export GOARCH=arm64\n+      - export CC=gcc-aarch64-linux-gnu\n+      - make release\n   github-release-linux-armv6:\n     build_dir: *build_dir\n     builddeps:\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: perf(cloudflared): reuse memory from buffer pool to get better throughput\n\nDescription: There are three lines of code using `io.CopyBuffer()` with `make([]byte, 512*1024)` directly.\r\nAnd they will make the cloudflared be very busy on allocating and releasing memory and will threshold the tunnel throughput by increasing latency.\r\n\r\nThis PR try to replace these `make([]byte, 512*1024)` with a `sync.Pool` to avoid allocating the buffer on every requests.\r\n\r\nRef: https://github.com/cloudflare/cloudflared/issues/160\n\nCode Diff:\nbuffer/pool.go\n@@ -0,0 +1,29 @@\n+package buffer\n+\n+import (\n+\t\"sync\"\n+)\n+\n+type Pool struct {\n+\t// A Pool must not be copied after first use.\n+\t// https://golang.org/pkg/sync/#Pool\n+\tbuffers sync.Pool\n+}\n+\n+func NewPool(bufferSize int) *Pool {\n+\treturn &Pool{\n+\t\tbuffers: sync.Pool{\n+\t\t\tNew: func() interface{} {\n+\t\t\t\treturn make([]byte, bufferSize)\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func (p *Pool) Get() []byte {\n+\treturn p.buffers.Get().([]byte)\n+}\n+\n+func (p *Pool) Put(buf []byte) {\n+\tp.buffers.Put(buf)\n+}\n---\norigin/supervisor.go\n@@ -11,6 +11,7 @@ import (\n \t\"github.com/google/uuid\"\n \t\"github.com/sirupsen/logrus\"\n \n+\t\"github.com/cloudflare/cloudflared/buffer\"\n \t\"github.com/cloudflare/cloudflared/connection\"\n \t\"github.com/cloudflare/cloudflared/edgediscovery\"\n \t\"github.com/cloudflare/cloudflared/h2mux\"\n@@ -62,6 +63,8 @@ type Supervisor struct {\n \n \teventDigestLock *sync.RWMutex\n \teventDigest     []byte\n+\n+\tbufferPool *buffer.Pool\n }\n \n type resolveResult struct {\n@@ -96,6 +99,7 @@ func NewSupervisor(config *TunnelConfig, u uuid.UUID) (*Supervisor, error) {\n \t\tlogger:            config.Logger.WithField(\"subsystem\", \"supervisor\"),\n \t\tjwtLock:           &sync.RWMutex{},\n \t\teventDigestLock:   &sync.RWMutex{},\n+\t\tbufferPool:        buffer.NewPool(512 * 1024),\n \t}, nil\n }\n \n@@ -230,7 +234,7 @@ func (s *Supervisor) startFirstTunnel(ctx context.Context, connectedSignal *sign\n \t\treturn\n \t}\n \n-\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID)\n+\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID, s.bufferPool)\n \t// If the first tunnel disconnects, keep restarting it.\n \tedgeErrors := 0\n \tfor s.unusedIPs() {\n@@ -253,7 +257,7 @@ func (s *Supervisor) startFirstTunnel(ctx context.Context, connectedSignal *sign\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n-\t\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID)\n+\t\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID, s.bufferPool)\n \t}\n }\n \n@@ -272,7 +276,7 @@ func (s *Supervisor) startTunnel(ctx context.Context, index int, connectedSignal\n \tif err != nil {\n \t\treturn\n \t}\n-\terr = ServeTunnelLoop(ctx, s, s.config, addr, uint8(index), connectedSignal, s.cloudflaredUUID)\n+\terr = ServeTunnelLoop(ctx, s, s.config, addr, uint8(index), connectedSignal, s.cloudflaredUUID, s.bufferPool)\n }\n \n func (s *Supervisor) newConnectedTunnelSignal(index int) *signal.Signal {\n---\norigin/tunnel.go\n@@ -20,6 +20,7 @@ import (\n \tlog \"github.com/sirupsen/logrus\"\n \t\"golang.org/x/sync/errgroup\"\n \n+\t\"github.com/cloudflare/cloudflared/buffer\"\n \t\"github.com/cloudflare/cloudflared/cmd/cloudflared/buildinfo\"\n \t\"github.com/cloudflare/cloudflared/connection\"\n \t\"github.com/cloudflare/cloudflared/h2mux\"\n@@ -178,6 +179,7 @@ func ServeTunnelLoop(ctx context.Context,\n \tconnectionID uint8,\n \tconnectedSignal *signal.Signal,\n \tu uuid.UUID,\n+\tbufferPool *buffer.Pool,\n ) error {\n \tconnectionLogger := config.Logger.WithField(\"connectionID\", connectionID)\n \tconfig.Metrics.incrementHaConnections()\n@@ -201,6 +203,7 @@ func ServeTunnelLoop(ctx context.Context,\n \t\t\tconnectedFuse,\n \t\t\t&backoff,\n \t\t\tu,\n+\t\t\tbufferPool,\n \t\t)\n \t\tif recoverable {\n \t\t\tif duration, ok := backoff.GetBackoffDuration(ctx); ok {\n@@ -223,6 +226,7 @@ func ServeTunnel(\n \tconnectedFuse *h2mux.BooleanFuse,\n \tbackoff *BackoffHandler,\n \tu uuid.UUID,\n+\tbufferPool *buffer.Pool,\n ) (err error, recoverable bool) {\n \t// Treat panics as recoverable errors\n \tdefer func() {\n@@ -243,7 +247,7 @@ func ServeTunnel(\n \ttags[\"ha\"] = connectionTag\n \n \t// Returns error from parsing the origin URL or handshake errors\n-\thandler, originLocalIP, err := NewTunnelHandler(ctx, config, addr, connectionID)\n+\thandler, originLocalIP, err := NewTunnelHandler(ctx, config, addr, connectionID, bufferPool)\n \tif err != nil {\n \t\terrLog := logger.WithError(err)\n \t\tswitch err.(type) {\n@@ -500,13 +504,16 @@ type TunnelHandler struct {\n \tconnectionID      string\n \tlogger            *log.Logger\n \tnoChunkedEncoding bool\n+\n+\tbufferPool *buffer.Pool\n }\n \n // NewTunnelHandler returns a TunnelHandler, origin LAN IP and error\n func NewTunnelHandler(ctx context.Context,\n \tconfig *TunnelConfig,\n \taddr *net.TCPAddr,\n \tconnectionID uint8,\n+\tbufferPool *buffer.Pool,\n ) (*TunnelHandler, string, error) {\n \toriginURL, err := validation.ValidateUrl(config.OriginUrl)\n \tif err != nil {\n@@ -522,6 +529,7 @@ func NewTunnelHandler(ctx context.Context,\n \t\tconnectionID:      uint8ToString(connectionID),\n \t\tlogger:            config.Logger,\n \t\tnoChunkedEncoding: config.NoChunkedEncoding,\n+\t\tbufferPool:        bufferPool,\n \t}\n \tif h.httpClient == nil {\n \t\th.httpClient = http.DefaultTransport\n@@ -642,7 +650,9 @@ func (h *TunnelHandler) serveHTTP(stream *h2mux.MuxedStream, req *http.Request)\n \t} else {\n \t\t// Use CopyBuffer, because Copy only allocates a 32KiB buffer, and cross-stream\n \t\t// compression generates dictionary on first write\n-\t\tio.CopyBuffer(stream, response.Body, make([]byte, 512*1024))\n+\t\tbuf := h.bufferPool.Get()\n+\t\tdefer h.bufferPool.Put(buf)\n+\t\tio.CopyBuffer(stream, response.Body, buf)\n \t}\n \treturn response, nil\n }\n---\noriginservice/originservice.go\n@@ -12,6 +12,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \n+\t\"github.com/cloudflare/cloudflared/buffer\"\n \t\"github.com/cloudflare/cloudflared/h2mux\"\n \t\"github.com/cloudflare/cloudflared/hello\"\n \t\"github.com/cloudflare/cloudflared/log\"\n@@ -33,13 +34,15 @@ type HTTPService struct {\n \tclient          http.RoundTripper\n \toriginURL       *url.URL\n \tchunkedEncoding bool\n+\tbufferPool      *buffer.Pool\n }\n \n func NewHTTPService(transport http.RoundTripper, url *url.URL, chunkedEncoding bool) OriginService {\n \treturn &HTTPService{\n \t\tclient:          transport,\n \t\toriginURL:       url,\n \t\tchunkedEncoding: chunkedEncoding,\n+\t\tbufferPool:      buffer.NewPool(512 * 1024),\n \t}\n }\n \n@@ -71,7 +74,9 @@ func (hc *HTTPService) Proxy(stream *h2mux.MuxedStream, req *http.Request) (*htt\n \t} else {\n \t\t// Use CopyBuffer, because Copy only allocates a 32KiB buffer, and cross-stream\n[[MASK]]\n \t}\n \treturn resp, nil\n }\n@@ -142,10 +147,11 @@ func (wsc *WebsocketService) Shutdown() {\n \n // HelloWorldService talks to the hello world example origin\n type HelloWorldService struct {\n-\tclient    http.RoundTripper\n-\tlistener  net.Listener\n-\toriginURL *url.URL\n-\tshutdownC chan struct{}\n+\tclient     http.RoundTripper\n+\tlistener   net.Listener\n+\toriginURL  *url.URL\n+\tshutdownC  chan struct{}\n+\tbufferPool *buffer.Pool\n }\n \n func NewHelloWorldService(transport http.RoundTripper) (OriginService, error) {\n@@ -164,7 +170,8 @@ func NewHelloWorldService(transport http.RoundTripper) (OriginService, error) {\n \t\t\tScheme: \"https\",\n \t\t\tHost:   listener.Addr().String(),\n \t\t},\n-\t\tshutdownC: shutdownC,\n+\t\tshutdownC:  shutdownC,\n+\t\tbufferPool: buffer.NewPool(512 * 1024),\n \t}, nil\n }\n \n@@ -184,7 +191,9 @@ func (hwc *HelloWorldService) Proxy(stream *h2mux.MuxedStream, req *http.Request\n \n \t// Use CopyBuffer, because Copy only allocates a 32KiB buffer, and cross-stream\n \t// compression generates dictionary on first write\n-\tio.CopyBuffer(stream, resp.Body, make([]byte, 512*1024))\n+\tbuf := hwc.bufferPool.Get()\n+\tdefer hwc.bufferPool.Put(buf)\n+\tio.CopyBuffer(stream, resp.Body, buf)\n \n \treturn resp, nil\n }\n---\n\n"}], "ideal": "buffer/pool.go\n@@ -0,0 +1,29 @@\n+package buffer\n+\n+import (\n+\t\"sync\"\n+)\n+\n+type Pool struct {\n+\t// A Pool must not be copied after first use.\n+\t// https://golang.org/pkg/sync/#Pool\n+\tbuffers sync.Pool\n+}\n+\n+func NewPool(bufferSize int) *Pool {\n+\treturn &Pool{\n+\t\tbuffers: sync.Pool{\n+\t\t\tNew: func() interface{} {\n+\t\t\t\treturn make([]byte, bufferSize)\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func (p *Pool) Get() []byte {\n+\treturn p.buffers.Get().([]byte)\n+}\n+\n+func (p *Pool) Put(buf []byte) {\n+\tp.buffers.Put(buf)\n+}\n---\norigin/supervisor.go\n@@ -11,6 +11,7 @@ import (\n \t\"github.com/google/uuid\"\n \t\"github.com/sirupsen/logrus\"\n \n+\t\"github.com/cloudflare/cloudflared/buffer\"\n \t\"github.com/cloudflare/cloudflared/connection\"\n \t\"github.com/cloudflare/cloudflared/edgediscovery\"\n \t\"github.com/cloudflare/cloudflared/h2mux\"\n@@ -62,6 +63,8 @@ type Supervisor struct {\n \n \teventDigestLock *sync.RWMutex\n \teventDigest     []byte\n+\n+\tbufferPool *buffer.Pool\n }\n \n type resolveResult struct {\n@@ -96,6 +99,7 @@ func NewSupervisor(config *TunnelConfig, u uuid.UUID) (*Supervisor, error) {\n \t\tlogger:            config.Logger.WithField(\"subsystem\", \"supervisor\"),\n \t\tjwtLock:           &sync.RWMutex{},\n \t\teventDigestLock:   &sync.RWMutex{},\n+\t\tbufferPool:        buffer.NewPool(512 * 1024),\n \t}, nil\n }\n \n@@ -230,7 +234,7 @@ func (s *Supervisor) startFirstTunnel(ctx context.Context, connectedSignal *sign\n \t\treturn\n \t}\n \n-\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID)\n+\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID, s.bufferPool)\n \t// If the first tunnel disconnects, keep restarting it.\n \tedgeErrors := 0\n \tfor s.unusedIPs() {\n@@ -253,7 +257,7 @@ func (s *Supervisor) startFirstTunnel(ctx context.Context, connectedSignal *sign\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n-\t\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID)\n+\t\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID, s.bufferPool)\n \t}\n }\n \n@@ -272,7 +276,7 @@ func (s *Supervisor) startTunnel(ctx context.Context, index int, connectedSignal\n \tif err != nil {\n \t\treturn\n \t}\n-\terr = ServeTunnelLoop(ctx, s, s.config, addr, uint8(index), connectedSignal, s.cloudflaredUUID)\n+\terr = ServeTunnelLoop(ctx, s, s.config, addr, uint8(index), connectedSignal, s.cloudflaredUUID, s.bufferPool)\n }\n \n func (s *Supervisor) newConnectedTunnelSignal(index int) *signal.Signal {\n---\norigin/tunnel.go\n@@ -20,6 +20,7 @@ import (\n \tlog \"github.com/sirupsen/logrus\"\n \t\"golang.org/x/sync/errgroup\"\n \n+\t\"github.com/cloudflare/cloudflared/buffer\"\n \t\"github.com/cloudflare/cloudflared/cmd/cloudflared/buildinfo\"\n \t\"github.com/cloudflare/cloudflared/connection\"\n \t\"github.com/cloudflare/cloudflared/h2mux\"\n@@ -178,6 +179,7 @@ func ServeTunnelLoop(ctx context.Context,\n \tconnectionID uint8,\n \tconnectedSignal *signal.Signal,\n \tu uuid.UUID,\n+\tbufferPool *buffer.Pool,\n ) error {\n \tconnectionLogger := config.Logger.WithField(\"connectionID\", connectionID)\n \tconfig.Metrics.incrementHaConnections()\n@@ -201,6 +203,7 @@ func ServeTunnelLoop(ctx context.Context,\n \t\t\tconnectedFuse,\n \t\t\t&backoff,\n \t\t\tu,\n+\t\t\tbufferPool,\n \t\t)\n \t\tif recoverable {\n \t\t\tif duration, ok := backoff.GetBackoffDuration(ctx); ok {\n@@ -223,6 +226,7 @@ func ServeTunnel(\n \tconnectedFuse *h2mux.BooleanFuse,\n \tbackoff *BackoffHandler,\n \tu uuid.UUID,\n+\tbufferPool *buffer.Pool,\n ) (err error, recoverable bool) {\n \t// Treat panics as recoverable errors\n \tdefer func() {\n@@ -243,7 +247,7 @@ func ServeTunnel(\n \ttags[\"ha\"] = connectionTag\n \n \t// Returns error from parsing the origin URL or handshake errors\n-\thandler, originLocalIP, err := NewTunnelHandler(ctx, config, addr, connectionID)\n+\thandler, originLocalIP, err := NewTunnelHandler(ctx, config, addr, connectionID, bufferPool)\n \tif err != nil {\n \t\terrLog := logger.WithError(err)\n \t\tswitch err.(type) {\n@@ -500,13 +504,16 @@ type TunnelHandler struct {\n \tconnectionID      string\n \tlogger            *log.Logger\n \tnoChunkedEncoding bool\n+\n+\tbufferPool *buffer.Pool\n }\n \n // NewTunnelHandler returns a TunnelHandler, origin LAN IP and error\n func NewTunnelHandler(ctx context.Context,\n \tconfig *TunnelConfig,\n \taddr *net.TCPAddr,\n \tconnectionID uint8,\n+\tbufferPool *buffer.Pool,\n ) (*TunnelHandler, string, error) {\n \toriginURL, err := validation.ValidateUrl(config.OriginUrl)\n \tif err != nil {\n@@ -522,6 +529,7 @@ func NewTunnelHandler(ctx context.Context,\n \t\tconnectionID:      uint8ToString(connectionID),\n \t\tlogger:            config.Logger,\n \t\tnoChunkedEncoding: config.NoChunkedEncoding,\n+\t\tbufferPool:        bufferPool,\n \t}\n \tif h.httpClient == nil {\n \t\th.httpClient = http.DefaultTransport\n@@ -642,7 +650,9 @@ func (h *TunnelHandler) serveHTTP(stream *h2mux.MuxedStream, req *http.Request)\n \t} else {\n \t\t// Use CopyBuffer, because Copy only allocates a 32KiB buffer, and cross-stream\n \t\t// compression generates dictionary on first write\n-\t\tio.CopyBuffer(stream, response.Body, make([]byte, 512*1024))\n+\t\tbuf := h.bufferPool.Get()\n+\t\tdefer h.bufferPool.Put(buf)\n+\t\tio.CopyBuffer(stream, response.Body, buf)\n \t}\n \treturn response, nil\n }\n---\noriginservice/originservice.go\n@@ -12,6 +12,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \n+\t\"github.com/cloudflare/cloudflared/buffer\"\n \t\"github.com/cloudflare/cloudflared/h2mux\"\n \t\"github.com/cloudflare/cloudflared/hello\"\n \t\"github.com/cloudflare/cloudflared/log\"\n@@ -33,13 +34,15 @@ type HTTPService struct {\n \tclient          http.RoundTripper\n \toriginURL       *url.URL\n \tchunkedEncoding bool\n+\tbufferPool      *buffer.Pool\n }\n \n func NewHTTPService(transport http.RoundTripper, url *url.URL, chunkedEncoding bool) OriginService {\n \treturn &HTTPService{\n \t\tclient:          transport,\n \t\toriginURL:       url,\n \t\tchunkedEncoding: chunkedEncoding,\n+\t\tbufferPool:      buffer.NewPool(512 * 1024),\n \t}\n }\n \n@@ -71,7 +74,9 @@ func (hc *HTTPService) Proxy(stream *h2mux.MuxedStream, req *http.Request) (*htt\n \t} else {\n \t\t// Use CopyBuffer, because Copy only allocates a 32KiB buffer, and cross-stream\n \t\t// compression generates dictionary on first write\n-\t\tio.CopyBuffer(stream, resp.Body, make([]byte, 512*1024))\n+\t\tbuf := hc.bufferPool.Get()\n+\t\tdefer hc.bufferPool.Put(buf)\n+\t\tio.CopyBuffer(stream, resp.Body, buf)\n \t}\n \treturn resp, nil\n }\n@@ -142,10 +147,11 @@ func (wsc *WebsocketService) Shutdown() {\n \n // HelloWorldService talks to the hello world example origin\n type HelloWorldService struct {\n-\tclient    http.RoundTripper\n-\tlistener  net.Listener\n-\toriginURL *url.URL\n-\tshutdownC chan struct{}\n+\tclient     http.RoundTripper\n+\tlistener   net.Listener\n+\toriginURL  *url.URL\n+\tshutdownC  chan struct{}\n+\tbufferPool *buffer.Pool\n }\n \n func NewHelloWorldService(transport http.RoundTripper) (OriginService, error) {\n@@ -164,7 +170,8 @@ func NewHelloWorldService(transport http.RoundTripper) (OriginService, error) {\n \t\t\tScheme: \"https\",\n \t\t\tHost:   listener.Addr().String(),\n \t\t},\n-\t\tshutdownC: shutdownC,\n+\t\tshutdownC:  shutdownC,\n+\t\tbufferPool: buffer.NewPool(512 * 1024),\n \t}, nil\n }\n \n@@ -184,7 +191,9 @@ func (hwc *HelloWorldService) Proxy(stream *h2mux.MuxedStream, req *http.Request\n \n \t// Use CopyBuffer, because Copy only allocates a 32KiB buffer, and cross-stream\n \t// compression generates dictionary on first write\n-\tio.CopyBuffer(stream, resp.Body, make([]byte, 512*1024))\n+\tbuf := hwc.bufferPool.Get()\n+\tdefer hwc.bufferPool.Put(buf)\n+\tio.CopyBuffer(stream, resp.Body, buf)\n \n \treturn resp, nil\n }\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Warn users about websockets being a requirement for SSH access\n\nDescription: If WebSockets are disabled to the origin the WebSocket headers will be silently stripped and any attempt to access resources over SSH will fail with `websocket: bad handshake`. This PR improves that error message.\r\n\r\nThis is not mentioned anywhere in any documentation that I could find. \r\n\r\nThis PR also removes closing the response body as it is not necessary as per https://github.com/cloudflare/cloudflared/blob/master/websocket/websocket.go#L72-L73\n\nCode Diff:\ncarrier/carrier.go\n@@ -37,13 +37,6 @@ func (c *StdinoutStream) Write(p []byte) (int, error) {\n \treturn os.Stdout.Write(p)\n }\n \n-// Helper to allow defering the response close with a check that the resp is not nil\n-func closeRespBody(resp *http.Response) {\n-\tif resp != nil {\n-\t\tresp.Body.Close()\n-\t}\n-}\n-\n // StartClient will copy the data from stdin/stdout over a WebSocket connection\n // to the edge (originURL)\n func StartClient(logger *logrus.Logger, stream io.ReadWriter, options *StartOptions) error {\n@@ -92,7 +85,7 @@ func serveConnection(logger *logrus.Logger, c net.Conn, options *StartOptions) {\n func serveStream(logger *logrus.Logger, conn io.ReadWriter, options *StartOptions) error {\n \twsConn, err := createWebsocketStream(options)\n \tif err != nil {\n-\t\tlogger.WithError(err).Errorf(\"failed to connect to %s\\n\", options.OriginURL)\n+\t\tlogger.WithError(err).Errorf(\"failed to connect to %s. Are WebSockets allowed to your origin server?\", options.OriginURL)\n \t\treturn err\n \t}\n \tdefer wsConn.Close()\n[[MASK]]\n \tif err != nil && IsAccessResponse(resp) {\n \t\twsConn, err = createAccessAuthenticatedStream(options)\n \t\tif err != nil {\n@@ -151,7 +143,6 @@ func IsAccessResponse(resp *http.Response) bool {\n // login again and generate a new one.\n func createAccessAuthenticatedStream(options *StartOptions) (*websocket.Conn, error) {\n \twsConn, resp, err := createAccessWebSocketStream(options)\n-\tdefer closeRespBody(resp)\n \tif err == nil {\n \t\treturn wsConn, nil\n \t}\n@@ -169,7 +160,6 @@ func createAccessAuthenticatedStream(options *StartOptions) (*websocket.Conn, er\n \t\treturn nil, err\n \t}\n \twsConn, resp, err = createAccessWebSocketStream(options)\n-\tdefer closeRespBody(resp)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n---\n\n"}], "ideal": "carrier/carrier.go\n@@ -37,13 +37,6 @@ func (c *StdinoutStream) Write(p []byte) (int, error) {\n \treturn os.Stdout.Write(p)\n }\n \n-// Helper to allow defering the response close with a check that the resp is not nil\n-func closeRespBody(resp *http.Response) {\n-\tif resp != nil {\n-\t\tresp.Body.Close()\n-\t}\n-}\n-\n // StartClient will copy the data from stdin/stdout over a WebSocket connection\n // to the edge (originURL)\n func StartClient(logger *logrus.Logger, stream io.ReadWriter, options *StartOptions) error {\n@@ -92,7 +85,7 @@ func serveConnection(logger *logrus.Logger, c net.Conn, options *StartOptions) {\n func serveStream(logger *logrus.Logger, conn io.ReadWriter, options *StartOptions) error {\n \twsConn, err := createWebsocketStream(options)\n \tif err != nil {\n-\t\tlogger.WithError(err).Errorf(\"failed to connect to %s\\n\", options.OriginURL)\n+\t\tlogger.WithError(err).Errorf(\"failed to connect to %s. Are WebSockets allowed to your origin server?\", options.OriginURL)\n \t\treturn err\n \t}\n \tdefer wsConn.Close()\n@@ -113,7 +106,6 @@ func createWebsocketStream(options *StartOptions) (*cloudflaredWebsocket.Conn, e\n \treq.Header = options.Headers\n \n \twsConn, resp, err := cloudflaredWebsocket.ClientConnect(req, nil)\n-\tdefer closeRespBody(resp)\n \tif err != nil && IsAccessResponse(resp) {\n \t\twsConn, err = createAccessAuthenticatedStream(options)\n \t\tif err != nil {\n@@ -151,7 +143,6 @@ func IsAccessResponse(resp *http.Response) bool {\n // login again and generate a new one.\n func createAccessAuthenticatedStream(options *StartOptions) (*websocket.Conn, error) {\n \twsConn, resp, err := createAccessWebSocketStream(options)\n-\tdefer closeRespBody(resp)\n \tif err == nil {\n \t\treturn wsConn, nil\n \t}\n@@ -169,7 +160,6 @@ func createAccessAuthenticatedStream(options *StartOptions) (*websocket.Conn, er\n \t\treturn nil, err\n \t}\n \twsConn, resp, err = createAccessWebSocketStream(options)\n-\tdefer closeRespBody(resp)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: support for multiarch docker manifest\n\nDescription: merged from https://github.com/klutchell/cloudflared\r\nrequires 'docker login' prior to 'make manifest' so the image can be pushed\n\nCode Diff:\nDockerfile\n@@ -1,28 +1,23 @@\n-# use a builder image for building cloudflare\n-FROM golang:1.13.3 as builder\n-ENV GO111MODULE=on\n-ENV CGO_ENABLED=0\n-ENV GOOS=linux\n+\n+FROM golang:1.12-alpine as builder\n \n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n-# copy our sources into the builder image\n COPY . .\n \n-# compile cloudflared\n-RUN make cloudflared\n-\n-# ---\n+ENV GO111MODULE on\n+ENV CGO_ENABLED 0\n \n-# use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian10:nonroot\n+RUN apk add --no-cache build-base=0.5-r1 git=2.22.0-r0 upx=3.95-r2 \\\n+    && make cloudflared \\\n+    && upx --no-progress cloudflared\n \n-# copy our compiled binary\n-COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+FROM scratch\n \n-# run as non-privileged user\n-USER nonroot\n+COPY --from=builder /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n-# command / entrypoint of container\n ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n+\n CMD [\"version\"]\n[[MASK]]\n PACKAGE_DIR   := $(CURDIR)/packaging\n INSTALL_BINDIR := usr/local/bin\n \n+DOCKER_CLI_EXPERIMENTAL := enabled\n+\n EQUINOX_FLAGS = --version=\"$(VERSION)\" \\\n \t\t\t\t --platforms=\"$(EQUINOX_BUILD_PLATFORMS)\" \\\n \t\t\t\t --app=\"$(EQUINOX_APP_ID)\" \\\n@@ -35,6 +37,17 @@ cloudflared: tunnel-deps\n container:\n \tdocker build -t cloudflare/cloudflared:\"$(VERSION)\" .\n \n+.PHONY: manifest\n+manifest:\n+\tdocker run --rm --privileged aptman/qus -s -- -r\n+\tdocker run --rm --privileged aptman/qus -s -- -p\n+\t-docker buildx create --use --name cloudflared\n+\tdocker buildx inspect --bootstrap\n+\tdocker buildx build . \\\n+\t\t-t cloudflare/cloudflared:\"$(VERSION)\" \\\n+\t\t--platform=linux/amd64,linux/arm64,linux/386,linux/arm/v7,linux/arm/v6 \\\n+\t\t--pull --push\n+\n .PHONY: test\n test: vet\n \tgo test -v -mod=vendor -race $(VERSION_FLAGS) ./...\n---\n\n"}], "ideal": "Dockerfile\n@@ -1,28 +1,23 @@\n-# use a builder image for building cloudflare\n-FROM golang:1.13.3 as builder\n-ENV GO111MODULE=on\n-ENV CGO_ENABLED=0\n-ENV GOOS=linux\n+\n+FROM golang:1.12-alpine as builder\n \n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n-# copy our sources into the builder image\n COPY . .\n \n-# compile cloudflared\n-RUN make cloudflared\n-\n-# ---\n+ENV GO111MODULE on\n+ENV CGO_ENABLED 0\n \n-# use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian10:nonroot\n+RUN apk add --no-cache build-base=0.5-r1 git=2.22.0-r0 upx=3.95-r2 \\\n+    && make cloudflared \\\n+    && upx --no-progress cloudflared\n \n-# copy our compiled binary\n-COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+FROM scratch\n \n-# run as non-privileged user\n-USER nonroot\n+COPY --from=builder /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n-# command / entrypoint of container\n ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n+\n CMD [\"version\"]\n+\n+RUN [\"cloudflared\", \"--version\"]\n---\nMakefile\n@@ -6,6 +6,8 @@ IMPORT_PATH   := github.com/cloudflare/cloudflared\n PACKAGE_DIR   := $(CURDIR)/packaging\n INSTALL_BINDIR := usr/local/bin\n \n+DOCKER_CLI_EXPERIMENTAL := enabled\n+\n EQUINOX_FLAGS = --version=\"$(VERSION)\" \\\n \t\t\t\t --platforms=\"$(EQUINOX_BUILD_PLATFORMS)\" \\\n \t\t\t\t --app=\"$(EQUINOX_APP_ID)\" \\\n@@ -35,6 +37,17 @@ cloudflared: tunnel-deps\n container:\n \tdocker build -t cloudflare/cloudflared:\"$(VERSION)\" .\n \n+.PHONY: manifest\n+manifest:\n+\tdocker run --rm --privileged aptman/qus -s -- -r\n+\tdocker run --rm --privileged aptman/qus -s -- -p\n+\t-docker buildx create --use --name cloudflared\n+\tdocker buildx inspect --bootstrap\n+\tdocker buildx build . \\\n+\t\t-t cloudflare/cloudflared:\"$(VERSION)\" \\\n+\t\t--platform=linux/amd64,linux/arm64,linux/386,linux/arm/v7,linux/arm/v6 \\\n+\t\t--pull --push\n+\n .PHONY: test\n test: vet\n \tgo test -v -mod=vendor -race $(VERSION_FLAGS) ./...\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: refactor(docker): optimize Dockerfile\n\nDescription: Remove obsolete upx binary compression\r\nRun as unprivileged user\r\nUse debian10 rootless base image for latest glibc libraries\n\nCode Diff:\nDockerfile\n@@ -1,15 +1,28 @@\n-FROM golang:1.12 as builder\n+# use a builder image for building cloudflare\n+FROM golang:1.13.3 as builder\n ENV GO111MODULE=on\n ENV CGO_ENABLED=0\n ENV GOOS=linux\n[[MASK]]\n+# copy our sources into the builder image\n COPY . .\n+\n+# compile cloudflared\n RUN make cloudflared\n-RUN upx --no-progress cloudflared\n \n-FROM gcr.io/distroless/base\n-COPY --from=builder /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+# ---\n+\n+# use a distroless base image with glibc\n+FROM gcr.io/distroless/base-debian10:nonroot\n+\n+# copy our compiled binary\n+COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+\n+# run as non-privileged user\n+USER nonroot\n+\n+# command / entrypoint of container\n ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n CMD [\"version\"]\n---\n\n"}], "ideal": "Dockerfile\n@@ -1,15 +1,28 @@\n-FROM golang:1.12 as builder\n+# use a builder image for building cloudflare\n+FROM golang:1.13.3 as builder\n ENV GO111MODULE=on\n ENV CGO_ENABLED=0\n ENV GOOS=linux\n+\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n-RUN apt-get update && apt-get install -y --no-install-recommends upx\n-# Run after `apt-get update` to improve rebuild scenarios\n+\n+# copy our sources into the builder image\n COPY . .\n+\n+# compile cloudflared\n RUN make cloudflared\n-RUN upx --no-progress cloudflared\n \n-FROM gcr.io/distroless/base\n-COPY --from=builder /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+# ---\n+\n+# use a distroless base image with glibc\n+FROM gcr.io/distroless/base-debian10:nonroot\n+\n+# copy our compiled binary\n+COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+\n+# run as non-privileged user\n+USER nonroot\n+\n+# command / entrypoint of container\n ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n CMD [\"version\"]\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Add support for specifying a specific HTTP Host: header on the origin.\n\nDescription: Potentially resolves #111 \r\n\r\nVery quick implementation, didn't test everything, but what I did test worked for me.\r\n\r\nUsage: cloudflared tunnel -url http://localhost -httphost example.test\r\n\r\nCan someone please check it?\n\nCode Diff:\ncmd/cloudflared/tunnel/cmd.go\n@@ -618,6 +618,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_HOSTNAME\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:    \"http-host-header\",\n+\t\t\tUsage:   \"Sets the HTTP Host header for the local webserver.\",\n+\t\t\tEnvVars: []string{\"TUNNEL_HTTP_HOST_HEADER\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewStringFlag(&cli.StringFlag{\n \t\t\tName:    \"origin-server-name\",\n \t\t\tUsage:   \"Hostname on the origin server certificate.\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -253,6 +253,7 @@ func prepareTunnelConfig(\n \t\tHTTPTransport:        httpTransport,\n \t\tHeartbeatInterval:    c.Duration(\"heartbeat-interval\"),\n \t\tHostname:             hostname,\n+\t\tHTTPHostHeader:       c.String(\"http-host-header\"),\n \t\tIncidentLookup:       origin.NewIncidentLookup(),\n \t\tIsAutoupdated:        c.Bool(\"is-autoupdated\"),\n \t\tIsFreeTunnel:         isFreeTunnel,\n---\norigin/tunnel.go\n@@ -53,6 +53,7 @@ type TunnelConfig struct {\n \tHTTPTransport        http.RoundTripper\n \tHeartbeatInterval    time.Duration\n \tHostname             string\n+\tHTTPHostHeader       string\n \tIncidentLookup       IncidentLookup\n \tIsAutoupdated        bool\n \tIsFreeTunnel         bool\n@@ -447,12 +448,13 @@ func H1ResponseToH2Response(h1 *http.Response) (h2 []h2mux.Header) {\n }\n \n type TunnelHandler struct {\n-\toriginUrl  string\n-\tmuxer      *h2mux.Muxer\n[[MASK]]\n+\thttpHostHeader string\n+\tmuxer          *h2mux.Muxer\n+\thttpClient     http.RoundTripper\n+\ttlsConfig      *tls.Config\n+\ttags           []tunnelpogs.Tag\n+\tmetrics        *TunnelMetrics\n \t// connectionID is only used by metrics, and prometheus requires labels to be string\n \tconnectionID      string\n \tlogger            *log.Logger\n@@ -473,6 +475,7 @@ func NewTunnelHandler(ctx context.Context,\n \t}\n \th := &TunnelHandler{\n \t\toriginUrl:         originURL,\n+\t\thttpHostHeader:    config.HTTPHostHeader,\n \t\thttpClient:        config.HTTPTransport,\n \t\ttlsConfig:         config.ClientTlsConfig,\n \t\ttags:              config.Tags,\n@@ -566,6 +569,11 @@ func (h *TunnelHandler) createRequest(stream *h2mux.MuxedStream) (*http.Request,\n }\n \n func (h *TunnelHandler) serveWebsocket(stream *h2mux.MuxedStream, req *http.Request) (*http.Response, error) {\n+\tif h.httpHostHeader != \"\" {\n+\t\treq.Header.Set(\"Host\", h.httpHostHeader)\n+\t\treq.Host = h.httpHostHeader\n+\t}\n+\n \tconn, response, err := websocket.ClientConnect(req, h.tlsConfig)\n \tif err != nil {\n \t\treturn nil, err\n@@ -594,6 +602,11 @@ func (h *TunnelHandler) serveHTTP(stream *h2mux.MuxedStream, req *http.Request)\n \t// Request origin to keep connection alive to improve performance\n \treq.Header.Set(\"Connection\", \"keep-alive\")\n \n+\tif h.httpHostHeader != \"\" {\n+\t\treq.Header.Set(\"Host\", h.httpHostHeader)\n+\t\treq.Host = h.httpHostHeader\n+\t}\n+\n \tresponse, err := h.httpClient.RoundTrip(req)\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"Error proxying request to origin\")\n---\n\n"}], "ideal": "cmd/cloudflared/tunnel/cmd.go\n@@ -618,6 +618,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_HOSTNAME\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:    \"http-host-header\",\n+\t\t\tUsage:   \"Sets the HTTP Host header for the local webserver.\",\n+\t\t\tEnvVars: []string{\"TUNNEL_HTTP_HOST_HEADER\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewStringFlag(&cli.StringFlag{\n \t\t\tName:    \"origin-server-name\",\n \t\t\tUsage:   \"Hostname on the origin server certificate.\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -253,6 +253,7 @@ func prepareTunnelConfig(\n \t\tHTTPTransport:        httpTransport,\n \t\tHeartbeatInterval:    c.Duration(\"heartbeat-interval\"),\n \t\tHostname:             hostname,\n+\t\tHTTPHostHeader:       c.String(\"http-host-header\"),\n \t\tIncidentLookup:       origin.NewIncidentLookup(),\n \t\tIsAutoupdated:        c.Bool(\"is-autoupdated\"),\n \t\tIsFreeTunnel:         isFreeTunnel,\n---\norigin/tunnel.go\n@@ -53,6 +53,7 @@ type TunnelConfig struct {\n \tHTTPTransport        http.RoundTripper\n \tHeartbeatInterval    time.Duration\n \tHostname             string\n+\tHTTPHostHeader       string\n \tIncidentLookup       IncidentLookup\n \tIsAutoupdated        bool\n \tIsFreeTunnel         bool\n@@ -447,12 +448,13 @@ func H1ResponseToH2Response(h1 *http.Response) (h2 []h2mux.Header) {\n }\n \n type TunnelHandler struct {\n-\toriginUrl  string\n-\tmuxer      *h2mux.Muxer\n-\thttpClient http.RoundTripper\n-\ttlsConfig  *tls.Config\n-\ttags       []tunnelpogs.Tag\n-\tmetrics    *TunnelMetrics\n+\toriginUrl      string\n+\thttpHostHeader string\n+\tmuxer          *h2mux.Muxer\n+\thttpClient     http.RoundTripper\n+\ttlsConfig      *tls.Config\n+\ttags           []tunnelpogs.Tag\n+\tmetrics        *TunnelMetrics\n \t// connectionID is only used by metrics, and prometheus requires labels to be string\n \tconnectionID      string\n \tlogger            *log.Logger\n@@ -473,6 +475,7 @@ func NewTunnelHandler(ctx context.Context,\n \t}\n \th := &TunnelHandler{\n \t\toriginUrl:         originURL,\n+\t\thttpHostHeader:    config.HTTPHostHeader,\n \t\thttpClient:        config.HTTPTransport,\n \t\ttlsConfig:         config.ClientTlsConfig,\n \t\ttags:              config.Tags,\n@@ -566,6 +569,11 @@ func (h *TunnelHandler) createRequest(stream *h2mux.MuxedStream) (*http.Request,\n }\n \n func (h *TunnelHandler) serveWebsocket(stream *h2mux.MuxedStream, req *http.Request) (*http.Response, error) {\n+\tif h.httpHostHeader != \"\" {\n+\t\treq.Header.Set(\"Host\", h.httpHostHeader)\n+\t\treq.Host = h.httpHostHeader\n+\t}\n+\n \tconn, response, err := websocket.ClientConnect(req, h.tlsConfig)\n \tif err != nil {\n \t\treturn nil, err\n@@ -594,6 +602,11 @@ func (h *TunnelHandler) serveHTTP(stream *h2mux.MuxedStream, req *http.Request)\n \t// Request origin to keep connection alive to improve performance\n \treq.Header.Set(\"Connection\", \"keep-alive\")\n \n+\tif h.httpHostHeader != \"\" {\n+\t\treq.Header.Set(\"Host\", h.httpHostHeader)\n+\t\treq.Host = h.httpHostHeader\n+\t}\n+\n \tresponse, err := h.httpClient.RoundTrip(req)\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"Error proxying request to origin\")\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Access/ssh-config: generate consistent ssh_config\n\nDescription: * Prefer text/template over html/template to avoid unwanted HTML encoding\r\n* Use templated \"cfpipe-{{.Hostname}}\"\r\n* Fix IdentityFile suffix in \"cfpipe\" to use key generated by \"ssh-gen\"\n\nCode Diff:\ncmd/cloudflared/access/cmd.go\n@@ -3,10 +3,10 @@ package access\n import (\n \t\"errors\"\n \t\"fmt\"\n-\t\"html/template\"\n \t\"net/url\"\n \t\"os\"\n \t\"strings\"\n[[MASK]]\n \n Host {{.Hostname}}\n {{- if .ShortLivedCerts}}\n-\tProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt cfpipe >&2 <&1' \n+\tProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt cfpipe-{{.Hostname}} >&2 <&1'\n \n Host cfpipe-{{.Hostname}}\n \tHostName {{.Hostname}}\n \tProxyCommand {{.Cloudflared}} access ssh --hostname %h\n-\tIdentityFile ~/.cloudflared/{{.Hostname}}.me-cf_key\n+\tIdentityFile ~/.cloudflared/{{.Hostname}}-cf_key\n \tCertificateFile ~/.cloudflared/{{.Hostname}}-cf_key-cert.pub\n {{- else}}\n \tProxyCommand {{.Cloudflared}} access ssh --hostname %h\n---\n\n"}], "ideal": "cmd/cloudflared/access/cmd.go\n@@ -3,10 +3,10 @@ package access\n import (\n \t\"errors\"\n \t\"fmt\"\n-\t\"html/template\"\n \t\"net/url\"\n \t\"os\"\n \t\"strings\"\n+\t\"text/template\"\n \n \t\"github.com/cloudflare/cloudflared/cmd/cloudflared/shell\"\n \t\"github.com/cloudflare/cloudflared/cmd/cloudflared/token\"\n@@ -31,12 +31,12 @@ Add this configuration block to your {{.Home}}/.ssh/config:\n \n Host {{.Hostname}}\n {{- if .ShortLivedCerts}}\n-\tProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt cfpipe >&2 <&1' \n+\tProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt cfpipe-{{.Hostname}} >&2 <&1'\n \n Host cfpipe-{{.Hostname}}\n \tHostName {{.Hostname}}\n \tProxyCommand {{.Cloudflared}} access ssh --hostname %h\n-\tIdentityFile ~/.cloudflared/{{.Hostname}}.me-cf_key\n+\tIdentityFile ~/.cloudflared/{{.Hostname}}-cf_key\n \tCertificateFile ~/.cloudflared/{{.Hostname}}-cf_key-cert.pub\n {{- else}}\n \tProxyCommand {{.Cloudflared}} access ssh --hostname %h\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Add -w -s to ldflags when compiling for release\n\nDescription: By default, when compiling cloudflared via make, we can strip the symbol\r\ntable and DWARF debugging information from the binary. This results in\r\nan approximately 10Mb reduction in file size, with no impact on\r\nexecution.\r\n\r\nIf you need to run cloudflared through a debugger and need the\r\nDWARF/symbol table information, you can run `make cloudflared DEBUG=true` to\r\nuse the previous behaviour.\n\nCode Diff:\nMakefile\n@@ -1,6 +1,6 @@\n VERSION       := $(shell git describe --tags --always --dirty=\"-dev\" --match \"[0-9][0-9][0-9][0-9].*.*\")\n DATE          := $(shell date -u '+%Y-%m-%d-%H%M UTC')\n-VERSION_FLAGS := -ldflags='-X \"main.Version=$(VERSION)\" -X \"main.BuildTime=$(DATE)\"'\n+LD_FLAGS      := -X \"main.Version=$(VERSION)\" -X \"main.BuildTime=$(DATE)\"\n MSI_VERSION   := $(shell git tag -l --sort=v:refname | grep \"w\" | tail -1 | cut -c2-)\n #MSI_VERSION expects the format of the tag to be: (wX.X.X). Starts with the w character to not break cfsetup.\n #e.g. w3.0.1 or w4.2.10. It trims off the w character when creating the MSI.\n@@ -62,6 +62,10 @@ else\n \tTARGET_PUBLIC_REPO ?= $(FLAVOR)\n endif\n \n+ifneq ($(DEBUG), true)\n+\tLD_FLAGS += -w -s\n+endif\n+\n .PHONY: all\n all: cloudflared test\n \n[[MASK]]\n+\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) go build -v -mod=vendor -ldflags='$(LD_FLAGS)' $(IMPORT_PATH)/cmd/cloudflared\n \n .PHONY: container\n container:\n \tdocker build --build-arg=TARGET_ARCH=$(TARGET_ARCH) --build-arg=TARGET_OS=$(TARGET_OS) -t cloudflare/cloudflared-$(TARGET_OS)-$(TARGET_ARCH):\"$(VERSION)\" .\n \n .PHONY: test\n test: vet\n-\tgo test -v -mod=vendor -race $(VERSION_FLAGS) ./...\n+\tgo test -v -mod=vendor -race -ldflags='$(LD_FLAGS)' ./...\n \n .PHONY: test-ssh-server\n test-ssh-server:\n@@ -190,7 +194,7 @@ homebrew-release: homebrew-upload\n \n .PHONY: release\n release: bin/equinox\n-\tbin/equinox release $(EQUINOX_FLAGS) -- $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tbin/equinox release $(EQUINOX_FLAGS) -- -ldflags='$(LD_FLAGS)' $(IMPORT_PATH)/cmd/cloudflared\n \n .PHONY: github-release\n github-release: cloudflared\n@@ -225,4 +229,4 @@ vet:\n \n .PHONY: msi\n msi: cloudflared\n-\tgo-msi make --msi cloudflared.msi --version $(MSI_VERSION)\n\\ No newline at end of file\n+\tgo-msi make --msi cloudflared.msi --version $(MSI_VERSION)\n---\n\n"}], "ideal": "Makefile\n@@ -1,6 +1,6 @@\n VERSION       := $(shell git describe --tags --always --dirty=\"-dev\" --match \"[0-9][0-9][0-9][0-9].*.*\")\n DATE          := $(shell date -u '+%Y-%m-%d-%H%M UTC')\n-VERSION_FLAGS := -ldflags='-X \"main.Version=$(VERSION)\" -X \"main.BuildTime=$(DATE)\"'\n+LD_FLAGS      := -X \"main.Version=$(VERSION)\" -X \"main.BuildTime=$(DATE)\"\n MSI_VERSION   := $(shell git tag -l --sort=v:refname | grep \"w\" | tail -1 | cut -c2-)\n #MSI_VERSION expects the format of the tag to be: (wX.X.X). Starts with the w character to not break cfsetup.\n #e.g. w3.0.1 or w4.2.10. It trims off the w character when creating the MSI.\n@@ -62,6 +62,10 @@ else\n \tTARGET_PUBLIC_REPO ?= $(FLAVOR)\n endif\n \n+ifneq ($(DEBUG), true)\n+\tLD_FLAGS += -w -s\n+endif\n+\n .PHONY: all\n all: cloudflared test\n \n@@ -71,15 +75,15 @@ clean:\n \n .PHONY: cloudflared\n cloudflared: tunnel-deps\n-\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) go build -v -mod=vendor $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) go build -v -mod=vendor -ldflags='$(LD_FLAGS)' $(IMPORT_PATH)/cmd/cloudflared\n \n .PHONY: container\n container:\n \tdocker build --build-arg=TARGET_ARCH=$(TARGET_ARCH) --build-arg=TARGET_OS=$(TARGET_OS) -t cloudflare/cloudflared-$(TARGET_OS)-$(TARGET_ARCH):\"$(VERSION)\" .\n \n .PHONY: test\n test: vet\n-\tgo test -v -mod=vendor -race $(VERSION_FLAGS) ./...\n+\tgo test -v -mod=vendor -race -ldflags='$(LD_FLAGS)' ./...\n \n .PHONY: test-ssh-server\n test-ssh-server:\n@@ -190,7 +194,7 @@ homebrew-release: homebrew-upload\n \n .PHONY: release\n release: bin/equinox\n-\tbin/equinox release $(EQUINOX_FLAGS) -- $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tbin/equinox release $(EQUINOX_FLAGS) -- -ldflags='$(LD_FLAGS)' $(IMPORT_PATH)/cmd/cloudflared\n \n .PHONY: github-release\n github-release: cloudflared\n@@ -225,4 +229,4 @@ vet:\n \n .PHONY: msi\n msi: cloudflared\n-\tgo-msi make --msi cloudflared.msi --version $(MSI_VERSION)\n\\ No newline at end of file\n+\tgo-msi make --msi cloudflared.msi --version $(MSI_VERSION)\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: tunneldns: Update reporting metrics for API breakage in CoreDNS.\n\nDescription: Use the new metrics.WithServer(ctx) method to get a server name, as the vars.Report emethod name takes this as its first param.\r\n\r\nAPI was broken by upstream PR: https://github.com/coredns/coredns/pull/2722 \n\nCode Diff:\ntunneldns/metrics.go\n@@ -4,6 +4,7 @@ import (\n \t\"context\"\n[[MASK]]\n \t\"github.com/coredns/coredns/plugin/pkg/rcode\"\n@@ -37,7 +38,7 @@ func (p MetricsPlugin) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dn\n \tstatus, err := plugin.NextOrFailure(p.Name(), p.Next, ctx, rw, r)\n \n \t// Update built-in metrics\n-\tvars.Report(ctx, state, \".\", rcode.ToString(rw.Rcode), rw.Len, rw.Start)\n+\tvars.Report(metrics.WithServer(ctx), state, \".\", rcode.ToString(rw.Rcode), rw.Len, rw.Start)\n \n \treturn status, err\n }\n---\n\n"}], "ideal": "tunneldns/metrics.go\n@@ -4,6 +4,7 @@ import (\n \t\"context\"\n \n \t\"github.com/coredns/coredns/plugin\"\n+\t\"github.com/coredns/coredns/plugin/metrics\"\n \t\"github.com/coredns/coredns/plugin/metrics/vars\"\n \t\"github.com/coredns/coredns/plugin/pkg/dnstest\"\n \t\"github.com/coredns/coredns/plugin/pkg/rcode\"\n@@ -37,7 +38,7 @@ func (p MetricsPlugin) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dn\n \tstatus, err := plugin.NextOrFailure(p.Name(), p.Next, ctx, rw, r)\n \n \t// Update built-in metrics\n-\tvars.Report(ctx, state, \".\", rcode.ToString(rw.Rcode), rw.Len, rw.Start)\n+\tvars.Report(metrics.WithServer(ctx), state, \".\", rcode.ToString(rw.Rcode), rw.Len, rw.Start)\n \n \treturn status, err\n }\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Build a docker container\n\nDescription: The build phase makes the assumption that any capnproto-files are pre-processed before building in-docker. I personally prefer \"add-on-change\" for protos over add-on-compile since that may lead to a dirty build.\r\n\r\nChose to add this as a PR even though there's already an open one. Feel free to close if we should focus on one PR with a slightly different direction instead.\r\n\r\nFinally, my comment in the previous PR (#89) set out to clone inside the container which likely is a safer approach for release builds, but copying tree allows us to do \"developer\"/in-transit builds.\n\nCode Diff:\nDockerfile\n@@ -0,0 +1,12 @@\n+FROM golang:1.12 as builder\n[[MASK]]\n+RUN upx --no-progress cloudflared\n+\n+FROM gcr.io/distroless/base\n+COPY --from=builder /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n+CMD [\"version\"]\n---\nMakefile\n@@ -31,6 +31,10 @@ clean:\n cloudflared: tunnel-deps\n \tgo build -v $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n \n+.PHONY: container\n+container:\n+\tdocker build -t cloudflare/cloudflared:\"$(VERSION)\" .\n+\n .PHONY: test\n test: vet\n \tgo test -v -race $(VERSION_FLAGS) ./...\n---\n\n"}], "ideal": "Dockerfile\n@@ -0,0 +1,12 @@\n+FROM golang:1.12 as builder\n+WORKDIR /go/src/github.com/cloudflare/cloudflared/\n+RUN apt-get update && apt-get install -y --no-install-recommends upx\n+# Run after `apt-get update` to improve rebuild scenarios\n+COPY . .\n+RUN make cloudflared\n+RUN upx --no-progress cloudflared\n+\n+FROM gcr.io/distroless/base\n+COPY --from=builder /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n+CMD [\"version\"]\n---\nMakefile\n@@ -31,6 +31,10 @@ clean:\n cloudflared: tunnel-deps\n \tgo build -v $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n \n+.PHONY: container\n+container:\n+\tdocker build -t cloudflare/cloudflared:\"$(VERSION)\" .\n+\n .PHONY: test\n test: vet\n \tgo test -v -race $(VERSION_FLAGS) ./...\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: configure git to access to http(s) based repos behind CloudFlare Access\n\nDescription:  example command: `cloudflared access gitConfig https://git.site.com`\n\nCode Diff:\ncmd/cloudflared/access/cmd.go\n@@ -72,6 +72,14 @@ func Commands() []*cli.Command {\n \t\t\t\t\tArgsUsage:       \"allow-request will allow the curl request to continue even if the jwt is not present.\",\n \t\t\t\t\tSkipFlagParsing: true,\n \t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tName:   \"gitConfig\",\n+\t\t\t\t\tAction: gitConfig,\n+\t\t\t\t\tUsage:  \"gitConfig <repo_url>\",\n+\t\t\t\t\tDescription: `The gitConfig subcommand configures your git to injects the JWT into a cf-access-token\n+\t\t\t\t\theader when using git to reach an application behind Access.`,\n+\t\t\t\t\tSkipFlagParsing: true,\n+\t\t\t\t},\n \t\t\t\t{\n \t\t\t\t\tName:        \"token\",\n \t\t\t\t\tAction:      generateToken,\n@@ -182,6 +190,41 @@ func curl(c *cli.Context) error {\n \treturn shell.Run(\"curl\", cmdArgs...)\n }\n \n+/* gitConfig modifies your ~/.gitconfig file to\n+pass Access JWT along in request\n+*/\n+func gitConfig(c *cli.Context) error {\n+\traven.SetDSN(sentryDSN)\n+\tlogger := log.CreateLogger()\n+\targs := c.Args()\n+\tif args.Len() < 1 {\n+\t\tlogger.Error(\"Please provide the access app and command you wish to run.\")\n+\t\treturn errors.New(\"incorrect args\")\n+\t}\n+\n+\tcmdArgs := args.Slice()\n+\tappURL, err := getAppURL(cmdArgs)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\ttok, err := token.GetTokenIfExists(appURL)\n+\tif err != nil || tok == \"\" {\n+\t\ttok, err = token.FetchToken(appURL)\n+\t\tif err != nil {\n+\t\t\tlogger.Error(\"Failed to refresh token: \", err)\n+\t\t\treturn err\n+\t\t}\n[[MASK]]\n+\t\tfmt.Sprintf(\"http.https://%s.extraheader\", appURL.Hostname()),\n+\t\tfmt.Sprintf(\"cf-access-token:%s\", tok),\n+\t}\n+\treturn shell.Run(\"git\", gitArgs...)\n+}\n+\n // token dumps provided token to stdout\n func generateToken(c *cli.Context) error {\n \traven.SetDSN(sentryDSN)\n---\n\n"}], "ideal": "cmd/cloudflared/access/cmd.go\n@@ -72,6 +72,14 @@ func Commands() []*cli.Command {\n \t\t\t\t\tArgsUsage:       \"allow-request will allow the curl request to continue even if the jwt is not present.\",\n \t\t\t\t\tSkipFlagParsing: true,\n \t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tName:   \"gitConfig\",\n+\t\t\t\t\tAction: gitConfig,\n+\t\t\t\t\tUsage:  \"gitConfig <repo_url>\",\n+\t\t\t\t\tDescription: `The gitConfig subcommand configures your git to injects the JWT into a cf-access-token\n+\t\t\t\t\theader when using git to reach an application behind Access.`,\n+\t\t\t\t\tSkipFlagParsing: true,\n+\t\t\t\t},\n \t\t\t\t{\n \t\t\t\t\tName:        \"token\",\n \t\t\t\t\tAction:      generateToken,\n@@ -182,6 +190,41 @@ func curl(c *cli.Context) error {\n \treturn shell.Run(\"curl\", cmdArgs...)\n }\n \n+/* gitConfig modifies your ~/.gitconfig file to\n+pass Access JWT along in request\n+*/\n+func gitConfig(c *cli.Context) error {\n+\traven.SetDSN(sentryDSN)\n+\tlogger := log.CreateLogger()\n+\targs := c.Args()\n+\tif args.Len() < 1 {\n+\t\tlogger.Error(\"Please provide the access app and command you wish to run.\")\n+\t\treturn errors.New(\"incorrect args\")\n+\t}\n+\n+\tcmdArgs := args.Slice()\n+\tappURL, err := getAppURL(cmdArgs)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\ttok, err := token.GetTokenIfExists(appURL)\n+\tif err != nil || tok == \"\" {\n+\t\ttok, err = token.FetchToken(appURL)\n+\t\tif err != nil {\n+\t\t\tlogger.Error(\"Failed to refresh token: \", err)\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tgitArgs := []string{\n+\t\t\"config\",\n+\t\t\"--global\",\n+\t\tfmt.Sprintf(\"http.https://%s.extraheader\", appURL.Hostname()),\n+\t\tfmt.Sprintf(\"cf-access-token:%s\", tok),\n+\t}\n+\treturn shell.Run(\"git\", gitArgs...)\n+}\n+\n // token dumps provided token to stdout\n func generateToken(c *cli.Context) error {\n \traven.SetDSN(sentryDSN)\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Support UNIX sockets\n\nDescription: This pull requests adds support for unix socket upstreams.\n\nCode Diff:\ncmd/cloudflared/config/configuration.go\n@@ -63,7 +63,17 @@ func FindDefaultConfigPath() string {\n \treturn \"\"\n }\n \n+// ValidateUnixSocket ensures --unix-socket param is used exclusively\n+// i.e. it fails if a user specifies both --url and --unix-socket\n+func ValidateUnixSocket(c *cli.Context) (string, error) {\n+\tif c.IsSet(\"unix-socket\") && (c.IsSet(\"url\") || c.NArg() > 0) {\n+\t\treturn \"\", errors.New(\"--unix-socket must be used exclusivly.\")\n+\t}\n+\treturn c.String(\"unix-socket\"), nil\n+}\n+\n // ValidateUrl will validate url flag correctness. It can be either from --url or argument\n+// Notice ValidateUnixSocket, it will enforce --unix-socket is not used with --url or argument\n func ValidateUrl(c *cli.Context) (string, error) {\n \tvar url = c.String(\"url\")\n \tif c.NArg() > 0 {\n---\ncmd/cloudflared/tunnel/cmd.go\n@@ -474,6 +474,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_URL\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:    \"unix-socket\",\n+\t\t\tUsage:   \"Path to unix socket to use instead of --url\",\n+\t\t\tEnvVars: []string{\"TUNNEL_UNIX_SOCKET\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewStringFlag(&cli.StringFlag{\n \t\t\tName:    \"hostname\",\n \t\t\tUsage:   \"Set a hostname on a Cloudflare zone to route traffic through this tunnel.\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -1,6 +1,7 @@\n package tunnel\n \n import (\n+\t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n \t\"encoding/hex\"\n@@ -160,7 +161,6 @@ func prepareTunnelConfig(c *cli.Context, buildInfo *origin.BuildInfo, version st\n \t\tlogger.WithError(err).Error(\"Error validating origin URL\")\n \t\treturn nil, errors.Wrap(err, \"Error validating origin URL\")\n \t}\n-\tlogger.Infof(\"Proxying tunnel requests to %s\", originURL)\n \n \toriginCert, err := getOriginCert(c)\n \tif err != nil {\n@@ -175,19 +175,37 @@ func prepareTunnelConfig(c *cli.Context, buildInfo *origin.BuildInfo, version st\n \n \ttunnelMetrics := origin.NewTunnelMetrics()\n \thttpTransport := &http.Transport{\n-\t\tProxy: http.ProxyFromEnvironment,\n-\t\tDialContext: (&net.Dialer{\n-\t\t\tTimeout:   c.Duration(\"proxy-connect-timeout\"),\n-\t\t\tKeepAlive: c.Duration(\"proxy-tcp-keepalive\"),\n-\t\t\tDualStack: !c.Bool(\"proxy-no-happy-eyeballs\"),\n-\t\t}).DialContext,\n+\t\tProxy:                 http.ProxyFromEnvironment,\n \t\tMaxIdleConns:          c.Int(\"proxy-keepalive-connections\"),\n \t\tIdleConnTimeout:       c.Duration(\"proxy-keepalive-timeout\"),\n \t\tTLSHandshakeTimeout:   c.Duration(\"proxy-tls-timeout\"),\n \t\tExpectContinueTimeout: 1 * time.Second,\n \t\tTLSClientConfig:       &tls.Config{RootCAs: originCertPool, InsecureSkipVerify: c.IsSet(\"no-tls-verify\")},\n \t}\n \n+\tdialContext := (&net.Dialer{\n+\t\tTimeout:   c.Duration(\"proxy-connect-timeout\"),\n+\t\tKeepAlive: c.Duration(\"proxy-tcp-keepalive\"),\n+\t\tDualStack: !c.Bool(\"proxy-no-happy-eyeballs\"),\n+\t}).DialContext\n+\n+\tif c.IsSet(\"unix-socket\") {\n+\t\tunixSocket, err := config.ValidateUnixSocket(c)\n+\t\tif err != nil {\n+\t\t\tlogger.WithError(err).Error(\"Error validating --unix-socket\")\n+\t\t\treturn nil, errors.Wrap(err, \"Error validating --unix-socket\")\n+\t\t}\n+\n+\t\tlogger.Infof(\"Proxying tunnel requests to unix:%s\", unixSocket)\n+\t\thttpTransport.DialContext = func(ctx context.Context, _, _ string) (net.Conn, error) {\n+\t\t\t// if --unix-socket specified, enforce network type \"unix\"\n+\t\t\treturn dialContext(ctx, \"unix\", unixSocket)\n+\t\t}\n+\t} else {\n+\t\tlogger.Infof(\"Proxying tunnel requests to %s\", originURL)\n+\t\thttpTransport.DialContext = dialContext\n+\t}\n+\n \tif !c.IsSet(\"hello-world\") && c.IsSet(\"origin-server-name\") {\n \t\thttpTransport.TLSClientConfig.ServerName = c.String(\"origin-server-name\")\n \t}\n---\norigin/tunnel.go\n@@ -37,8 +37,10 @@ const (\n )\n \n type TunnelConfig struct {\n[[MASK]]\n \tHostname           string\n \tOriginCert         []byte\n \tTlsConfig          *tls.Config\n---\n\n"}], "ideal": "cmd/cloudflared/config/configuration.go\n@@ -63,7 +63,17 @@ func FindDefaultConfigPath() string {\n \treturn \"\"\n }\n \n+// ValidateUnixSocket ensures --unix-socket param is used exclusively\n+// i.e. it fails if a user specifies both --url and --unix-socket\n+func ValidateUnixSocket(c *cli.Context) (string, error) {\n+\tif c.IsSet(\"unix-socket\") && (c.IsSet(\"url\") || c.NArg() > 0) {\n+\t\treturn \"\", errors.New(\"--unix-socket must be used exclusivly.\")\n+\t}\n+\treturn c.String(\"unix-socket\"), nil\n+}\n+\n // ValidateUrl will validate url flag correctness. It can be either from --url or argument\n+// Notice ValidateUnixSocket, it will enforce --unix-socket is not used with --url or argument\n func ValidateUrl(c *cli.Context) (string, error) {\n \tvar url = c.String(\"url\")\n \tif c.NArg() > 0 {\n---\ncmd/cloudflared/tunnel/cmd.go\n@@ -474,6 +474,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_URL\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:    \"unix-socket\",\n+\t\t\tUsage:   \"Path to unix socket to use instead of --url\",\n+\t\t\tEnvVars: []string{\"TUNNEL_UNIX_SOCKET\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewStringFlag(&cli.StringFlag{\n \t\t\tName:    \"hostname\",\n \t\t\tUsage:   \"Set a hostname on a Cloudflare zone to route traffic through this tunnel.\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -1,6 +1,7 @@\n package tunnel\n \n import (\n+\t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n \t\"encoding/hex\"\n@@ -160,7 +161,6 @@ func prepareTunnelConfig(c *cli.Context, buildInfo *origin.BuildInfo, version st\n \t\tlogger.WithError(err).Error(\"Error validating origin URL\")\n \t\treturn nil, errors.Wrap(err, \"Error validating origin URL\")\n \t}\n-\tlogger.Infof(\"Proxying tunnel requests to %s\", originURL)\n \n \toriginCert, err := getOriginCert(c)\n \tif err != nil {\n@@ -175,19 +175,37 @@ func prepareTunnelConfig(c *cli.Context, buildInfo *origin.BuildInfo, version st\n \n \ttunnelMetrics := origin.NewTunnelMetrics()\n \thttpTransport := &http.Transport{\n-\t\tProxy: http.ProxyFromEnvironment,\n-\t\tDialContext: (&net.Dialer{\n-\t\t\tTimeout:   c.Duration(\"proxy-connect-timeout\"),\n-\t\t\tKeepAlive: c.Duration(\"proxy-tcp-keepalive\"),\n-\t\t\tDualStack: !c.Bool(\"proxy-no-happy-eyeballs\"),\n-\t\t}).DialContext,\n+\t\tProxy:                 http.ProxyFromEnvironment,\n \t\tMaxIdleConns:          c.Int(\"proxy-keepalive-connections\"),\n \t\tIdleConnTimeout:       c.Duration(\"proxy-keepalive-timeout\"),\n \t\tTLSHandshakeTimeout:   c.Duration(\"proxy-tls-timeout\"),\n \t\tExpectContinueTimeout: 1 * time.Second,\n \t\tTLSClientConfig:       &tls.Config{RootCAs: originCertPool, InsecureSkipVerify: c.IsSet(\"no-tls-verify\")},\n \t}\n \n+\tdialContext := (&net.Dialer{\n+\t\tTimeout:   c.Duration(\"proxy-connect-timeout\"),\n+\t\tKeepAlive: c.Duration(\"proxy-tcp-keepalive\"),\n+\t\tDualStack: !c.Bool(\"proxy-no-happy-eyeballs\"),\n+\t}).DialContext\n+\n+\tif c.IsSet(\"unix-socket\") {\n+\t\tunixSocket, err := config.ValidateUnixSocket(c)\n+\t\tif err != nil {\n+\t\t\tlogger.WithError(err).Error(\"Error validating --unix-socket\")\n+\t\t\treturn nil, errors.Wrap(err, \"Error validating --unix-socket\")\n+\t\t}\n+\n+\t\tlogger.Infof(\"Proxying tunnel requests to unix:%s\", unixSocket)\n+\t\thttpTransport.DialContext = func(ctx context.Context, _, _ string) (net.Conn, error) {\n+\t\t\t// if --unix-socket specified, enforce network type \"unix\"\n+\t\t\treturn dialContext(ctx, \"unix\", unixSocket)\n+\t\t}\n+\t} else {\n+\t\tlogger.Infof(\"Proxying tunnel requests to %s\", originURL)\n+\t\thttpTransport.DialContext = dialContext\n+\t}\n+\n \tif !c.IsSet(\"hello-world\") && c.IsSet(\"origin-server-name\") {\n \t\thttpTransport.TLSClientConfig.ServerName = c.String(\"origin-server-name\")\n \t}\n---\norigin/tunnel.go\n@@ -37,8 +37,10 @@ const (\n )\n \n type TunnelConfig struct {\n+\t// OriginUrl may not be used if a user specifies a unix socket.\n+\tOriginUrl string\n+\n \tEdgeAddrs          []string\n-\tOriginUrl          string\n \tHostname           string\n \tOriginCert         []byte\n \tTlsConfig          *tls.Config\n---\n"}
{"input": [{"role": "system", "content": "You are given a GitHub pull request title, description, and code that contains masked lines.\n\nGenerate the code diff by replacing the masked lines with code that solves the GitHub pull request.\n\nThe masked lines are marked with [[MASK]] in the code diff.\n\nGenerate the entire code diff by replacing the masked lines of code with the correct lines of code, while including all the previous code.\n\nOnly generate the code diff, do not generate anything else."}, {"role": "user", "content": "Title: Makes origin.TunnelMetrics public again\n\nDescription: Test code must avoid the prometheus static initialization, and\r\ncan do this by creating a dummy TunnelMetrics object, provided\r\nit is public.\n\nCode Diff:\norigin/metrics.go\n@@ -27,7 +27,7 @@ type muxerMetrics struct {\n \toutBoundRateMax  *prometheus.GaugeVec\n }\n \n-type tunnelMetrics struct {\n+type TunnelMetrics struct {\n \thaConnections     prometheus.Gauge\n \ttotalRequests     prometheus.Counter\n \trequestsPerTunnel *prometheus.CounterVec\n@@ -229,7 +229,7 @@ func convertRTTMilliSec(t time.Duration) float64 {\n }\n \n // Metrics that can be collected without asking the edge\n-func NewTunnelMetrics() *tunnelMetrics {\n+func NewTunnelMetrics() *TunnelMetrics {\n \thaConnections := prometheus.NewGauge(\n \t\tprometheus.GaugeOpts{\n \t\t\tName: \"ha_connections\",\n@@ -305,7 +305,7 @@ func NewTunnelMetrics() *tunnelMetrics {\n \t)\n \tprometheus.MustRegister(serverLocations)\n \n-\treturn &tunnelMetrics{\n+\treturn &TunnelMetrics{\n \t\thaConnections:                  haConnections,\n \t\ttotalRequests:                  totalRequests,\n \t\trequestsPerTunnel:              requestsPerTunnel,\n@@ -322,19 +322,19 @@ func NewTunnelMetrics() *tunnelMetrics {\n \t}\n }\n \n-func (t *tunnelMetrics) incrementHaConnections() {\n+func (t *TunnelMetrics) incrementHaConnections() {\n \tt.haConnections.Inc()\n }\n[[MASK]]\n \n-func (t *tunnelMetrics) updateMuxerMetrics(connectionID string, metrics *h2mux.MuxerMetrics) {\n+func (t *TunnelMetrics) updateMuxerMetrics(connectionID string, metrics *h2mux.MuxerMetrics) {\n \tt.muxerMetrics.update(connectionID, metrics)\n }\n \n-func (t *tunnelMetrics) incrementRequests(connectionID string) {\n+func (t *TunnelMetrics) incrementRequests(connectionID string) {\n \tt.concurrentRequestsLock.Lock()\n \tvar concurrentRequests uint64\n \tvar ok bool\n@@ -356,7 +356,7 @@ func (t *tunnelMetrics) incrementRequests(connectionID string) {\n \tt.concurrentRequestsPerTunnel.WithLabelValues(connectionID).Inc()\n }\n \n-func (t *tunnelMetrics) decrementConcurrentRequests(connectionID string) {\n+func (t *TunnelMetrics) decrementConcurrentRequests(connectionID string) {\n \tt.concurrentRequestsLock.Lock()\n \tif _, ok := t.concurrentRequests[connectionID]; ok {\n \t\tt.concurrentRequests[connectionID] -= 1\n@@ -368,13 +368,13 @@ func (t *tunnelMetrics) decrementConcurrentRequests(connectionID string) {\n \tt.concurrentRequestsPerTunnel.WithLabelValues(connectionID).Dec()\n }\n \n-func (t *tunnelMetrics) incrementResponses(connectionID, code string) {\n+func (t *TunnelMetrics) incrementResponses(connectionID, code string) {\n \tt.responseByCode.WithLabelValues(code).Inc()\n \tt.responseCodePerTunnel.WithLabelValues(connectionID, code).Inc()\n \n }\n \n-func (t *tunnelMetrics) registerServerLocation(connectionID, loc string) {\n+func (t *TunnelMetrics) registerServerLocation(connectionID, loc string) {\n \tt.locationLock.Lock()\n \tdefer t.locationLock.Unlock()\n \tif oldLoc, ok := t.oldServerLocations[connectionID]; ok && oldLoc == loc {\n---\norigin/tunnel.go\n@@ -53,7 +53,7 @@ type TunnelConfig struct {\n \tTags              []tunnelpogs.Tag\n \tHAConnections     int\n \tHTTPTransport     http.RoundTripper\n-\tMetrics           *tunnelMetrics\n+\tMetrics           *TunnelMetrics\n \tMetricsUpdateFreq time.Duration\n \tProtocolLogger    *logrus.Logger\n \tLogger            *logrus.Logger\n@@ -335,7 +335,7 @@ func UnregisterTunnel(muxer *h2mux.Muxer, gracePeriod time.Duration) error {\n func LogServerInfo(logger *logrus.Entry,\n \tpromise tunnelrpc.ServerInfo_Promise,\n \tconnectionID uint8,\n-\tmetrics *tunnelMetrics,\n+\tmetrics *TunnelMetrics,\n ) {\n \tserverInfoMessage, err := promise.Struct()\n \tif err != nil {\n@@ -398,7 +398,7 @@ type TunnelHandler struct {\n \thttpClient http.RoundTripper\n \ttlsConfig  *tls.Config\n \ttags       []tunnelpogs.Tag\n-\tmetrics    *tunnelMetrics\n+\tmetrics    *TunnelMetrics\n \t// connectionID is only used by metrics, and prometheus requires labels to be string\n \tconnectionID string\n }\n---\n\n"}], "ideal": "origin/metrics.go\n@@ -27,7 +27,7 @@ type muxerMetrics struct {\n \toutBoundRateMax  *prometheus.GaugeVec\n }\n \n-type tunnelMetrics struct {\n+type TunnelMetrics struct {\n \thaConnections     prometheus.Gauge\n \ttotalRequests     prometheus.Counter\n \trequestsPerTunnel *prometheus.CounterVec\n@@ -229,7 +229,7 @@ func convertRTTMilliSec(t time.Duration) float64 {\n }\n \n // Metrics that can be collected without asking the edge\n-func NewTunnelMetrics() *tunnelMetrics {\n+func NewTunnelMetrics() *TunnelMetrics {\n \thaConnections := prometheus.NewGauge(\n \t\tprometheus.GaugeOpts{\n \t\t\tName: \"ha_connections\",\n@@ -305,7 +305,7 @@ func NewTunnelMetrics() *tunnelMetrics {\n \t)\n \tprometheus.MustRegister(serverLocations)\n \n-\treturn &tunnelMetrics{\n+\treturn &TunnelMetrics{\n \t\thaConnections:                  haConnections,\n \t\ttotalRequests:                  totalRequests,\n \t\trequestsPerTunnel:              requestsPerTunnel,\n@@ -322,19 +322,19 @@ func NewTunnelMetrics() *tunnelMetrics {\n \t}\n }\n \n-func (t *tunnelMetrics) incrementHaConnections() {\n+func (t *TunnelMetrics) incrementHaConnections() {\n \tt.haConnections.Inc()\n }\n \n-func (t *tunnelMetrics) decrementHaConnections() {\n+func (t *TunnelMetrics) decrementHaConnections() {\n \tt.haConnections.Dec()\n }\n \n-func (t *tunnelMetrics) updateMuxerMetrics(connectionID string, metrics *h2mux.MuxerMetrics) {\n+func (t *TunnelMetrics) updateMuxerMetrics(connectionID string, metrics *h2mux.MuxerMetrics) {\n \tt.muxerMetrics.update(connectionID, metrics)\n }\n \n-func (t *tunnelMetrics) incrementRequests(connectionID string) {\n+func (t *TunnelMetrics) incrementRequests(connectionID string) {\n \tt.concurrentRequestsLock.Lock()\n \tvar concurrentRequests uint64\n \tvar ok bool\n@@ -356,7 +356,7 @@ func (t *tunnelMetrics) incrementRequests(connectionID string) {\n \tt.concurrentRequestsPerTunnel.WithLabelValues(connectionID).Inc()\n }\n \n-func (t *tunnelMetrics) decrementConcurrentRequests(connectionID string) {\n+func (t *TunnelMetrics) decrementConcurrentRequests(connectionID string) {\n \tt.concurrentRequestsLock.Lock()\n \tif _, ok := t.concurrentRequests[connectionID]; ok {\n \t\tt.concurrentRequests[connectionID] -= 1\n@@ -368,13 +368,13 @@ func (t *tunnelMetrics) decrementConcurrentRequests(connectionID string) {\n \tt.concurrentRequestsPerTunnel.WithLabelValues(connectionID).Dec()\n }\n \n-func (t *tunnelMetrics) incrementResponses(connectionID, code string) {\n+func (t *TunnelMetrics) incrementResponses(connectionID, code string) {\n \tt.responseByCode.WithLabelValues(code).Inc()\n \tt.responseCodePerTunnel.WithLabelValues(connectionID, code).Inc()\n \n }\n \n-func (t *tunnelMetrics) registerServerLocation(connectionID, loc string) {\n+func (t *TunnelMetrics) registerServerLocation(connectionID, loc string) {\n \tt.locationLock.Lock()\n \tdefer t.locationLock.Unlock()\n \tif oldLoc, ok := t.oldServerLocations[connectionID]; ok && oldLoc == loc {\n---\norigin/tunnel.go\n@@ -53,7 +53,7 @@ type TunnelConfig struct {\n \tTags              []tunnelpogs.Tag\n \tHAConnections     int\n \tHTTPTransport     http.RoundTripper\n-\tMetrics           *tunnelMetrics\n+\tMetrics           *TunnelMetrics\n \tMetricsUpdateFreq time.Duration\n \tProtocolLogger    *logrus.Logger\n \tLogger            *logrus.Logger\n@@ -335,7 +335,7 @@ func UnregisterTunnel(muxer *h2mux.Muxer, gracePeriod time.Duration) error {\n func LogServerInfo(logger *logrus.Entry,\n \tpromise tunnelrpc.ServerInfo_Promise,\n \tconnectionID uint8,\n-\tmetrics *tunnelMetrics,\n+\tmetrics *TunnelMetrics,\n ) {\n \tserverInfoMessage, err := promise.Struct()\n \tif err != nil {\n@@ -398,7 +398,7 @@ type TunnelHandler struct {\n \thttpClient http.RoundTripper\n \ttlsConfig  *tls.Config\n \ttags       []tunnelpogs.Tag\n-\tmetrics    *tunnelMetrics\n+\tmetrics    *TunnelMetrics\n \t// connectionID is only used by metrics, and prometheus requires labels to be string\n \tconnectionID string\n }\n---\n"}
