{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFragmented datagrams would be processed instead of being dumped right\naway. In reality, thse datagrams would be dropped anyway later so there\nshould functionally not be any change. Additionally, the feature is off\nby default.\n\nCloses #16203\n\nSigned-off-by: Claus Lensb\u00f8l <claus@tailscale.com>\n\n\n---\n\nChoice A:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/init@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/autobuild@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/analyze@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n---\n\n\n---\n\nChoice B:\ntsnet/depaware.txt\n@@ -132,7 +132,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n    L \ud83d\udca3 github.com/mdlayher/netlink                                  from github.com/google/nftables+\n    L \ud83d\udca3 github.com/mdlayher/netlink/nlenc                            from github.com/jsimonetti/rtnetlink+\n    L    github.com/mdlayher/netlink/nltest                           from github.com/google/nftables\n-  LA    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n+   L    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n   LA \ud83d\udca3 github.com/mdlayher/socket                                   from github.com/mdlayher/netlink+\n         github.com/miekg/dns                                         from tailscale.com/net/dns/recursive\n  LDWA \ud83d\udca3 github.com/mitchellh/go-ps                                   from tailscale.com/safesocket\n---\nutil/systemd/systemd_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package systemd\n \n---\nutil/systemd/systemd_nonlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux || android\n \n package systemd\n \n---\n\n\n---\n\nChoice C:\nwgengine/magicsock/magicsock_linux.go\n@@ -66,10 +66,10 @@ var (\n \t\t// fragmented, and we don't want to handle reassembly.\n \t\tbpf.LoadAbsolute{Off: 6, Size: 2},\n \t\t// More Fragments bit set means this is part of a fragmented packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 7, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 8, SkipFalse: 0},\n \t\t// Non-zero fragment offset with MF=0 means this is the last\n \t\t// fragment of packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 6, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 7, SkipFalse: 0},\n \n \t\t// Load IP header length into X register.\n \t\tbpf.LoadMemShift{Off: 0},\n---\nwgengine/magicsock/magicsock_linux_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"net/netip\"\n \t\"testing\"\n \n+\t\"golang.org/x/net/bpf\"\n \t\"golang.org/x/sys/cpu\"\n \t\"golang.org/x/sys/unix\"\n \t\"tailscale.com/disco\"\n@@ -146,3 +147,78 @@ func TestEthernetProto(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestBpfDiscardV4(t *testing.T) {\n+\t// Good packet as a reference for what should not be rejected\n+\tudp4Packet := []byte{\n+\t\t// IPv4 header\n+\t\t0x45, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x40, 0x11, 0x00, 0x00,\n+\t\t0x7f, 0x00, 0x00, 0x01, // source ip\n+\t\t0x7f, 0x00, 0x00, 0x02, // dest ip\n+\n+\t\t// UDP header\n+\t\t0x30, 0x39, // src port\n+\t\t0xd4, 0x31, // dest port\n+\t\t0x00, 0x12, // length; 8 bytes header + 10 bytes payload = 18 bytes\n+\t\t0x00, 0x00, // checksum; unused\n+\n+\t\t// Payload: disco magic plus 32 bytes for key and 24 bytes for nonce\n+\t\t0x54, 0x53, 0xf0, 0x9f, 0x92, 0xac, 0x00, 0x01, 0x02, 0x03,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n+\t}\n+\n+\tvm, err := bpf.NewVM(magicsockFilterV4)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed creating BPF VM: %v\", err)\n+\t}\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\treplace map[int]byte\n+\t\taccept  bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"base accepted datagram\",\n+\t\t\treplace: map[int]byte{},\n+\t\t\taccept:  true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"more fragments\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t6: 0x20,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some fragment\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t7: 0x01,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t}\n+\n+\tudp4PacketChanged := make([]byte, len(udp4Packet))\n+\tcopy(udp4PacketChanged, udp4Packet)\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfor k, v := range tt.replace {\n+\t\t\t\tudp4PacketChanged[k] = v\n+\t\t\t}\n+\t\t\tret, err := vm.Run(udp4PacketChanged)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"BPF VM error: %v\", err)\n+\t\t\t}\n+\n+\t\t\tif (ret != 0) != tt.accept {\n+\t\t\t\tt.Errorf(\"expected accept=%v, got ret=%v\", tt.accept, ret)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice D:\nwgengine/netstack/netstack.go\n@@ -326,10 +326,15 @@ func Create(logf logger.Logf, tundev *tstun.Wrapper, e wgengine.Engine, mc *magi\n \tif tcpipErr != nil {\n \t\treturn nil, fmt.Errorf(\"could not disable TCP RACK: %v\", tcpipErr)\n \t}\n-\tcubicOpt := tcpip.CongestionControlOption(\"cubic\")\n-\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &cubicOpt)\n+\t// gVisor defaults to reno at the time of writing. We explicitly set reno\n+\t// congestion control in order to prevent unexpected changes. Netstack\n+\t// has an int overflow in sender congestion window arithmetic that is more\n+\t// prone to trigger with cubic congestion control.\n+\t// See https://github.com/google/gvisor/issues/11632\n+\trenoOpt := tcpip.CongestionControlOption(\"reno\")\n+\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &renoOpt)\n \tif tcpipErr != nil {\n-\t\treturn nil, fmt.Errorf(\"could not set cubic congestion control: %v\", tcpipErr)\n+\t\treturn nil, fmt.Errorf(\"could not set reno congestion control: %v\", tcpipErr)\n \t}\n \terr := setTCPBufSizes(ipstack)\n \tif err != nil {\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #cleanup\n\n---\n\nChoice A:\ndrive/driveimpl/dirfs/dirfs.go\n@@ -44,7 +44,7 @@ func (c *Child) isAvailable() bool {\n // Any attempts to perform operations on paths inside of children will result\n // in a panic, as these are not expected to be performed on this FS.\n //\n-// An FS an optionally have a StaticRoot, which will insert a folder with that\n+// An FS can optionally have a StaticRoot, which will insert a folder with that\n // StaticRoot into the tree, like this:\n //\n // -- <StaticRoot>\n---\ndrive/driveimpl/fileserver.go\n@@ -61,7 +61,7 @@ func NewFileServer() (*FileServer, error) {\n \t}, nil\n }\n \n-// generateSecretToken generates a hex-encoded 256 bit secet.\n+// generateSecretToken generates a hex-encoded 256 bit secret.\n func generateSecretToken() (string, error) {\n \ttokenBytes := make([]byte, 32)\n \t_, err := rand.Read(tokenBytes)\n---\ndrive/remote_permissions.go\n@@ -32,7 +32,7 @@ type grant struct {\n \tAccess string\n }\n \n-// ParsePermissions builds a Permissions map from a lis of raw grants.\n+// ParsePermissions builds a Permissions map from a list of raw grants.\n func ParsePermissions(rawGrants [][]byte) (Permissions, error) {\n \tpermissions := make(Permissions)\n \tfor _, rawGrant := range rawGrants {\n---\n\n\n---\n\nChoice B:\nnet/packet/packet.go\n@@ -51,10 +51,11 @@ type Parsed struct {\n \tIPVersion uint8\n \t// IPProto is the IP subprotocol (UDP, TCP, etc.). Valid iff IPVersion != 0.\n \tIPProto ipproto.Proto\n-\t// SrcIP4 is the source address. Family matches IPVersion. Port is\n-\t// valid iff IPProto == TCP || IPProto == UDP.\n+\t// Src is the source address. Family matches IPVersion. Port is\n+\t// valid iff IPProto == TCP || IPProto == UDP || IPProto == SCTP.\n \tSrc netip.AddrPort\n-\t// DstIP4 is the destination address. Family matches IPVersion.\n+\t// Dst is the destination address. Family matches IPVersion. Port is\n+\t// valid iff IPProto == TCP || IPProto == UDP || IPProto == SCTP.\n \tDst netip.AddrPort\n \t// TCPFlags is the packet's TCP flag bits. Valid iff IPProto == TCP.\n \tTCPFlags TCPFlag\n---\n\n\n---\n\nChoice C:\nprober/derp.go\n@@ -596,11 +596,23 @@ func (d *derpProber) updateMap(ctx context.Context) error {\n }\n \n func (d *derpProber) ProbeUDP(ipaddr string, port int) ProbeClass {\n+\tinitLabels := make(Labels)\n+\tip := net.ParseIP(ipaddr)\n+\n+\tif ip.To4() != nil {\n+\t\tinitLabels[\"address_family\"] = \"ipv4\"\n+\t} else if ip.To16() != nil { // Will return an IPv4 as 16 byte, so ensure the check for IPv4 precedes this\n+\t\tinitLabels[\"address_family\"] = \"ipv6\"\n+\t} else {\n+\t\tinitLabels[\"address_family\"] = \"unknown\"\n+\t}\n+\n \treturn ProbeClass{\n \t\tProbe: func(ctx context.Context) error {\n \t\t\treturn derpProbeUDP(ctx, ipaddr, port)\n \t\t},\n-\t\tClass: \"derp_udp\",\n+\t\tClass:  \"derp_udp\",\n+\t\tLabels: initLabels,\n \t}\n }\n \n---\nprober/prober.go\n@@ -404,10 +404,14 @@ func (p *Probe) recordEndLocked(err error) {\n \t\tp.mSeconds.WithLabelValues(\"ok\").Add(latency.Seconds())\n \t\tp.latencyHist.Value = latency\n \t\tp.latencyHist = p.latencyHist.Next()\n+\t\tp.mAttempts.WithLabelValues(\"fail\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"fail\").Add(0)\n \t} else {\n \t\tp.latency = 0\n \t\tp.mAttempts.WithLabelValues(\"fail\").Inc()\n \t\tp.mSeconds.WithLabelValues(\"fail\").Add(latency.Seconds())\n+\t\tp.mAttempts.WithLabelValues(\"ok\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"ok\").Add(0)\n \t}\n \tp.successHist.Value = p.succeeded\n \tp.successHist = p.successHist.Next()\n---\n\n\n---\n\nChoice D:\nclient/systray/logo.go\n@@ -11,10 +11,12 @@ import (\n \t\"image\"\n \t\"image/color\"\n \t\"image/png\"\n+\t\"runtime\"\n \t\"sync\"\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/fogleman/gg\"\n )\n \n@@ -251,7 +253,13 @@ func (logo tsLogo) renderWithBorder(borderUnits int) *bytes.Buffer {\n \t}\n \n \tb := bytes.NewBuffer(nil)\n-\tpng.Encode(b, dc.Image())\n+\n+\t// Encode as ICO format on Windows, PNG on all other platforms.\n+\tif runtime.GOOS == \"windows\" {\n+\t\t_ = ico.Encode(b, dc.Image())\n+\t} else {\n+\t\t_ = png.Encode(b, dc.Image())\n+\t}\n \treturn b\n }\n \n---\nclient/systray/systray.go\n@@ -7,9 +7,11 @@\n package systray\n \n import (\n+\t\"bytes\"\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"image\"\n \t\"io\"\n \t\"log\"\n \t\"net/http\"\n@@ -23,6 +25,7 @@ import (\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/atotto/clipboard\"\n \tdbus \"github.com/godbus/dbus/v5\"\n \t\"github.com/toqueteos/webbrowser\"\n@@ -330,6 +333,20 @@ func setRemoteIcon(menu *systray.MenuItem, urlStr string) {\n \t\tresp, err := http.Get(urlStr)\n \t\tif err == nil && resp.StatusCode == http.StatusOK {\n \t\t\tb, _ = io.ReadAll(resp.Body)\n+\n+\t\t\t// Convert image to ICO format on Windows\n+\t\t\tif runtime.GOOS == \"windows\" {\n+\t\t\t\tim, _, err := image.Decode(bytes.NewReader(b))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tbuf := bytes.NewBuffer(nil)\n+\t\t\t\tif err := ico.Encode(buf, im); err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tb = buf.Bytes()\n+\t\t\t}\n+\n \t\t\thttpCache[urlStr] = b\n \t\t\tresp.Body.Close()\n \t\t}\n---\ngo.mod\n@@ -4,7 +4,8 @@ go 1.24.0\n \n require (\n \tfilippo.io/mkcert v1.4.4\n-\tfyne.io/systray v1.11.0\n+\tfyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a\n+\tgithub.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9\n \tgithub.com/akutz/memconn v0.1.0\n \tgithub.com/alexbrainman/sspi v0.0.0-20231016080023-1a75b4708caa\n \tgithub.com/andybalholm/brotli v1.1.0\n@@ -100,7 +101,7 @@ require (\n \tgolang.org/x/net v0.36.0\n \tgolang.org/x/oauth2 v0.26.0\n \tgolang.org/x/sync v0.11.0\n-\tgolang.org/x/sys v0.30.0\n+\tgolang.org/x/sys v0.31.0\n \tgolang.org/x/term v0.29.0\n \tgolang.org/x/time v0.10.0\n \tgolang.org/x/tools v0.30.0\n---\ngo.sum\n@@ -41,8 +41,8 @@ filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\n filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\n filippo.io/mkcert v1.4.4 h1:8eVbbwfVlaqUM7OwuftKc2nuYOoTDQWqsoXmzoXZdbc=\n filippo.io/mkcert v1.4.4/go.mod h1:VyvOchVuAye3BoUsPUOOofKygVwLV2KQMVFJNRq+1dA=\n-fyne.io/systray v1.11.0 h1:D9HISlxSkx+jHSniMBR6fCFOUjk1x/OOOJLa9lJYAKg=\n-fyne.io/systray v1.11.0/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a h1:I8mEKo5sawHu8CqYf3FSjIl9b3puXasFVn2D/hrCneY=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n github.com/4meepo/tagalign v1.3.3 h1:ZsOxcwGD/jP4U/aw7qeWu58i7dwYemfy5Y+IF1ACoNw=\n github.com/4meepo/tagalign v1.3.3/go.mod h1:Q9c1rYMZJc9dPRkbQPpcBNCLEmY2njbAsXhQOZFE2dE=\n github.com/Abirdcfly/dupword v0.0.14 h1:3U4ulkc8EUo+CaT105/GJ1BQwtgyj6+VaBVbAX11Ba8=\n@@ -67,6 +67,8 @@ github.com/Djarvur/go-err113 v0.1.0 h1:uCRZZOdMQ0TZPHYTdYpoC0bLYJKPEHPUJ8MeAa51l\n github.com/Djarvur/go-err113 v0.1.0/go.mod h1:4UJr5HIiMZrwgkSPdsjy2uOQExX/WEILpIrO9UPGuXs=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0 h1:sATXp1x6/axKxz2Gjxv8MALP0bXaNRfQinEwyfMcx8c=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0/go.mod h1:Nl76DrGNJTA1KJ0LePKBw/vznBX1EHbAZX8mwjR82nI=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9 h1:1ltqoej5GtaWF8jaiA49HwsZD459jqm9YFz9ZtMFpQA=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9/go.mod h1:7uhhqiBaR4CpN0k9rMjOtjpcfGd6DG2m04zQxKnWQ0I=\n github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\n github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\n github.com/Masterminds/semver v1.5.0 h1:H65muMkzWKEuNDnfl9d70GUjFniHKHRbFPGBuZ3QEww=\n@@ -1218,8 +1220,8 @@ golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n-golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=\n-golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=\n+golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes #16027\n\n---\n\nChoice A:\nipn/auditlog/extension.go\n@@ -22,7 +22,7 @@ import (\n )\n \n // featureName is the name of the feature implemented by this package.\n-// It is also the the [extension] name and the log prefix.\n+// It is also the [extension] name and the log prefix.\n const featureName = \"auditlog\"\n \n func init() {\n---\n\n\n---\n\nChoice B:\ncmd/natc/ippool/consensusippool.go\n@@ -10,6 +10,8 @@ import (\n \t\"fmt\"\n \t\"log\"\n \t\"net/netip\"\n+\t\"os\"\n+\t\"path/filepath\"\n \t\"time\"\n \n \t\"github.com/hashicorp/raft\"\n@@ -150,9 +152,14 @@ func (ipp *ConsensusIPPool) domainLookup(from tailcfg.NodeID, addr netip.Addr) (\n }\n \n // StartConsensus is part of the IPPool interface. It starts the raft background routines that handle consensus.\n-func (ipp *ConsensusIPPool) StartConsensus(ctx context.Context, ts *tsnet.Server, clusterTag string) error {\n+func (ipp *ConsensusIPPool) StartConsensus(ctx context.Context, ts *tsnet.Server, clusterTag string, clusterStateDir string) error {\n \tcfg := tsconsensus.DefaultConfig()\n \tcfg.ServeDebugMonitor = true\n+\tvar err error\n+\tcfg.StateDirPath, err = getStatePath(clusterStateDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tcns, err := tsconsensus.Start(ctx, ts, ipp, clusterTag, cfg)\n \tif err != nil {\n \t\treturn err\n@@ -204,6 +211,30 @@ func (ps *consensusPerPeerState) unusedIPV4(ipset *netipx.IPSet, reuseDeadline t\n \treturn netip.Addr{}, false, \"\", errors.New(\"ip pool exhausted\")\n }\n \n+func getStatePath(pathFromFlag string) (string, error) {\n+\tvar dirPath string\n+\tif pathFromFlag != \"\" {\n+\t\tdirPath = pathFromFlag\n+\t} else {\n+\t\tconfDir, err := os.UserConfigDir()\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tdirPath = filepath.Join(confDir, \"nat-connector-cluster-state\")\n+\t}\n+\n+\tif err := os.MkdirAll(dirPath, 0700); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif fi, err := os.Stat(dirPath); err != nil {\n+\t\treturn \"\", err\n+\t} else if !fi.IsDir() {\n+\t\treturn \"\", fmt.Errorf(\"%v is not a directory\", dirPath)\n+\t}\n+\n+\treturn dirPath, nil\n+}\n+\n // isCloseToExpiry returns true if the lastUsed and now times are more than\n // half the lifetime apart\n func isCloseToExpiry(lastUsed, now time.Time, lifetime time.Duration) bool {\n---\ncmd/natc/natc.go\n@@ -59,6 +59,7 @@ func main() {\n \t\twgPort          = fs.Uint(\"wg-port\", 0, \"udp port for wireguard and peer to peer traffic\")\n \t\tclusterTag      = fs.String(\"cluster-tag\", \"\", \"optionally run in a consensus cluster with other nodes with this tag\")\n \t\tserver          = fs.String(\"login-server\", ipn.DefaultControlURL, \"the base URL of control server\")\n+\t\tclusterStateDir = fs.String(\"cluster-state-dir\", \"\", \"path to directory in which to store raft state\")\n \t)\n \tff.Parse(fs, os.Args[1:], ff.WithEnvVarPrefix(\"TS_NATC\"))\n \n@@ -155,7 +156,7 @@ func main() {\n \tvar ipp ippool.IPPool\n \tif *clusterTag != \"\" {\n \t\tcipp := ippool.NewConsensusIPPool(addrPool)\n-\t\terr = cipp.StartConsensus(ctx, ts, *clusterTag)\n+\t\terr = cipp.StartConsensus(ctx, ts, *clusterTag, *clusterStateDir)\n \t\tif err != nil {\n \t\t\tlog.Fatalf(\"StartConsensus: %v\", err)\n \t\t}\n---\n\n\n---\n\nChoice C:\ncmd/tailscale/cli/file.go\n@@ -15,8 +15,10 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"os\"\n+\t\"os/user\"\n \t\"path\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"sync/atomic\"\n \t\"time\"\n@@ -452,6 +454,7 @@ var fileGetCmd = &ffcli.Command{\n \toverwrite:  overwrite existing file\n \trename:     write to a new number-suffixed filename`)\n \t\tffcomplete.Flag(fs, \"conflict\", ffcomplete.Fixed(\"skip\", \"overwrite\", \"rename\"))\n+\t\tfs.StringVar(&getArgs.chown, \"chown\", \"\", \"sets owner:group for received files\")\n \t\treturn fs\n \t})(),\n }\n@@ -461,6 +464,7 @@ var getArgs = struct {\n \tloop     bool\n \tverbose  bool\n \tconflict onConflict\n+\tchown    string\n }{conflict: skipOnExist}\n \n func numberedFileName(dir, name string, i int) string {\n@@ -512,7 +516,7 @@ func openFileOrSubstitute(dir, base string, action onConflict) (*os.File, error)\n \t}\n }\n \n-func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targetFile string, size int64, err error) {\n+func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string, chown string) (targetFile string, size int64, err error) {\n \trc, size, err := localClient.GetWaitingFile(ctx, wf.Name)\n \tif err != nil {\n \t\treturn \"\", 0, fmt.Errorf(\"opening inbox file %q: %w\", wf.Name, err)\n@@ -531,10 +535,51 @@ func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targe\n \t\tf.Close()\n \t\treturn \"\", 0, fmt.Errorf(\"failed to write %v: %v\", f.Name(), err)\n \t}\n+\tif chown != \"\" {\n+\t\tusr, grp, _ := strings.Cut(chown, \":\")\n+\n+\t\t// Set default values to allow for partial changes (e.g. `user` or `:staff`)\n+\t\tuid, gid, err := fileStat(f)\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to stat file: %v\", err)\n+\t\t}\n+\n+\t\tif usr != \"\" {\n+\t\t\tif uid, err = strconv.Atoi(usr); err != nil {\n+\t\t\t\tuser, err := user.Lookup(usr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup user: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif uid, err = strconv.Atoi(user.Uid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert uid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif grp != \"\" {\n+\t\t\tif gid, err = strconv.Atoi(grp); err != nil {\n+\t\t\t\tgroup, err := user.LookupGroup(grp)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup group: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif gid, err = strconv.Atoi(group.Gid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert gid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif err := f.Chown(uid, gid); err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to chown file: %v\", err)\n+\t\t}\n+\t}\n \treturn f.Name(), size, f.Close()\n }\n \n-func runFileGetOneBatch(ctx context.Context, dir string) []error {\n+func runFileGetOneBatch(ctx context.Context, dir, chown string) []error {\n \tvar wfs []apitype.WaitingFile\n \tvar err error\n \tvar errs []error\n@@ -563,7 +608,7 @@ func runFileGetOneBatch(ctx context.Context, dir string) []error {\n \t\t\terrs = append(errs, fmt.Errorf(\"too many errors in runFileGetOneBatch(). %d files unexamined\", len(wfs)-i))\n \t\t\tbreak\n \t\t}\n-\t\twrittenFile, size, err := receiveFile(ctx, wf, dir)\n+\t\twrittenFile, size, err := receiveFile(ctx, wf, dir, chown)\n \t\tif err != nil {\n \t\t\terrs = append(errs, err)\n \t\t\tcontinue\n@@ -602,7 +647,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t}\n \tif getArgs.loop {\n \t\tfor {\n-\t\t\terrs := runFileGetOneBatch(ctx, dir)\n+\t\t\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \t\t\tfor _, err := range errs {\n \t\t\t\toutln(err)\n \t\t\t}\n@@ -621,7 +666,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t\t\t}\n \t\t}\n \t}\n-\terrs := runFileGetOneBatch(ctx, dir)\n+\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \tif len(errs) == 0 {\n \t\treturn nil\n \t}\n@@ -635,6 +680,9 @@ func wipeInbox(ctx context.Context) error {\n \tif getArgs.wait {\n \t\treturn errors.New(\"can't use --wait with /dev/null target\")\n \t}\n+\tif getArgs.chown != \"\" {\n+\t\treturn errors.New(\"can't use --chown with /dev/null target\")\n+\t}\n \twfs, err := localClient.WaitingFiles(ctx)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting WaitingFiles: %w\", err)\n---\ncmd/tailscale/cli/file_stub.go\n@@ -0,0 +1,16 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build windows || wasm || plan9 || tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(_f *os.File) (int, int, error) {\n+\treturn -1, -1, errors.New(\"Not implemented\")\n+}\n---\ncmd/tailscale/cli/file_unix.go\n@@ -0,0 +1,26 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build !windows && !wasm && !plan9 && !tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(f *os.File) (int, int, error) {\n+\tif f == nil {\n+\t\treturn -1, -1, errors.New(\"file cannot be nil\")\n+\t}\n+\n+\tvar stat syscall.Stat_t\n+\tif err := syscall.Stat(f.Name(), &stat); err != nil {\n+\t\treturn -1, -1, err\n+\t}\n+\n+\treturn int(stat.Uid), int(stat.Gid), nil\n+}\n---\n\n\n---\n\nChoice D:\nwgengine/userspace.go\n@@ -1580,6 +1580,12 @@ type fwdDNSLinkSelector struct {\n }\n \n func (ls fwdDNSLinkSelector) PickLink(ip netip.Addr) (linkName string) {\n+\t// sandboxed macOS does not automatically bind to the loopback interface so\n+\t// we must be explicit about it.\n+\tif runtime.GOOS == \"darwin\" && ip.IsLoopback() {\n+\t\treturn \"lo0\"\n+\t}\n+\n \tif ls.ue.isDNSIPOverTailscale.Load()(ip) {\n \t\treturn ls.tunName\n \t}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/corp#27759\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -3289,14 +3289,24 @@ func (b *LocalBackend) popBrowserAuthNow(url string, keyExpired bool, recipient\n //\n // b.mu must *not* be held.\n func (b *LocalBackend) validPopBrowserURL(urlStr string) bool {\n+\tb.mu.Lock()\n+\tdefer b.mu.Unlock()\n+\treturn b.validPopBrowserURLLocked(urlStr)\n+}\n+\n+// validPopBrowserURLLocked reports whether urlStr is a valid value for a\n+// control server to send in a *URL field.\n+//\n+// b.mu must be held.\n+func (b *LocalBackend) validPopBrowserURLLocked(urlStr string) bool {\n \tif urlStr == \"\" {\n \t\treturn false\n \t}\n \tu, err := url.Parse(urlStr)\n \tif err != nil {\n \t\treturn false\n \t}\n-\tserverURL := b.Prefs().ControlURLOrDefault()\n+\tserverURL := b.sanitizedPrefsLocked().ControlURLOrDefault()\n \tif ipn.IsLoginServerSynonym(serverURL) {\n \t\t// When connected to the official Tailscale control plane, only allow\n \t\t// URLs from tailscale.com or its subdomains.\n@@ -5830,7 +5840,7 @@ func (b *LocalBackend) setNetMapLocked(nm *netmap.NetworkMap) {\n \tif nm != nil {\n \t\tmessages := make(map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage)\n \t\tfor id, msg := range nm.DisplayMessages {\n-\t\t\tif msg.PrimaryAction != nil && !b.validPopBrowserURL(msg.PrimaryAction.URL) {\n+\t\t\tif msg.PrimaryAction != nil && !b.validPopBrowserURLLocked(msg.PrimaryAction.URL) {\n \t\t\t\tmsg.PrimaryAction = nil\n \t\t\t}\n \t\t\tmessages[id] = msg\n---\nipn/ipnlocal/local_test.go\n@@ -5374,6 +5374,7 @@ func TestDisplayMessagesURLFilter(t *testing.T) {\n \tht.SetIPNState(\"NeedsLogin\", true)\n \tht.GotStreamedMapResponse()\n \n+\tdefer b.lockAndGetUnlock()()\n \tb.setNetMapLocked(&netmap.NetworkMap{\n \t\tDisplayMessages: map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n \t\t\t\"test-message\": {\n---\n\n\n---\n\nChoice B:\nhealth/health.go\n@@ -1054,13 +1054,18 @@ func (t *Tracker) stringsLocked() []string {\n \n \twarnLen := len(result)\n \tfor _, c := range t.controlMessages {\n+\t\tvar msg string\n \t\tif c.Title != \"\" && c.Text != \"\" {\n-\t\t\tresult = append(result, c.Title+\": \"+c.Text)\n+\t\t\tmsg = c.Title + \": \" + c.Text\n \t\t} else if c.Title != \"\" {\n-\t\t\tresult = append(result, c.Title)\n+\t\t\tmsg = c.Title + \".\"\n \t\t} else if c.Text != \"\" {\n-\t\t\tresult = append(result, c.Text)\n+\t\t\tmsg = c.Text\n \t\t}\n+\t\tif c.PrimaryAction != nil {\n+\t\t\tmsg = msg + \" \" + c.PrimaryAction.Label + \": \" + c.PrimaryAction.URL\n+\t\t}\n+\t\tresult = append(result, msg)\n \t}\n \tsort.Strings(result[warnLen:])\n \n---\nhealth/health_test.go\n@@ -467,29 +467,48 @@ func TestControlHealth(t *testing.T) {\n \tbaseWarns := ht.CurrentState().Warnings\n \tbaseStrs := ht.Strings()\n \n-\tht.SetControlHealth(map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n+\tmsgs := map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n \t\t\"control-health-test\": {\n \t\t\tTitle: \"Control health message\",\n-\t\t\tText:  \"Extra help\",\n+\t\t\tText:  \"Extra help.\",\n \t\t},\n \t\t\"control-health-title\": {\n \t\t\tTitle: \"Control health title only\",\n \t\t},\n-\t})\n+\t\t\"control-health-with-action\": {\n+\t\t\tTitle: \"Control health message\",\n+\t\t\tText:  \"Extra help.\",\n+\t\t\tPrimaryAction: &tailcfg.DisplayMessageAction{\n+\t\t\t\tURL:   \"http://www.example.com\",\n+\t\t\t\tLabel: \"Learn more\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\tht.SetControlHealth(msgs)\n \n \tt.Run(\"Warnings\", func(t *testing.T) {\n \t\twantWarns := map[WarnableCode]UnhealthyState{\n \t\t\t\"control-health-test\": {\n \t\t\t\tWarnableCode: \"control-health-test\",\n \t\t\t\tSeverity:     SeverityMedium,\n \t\t\t\tTitle:        \"Control health message\",\n-\t\t\t\tText:         \"Extra help\",\n+\t\t\t\tText:         \"Extra help.\",\n \t\t\t},\n \t\t\t\"control-health-title\": {\n \t\t\t\tWarnableCode: \"control-health-title\",\n \t\t\t\tSeverity:     SeverityMedium,\n \t\t\t\tTitle:        \"Control health title only\",\n \t\t\t},\n+\t\t\t\"control-health-with-action\": {\n+\t\t\t\tWarnableCode: \"control-health-with-action\",\n+\t\t\t\tSeverity:     SeverityMedium,\n+\t\t\t\tTitle:        \"Control health message\",\n+\t\t\t\tText:         \"Extra help.\",\n+\t\t\t\tPrimaryAction: &UnhealthyStateAction{\n+\t\t\t\t\tURL:   \"http://www.example.com\",\n+\t\t\t\t\tLabel: \"Learn more\",\n+\t\t\t\t},\n+\t\t\t},\n \t\t}\n \t\tstate := ht.CurrentState()\n \t\tgotWarns := maps.Clone(state.Warnings)\n@@ -505,8 +524,9 @@ func TestControlHealth(t *testing.T) {\n \n \tt.Run(\"Strings()\", func(t *testing.T) {\n \t\twantStrs := []string{\n-\t\t\t\"Control health message: Extra help\",\n-\t\t\t\"Control health title only\",\n+\t\t\t\"Control health message: Extra help.\",\n+\t\t\t\"Control health message: Extra help. Learn more: http://www.example.com\",\n+\t\t\t\"Control health title only.\",\n \t\t}\n \t\tvar gotStrs []string\n \t\tfor _, s := range ht.Strings() {\n@@ -527,8 +547,7 @@ func TestControlHealth(t *testing.T) {\n \t\t\tType: MetricLabelWarning,\n \t\t}).String()\n \t\twant := strconv.Itoa(\n-\t\t\t2 + // from SetControlHealth\n-\t\t\t\tlen(baseStrs),\n+\t\t\tlen(msgs) + len(baseStrs),\n \t\t)\n \t\tif got != want {\n \t\t\tt.Errorf(\"metricsHealthMessage.Get(warning) = %q, want %q\", got, want)\n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -49,7 +49,7 @@ jobs:\n \n     # Install a more recent Go that understands modern go.mod content.\n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n \n---\n.github/workflows/golangci-lint.yml\n@@ -25,7 +25,7 @@ jobs:\n     steps:\n       - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n-      - uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      - uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n         with:\n           go-version-file: go.mod\n           cache: false\n---\n.github/workflows/test.yml\n@@ -151,7 +151,7 @@ jobs:\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n         cache: false\n---\n\n\n---\n\nChoice D:\ncmd/k8s-operator/ingress.go\n@@ -292,9 +292,15 @@ func validateIngressClass(ctx context.Context, cl client.Client) error {\n \n func handlersForIngress(ctx context.Context, ing *networkingv1.Ingress, cl client.Client, rec record.EventRecorder, tlsHost string, logger *zap.SugaredLogger) (handlers map[string]*ipn.HTTPHandler, err error) {\n \taddIngressBackend := func(b *networkingv1.IngressBackend, path string) {\n+\t\tif path == \"\" {\n+\t\t\tpath = \"/\"\n+\t\t\trec.Eventf(ing, corev1.EventTypeNormal, \"PathUndefined\", \"configured backend is missing a path, defaulting to '/'\")\n+\t\t}\n+\n \t\tif b == nil {\n \t\t\treturn\n \t\t}\n+\n \t\tif b.Service == nil {\n \t\t\trec.Eventf(ing, corev1.EventTypeWarning, \"InvalidIngressBackend\", \"backend for path %q is missing service\", path)\n \t\t\treturn\n---\ncmd/k8s-operator/ingress_test.go\n@@ -16,6 +16,7 @@ import (\n \tapiextensionsv1 \"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1\"\n \tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \t\"k8s.io/apimachinery/pkg/types\"\n+\t\"k8s.io/client-go/tools/record\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n \t\"tailscale.com/ipn\"\n@@ -487,6 +488,138 @@ func TestIngressLetsEncryptStaging(t *testing.T) {\n \t}\n }\n \n+func TestEmptyPath(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname           string\n+\t\tpaths          []networkingv1.HTTPIngressPath\n+\t\texpectedEvents []string\n+\t}{\n+\t\t{\n+\t\t\tname: \"empty_path_with_prefix_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypePrefix),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty_path_with_implementation_specific_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty_path_with_exact_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeExact),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Warning UnsupportedPathTypeExact Exact path type strict matching is currently not supported and requests will be routed as for Prefix path type. This behaviour might change in the future.\",\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"two_competing_but_not_identical_paths_including_one_empty\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"/\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range testCases {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfc := fake.NewFakeClient(ingressClass())\n+\t\t\tft := &fakeTSClient{}\n+\t\t\tfr := record.NewFakeRecorder(3) // bump this if you expect a test case to throw more events\n+\t\t\tfakeTsnetServer := &fakeTSNetServer{certDomains: []string{\"foo.com\"}}\n+\t\t\tzl, err := zap.NewDevelopment()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tingR := &IngressReconciler{\n+\t\t\t\trecorder: fr,\n+\t\t\t\tClient:   fc,\n+\t\t\t\tssr: &tailscaleSTSReconciler{\n+\t\t\t\t\tClient:            fc,\n+\t\t\t\t\ttsClient:          ft,\n+\t\t\t\t\ttsnetServer:       fakeTsnetServer,\n+\t\t\t\t\tdefaultTags:       []string{\"tag:k8s\"},\n+\t\t\t\t\toperatorNamespace: \"operator-ns\",\n+\t\t\t\t\tproxyImage:        \"tailscale/tailscale\",\n+\t\t\t\t},\n+\t\t\t\tlogger: zl.Sugar(),\n+\t\t\t}\n+\n+\t\t\t// 1. Resources get created for regular Ingress\n+\t\t\tmustCreate(t, fc, ingressWithPaths(tt.paths))\n+\t\t\tmustCreate(t, fc, service())\n+\n+\t\t\texpectReconciled(t, ingR, \"default\", \"test\")\n+\n+\t\t\tfullName, shortName := findGenName(t, fc, \"default\", \"test\", \"ingress\")\n+\t\t\tmustCreate(t, fc, &corev1.Pod{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tName:      fullName,\n+\t\t\t\t\tNamespace: \"operator-ns\",\n+\t\t\t\t\tUID:       \"test-uid\",\n+\t\t\t\t},\n+\t\t\t})\n+\t\t\topts := configOpts{\n+\t\t\t\tstsName:    shortName,\n+\t\t\t\tsecretName: fullName,\n+\t\t\t\tnamespace:  \"default\",\n+\t\t\t\tparentType: \"ingress\",\n+\t\t\t\thostname:   \"foo\",\n+\t\t\t\tapp:        kubetypes.AppIngressResource,\n+\t\t\t}\n+\t\t\tserveConfig := &ipn.ServeConfig{\n+\t\t\t\tTCP: map[uint16]*ipn.TCPPortHandler{443: {HTTPS: true}},\n+\t\t\t\tWeb: map[ipn.HostPort]*ipn.WebServerConfig{\"${TS_CERT_DOMAIN}:443\": {Handlers: map[string]*ipn.HTTPHandler{\"/\": {Proxy: \"http://1.2.3.4:8080/\"}}}},\n+\t\t\t}\n+\t\t\topts.serveConfig = serveConfig\n+\n+\t\t\texpectEqual(t, fc, expectedSecret(t, fc, opts))\n+\t\t\texpectEqual(t, fc, expectedHeadlessService(shortName, \"ingress\"))\n+\t\t\texpectEqual(t, fc, expectedSTSUserspace(t, fc, opts), removeHashAnnotation, removeResourceReqs)\n+\n+\t\t\texpectEvents(t, fr, tt.expectedEvents)\n+\t\t})\n+\t}\n+}\n+\n+// ptrPathType is a helper function to return a pointer to the pathtype string (required for TestEmptyPath)\n+func ptrPathType(p networkingv1.PathType) *networkingv1.PathType {\n+\treturn &p\n+}\n+\n func ingressClass() *networkingv1.IngressClass {\n \treturn &networkingv1.IngressClass{\n \t\tObjectMeta: metav1.ObjectMeta{Name: \"tailscale\"},\n@@ -520,16 +653,47 @@ func ingress() *networkingv1.Ingress {\n \t\t},\n \t\tSpec: networkingv1.IngressSpec{\n \t\t\tIngressClassName: ptr.To(\"tailscale\"),\n-\t\t\tDefaultBackend: &networkingv1.IngressBackend{\n-\t\t\t\tService: &networkingv1.IngressServiceBackend{\n-\t\t\t\t\tName: \"test\",\n-\t\t\t\t\tPort: networkingv1.ServiceBackendPort{\n-\t\t\t\t\t\tNumber: 8080,\n+\t\t\tDefaultBackend:   backend(),\n+\t\t\tTLS: []networkingv1.IngressTLS{\n+\t\t\t\t{Hosts: []string{\"default-test\"}},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func ingressWithPaths(paths []networkingv1.HTTPIngressPath) *networkingv1.Ingress {\n+\treturn &networkingv1.Ingress{\n+\t\tTypeMeta: metav1.TypeMeta{Kind: \"Ingress\", APIVersion: \"networking.k8s.io/v1\"},\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      \"test\",\n+\t\t\tNamespace: \"default\",\n+\t\t\tUID:       types.UID(\"1234-UID\"),\n+\t\t},\n+\t\tSpec: networkingv1.IngressSpec{\n+\t\t\tIngressClassName: ptr.To(\"tailscale\"),\n+\t\t\tRules: []networkingv1.IngressRule{\n+\t\t\t\t{\n+\t\t\t\t\tHost: \"foo.tailnetxyz.ts.net\",\n+\t\t\t\t\tIngressRuleValue: networkingv1.IngressRuleValue{\n+\t\t\t\t\t\tHTTP: &networkingv1.HTTPIngressRuleValue{\n+\t\t\t\t\t\t\tPaths: paths,\n+\t\t\t\t\t\t},\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n \t\t\tTLS: []networkingv1.IngressTLS{\n-\t\t\t\t{Hosts: []string{\"default-test\"}},\n+\t\t\t\t{Hosts: []string{\"foo.tailnetxyz.ts.net\"}},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func backend() *networkingv1.IngressBackend {\n+\treturn &networkingv1.IngressBackend{\n+\t\tService: &networkingv1.IngressServiceBackend{\n+\t\t\tName: \"test\",\n+\t\t\tPort: networkingv1.ServiceBackendPort{\n+\t\t\t\tNumber: 8080,\n \t\t\t},\n \t\t},\n \t}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAdds missing `AttrConfig` field to `ACLDetails` struct to expose attribute configuration functionality already present in the internal policy package. \n\n---\n\nChoice A:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n---\n\n\n---\n\nChoice B:\nclient/tailscale/acl.go\n@@ -50,6 +50,18 @@ type NodeAttrGrant struct {\n \tAttr []string `json:\"attr,omitempty\"`\n }\n \n+// ACLAttrConfig defines the configuration for a custom attribute.\n+type ACLAttrConfig struct {\n+\t// Type specifies the attribute type. Valid values: \"string\", \"number\", \"bool\".\n+\tType string `json:\"type,omitempty\"`\n+\n+\t// AllowSetByNode allows nodes to set this attribute themselves.\n+\tAllowSetByNode bool `json:\"allowSetByNode,omitempty\"`\n+\n+\t// BroadcastToPeers lists target nodes to receive this attribute value.\n+\tBroadcastToPeers []string `json:\"broadcastToPeers,omitempty\"`\n+}\n+\n // ACLDetails contains all the details for an ACL.\n type ACLDetails struct {\n \tTests     []ACLTest           `json:\"tests,omitempty\"`\n@@ -58,6 +70,9 @@ type ACLDetails struct {\n \tTagOwners map[string][]string `json:\"tagowners,omitempty\"`\n \tHosts     map[string]string   `json:\"hosts,omitempty\"`\n \tNodeAttrs []NodeAttrGrant     `json:\"nodeAttrs,omitempty\"`\n+\n+\t// AttrConfig maps attribute names to their configuration.\n+\tAttrConfig map[string]ACLAttrConfig `json:\"attrConfig,omitempty\"`\n }\n \n // ACL contains an ACLDetails and metadata.\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/c2n.go\n@@ -240,13 +240,14 @@ func handleC2NAppConnectorDomainRoutesGet(b *LocalBackend, w http.ResponseWriter\n \tb.logf(\"c2n: GET /appconnector/routes received\")\n \n \tvar res tailcfg.C2NAppConnectorDomainRoutesResponse\n-\tif b.appConnector == nil {\n+\tappConnector := b.AppConnector()\n+\tif appConnector == nil {\n \t\tw.Header().Set(\"Content-Type\", \"application/json\")\n \t\tjson.NewEncoder(w).Encode(res)\n \t\treturn\n \t}\n \n-\tres.Domains = b.appConnector.DomainRoutes()\n+\tres.Domains = appConnector.DomainRoutes()\n \n \tw.Header().Set(\"Content-Type\", \"application/json\")\n \tjson.NewEncoder(w).Encode(res)\n---\nipn/ipnlocal/local.go\n@@ -4150,8 +4150,8 @@ func (b *LocalBackend) SetUseExitNodeEnabled(v bool) (ipn.PrefsView, error) {\n // AdvertiseRoutes has been set in the MaskedPrefs.\n func (b *LocalBackend) MaybeClearAppConnector(mp *ipn.MaskedPrefs) error {\n \tvar err error\n-\tif b.appConnector != nil && mp.AdvertiseRoutesSet {\n-\t\terr = b.appConnector.ClearRoutes()\n+\tif ac := b.AppConnector(); ac != nil && mp.AdvertiseRoutesSet {\n+\t\terr = ac.ClearRoutes()\n \t\tif err != nil {\n \t\t\tb.logf(\"appc: clear routes error: %v\", err)\n \t\t}\n@@ -4755,9 +4755,7 @@ func (b *LocalBackend) readvertiseAppConnectorRoutes() {\n \t//\n \t// Grab a copy of the field, since b.mu only guards access to the\n \t// b.appConnector field itself.\n-\tb.mu.Lock()\n-\tappConnector := b.appConnector\n-\tb.mu.Unlock()\n+\tappConnector := b.AppConnector()\n \n \tif appConnector == nil {\n \t\treturn\n@@ -6432,6 +6430,15 @@ func (b *LocalBackend) OfferingAppConnector() bool {\n \treturn b.appConnector != nil\n }\n \n+// AppConnector returns the current AppConnector, or nil if not configured.\n+//\n+// TODO(nickkhyl): move app connectors to [nodeBackend], or perhaps a feature package?\n+func (b *LocalBackend) AppConnector() *appc.AppConnector {\n+\tb.mu.Lock()\n+\tdefer b.mu.Unlock()\n+\treturn b.appConnector\n+}\n+\n // allowExitNodeDNSProxyToServeName reports whether the Exit Node DNS\n // proxy is allowed to serve responses for the provided DNS name.\n func (b *LocalBackend) allowExitNodeDNSProxyToServeName(name string) bool {\n---\n\n\n---\n\nChoice D:\ngo.toolchain.rev\n@@ -1 +1 @@\n-982da8f24fa0504f2214f24b0d68b2febd5983f8\n+98e8c99c256a5aeaa13725d2e43fdd7f465ba200\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/corp#27759\n\n---\n\nChoice A:\nbuild_docker.sh\n@@ -16,7 +16,7 @@ eval \"$(./build_dist.sh shellvars)\"\n \n DEFAULT_TARGET=\"client\"\n DEFAULT_TAGS=\"v${VERSION_SHORT},v${VERSION_MINOR}\"\n-DEFAULT_BASE=\"tailscale/alpine-base:3.18\"\n+DEFAULT_BASE=\"tailscale/alpine-base:3.19\"\n # Set a few pre-defined OCI annotations. The source annotation is used by tools such as Renovate that scan the linked\n # Github repo to find release notes for any new image tags. Note that for official Tailscale images the default\n # annotations defined here will be overriden by release scripts that call this script.\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -3289,14 +3289,24 @@ func (b *LocalBackend) popBrowserAuthNow(url string, keyExpired bool, recipient\n //\n // b.mu must *not* be held.\n func (b *LocalBackend) validPopBrowserURL(urlStr string) bool {\n+\tb.mu.Lock()\n+\tdefer b.mu.Unlock()\n+\treturn b.validPopBrowserURLLocked(urlStr)\n+}\n+\n+// validPopBrowserURLLocked reports whether urlStr is a valid value for a\n+// control server to send in a *URL field.\n+//\n+// b.mu must be held.\n+func (b *LocalBackend) validPopBrowserURLLocked(urlStr string) bool {\n \tif urlStr == \"\" {\n \t\treturn false\n \t}\n \tu, err := url.Parse(urlStr)\n \tif err != nil {\n \t\treturn false\n \t}\n-\tserverURL := b.Prefs().ControlURLOrDefault()\n+\tserverURL := b.sanitizedPrefsLocked().ControlURLOrDefault()\n \tif ipn.IsLoginServerSynonym(serverURL) {\n \t\t// When connected to the official Tailscale control plane, only allow\n \t\t// URLs from tailscale.com or its subdomains.\n@@ -5830,7 +5840,7 @@ func (b *LocalBackend) setNetMapLocked(nm *netmap.NetworkMap) {\n \tif nm != nil {\n \t\tmessages := make(map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage)\n \t\tfor id, msg := range nm.DisplayMessages {\n-\t\t\tif msg.PrimaryAction != nil && !b.validPopBrowserURL(msg.PrimaryAction.URL) {\n+\t\t\tif msg.PrimaryAction != nil && !b.validPopBrowserURLLocked(msg.PrimaryAction.URL) {\n \t\t\t\tmsg.PrimaryAction = nil\n \t\t\t}\n \t\t\tmessages[id] = msg\n---\nipn/ipnlocal/local_test.go\n@@ -5374,6 +5374,7 @@ func TestDisplayMessagesURLFilter(t *testing.T) {\n \tht.SetIPNState(\"NeedsLogin\", true)\n \tht.GotStreamedMapResponse()\n \n+\tdefer b.lockAndGetUnlock()()\n \tb.setNetMapLocked(&netmap.NetworkMap{\n \t\tDisplayMessages: map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n \t\t\t\"test-message\": {\n---\n\n\n---\n\nChoice C:\ncmd/tailscale/cli/cli.go\n@@ -207,6 +207,8 @@ func noDupFlagify(c *ffcli.Command) {\n \t}\n }\n \n+var fileCmd func() *ffcli.Command\n+\n func newRootCmd() *ffcli.Command {\n \trootfs := newFlagSet(\"tailscale\")\n \trootfs.Func(\"socket\", \"path to tailscaled socket\", func(s string) error {\n@@ -247,7 +249,7 @@ change in the future.\n \t\t\tserveCmd(),\n \t\t\tversionCmd,\n \t\t\twebCmd,\n-\t\t\tfileCmd,\n+\t\t\tnilOrCall(fileCmd),\n \t\t\tbugReportCmd,\n \t\t\tcertCmd,\n \t\t\tnetlockCmd,\n@@ -286,6 +288,13 @@ func nonNilCmds(cmds ...*ffcli.Command) []*ffcli.Command {\n \treturn slicesx.AppendNonzero(cmds[:0], cmds)\n }\n \n+func nilOrCall(f func() *ffcli.Command) *ffcli.Command {\n+\tif f == nil {\n+\t\treturn nil\n+\t}\n+\treturn f()\n+}\n+\n func fatalf(format string, a ...any) {\n \tif Fatalf != nil {\n \t\tFatalf(format, a...)\n---\ncmd/tailscale/cli/file.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !ts_omit_taildrop\n+\n package cli\n \n import (\n@@ -38,14 +40,20 @@ import (\n \t\"tailscale.com/version\"\n )\n \n-var fileCmd = &ffcli.Command{\n-\tName:       \"file\",\n-\tShortUsage: \"tailscale file <cp|get> ...\",\n-\tShortHelp:  \"Send or receive files\",\n-\tSubcommands: []*ffcli.Command{\n-\t\tfileCpCmd,\n-\t\tfileGetCmd,\n-\t},\n+func init() {\n+\tfileCmd = getFileCmd\n+}\n+\n+func getFileCmd() *ffcli.Command {\n+\treturn &ffcli.Command{\n+\t\tName:       \"file\",\n+\t\tShortUsage: \"tailscale file <cp|get> ...\",\n+\t\tShortHelp:  \"Send or receive files\",\n+\t\tSubcommands: []*ffcli.Command{\n+\t\t\tfileCpCmd,\n+\t\t\tfileGetCmd,\n+\t\t},\n+\t}\n }\n \n type countingReader struct {\n---\n\n\n---\n\nChoice D:\nipn/localapi/localapi.go\n@@ -397,6 +397,15 @@ func (h *Handler) serveBugReport(w http.ResponseWriter, r *http.Request) {\n \t// OS-specific details\n \th.logf.JSON(1, \"UserBugReportOS\", osdiag.SupportInfo(osdiag.LogSupportInfoReasonBugReport))\n \n+\t// Tailnet lock details\n+\tst := h.b.NetworkLockStatus()\n+\tif st.Enabled {\n+\t\th.logf.JSON(1, \"UserBugReportTailnetLockStatus\", st)\n+\t\tif st.NodeKeySignature != nil {\n+\t\t\th.logf(\"user bugreport tailnet lock signature: %s\", st.NodeKeySignature.String())\n+\t\t}\n+\t}\n+\n \tif defBool(r.URL.Query().Get(\"diagnose\"), false) {\n \t\th.b.Doctor(r.Context(), logger.WithPrefix(h.logf, \"diag: \"))\n \t}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #16010\n\n---\n\nChoice A:\nposture/serialnumber_stub.go\n@@ -1,13 +1,12 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-// android: not implemented\n // js: not implemented\n // plan9: not implemented\n // solaris: currently unsupported by go-smbios:\n // https://github.com/digitalocean/go-smbios/pull/21\n \n-//go:build android || solaris || plan9 || js || wasm || tamago || aix || (darwin && !cgo && !ios)\n+//go:build solaris || plan9 || js || wasm || tamago || aix || (darwin && !cgo && !ios)\n \n package posture\n \n---\nposture/serialnumber_syspolicy.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build android || ios\n+\n package posture\n \n import (\n@@ -10,9 +12,9 @@ import (\n \t\"tailscale.com/util/syspolicy\"\n )\n \n-// GetSerialNumbers returns the serial number of the iOS/tvOS device as reported by an\n+// GetSerialNumbers returns the serial number of the device as reported by an\n // MDM solution. It requires configuration via the DeviceSerialNumber system policy.\n-// This is the only way to gather serial numbers on iOS and tvOS.\n+// This is the only way to gather serial numbers on iOS, tvOS and Android.\n func GetSerialNumbers(_ logger.Logf) ([]string, error) {\n \ts, err := syspolicy.GetString(syspolicy.DeviceSerialNumber, \"\")\n \tif err != nil {\n---\nutil/syspolicy/policy_keys.go\n@@ -126,8 +126,8 @@ const (\n \t// The default is \"user-decides\" unless otherwise stated.\n \tPostureChecking Key = \"PostureChecking\"\n \t// DeviceSerialNumber is the serial number of the device that is running Tailscale.\n-\t// This is used on iOS/tvOS to allow IT administrators to manually give us a serial number via MDM.\n-\t// We are unable to programmatically get the serial number from IOKit due to sandboxing restrictions.\n+\t// This is used on Android, iOS and tvOS to allow IT administrators to manually give us a serial number via MDM.\n+\t// We are unable to programmatically get the serial number on mobile due to sandboxing restrictions.\n \tDeviceSerialNumber Key = \"DeviceSerialNumber\"\n \n \t// ManagedByOrganizationName indicates the name of the organization managing the Tailscale\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/extension_host.go\n@@ -25,6 +25,7 @@ import (\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/execqueue\"\n \t\"tailscale.com/util/set\"\n+\t\"tailscale.com/util/slicesx\"\n \t\"tailscale.com/util/testenv\"\n )\n \n@@ -378,7 +379,7 @@ func (h *ExtensionHost) NotifyProfileChange(profile ipn.LoginProfileView, prefs\n \th.currentPrefs = prefs\n \th.currentProfile = profile\n \t// Get the callbacks to be invoked.\n-\tcbs := collectValues(h.profileStateChangeCbs)\n+\tcbs := slicesx.MapValues(h.profileStateChangeCbs)\n \th.mu.Unlock()\n \tfor _, cb := range cbs {\n \t\tcb(profile, prefs, sameNode)\n@@ -402,7 +403,7 @@ func (h *ExtensionHost) NotifyProfilePrefsChanged(profile ipn.LoginProfileView,\n \th.currentPrefs = newPrefs\n \th.currentProfile = profile\n \t// Get the callbacks to be invoked.\n-\tstateCbs := collectValues(h.profileStateChangeCbs)\n+\tstateCbs := slicesx.MapValues(h.profileStateChangeCbs)\n \th.mu.Unlock()\n \tfor _, cb := range stateCbs {\n \t\tcb(profile, newPrefs, true)\n@@ -443,7 +444,7 @@ func (h *ExtensionHost) DetermineBackgroundProfile(profiles ipnext.ProfileStore)\n \t// Attempt to resolve the background profile using the registered\n \t// background profile resolvers (e.g., [ipn/desktop.desktopSessionsExt] on Windows).\n \th.mu.Lock()\n-\tresolvers := collectValues(h.backgroundProfileResolvers)\n+\tresolvers := slicesx.MapValues(h.backgroundProfileResolvers)\n \th.mu.Unlock()\n \tfor _, resolver := range resolvers {\n \t\tif profile := resolver(profiles); profile.Valid() {\n@@ -481,7 +482,7 @@ func (h *ExtensionHost) NotifyNewControlClient(cc controlclient.Client, profile\n \t\treturn nil\n \t}\n \th.mu.Lock()\n-\tcbs := collectValues(h.newControlClientCbs)\n+\tcbs := slicesx.MapValues(h.newControlClientCbs)\n \th.mu.Unlock()\n \tif len(cbs) > 0 {\n \t\tccShutdownCbs = make([]func(), 0, len(cbs))\n@@ -527,7 +528,7 @@ func (h *ExtensionHost) AuditLogger() ipnauth.AuditLogFunc {\n \t}\n \n \th.mu.Lock()\n-\tproviders := collectValues(h.auditLoggers)\n+\tproviders := slicesx.MapValues(h.auditLoggers)\n \th.mu.Unlock()\n \n \tvar loggers []ipnauth.AuditLogFunc\n@@ -642,17 +643,3 @@ type execQueue interface {\n \tShutdown()\n \tWait(context.Context) error\n }\n-\n-// collectValues is like [slices.Collect] of [maps.Values],\n-// but pre-allocates the slice to avoid reallocations.\n-// It returns nil if the map is empty.\n-func collectValues[K comparable, V any](m map[K]V) []V {\n-\tif len(m) == 0 {\n-\t\treturn nil\n-\t}\n-\ts := make([]V, 0, len(m))\n-\tfor _, v := range m {\n-\t\ts = append(s, v)\n-\t}\n-\treturn s\n-}\n---\n\n\n---\n\nChoice C:\nwgengine/netstack/netstack.go\n@@ -327,10 +327,15 @@ func Create(logf logger.Logf, tundev *tstun.Wrapper, e wgengine.Engine, mc *magi\n \tif tcpipErr != nil {\n \t\treturn nil, fmt.Errorf(\"could not disable TCP RACK: %v\", tcpipErr)\n \t}\n-\tcubicOpt := tcpip.CongestionControlOption(\"cubic\")\n-\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &cubicOpt)\n+\t// gVisor defaults to reno at the time of writing. We explicitly set reno\n+\t// congestion control in order to prevent unexpected changes. Netstack\n+\t// has an int overflow in sender congestion window arithmetic that is more\n+\t// prone to trigger with cubic congestion control.\n+\t// See https://github.com/google/gvisor/issues/11632\n+\trenoOpt := tcpip.CongestionControlOption(\"reno\")\n+\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &renoOpt)\n \tif tcpipErr != nil {\n-\t\treturn nil, fmt.Errorf(\"could not set cubic congestion control: %v\", tcpipErr)\n+\t\treturn nil, fmt.Errorf(\"could not set reno congestion control: %v\", tcpipErr)\n \t}\n \terr := setTCPBufSizes(ipstack)\n \tif err != nil {\n---\n\n\n---\n\nChoice D:\nutil/mak/mak.go\n@@ -5,11 +5,6 @@\n // things, notably to maps, but also slices.\n package mak\n \n-import (\n-\t\"fmt\"\n-\t\"reflect\"\n-)\n-\n // Set populates an entry in a map, making the map if necessary.\n //\n // That is, it assigns (*m)[k] = v, making *m if it was nil.\n@@ -20,35 +15,6 @@ func Set[K comparable, V any, T ~map[K]V](m *T, k K, v V) {\n \t(*m)[k] = v\n }\n \n-// NonNil takes a pointer to a Go data structure\n-// (currently only a slice or a map) and makes sure it's non-nil for\n-// JSON serialization. (In particular, JavaScript clients usually want\n-// the field to be defined after they decode the JSON.)\n-//\n-// Deprecated: use NonNilSliceForJSON or NonNilMapForJSON instead.\n-func NonNil(ptr any) {\n-\tif ptr == nil {\n-\t\tpanic(\"nil interface\")\n-\t}\n-\trv := reflect.ValueOf(ptr)\n-\tif rv.Kind() != reflect.Ptr {\n-\t\tpanic(fmt.Sprintf(\"kind %v, not Ptr\", rv.Kind()))\n-\t}\n-\tif rv.Pointer() == 0 {\n-\t\tpanic(\"nil pointer\")\n-\t}\n-\trv = rv.Elem()\n-\tif rv.Pointer() != 0 {\n-\t\treturn\n-\t}\n-\tswitch rv.Type().Kind() {\n-\tcase reflect.Slice:\n-\t\trv.Set(reflect.MakeSlice(rv.Type(), 0, 0))\n-\tcase reflect.Map:\n-\t\trv.Set(reflect.MakeMap(rv.Type()))\n-\t}\n-}\n-\n // NonNilSliceForJSON makes sure that *slicePtr is non-nil so it will\n // won't be omitted from JSON serialization and possibly confuse JavaScript\n // clients expecting it to be present.\n---\nutil/mak/mak_test.go\n@@ -40,35 +40,6 @@ func TestSet(t *testing.T) {\n \t})\n }\n \n-func TestNonNil(t *testing.T) {\n-\tvar s []string\n-\tNonNil(&s)\n-\tif len(s) != 0 {\n-\t\tt.Errorf(\"slice len = %d; want 0\", len(s))\n-\t}\n-\tif s == nil {\n-\t\tt.Error(\"slice still nil\")\n-\t}\n-\n-\ts = append(s, \"foo\")\n-\tNonNil(&s)\n-\tif len(s) != 1 {\n-\t\tt.Errorf(\"len = %d; want 1\", len(s))\n-\t}\n-\tif s[0] != \"foo\" {\n-\t\tt.Errorf(\"value = %q; want foo\", s)\n-\t}\n-\n-\tvar m map[string]string\n-\tNonNil(&m)\n-\tif len(m) != 0 {\n-\t\tt.Errorf(\"map len = %d; want 0\", len(s))\n-\t}\n-\tif m == nil {\n-\t\tt.Error(\"map still nil\")\n-\t}\n-}\n-\n func TestNonNilMapForJSON(t *testing.T) {\n \ttype M map[string]int\n \tvar m M\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis commit fixes the bug that c2n requests are skiped when updating vipServices in serveConfig. This then resulted netmap update being skipped which caused inaccuracy of Capmap info on client side. After this fix, client always inform control about it's vipServices config changes.\r\n\r\nFixes tailscale/corp#29219\n\n---\n\nChoice A:\ncmd/tsidp/README.md\n@@ -35,7 +35,7 @@\n \n    ```bash\n    docker run -d \\\n-     --name `tsidp` \\\n+     --name tsidp \\\n      -p 443:443 \\\n      -e TS_AUTHKEY=YOUR_TAILSCALE_AUTHKEY \\\n      -e TS_HOSTNAME=idp \\\n---\n\n\n---\n\nChoice B:\nprober/tls_test.go\n@@ -252,7 +252,7 @@ func TestCRL(t *testing.T) {\n \t\t\t\"NoCRL\",\n \t\t\tleafCertParsed,\n \t\t\tnil,\n-\t\t\t\"\",\n+\t\t\t\"no CRL server presented in leaf cert for\",\n \t\t},\n \t\t{\n \t\t\t\"NotBeforeCRLStaplingDate\",\n@@ -276,7 +276,7 @@ func TestCRL(t *testing.T) {\n \t\t\t\treturn\n \t\t\t}\n \n-\t\t\tif err == nil || !strings.Contains(err.Error(), tt.wantErr) {\n+\t\t\tif err == nil || tt.wantErr == \"\" || !strings.Contains(err.Error(), tt.wantErr) {\n \t\t\t\tt.Errorf(\"unexpected error %q; want %q\", err, tt.wantErr)\n \t\t\t}\n \t\t})\n---\n\n\n---\n\nChoice C:\nwgengine/magicsock/magicsock.go\n@@ -1625,6 +1625,25 @@ func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey ke\n \t\tc.mu.Unlock()\n \t\treturn false, errConnClosed\n \t}\n+\tvar di *discoInfo\n+\tswitch {\n+\tcase c.peerMap.knownPeerDiscoKey(dstDisco):\n+\t\tdi = c.discoInfoForKnownPeerLocked(dstDisco)\n+\tcase isRelayHandshakeMsg:\n+\t\t// TODO(jwhited): consider caching relay server disco shared keys\n+\t\tdi = &discoInfo{\n+\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n+\t\t}\n+\tdefault:\n+\t\t// This is an attempt to send to an unknown peer that is not a relay\n+\t\t// server. This can happen when a call to the current function, which is\n+\t\t// often via a new goroutine, races with applying a change in the\n+\t\t// netmap, e.g. the associated peer(s) for dstDisco goes away.\n+\t\tc.mu.Unlock()\n+\t\treturn false, errors.New(\"unknown peer\")\n+\t}\n+\tc.mu.Unlock()\n+\n \tpkt := make([]byte, 0, 512) // TODO: size it correctly? pool? if it matters.\n \tif geneveVNI != nil {\n \t\tgh := packet.GeneveHeader{\n@@ -1641,23 +1660,6 @@ func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey ke\n \t}\n \tpkt = append(pkt, disco.Magic...)\n \tpkt = c.discoPublic.AppendTo(pkt)\n-\tvar di *discoInfo\n-\tif !isRelayHandshakeMsg {\n-\t\tdi = c.discoInfoLocked(dstDisco)\n-\t} else {\n-\t\t// c.discoInfoLocked() caches [*discoInfo] for dstDisco. It assumes that\n-\t\t// dstDisco is a known Tailscale peer, and will be cleaned around\n-\t\t// network map changes. In the case of a relay handshake message,\n-\t\t// dstDisco belongs to a relay server with a disco key that is\n-\t\t// discovered at endpoint allocation time or [disco.CallMeMaybeVia]\n-\t\t// reception time. There is no clear ending to its lifetime, so we\n-\t\t// can't cache with the same strategy. Instead, generate the shared\n-\t\t// key on the fly for now.\n-\t\tdi = &discoInfo{\n-\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n-\t\t}\n-\t}\n-\tc.mu.Unlock()\n \n \tif isDERP {\n \t\tmetricSendDiscoDERP.Add(1)\n@@ -1814,7 +1816,7 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t//\n \t// From here on, peerNode and de are non-nil.\n \n-\tdi := c.discoInfoLocked(sender)\n+\tdi := c.discoInfoForKnownPeerLocked(sender)\n \n \tsealedBox := msg[discoHeaderLen:]\n \tpayload, ok := di.sharedKey.Open(sealedBox)\n@@ -2076,10 +2078,15 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \t}\n }\n \n-// discoInfoLocked returns the previous or new discoInfo for k.\n+// discoInfoForKnownPeerLocked returns the previous or new discoInfo for k.\n+//\n+// Callers must only pass key.DiscoPublic's that are present in and\n+// lifetime-managed via [Conn].peerMap. UDP relay server disco keys are discovered\n+// at relay endpoint allocation time or [disco.CallMeMaybeVia] reception time\n+// and therefore must never pass through this method.\n //\n // c.mu must be held.\n-func (c *Conn) discoInfoLocked(k key.DiscoPublic) *discoInfo {\n+func (c *Conn) discoInfoForKnownPeerLocked(k key.DiscoPublic) *discoInfo {\n \tdi, ok := c.discoInfo[k]\n \tif !ok {\n \t\tdi = &discoInfo{\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -6146,17 +6146,17 @@ func (b *LocalBackend) setTCPPortsInterceptedFromNetmapAndPrefsLocked(prefs ipn.\n \t\t}\n \t}\n \n-\t// Update funnel info in hostinfo and kick off control update if needed.\n-\tb.updateIngressLocked()\n+\t// Update funnel and service hash info in hostinfo and kick off control update if needed.\n+\tb.updateIngressAndServiceHashLocked(prefs)\n \tb.setTCPPortsIntercepted(handlePorts)\n \tb.setVIPServicesTCPPortsInterceptedLocked(vipServicesPorts)\n }\n \n-// updateIngressLocked updates the hostinfo.WireIngress and hostinfo.IngressEnabled fields and kicks off a Hostinfo\n-// update if the values have changed.\n+// updateIngressAndServiceHashLocked updates the hostinfo.ServicesHash, hostinfo.WireIngress and\n+// hostinfo.IngressEnabled fields and kicks off a Hostinfo update if the values have changed.\n //\n // b.mu must be held.\n-func (b *LocalBackend) updateIngressLocked() {\n+func (b *LocalBackend) updateIngressAndServiceHashLocked(prefs ipn.PrefsView) {\n \tif b.hostinfo == nil {\n \t\treturn\n \t}\n@@ -6171,6 +6171,11 @@ func (b *LocalBackend) updateIngressLocked() {\n \t\tb.hostinfo.WireIngress = wire\n \t\thostInfoChanged = true\n \t}\n+\tlatestHash := b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\tif b.hostinfo.ServicesHash != latestHash {\n+\t\tb.hostinfo.ServicesHash = latestHash\n+\t\thostInfoChanged = true\n+\t}\n \t// Kick off a Hostinfo update to control if ingress status has changed.\n \tif hostInfoChanged {\n \t\tb.goTracker.Go(b.doSetHostinfoFilterServices)\n---\nipn/ipnlocal/local_test.go\n@@ -5134,10 +5134,17 @@ func TestUpdatePrefsOnSysPolicyChange(t *testing.T) {\n \t}\n }\n \n-func TestUpdateIngressLocked(t *testing.T) {\n+func TestUpdateIngressAndServiceHashLocked(t *testing.T) {\n+\tprefs := ipn.NewPrefs().View()\n+\tpreviousSC := &ipn.ServeConfig{\n+\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\"svc:abc\": {Tun: true},\n+\t\t},\n+\t}\n \ttests := []struct {\n \t\tname              string\n \t\thi                *tailcfg.Hostinfo\n+\t\thasPreviousSC     bool // whether to overwrite the ServeConfig hash in the Hostinfo using previousSC\n \t\tsc                *ipn.ServeConfig\n \t\twantIngress       bool\n \t\twantWireIngress   bool\n@@ -5163,6 +5170,16 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantWireIngress:   false, // implied by wantIngress\n \t\t\twantControlUpdate: true,\n \t\t},\n+\t\t{\n+\t\t\tname: \"empty_hostinfo_service_configured\",\n+\t\t\thi:   &tailcfg.Hostinfo{},\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t\t{\n \t\t\tname: \"empty_hostinfo_funnel_disabled\",\n \t\t\thi:   &tailcfg.Hostinfo{},\n@@ -5175,7 +5192,7 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantControlUpdate: true,\n \t\t},\n \t\t{\n-\t\t\tname: \"empty_hostinfo_no_funnel\",\n+\t\t\tname: \"empty_hostinfo_no_funnel_no_service\",\n \t\t\thi:   &tailcfg.Hostinfo{},\n \t\t\tsc: &ipn.ServeConfig{\n \t\t\t\tTCP: map[uint16]*ipn.TCPPortHandler{\n@@ -5196,6 +5213,16 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantIngress:     true,\n \t\t\twantWireIngress: false, // implied by wantIngress\n \t\t},\n+\t\t{\n+\t\t\tname:          \"service_hash_no_change\",\n+\t\t\thi:            &tailcfg.Hostinfo{},\n+\t\t\thasPreviousSC: true,\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n \t\t{\n \t\t\tname: \"funnel_disabled_no_change\",\n \t\t\thi: &tailcfg.Hostinfo{\n@@ -5208,6 +5235,13 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t},\n \t\t\twantWireIngress: true, // true if there is any AllowFunnel block\n \t\t},\n+\t\t{\n+\t\t\tname:              \"service_got_removed\",\n+\t\t\thi:                &tailcfg.Hostinfo{},\n+\t\t\thasPreviousSC:     true,\n+\t\t\tsc:                &ipn.ServeConfig{},\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t\t{\n \t\t\tname: \"funnel_changes_to_disabled\",\n \t\t\thi: &tailcfg.Hostinfo{\n@@ -5235,12 +5269,35 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantWireIngress:   false, // implied by wantIngress\n \t\t\twantControlUpdate: true,\n \t\t},\n+\t\t{\n+\t\t\tname: \"both_funnel_and_service_changes\",\n+\t\t\thi: &tailcfg.Hostinfo{\n+\t\t\t\tIngressEnabled: true,\n+\t\t\t},\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tAllowFunnel: map[ipn.HostPort]bool{\n+\t\t\t\t\t\"tailnet.xyz:443\": false,\n+\t\t\t\t},\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantWireIngress:   true, // true if there is any AllowFunnel block\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t}\n \n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tt.Parallel()\n \t\t\tb := newTestLocalBackend(t)\n \t\t\tb.hostinfo = tt.hi\n+\t\t\tif tt.hasPreviousSC {\n+\t\t\t\tb.mu.Lock()\n+\t\t\t\tb.serveConfig = previousSC.View()\n+\t\t\t\tb.hostinfo.ServicesHash = b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\t\t\t\tb.mu.Unlock()\n+\t\t\t}\n \t\t\tb.serveConfig = tt.sc.View()\n \t\t\tallDone := make(chan bool, 1)\n \t\t\tdefer b.goTracker.AddDoneCallback(func() {\n@@ -5256,7 +5313,7 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t})()\n \n \t\t\twas := b.goTracker.StartedGoroutines()\n-\t\t\tb.updateIngressLocked()\n+\t\t\tb.updateIngressAndServiceHashLocked(prefs)\n \n \t\t\tif tt.hi != nil {\n \t\t\t\tif tt.hi.IngressEnabled != tt.wantIngress {\n@@ -5265,6 +5322,12 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t\tif tt.hi.WireIngress != tt.wantWireIngress {\n \t\t\t\t\tt.Errorf(\"WireIngress = %v, want %v\", tt.hi.WireIngress, tt.wantWireIngress)\n \t\t\t\t}\n+\t\t\t\tb.mu.Lock()\n+\t\t\t\tsvcHash := b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\t\t\t\tb.mu.Unlock()\n+\t\t\t\tif tt.hi.ServicesHash != svcHash {\n+\t\t\t\t\tt.Errorf(\"ServicesHash = %v, want %v\", tt.hi.ServicesHash, svcHash)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tstartedGoroutine := b.goTracker.StartedGoroutines() != was\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nSorry for my misoperation....\n\n---\n\nChoice A:\nipn/ipnlocal/ssh_stub.go\n@@ -8,6 +8,7 @@ package ipnlocal\n import (\n \t\"errors\"\n \n+\t\"golang.org/x/crypto/ssh\"\n \t\"tailscale.com/tailcfg\"\n )\n \n@@ -18,3 +19,7 @@ func (b *LocalBackend) getSSHHostKeyPublicStrings() ([]string, error) {\n func (b *LocalBackend) getSSHUsernames(*tailcfg.C2NSSHUsernamesRequest) (*tailcfg.C2NSSHUsernamesResponse, error) {\n \treturn nil, errors.New(\"not implemented\")\n }\n+\n+func (b *LocalBackend) GetSSH_HostKeys() (keys []ssh.Signer, err error) {\n+\treturn nil, errors.New(\"not implemented\")\n+}\n---\n\n\n---\n\nChoice B:\ngo.toolchain.rev\n@@ -1 +1 @@\n-4fdaeeb8fe43bcdb4e8cc736433b9cd9c0ddd221\n+16b6e4fd15c59336156cdbc977de1745ad094f2d\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/node_backend.go\n@@ -177,6 +177,11 @@ func (nb *nodeBackend) NodeByKey(k key.NodePublic) (_ tailcfg.NodeID, ok bool) {\n func (nb *nodeBackend) PeerByID(id tailcfg.NodeID) (_ tailcfg.NodeView, ok bool) {\n \tnb.mu.Lock()\n \tdefer nb.mu.Unlock()\n+\tif nb.netMap != nil {\n+\t\tif self := nb.netMap.SelfNode; self.Valid() && self.ID() == id {\n+\t\t\treturn self, true\n+\t\t}\n+\t}\n \tn, ok := nb.peers[id]\n \treturn n, ok\n }\n---\n\n\n---\n\nChoice D:\nwgengine/magicsock/endpoint.go\n@@ -552,7 +552,7 @@ func (de *endpoint) addrForSendLocked(now mono.Time) (udpAddr, derpAddr netip.Ad\n // addrForWireGuardSendLocked returns the address that should be used for\n // sending the next packet. If a packet has never or not recently been sent to\n // the endpoint, then a randomly selected address for the endpoint is returned,\n-// as well as a bool indiciating that WireGuard discovery pings should be started.\n+// as well as a bool indicating that WireGuard discovery pings should be started.\n // If the addresses have latency information available, then the address with the\n // best latency is used.\n //\n@@ -1261,7 +1261,7 @@ func (de *endpoint) sendDiscoPingsLocked(now mono.Time, sendCallMeMaybe bool) {\n }\n \n // sendWireGuardOnlyPingsLocked evaluates all available addresses for\n-// a WireGuard only endpoint and initates an ICMP ping for useable\n+// a WireGuard only endpoint and initiates an ICMP ping for useable\n // addresses.\n func (de *endpoint) sendWireGuardOnlyPingsLocked(now mono.Time) {\n \tif runtime.GOOS == \"js\" {\n@@ -1629,7 +1629,7 @@ func (de *endpoint) handlePongConnLocked(m *disco.Pong, di *discoInfo, src netip\n \t\t\tde.c.logf(\"magicsock: disco: node %v %v now using %v mtu=%v tx=%x\", de.publicKey.ShortString(), de.discoShort(), sp.to, thisPong.wireMTU, m.TxID[:6])\n \t\t\tde.debugUpdates.Add(EndpointChange{\n \t\t\t\tWhen: time.Now(),\n-\t\t\t\tWhat: \"handlePingLocked-bestAddr-update\",\n+\t\t\t\tWhat: \"handlePongConnLocked-bestAddr-update\",\n \t\t\t\tFrom: de.bestAddr,\n \t\t\t\tTo:   thisPong,\n \t\t\t})\n@@ -1638,7 +1638,7 @@ func (de *endpoint) handlePongConnLocked(m *disco.Pong, di *discoInfo, src netip\n \t\tif de.bestAddr.AddrPort == thisPong.AddrPort {\n \t\t\tde.debugUpdates.Add(EndpointChange{\n \t\t\t\tWhen: time.Now(),\n-\t\t\t\tWhat: \"handlePingLocked-bestAddr-latency\",\n+\t\t\t\tWhat: \"handlePongConnLocked-bestAddr-latency\",\n \t\t\t\tFrom: de.bestAddr,\n \t\t\t\tTo:   thisPong,\n \t\t\t})\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFix CompareAndSwap in the edge-case where\r\nthe underlying sync.AtomicValue is uninitialized\r\n(i.e., Store was never called) and\r\nthe oldV is the zero value,\r\nthen perform CompareAndSwap with any(nil).\r\n\r\nAlso, document that T must be comparable.\r\nThis is a pre-existing restriction.\r\n\r\nFixes #16135\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -1463,18 +1463,60 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+// PeerContext provides contextual information about a peer.\n+type PeerContext interface {\n+\tNode() tailcfg.NodeView\n+\tCaps() tailcfg.PeerCapMap\n+}\n+\n+// peerContext is a short-lived struct containing information about a peer.\n+// It is not safe for concurrent use and [localNodeContext]'s mutex must be held\n+// when using it. Therefore, it must not be retained or used outside the scope\n+// of the predicate or callback it was passed to.\n+type peerContext struct {\n+\tself *localNodeContext\n+\tpeer tailcfg.NodeView\n+}\n+\n+func (p peerContext) Node() tailcfg.NodeView {\n+\tif p.self == nil {\n+\t\tpanic(\"peerInfo used outside of its scope\")\n+\t}\n+\treturn p.peer\n+}\n+\n+// HasCap reports whether the peer has the specified capability.\n+// It panics if used outside of the PeerInfo's scope.\n+func (p peerContext) Caps() tailcfg.PeerCapMap {\n+\tif p.self == nil {\n+\t\tpanic(\"peerInfo used outside of its scope\")\n+\t}\n+\tif p.peer.Addresses().Len() == 0 {\n+\t\treturn nil\n+\t}\n+\treturn p.self.peerCapsLocked(p.peer.Addresses().At(0).Addr())\n+}\n+\n+// AppendMatchingPeers appends to base all peers in the netmap that match the predicate.\n+// The predicate is called with the node context's internal mutex locked,\n+// so it must not call back into the backend or the node context.\n+// The PeerInfo struct is only valid during the predicate call,\n+// and must not be retained or used outside of it.\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(PeerContext) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n+\tpi := &peerContext{self: b}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tpi.peer = peer\n+\t\tif pred(pi) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n+\tpi.self = nil\n \treturn ret\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n-\t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n+\tpeers := cn.AppendMatchingPeers(nil, func(p PeerContext) bool {\n+\t\tif !p.Node().Valid() || p.Node().Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n-\t\tif self != p.User() {\n+\t\tif self != p.Node().User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Caps().HasCapability(tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n---\n\n\n---\n\nChoice B:\ntailcfg/tailcfg.go\n@@ -1462,6 +1462,13 @@ const (\n \t// user groups as Kubernetes user groups. This capability is read by\n \t// peers that are Tailscale Kubernetes operator instances.\n \tPeerCapabilityKubernetes PeerCapability = \"tailscale.com/cap/kubernetes\"\n+\n+\t// PeerCapabilityRelay grants the ability for a peer to allocate relay\n+\t// endpoints.\n+\tPeerCapabilityRelay PeerCapability = \"tailscale.com/cap/relay\"\n+\t// PeerCapabilityRelayTarget grants the current node the ability to allocate\n+\t// relay endpoints to the peer which has this capability.\n+\tPeerCapabilityRelayTarget PeerCapability = \"tailscale.com/cap/relay-target\"\n )\n \n // NodeCapMap is a map of capabilities to their optional values. It is valid for\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local_test.go\n@@ -15,6 +15,7 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n+\t\"runtime\"\n \t\"slices\"\n \t\"strings\"\n \t\"sync\"\n@@ -2596,6 +2597,9 @@ func TestPreferencePolicyInfo(t *testing.T) {\n }\n \n func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n+\tif runtime.GOOS == \"darwin\" {\n+\t\tt.Skip(\"test known broken on macOS; see https://github.com/tailscale/tailscale/issues/15691\")\n+\t}\n \ttests := []struct {\n \t\tbefore, after  opt.Bool\n \t\tcontainer      opt.Bool\n---\n\n\n---\n\nChoice D:\nsyncs/syncs.go\n@@ -67,12 +67,18 @@ func (v *AtomicValue[T]) Swap(x T) (old T) {\n \tif oldV != nil {\n \t\treturn oldV.(wrappedValue[T]).v\n \t}\n-\treturn old\n+\treturn old // zero value of T\n }\n \n // CompareAndSwap executes the compare-and-swap operation for the Value.\n+// It panics if T is not comparable.\n func (v *AtomicValue[T]) CompareAndSwap(oldV, newV T) (swapped bool) {\n-\treturn v.v.CompareAndSwap(wrappedValue[T]{oldV}, wrappedValue[T]{newV})\n+\tvar zero T\n+\treturn v.v.CompareAndSwap(wrappedValue[T]{oldV}, wrappedValue[T]{newV}) ||\n+\t\t// In the edge-case where [atomic.Value.Store] is uninitialized\n+\t\t// and trying to compare with the zero value of T,\n+\t\t// then compare-and-swap with the nil any value.\n+\t\t(any(oldV) == any(zero) && v.v.CompareAndSwap(any(nil), wrappedValue[T]{newV}))\n }\n \n // MutexValue is a value protected by a mutex.\n---\nsyncs/syncs_test.go\n@@ -64,6 +64,23 @@ func TestAtomicValue(t *testing.T) {\n \t\t\tt.Fatalf(\"LoadOk = (%v, %v), want (nil, true)\", got, gotOk)\n \t\t}\n \t}\n+\n+\t{\n+\t\tc1, c2, c3 := make(chan struct{}), make(chan struct{}), make(chan struct{})\n+\t\tvar v AtomicValue[chan struct{}]\n+\t\tif v.CompareAndSwap(c1, c2) != false {\n+\t\t\tt.Fatalf(\"CompareAndSwap = true, want false\")\n+\t\t}\n+\t\tif v.CompareAndSwap(nil, c1) != true {\n+\t\t\tt.Fatalf(\"CompareAndSwap = false, want true\")\n+\t\t}\n+\t\tif v.CompareAndSwap(c2, c3) != false {\n+\t\t\tt.Fatalf(\"CompareAndSwap = true, want false\")\n+\t\t}\n+\t\tif v.CompareAndSwap(c1, c2) != true {\n+\t\t\tt.Fatalf(\"CompareAndSwap = false, want true\")\n+\t\t}\n+\t}\n }\n \n func TestMutexValue(t *testing.T) {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis adds SmallSet.SoleElement, which I need in another repo for\nefficiency. I added tests, but those tests failed because Add(1) +\nAdd(1) was promoting the first Add's sole element to a map of one\nitem. So fix that, and add more tests.\n\nUpdates tailscale/corp#29093\n\n\n---\n\nChoice A:\nnet/packet/packet.go\n@@ -51,10 +51,11 @@ type Parsed struct {\n \tIPVersion uint8\n \t// IPProto is the IP subprotocol (UDP, TCP, etc.). Valid iff IPVersion != 0.\n \tIPProto ipproto.Proto\n-\t// SrcIP4 is the source address. Family matches IPVersion. Port is\n-\t// valid iff IPProto == TCP || IPProto == UDP.\n+\t// Src is the source address. Family matches IPVersion. Port is\n+\t// valid iff IPProto == TCP || IPProto == UDP || IPProto == SCTP.\n \tSrc netip.AddrPort\n-\t// DstIP4 is the destination address. Family matches IPVersion.\n+\t// Dst is the destination address. Family matches IPVersion. Port is\n+\t// valid iff IPProto == TCP || IPProto == UDP || IPProto == SCTP.\n \tDst netip.AddrPort\n \t// TCPFlags is the packet's TCP flag bits. Valid iff IPProto == TCP.\n \tTCPFlags TCPFlag\n---\n\n\n---\n\nChoice B:\nipn/localapi/localapi.go\n@@ -397,6 +397,15 @@ func (h *Handler) serveBugReport(w http.ResponseWriter, r *http.Request) {\n \t// OS-specific details\n \th.logf.JSON(1, \"UserBugReportOS\", osdiag.SupportInfo(osdiag.LogSupportInfoReasonBugReport))\n \n+\t// Tailnet lock details\n+\tst := h.b.NetworkLockStatus()\n+\tif st.Enabled {\n+\t\th.logf.JSON(1, \"UserBugReportTailnetLockStatus\", st)\n+\t\tif st.NodeKeySignature != nil {\n+\t\t\th.logf(\"user bugreport tailnet lock signature: %s\", st.NodeKeySignature.String())\n+\t\t}\n+\t}\n+\n \tif defBool(r.URL.Query().Get(\"diagnose\"), false) {\n \t\th.b.Doctor(r.Context(), logger.WithPrefix(h.logf, \"diag: \"))\n \t}\n---\n\n\n---\n\nChoice C:\ntsnet/depaware.txt\n@@ -132,7 +132,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n    L \ud83d\udca3 github.com/mdlayher/netlink                                  from github.com/google/nftables+\n    L \ud83d\udca3 github.com/mdlayher/netlink/nlenc                            from github.com/jsimonetti/rtnetlink+\n    L    github.com/mdlayher/netlink/nltest                           from github.com/google/nftables\n-  LA    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n+   L    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n   LA \ud83d\udca3 github.com/mdlayher/socket                                   from github.com/mdlayher/netlink+\n         github.com/miekg/dns                                         from tailscale.com/net/dns/recursive\n  LDWA \ud83d\udca3 github.com/mitchellh/go-ps                                   from tailscale.com/safesocket\n---\nutil/systemd/systemd_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package systemd\n \n---\nutil/systemd/systemd_nonlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux || android\n \n package systemd\n \n---\n\n\n---\n\nChoice D:\nutil/set/smallset.go\n@@ -50,6 +50,15 @@ func (s SmallSet[T]) Contains(e T) bool {\n \treturn e != zero && s.one == e\n }\n \n+// SoleElement returns the single value in the set, if the set has exactly one\n+// element.\n+//\n+// If the set is empty or has more than one element, ok will be false and e will\n+// be the zero value of T.\n+func (s SmallSet[T]) SoleElement() (e T, ok bool) {\n+\treturn s.one, s.Len() == 1\n+}\n+\n // Add adds e to the set.\n //\n // When storing a SmallSet in a map as a value type, it is important to\n@@ -61,10 +70,15 @@ func (s *SmallSet[T]) Add(e T) {\n \t\ts.m.Add(e)\n \t\treturn\n \t}\n-\t// Size zero to one non-zero element.\n-\tif s.one == zero && e != zero {\n-\t\ts.one = e\n-\t\treturn\n+\t// Non-zero elements can go into s.one.\n+\tif e != zero {\n+\t\tif s.one == zero {\n+\t\t\ts.one = e // Len 0 to Len 1\n+\t\t\treturn\n+\t\t}\n+\t\tif s.one == e {\n+\t\t\treturn // dup\n+\t\t}\n \t}\n \t// Need to make a multi map, either\n \t// because we now have two items, or\n@@ -73,7 +87,7 @@ func (s *SmallSet[T]) Add(e T) {\n \tif s.one != zero {\n \t\ts.m.Add(s.one) // move single item to multi\n \t}\n-\ts.m.Add(e) // add new item\n+\ts.m.Add(e) // add new item, possibly zero\n \ts.one = zero\n }\n \n---\nutil/set/smallset_test.go\n@@ -84,8 +84,43 @@ func TestSmallSet(t *testing.T) {\n \t\t\t\t\t\t\tt.Errorf(\"contains(%v) mismatch after ops %s: normal=%v, small=%v\", e, name(), normal.Contains(e), small.Contains(e))\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\n+\t\t\t\t\tif err := small.checkInvariants(); err != nil {\n+\t\t\t\t\t\tt.Errorf(\"checkInvariants failed after ops %s: %v\", name(), err)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif !t.Failed() {\n+\t\t\t\t\t\tsole, ok := small.SoleElement()\n+\t\t\t\t\t\tif ok != (small.Len() == 1) {\n+\t\t\t\t\t\t\tt.Errorf(\"SoleElement ok mismatch after ops %s: SoleElement ok=%v, want=%v\", name(), ok, !ok)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif ok && sole != smallEle[0] {\n+\t\t\t\t\t\t\tt.Errorf(\"SoleElement value mismatch after ops %s: SoleElement=%v, want=%v\", name(), sole, smallEle[0])\n+\t\t\t\t\t\t\tt.Errorf(\"Internals: %+v\", small)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (s *SmallSet[T]) checkInvariants() error {\n+\tvar zero T\n+\tif s.m != nil && s.one != zero {\n+\t\treturn fmt.Errorf(\"both m and one are non-zero\")\n+\t}\n+\tif s.m != nil {\n+\t\tswitch len(s.m) {\n+\t\tcase 0:\n+\t\t\treturn fmt.Errorf(\"m is non-nil but empty\")\n+\t\tcase 1:\n+\t\t\tfor k := range s.m {\n+\t\t\t\tif k != zero {\n+\t\t\t\t\treturn fmt.Errorf(\"m contains exactly 1 non-zero element, %v\", k)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n+\treturn nil\n }\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThe field must only be accessed while holding `LocalBackend`'s mutex, but there are two places where it's accessed without the mutex:\r\n - `(LocalBackend).MaybeClearAppConnector()`\r\n - `handleC2NAppConnectorDomainRoutesGet()`\r\n\r\nFixes #16123\n\n---\n\nChoice A:\nfeature/taildrop/ext.go\n@@ -100,6 +100,10 @@ func (e *Extension) Init(h ipnext.Host) error {\n \th.Hooks().SetPeerStatus.Add(e.setPeerStatus)\n \th.Hooks().BackendStateChange.Add(e.onBackendStateChange)\n \n+\t// TODO(nickkhyl): remove this after the profileManager refactoring.\n+\t// See tailscale/tailscale#15974.\n+\tprofile, prefs := h.Profiles().CurrentProfileState()\n+\te.onChangeProfile(profile, prefs, false)\n \treturn nil\n }\n \n---\nfeature/taildrop/integration_test.go\n@@ -26,7 +26,6 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n-\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n \ttestTaildropIntegration(t, false)\n }\n \n---\nipn/ipnext/ipnext.go\n@@ -37,7 +37,10 @@ type Extension interface {\n \t// It must be the same as the name used to register the extension.\n \tName() string\n \n-\t// Init is called to initialize the extension when LocalBackend is initialized.\n+\t// Init is called to initialize the extension when LocalBackend's\n+\t// Start method is called. Extensions are created but not initialized\n+\t// unless LocalBackend is started.\n+\t//\n \t// If the extension cannot be initialized, it must return an error,\n \t// and its Shutdown method will not be called on the host's shutdown.\n \t// Returned errors are not fatal; they are used for logging.\n@@ -333,6 +336,7 @@ type Hooks struct {\n \t// BackendStateChange is called when the backend state changes.\n \tBackendStateChange feature.Hooks[func(ipn.State)]\n \n+\t// ProfileStateChange contains callbacks that are invoked when the current login profile\n \t// or its [ipn.Prefs] change, after those changes have been made. The current login profile\n \t// may be changed either because of a profile switch, or because the profile information\n \t// was updated by [LocalBackend.SetControlClientStatus], including when the profile\n---\nipn/ipnlocal/local.go\n@@ -237,6 +237,8 @@ type LocalBackend struct {\n \t// for testing and graceful shutdown purposes.\n \tgoTracker goroutines.Tracker\n \n+\tstartOnce sync.Once // protects the one\u2011time initialization in [LocalBackend.Start]\n+\n \t// extHost is the bridge between [LocalBackend] and the registered [ipnext.Extension]s.\n \t// It may be nil in tests that use direct composite literal initialization of [LocalBackend]\n \t// instead of calling [NewLocalBackend]. A nil pointer is a valid, no-op host.\n@@ -568,8 +570,6 @@ func NewLocalBackend(logf logger.Logf, logID logid.PublicID, sys *tsd.System, lo\n \t\t\t}\n \t\t}\n \t}\n-\n-\tb.extHost.Init()\n \treturn b, nil\n }\n \n@@ -2162,6 +2162,11 @@ func (b *LocalBackend) getNewControlClientFuncLocked() clientGen {\n \treturn b.ccGen\n }\n \n+// initOnce is called on the first call to [LocalBackend.Start].\n+func (b *LocalBackend) initOnce() {\n+\tb.extHost.Init()\n+}\n+\n // Start applies the configuration specified in opts, and starts the\n // state machine.\n //\n@@ -2175,6 +2180,8 @@ func (b *LocalBackend) getNewControlClientFuncLocked() clientGen {\n func (b *LocalBackend) Start(opts ipn.Options) error {\n \tb.logf(\"Start\")\n \n+\tb.startOnce.Do(b.initOnce)\n+\n \tvar clientToShutdown controlclient.Client\n \tdefer func() {\n \t\tif clientToShutdown != nil {\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/c2n.go\n@@ -240,13 +240,14 @@ func handleC2NAppConnectorDomainRoutesGet(b *LocalBackend, w http.ResponseWriter\n \tb.logf(\"c2n: GET /appconnector/routes received\")\n \n \tvar res tailcfg.C2NAppConnectorDomainRoutesResponse\n-\tif b.appConnector == nil {\n+\tappConnector := b.AppConnector()\n+\tif appConnector == nil {\n \t\tw.Header().Set(\"Content-Type\", \"application/json\")\n \t\tjson.NewEncoder(w).Encode(res)\n \t\treturn\n \t}\n \n-\tres.Domains = b.appConnector.DomainRoutes()\n+\tres.Domains = appConnector.DomainRoutes()\n \n \tw.Header().Set(\"Content-Type\", \"application/json\")\n \tjson.NewEncoder(w).Encode(res)\n---\nipn/ipnlocal/local.go\n@@ -4150,8 +4150,8 @@ func (b *LocalBackend) SetUseExitNodeEnabled(v bool) (ipn.PrefsView, error) {\n // AdvertiseRoutes has been set in the MaskedPrefs.\n func (b *LocalBackend) MaybeClearAppConnector(mp *ipn.MaskedPrefs) error {\n \tvar err error\n-\tif b.appConnector != nil && mp.AdvertiseRoutesSet {\n-\t\terr = b.appConnector.ClearRoutes()\n+\tif ac := b.AppConnector(); ac != nil && mp.AdvertiseRoutesSet {\n+\t\terr = ac.ClearRoutes()\n \t\tif err != nil {\n \t\t\tb.logf(\"appc: clear routes error: %v\", err)\n \t\t}\n@@ -4755,9 +4755,7 @@ func (b *LocalBackend) readvertiseAppConnectorRoutes() {\n \t//\n \t// Grab a copy of the field, since b.mu only guards access to the\n \t// b.appConnector field itself.\n-\tb.mu.Lock()\n-\tappConnector := b.appConnector\n-\tb.mu.Unlock()\n+\tappConnector := b.AppConnector()\n \n \tif appConnector == nil {\n \t\treturn\n@@ -6432,6 +6430,15 @@ func (b *LocalBackend) OfferingAppConnector() bool {\n \treturn b.appConnector != nil\n }\n \n+// AppConnector returns the current AppConnector, or nil if not configured.\n+//\n+// TODO(nickkhyl): move app connectors to [nodeBackend], or perhaps a feature package?\n+func (b *LocalBackend) AppConnector() *appc.AppConnector {\n+\tb.mu.Lock()\n+\tdefer b.mu.Unlock()\n+\treturn b.appConnector\n+}\n+\n // allowExitNodeDNSProxyToServeName reports whether the Exit Node DNS\n // proxy is allowed to serve responses for the provided DNS name.\n func (b *LocalBackend) allowExitNodeDNSProxyToServeName(name string) bool {\n---\n\n\n---\n\nChoice C:\ngo.toolchain.rev\n@@ -1 +1 @@\n-4fdaeeb8fe43bcdb4e8cc736433b9cd9c0ddd221\n+16b6e4fd15c59336156cdbc977de1745ad094f2d\n---\n\n\n---\n\nChoice D:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUsing `WINHTTP_AUTOPROXY_ALLOW_AUTOCONFIG` on Windows versions older than Windows 10 1703 (build 15063) is not supported and causes `WinHttpGetProxyForUrl` to fail with `ERROR_INVALID_PARAMETER`. This results in failures reaching the control on environments where a proxy is required.\r\n\r\nWe use `wingoes` version detection to conditionally set the `WINHTTP_AUTOPROXY_ALLOW_AUTOCONFIG` flag\r\non Windows builds greater than 15063.\r\n\r\nWhile there, we also update proxy detection to use `WINHTTP_AUTO_DETECT_TYPE_DNS_A`, as DNS-based proxy discovery might be required with Active Directory and in certain other environments.\r\n\r\nUpdates tailscale/corp#29168\r\nFixes #879\n\n---\n\nChoice A:\ncmd/derper/depaware.txt\n@@ -12,7 +12,7 @@ tailscale.com/cmd/derper dependencies: (generated by github.com/tailscale/depawa\n         github.com/coder/websocket/internal/util                     from github.com/coder/websocket\n         github.com/coder/websocket/internal/xsync                    from github.com/coder/websocket\n    L    github.com/coreos/go-iptables/iptables                       from tailscale.com/util/linuxfw\n-   W \ud83d\udca3 github.com/dblohm7/wingoes                                   from tailscale.com/util/winutil\n+   W \ud83d\udca3 github.com/dblohm7/wingoes                                   from tailscale.com/util/winutil+\n         github.com/fxamacker/cbor/v2                                 from tailscale.com/tka\n         github.com/go-json-experiment/json                           from tailscale.com/types/opt+\n         github.com/go-json-experiment/json/internal                  from github.com/go-json-experiment/json+\n---\nnet/tshttpproxy/tshttpproxy_windows.go\n@@ -18,6 +18,7 @@ import (\n \t\"unsafe\"\n \n \t\"github.com/alexbrainman/sspi/negotiate\"\n+\t\"github.com/dblohm7/wingoes\"\n \t\"golang.org/x/sys/windows\"\n \t\"tailscale.com/hostinfo\"\n \t\"tailscale.com/syncs\"\n@@ -97,9 +98,7 @@ func proxyFromWinHTTPOrCache(req *http.Request) (*url.URL, error) {\n \t\t}\n \t\tif err == windows.ERROR_INVALID_PARAMETER {\n \t\t\tmetricErrInvalidParameters.Add(1)\n-\t\t\t// Seen on Windows 8.1. (https://github.com/tailscale/tailscale/issues/879)\n-\t\t\t// TODO(bradfitz): figure this out.\n-\t\t\tsetNoProxyUntil(time.Hour)\n+\t\t\tsetNoProxyUntil(10 * time.Second)\n \t\t\tproxyErrorf(\"tshttpproxy: winhttp: GetProxyForURL(%q): ERROR_INVALID_PARAMETER [unexpected]\", urlStr)\n \t\t\treturn nil, nil\n \t\t}\n@@ -238,17 +237,30 @@ func (pi *winHTTPProxyInfo) free() {\n \t}\n }\n \n-var proxyForURLOpts = &winHTTPAutoProxyOptions{\n-\tDwFlags:           winHTTP_AUTOPROXY_ALLOW_AUTOCONFIG | winHTTP_AUTOPROXY_AUTO_DETECT,\n-\tDwAutoDetectFlags: winHTTP_AUTO_DETECT_TYPE_DHCP, // | winHTTP_AUTO_DETECT_TYPE_DNS_A,\n-}\n+var getProxyForURLOpts = sync.OnceValue(func() *winHTTPAutoProxyOptions {\n+\topts := &winHTTPAutoProxyOptions{\n+\t\tDwFlags:           winHTTP_AUTOPROXY_AUTO_DETECT,\n+\t\tDwAutoDetectFlags: winHTTP_AUTO_DETECT_TYPE_DHCP | winHTTP_AUTO_DETECT_TYPE_DNS_A,\n+\t}\n+\t// Support for the WINHTTP_AUTOPROXY_ALLOW_AUTOCONFIG flag was added in Windows 10, version 1703.\n+\t//\n+\t// Using it on earlier versions causes GetProxyForURL to fail with ERROR_INVALID_PARAMETER,\n+\t// which prevents proxy detection and can lead to failures reaching the control server\n+\t// on environments where a proxy is required.\n+\t//\n+\t// https://web.archive.org/web/20250529044903/https://learn.microsoft.com/en-us/windows/win32/api/winhttp/ns-winhttp-winhttp_autoproxy_options\n+\tif wingoes.IsWin10BuildOrGreater(wingoes.Win10Build1703) {\n+\t\topts.DwFlags |= winHTTP_AUTOPROXY_ALLOW_AUTOCONFIG\n+\t}\n+\treturn opts\n+})\n \n func (hi winHTTPInternet) GetProxyForURL(urlStr string) (string, error) {\n \tvar out winHTTPProxyInfo\n \terr := winHTTPGetProxyForURL(\n \t\thi,\n \t\twindows.StringToUTF16Ptr(urlStr),\n-\t\tproxyForURLOpts,\n+\t\tgetProxyForURLOpts(),\n \t\t&out,\n \t)\n \tif err != nil {\n---\n\n\n---\n\nChoice B:\ncmd/derper/cert_test.go\n@@ -140,6 +140,15 @@ func TestPinnedCertRawIP(t *testing.T) {\n \tvar hs http.Server\n \ths.Handler = mux\n \ths.TLSConfig = cp.TLSConfig()\n+\tgetCert := hs.TLSConfig.GetCertificate\n+\ths.TLSConfig.GetCertificate=func(hi *tls.ClientHelloInfo) (*tls.Certificate, error) {\n+\t\tcert, err := getCert(hi)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tcert.Certificate = append(cert.Certificate, ds.MetaCert())\n+\t\treturn cert, nil\n+\t}\n \tgo hs.ServeTLS(ln, \"\", \"\")\n \n \tlnPort := ln.Addr().(*net.TCPAddr).Port\n---\nnet/tlsdial/tlsdial.go\n@@ -263,7 +263,7 @@ func SetConfigExpectedCertHash(c *tls.Config, wantFullCertSHA256Hex string) {\n \t\tif len(rawCerts) == 0 {\n \t\t\treturn errors.New(\"no certs presented\")\n \t\t}\n-\t\tif len(rawCerts) > 1 {\n+\t\tif len(rawCerts) > 2 {\n \t\t\treturn errors.New(\"unexpected multiple certs presented\")\n \t\t}\n \t\tif fmt.Sprintf(\"%02x\", sha256.Sum256(rawCerts[0])) != wantFullCertSHA256Hex {\n---\n\n\n---\n\nChoice C:\nclient/systray/systray.go\n@@ -84,12 +84,13 @@ type Menu struct {\n \tbgCancel context.CancelFunc\n \n \t// Top-level menu items\n-\tconnect    *systray.MenuItem\n-\tdisconnect *systray.MenuItem\n-\tself       *systray.MenuItem\n-\texitNodes  *systray.MenuItem\n-\tmore       *systray.MenuItem\n-\tquit       *systray.MenuItem\n+\tconnect     *systray.MenuItem\n+\tdisconnect  *systray.MenuItem\n+\tself        *systray.MenuItem\n+\texitNodes   *systray.MenuItem\n+\tmore        *systray.MenuItem\n+\trebuildMenu *systray.MenuItem\n+\tquit        *systray.MenuItem\n \n \trebuildCh  chan struct{} // triggers a menu rebuild\n \taccountsCh chan ipn.ProfileID\n@@ -295,6 +296,17 @@ func (menu *Menu) rebuild() {\n \t\t})\n \t}\n \n+\t// TODO(#15528): this menu item shouldn't be necessary at all,\n+\t// but is at least more discoverable than having users switch profiles or exit nodes.\n+\tmenu.rebuildMenu = systray.AddMenuItem(\"Rebuild menu\", \"Fix missing menu items\")\n+\tonClick(ctx, menu.rebuildMenu, func(ctx context.Context) {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\tcase menu.rebuildCh <- struct{}{}:\n+\t\t}\n+\t})\n+\tmenu.rebuildMenu.Enable()\n+\n \tmenu.quit = systray.AddMenuItem(\"Quit\", \"Quit the app\")\n \tmenu.quit.Enable()\n \n---\n\n\n---\n\nChoice D:\nnet/netmon/netmon.go\n@@ -441,14 +441,14 @@ func (m *Monitor) handlePotentialChange(newState *State, forceCallbacks bool) {\n \tdelta.Major = m.IsMajorChangeFrom(oldState, newState)\n \tif delta.Major {\n \t\tm.gwValid = false\n-\t\tm.ifState = newState\n \n \t\tif s1, s2 := oldState.String(), delta.New.String(); s1 == s2 {\n \t\t\tm.logf(\"[unexpected] network state changed, but stringification didn't: %v\", s1)\n \t\t\tm.logf(\"[unexpected] old: %s\", jsonSummary(oldState))\n \t\t\tm.logf(\"[unexpected] new: %s\", jsonSummary(newState))\n \t\t}\n \t}\n+\tm.ifState = newState\n \t// See if we have a queued or new time jump signal.\n \tif timeJumped {\n \t\tm.resetTimeJumpedLocked()\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nI stumbled on this in passing while doing something else, and it seems low-risk.\n\nAs suggested in the comment, it now being more than six months since this was\ndeprecated and there being no (further) uses of the old pattern in our internal\nservices, let's drop the migrator.\n\nUpdates #cleanup\n\nChange-Id: Ie4fb9518b2ca04a9b361e09c51cbbacf1e2633a8\nSigned-off-by: M. J. Fromberger <fromberger@tailscale.com>\n\n\n---\n\nChoice A:\nipn/localapi/localapi.go\n@@ -397,6 +397,15 @@ func (h *Handler) serveBugReport(w http.ResponseWriter, r *http.Request) {\n \t// OS-specific details\n \th.logf.JSON(1, \"UserBugReportOS\", osdiag.SupportInfo(osdiag.LogSupportInfoReasonBugReport))\n \n+\t// Tailnet lock details\n+\tst := h.b.NetworkLockStatus()\n+\tif st.Enabled {\n+\t\th.logf.JSON(1, \"UserBugReportTailnetLockStatus\", st)\n+\t\tif st.NodeKeySignature != nil {\n+\t\t\th.logf(\"user bugreport tailnet lock signature: %s\", st.NodeKeySignature.String())\n+\t\t}\n+\t}\n+\n \tif defBool(r.URL.Query().Get(\"diagnose\"), false) {\n \t\th.b.Doctor(r.Context(), logger.WithPrefix(h.logf, \"diag: \"))\n \t}\n---\n\n\n---\n\nChoice B:\nnet/dns/debian_resolvconf.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || freebsd || openbsd\n+//go:build (linux && !android) || freebsd || openbsd\n \n package dns\n \n---\nnet/dns/direct.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android && !ios\n+\n package dns\n \n import (\n---\nnet/dns/direct_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build linux && !android\n+\n package dns\n \n import (\n---\nnet/dns/direct_notlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux && !android && !ios\n \n package dns\n \n---\nnet/dns/manager_default.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux && !freebsd && !openbsd && !windows && !darwin && !illumos && !solaris && !plan9\n+//go:build (!linux || android) && !freebsd && !openbsd && !windows && !darwin && !illumos && !solaris && !plan9\n \n package dns\n \n---\nnet/dns/manager_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build linux && !android\n+\n package dns\n \n import (\n---\nnet/dns/nm.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package dns\n \n---\nnet/dns/openresolv.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || freebsd || openbsd\n+//go:build (linux && !android) || freebsd || openbsd\n \n package dns\n \n---\nnet/dns/resolved.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package dns\n \n---\ntsnet/depaware.txt\n@@ -103,7 +103,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         github.com/go-json-experiment/json/jsontext                  from github.com/go-json-experiment/json+\n    W \ud83d\udca3 github.com/go-ole/go-ole                                     from github.com/go-ole/go-ole/oleutil+\n    W \ud83d\udca3 github.com/go-ole/go-ole/oleutil                             from tailscale.com/wgengine/winnet\n-  LA \ud83d\udca3 github.com/godbus/dbus/v5                                    from tailscale.com/net/dns\n+   L \ud83d\udca3 github.com/godbus/dbus/v5                                    from tailscale.com/net/dns\n         github.com/golang/groupcache/lru                             from tailscale.com/net/dnscache\n         github.com/google/btree                                      from gvisor.dev/gvisor/pkg/tcpip/header+\n    L    github.com/google/nftables                                   from tailscale.com/util/linuxfw\n@@ -116,8 +116,8 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n  LDW    github.com/gorilla/csrf                                      from tailscale.com/client/web\n  LDW    github.com/gorilla/securecookie                              from github.com/gorilla/csrf\n         github.com/hdevalence/ed25519consensus                       from tailscale.com/clientupdate/distsign+\n-  LA \ud83d\udca3 github.com/illarion/gonotify/v3                              from tailscale.com/net/dns\n-  LA    github.com/illarion/gonotify/v3/syscallf                     from github.com/illarion/gonotify/v3\n+   L \ud83d\udca3 github.com/illarion/gonotify/v3                              from tailscale.com/net/dns\n+   L    github.com/illarion/gonotify/v3/syscallf                     from github.com/illarion/gonotify/v3\n    L    github.com/jmespath/go-jmespath                              from github.com/aws/aws-sdk-go-v2/service/ssm\n    L \ud83d\udca3 github.com/jsimonetti/rtnetlink                              from tailscale.com/net/netmon\n    L    github.com/jsimonetti/rtnetlink/internal/unix                from github.com/jsimonetti/rtnetlink\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/extension_host_test.go\n@@ -284,7 +284,7 @@ func TestNewExtensionHost(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tt.Parallel()\n \t\t\tlogf := tstest.WhileTestRunningLogger(t)\n-\t\t\th, err := NewExtensionHost(logf, &tsd.System{}, &testBackend{}, tt.defs...)\n+\t\t\th, err := NewExtensionHost(logf, tsd.NewSystem(), &testBackend{}, tt.defs...)\n \t\t\tif gotErr := err != nil; gotErr != tt.wantErr {\n \t\t\t\tt.Errorf(\"NewExtensionHost: gotErr %v(%v); wantErr %v\", gotErr, err, tt.wantErr)\n \t\t\t}\n@@ -1118,7 +1118,7 @@ func newExtensionHostForTest[T ipnext.Extension](t *testing.T, b Backend, initia\n \t\t}\n \t\tdefs[i] = ipnext.DefinitionForTest(ext)\n \t}\n-\th, err := NewExtensionHost(logf, &tsd.System{}, b, defs...)\n+\th, err := NewExtensionHost(logf, tsd.NewSystem(), b, defs...)\n \tif err != nil {\n \t\tt.Fatalf(\"NewExtensionHost: %v\", err)\n \t}\n---\nipn/ipnlocal/state_test.go\n@@ -1397,7 +1397,7 @@ func newLocalBackendWithMockEngineAndControl(t *testing.T, enableLogging bool) (\n \tdialer := &tsdial.Dialer{Logf: logf}\n \tdialer.SetNetMon(netmon.NewStatic())\n \n-\tsys := &tsd.System{}\n+\tsys := tsd.NewSystem()\n \tsys.Set(dialer)\n \tsys.Set(dialer.NetMon())\n \n---\n\n\n---\n\nChoice D:\ntsnet/tsnet.go\n@@ -536,10 +536,7 @@ func (s *Server) start() (reterr error) {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\ts.rootPath, err = getTSNetDir(s.logf, confDir, prog)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\t\ts.rootPath = filepath.Join(confDir, \"tsnet-\"+prog)\n \t}\n \tif err := os.MkdirAll(s.rootPath, 0700); err != nil {\n \t\treturn err\n@@ -897,49 +894,6 @@ func (s *Server) getUDPHandlerForFlow(src, dst netip.AddrPort) (handler func(net\n \treturn func(c nettype.ConnPacketConn) { ln.handle(c) }, true\n }\n \n-// getTSNetDir usually just returns filepath.Join(confDir, \"tsnet-\"+prog)\n-// with no error.\n-//\n-// One special case is that it renames old \"tslib-\" directories to\n-// \"tsnet-\", and that rename might return an error.\n-//\n-// TODO(bradfitz): remove this maybe 6 months after 2022-03-17,\n-// once people (notably Tailscale corp services) have updated.\n-func getTSNetDir(logf logger.Logf, confDir, prog string) (string, error) {\n-\toldPath := filepath.Join(confDir, \"tslib-\"+prog)\n-\tnewPath := filepath.Join(confDir, \"tsnet-\"+prog)\n-\n-\tfi, err := os.Lstat(oldPath)\n-\tif os.IsNotExist(err) {\n-\t\t// Common path.\n-\t\treturn newPath, nil\n-\t}\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tif !fi.IsDir() {\n-\t\treturn \"\", fmt.Errorf(\"expected old tslib path %q to be a directory; got %v\", oldPath, fi.Mode())\n-\t}\n-\n-\t// At this point, oldPath exists and is a directory. But does\n-\t// the new path exist?\n-\n-\tfi, err = os.Lstat(newPath)\n-\tif err == nil && fi.IsDir() {\n-\t\t// New path already exists somehow. Ignore the old one and\n-\t\t// don't try to migrate it.\n-\t\treturn newPath, nil\n-\t}\n-\tif err != nil && !os.IsNotExist(err) {\n-\t\treturn \"\", err\n-\t}\n-\tif err := os.Rename(oldPath, newPath); err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tlogf(\"renamed old tsnet state storage directory %q to %q\", oldPath, newPath)\n-\treturn newPath, nil\n-}\n-\n // APIClient returns a tailscale.Client that can be used to make authenticated\n // requests to the Tailscale control server.\n // It requires the user to set tailscale.I_Acknowledge_This_API_Is_Unstable.\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nfixes tailscale/tailscale#16082\r\n\r\nRouteAll should be true by default on iOS and Android.  These platforms don't have\r\na CLI and aren't impacted by the original issue that prompted this change.\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -5918,19 +5918,22 @@ func (b *LocalBackend) requestEngineStatusAndWait() {\n \tb.logf(\"requestEngineStatusAndWait: got status update.\")\n }\n \n+// [controlclient.Auto] implements [auditlog.Transport].\n+var _ auditlog.Transport = (*controlclient.Auto)(nil)\n+\n // setControlClientLocked sets the control client to cc,\n // which may be nil.\n //\n // b.mu must be held.\n func (b *LocalBackend) setControlClientLocked(cc controlclient.Client) {\n \tb.cc = cc\n \tb.ccAuto, _ = cc.(*controlclient.Auto)\n-\tif b.auditLogger != nil {\n+\tif t, ok := b.cc.(auditlog.Transport); ok && b.auditLogger != nil {\n \t\tif err := b.auditLogger.SetProfileID(b.pm.CurrentProfile().ID()); err != nil {\n \t\t\tb.logf(\"audit logger set profile ID failure: %v\", err)\n \t\t}\n \n-\t\tif err := b.auditLogger.Start(b.ccAuto); err != nil {\n+\t\tif err := b.auditLogger.Start(t); err != nil {\n \t\t\tb.logf(\"audit logger start failure: %v\", err)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice B:\nipn/prefs.go\n@@ -721,9 +721,10 @@ func (p *Prefs) ControlURLOrDefault() string {\n // of the platform it's running on.\n func (p *Prefs) DefaultRouteAll(goos string) bool {\n \tswitch goos {\n-\tcase \"windows\":\n+\tcase \"windows\", \"android\", \"ios\":\n \t\treturn true\n \tcase \"darwin\":\n+\t\t// Only true for macAppStore and macsys, false for darwin tailscaled.\n \t\treturn version.IsSandboxedMacOS()\n \tdefault:\n \t\treturn false\n---\n\n\n---\n\nChoice C:\npkgdoc_test.go\n@@ -26,6 +26,9 @@ func TestPackageDocs(t *testing.T) {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tif fi.Mode().IsDir() && path == \".git\" {\n+\t\t\treturn filepath.SkipDir // No documentation lives in .git\n+\t\t}\n \t\tif fi.Mode().IsRegular() && strings.HasSuffix(path, \".go\") {\n \t\t\tif strings.HasSuffix(path, \"_test.go\") {\n \t\t\t\treturn nil\n---\n\n\n---\n\nChoice D:\ngo.mod\n@@ -272,7 +272,7 @@ require (\n \tgithub.com/gordonklaus/ineffassign v0.1.0 // indirect\n \tgithub.com/goreleaser/chglog v0.5.0 // indirect\n \tgithub.com/goreleaser/fileglob v1.3.0 // indirect\n-\tgithub.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30\n+\tgithub.com/gorilla/csrf v1.7.3\n \tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n \tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n \tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n---\ngo.sum\n@@ -524,8 +524,8 @@ github.com/goreleaser/fileglob v1.3.0 h1:/X6J7U8lbDpQtBvGcwwPS6OpzkNVlVEsFUVRx9+\n github.com/goreleaser/fileglob v1.3.0/go.mod h1:Jx6BoXv3mbYkEzwm9THo7xbr5egkAraxkGorbJb4RxU=\n github.com/goreleaser/nfpm/v2 v2.33.1 h1:EkdAzZyVhAI9JC1vjmjjbmnNzyH1J6Cu4JCsA7YcQuc=\n github.com/goreleaser/nfpm/v2 v2.33.1/go.mod h1:8wwWWvJWmn84xo/Sqiv0aMvEGTHlHZTXTEuVSgQpkIM=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30 h1:fiJdrgVBkjZ5B1HJ2WQwNOaXB+QyYcNXTA3t1XYLz0M=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n+github.com/gorilla/csrf v1.7.3 h1:BHWt6FTLZAb2HtWT5KDBf6qgpZzvtbp9QWDRKZMXJC0=\n+github.com/gorilla/csrf v1.7.3/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n github.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\n github.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\n github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/corp#29093\n\n\n---\n\nChoice A:\nhostinfo/hostinfo.go\n@@ -43,7 +43,7 @@ func RegisterHostinfoNewHook(f func(*tailcfg.Hostinfo)) {\n \n // New returns a partially populated Hostinfo for the current host.\n func New() *tailcfg.Hostinfo {\n-\thostname, _ := os.Hostname()\n+\thostname, _ := Hostname()\n \thostname = dnsname.FirstLabel(hostname)\n \thi := &tailcfg.Hostinfo{\n \t\tIPNVersion:      version.Long(),\n@@ -509,3 +509,21 @@ func IsInVM86() bool {\n \t\treturn New().DeviceModel == copyV86DeviceModel\n \t})\n }\n+\n+type hostnameQuery func() (string, error)\n+\n+var hostnameFn atomic.Value // of func() (string, error)\n+\n+// SetHostNameFn sets a custom function for querying the system hostname.\n+func SetHostnameFn(fn hostnameQuery) {\n+\thostnameFn.Store(fn)\n+}\n+\n+// Hostname returns the system hostname using the function\n+// set by SetHostNameFn.  We will fallback to os.Hostname.\n+func Hostname() (string, error) {\n+\tif fn, ok := hostnameFn.Load().(hostnameQuery); ok && fn != nil {\n+\t\treturn fn()\n+\t}\n+\treturn os.Hostname()\n+}\n---\nhostinfo/hostinfo_test.go\n@@ -5,6 +5,7 @@ package hostinfo\n \n import (\n \t\"encoding/json\"\n+\t\"os\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -49,3 +50,31 @@ func TestEtcAptSourceFileIsDisabled(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestCustomHostnameFunc(t *testing.T) {\n+\twant := \"custom-hostname\"\n+\tSetHostnameFn(func() (string, error) {\n+\t\treturn want, nil\n+\t})\n+\n+\tgot, err := Hostname()\n+\tif err != nil {\n+\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+\n+\tif got != want {\n+\t\tt.Errorf(\"got %q, want %q\", got, want)\n+\t}\n+\n+\tSetHostnameFn(os.Hostname)\n+\tgot, err = Hostname()\n+\twant, _ = os.Hostname()\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+\tif got != want {\n+\t\tt.Errorf(\"got %q, want %q\", got, want)\n+\t}\n+\n+}\n---\nipn/ipnlocal/local.go\n@@ -1245,7 +1245,7 @@ func (b *LocalBackend) UpdateStatus(sb *ipnstate.StatusBuilder) {\n \t\t\t}\n \n \t\t} else {\n-\t\t\tss.HostName, _ = os.Hostname()\n+\t\t\tss.HostName, _ = hostinfo.Hostname()\n \t\t}\n \t\tfor _, pln := range b.peerAPIListeners {\n \t\t\tss.PeerAPIURL = append(ss.PeerAPIURL, pln.urlStr)\n---\n\n\n---\n\nChoice B:\nnet/routetable/routetable_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package routetable\n \n---\nnet/routetable/routetable_other.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux && !darwin && !freebsd\n+//go:build android || (!linux && !darwin && !freebsd)\n \n package routetable\n \n---\nnet/tstun/linkattrs_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android\n+\n package tstun\n \n import (\n---\nnet/tstun/linkattrs_notlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux || android\n \n package tstun\n \n---\nwgengine/router/router_android.go\n@@ -0,0 +1,29 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build android\n+\n+package router\n+\n+import (\n+\t\"github.com/tailscale/wireguard-go/tun\"\n+\t\"tailscale.com/health\"\n+\t\"tailscale.com/net/netmon\"\n+\t\"tailscale.com/types/logger\"\n+)\n+\n+func newUserspaceRouter(logf logger.Logf, tunDev tun.Device, netMon *netmon.Monitor, health *health.Tracker) (Router, error) {\n+\t// Note, this codepath is _not_ used when building the android app\n+\t// from github.com/tailscale/tailscale-android. The android app\n+\t// constructs its own wgengine with a custom router implementation\n+\t// that plugs into Android networking APIs.\n+\t//\n+\t// In practice, the only place this fake router gets used is when\n+\t// you build a tsnet app for android, in which case we don't want\n+\t// to touch the OS network stack and a no-op router is correct.\n+\treturn NewFake(logf), nil\n+}\n+\n+func cleanUp(logf logger.Logf, interfaceName string) {\n+\t// Nothing to do here.\n+}\n---\nwgengine/router/router_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android\n+\n package router\n \n import (\n---\n\n\n---\n\nChoice C:\ntsnet/tsnet.go\n@@ -536,10 +536,7 @@ func (s *Server) start() (reterr error) {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\ts.rootPath, err = getTSNetDir(s.logf, confDir, prog)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\t\ts.rootPath = filepath.Join(confDir, \"tsnet-\"+prog)\n \t}\n \tif err := os.MkdirAll(s.rootPath, 0700); err != nil {\n \t\treturn err\n@@ -897,49 +894,6 @@ func (s *Server) getUDPHandlerForFlow(src, dst netip.AddrPort) (handler func(net\n \treturn func(c nettype.ConnPacketConn) { ln.handle(c) }, true\n }\n \n-// getTSNetDir usually just returns filepath.Join(confDir, \"tsnet-\"+prog)\n-// with no error.\n-//\n-// One special case is that it renames old \"tslib-\" directories to\n-// \"tsnet-\", and that rename might return an error.\n-//\n-// TODO(bradfitz): remove this maybe 6 months after 2022-03-17,\n-// once people (notably Tailscale corp services) have updated.\n-func getTSNetDir(logf logger.Logf, confDir, prog string) (string, error) {\n-\toldPath := filepath.Join(confDir, \"tslib-\"+prog)\n-\tnewPath := filepath.Join(confDir, \"tsnet-\"+prog)\n-\n-\tfi, err := os.Lstat(oldPath)\n-\tif os.IsNotExist(err) {\n-\t\t// Common path.\n-\t\treturn newPath, nil\n-\t}\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tif !fi.IsDir() {\n-\t\treturn \"\", fmt.Errorf(\"expected old tslib path %q to be a directory; got %v\", oldPath, fi.Mode())\n-\t}\n-\n-\t// At this point, oldPath exists and is a directory. But does\n-\t// the new path exist?\n-\n-\tfi, err = os.Lstat(newPath)\n-\tif err == nil && fi.IsDir() {\n-\t\t// New path already exists somehow. Ignore the old one and\n-\t\t// don't try to migrate it.\n-\t\treturn newPath, nil\n-\t}\n-\tif err != nil && !os.IsNotExist(err) {\n-\t\treturn \"\", err\n-\t}\n-\tif err := os.Rename(oldPath, newPath); err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tlogf(\"renamed old tsnet state storage directory %q to %q\", oldPath, newPath)\n-\treturn newPath, nil\n-}\n-\n // APIClient returns a tailscale.Client that can be used to make authenticated\n // requests to the Tailscale control server.\n // It requires the user to set tailscale.I_Acknowledge_This_API_Is_Unstable.\n---\n\n\n---\n\nChoice D:\nutil/set/smallset.go\n@@ -0,0 +1,134 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package set\n+\n+import (\n+\t\"iter\"\n+\t\"maps\"\n+\n+\t\"tailscale.com/types/structs\"\n+)\n+\n+// SmallSet is a set that is optimized for reducing memory overhead when the\n+// expected size of the set is 0 or 1 elements.\n+//\n+// The zero value of SmallSet is a usable empty set.\n+//\n+// When storing a SmallSet in a map as a value type, it is important to re-assign\n+// the map entry after calling Add or Delete, as the SmallSet's representation\n+// may change.\n+//\n+// Copying a SmallSet by value may alias the previous value. Use the Clone method\n+// to create a new SmallSet with the same contents.\n+type SmallSet[T comparable] struct {\n+\t_   structs.Incomparable // to prevent == mistakes\n+\tone T                    // if non-zero, then single item in set\n+\tm   Set[T]               // if non-nil, the set of items, which might be size 1 if it's the zero value of T\n+}\n+\n+// Values returns an iterator over the elements of the set.\n+// The iterator will yield the elements in no particular order.\n+func (s SmallSet[T]) Values() iter.Seq[T] {\n+\tif s.m != nil {\n+\t\treturn maps.Keys(s.m)\n+\t}\n+\tvar zero T\n+\treturn func(yield func(T) bool) {\n+\t\tif s.one != zero {\n+\t\t\tyield(s.one)\n+\t\t}\n+\t}\n+}\n+\n+// Contains reports whether e is in the set.\n+func (s SmallSet[T]) Contains(e T) bool {\n+\tif s.m != nil {\n+\t\treturn s.m.Contains(e)\n+\t}\n+\tvar zero T\n+\treturn e != zero && s.one == e\n+}\n+\n+// Add adds e to the set.\n+//\n+// When storing a SmallSet in a map as a value type, it is important to\n+// re-assign the map entry after calling Add or Delete, as the SmallSet's\n+// representation may change.\n+func (s *SmallSet[T]) Add(e T) {\n+\tvar zero T\n+\tif s.m != nil {\n+\t\ts.m.Add(e)\n+\t\treturn\n+\t}\n+\t// Size zero to one non-zero element.\n+\tif s.one == zero && e != zero {\n+\t\ts.one = e\n+\t\treturn\n+\t}\n+\t// Need to make a multi map, either\n+\t// because we now have two items, or\n+\t// because e is the zero value.\n+\ts.m = Set[T]{}\n+\tif s.one != zero {\n+\t\ts.m.Add(s.one) // move single item to multi\n+\t}\n+\ts.m.Add(e) // add new item\n+\ts.one = zero\n+}\n+\n+// Len reports the number of elements in the set.\n+func (s SmallSet[T]) Len() int {\n+\tvar zero T\n+\tif s.m != nil {\n+\t\treturn s.m.Len()\n+\t}\n+\tif s.one != zero {\n+\t\treturn 1\n+\t}\n+\treturn 0\n+}\n+\n+// Delete removes e from the set.\n+//\n+// When storing a SmallSet in a map as a value type, it is important to\n+// re-assign the map entry after calling Add or Delete, as the SmallSet's\n+// representation may change.\n+func (s *SmallSet[T]) Delete(e T) {\n+\tvar zero T\n+\tif s.m == nil {\n+\t\tif s.one == e {\n+\t\t\ts.one = zero\n+\t\t}\n+\t\treturn\n+\t}\n+\ts.m.Delete(e)\n+\n+\t// If the map size drops to zero, that means\n+\t// it only contained the zero value of T.\n+\tif s.m.Len() == 0 {\n+\t\ts.m = nil\n+\t\treturn\n+\t}\n+\n+\t// If the map size drops to one element and doesn't\n+\t// contain the zero value, we can switch back to the\n+\t// single-item representation.\n+\tif s.m.Len() == 1 {\n+\t\tfor v := range s.m {\n+\t\t\tif v != zero {\n+\t\t\t\ts.one = v\n+\t\t\t\ts.m = nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// Clone returns a copy of s that doesn't alias the original.\n+func (s SmallSet[T]) Clone() SmallSet[T] {\n+\treturn SmallSet[T]{\n+\t\tone: s.one,\n+\t\tm:   maps.Clone(s.m), // preserves nilness\n+\t}\n+}\n---\nutil/set/smallset_test.go\n@@ -0,0 +1,91 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package set\n+\n+import (\n+\t\"fmt\"\n+\t\"iter\"\n+\t\"maps\"\n+\t\"reflect\"\n+\t\"slices\"\n+\t\"testing\"\n+)\n+\n+func TestSmallSet(t *testing.T) {\n+\tt.Parallel()\n+\n+\twantSize := reflect.TypeFor[int64]().Size() + reflect.TypeFor[map[int]struct{}]().Size()\n+\tif wantSize > 16 {\n+\t\tt.Errorf(\"wantSize should be no more than 16\") // it might be smaller on 32-bit systems\n+\t}\n+\tif size := reflect.TypeFor[SmallSet[int64]]().Size(); size != wantSize {\n+\t\tt.Errorf(\"SmallSet[int64] size is %d, want %v\", size, wantSize)\n+\t}\n+\n+\ttype op struct {\n+\t\tadd bool\n+\t\tv   int\n+\t}\n+\tops := iter.Seq[op](func(yield func(op) bool) {\n+\t\tfor _, add := range []bool{false, true} {\n+\t\t\tfor v := range 4 {\n+\t\t\t\tif !yield(op{add: add, v: v}) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t})\n+\ttype setLike interface {\n+\t\tAdd(int)\n+\t\tDelete(int)\n+\t}\n+\tapply := func(s setLike, o op) {\n+\t\tif o.add {\n+\t\t\ts.Add(o.v)\n+\t\t} else {\n+\t\t\ts.Delete(o.v)\n+\t\t}\n+\t}\n+\n+\t// For all combinations of 4 operations,\n+\t// apply them to both a regular map and SmallSet\n+\t// and make sure all the invariants hold.\n+\n+\tfor op1 := range ops {\n+\t\tfor op2 := range ops {\n+\t\t\tfor op3 := range ops {\n+\t\t\t\tfor op4 := range ops {\n+\n+\t\t\t\t\tnormal := Set[int]{}\n+\t\t\t\t\tsmall := &SmallSet[int]{}\n+\t\t\t\t\tfor _, op := range []op{op1, op2, op3, op4} {\n+\t\t\t\t\t\tapply(normal, op)\n+\t\t\t\t\t\tapply(small, op)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tname := func() string {\n+\t\t\t\t\t\treturn fmt.Sprintf(\"op1=%v, op2=%v, op3=%v, op4=%v\", op1, op2, op3, op4)\n+\t\t\t\t\t}\n+\t\t\t\t\tif normal.Len() != small.Len() {\n+\t\t\t\t\t\tt.Errorf(\"len mismatch after ops %s: normal=%d, small=%d\", name(), normal.Len(), small.Len())\n+\t\t\t\t\t}\n+\t\t\t\t\tif got := small.Clone().Len(); normal.Len() != got {\n+\t\t\t\t\t\tt.Errorf(\"len mismatch after ops %s: normal=%d, clone=%d\", name(), normal.Len(), got)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tnormalEle := slices.Sorted(maps.Keys(normal))\n+\t\t\t\t\tsmallEle := slices.Sorted(small.Values())\n+\t\t\t\t\tif !slices.Equal(normalEle, smallEle) {\n+\t\t\t\t\t\tt.Errorf(\"elements mismatch after ops %s: normal=%v, small=%v\", name(), normalEle, smallEle)\n+\t\t\t\t\t}\n+\t\t\t\t\tfor e := range 5 {\n+\t\t\t\t\t\tif normal.Contains(e) != small.Contains(e) {\n+\t\t\t\t\t\t\tt.Errorf(\"contains(%v) mismatch after ops %s: normal=%v, small=%v\", e, name(), normal.Contains(e), small.Contains(e))\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #1552\n\n---\n\nChoice A:\nnet/netmon/state.go\n@@ -27,8 +27,9 @@ import (\n // same interface and subnet.\n var forceAllIPv6Endpoints = envknob.RegisterBool(\"TS_DEBUG_FORCE_ALL_IPV6_ENDPOINTS\")\n \n-// set a debug knob to exclude interfaces from the list of interfaces\n-var excludedInterfaces = envknob.RegisterString(\"TS_DEBUG_EXCLUDED_INTERFACES\")\n+// suppressInterfaces is a debug knob containing a list of interface names that should not be advertised as endpoints. \n+// Traffic may still flow over these interfaces if system routing makes the decision to do so.\n+var excludeInterfaces = envknob.RegisterString(\"TS_DEBUG_EXCLUDE_INTERFACES\")\n \n // LoginEndpointForProxyDetermination is the URL used for testing\n // which HTTP proxy the system should use.\n@@ -54,7 +55,7 @@ func isExcludedInterface(nif *net.Interface) bool {\n \t\treturn false\n \t}\n \n-\tremain := excludedInterfaces()\n+\tremain := excludeInterfaces()\n \tfor remain != \"\" {\n \t\tvar candidate string\n \t\tcandidate, remain, _ = strings.Cut(remain, \",\")\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/peerapi.go\n@@ -417,7 +417,7 @@ func (h *peerAPIHandler) handleServeIngress(w http.ResponseWriter, r *http.Reque\n \t}\n \tlogAndError := func(code int, publicMsg string) {\n \t\th.logf(\"ingress: bad request from %v: %s\", h.remoteAddr, publicMsg)\n-\t\thttp.Error(w, publicMsg, http.StatusMethodNotAllowed)\n+\t\thttp.Error(w, publicMsg, code)\n \t}\n \tbad := func(publicMsg string) {\n \t\tlogAndError(http.StatusBadRequest, publicMsg)\n---\n\n\n---\n\nChoice C:\ntypes/logger/logger.go\n@@ -323,6 +323,7 @@ func (fn ArgWriter) Format(f fmt.State, _ rune) {\n \tbw.Reset(f)\n \tfn(bw)\n \tbw.Flush()\n+\tbw.Reset(io.Discard)\n \targBufioPool.Put(bw)\n }\n \n---\n\n\n---\n\nChoice D:\ngo.toolchain.rev\n@@ -1 +1 @@\n-4fdaeeb8fe43bcdb4e8cc736433b9cd9c0ddd221\n+16b6e4fd15c59336156cdbc977de1745ad094f2d\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps Ubuntu version for test container images 22.04 -> 24.04.\r\n\r\n(Could also change to `ubuntu-latest`, but it seems not a bad thing to be aware when versions change)\r\n\r\nUpdates#cleanup\n\n---\n\nChoice A:\nipn/ipnlocal/local_test.go\n@@ -15,7 +15,6 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n-\t\"runtime\"\n \t\"slices\"\n \t\"strings\"\n \t\"sync\"\n@@ -2597,9 +2596,6 @@ func TestPreferencePolicyInfo(t *testing.T) {\n }\n \n func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n-\tif runtime.GOOS == \"darwin\" {\n-\t\tt.Skip(\"test known broken on macOS; see https://github.com/tailscale/tailscale/issues/15691\")\n-\t}\n \ttests := []struct {\n \t\tbefore, after  opt.Bool\n \t\tcontainer      opt.Bool\n@@ -2669,7 +2665,7 @@ func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n \t\t\t// On platforms that don't support auto-update we can never\n \t\t\t// transition to auto-updates being enabled. The value should\n \t\t\t// remain unchanged after onTailnetDefaultAutoUpdate.\n-\t\t\tif !clientupdate.CanAutoUpdate() && want.EqualBool(true) {\n+\t\t\tif !clientupdate.CanAutoUpdate() {\n \t\t\t\twant = tt.before\n \t\t\t}\n \t\t\tif got := b.pm.CurrentPrefs().AutoUpdate().Apply; got != want {\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/drive.go\n@@ -4,6 +4,7 @@\n package ipnlocal\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"slices\"\n@@ -338,7 +339,7 @@ func (b *LocalBackend) driveRemotesFromPeers(nm *netmap.NetworkMap) []*drive.Rem\n \t\t\t\t// Check that the peer is allowed to share with us.\n \t\t\t\taddresses := peer.Addresses()\n \t\t\t\tfor _, p := range addresses.All() {\n-\t\t\t\t\tif cn.PeerHasCap(p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n+\t\t\t\t\tif cn.PeerHasCap(context.Background(), p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n---\nipn/ipnlocal/local.go\n@@ -96,6 +96,7 @@ import (\n \t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/util/clientmetric\"\n+\t\"tailscale.com/util/ctxkey\"\n \t\"tailscale.com/util/deephash\"\n \t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/goroutines\"\n@@ -1463,15 +1464,19 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+var nodeCtxLockedKey = ctxkey.New(\"localNodeContext-locked\", false)\n+\n+var ctxNodeContextLocked = nodeCtxLockedKey.WithValue(context.Background(), true)\n+\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(context.Context, tailcfg.NodeView) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tif pred(ctxNodeContextLocked, peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n@@ -6652,9 +6657,11 @@ func (b *LocalBackend) TestOnlyPublicKeys() (machineKey key.MachinePublic, nodeK\n \n // PeerHasCap reports whether the peer with the given Tailscale IP addresses\n // contains the given capability string, with any value(s).\n-func (b *localNodeContext) PeerHasCap(addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n-\tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n+func (b *localNodeContext) PeerHasCap(ctx context.Context, addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n+\tif !nodeCtxLockedKey.Value(ctx) {\n+\t\tb.mu.Lock()\n+\t\tdefer b.mu.Unlock()\n+\t}\n \treturn b.peerHasCapLocked(addr, wantCap)\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n+\tpeers := cn.AppendMatchingPeers(nil, func(ctx context.Context, p tailcfg.NodeView) bool {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n \t\tif self != p.User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(ctx, p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n@@ -241,7 +241,7 @@ func (b *LocalBackend) taildropTargetStatus(p tailcfg.NodeView) ipnstate.Taildro\n \t}\n \tif nm.User() != p.User() {\n \t\t// Different user must have the explicit file sharing target capability\n-\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(context.Background(), p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn ipnstate.TaildropTargetOwnedByOtherUser\n \t\t}\n---\n\n\n---\n\nChoice C:\ntstest/integration/testcontrol/testcontrol.go\n@@ -839,15 +839,17 @@ func (s *Server) serveMap(w http.ResponseWriter, r *http.Request, mkey key.Machi\n \n \tw.WriteHeader(200)\n \tfor {\n-\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n-\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n-\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif streaming {\n+\t\t// Only send raw map responses to the streaming poll, to avoid a\n+\t\t// non-streaming map request beating the streaming poll in a race and\n+\t\t// potentially dropping the map response.\n+\t\tif streaming {\n+\t\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n+\t\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n+\t\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treturn\n \t\t}\n \n \t\tif s.canGenerateAutomaticMapResponseFor(req.NodeKey) {\n---\n\n\n---\n\nChoice D:\n.github/workflows/test.yml\n@@ -39,7 +39,7 @@ concurrency:\n \n jobs:\n   race-root-integration:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     strategy:\n       fail-fast: false # don't abort the entire matrix if one element fails\n       matrix:\n@@ -74,7 +74,7 @@ jobs:\n             buildflags: \"-race\"\n             shard: '3/3'\n           - goarch: \"386\" # thanks yaml\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -187,7 +187,7 @@ jobs:\n         find $(go env GOMODCACHE)/cache -type f -mmin +90 -delete\n \n   privileged:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     container:\n       image: golang:latest\n       options: --privileged\n@@ -214,7 +214,7 @@ jobs:\n         XDG_CACHE_HOME: \"/var/lib/ghrunner/cache\"\n \n   race-build:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -258,7 +258,7 @@ jobs:\n           - goos: openbsd\n             goarch: amd64\n \n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -300,7 +300,7 @@ jobs:\n \n   ios: # similar to cross above, but iOS can't build most of the repo. So, just\n        #make it build a few smoke packages.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -328,7 +328,7 @@ jobs:\n           - goos: illumos\n             goarch: amd64\n \n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -366,7 +366,7 @@ jobs:\n     # similar to cross above, but android fails to build a few pieces of the\n     # repo. We should fix those pieces, they're small, but as a stepping stone,\n     # only test the subset of android that our past smoke test checked.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -381,7 +381,7 @@ jobs:\n         GOARCH: arm64\n \n   wasm: # builds tsconnect, which is the only wasm build we support\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -420,7 +420,7 @@ jobs:\n         find $(go env GOMODCACHE)/cache -type f -mmin +90 -delete\n \n   tailscale_go: # Subset of tests that depend on our custom Go toolchain.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -440,7 +440,7 @@ jobs:\n     # explicit 'if' condition, because the default condition for steps is\n     # 'success()', meaning \"only run this if no previous steps failed\".\n     if: github.event_name == 'pull_request'\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: build fuzzers\n       id: build\n@@ -492,7 +492,7 @@ jobs:\n         path: ${{ env.artifacts_path }}/out/artifacts\n \n   depaware:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -501,7 +501,7 @@ jobs:\n         make depaware\n \n   go_generate:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -514,7 +514,7 @@ jobs:\n         git diff --name-only --exit-code || (echo \"The files above need updating. Please run 'go generate'.\"; exit 1)\n \n   go_mod_tidy:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -526,15 +526,15 @@ jobs:\n         git diff --name-only --exit-code || (echo \"Please run 'go mod tidy'.\"; exit 1)\n \n   licenses:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: check licenses\n       run: ./scripts/check_license_headers.sh .\n \n   staticcheck:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     strategy:\n       fail-fast: false # don't abort the entire matrix if one element fails\n       matrix:\n@@ -575,7 +575,7 @@ jobs:\n       - go_mod_tidy\n       - licenses\n       - staticcheck\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: notify  \n       # Only notify slack for merged commits, not PR failures.\n@@ -604,7 +604,7 @@ jobs:\n \n   check_mergeability:\n     if: always()\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     needs:\n       - android\n       - test\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFix the wireshark lua dissector to support 0 bit position and not throw modulo div by 0 errors.\r\n\r\nAdd new disco frame types to the decoder.\r\n\r\nUpdates tailscale/corp#29036\n\n---\n\nChoice A:\nclient/web/package.json\n@@ -3,7 +3,7 @@\n   \"version\": \"0.0.1\",\n   \"license\": \"BSD-3-Clause\",\n   \"engines\": {\n-    \"node\": \"18.20.4\",\n+    \"node\": \"22.14.0\",\n     \"yarn\": \"1.22.19\"\n   },\n   \"type\": \"module\",\n@@ -20,7 +20,7 @@\n     \"zustand\": \"^4.4.7\"\n   },\n   \"devDependencies\": {\n-    \"@types/node\": \"^18.16.1\",\n+    \"@types/node\": \"^22.14.0\",\n     \"@types/react\": \"^18.0.20\",\n     \"@types/react-dom\": \"^18.0.6\",\n     \"@vitejs/plugin-react-swc\": \"^3.6.0\",\n---\nclient/web/yarn.lock\n@@ -1880,12 +1880,12 @@\n   resolved \"https://registry.yarnpkg.com/@types/json5/-/json5-0.0.29.tgz#ee28707ae94e11d2b827bcbe5270bcea7f3e71ee\"\n   integrity sha512-dRLjCWHYg4oaA77cxO64oO+7JwCwnIzkZPdrrC71jQmQtlhM556pwKo5bUzqvZndkVbeFLIIi+9TC40JNF5hNQ==\n \n-\"@types/node@^18.16.1\":\n-  version \"18.19.18\"\n-  resolved \"https://registry.yarnpkg.com/@types/node/-/node-18.19.18.tgz#7526471b28828d1fef1f7e4960fb9477e6e4369c\"\n-  integrity sha512-80CP7B8y4PzZF0GWx15/gVWRrB5y/bIjNI84NK3cmQJu0WZwvmj2WMA5LcofQFVfLqqCSp545+U2LsrVzX36Zg==\n+\"@types/node@^22.14.0\":\n+  version \"22.14.0\"\n+  resolved \"https://registry.yarnpkg.com/@types/node/-/node-22.14.0.tgz#d3bfa3936fef0dbacd79ea3eb17d521c628bb47e\"\n+  integrity sha512-Kmpl+z84ILoG+3T/zQFyAJsU6EPTmOCj8/2+83fSN6djd6I4o7uOuGIH6vq3PrjY5BGitSbFuMN18j3iknubbA==\n   dependencies:\n-    undici-types \"~5.26.4\"\n+    undici-types \"~6.21.0\"\n \n \"@types/parse-json@^4.0.0\":\n   version \"4.0.2\"\n@@ -5124,10 +5124,10 @@ unbox-primitive@^1.0.2:\n     has-symbols \"^1.0.3\"\n     which-boxed-primitive \"^1.0.2\"\n \n-undici-types@~5.26.4:\n-  version \"5.26.5\"\n-  resolved \"https://registry.yarnpkg.com/undici-types/-/undici-types-5.26.5.tgz#bcd539893d00b56e964fd2657a4866b221a65617\"\n-  integrity sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA==\n+undici-types@~6.21.0:\n+  version \"6.21.0\"\n+  resolved \"https://registry.yarnpkg.com/undici-types/-/undici-types-6.21.0.tgz#691d00af3909be93a7faa13be61b3a5b50ef12cb\"\n+  integrity sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==\n \n unicode-canonical-property-names-ecmascript@^2.0.0:\n   version \"2.0.0\"\n---\ntool/node.rev\n@@ -1 +1 @@\n-18.20.4\n+22.14.0\n---\n\n\n---\n\nChoice B:\nwgengine/netstack/netstack.go\n@@ -326,10 +326,15 @@ func Create(logf logger.Logf, tundev *tstun.Wrapper, e wgengine.Engine, mc *magi\n \tif tcpipErr != nil {\n \t\treturn nil, fmt.Errorf(\"could not disable TCP RACK: %v\", tcpipErr)\n \t}\n-\tcubicOpt := tcpip.CongestionControlOption(\"cubic\")\n-\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &cubicOpt)\n+\t// gVisor defaults to reno at the time of writing. We explicitly set reno\n+\t// congestion control in order to prevent unexpected changes. Netstack\n+\t// has an int overflow in sender congestion window arithmetic that is more\n+\t// prone to trigger with cubic congestion control.\n+\t// See https://github.com/google/gvisor/issues/11632\n+\trenoOpt := tcpip.CongestionControlOption(\"reno\")\n+\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &renoOpt)\n \tif tcpipErr != nil {\n-\t\treturn nil, fmt.Errorf(\"could not set cubic congestion control: %v\", tcpipErr)\n+\t\treturn nil, fmt.Errorf(\"could not set reno congestion control: %v\", tcpipErr)\n \t}\n \terr := setTCPBufSizes(ipstack)\n \tif err != nil {\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local.go\n@@ -3289,14 +3289,24 @@ func (b *LocalBackend) popBrowserAuthNow(url string, keyExpired bool, recipient\n //\n // b.mu must *not* be held.\n func (b *LocalBackend) validPopBrowserURL(urlStr string) bool {\n+\tb.mu.Lock()\n+\tdefer b.mu.Unlock()\n+\treturn b.validPopBrowserURLLocked(urlStr)\n+}\n+\n+// validPopBrowserURLLocked reports whether urlStr is a valid value for a\n+// control server to send in a *URL field.\n+//\n+// b.mu must be held.\n+func (b *LocalBackend) validPopBrowserURLLocked(urlStr string) bool {\n \tif urlStr == \"\" {\n \t\treturn false\n \t}\n \tu, err := url.Parse(urlStr)\n \tif err != nil {\n \t\treturn false\n \t}\n-\tserverURL := b.Prefs().ControlURLOrDefault()\n+\tserverURL := b.sanitizedPrefsLocked().ControlURLOrDefault()\n \tif ipn.IsLoginServerSynonym(serverURL) {\n \t\t// When connected to the official Tailscale control plane, only allow\n \t\t// URLs from tailscale.com or its subdomains.\n@@ -5830,7 +5840,7 @@ func (b *LocalBackend) setNetMapLocked(nm *netmap.NetworkMap) {\n \tif nm != nil {\n \t\tmessages := make(map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage)\n \t\tfor id, msg := range nm.DisplayMessages {\n-\t\t\tif msg.PrimaryAction != nil && !b.validPopBrowserURL(msg.PrimaryAction.URL) {\n+\t\t\tif msg.PrimaryAction != nil && !b.validPopBrowserURLLocked(msg.PrimaryAction.URL) {\n \t\t\t\tmsg.PrimaryAction = nil\n \t\t\t}\n \t\t\tmessages[id] = msg\n---\nipn/ipnlocal/local_test.go\n@@ -5374,6 +5374,7 @@ func TestDisplayMessagesURLFilter(t *testing.T) {\n \tht.SetIPNState(\"NeedsLogin\", true)\n \tht.GotStreamedMapResponse()\n \n+\tdefer b.lockAndGetUnlock()()\n \tb.setNetMapLocked(&netmap.NetworkMap{\n \t\tDisplayMessages: map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n \t\t\t\"test-message\": {\n---\n\n\n---\n\nChoice D:\nfeature/capture/dissector/ts-dissector.lua\n@@ -1,5 +1,5 @@\n function hasbit(x, p)\n-  return x % (p + p) >= p       \n+  return bit.band(x, p) ~= 0\n end\n \n tsdebug_ll = Proto(\"tsdebug\", \"Tailscale debug\")\n@@ -128,6 +128,10 @@ function tsdisco_frame.dissector(buffer, pinfo, tree)\n     if     message_type == 1 then subtree:add(DISCO_TYPE, \"Ping\")\n     elseif message_type == 2 then subtree:add(DISCO_TYPE, \"Pong\")\n     elseif message_type == 3 then subtree:add(DISCO_TYPE, \"Call me maybe\")\n+    elseif message_type == 4 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint\")\n+    elseif message_type == 5 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint Challenge\")\n+    elseif message_type == 6 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint Answer\")\n+    elseif message_type == 7 then subtree:add(DISCO_TYPE, \"Call me maybe via\")\n     end\n \n     -- Message version\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIn accordance with the OIDC/OAuth 2.0 protocol, do not send an empty refresh_token and instead omit the field when empty.\r\n\r\nFixes https://github.com/tailscale/tailscale/issues/16073\n\n---\n\nChoice A:\nipn/ipnlocal/serve.go\n@@ -632,7 +632,7 @@ func (b *LocalBackend) getServeHandler(r *http.Request) (_ ipn.HTTPHandlerView,\n \n \thostname := r.Host\n \tif r.TLS == nil {\n-\t\ttcd := \".\" + b.Status().CurrentTailnet.MagicDNSSuffix\n+\t\ttcd := \".\" + b.CurrentProfile().NetworkProfile().MagicDNSName\n \t\tif host, _, err := net.SplitHostPort(hostname); err == nil {\n \t\t\thostname = host\n \t\t}\n---\n\n\n---\n\nChoice B:\ncmd/tsidp/tsidp.go\n@@ -795,7 +795,7 @@ type oidcTokenResponse struct {\n \tIDToken      string `json:\"id_token\"`\n \tTokenType    string `json:\"token_type\"`\n \tAccessToken  string `json:\"access_token\"`\n-\tRefreshToken string `json:\"refresh_token\"`\n+\tRefreshToken string `json:\"refresh_token,omitempty\"`\n \tExpiresIn    int    `json:\"expires_in\"`\n }\n \n---\n\n\n---\n\nChoice C:\nwgengine/magicsock/endpoint.go\n@@ -820,7 +820,7 @@ func (de *endpoint) heartbeat() {\n \n \tudpAddr, _, _ := de.addrForSendLocked(now)\n \tif udpAddr.IsValid() {\n-\t\t// We have a preferred path. Ping that every 2 seconds.\n+\t\t// We have a preferred path. Ping that every 'heartbeatInterval'.\n \t\tde.startDiscoPingLocked(udpAddr, now, pingHeartbeat, 0, nil)\n \t}\n \n---\n\n\n---\n\nChoice D:\ndocs/windows/policy/en-US/tailscale.adml\n@@ -16,6 +16,7 @@\n             <string id=\"SINCE_V1_62\">Tailscale version 1.62.0 and later</string>\n             <string id=\"SINCE_V1_74\">Tailscale version 1.74.0 and later</string>\n             <string id=\"SINCE_V1_78\">Tailscale version 1.78.0 and later</string>\n+            <string id=\"SINCE_V1_80\">Tailscale version 1.80.0 and later</string>\n             <string id=\"SINCE_V1_82\">Tailscale version 1.82.0 and later</string>\n             <string id=\"SINCE_V1_84\">Tailscale version 1.84.0 and later</string>\n             <string id=\"Tailscale_Category\">Tailscale</string>\n@@ -271,6 +272,12 @@ If you enable this policy, the menu item will be displayed indicating the organi\n If you disable this policy or do not configure it, the corresponding menu item will be hidden.\n \n See https://tailscale.com/kb/1315/mdm-keys#set-your-organization-name for more details.]]></string>\n+            <string id=\"OnboardingFlow\">Show the onboarding flow</string>\n+            <string id=\"OnboardingFlow_Help\"><![CDATA[This policy can be used to show or hide the onboarding flow displayed by the GUI.\n+\n+If you enable or don't configure this policy, the onboarding flow will be shown to new users who have not yet signed in to a Tailscale account.\n+\n+If you disable this policy, the onboarding flow will never be shown.]]></string>\n         </stringTable>\n         <presentationTable>\n             <presentation id=\"LoginURL\">\n---\ndocs/windows/policy/tailscale.admx\n@@ -54,6 +54,10 @@\n                   displayName=\"$(string.SINCE_V1_78)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n       </definition>\n+      <definition name=\"SINCE_V1_80\"\n+                  displayName=\"$(string.SINCE_V1_80)\">\n+        <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n+      </definition>\n       <definition name=\"SINCE_V1_82\"\n                   displayName=\"$(string.SINCE_V1_82)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n@@ -335,6 +339,16 @@\n         <string>hide</string>\n       </disabledValue>\n     </policy>\n+    <policy name=\"OnboardingFlow\" class=\"Both\" displayName=\"$(string.OnboardingFlow)\" explainText=\"$(string.OnboardingFlow_Help)\" key=\"Software\\Policies\\Tailscale\" valueName=\"OnboardingFlow\">\n+      <parentCategory ref=\"UI_Category\" />\n+      <supportedOn ref=\"SINCE_V1_80\" />\n+      <enabledValue>\n+        <string>show</string>\n+      </enabledValue>\n+      <disabledValue>\n+        <string>hide</string>\n+      </disabledValue>\n+    </policy>\n     <policy name=\"ManagedBy\" class=\"Both\" displayName=\"$(string.ManagedBy)\" explainText=\"$(string.ManagedBy_Help)\" presentation=\"$(presentation.ManagedBy)\" key=\"Software\\Policies\\Tailscale\">\n       <parentCategory ref=\"UI_Category\" />\n       <supportedOn ref=\"SINCE_V1_62\" />\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates https://github.com/tailscale/corp/issues/28916\n\n---\n\nChoice A:\nipn/conf.go\n@@ -145,9 +145,15 @@ func (c *ConfigVAlpha) ToPrefs() (MaskedPrefs, error) {\n \t\tmp.AppConnector = *c.AppConnector\n \t\tmp.AppConnectorSet = true\n \t}\n+\t// Configfile should be the source of truth for whether this node\n+\t// advertises any services.  We need to ensure that each reload updates\n+\t// currently advertised services as else the transition from 'some\n+\t// services are advertised' to 'advertised services are empty/unset in\n+\t// conffile' would have no effect (especially given that an empty\n+\t// service slice would be omitted from the JSON config).\n+\tmp.AdvertiseServicesSet = true\n \tif c.AdvertiseServices != nil {\n \t\tmp.AdvertiseServices = c.AdvertiseServices\n-\t\tmp.AdvertiseServicesSet = true\n \t}\n \treturn mp, nil\n }\n---\nipn/ipnlocal/local_test.go\n@@ -4745,32 +4745,133 @@ func TestLoginNotifications(t *testing.T) {\n // TestConfigFileReload tests that the LocalBackend reloads its configuration\n // when the configuration file changes.\n func TestConfigFileReload(t *testing.T) {\n-\tcfg1 := `{\"Hostname\": \"foo\", \"Version\": \"alpha0\"}`\n-\tf := filepath.Join(t.TempDir(), \"cfg\")\n-\tmust.Do(os.WriteFile(f, []byte(cfg1), 0600))\n-\tsys := new(tsd.System)\n-\tsys.InitialConfig = must.Get(conffile.Load(f))\n-\tlb := newTestLocalBackendWithSys(t, sys)\n-\tmust.Do(lb.Start(ipn.Options{}))\n-\n-\tlb.mu.Lock()\n-\thn := lb.hostinfo.Hostname\n-\tlb.mu.Unlock()\n-\tif hn != \"foo\" {\n-\t\tt.Fatalf(\"got %q; want %q\", hn, \"foo\")\n+\ttype testCase struct {\n+\t\tname    string\n+\t\tinitial *conffile.Config\n+\t\tupdated *conffile.Config\n+\t\tcheckFn func(*testing.T, *LocalBackend)\n \t}\n \n-\tcfg2 := `{\"Hostname\": \"bar\", \"Version\": \"alpha0\"}`\n-\tmust.Do(os.WriteFile(f, []byte(cfg2), 0600))\n-\tif !must.Get(lb.ReloadConfig()) {\n-\t\tt.Fatal(\"reload failed\")\n+\ttests := []testCase{\n+\t\t{\n+\t\t\tname: \"hostname_change\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:  \"alpha0\",\n+\t\t\t\t\tHostname: ptr.To(\"initial-host\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:  \"alpha0\",\n+\t\t\t\t\tHostname: ptr.To(\"updated-host\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif got := b.Prefs().Hostname(); got != \"updated-host\" {\n+\t\t\t\t\tt.Errorf(\"hostname = %q; want updated-host\", got)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"start_advertising_services\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion: \"alpha0\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\", \"svc:def\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif got := b.Prefs().AdvertiseServices().AsSlice(); !reflect.DeepEqual(got, []string{\"svc:abc\", \"svc:def\"}) {\n+\t\t\t\t\tt.Errorf(\"AdvertiseServices = %v; want [svc:abc, svc:def]\", got)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"change_advertised_services\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\", \"svc:def\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\", \"svc:ghi\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif got := b.Prefs().AdvertiseServices().AsSlice(); !reflect.DeepEqual(got, []string{\"svc:abc\", \"svc:ghi\"}) {\n+\t\t\t\t\tt.Errorf(\"AdvertiseServices = %v; want [svc:abc, svc:ghi]\", got)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"unset_advertised_services\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion: \"alpha0\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif b.Prefs().AdvertiseServices().Len() != 0 {\n+\t\t\t\t\tt.Errorf(\"got %d AdvertiseServices wants none\", b.Prefs().AdvertiseServices().Len())\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n \t}\n \n-\tlb.mu.Lock()\n-\thn = lb.hostinfo.Hostname\n-\tlb.mu.Unlock()\n-\tif hn != \"bar\" {\n-\t\tt.Fatalf(\"got %q; want %q\", hn, \"bar\")\n+\tfor _, tc := range tests {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tdir := t.TempDir()\n+\t\t\tpath := filepath.Join(dir, \"tailscale.conf\")\n+\n+\t\t\t// Write initial config\n+\t\t\tinitialJSON, err := json.Marshal(tc.initial.Parsed)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif err := os.WriteFile(path, initialJSON, 0644); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\n+\t\t\t// Create backend with initial config\n+\t\t\ttc.initial.Path = path\n+\t\t\ttc.initial.Raw = initialJSON\n+\t\t\tsys := &tsd.System{\n+\t\t\t\tInitialConfig: tc.initial,\n+\t\t\t}\n+\t\t\tb := newTestLocalBackendWithSys(t, sys)\n+\n+\t\t\t// Update config file\n+\t\t\tupdatedJSON, err := json.Marshal(tc.updated.Parsed)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif err := os.WriteFile(path, updatedJSON, 0644); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\n+\t\t\t// Trigger reload\n+\t\t\tif ok, err := b.ReloadConfig(); !ok || err != nil {\n+\t\t\t\tt.Fatalf(\"ReloadConfig() = %v, %v; want true, nil\", ok, err)\n+\t\t\t}\n+\n+\t\t\t// Check outcome\n+\t\t\ttc.checkFn(t, b)\n+\t\t})\n \t}\n }\n \n---\n\n\n---\n\nChoice B:\ncmd/k8s-operator/deploy/crds/tailscale.com_connectors.yaml\n@@ -32,6 +32,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_dnsconfigs.yaml\n@@ -20,6 +20,9 @@ spec:\n           jsonPath: .status.nameserver.ip\n           name: NameserverIP\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -18,6 +18,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxygroups.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .spec.type\n           name: Type\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_recorders.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .status.devices[?(@.url != \"\")].url\n           name: URL\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -61,6 +61,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -312,6 +315,9 @@ spec:\n               jsonPath: .status.nameserver.ip\n               name: NameserverIP\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -492,6 +498,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -2803,6 +2812,9 @@ spec:\n               jsonPath: .spec.type\n               name: Type\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -3013,6 +3025,9 @@ spec:\n               jsonPath: .status.devices[?(@.url != \"\")].url\n               name: URL\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n---\nk8s-operator/apis/v1alpha1/types_connector.go\n@@ -24,6 +24,7 @@ var ConnectorKind = \"Connector\"\n // +kubebuilder:printcolumn:name=\"IsExitNode\",type=\"string\",JSONPath=`.status.isExitNode`,description=\"Whether this Connector instance defines an exit node.\"\n // +kubebuilder:printcolumn:name=\"IsAppConnector\",type=\"string\",JSONPath=`.status.isAppConnector`,description=\"Whether this Connector instance is an app connector.\"\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ConnectorReady\")].reason`,description=\"Status of the deployed Connector resources.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Connector defines a Tailscale node that will be deployed in the cluster. The\n // node can be configured to act as a Tailscale subnet router and/or a Tailscale\n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -16,6 +16,7 @@ var ProxyClassKind = \"ProxyClass\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyClassReady\")].reason`,description=\"Status of the ProxyClass.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyClass describes a set of configuration parameters that can be applied to\n // proxy resources created by the Tailscale Kubernetes operator.\n---\nk8s-operator/apis/v1alpha1/types_proxygroup.go\n@@ -14,6 +14,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=pg\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyGroupReady\")].reason`,description=\"Status of the deployed ProxyGroup resources.\"\n // +kubebuilder:printcolumn:name=\"Type\",type=\"string\",JSONPath=`.spec.type`,description=\"ProxyGroup type.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyGroup defines a set of Tailscale devices that will act as proxies.\n // Currently only egress ProxyGroups are supported.\n---\nk8s-operator/apis/v1alpha1/types_recorder.go\n@@ -15,6 +15,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=rec\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"RecorderReady\")].reason`,description=\"Status of the deployed Recorder resources.\"\n // +kubebuilder:printcolumn:name=\"URL\",type=\"string\",JSONPath=`.status.devices[?(@.url != \"\")].url`,description=\"URL on which the UI is exposed if enabled.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Recorder defines a tsrecorder device for recording SSH sessions. By default,\n // it will store recordings in a local ephemeral volume. If you want to persist\n---\nk8s-operator/apis/v1alpha1/types_tsdnsconfig.go\n@@ -18,6 +18,7 @@ var DNSConfigKind = \"DNSConfig\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster,shortName=dc\n // +kubebuilder:printcolumn:name=\"NameserverIP\",type=\"string\",JSONPath=`.status.nameserver.ip`,description=\"Service IP address of the nameserver\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // DNSConfig can be deployed to cluster to make a subset of Tailscale MagicDNS\n // names resolvable by cluster workloads. Use this if: A) you need to refer to\n---\n\n\n---\n\nChoice C:\ngo.toolchain.rev\n@@ -1 +1 @@\n-982da8f24fa0504f2214f24b0d68b2febd5983f8\n+98e8c99c256a5aeaa13725d2e43fdd7f465ba200\n---\n\n\n---\n\nChoice D:\nclientupdate/clientupdate_windows.go\n@@ -16,6 +16,7 @@ import (\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"strings\"\n+\t\"time\"\n \n \t\"github.com/google/uuid\"\n \t\"golang.org/x/sys/windows\"\n@@ -34,6 +35,12 @@ const (\n \t// It is used to re-launch the GUI process (tailscale-ipn.exe) after\n \t// install is complete.\n \twinExePathEnv = \"TS_UPDATE_WIN_EXE_PATH\"\n+\t// winVersionEnv is the environment variable that is set along with\n+\t// winMSIEnv and carries the version of tailscale that is being installed.\n+\t// It is used for logging purposes.\n+\twinVersionEnv = \"TS_UPDATE_WIN_VERSION\"\n+\t// updaterPrefix is the prefix for the temporary executable created by [makeSelfCopy].\n+\tupdaterPrefix = \"tailscale-updater\"\n )\n \n func makeSelfCopy() (origPathExe, tmpPathExe string, err error) {\n@@ -46,7 +53,7 @@ func makeSelfCopy() (origPathExe, tmpPathExe string, err error) {\n \t\treturn \"\", \"\", err\n \t}\n \tdefer f.Close()\n-\tf2, err := os.CreateTemp(\"\", \"tailscale-updater-*.exe\")\n+\tf2, err := os.CreateTemp(\"\", updaterPrefix+\"-*.exe\")\n \tif err != nil {\n \t\treturn \"\", \"\", err\n \t}\n@@ -137,7 +144,7 @@ you can run the command prompt as Administrator one of these ways:\n \tup.Logf(\"authenticode verification succeeded\")\n \n \tup.Logf(\"making tailscale.exe copy to switch to...\")\n-\tup.cleanupOldDownloads(filepath.Join(os.TempDir(), \"tailscale-updater-*.exe\"))\n+\tup.cleanupOldDownloads(filepath.Join(os.TempDir(), updaterPrefix+\"-*.exe\"))\n \tselfOrig, selfCopy, err := makeSelfCopy()\n \tif err != nil {\n \t\treturn err\n@@ -146,7 +153,7 @@ you can run the command prompt as Administrator one of these ways:\n \tup.Logf(\"running tailscale.exe copy for final install...\")\n \n \tcmd := exec.Command(selfCopy, \"update\")\n-\tcmd.Env = append(os.Environ(), winMSIEnv+\"=\"+msiTarget, winExePathEnv+\"=\"+selfOrig)\n+\tcmd.Env = append(os.Environ(), winMSIEnv+\"=\"+msiTarget, winExePathEnv+\"=\"+selfOrig, winVersionEnv+\"=\"+ver)\n \tcmd.Stdout = up.Stderr\n \tcmd.Stderr = up.Stderr\n \tcmd.Stdin = os.Stdin\n@@ -162,23 +169,62 @@ you can run the command prompt as Administrator one of these ways:\n func (up *Updater) installMSI(msi string) error {\n \tvar err error\n \tfor tries := 0; tries < 2; tries++ {\n-\t\tcmd := exec.Command(\"msiexec.exe\", \"/i\", filepath.Base(msi), \"/quiet\", \"/norestart\", \"/qn\")\n+\t\t// msiexec.exe requires exclusive access to the log file, so create a dedicated one for each run.\n+\t\tinstallLogPath := up.startNewLogFile(\"tailscale-installer\", os.Getenv(winVersionEnv))\n+\t\tup.Logf(\"Install log: %s\", installLogPath)\n+\t\tcmd := exec.Command(\"msiexec.exe\", \"/i\", filepath.Base(msi), \"/quiet\", \"/norestart\", \"/qn\", \"/L*v\", installLogPath)\n \t\tcmd.Dir = filepath.Dir(msi)\n \t\tcmd.Stdout = up.Stdout\n \t\tcmd.Stderr = up.Stderr\n \t\tcmd.Stdin = os.Stdin\n \t\terr = cmd.Run()\n-\t\tif err == nil {\n-\t\t\tbreak\n+\t\tswitch err := err.(type) {\n+\t\tcase nil:\n+\t\t\t// Success.\n+\t\t\treturn nil\n+\t\tcase *exec.ExitError:\n+\t\t\t// For possible error codes returned by Windows Installer, see\n+\t\t\t// https://web.archive.org/web/20250409144914/https://learn.microsoft.com/en-us/windows/win32/msi/error-codes\n+\t\t\tswitch windows.Errno(err.ExitCode()) {\n+\t\t\tcase windows.ERROR_SUCCESS_REBOOT_REQUIRED:\n+\t\t\t\t// In most cases, updating Tailscale should not require a reboot.\n+\t\t\t\t// If it does, it might be because we failed to close the GUI\n+\t\t\t\t// and the installer couldn't replace tailscale-ipn.exe.\n+\t\t\t\t// The old GUI will continue to run until the next reboot.\n+\t\t\t\t// Not ideal, but also not a retryable error.\n+\t\t\t\tup.Logf(\"[unexpected] reboot required\")\n+\t\t\t\treturn nil\n+\t\t\tcase windows.ERROR_SUCCESS_REBOOT_INITIATED:\n+\t\t\t\t// Same as above, but perhaps the device is configured to prompt\n+\t\t\t\t// the user to reboot and the user has chosen to reboot now.\n+\t\t\t\tup.Logf(\"[unexpected] reboot initiated\")\n+\t\t\t\treturn nil\n+\t\t\tcase windows.ERROR_INSTALL_ALREADY_RUNNING:\n+\t\t\t\t// The Windows Installer service is currently busy.\n+\t\t\t\t// It could be our own install initiated by user/MDM/GP, another MSI install or perhaps a Windows Update install.\n+\t\t\t\t// Anyway, we can't do anything about it right now. The user (or tailscaled) can retry later.\n+\t\t\t\t// Retrying now will likely fail, and is risky since we might uninstall the current version\n+\t\t\t\t// and then fail to install the new one, leaving the user with no Tailscale at all.\n+\t\t\t\t//\n+\t\t\t\t// TODO(nickkhyl,awly): should we check if this is actually a downgrade before uninstalling the current version?\n+\t\t\t\t// Also, maybe keep retrying the install longer if we uninstalled the current version due to a failed install attempt?\n+\t\t\t\tup.Logf(\"another installation is already in progress\")\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\tdefault:\n+\t\t\t// Everything else is a retryable error.\n \t\t}\n+\n \t\tup.Logf(\"Install attempt failed: %v\", err)\n \t\tuninstallVersion := up.currentVersion\n \t\tif v := os.Getenv(\"TS_DEBUG_UNINSTALL_VERSION\"); v != \"\" {\n \t\t\tuninstallVersion = v\n \t\t}\n+\t\tuninstallLogPath := up.startNewLogFile(\"tailscale-uninstaller\", uninstallVersion)\n \t\t// Assume it's a downgrade, which msiexec won't permit. Uninstall our current version first.\n \t\tup.Logf(\"Uninstalling current version %q for downgrade...\", uninstallVersion)\n-\t\tcmd = exec.Command(\"msiexec.exe\", \"/x\", msiUUIDForVersion(uninstallVersion), \"/norestart\", \"/qn\")\n+\t\tup.Logf(\"Uninstall log: %s\", uninstallLogPath)\n+\t\tcmd = exec.Command(\"msiexec.exe\", \"/x\", msiUUIDForVersion(uninstallVersion), \"/norestart\", \"/qn\", \"/L*v\", uninstallLogPath)\n \t\tcmd.Stdout = up.Stdout\n \t\tcmd.Stderr = up.Stderr\n \t\tcmd.Stdin = os.Stdin\n@@ -205,12 +251,14 @@ func (up *Updater) switchOutputToFile() (io.Closer, error) {\n \tvar logFilePath string\n \texePath, err := os.Executable()\n \tif err != nil {\n-\t\tlogFilePath = filepath.Join(os.TempDir(), \"tailscale-updater.log\")\n+\t\tlogFilePath = up.startNewLogFile(updaterPrefix, os.Getenv(winVersionEnv))\n \t} else {\n-\t\tlogFilePath = strings.TrimSuffix(exePath, \".exe\") + \".log\"\n+\t\t// Use the same suffix as the self-copy executable.\n+\t\tsuffix := strings.TrimSuffix(strings.TrimPrefix(filepath.Base(exePath), updaterPrefix), \".exe\")\n+\t\tlogFilePath = up.startNewLogFile(updaterPrefix, os.Getenv(winVersionEnv)+suffix)\n \t}\n \n-\tup.Logf(\"writing update output to %q\", logFilePath)\n+\tup.Logf(\"writing update output to: %s\", logFilePath)\n \tlogFile, err := os.Create(logFilePath)\n \tif err != nil {\n \t\treturn nil, err\n@@ -223,3 +271,20 @@ func (up *Updater) switchOutputToFile() (io.Closer, error) {\n \tup.Stderr = logFile\n \treturn logFile, nil\n }\n+\n+// startNewLogFile returns a name for a new log file.\n+// It cleans up any old log files with the same baseNamePrefix.\n+func (up *Updater) startNewLogFile(baseNamePrefix, baseNameSuffix string) string {\n+\tbaseName := fmt.Sprintf(\"%s-%s-%s.log\", baseNamePrefix,\n+\t\ttime.Now().Format(\"20060102T150405\"), baseNameSuffix)\n+\n+\tdir := filepath.Join(os.Getenv(\"ProgramData\"), \"Tailscale\", \"Logs\")\n+\tif err := os.MkdirAll(dir, 0700); err != nil {\n+\t\tup.Logf(\"failed to create log directory: %v\", err)\n+\t\treturn filepath.Join(os.TempDir(), baseName)\n+\t}\n+\n+\t// TODO(nickkhyl): preserve up to N old log files?\n+\tup.cleanupOldDownloads(filepath.Join(dir, baseNamePrefix+\"-*.log\"))\n+\treturn filepath.Join(dir, baseName)\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nPreviously, a missing or invalid `dns` parameter on GET `/dns-query` returned only \u201cmissing \u2018dns\u2019 parameter\u201d. Now the error message guides users to `?dns=` or `?q=`.\r\n\r\nUpdates: #16055\n\n---\n\nChoice A:\ngo.toolchain.rev\n@@ -1 +1 @@\n-982da8f24fa0504f2214f24b0d68b2febd5983f8\n+98e8c99c256a5aeaa13725d2e43fdd7f465ba200\n---\n\n\n---\n\nChoice B:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/init@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/autobuild@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/analyze@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/peerapi.go\n@@ -859,7 +859,7 @@ func dohQuery(r *http.Request) (dnsQuery []byte, publicErr string) {\n \tcase \"GET\":\n \t\tq64 := r.FormValue(\"dns\")\n \t\tif q64 == \"\" {\n-\t\t\treturn nil, \"missing 'dns' parameter\"\n+\t\t\treturn nil, \"missing \u2018dns\u2019 parameter; try '?dns=' (DoH standard) or use '?q=<name>' for JSON debug mode\"\n \t\t}\n \t\tif base64.RawURLEncoding.DecodedLen(len(q64)) > maxQueryLen {\n \t\t\treturn nil, \"query too large\"\n---\n\n\n---\n\nChoice D:\nwgengine/magicsock/magicsock.go\n@@ -138,6 +138,7 @@ type Conn struct {\n \t// struct. Initialized once at construction, then constant.\n \n \teventBus               *eventbus.Bus\n+\teventClient            *eventbus.Client\n \tlogf                   logger.Logf\n \tepFunc                 func([]tailcfg.Endpoint)\n \tderpActiveFunc         func()\n@@ -547,6 +548,31 @@ func NewConn(opts Options) (*Conn, error) {\n \tc.testOnlyPacketListener = opts.TestOnlyPacketListener\n \tc.noteRecvActivity = opts.NoteRecvActivity\n \n+\t// If an event bus is enabled, subscribe to portmapping changes; otherwise\n+\t// use the callback mechanism of portmapper.Client.\n+\t//\n+\t// TODO(creachadair): Remove the switch once the event bus is mandatory.\n+\tonPortMapChanged := c.onPortMapChanged\n+\tif c.eventBus != nil {\n+\t\tc.eventClient = c.eventBus.Client(\"magicsock.Conn\")\n+\n+\t\tpmSub := eventbus.Subscribe[portmapper.Mapping](c.eventClient)\n+\t\tgo func() {\n+\t\t\tdefer pmSub.Close()\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase <-pmSub.Events():\n+\t\t\t\t\tc.onPortMapChanged()\n+\t\t\t\tcase <-pmSub.Done():\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\n+\t\t// Disable the explicit callback from the portmapper, the subscriber handles it.\n+\t\tonPortMapChanged = nil\n+\t}\n+\n \t// Don't log the same log messages possibly every few seconds in our\n \t// portmapper.\n \tportmapperLogf := logger.WithPrefix(c.logf, \"portmapper: \")\n@@ -560,7 +586,7 @@ func NewConn(opts Options) (*Conn, error) {\n \t\tNetMon:       opts.NetMon,\n \t\tDebugKnobs:   portMapOpts,\n \t\tControlKnobs: opts.ControlKnobs,\n-\t\tOnChange:     c.onPortMapChanged,\n+\t\tOnChange:     onPortMapChanged,\n \t})\n \tc.portMapper.SetGatewayLookupFunc(opts.NetMon.GatewayAndSelfIP)\n \tc.netMon = opts.NetMon\n@@ -2478,6 +2504,9 @@ func (c *connBind) Close() error {\n \tif c.closeDisco6 != nil {\n \t\tc.closeDisco6.Close()\n \t}\n+\tif c.eventClient != nil {\n+\t\tc.eventClient.Close()\n+\t}\n \t// Send an empty read result to unblock receiveDERP,\n \t// which will then check connBind.Closed.\n \t// connBind.Closed takes c.mu, but c.derpRecvCh is buffered.\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAs noted in #16048, the ./ssh/tailssh package failed to build on\nAndroid, because GOOS=android also matches the \"linux\" build\ntag. Exclude Android like iOS is excluded from macOS (darwin).\n\nThis now works:\n\n    $ GOOS=android go install ./ipn/ipnlocal ./ssh/tailssh\n\nThe original PR at #16048 is also fine, but this stops the problem\nearlier.\n\nUpdates #16048\n\n\n---\n\nChoice A:\n.github/workflows/test.yml\n@@ -305,7 +305,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: build some\n-      run: ./tool/go build ./ipn/... ./wgengine/ ./types/... ./control/controlclient\n+      run: ./tool/go build ./ipn/... ./ssh/tailssh ./wgengine/ ./types/... ./control/controlclient\n       env:\n         GOOS: ios\n         GOARCH: arm64\n@@ -375,7 +375,7 @@ jobs:\n       # some Android breakages early.\n       # TODO(bradfitz): better; see https://github.com/tailscale/tailscale/issues/4482\n     - name: build some\n-      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version\n+      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version ./ssh/tailssh\n       env:\n         GOOS: android\n         GOARCH: arm64\n---\nssh/tailssh/incubator.go\n@@ -7,7 +7,7 @@\n // and groups to the specified `--uid`, `--gid` and `--groups`, and\n // then launches the requested `--cmd`.\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd\n \n package tailssh\n \n---\nssh/tailssh/incubator_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package tailssh\n \n---\nssh/tailssh/tailssh.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n // Package tailssh is an SSH server integrated into Tailscale.\n package tailssh\n---\nssh/tailssh/user.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n package tailssh\n \n---\n\n\n---\n\nChoice B:\ncmd/natc/natc.go\n@@ -359,7 +359,7 @@ var tsMBox = dnsmessage.MustNewName(\"support.tailscale.com.\")\n // generateDNSResponse generates a DNS response for the given request. The from\n // argument is the NodeID of the node that sent the request.\n func (c *connector) generateDNSResponse(req *dnsmessage.Message, from tailcfg.NodeID) ([]byte, error) {\n-\tpm, _ := c.perPeerMap.LoadOrStore(from, &perPeerState{c: c})\n+\tpm, _ := c.perPeerMap.LoadOrStore(from, newPerPeerState(c))\n \tvar addrs []netip.Addr\n \tif len(req.Questions) > 0 {\n \t\tswitch req.Questions[0].Type {\n@@ -509,14 +509,22 @@ func proxyTCPConn(c net.Conn, dest string) {\n \n // perPeerState holds the state for a single peer.\n type perPeerState struct {\n-\tc *connector\n+\tv6ULA netip.Prefix\n+\tipset *netipx.IPSet\n \n \tmu           sync.Mutex\n \taddrInUse    *big.Int\n \tdomainToAddr map[string][]netip.Addr\n \taddrToDomain *bart.Table[string]\n }\n \n+func newPerPeerState(c *connector) *perPeerState {\n+\treturn &perPeerState{\n+\t\tipset: c.ipset,\n+\t\tv6ULA: c.v6ULA,\n+\t}\n+}\n+\n // domainForIP returns the domain name assigned to the given IP address and\n // whether it was found.\n func (ps *perPeerState) domainForIP(ip netip.Addr) (_ string, ok bool) {\n@@ -555,7 +563,7 @@ func (ps *perPeerState) unusedIPv4Locked() netip.Addr {\n \tif ps.addrInUse == nil {\n \t\tps.addrInUse = big.NewInt(0)\n \t}\n-\treturn allocAddr(ps.c.ipset, ps.addrInUse)\n+\treturn allocAddr(ps.ipset, ps.addrInUse)\n }\n \n // assignAddrsLocked assigns a pair of unique IP addresses for the given domain\n@@ -570,7 +578,7 @@ func (ps *perPeerState) assignAddrsLocked(domain string) []netip.Addr {\n \tif !v4.IsValid() {\n \t\treturn nil\n \t}\n-\tas16 := ps.c.v6ULA.Addr().As16()\n+\tas16 := ps.v6ULA.Addr().As16()\n \tas4 := v4.As4()\n \tcopy(as16[12:], as4[:])\n \tv6 := netip.AddrFrom16(as16)\n---\ncmd/natc/natc_test.go\n@@ -220,7 +220,7 @@ func TestPerPeerState(t *testing.T) {\n \t}\n \tc.setPrefixes([]netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")})\n \n-\tps := &perPeerState{c: c}\n+\tps := newPerPeerState(c)\n \n \taddrs, err := ps.ipForDomain(\"example.com\")\n \tif err != nil {\n@@ -360,7 +360,7 @@ func TestIPPoolExhaustion(t *testing.T) {\n \t}\n \tc.setPrefixes([]netip.Prefix{smallPrefix})\n \n-\tps := &perPeerState{c: c}\n+\tps := newPerPeerState(c)\n \n \tassignedIPs := make(map[netip.Addr]string)\n \n---\n\n\n---\n\nChoice C:\nbuild_dist.sh\n@@ -28,18 +28,26 @@ EOF\n \texit 0\n fi\n \n-tags=\"\"\n+tags=\"${TAGS:-}\"\n ldflags=\"-X tailscale.com/version.longStamp=${VERSION_LONG} -X tailscale.com/version.shortStamp=${VERSION_SHORT}\"\n \n # build_dist.sh arguments must precede go build arguments.\n while [ \"$#\" -gt 1 ]; do\n \tcase \"$1\" in\n \t--extra-small)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --extra-small or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\tldflags=\"$ldflags -w -s\"\n \t\ttags=\"${tags:+$tags,}ts_omit_aws,ts_omit_bird,ts_omit_tap,ts_omit_kube,ts_omit_completion,ts_omit_ssh,ts_omit_wakeonlan,ts_omit_capture\"\n \t\t;;\n \t--box)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --box or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\ttags=\"${tags:+$tags,}ts_include_cli\"\n \t\t;;\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -958,7 +958,9 @@ func (b *LocalBackend) linkChange(delta *netmon.ChangeDelta) {\n \n \tif peerAPIListenAsync && b.netMap != nil && b.state == ipn.Running {\n \t\twant := b.netMap.GetAddresses().Len()\n-\t\tif len(b.peerAPIListeners) < want {\n+\t\thave := len(b.peerAPIListeners)\n+\t\tb.logf(\"[v1] linkChange: have %d peerAPIListeners, want %d\", have, want)\n+\t\tif have < want {\n \t\t\tb.logf(\"linkChange: peerAPIListeners too low; trying again\")\n \t\t\tb.goTracker.Go(b.initPeerAPIListener)\n \t\t}\n@@ -5369,6 +5371,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n+\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nWhen it is built for Android, it will fail with the following error:\r\n\r\n```\r\nError: ssh/tailssh/tailssh.go:110:20: cannot use lb (variable of type *ipnlocal.LocalBackend) as ipnLocalBackend value in struct literal: *ipnlocal.LocalBackend does not implement ipnLocalBackend (missing method GetSSH_HostKeys)\r\n```\n\n---\n\nChoice A:\nipn/ipnlocal/ssh_stub.go\n@@ -8,6 +8,7 @@ package ipnlocal\n import (\n \t\"errors\"\n \n+\t\"golang.org/x/crypto/ssh\"\n \t\"tailscale.com/tailcfg\"\n )\n \n@@ -18,3 +19,7 @@ func (b *LocalBackend) getSSHHostKeyPublicStrings() ([]string, error) {\n func (b *LocalBackend) getSSHUsernames(*tailcfg.C2NSSHUsernamesRequest) (*tailcfg.C2NSSHUsernamesResponse, error) {\n \treturn nil, errors.New(\"not implemented\")\n }\n+\n+func (b *LocalBackend) GetSSH_HostKeys() (keys []ssh.Signer, err error) {\n+\treturn nil, errors.New(\"not implemented\")\n+}\n---\n\n\n---\n\nChoice B:\nprober/prober.go\n@@ -559,8 +559,8 @@ func (p *Prober) RunHandler(w http.ResponseWriter, r *http.Request) error {\n \t\t\tPreviousSuccessRatio:  prevInfo.RecentSuccessRatio(),\n \t\t\tPreviousMedianLatency: prevInfo.RecentMedianLatency(),\n \t\t}\n-\t\tw.WriteHeader(respStatus)\n \t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tw.WriteHeader(respStatus)\n \t\tif err := json.NewEncoder(w).Encode(resp); err != nil {\n \t\t\treturn tsweb.Error(http.StatusInternalServerError, \"error encoding JSON response\", err)\n \t\t}\n---\nprober/prober_test.go\n@@ -598,6 +598,9 @@ func TestProberRunHandler(t *testing.T) {\n \t\t\t\t}\n \n \t\t\t\tif reqJSON {\n+\t\t\t\t\tif w.Header().Get(\"Content-Type\") != \"application/json\" {\n+\t\t\t\t\t\tt.Errorf(\"unexpected content type: got %q, want application/json\", w.Header().Get(\"Content-Type\"))\n+\t\t\t\t\t}\n \t\t\t\t\tvar gotJSON RunHandlerResponse\n \t\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), &gotJSON); err != nil {\n \t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, w.Body.String())\n---\n\n\n---\n\nChoice C:\n.github/workflows/installer.yml\n@@ -1,6 +1,8 @@\n name: test installer.sh\n \n on:\n+  schedule:\n+    - cron: '0 15 * * *' # 10am EST (UTC-4/5)\n   push:\n     branches:\n       - \"main\"\n@@ -72,10 +74,10 @@ jobs:\n       # tar and gzip are needed by the actions/checkout below.\n       run: yum install -y --allowerasing tar gzip ${{ matrix.deps }}\n       if: |\n-        contains(matrix.image, 'centos')\n-        || contains(matrix.image, 'oraclelinux')\n-        || contains(matrix.image, 'fedora')\n-        || contains(matrix.image, 'amazonlinux')\n+        contains(matrix.image, 'centos') ||\n+        contains(matrix.image, 'oraclelinux') ||\n+        contains(matrix.image, 'fedora') ||\n+        contains(matrix.image, 'amazonlinux')\n     - name: install dependencies (zypper)\n       # tar and gzip are needed by the actions/checkout below.\n       run: zypper --non-interactive install tar gzip ${{ matrix.deps }}\n@@ -85,11 +87,11 @@ jobs:\n         apt-get update\n         apt-get install -y ${{ matrix.deps }}\n       if: |\n-        contains(matrix.image, 'debian')\n-        || contains(matrix.image, 'ubuntu')\n-        || contains(matrix.image, 'elementary')\n-        || contains(matrix.image, 'parrotsec')\n-        || contains(matrix.image, 'kalilinux')\n+        contains(matrix.image, 'debian') ||\n+        contains(matrix.image, 'ubuntu') ||\n+        contains(matrix.image, 'elementary') ||\n+        contains(matrix.image, 'parrotsec') ||\n+        contains(matrix.image, 'kalilinux')\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: run installer\n@@ -100,3 +102,30 @@ jobs:\n       continue-on-error: true\n     - name: check tailscale version\n       run: tailscale --version\n+  notify-slack:\n+    needs: test\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Notify Slack of failure on scheduled runs\n+        if: failure() && github.event_name == 'schedule'\n+        uses: slackapi/slack-github-action@485a9d42d3a73031f12ec201c457e2162c45d02d # v2.0.0\n+        with:\n+          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}\n+          webhook-type: incoming-webhook\n+          payload: |\n+            {\n+              \"attachments\": [{\n+                \"title\": \"Tailscale installer test failed\",\n+                \"title_link\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\n+                \"text\": \"One or more OSes in the test matrix failed. See the run for details.\",\n+                \"fields\": [\n+                  {\n+                    \"title\": \"Ref\",\n+                    \"value\": \"${{ github.ref_name }}\",\n+                    \"short\": true\n+                  }\n+                ],\n+                \"footer\": \"${{ github.workflow }} on schedule\",\n+                \"color\": \"danger\"\n+              }]\n+            }\n---\n\n\n---\n\nChoice D:\nipn/prefs.go\n@@ -607,9 +607,9 @@ func (p *Prefs) Equals(p2 *Prefs) bool {\n \t\tp.OperatorUser == p2.OperatorUser &&\n \t\tp.Hostname == p2.Hostname &&\n \t\tp.ForceDaemon == p2.ForceDaemon &&\n-\t\tcompareIPNets(p.AdvertiseRoutes, p2.AdvertiseRoutes) &&\n-\t\tcompareStrings(p.AdvertiseTags, p2.AdvertiseTags) &&\n-\t\tcompareStrings(p.AdvertiseServices, p2.AdvertiseServices) &&\n+\t\tslices.Equal(p.AdvertiseRoutes, p2.AdvertiseRoutes) &&\n+\t\tslices.Equal(p.AdvertiseTags, p2.AdvertiseTags) &&\n+\t\tslices.Equal(p.AdvertiseServices, p2.AdvertiseServices) &&\n \t\tp.Persist.Equals(p2.Persist) &&\n \t\tp.ProfileName == p2.ProfileName &&\n \t\tp.AutoUpdate.Equals(p2.AutoUpdate) &&\n@@ -636,30 +636,6 @@ func (ap AppConnectorPrefs) Pretty() string {\n \treturn \"\"\n }\n \n-func compareIPNets(a, b []netip.Prefix) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n-\tfor i := range a {\n-\t\tif a[i] != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-func compareStrings(a, b []string) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n-\tfor i := range a {\n-\t\tif a[i] != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n // NewPrefs returns the default preferences to use.\n func NewPrefs() *Prefs {\n \t// Provide default values for options which might be missing\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nheartbeatInterval is currently 3s.\r\n\r\nUpdates #cleanup\n\n---\n\nChoice A:\nwgengine/magicsock/endpoint.go\n@@ -552,7 +552,7 @@ func (de *endpoint) addrForSendLocked(now mono.Time) (udpAddr, derpAddr netip.Ad\n // addrForWireGuardSendLocked returns the address that should be used for\n // sending the next packet. If a packet has never or not recently been sent to\n // the endpoint, then a randomly selected address for the endpoint is returned,\n-// as well as a bool indiciating that WireGuard discovery pings should be started.\n+// as well as a bool indicating that WireGuard discovery pings should be started.\n // If the addresses have latency information available, then the address with the\n // best latency is used.\n //\n@@ -1261,7 +1261,7 @@ func (de *endpoint) sendDiscoPingsLocked(now mono.Time, sendCallMeMaybe bool) {\n }\n \n // sendWireGuardOnlyPingsLocked evaluates all available addresses for\n-// a WireGuard only endpoint and initates an ICMP ping for useable\n+// a WireGuard only endpoint and initiates an ICMP ping for useable\n // addresses.\n func (de *endpoint) sendWireGuardOnlyPingsLocked(now mono.Time) {\n \tif runtime.GOOS == \"js\" {\n@@ -1629,7 +1629,7 @@ func (de *endpoint) handlePongConnLocked(m *disco.Pong, di *discoInfo, src netip\n \t\t\tde.c.logf(\"magicsock: disco: node %v %v now using %v mtu=%v tx=%x\", de.publicKey.ShortString(), de.discoShort(), sp.to, thisPong.wireMTU, m.TxID[:6])\n \t\t\tde.debugUpdates.Add(EndpointChange{\n \t\t\t\tWhen: time.Now(),\n-\t\t\t\tWhat: \"handlePingLocked-bestAddr-update\",\n+\t\t\t\tWhat: \"handlePongConnLocked-bestAddr-update\",\n \t\t\t\tFrom: de.bestAddr,\n \t\t\t\tTo:   thisPong,\n \t\t\t})\n@@ -1638,7 +1638,7 @@ func (de *endpoint) handlePongConnLocked(m *disco.Pong, di *discoInfo, src netip\n \t\tif de.bestAddr.AddrPort == thisPong.AddrPort {\n \t\t\tde.debugUpdates.Add(EndpointChange{\n \t\t\t\tWhen: time.Now(),\n-\t\t\t\tWhat: \"handlePingLocked-bestAddr-latency\",\n+\t\t\t\tWhat: \"handlePongConnLocked-bestAddr-latency\",\n \t\t\t\tFrom: de.bestAddr,\n \t\t\t\tTo:   thisPong,\n \t\t\t})\n---\n\n\n---\n\nChoice B:\nwgengine/magicsock/endpoint.go\n@@ -820,7 +820,7 @@ func (de *endpoint) heartbeat() {\n \n \tudpAddr, _, _ := de.addrForSendLocked(now)\n \tif udpAddr.IsValid() {\n-\t\t// We have a preferred path. Ping that every 2 seconds.\n+\t\t// We have a preferred path. Ping that every 'heartbeatInterval'.\n \t\tde.startDiscoPingLocked(udpAddr, now, pingHeartbeat, 0, nil)\n \t}\n \n---\n\n\n---\n\nChoice C:\ngo.toolchain.rev\n@@ -1 +1 @@\n-982da8f24fa0504f2214f24b0d68b2febd5983f8\n+98e8c99c256a5aeaa13725d2e43fdd7f465ba200\n---\n\n\n---\n\nChoice D:\nrelease/dist/cli/cli.go\n@@ -65,6 +65,7 @@ func CLI(getTargets func() ([]dist.Target, error)) *ffcli.Command {\n \t\t\t\t\tfs.StringVar(&buildArgs.manifest, \"manifest\", \"\", \"manifest file to write\")\n \t\t\t\t\tfs.BoolVar(&buildArgs.verbose, \"verbose\", false, \"verbose logging\")\n \t\t\t\t\tfs.StringVar(&buildArgs.webClientRoot, \"web-client-root\", \"\", \"path to root of web client source to build\")\n+\t\t\t\t\tfs.StringVar(&buildArgs.outPath, \"out\", \"\", \"path to write output artifacts (defaults to '$PWD/dist' if not set)\")\n \t\t\t\t\treturn fs\n \t\t\t\t})(),\n \t\t\t\tLongHelp: strings.TrimSpace(`\n@@ -156,6 +157,7 @@ var buildArgs struct {\n \tmanifest      string\n \tverbose       bool\n \twebClientRoot string\n+\toutPath       string\n }\n \n func runBuild(ctx context.Context, filters []string, targets []dist.Target) error {\n@@ -172,7 +174,11 @@ func runBuild(ctx context.Context, filters []string, targets []dist.Target) erro\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting working directory: %w\", err)\n \t}\n-\tb, err := dist.NewBuild(wd, filepath.Join(wd, \"dist\"))\n+\toutPath := filepath.Join(wd, \"dist\")\n+\tif buildArgs.outPath != \"\" {\n+\t\toutPath = buildArgs.outPath\n+\t}\n+\tb, err := dist.NewBuild(wd, outPath)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"creating build context: %w\", err)\n \t}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIt seems like there is some sort of general issue with either the internal client in this repo that attempts to parse the error returned from the API or with the logic API side- the error that we get in kube client is a pointer to our type if it's a 'feature flag not enabled' error, but a concrete type if it's a 404. Right now, I can't debug this and we need to fix the code, so this does that.\r\n\r\nUpdates tailscale/tailscale#15895\n\n---\n\nChoice A:\ncmd/k8s-operator/ingress.go\n@@ -292,9 +292,15 @@ func validateIngressClass(ctx context.Context, cl client.Client) error {\n \n func handlersForIngress(ctx context.Context, ing *networkingv1.Ingress, cl client.Client, rec record.EventRecorder, tlsHost string, logger *zap.SugaredLogger) (handlers map[string]*ipn.HTTPHandler, err error) {\n \taddIngressBackend := func(b *networkingv1.IngressBackend, path string) {\n+\t\tif path == \"\" {\n+\t\t\tpath = \"/\"\n+\t\t\trec.Eventf(ing, corev1.EventTypeNormal, \"PathUndefined\", \"configured backend is missing a path, defaulting to '/'\")\n+\t\t}\n+\n \t\tif b == nil {\n \t\t\treturn\n \t\t}\n+\n \t\tif b.Service == nil {\n \t\t\trec.Eventf(ing, corev1.EventTypeWarning, \"InvalidIngressBackend\", \"backend for path %q is missing service\", path)\n \t\t\treturn\n---\ncmd/k8s-operator/ingress_test.go\n@@ -16,6 +16,7 @@ import (\n \tapiextensionsv1 \"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1\"\n \tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \t\"k8s.io/apimachinery/pkg/types\"\n+\t\"k8s.io/client-go/tools/record\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n \t\"tailscale.com/ipn\"\n@@ -487,6 +488,138 @@ func TestIngressLetsEncryptStaging(t *testing.T) {\n \t}\n }\n \n+func TestEmptyPath(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname           string\n+\t\tpaths          []networkingv1.HTTPIngressPath\n+\t\texpectedEvents []string\n+\t}{\n+\t\t{\n+\t\t\tname: \"empty_path_with_prefix_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypePrefix),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty_path_with_implementation_specific_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty_path_with_exact_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeExact),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Warning UnsupportedPathTypeExact Exact path type strict matching is currently not supported and requests will be routed as for Prefix path type. This behaviour might change in the future.\",\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"two_competing_but_not_identical_paths_including_one_empty\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"/\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range testCases {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfc := fake.NewFakeClient(ingressClass())\n+\t\t\tft := &fakeTSClient{}\n+\t\t\tfr := record.NewFakeRecorder(3) // bump this if you expect a test case to throw more events\n+\t\t\tfakeTsnetServer := &fakeTSNetServer{certDomains: []string{\"foo.com\"}}\n+\t\t\tzl, err := zap.NewDevelopment()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tingR := &IngressReconciler{\n+\t\t\t\trecorder: fr,\n+\t\t\t\tClient:   fc,\n+\t\t\t\tssr: &tailscaleSTSReconciler{\n+\t\t\t\t\tClient:            fc,\n+\t\t\t\t\ttsClient:          ft,\n+\t\t\t\t\ttsnetServer:       fakeTsnetServer,\n+\t\t\t\t\tdefaultTags:       []string{\"tag:k8s\"},\n+\t\t\t\t\toperatorNamespace: \"operator-ns\",\n+\t\t\t\t\tproxyImage:        \"tailscale/tailscale\",\n+\t\t\t\t},\n+\t\t\t\tlogger: zl.Sugar(),\n+\t\t\t}\n+\n+\t\t\t// 1. Resources get created for regular Ingress\n+\t\t\tmustCreate(t, fc, ingressWithPaths(tt.paths))\n+\t\t\tmustCreate(t, fc, service())\n+\n+\t\t\texpectReconciled(t, ingR, \"default\", \"test\")\n+\n+\t\t\tfullName, shortName := findGenName(t, fc, \"default\", \"test\", \"ingress\")\n+\t\t\tmustCreate(t, fc, &corev1.Pod{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tName:      fullName,\n+\t\t\t\t\tNamespace: \"operator-ns\",\n+\t\t\t\t\tUID:       \"test-uid\",\n+\t\t\t\t},\n+\t\t\t})\n+\t\t\topts := configOpts{\n+\t\t\t\tstsName:    shortName,\n+\t\t\t\tsecretName: fullName,\n+\t\t\t\tnamespace:  \"default\",\n+\t\t\t\tparentType: \"ingress\",\n+\t\t\t\thostname:   \"foo\",\n+\t\t\t\tapp:        kubetypes.AppIngressResource,\n+\t\t\t}\n+\t\t\tserveConfig := &ipn.ServeConfig{\n+\t\t\t\tTCP: map[uint16]*ipn.TCPPortHandler{443: {HTTPS: true}},\n+\t\t\t\tWeb: map[ipn.HostPort]*ipn.WebServerConfig{\"${TS_CERT_DOMAIN}:443\": {Handlers: map[string]*ipn.HTTPHandler{\"/\": {Proxy: \"http://1.2.3.4:8080/\"}}}},\n+\t\t\t}\n+\t\t\topts.serveConfig = serveConfig\n+\n+\t\t\texpectEqual(t, fc, expectedSecret(t, fc, opts))\n+\t\t\texpectEqual(t, fc, expectedHeadlessService(shortName, \"ingress\"))\n+\t\t\texpectEqual(t, fc, expectedSTSUserspace(t, fc, opts), removeHashAnnotation, removeResourceReqs)\n+\n+\t\t\texpectEvents(t, fr, tt.expectedEvents)\n+\t\t})\n+\t}\n+}\n+\n+// ptrPathType is a helper function to return a pointer to the pathtype string (required for TestEmptyPath)\n+func ptrPathType(p networkingv1.PathType) *networkingv1.PathType {\n+\treturn &p\n+}\n+\n func ingressClass() *networkingv1.IngressClass {\n \treturn &networkingv1.IngressClass{\n \t\tObjectMeta: metav1.ObjectMeta{Name: \"tailscale\"},\n@@ -520,16 +653,47 @@ func ingress() *networkingv1.Ingress {\n \t\t},\n \t\tSpec: networkingv1.IngressSpec{\n \t\t\tIngressClassName: ptr.To(\"tailscale\"),\n-\t\t\tDefaultBackend: &networkingv1.IngressBackend{\n-\t\t\t\tService: &networkingv1.IngressServiceBackend{\n-\t\t\t\t\tName: \"test\",\n-\t\t\t\t\tPort: networkingv1.ServiceBackendPort{\n-\t\t\t\t\t\tNumber: 8080,\n+\t\t\tDefaultBackend:   backend(),\n+\t\t\tTLS: []networkingv1.IngressTLS{\n+\t\t\t\t{Hosts: []string{\"default-test\"}},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func ingressWithPaths(paths []networkingv1.HTTPIngressPath) *networkingv1.Ingress {\n+\treturn &networkingv1.Ingress{\n+\t\tTypeMeta: metav1.TypeMeta{Kind: \"Ingress\", APIVersion: \"networking.k8s.io/v1\"},\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      \"test\",\n+\t\t\tNamespace: \"default\",\n+\t\t\tUID:       types.UID(\"1234-UID\"),\n+\t\t},\n+\t\tSpec: networkingv1.IngressSpec{\n+\t\t\tIngressClassName: ptr.To(\"tailscale\"),\n+\t\t\tRules: []networkingv1.IngressRule{\n+\t\t\t\t{\n+\t\t\t\t\tHost: \"foo.tailnetxyz.ts.net\",\n+\t\t\t\t\tIngressRuleValue: networkingv1.IngressRuleValue{\n+\t\t\t\t\t\tHTTP: &networkingv1.HTTPIngressRuleValue{\n+\t\t\t\t\t\t\tPaths: paths,\n+\t\t\t\t\t\t},\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n \t\t\tTLS: []networkingv1.IngressTLS{\n-\t\t\t\t{Hosts: []string{\"default-test\"}},\n+\t\t\t\t{Hosts: []string{\"foo.tailnetxyz.ts.net\"}},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func backend() *networkingv1.IngressBackend {\n+\treturn &networkingv1.IngressBackend{\n+\t\tService: &networkingv1.IngressServiceBackend{\n+\t\t\tName: \"test\",\n+\t\t\tPort: networkingv1.ServiceBackendPort{\n+\t\t\t\tNumber: 8080,\n \t\t\t},\n \t\t},\n \t}\n---\n\n\n---\n\nChoice B:\nwords/scales.txt\n@@ -440,3 +440,5 @@ sidemirror\n wage\n salary\n fujita\n+caiman\n+cichlid\n---\nwords/tails.txt\n@@ -720,3 +720,5 @@ mining\n coat\n follow\n stalk\n+caudal\n+chronicle\n---\n\n\n---\n\nChoice C:\ncmd/k8s-operator/ingress-for-pg.go\n@@ -1105,13 +1105,11 @@ func isErrorFeatureFlagNotEnabled(err error) bool {\n \t// Tailscale control plane when a Tailscale Service API call is made for a\n \t// tailnet that does not have the Tailscale Services feature flag enabled.\n \tconst messageFFNotEnabled = \"feature unavailable for tailnet\"\n-\tvar errResp *tailscale.ErrResponse\n-\tok := errors.As(err, &errResp)\n-\treturn ok && strings.Contains(errResp.Message, messageFFNotEnabled)\n+\treturn err != nil && strings.Contains(err.Error(), messageFFNotEnabled)\n }\n \n func isErrorTailscaleServiceNotFound(err error) bool {\n-\tvar errResp *tailscale.ErrResponse\n+\tvar errResp tailscale.ErrResponse\n \tok := errors.As(err, &errResp)\n \treturn ok && errResp.Status == http.StatusNotFound\n }\n---\ncmd/k8s-operator/svc-for-pg_test.go\n@@ -8,10 +8,8 @@ package main\n import (\n \t\"context\"\n \t\"encoding/json\"\n-\t\"errors\"\n \t\"fmt\"\n \t\"math/rand/v2\"\n-\t\"net/http\"\n \t\"net/netip\"\n \t\"testing\"\n \n@@ -23,7 +21,6 @@ import (\n \t\"k8s.io/client-go/tools/record\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n-\t\"tailscale.com/internal/client/tailscale\"\n \t\"tailscale.com/ipn/ipnstate\"\n \ttsoperator \"tailscale.com/k8s-operator\"\n \ttsapi \"tailscale.com/k8s-operator/apis/v1alpha1\"\n@@ -108,8 +105,7 @@ func TestServicePGReconciler_UpdateHostname(t *testing.T) {\n \tif err == nil {\n \t\tt.Fatalf(\"svc:default-%s not cleaned up\", svc.Name)\n \t}\n-\tvar errResp *tailscale.ErrResponse\n-\tif !errors.As(err, &errResp) || errResp.Status != http.StatusNotFound {\n+\tif !isErrorTailscaleServiceNotFound(err) {\n \t\tt.Fatalf(\"unexpected error: %v\", err)\n \t}\n }\n---\ncmd/k8s-operator/testutils_test.go\n@@ -901,11 +901,11 @@ func (c *fakeTSClient) GetVIPService(ctx context.Context, name tailcfg.ServiceNa\n \tc.Lock()\n \tdefer c.Unlock()\n \tif c.vipServices == nil {\n-\t\treturn nil, &tailscale.ErrResponse{Status: http.StatusNotFound}\n+\t\treturn nil, tailscale.ErrResponse{Status: http.StatusNotFound}\n \t}\n \tsvc, ok := c.vipServices[name]\n \tif !ok {\n-\t\treturn nil, &tailscale.ErrResponse{Status: http.StatusNotFound}\n+\t\treturn nil, tailscale.ErrResponse{Status: http.StatusNotFound}\n \t}\n \treturn svc, nil\n }\n---\n\n\n---\n\nChoice D:\ngo.mod\n@@ -77,7 +77,7 @@ require (\n \tgithub.com/tailscale/certstore v0.1.1-0.20231202035212-d3fa0460f47e\n \tgithub.com/tailscale/depaware v0.0.0-20250112153213-b748de04d81b\n \tgithub.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41\n-\tgithub.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca\n+\tgithub.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869\n \tgithub.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05\n \tgithub.com/tailscale/hujson v0.0.0-20221223112325-20486734a56a\n \tgithub.com/tailscale/mkctr v0.0.0-20250228050937-c75ea1476830\n---\ngo.sum\n@@ -910,8 +910,8 @@ github.com/tailscale/go-winio v0.0.0-20231025203758-c4f33415bf55 h1:Gzfnfk2TWrk8\n github.com/tailscale/go-winio v0.0.0-20231025203758-c4f33415bf55/go.mod h1:4k4QO+dQ3R5FofL+SanAUZe+/QfeK0+OIuwDIRu2vSg=\n github.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41 h1:/V2rCMMWcsjYaYO2MeovLw+ClP63OtXgCF2Y1eb8+Ns=\n github.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41/go.mod h1:/roCdA6gg6lQyw/Oz6gIIGu3ggJKYhF+WC/AQReE5XQ=\n-github.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca h1:ecjHwH73Yvqf/oIdQ2vxAX+zc6caQsYdPzsxNW1J3G8=\n-github.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca/go.mod h1:ikbF+YT089eInTp9f2vmvy4+ZVnW5hzX1q2WknxSprQ=\n+github.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869 h1:SRL6irQkKGQKKLzvQP/ke/2ZuB7Py5+XuqtOgSj+iMM=\n+github.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869/go.mod h1:ikbF+YT089eInTp9f2vmvy4+ZVnW5hzX1q2WknxSprQ=\n github.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05 h1:4chzWmimtJPxRs2O36yuGRW3f9SYV+bMTTvMBI0EKio=\n github.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05/go.mod h1:PdCqy9JzfWMJf1H5UJW2ip33/d4YkoKN0r67yKH1mG8=\n github.com/tailscale/hujson v0.0.0-20221223112325-20486734a56a h1:SJy1Pu0eH1C29XwJucQo73FrleVK6t4kYz4NVhp34Yw=\n---\ntempfork/acme/acme.go\n@@ -270,10 +270,7 @@ func (c *Client) FetchRenewalInfo(ctx context.Context, leaf []byte) (*RenewalInf\n \t\treturn nil, fmt.Errorf(\"parsing leaf certificate: %w\", err)\n \t}\n \n-\trenewalURL, err := c.getRenewalURL(parsedLeaf)\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"generating renewal info URL: %w\", err)\n-\t}\n+\trenewalURL := c.getRenewalURL(parsedLeaf)\n \n \tres, err := c.get(ctx, renewalURL, wantStatus(http.StatusOK))\n \tif err != nil {\n@@ -288,16 +285,20 @@ func (c *Client) FetchRenewalInfo(ctx context.Context, leaf []byte) (*RenewalInf\n \treturn &info, nil\n }\n \n-func (c *Client) getRenewalURL(cert *x509.Certificate) (string, error) {\n+func (c *Client) getRenewalURL(cert *x509.Certificate) string {\n \t// See https://www.ietf.org/archive/id/draft-ietf-acme-ari-04.html#name-the-renewalinfo-resource\n \t// for how the request URL is built.\n \turl := c.dir.RenewalInfoURL\n \tif !strings.HasSuffix(url, \"/\") {\n \t\turl += \"/\"\n \t}\n+\treturn url + certRenewalIdentifier(cert)\n+}\n+\n+func certRenewalIdentifier(cert *x509.Certificate) string {\n \taki := base64.RawURLEncoding.EncodeToString(cert.AuthorityKeyId)\n \tserial := base64.RawURLEncoding.EncodeToString(cert.SerialNumber.Bytes())\n-\treturn fmt.Sprintf(\"%s%s.%s\", url, aki, serial), nil\n+\treturn aki + \".\" + serial\n }\n \n // AcceptTOS always returns true to indicate the acceptance of a CA's Terms of Service\n---\ntempfork/acme/acme_test.go\n@@ -549,10 +549,7 @@ func TestGetRenewalURL(t *testing.T) {\n \t}\n \n \tclient := newTestClientWithMockDirectory()\n-\turlString, err := client.getRenewalURL(parsedLeaf)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\turlString := client.getRenewalURL(parsedLeaf)\n \n \tparsedURL, err := url.Parse(urlString)\n \tif err != nil {\n---\ntempfork/acme/rfc8555.go\n@@ -7,6 +7,7 @@ package acme\n import (\n \t\"context\"\n \t\"crypto\"\n+\t\"crypto/x509\"\n \t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"encoding/pem\"\n@@ -205,6 +206,7 @@ func (c *Client) AuthorizeOrder(ctx context.Context, id []AuthzID, opt ...OrderO\n \t\tIdentifiers []wireAuthzID `json:\"identifiers\"`\n \t\tNotBefore   string        `json:\"notBefore,omitempty\"`\n \t\tNotAfter    string        `json:\"notAfter,omitempty\"`\n+\t\tReplaces    string        `json:\"replaces,omitempty\"`\n \t}{}\n \tfor _, v := range id {\n \t\treq.Identifiers = append(req.Identifiers, wireAuthzID{\n@@ -218,6 +220,14 @@ func (c *Client) AuthorizeOrder(ctx context.Context, id []AuthzID, opt ...OrderO\n \t\t\treq.NotBefore = time.Time(o).Format(time.RFC3339)\n \t\tcase orderNotAfterOpt:\n \t\t\treq.NotAfter = time.Time(o).Format(time.RFC3339)\n+\t\tcase orderReplacesCert:\n+\t\t\treq.Replaces = certRenewalIdentifier(o.cert)\n+\t\tcase orderReplacesCertDER:\n+\t\t\tcert, err := x509.ParseCertificate(o)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"failed to parse certificate being replaced: %w\", err)\n+\t\t\t}\n+\t\t\treq.Replaces = certRenewalIdentifier(cert)\n \t\tdefault:\n \t\t\t// Package's fault if we let this happen.\n \t\t\tpanic(fmt.Sprintf(\"unsupported order option type %T\", o))\n---\ntempfork/acme/rfc8555_test.go\n@@ -766,10 +766,17 @@ func TestRFC_AuthorizeOrder(t *testing.T) {\n \ts.start()\n \tdefer s.close()\n \n+\tprevCertDER, _ := pem.Decode([]byte(leafPEM))\n+\tprevCert, err := x509.ParseCertificate(prevCertDER.Bytes)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n \tcl := &Client{Key: testKeyEC, DirectoryURL: s.url(\"/\")}\n \to, err := cl.AuthorizeOrder(context.Background(), DomainIDs(\"example.org\"),\n \t\tWithOrderNotBefore(time.Date(2019, 8, 31, 0, 0, 0, 0, time.UTC)),\n \t\tWithOrderNotAfter(time.Date(2019, 9, 2, 0, 0, 0, 0, time.UTC)),\n+\t\tWithOrderReplacesCert(prevCert),\n \t)\n \tif err != nil {\n \t\tt.Fatal(err)\n---\ntempfork/acme/types.go\n@@ -391,6 +391,30 @@ type orderNotAfterOpt time.Time\n \n func (orderNotAfterOpt) privateOrderOpt() {}\n \n+// WithOrderReplacesCert indicates that this Order is for a replacement of an\n+// existing certificate.\n+// See https://datatracker.ietf.org/doc/html/draft-ietf-acme-ari-03#section-5\n+func WithOrderReplacesCert(cert *x509.Certificate) OrderOption {\n+\treturn orderReplacesCert{cert}\n+}\n+\n+type orderReplacesCert struct {\n+\tcert *x509.Certificate\n+}\n+\n+func (orderReplacesCert) privateOrderOpt() {}\n+\n+// WithOrderReplacesCertDER indicates that this Order is for a replacement of\n+// an existing DER-encoded certificate.\n+// See https://datatracker.ietf.org/doc/html/draft-ietf-acme-ari-03#section-5\n+func WithOrderReplacesCertDER(der []byte) OrderOption {\n+\treturn orderReplacesCertDER(der)\n+}\n+\n+type orderReplacesCertDER []byte\n+\n+func (orderReplacesCertDER) privateOrderOpt() {}\n+\n // Authorization encodes an authorization response.\n type Authorization struct {\n \t// URI uniquely identifies a authorization.\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nTaildrop wasn't working on iOS since #15971 because GetExt didn't work\nuntil after init, but that PR moved Init until after Start.\n\nThis makes GetExt work before LocalBackend.Start (ExtensionHost.Init).\n\nUpdates #15812\n\n\n---\n\nChoice A:\ncmd/tailscaled/tailscaled.go\n@@ -151,10 +151,33 @@ var subCommands = map[string]*func([]string) error{\n \t\"serve-taildrive\":         &serveDriveFunc,\n }\n \n-var beCLI func() // non-nil if CLI is linked in\n+var beCLI func() // non-nil if CLI is linked in with the \"ts_include_cli\" build tag\n+\n+// shouldRunCLI reports whether we should run the Tailscale CLI (cmd/tailscale)\n+// instead of the daemon (cmd/tailscaled) in the case when the two are linked\n+// together into one binary for space savings reasons.\n+func shouldRunCLI() bool {\n+\tif beCLI == nil {\n+\t\t// Not linked in with the \"ts_include_cli\" build tag.\n+\t\treturn false\n+\t}\n+\tif len(os.Args) > 0 && filepath.Base(os.Args[0]) == \"tailscale\" {\n+\t\t// The binary was named (or hardlinked) as \"tailscale\".\n+\t\treturn true\n+\t}\n+\tif envknob.Bool(\"TS_BE_CLI\") {\n+\t\t// The environment variable was set to force it.\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n \n func main() {\n \tenvknob.PanicIfAnyEnvCheckedInInit()\n+\tif shouldRunCLI() {\n+\t\tbeCLI()\n+\t\treturn\n+\t}\n \tenvknob.ApplyDiskConfig()\n \tapplyIntegrationTestEnvKnob()\n \n@@ -175,11 +198,6 @@ func main() {\n \tflag.BoolVar(&args.disableLogs, \"no-logs-no-support\", false, \"disable log uploads; this also disables any technical support\")\n \tflag.StringVar(&args.confFile, \"config\", \"\", \"path to config file, or 'vm:user-data' to use the VM's user-data (EC2)\")\n \n-\tif len(os.Args) > 0 && filepath.Base(os.Args[0]) == \"tailscale\" && beCLI != nil {\n-\t\tbeCLI()\n-\t\treturn\n-\t}\n-\n \tif len(os.Args) > 1 {\n \t\tsub := os.Args[1]\n \t\tif fp, ok := subCommands[sub]; ok {\n---\n\n\n---\n\nChoice B:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/init@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/autobuild@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/analyze@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n---\n\n\n---\n\nChoice C:\nflake.lock\n@@ -36,11 +36,11 @@\n     },\n     \"nixpkgs\": {\n       \"locked\": {\n-        \"lastModified\": 1724748588,\n-        \"narHash\": \"sha256-NlpGA4+AIf1dKNq76ps90rxowlFXUsV9x7vK/mN37JM=\",\n+        \"lastModified\": 1743938762,\n+        \"narHash\": \"sha256-UgFYn8sGv9B8PoFpUfCa43CjMZBl1x/ShQhRDHBFQdI=\",\n         \"owner\": \"NixOS\",\n         \"repo\": \"nixpkgs\",\n-        \"rev\": \"a6292e34000dc93d43bccf78338770c1c5ec8a99\",\n+        \"rev\": \"74a40410369a1c35ee09b8a1abee6f4acbedc059\",\n         \"type\": \"github\"\n       },\n       \"original\": {\n---\nflake.nix\n@@ -68,14 +68,14 @@\n     # you're an end user you should be prepared for this flake to not\n     # build periodically.\n     tailscale = pkgs:\n-      pkgs.buildGo123Module rec {\n+      pkgs.buildGo124Module rec {\n         name = \"tailscale\";\n \n         src = ./.;\n         vendorHash = pkgs.lib.fileContents ./go.mod.sri;\n         nativeBuildInputs = pkgs.lib.optionals pkgs.stdenv.isLinux [pkgs.makeWrapper];\n         ldflags = [\"-X tailscale.com/version.gitCommitStamp=${tailscaleRev}\"];\n-        CGO_ENABLED = 0;\n+        env.CGO_ENABLED = 0;\n         subPackages = [\"cmd/tailscale\" \"cmd/tailscaled\"];\n         doCheck = false;\n \n@@ -118,7 +118,7 @@\n           gotools\n           graphviz\n           perl\n-          go_1_23\n+          go_1_24\n           yarn\n \n           # qemu and e2fsprogs are needed for natlab\n@@ -130,4 +130,4 @@\n   in\n     flake-utils.lib.eachDefaultSystem (system: flakeForSystem nixpkgs system);\n }\n-# nix-direnv cache busting line: sha256-xO1DuLWi6/lpA9ubA2ZYVJM+CkVNA5IaVGZxX9my0j0=\n+# nix-direnv cache busting line: sha256-av4kr09rjNRmag94ziNjJuI/cg8b8lAD3Tk24t/ezH4=\n---\ngo.mod.sri\n@@ -1 +1 @@\n-sha256-xO1DuLWi6/lpA9ubA2ZYVJM+CkVNA5IaVGZxX9my0j0=\n+sha256-av4kr09rjNRmag94ziNjJuI/cg8b8lAD3Tk24t/ezH4=\n\\ No newline at end of file\n---\nshell.nix\n@@ -16,4 +16,4 @@\n ) {\n   src =  ./.;\n }).shellNix\n-# nix-direnv cache busting line: sha256-xO1DuLWi6/lpA9ubA2ZYVJM+CkVNA5IaVGZxX9my0j0=\n+# nix-direnv cache busting line: sha256-av4kr09rjNRmag94ziNjJuI/cg8b8lAD3Tk24t/ezH4=\n---\n\n\n---\n\nChoice D:\nipn/ipnext/ipnext.go\n@@ -114,7 +114,7 @@ func RegisterExtension(name string, newExt NewExtensionFn) {\n \t\tpanic(fmt.Sprintf(\"ipnext: newExt is nil: %q\", name))\n \t}\n \tif extensions.Contains(name) {\n-\t\tpanic(fmt.Sprintf(\"ipnext: duplicate extensions: %q\", name))\n+\t\tpanic(fmt.Sprintf(\"ipnext: duplicate extension name %q\", name))\n \t}\n \textensions.Set(name, &Definition{name, newExt})\n }\n---\nipn/ipnlocal/extension_host.go\n@@ -22,6 +22,7 @@ import (\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/execqueue\"\n+\t\"tailscale.com/util/mak\"\n \t\"tailscale.com/util/testenv\"\n )\n \n@@ -97,7 +98,8 @@ type ExtensionHost struct {\n \tinitialized atomic.Bool\n \t// activeExtensions is a subset of allExtensions that have been initialized and are ready to use.\n \tactiveExtensions []ipnext.Extension\n-\t// extensionsByName are the activeExtensions indexed by their names.\n+\t// extensionsByName are the extensions indexed by their names.\n+\t// They are not necessarily initialized (in activeExtensions) yet.\n \textensionsByName map[string]ipnext.Extension\n \t// postInitWorkQueue is a queue of functions to be executed\n \t// by the workQueue after all extensions have been initialized.\n@@ -184,6 +186,24 @@ func newExtensionHost(logf logger.Logf, b Backend, overrideExts ...*ipnext.Defin\n \t\t\treturn nil, fmt.Errorf(\"failed to create %q extension: %v\", d.Name(), err)\n \t\t}\n \t\thost.allExtensions = append(host.allExtensions, ext)\n+\n+\t\tif d.Name() != ext.Name() {\n+\t\t\treturn nil, fmt.Errorf(\"extension name %q does not match the registered name %q\", ext.Name(), d.Name())\n+\t\t}\n+\n+\t\tif _, ok := host.extensionsByName[ext.Name()]; ok {\n+\t\t\treturn nil, fmt.Errorf(\"duplicate extension name %q\", ext.Name())\n+\t\t} else {\n+\t\t\tmak.Set(&host.extensionsByName, ext.Name(), ext)\n+\t\t}\n+\n+\t\ttyp := reflect.TypeOf(ext)\n+\t\tif _, ok := host.extByType.Load(typ); ok {\n+\t\t\tif _, ok := ext.(interface{ PermitDoubleRegister() }); !ok {\n+\t\t\t\treturn nil, fmt.Errorf(\"duplicate extension type %T\", ext)\n+\t\t\t}\n+\t\t}\n+\t\thost.extByType.Store(typ, ext)\n \t}\n \treturn host, nil\n }\n@@ -215,10 +235,6 @@ func (h *ExtensionHost) init() {\n \tdefer h.initDone.Store(true)\n \n \t// Initialize the extensions in the order they were registered.\n-\th.mu.Lock()\n-\th.activeExtensions = make([]ipnext.Extension, 0, len(h.allExtensions))\n-\th.extensionsByName = make(map[string]ipnext.Extension, len(h.allExtensions))\n-\th.mu.Unlock()\n \tfor _, ext := range h.allExtensions {\n \t\t// Do not hold the lock while calling [ipnext.Extension.Init].\n \t\t// Extensions call back into the host to register their callbacks,\n@@ -240,8 +256,6 @@ func (h *ExtensionHost) init() {\n \t\t// We'd like to make them visible to other extensions that are initialized later.\n \t\th.mu.Lock()\n \t\th.activeExtensions = append(h.activeExtensions, ext)\n-\t\th.extensionsByName[ext.Name()] = ext\n-\t\th.extByType.Store(reflect.TypeOf(ext), ext)\n \t\th.mu.Unlock()\n \t}\n \n---\nipn/ipnlocal/extension_host_test.go\n@@ -30,6 +30,7 @@ import (\n \t\"tailscale.com/tstime\"\n \t\"tailscale.com/types/key\"\n \t\"tailscale.com/types/lazy\"\n+\t\"tailscale.com/types/logger\"\n \t\"tailscale.com/types/persist\"\n \t\"tailscale.com/util/must\"\n )\n@@ -1042,6 +1043,38 @@ func TestNilExtensionHostMethodCall(t *testing.T) {\n \t}\n }\n \n+// extBeforeStartExtension is a test extension used by TestGetExtBeforeStart.\n+// It is registered with the [ipnext.RegisterExtension].\n+type extBeforeStartExtension struct{}\n+\n+func init() {\n+\tipnext.RegisterExtension(\"ext-before-start\", mkExtBeforeStartExtension)\n+}\n+\n+func mkExtBeforeStartExtension(logger.Logf, ipnext.SafeBackend) (ipnext.Extension, error) {\n+\treturn extBeforeStartExtension{}, nil\n+}\n+\n+func (extBeforeStartExtension) Name() string { return \"ext-before-start\" }\n+func (extBeforeStartExtension) Init(ipnext.Host) error {\n+\treturn nil\n+}\n+func (extBeforeStartExtension) Shutdown() error {\n+\treturn nil\n+}\n+\n+// TestGetExtBeforeStart verifies that an extension registered via\n+// RegisterExtension can be retrieved with GetExt before the host is started\n+// (via LocalBackend.Start)\n+func TestGetExtBeforeStart(t *testing.T) {\n+\tlb := newTestBackend(t)\n+\t// Now call GetExt without calling Start on the LocalBackend.\n+\t_, ok := GetExt[extBeforeStartExtension](lb)\n+\tif !ok {\n+\t\tt.Fatal(\"didn't find extension\")\n+\t}\n+}\n+\n // checkMethodCallWithZeroArgs calls the method m on the receiver r\n // with zero values for all its arguments, except the receiver itself.\n // It returns the result of the method call, or fails the test if the call panics.\n@@ -1151,6 +1184,10 @@ type testExtension struct {\n \n var _ ipnext.Extension = (*testExtension)(nil)\n \n+// PermitDoubleRegister is a sentinel method whose existence tells the\n+// ExtensionHost to permit it to be registered multiple times.\n+func (*testExtension) PermitDoubleRegister() {}\n+\n func (e *testExtension) setT(t *testing.T) {\n \te.t = t\n }\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #cleanup\n\n---\n\nChoice A:\n.github/workflows/codeql-analysis.yml\n@@ -49,7 +49,7 @@ jobs:\n \n     # Install a more recent Go that understands modern go.mod content.\n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n \n---\n.github/workflows/golangci-lint.yml\n@@ -25,7 +25,7 @@ jobs:\n     steps:\n       - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n-      - uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      - uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n         with:\n           go-version-file: go.mod\n           cache: false\n---\n.github/workflows/test.yml\n@@ -151,7 +151,7 @@ jobs:\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n         cache: false\n---\n\n\n---\n\nChoice B:\ncmd/natc/ippool/ippool.go\n@@ -24,7 +24,6 @@ var ErrNoIPsAvailable = errors.New(\"no IPs available\")\n type IPPool struct {\n \tperPeerMap syncs.Map[tailcfg.NodeID, *perPeerState]\n \tIPSet      *netipx.IPSet\n-\tV6ULA      netip.Prefix\n }\n \n func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bool) {\n@@ -44,15 +43,13 @@ func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bo\n func (ipp *IPPool) IPForDomain(from tailcfg.NodeID, domain string) (netip.Addr, error) {\n \tnpps := &perPeerState{\n \t\tipset: ipp.IPSet,\n-\t\tv6ULA: ipp.V6ULA,\n \t}\n \tps, _ := ipp.perPeerMap.LoadOrStore(from, npps)\n \treturn ps.ipForDomain(domain)\n }\n \n // perPeerState holds the state for a single peer.\n type perPeerState struct {\n-\tv6ULA netip.Prefix\n \tipset *netipx.IPSet\n \n \tmu           sync.Mutex\n---\ncmd/natc/ippool/ippool_test.go\n@@ -19,8 +19,7 @@ func TestIPPoolExhaustion(t *testing.T) {\n \tvar ipsb netipx.IPSetBuilder\n \tipsb.AddPrefix(smallPrefix)\n \taddrPool := must.Get(ipsb.IPSet())\n-\tv6ULA := netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\")\n-\tpool := IPPool{V6ULA: v6ULA, IPSet: addrPool}\n+\tpool := IPPool{IPSet: addrPool}\n \n \tassignedIPs := make(map[netip.Addr]string)\n \n@@ -52,9 +51,6 @@ func TestIPPoolExhaustion(t *testing.T) {\n \t\tif addr.Is4() && !smallPrefix.Contains(addr) {\n \t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, smallPrefix)\n \t\t}\n-\t\tif addr.Is6() && !v6ULA.Contains(addr) {\n-\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, v6ULA)\n-\t\t}\n \t}\n \n \t// expect one error for each iteration with the 5th domain\n@@ -73,7 +69,6 @@ func TestIPPool(t *testing.T) {\n \tipsb.AddPrefix(netip.MustParsePrefix(\"100.64.1.0/24\"))\n \taddrPool := must.Get(ipsb.IPSet())\n \tpool := IPPool{\n-\t\tV6ULA: netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n \t\tIPSet: addrPool,\n \t}\n \tfrom := tailcfg.NodeID(12345)\n---\ncmd/natc/natc.go\n@@ -153,7 +153,7 @@ func main() {\n \t\twhois:      lc,\n \t\tv6ULA:      v6ULA,\n \t\tignoreDsts: ignoreDstTable,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\troutes:     routes,\n \t\tdnsAddr:    dnsAddr,\n \t\tresolver:   net.DefaultResolver,\n---\ncmd/natc/natc_test.go\n@@ -270,7 +270,7 @@ func TestDNSResponse(t *testing.T) {\n \t\tignoreDsts: &bart.Table[bool]{},\n \t\troutes:     routes,\n \t\tv6ULA:      v6ULA,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\tdnsAddr:    dnsAddr,\n \t}\n \tc.ignoreDsts.Insert(netip.MustParsePrefix(\"8.8.4.4/32\"), true)\n---\n\n\n---\n\nChoice C:\ncmd/k8s-operator/ingress-for-pg.go\n@@ -1105,13 +1105,11 @@ func isErrorFeatureFlagNotEnabled(err error) bool {\n \t// Tailscale control plane when a Tailscale Service API call is made for a\n \t// tailnet that does not have the Tailscale Services feature flag enabled.\n \tconst messageFFNotEnabled = \"feature unavailable for tailnet\"\n-\tvar errResp *tailscale.ErrResponse\n-\tok := errors.As(err, &errResp)\n-\treturn ok && strings.Contains(errResp.Message, messageFFNotEnabled)\n+\treturn err != nil && strings.Contains(err.Error(), messageFFNotEnabled)\n }\n \n func isErrorTailscaleServiceNotFound(err error) bool {\n-\tvar errResp *tailscale.ErrResponse\n+\tvar errResp tailscale.ErrResponse\n \tok := errors.As(err, &errResp)\n \treturn ok && errResp.Status == http.StatusNotFound\n }\n---\ncmd/k8s-operator/svc-for-pg_test.go\n@@ -8,10 +8,8 @@ package main\n import (\n \t\"context\"\n \t\"encoding/json\"\n-\t\"errors\"\n \t\"fmt\"\n \t\"math/rand/v2\"\n-\t\"net/http\"\n \t\"net/netip\"\n \t\"testing\"\n \n@@ -23,7 +21,6 @@ import (\n \t\"k8s.io/client-go/tools/record\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n-\t\"tailscale.com/internal/client/tailscale\"\n \t\"tailscale.com/ipn/ipnstate\"\n \ttsoperator \"tailscale.com/k8s-operator\"\n \ttsapi \"tailscale.com/k8s-operator/apis/v1alpha1\"\n@@ -108,8 +105,7 @@ func TestServicePGReconciler_UpdateHostname(t *testing.T) {\n \tif err == nil {\n \t\tt.Fatalf(\"svc:default-%s not cleaned up\", svc.Name)\n \t}\n-\tvar errResp *tailscale.ErrResponse\n-\tif !errors.As(err, &errResp) || errResp.Status != http.StatusNotFound {\n+\tif !isErrorTailscaleServiceNotFound(err) {\n \t\tt.Fatalf(\"unexpected error: %v\", err)\n \t}\n }\n---\ncmd/k8s-operator/testutils_test.go\n@@ -901,11 +901,11 @@ func (c *fakeTSClient) GetVIPService(ctx context.Context, name tailcfg.ServiceNa\n \tc.Lock()\n \tdefer c.Unlock()\n \tif c.vipServices == nil {\n-\t\treturn nil, &tailscale.ErrResponse{Status: http.StatusNotFound}\n+\t\treturn nil, tailscale.ErrResponse{Status: http.StatusNotFound}\n \t}\n \tsvc, ok := c.vipServices[name]\n \tif !ok {\n-\t\treturn nil, &tailscale.ErrResponse{Status: http.StatusNotFound}\n+\t\treturn nil, tailscale.ErrResponse{Status: http.StatusNotFound}\n \t}\n \treturn svc, nil\n }\n---\n\n\n---\n\nChoice D:\nwgengine/magicsock/endpoint.go\n@@ -552,7 +552,7 @@ func (de *endpoint) addrForSendLocked(now mono.Time) (udpAddr, derpAddr netip.Ad\n // addrForWireGuardSendLocked returns the address that should be used for\n // sending the next packet. If a packet has never or not recently been sent to\n // the endpoint, then a randomly selected address for the endpoint is returned,\n-// as well as a bool indiciating that WireGuard discovery pings should be started.\n+// as well as a bool indicating that WireGuard discovery pings should be started.\n // If the addresses have latency information available, then the address with the\n // best latency is used.\n //\n@@ -1261,7 +1261,7 @@ func (de *endpoint) sendDiscoPingsLocked(now mono.Time, sendCallMeMaybe bool) {\n }\n \n // sendWireGuardOnlyPingsLocked evaluates all available addresses for\n-// a WireGuard only endpoint and initates an ICMP ping for useable\n+// a WireGuard only endpoint and initiates an ICMP ping for useable\n // addresses.\n func (de *endpoint) sendWireGuardOnlyPingsLocked(now mono.Time) {\n \tif runtime.GOOS == \"js\" {\n@@ -1629,7 +1629,7 @@ func (de *endpoint) handlePongConnLocked(m *disco.Pong, di *discoInfo, src netip\n \t\t\tde.c.logf(\"magicsock: disco: node %v %v now using %v mtu=%v tx=%x\", de.publicKey.ShortString(), de.discoShort(), sp.to, thisPong.wireMTU, m.TxID[:6])\n \t\t\tde.debugUpdates.Add(EndpointChange{\n \t\t\t\tWhen: time.Now(),\n-\t\t\t\tWhat: \"handlePingLocked-bestAddr-update\",\n+\t\t\t\tWhat: \"handlePongConnLocked-bestAddr-update\",\n \t\t\t\tFrom: de.bestAddr,\n \t\t\t\tTo:   thisPong,\n \t\t\t})\n@@ -1638,7 +1638,7 @@ func (de *endpoint) handlePongConnLocked(m *disco.Pong, di *discoInfo, src netip\n \t\tif de.bestAddr.AddrPort == thisPong.AddrPort {\n \t\t\tde.debugUpdates.Add(EndpointChange{\n \t\t\t\tWhen: time.Now(),\n-\t\t\t\tWhat: \"handlePingLocked-bestAddr-latency\",\n+\t\t\t\tWhat: \"handlePongConnLocked-bestAddr-latency\",\n \t\t\t\tFrom: de.bestAddr,\n \t\t\t\tTo:   thisPong,\n \t\t\t})\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThe same message was used for \"up\" and \"down\" permission failures, but\n\"set\" works better for both. Suggesting \"up --operator\" for a \"down\"\npermission failure was confusing.\n\nIt's not like the latter command works in one shot anyway.\n\nFixes #16008\n\n\n---\n\nChoice A:\nwgengine/magicsock/endpoint.go\n@@ -1480,7 +1480,7 @@ func (de *endpoint) addCandidateEndpoint(ep netip.AddrPort, forRxPingTxID stun.T\n \t\t\t}\n \t\t}\n \t\tsize2 := len(de.endpointState)\n-\t\tde.c.dlogf(\"[v1] magicsock: disco: addCandidateEndpoint pruned %v candidate set from %v to %v entries\", size, size2)\n+\t\tde.c.dlogf(\"[v1] magicsock: disco: addCandidateEndpoint pruned %v (%s) candidate set from %v to %v entries\", de.discoShort(), de.publicKey.ShortString(), size, size2)\n \t}\n \treturn false\n }\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/serve.go\n@@ -632,7 +632,7 @@ func (b *LocalBackend) getServeHandler(r *http.Request) (_ ipn.HTTPHandlerView,\n \n \thostname := r.Host\n \tif r.TLS == nil {\n-\t\ttcd := \".\" + b.Status().CurrentTailnet.MagicDNSSuffix\n+\t\ttcd := \".\" + b.CurrentProfile().NetworkProfile().MagicDNSName\n \t\tif host, _, err := net.SplitHostPort(hostname); err == nil {\n \t\t\thostname = host\n \t\t}\n---\n\n\n---\n\nChoice C:\nwgengine/magicsock/magicsock.go\n@@ -317,7 +317,11 @@ type Conn struct {\n \t// by node key, node ID, and discovery key.\n \tpeerMap peerMap\n \n-\t// discoInfo is the state for an active DiscoKey.\n+\t// relayManager manages allocation and handshaking of\n+\t// [tailscale.com/net/udprelay.Server] endpoints.\n+\trelayManager relayManager\n+\n+\t// discoInfo is the state for an active peer DiscoKey.\n \tdiscoInfo map[key.DiscoPublic]*discoInfo\n \n \t// netInfoFunc is a callback that provides a tailcfg.NetInfo when\n@@ -1628,9 +1632,11 @@ func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey ke\n \tvar di *discoInfo\n \tswitch {\n \tcase isRelayHandshakeMsg:\n-\t\t// TODO(jwhited): consider caching relay server disco shared keys\n-\t\tdi = &discoInfo{\n-\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n+\t\tvar ok bool\n+\t\tdi, ok = c.relayManager.discoInfo(dstDisco)\n+\t\tif !ok {\n+\t\t\tc.mu.Unlock()\n+\t\t\treturn false, errors.New(\"unknown relay server\")\n \t\t}\n \tcase c.peerMap.knownPeerDiscoKey(dstDisco):\n \t\tdi = c.discoInfoForKnownPeerLocked(dstDisco)\n@@ -1806,7 +1812,7 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \tswitch {\n \tcase shouldBeRelayHandshakeMsg:\n \t\tvar ok bool\n-\t\tdi, ok = c.discoInfoForRelayHandshakeLocked(sender, geneve.VNI)\n+\t\tdi, ok = c.relayManager.discoInfo(sender)\n \t\tif !ok {\n \t\t\tif debugDisco() {\n \t\t\t\tc.logf(\"magicsock: disco: ignoring disco-looking relay handshake frame, no active handshakes with key %v over VNI %d\", sender.ShortString(), geneve.VNI)\n@@ -1882,15 +1888,15 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t}\n \n \tif shouldBeRelayHandshakeMsg {\n-\t\t_, ok := dm.(*disco.BindUDPRelayEndpointChallenge)\n+\t\tchallenge, ok := dm.(*disco.BindUDPRelayEndpointChallenge)\n \t\tif !ok {\n \t\t\t// We successfully parsed the disco message, but it wasn't a\n \t\t\t// challenge. We should never receive other message types\n \t\t\t// from a relay server with the Geneve header control bit set.\n \t\t\tc.logf(\"[unexpected] %T packets should not come from a relay server with Geneve control bit set\", dm)\n \t\t\treturn\n \t\t}\n-\t\t// TODO(jwhited): handle the challenge on the associated [*endpoint]\n+\t\tc.relayManager.handleBindUDPRelayEndpointChallenge(challenge, di, src, geneve.VNI)\n \t\treturn\n \t}\n \n@@ -1909,18 +1915,28 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t\t\t}\n \t\t\treturn true\n \t\t})\n-\tcase *disco.CallMeMaybe:\n+\tcase *disco.CallMeMaybe, *disco.CallMeMaybeVia:\n+\t\tvar via *disco.CallMeMaybeVia\n+\t\tisVia := false\n+\t\tmsgType := \"CallMeMaybe\"\n+\t\tcmm, ok := dm.(*disco.CallMeMaybe)\n+\t\tif !ok {\n+\t\t\tvia = dm.(*disco.CallMeMaybeVia)\n+\t\t\tmsgType = \"CallMeMaybeVia\"\n+\t\t\tisVia = true\n+\t\t}\n+\n \t\tmetricRecvDiscoCallMeMaybe.Add(1)\n \t\tif !isDERP || derpNodeSrc.IsZero() {\n-\t\t\t// CallMeMaybe messages should only come via DERP.\n-\t\t\tc.logf(\"[unexpected] CallMeMaybe packets should only come via DERP\")\n+\t\t\t// CallMeMaybe{Via} messages should only come via DERP.\n+\t\t\tc.logf(\"[unexpected] %s packets should only come via DERP\", msgType)\n \t\t\treturn\n \t\t}\n \t\tnodeKey := derpNodeSrc\n \t\tep, ok := c.peerMap.endpointForNodeKey(nodeKey)\n \t\tif !ok {\n \t\t\tmetricRecvDiscoCallMeMaybeBadNode.Add(1)\n-\t\t\tc.logf(\"magicsock: disco: ignoring CallMeMaybe from %v; %v is unknown\", sender.ShortString(), derpNodeSrc.ShortString())\n+\t\t\tc.logf(\"magicsock: disco: ignoring %s from %v; %v is unknown\", msgType, sender.ShortString(), derpNodeSrc.ShortString())\n \t\t\treturn\n \t\t}\n \t\tepDisco := ep.disco.Load()\n@@ -1929,14 +1945,23 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t\t}\n \t\tif epDisco.key != di.discoKey {\n \t\t\tmetricRecvDiscoCallMeMaybeBadDisco.Add(1)\n-\t\t\tc.logf(\"[unexpected] CallMeMaybe from peer via DERP whose netmap discokey != disco source\")\n+\t\t\tc.logf(\"[unexpected] %s from peer via DERP whose netmap discokey != disco source\", msgType)\n \t\t\treturn\n \t\t}\n-\t\tc.dlogf(\"[v1] magicsock: disco: %v<-%v (%v, %v)  got call-me-maybe, %d endpoints\",\n-\t\t\tc.discoShort, epDisco.short,\n-\t\t\tep.publicKey.ShortString(), derpStr(src.String()),\n-\t\t\tlen(dm.MyNumber))\n-\t\tgo ep.handleCallMeMaybe(dm)\n+\t\tif isVia {\n+\t\t\tc.dlogf(\"[v1] magicsock: disco: %v<-%v via %v (%v, %v)  got call-me-maybe-via, %d endpoints\",\n+\t\t\t\tc.discoShort, epDisco.short, via.ServerDisco.ShortString(),\n+\t\t\t\tep.publicKey.ShortString(), derpStr(src.String()),\n+\t\t\t\tlen(via.AddrPorts))\n+\t\t\tc.relayManager.handleCallMeMaybeVia(via)\n+\t\t} else {\n+\t\t\tc.dlogf(\"[v1] magicsock: disco: %v<-%v (%v, %v)  got call-me-maybe, %d endpoints\",\n+\t\t\t\tc.discoShort, epDisco.short,\n+\t\t\t\tep.publicKey.ShortString(), derpStr(src.String()),\n+\t\t\t\tlen(cmm.MyNumber))\n+\t\t\tgo ep.handleCallMeMaybe(cmm)\n+\t\t}\n+\n \t}\n \treturn\n }\n@@ -2108,15 +2133,6 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \t}\n }\n \n-// discoInfoForRelayHandshakeLocked returns a [*discoInfo] for k and vni if one\n-// is known, i.e. an [endpoint] has an in-progress handshake with k over vni.\n-//\n-// c.mu must be held\n-func (c *Conn) discoInfoForRelayHandshakeLocked(k key.DiscoPublic, vni uint32) (*discoInfo, bool) {\n-\t// TODO(jwhited): implement\n-\treturn nil, false\n-}\n-\n // discoInfoForKnownPeerLocked returns the previous or new discoInfo for k.\n //\n // Callers must only pass key.DiscoPublic's that are present in and\n---\nwgengine/magicsock/relaymanager.go\n@@ -0,0 +1,51 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package magicsock\n+\n+import (\n+\t\"net/netip\"\n+\t\"sync\"\n+\n+\t\"tailscale.com/disco\"\n+\t\"tailscale.com/types/key\"\n+)\n+\n+// relayManager manages allocation and handshaking of\n+// [tailscale.com/net/udprelay.Server] endpoints. The zero value is ready for\n+// use.\n+type relayManager struct {\n+\tmu                     sync.Mutex // guards the following fields\n+\tdiscoInfoByServerDisco map[key.DiscoPublic]*discoInfo\n+}\n+\n+func (h *relayManager) initLocked() {\n+\tif h.discoInfoByServerDisco != nil {\n+\t\treturn\n+\t}\n+\th.discoInfoByServerDisco = make(map[key.DiscoPublic]*discoInfo)\n+}\n+\n+// discoInfo returns a [*discoInfo] for 'serverDisco' if there is an\n+// active/ongoing handshake with it, otherwise it returns nil, false.\n+func (h *relayManager) discoInfo(serverDisco key.DiscoPublic) (_ *discoInfo, ok bool) {\n+\th.mu.Lock()\n+\tdefer h.mu.Unlock()\n+\th.initLocked()\n+\tdi, ok := h.discoInfoByServerDisco[serverDisco]\n+\treturn di, ok\n+}\n+\n+func (h *relayManager) handleCallMeMaybeVia(dm *disco.CallMeMaybeVia) {\n+\th.mu.Lock()\n+\tdefer h.mu.Unlock()\n+\th.initLocked()\n+\t// TODO(jwhited): implement\n+}\n+\n+func (h *relayManager) handleBindUDPRelayEndpointChallenge(dm *disco.BindUDPRelayEndpointChallenge, di *discoInfo, src netip.AddrPort, vni uint32) {\n+\th.mu.Lock()\n+\tdefer h.mu.Unlock()\n+\th.initLocked()\n+\t// TODO(jwhited): implement\n+}\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/cli.go\n@@ -164,7 +164,7 @@ func Run(args []string) (err error) {\n \n \terr = rootCmd.Run(context.Background())\n \tif tailscale.IsAccessDeniedError(err) && os.Getuid() != 0 && runtime.GOOS != \"windows\" {\n-\t\treturn fmt.Errorf(\"%v\\n\\nUse 'sudo tailscale %s' or 'tailscale up --operator=$USER' to not require root.\", err, strings.Join(args, \" \"))\n+\t\treturn fmt.Errorf(\"%v\\n\\nUse 'sudo tailscale %s'.\\nTo not require root, use 'sudo tailscale set --operator=$USER' once.\", err, strings.Join(args, \" \"))\n \t}\n \tif errors.Is(err, flag.ErrHelp) {\n \t\treturn nil\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/corp#24795\n\n---\n\nChoice A:\nsyncs/syncs.go\n@@ -67,12 +67,18 @@ func (v *AtomicValue[T]) Swap(x T) (old T) {\n \tif oldV != nil {\n \t\treturn oldV.(wrappedValue[T]).v\n \t}\n-\treturn old\n+\treturn old // zero value of T\n }\n \n // CompareAndSwap executes the compare-and-swap operation for the Value.\n+// It panics if T is not comparable.\n func (v *AtomicValue[T]) CompareAndSwap(oldV, newV T) (swapped bool) {\n-\treturn v.v.CompareAndSwap(wrappedValue[T]{oldV}, wrappedValue[T]{newV})\n+\tvar zero T\n+\treturn v.v.CompareAndSwap(wrappedValue[T]{oldV}, wrappedValue[T]{newV}) ||\n+\t\t// In the edge-case where [atomic.Value.Store] is uninitialized\n+\t\t// and trying to compare with the zero value of T,\n+\t\t// then compare-and-swap with the nil any value.\n+\t\t(any(oldV) == any(zero) && v.v.CompareAndSwap(any(nil), wrappedValue[T]{newV}))\n }\n \n // MutexValue is a value protected by a mutex.\n---\nsyncs/syncs_test.go\n@@ -64,6 +64,23 @@ func TestAtomicValue(t *testing.T) {\n \t\t\tt.Fatalf(\"LoadOk = (%v, %v), want (nil, true)\", got, gotOk)\n \t\t}\n \t}\n+\n+\t{\n+\t\tc1, c2, c3 := make(chan struct{}), make(chan struct{}), make(chan struct{})\n+\t\tvar v AtomicValue[chan struct{}]\n+\t\tif v.CompareAndSwap(c1, c2) != false {\n+\t\t\tt.Fatalf(\"CompareAndSwap = true, want false\")\n+\t\t}\n+\t\tif v.CompareAndSwap(nil, c1) != true {\n+\t\t\tt.Fatalf(\"CompareAndSwap = false, want true\")\n+\t\t}\n+\t\tif v.CompareAndSwap(c2, c3) != false {\n+\t\t\tt.Fatalf(\"CompareAndSwap = true, want false\")\n+\t\t}\n+\t\tif v.CompareAndSwap(c1, c2) != true {\n+\t\t\tt.Fatalf(\"CompareAndSwap = false, want true\")\n+\t\t}\n+\t}\n }\n \n func TestMutexValue(t *testing.T) {\n---\n\n\n---\n\nChoice B:\ncmd/k8s-operator/svc-for-pg.go\n@@ -211,6 +211,11 @@ func (r *HAServiceReconciler) maybeProvision(ctx context.Context, hostname strin\n \t// already created and not owned by this Service.\n \tserviceName := tailcfg.ServiceName(\"svc:\" + hostname)\n \texistingVIPSvc, err := r.tsClient.GetVIPService(ctx, serviceName)\n+\tif isErrorFeatureFlagNotEnabled(err) {\n+\t\tlogger.Warn(msgFeatureFlagNotEnabled)\n+\t\tr.recorder.Event(svc, corev1.EventTypeWarning, warningTailscaleServiceFeatureFlagNotEnabled, msgFeatureFlagNotEnabled)\n+\t\treturn false, nil\n+\t}\n \tif err != nil && !isErrorTailscaleServiceNotFound(err) {\n \t\treturn false, fmt.Errorf(\"error getting Tailscale Service %q: %w\", hostname, err)\n \t}\n@@ -529,6 +534,11 @@ func (r *HAServiceReconciler) tailnetCertDomain(ctx context.Context) (string, er\n // It returns true if an existing VIPService was updated to remove owner reference, as well as any error that occurred.\n func (r *HAServiceReconciler) cleanupVIPService(ctx context.Context, name tailcfg.ServiceName, logger *zap.SugaredLogger) (updated bool, err error) {\n \tsvc, err := r.tsClient.GetVIPService(ctx, name)\n+\tif isErrorFeatureFlagNotEnabled(err) {\n+\t\tmsg := fmt.Sprintf(\"Unable to proceed with cleanup: %s.\", msgFeatureFlagNotEnabled)\n+\t\tlogger.Warn(msg)\n+\t\treturn false, nil\n+\t}\n \tif err != nil {\n \t\terrResp := &tailscale.ErrResponse{}\n \t\tok := errors.As(err, errResp)\n---\n\n\n---\n\nChoice C:\ngo.mod\n@@ -98,14 +98,14 @@ require (\n \tgo.uber.org/zap v1.27.0\n \tgo4.org/mem v0.0.0-20240501181205-ae6ca9944745\n \tgo4.org/netipx v0.0.0-20231129151722-fdeea329fbba\n-\tgolang.org/x/crypto v0.35.0\n+\tgolang.org/x/crypto v0.37.0\n \tgolang.org/x/exp v0.0.0-20250210185358-939b2ce775ac\n \tgolang.org/x/mod v0.23.0\n \tgolang.org/x/net v0.36.0\n \tgolang.org/x/oauth2 v0.26.0\n-\tgolang.org/x/sync v0.11.0\n-\tgolang.org/x/sys v0.31.0\n-\tgolang.org/x/term v0.29.0\n+\tgolang.org/x/sync v0.13.0\n+\tgolang.org/x/sys v0.32.0\n+\tgolang.org/x/term v0.31.0\n \tgolang.org/x/time v0.10.0\n \tgolang.org/x/tools v0.30.0\n \tgolang.zx2c4.com/wintun v0.0.0-20230126152724-0fa3db229ce2\n@@ -392,7 +392,7 @@ require (\n \tgo.uber.org/multierr v1.11.0 // indirect\n \tgolang.org/x/exp/typeparams v0.0.0-20240314144324-c7f7c6466f7f // indirect\n \tgolang.org/x/image v0.24.0 // indirect\n-\tgolang.org/x/text v0.22.0 // indirect\n+\tgolang.org/x/text v0.24.0 // indirect\n \tgomodules.xyz/jsonpatch/v2 v2.4.0 // indirect\n \tgoogle.golang.org/protobuf v1.35.1 // indirect\n \tgopkg.in/inf.v0 v0.9.1 // indirect\n---\ngo.sum\n@@ -1087,8 +1087,8 @@ golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5y\n golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=\n golang.org/x/crypto v0.1.0/go.mod h1:RecgLatLF4+eUMCP1PoPZQb+cVrJcOPbHkTkbkB9sbw=\n golang.org/x/crypto v0.3.0/go.mod h1:hebNnKkNXi2UzZN1eVRvBB7co0a+JxK6XbPiWVs/3J4=\n-golang.org/x/crypto v0.35.0 h1:b15kiHdrGCHrP6LvwaQ3c03kgNhhiMgvlhxHQhmg2Xs=\n-golang.org/x/crypto v0.35.0/go.mod h1:dy7dXNW32cAb/6/PRuTNsix8T+vJAqvuIy5Bli/x0YQ=\n+golang.org/x/crypto v0.37.0 h1:kJNSjF/Xp7kU0iB2Z+9viTPMW4EqqsrywMXLJOOsXSE=\n+golang.org/x/crypto v0.37.0/go.mod h1:vg+k43peMZ0pUMhYmVAWysMK35e6ioLh3wB8ZCAfbVc=\n golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\n golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\n golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\n@@ -1200,8 +1200,8 @@ golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJ\n golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n-golang.org/x/sync v0.11.0 h1:GGz8+XQP4FvTTrjZPzNKTMFtSXH80RAzG+5ghFPgK9w=\n-golang.org/x/sync v0.11.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\n+golang.org/x/sync v0.13.0 h1:AauUjRAJ9OSnvULf/ARrrVywoJDy0YS2AwQ98I37610=\n+golang.org/x/sync v0.13.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=\n golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n@@ -1264,16 +1264,16 @@ golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n-golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=\n-golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n+golang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=\n+golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.2.0/go.mod h1:TVmDHMZPmdnySmBfhjOoOdhjzdE1h4u1VwSiw2l1Nuc=\n golang.org/x/term v0.4.0/go.mod h1:9P2UbLfCdcvo3p/nzKvsmas4TnlujnuoV9hGgYzW1lQ=\n golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\n-golang.org/x/term v0.29.0 h1:L6pJp37ocefwRRtYPKSWOWzOtWSxVajvz2ldH/xi3iU=\n-golang.org/x/term v0.29.0/go.mod h1:6bl4lRlvVuDgSf3179VpIxBF0o10JUpXWOnI7nErv7s=\n+golang.org/x/term v0.31.0 h1:erwDkOK1Msy6offm1mOgvspSkslFnIGsFnxOKoufg3o=\n+golang.org/x/term v0.31.0/go.mod h1:R4BeIy7D95HzImkxGkTW1UQTtP54tio2RyHz7PwK0aw=\n golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n@@ -1284,8 +1284,8 @@ golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\n golang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n golang.org/x/text v0.6.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n-golang.org/x/text v0.22.0 h1:bofq7m3/HAFvbF51jz3Q9wLg3jkvSPuiZu/pD1XwgtM=\n-golang.org/x/text v0.22.0/go.mod h1:YRoo4H8PVmsu+E3Ou7cqLVH8oXWIHVoX0jqUWALQhfY=\n+golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=\n+golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=\n golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n---\n\n\n---\n\nChoice D:\nwords/scales.txt\n@@ -440,3 +440,5 @@ sidemirror\n wage\n salary\n fujita\n+caiman\n+cichlid\n---\nwords/tails.txt\n@@ -720,3 +720,5 @@ mining\n coat\n follow\n stalk\n+caudal\n+chronicle\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #cleanup\n\n---\n\nChoice A:\ndocs/windows/policy/en-US/tailscale.adml\n@@ -16,6 +16,7 @@\n             <string id=\"SINCE_V1_62\">Tailscale version 1.62.0 and later</string>\n             <string id=\"SINCE_V1_74\">Tailscale version 1.74.0 and later</string>\n             <string id=\"SINCE_V1_78\">Tailscale version 1.78.0 and later</string>\n+            <string id=\"SINCE_V1_80\">Tailscale version 1.80.0 and later</string>\n             <string id=\"SINCE_V1_82\">Tailscale version 1.82.0 and later</string>\n             <string id=\"SINCE_V1_84\">Tailscale version 1.84.0 and later</string>\n             <string id=\"Tailscale_Category\">Tailscale</string>\n@@ -271,6 +272,12 @@ If you enable this policy, the menu item will be displayed indicating the organi\n If you disable this policy or do not configure it, the corresponding menu item will be hidden.\n \n See https://tailscale.com/kb/1315/mdm-keys#set-your-organization-name for more details.]]></string>\n+            <string id=\"OnboardingFlow\">Show the onboarding flow</string>\n+            <string id=\"OnboardingFlow_Help\"><![CDATA[This policy can be used to show or hide the onboarding flow displayed by the GUI.\n+\n+If you enable or don't configure this policy, the onboarding flow will be shown to new users who have not yet signed in to a Tailscale account.\n+\n+If you disable this policy, the onboarding flow will never be shown.]]></string>\n         </stringTable>\n         <presentationTable>\n             <presentation id=\"LoginURL\">\n---\ndocs/windows/policy/tailscale.admx\n@@ -54,6 +54,10 @@\n                   displayName=\"$(string.SINCE_V1_78)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n       </definition>\n+      <definition name=\"SINCE_V1_80\"\n+                  displayName=\"$(string.SINCE_V1_80)\">\n+        <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n+      </definition>\n       <definition name=\"SINCE_V1_82\"\n                   displayName=\"$(string.SINCE_V1_82)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n@@ -335,6 +339,16 @@\n         <string>hide</string>\n       </disabledValue>\n     </policy>\n+    <policy name=\"OnboardingFlow\" class=\"Both\" displayName=\"$(string.OnboardingFlow)\" explainText=\"$(string.OnboardingFlow_Help)\" key=\"Software\\Policies\\Tailscale\" valueName=\"OnboardingFlow\">\n+      <parentCategory ref=\"UI_Category\" />\n+      <supportedOn ref=\"SINCE_V1_80\" />\n+      <enabledValue>\n+        <string>show</string>\n+      </enabledValue>\n+      <disabledValue>\n+        <string>hide</string>\n+      </disabledValue>\n+    </policy>\n     <policy name=\"ManagedBy\" class=\"Both\" displayName=\"$(string.ManagedBy)\" explainText=\"$(string.ManagedBy_Help)\" presentation=\"$(presentation.ManagedBy)\" key=\"Software\\Policies\\Tailscale\">\n       <parentCategory ref=\"UI_Category\" />\n       <supportedOn ref=\"SINCE_V1_62\" />\n---\n\n\n---\n\nChoice B:\nwgengine/magicsock/endpoint.go\n@@ -1480,7 +1480,7 @@ func (de *endpoint) addCandidateEndpoint(ep netip.AddrPort, forRxPingTxID stun.T\n \t\t\t}\n \t\t}\n \t\tsize2 := len(de.endpointState)\n-\t\tde.c.dlogf(\"[v1] magicsock: disco: addCandidateEndpoint pruned %v candidate set from %v to %v entries\", size, size2)\n+\t\tde.c.dlogf(\"[v1] magicsock: disco: addCandidateEndpoint pruned %v (%s) candidate set from %v to %v entries\", de.discoShort(), de.publicKey.ShortString(), size, size2)\n \t}\n \treturn false\n }\n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -49,7 +49,7 @@ jobs:\n \n     # Install a more recent Go that understands modern go.mod content.\n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n \n---\n.github/workflows/golangci-lint.yml\n@@ -25,7 +25,7 @@ jobs:\n     steps:\n       - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n-      - uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      - uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n         with:\n           go-version-file: go.mod\n           cache: false\n---\n.github/workflows/test.yml\n@@ -151,7 +151,7 @@ jobs:\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n         cache: false\n---\n\n\n---\n\nChoice D:\nwgengine/netstack/netstack.go\n@@ -327,10 +327,15 @@ func Create(logf logger.Logf, tundev *tstun.Wrapper, e wgengine.Engine, mc *magi\n \tif tcpipErr != nil {\n \t\treturn nil, fmt.Errorf(\"could not disable TCP RACK: %v\", tcpipErr)\n \t}\n-\tcubicOpt := tcpip.CongestionControlOption(\"cubic\")\n-\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &cubicOpt)\n+\t// gVisor defaults to reno at the time of writing. We explicitly set reno\n+\t// congestion control in order to prevent unexpected changes. Netstack\n+\t// has an int overflow in sender congestion window arithmetic that is more\n+\t// prone to trigger with cubic congestion control.\n+\t// See https://github.com/google/gvisor/issues/11632\n+\trenoOpt := tcpip.CongestionControlOption(\"reno\")\n+\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &renoOpt)\n \tif tcpipErr != nil {\n-\t\treturn nil, fmt.Errorf(\"could not set cubic congestion control: %v\", tcpipErr)\n+\t\treturn nil, fmt.Errorf(\"could not set reno congestion control: %v\", tcpipErr)\n \t}\n \terr := setTCPBufSizes(ipstack)\n \tif err != nil {\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUse of the httptest client doesn't render header ordering as expected.\r\n\r\nUse http.DefaultClient for the test to ensure that the header ordering test is valid.\r\n\r\nUpdates tailscale/corp#27370\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -2404,11 +2404,9 @@ func (b *LocalBackend) Start(opts ipn.Options) error {\n \t}\n \n \tvar auditLogShutdown func()\n-\t// Audit logging is only available if the client has set up a proper persistent\n-\t// store for the logs in sys.\n \tstore, ok := b.sys.AuditLogStore.GetOK()\n \tif !ok {\n-\t\tb.logf(\"auditlog: [unexpected] no persistent audit log storage configured.  using memory store.\")\n+\t\t// Use memory store by default if no explicit store is provided.\n \t\tstore = auditlog.NewLogStore(&memstore.Store{})\n \t}\n \n---\n\n\n---\n\nChoice B:\ntsnet/tsnet_test.go\n@@ -120,6 +120,7 @@ func startControl(t *testing.T) (controlURL string, control *testcontrol.Server)\n \t\t\tProxied: true,\n \t\t},\n \t\tMagicDNSDomain: \"tail-scale.ts.net\",\n+\t\tLogf:           t.Logf,\n \t}\n \tcontrol.HTTPTestServer = httptest.NewUnstartedServer(control)\n \tcontrol.HTTPTestServer.Start()\n@@ -221,7 +222,7 @@ func startServer(t *testing.T, ctx context.Context, controlURL, hostname string)\n \t\tgetCertForTesting: testCertRoot.getCert,\n \t}\n \tif *verboseNodes {\n-\t\ts.Logf = log.Printf\n+\t\ts.Logf = t.Logf\n \t}\n \tt.Cleanup(func() { s.Close() })\n \n---\n\n\n---\n\nChoice C:\ncmd/k8s-operator/deploy/chart/templates/deployment.yaml\n@@ -64,6 +64,8 @@ spec:\n               value: operator\n             - name: OPERATOR_LOGGING\n               value: {{ .Values.operatorConfig.logging }}\n+            - name: OPERATOR_EPHEMERAL\n+              value: \"{{ .Values.operatorConfig.ephemeral }}\"\n             - name: OPERATOR_NAMESPACE\n               valueFrom:\n                 fieldRef:\n---\ncmd/k8s-operator/deploy/chart/values.yaml\n@@ -36,6 +36,10 @@ operatorConfig:\n   # Multiple tags are defined as array items and passed to the operator as a comma-separated string\n   defaultTags:\n     - \"tag:k8s-operator\"\n+  \n+  # When true, the operator will use an ephemeral auth key\n+  # https://tailscale.com/kb/1111/ephemeral-nodes/\n+  ephemeral: false\n \n   image:\n     # Repository defaults to DockerHub, but images are also synced to ghcr.io/tailscale/k8s-operator.\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -2215,6 +2215,14 @@ spec:\n                         https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n                         Defaults to false.\n                       type: boolean\n+                    ephemeral:\n+                      description: |-\n+                        Ephemeral can be set to true to make the proxy instance register\n+                        as an ephemeral node. Ephemeral nodes are automatically deleted\n+                        from the tailnet when they are offline for a while.\n+                        https://tailscale.com/kb/1111/ephemeral-nodes/\n+                        Defaults to false.\n+                      type: boolean\n                 useLetsEncryptStagingEnvironment:\n                   description: |-\n                     Set UseLetsEncryptStagingEnvironment to true to issue TLS\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -2684,6 +2684,14 @@ spec:\n                                             https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n                                             Defaults to false.\n                                         type: boolean\n+                                    ephemeral:\n+                                        description: |-\n+                                            Ephemeral can be set to true to make the proxy instance register\n+                                            as an ephemeral node. Ephemeral nodes are automatically deleted\n+                                            from the tailnet when they are offline for a while.\n+                                            https://tailscale.com/kb/1111/ephemeral-nodes/\n+                                            Defaults to false.\n+                                        type: boolean\n                                 type: object\n                             useLetsEncryptStagingEnvironment:\n                                 description: |-\n@@ -5009,6 +5017,8 @@ spec:\n                       value: operator\n                     - name: OPERATOR_LOGGING\n                       value: info\n+                    - name: OPERATOR_EPHEMERAL\n+                      value: \"false\"\n                     - name: OPERATOR_NAMESPACE\n                       valueFrom:\n                         fieldRef:\n---\ncmd/k8s-operator/operator.go\n@@ -139,6 +139,7 @@ func initTSNet(zlog *zap.SugaredLogger) (*tsnet.Server, tsClient) {\n \t\thostname         = defaultEnv(\"OPERATOR_HOSTNAME\", \"tailscale-operator\")\n \t\tkubeSecret       = defaultEnv(\"OPERATOR_SECRET\", \"\")\n \t\toperatorTags     = defaultEnv(\"OPERATOR_INITIAL_TAGS\", \"tag:k8s-operator\")\n+\t\tephemeral        = defaultBool(\"OPERATOR_EPHEMERAL\", false)\n \t)\n \tstartlog := zlog.Named(\"startup\")\n \tif clientIDPath == \"\" || clientSecretPath == \"\" {\n@@ -196,6 +197,7 @@ waitOnline:\n \t\t\t\t\tCreate: tailscale.KeyDeviceCreateCapabilities{\n \t\t\t\t\t\tReusable:      false,\n \t\t\t\t\t\tPreauthorized: true,\n+\t\t\t\t\t\tEphemeral:     ephemeral,\n \t\t\t\t\t\tTags:          strings.Split(operatorTags, \",\"),\n \t\t\t\t\t},\n \t\t\t\t},\n---\ncmd/k8s-operator/proxygroup.go\n@@ -477,7 +477,11 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t\tif len(tags) == 0 {\n \t\t\t\ttags = r.defaultTags\n \t\t\t}\n-\t\t\tauthKey, err = newAuthKey(ctx, r.tsClient, tags)\n+\t\t\tephemeral := false\n+\t\t\tif proxyClass != nil && proxyClass.Spec.TailscaleConfig != nil {\n+\t\t\t\tephemeral = proxyClass.Spec.TailscaleConfig.Ephemeral\n+\t\t\t}\n+\t\t\tauthKey, err = newAuthKey(ctx, r.tsClient, tags, ephemeral)\n \t\t\tif err != nil {\n \t\t\t\treturn \"\", err\n \t\t\t}\n---\ncmd/k8s-operator/sts.go\n@@ -376,7 +376,7 @@ func (a *tailscaleSTSReconciler) createOrGetSecret(ctx context.Context, logger *\n \t\tif len(tags) == 0 {\n \t\t\ttags = a.defaultTags\n \t\t}\n-\t\tauthKey, err = newAuthKey(ctx, a.tsClient, tags)\n+\t\tauthKey, err = newAuthKey(ctx, a.tsClient, tags, shouldUseEphemeral(stsC.ProxyClass))\n \t\tif err != nil {\n \t\t\treturn \"\", \"\", nil, err\n \t\t}\n@@ -511,12 +511,13 @@ func deviceInfo(sec *corev1.Secret, podUID string, log *zap.SugaredLogger) (dev\n \treturn dev, nil\n }\n \n-func newAuthKey(ctx context.Context, tsClient tsClient, tags []string) (string, error) {\n+func newAuthKey(ctx context.Context, tsClient tsClient, tags []string, ephemeral bool) (string, error) {\n \tcaps := tailscale.KeyCapabilities{\n \t\tDevices: tailscale.KeyDeviceCapabilities{\n \t\t\tCreate: tailscale.KeyDeviceCreateCapabilities{\n \t\t\t\tReusable:      false,\n \t\t\t\tPreauthorized: true,\n+\t\t\t\tEphemeral:     ephemeral,\n \t\t\t\tTags:          tags,\n \t\t\t},\n \t\t},\n@@ -1022,6 +1023,10 @@ func shouldAcceptRoutes(pc *tsapi.ProxyClass) bool {\n \treturn pc != nil && pc.Spec.TailscaleConfig != nil && pc.Spec.TailscaleConfig.AcceptRoutes\n }\n \n+func shouldUseEphemeral(pc *tsapi.ProxyClass) bool {\n+\treturn pc != nil && pc.Spec.TailscaleConfig != nil && pc.Spec.TailscaleConfig.Ephemeral\n+}\n+\n // ptrObject is a type constraint for pointer types that implement\n // client.Object.\n type ptrObject[T any] interface {\n---\ncmd/k8s-operator/tsrecorder.go\n@@ -289,7 +289,7 @@ func (r *RecorderReconciler) ensureAuthSecretCreated(ctx context.Context, tsr *t\n \tif len(tags) == 0 {\n \t\ttags = tsapi.Tags{\"tag:k8s\"}\n \t}\n-\tauthKey, err := newAuthKey(ctx, r.tsClient, tags.Stringify())\n+\tauthKey, err := newAuthKey(ctx, r.tsClient, tags.Stringify(), false)\n \tif err != nil {\n \t\treturn err\n \t}\n---\nk8s-operator/api.md\n@@ -1013,5 +1013,6 @@ _Appears in:_\n | Field | Description | Default | Validation |\n | --- | --- | --- | --- |\n | `acceptRoutes` _boolean_ | AcceptRoutes can be set to true to make the proxy instance accept<br />routes advertized by other nodes on the tailnet, such as subnet<br />routes.<br />This is equivalent of passing --accept-routes flag to a tailscale Linux client.<br />https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices<br />Defaults to false. |  |  |\n+| `ephemeral` _boolean_ | Ephemeral can be set to true to make the proxy instance register<br />as an ephemeral node. Ephemeral nodes are automatically deleted<br />from the tailnet when they are offline for a while.<br />https://tailscale.com/kb/1111/ephemeral-nodes/<br />Defaults to false. |  |  |\n \n \n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -91,6 +91,13 @@ type TailscaleConfig struct {\n \t// https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n \t// Defaults to false.\n \tAcceptRoutes bool `json:\"acceptRoutes,omitempty\"`\n+\n+\t// Ephemeral can be set to true to make the proxy instance register\n+\t// as an ephemeral node. Ephemeral nodes are automatically deleted\n+\t// from the tailnet when they are offline for a while.\n+\t// https://tailscale.com/kb/1111/ephemeral-nodes/\n+\t// Defaults to false.\n+\tEphemeral bool `json:\"ephemeral,omitempty\"`\n }\n \n type StatefulSet struct {\n---\n\n\n---\n\nChoice D:\nprober/prober_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n+\t\"net/http\"\n \t\"net/http/httptest\"\n \t\"strings\"\n \t\"sync\"\n@@ -586,30 +587,48 @@ func TestProberRunHandler(t *testing.T) {\n \t\t\t\tdefer probe.Close()\n \t\t\t\t<-probe.stopped // wait for the first run.\n \n-\t\t\t\tw := httptest.NewRecorder()\n+\t\t\t\tmux := http.NewServeMux()\n+\t\t\t\tserver := httptest.NewServer(mux)\n+\t\t\t\tdefer server.Close()\n+\n+\t\t\t\tmux.Handle(\"/prober/run/\", tsweb.StdHandler(tsweb.ReturnHandlerFunc(p.RunHandler), tsweb.HandlerOptions{}))\n+\n+\t\t\t\treq, err := http.NewRequest(\"GET\", server.URL+\"/prober/run/?name=\"+tt.name, nil)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"failed to create request: %v\", err)\n+\t\t\t\t}\n \n-\t\t\t\treq := httptest.NewRequest(\"GET\", \"/prober/run/?name=\"+tt.name, nil)\n \t\t\t\tif reqJSON {\n \t\t\t\t\treq.Header.Set(\"Accept\", \"application/json\")\n \t\t\t\t}\n-\t\t\t\ttsweb.StdHandler(tsweb.ReturnHandlerFunc(p.RunHandler), tsweb.HandlerOptions{}).ServeHTTP(w, req)\n-\t\t\t\tif w.Result().StatusCode != tt.wantResponseCode {\n-\t\t\t\t\tt.Errorf(\"unexpected response code: got %d, want %d\", w.Code, tt.wantResponseCode)\n+\n+\t\t\t\tresp, err := http.DefaultClient.Do(req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"failed to make request: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif resp.StatusCode != tt.wantResponseCode {\n+\t\t\t\t\tt.Errorf(\"unexpected response code: got %d, want %d\", resp.StatusCode, tt.wantResponseCode)\n \t\t\t\t}\n \n \t\t\t\tif reqJSON {\n-\t\t\t\t\tif w.Header().Get(\"Content-Type\") != \"application/json\" {\n-\t\t\t\t\t\tt.Errorf(\"unexpected content type: got %q, want application/json\", w.Header().Get(\"Content-Type\"))\n+\t\t\t\t\tif resp.Header.Get(\"Content-Type\") != \"application/json\" {\n+\t\t\t\t\t\tt.Errorf(\"unexpected content type: got %q, want application/json\", resp.Header.Get(\"Content-Type\"))\n \t\t\t\t\t}\n \t\t\t\t\tvar gotJSON RunHandlerResponse\n-\t\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), &gotJSON); err != nil {\n-\t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, w.Body.String())\n+\t\t\t\t\tbody, err := io.ReadAll(resp.Body)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tt.Fatalf(\"failed to read response body: %v\", err)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif err := json.Unmarshal(body, &gotJSON); err != nil {\n+\t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, body)\n \t\t\t\t\t}\n \t\t\t\t\tif diff := cmp.Diff(tt.wantJSONResponse, gotJSON, cmpopts.IgnoreFields(ProbeInfo{}, \"Start\", \"End\", \"Labels\", \"RecentLatencies\")); diff != \"\" {\n \t\t\t\t\t\tt.Errorf(\"unexpected JSON response (-want +got):\\n%s\", diff)\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tbody, _ := io.ReadAll(w.Result().Body)\n+\t\t\t\t\tbody, _ := io.ReadAll(resp.Body)\n \t\t\t\t\tif !strings.Contains(string(body), tt.wantPlaintextResponse) {\n \t\t\t\t\t\tt.Errorf(\"unexpected response body: got %q, want to contain %q\", body, tt.wantPlaintextResponse)\n \t\t\t\t\t}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nContent-type was responding as test/plain for probes accepting application/json. Set content type header before setting the response code to correct this.\r\n\r\nUpdates tailscale/corp#27370\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -6146,17 +6146,17 @@ func (b *LocalBackend) setTCPPortsInterceptedFromNetmapAndPrefsLocked(prefs ipn.\n \t\t}\n \t}\n \n-\t// Update funnel info in hostinfo and kick off control update if needed.\n-\tb.updateIngressLocked()\n+\t// Update funnel and service hash info in hostinfo and kick off control update if needed.\n+\tb.updateIngressAndServiceHashLocked(prefs)\n \tb.setTCPPortsIntercepted(handlePorts)\n \tb.setVIPServicesTCPPortsInterceptedLocked(vipServicesPorts)\n }\n \n-// updateIngressLocked updates the hostinfo.WireIngress and hostinfo.IngressEnabled fields and kicks off a Hostinfo\n-// update if the values have changed.\n+// updateIngressAndServiceHashLocked updates the hostinfo.ServicesHash, hostinfo.WireIngress and\n+// hostinfo.IngressEnabled fields and kicks off a Hostinfo update if the values have changed.\n //\n // b.mu must be held.\n-func (b *LocalBackend) updateIngressLocked() {\n+func (b *LocalBackend) updateIngressAndServiceHashLocked(prefs ipn.PrefsView) {\n \tif b.hostinfo == nil {\n \t\treturn\n \t}\n@@ -6171,6 +6171,11 @@ func (b *LocalBackend) updateIngressLocked() {\n \t\tb.hostinfo.WireIngress = wire\n \t\thostInfoChanged = true\n \t}\n+\tlatestHash := b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\tif b.hostinfo.ServicesHash != latestHash {\n+\t\tb.hostinfo.ServicesHash = latestHash\n+\t\thostInfoChanged = true\n+\t}\n \t// Kick off a Hostinfo update to control if ingress status has changed.\n \tif hostInfoChanged {\n \t\tb.goTracker.Go(b.doSetHostinfoFilterServices)\n---\nipn/ipnlocal/local_test.go\n@@ -5134,10 +5134,17 @@ func TestUpdatePrefsOnSysPolicyChange(t *testing.T) {\n \t}\n }\n \n-func TestUpdateIngressLocked(t *testing.T) {\n+func TestUpdateIngressAndServiceHashLocked(t *testing.T) {\n+\tprefs := ipn.NewPrefs().View()\n+\tpreviousSC := &ipn.ServeConfig{\n+\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\"svc:abc\": {Tun: true},\n+\t\t},\n+\t}\n \ttests := []struct {\n \t\tname              string\n \t\thi                *tailcfg.Hostinfo\n+\t\thasPreviousSC     bool // whether to overwrite the ServeConfig hash in the Hostinfo using previousSC\n \t\tsc                *ipn.ServeConfig\n \t\twantIngress       bool\n \t\twantWireIngress   bool\n@@ -5163,6 +5170,16 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantWireIngress:   false, // implied by wantIngress\n \t\t\twantControlUpdate: true,\n \t\t},\n+\t\t{\n+\t\t\tname: \"empty_hostinfo_service_configured\",\n+\t\t\thi:   &tailcfg.Hostinfo{},\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t\t{\n \t\t\tname: \"empty_hostinfo_funnel_disabled\",\n \t\t\thi:   &tailcfg.Hostinfo{},\n@@ -5175,7 +5192,7 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantControlUpdate: true,\n \t\t},\n \t\t{\n-\t\t\tname: \"empty_hostinfo_no_funnel\",\n+\t\t\tname: \"empty_hostinfo_no_funnel_no_service\",\n \t\t\thi:   &tailcfg.Hostinfo{},\n \t\t\tsc: &ipn.ServeConfig{\n \t\t\t\tTCP: map[uint16]*ipn.TCPPortHandler{\n@@ -5196,6 +5213,16 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantIngress:     true,\n \t\t\twantWireIngress: false, // implied by wantIngress\n \t\t},\n+\t\t{\n+\t\t\tname:          \"service_hash_no_change\",\n+\t\t\thi:            &tailcfg.Hostinfo{},\n+\t\t\thasPreviousSC: true,\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n \t\t{\n \t\t\tname: \"funnel_disabled_no_change\",\n \t\t\thi: &tailcfg.Hostinfo{\n@@ -5208,6 +5235,13 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t},\n \t\t\twantWireIngress: true, // true if there is any AllowFunnel block\n \t\t},\n+\t\t{\n+\t\t\tname:              \"service_got_removed\",\n+\t\t\thi:                &tailcfg.Hostinfo{},\n+\t\t\thasPreviousSC:     true,\n+\t\t\tsc:                &ipn.ServeConfig{},\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t\t{\n \t\t\tname: \"funnel_changes_to_disabled\",\n \t\t\thi: &tailcfg.Hostinfo{\n@@ -5235,12 +5269,35 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantWireIngress:   false, // implied by wantIngress\n \t\t\twantControlUpdate: true,\n \t\t},\n+\t\t{\n+\t\t\tname: \"both_funnel_and_service_changes\",\n+\t\t\thi: &tailcfg.Hostinfo{\n+\t\t\t\tIngressEnabled: true,\n+\t\t\t},\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tAllowFunnel: map[ipn.HostPort]bool{\n+\t\t\t\t\t\"tailnet.xyz:443\": false,\n+\t\t\t\t},\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantWireIngress:   true, // true if there is any AllowFunnel block\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t}\n \n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tt.Parallel()\n \t\t\tb := newTestLocalBackend(t)\n \t\t\tb.hostinfo = tt.hi\n+\t\t\tif tt.hasPreviousSC {\n+\t\t\t\tb.mu.Lock()\n+\t\t\t\tb.serveConfig = previousSC.View()\n+\t\t\t\tb.hostinfo.ServicesHash = b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\t\t\t\tb.mu.Unlock()\n+\t\t\t}\n \t\t\tb.serveConfig = tt.sc.View()\n \t\t\tallDone := make(chan bool, 1)\n \t\t\tdefer b.goTracker.AddDoneCallback(func() {\n@@ -5256,7 +5313,7 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t})()\n \n \t\t\twas := b.goTracker.StartedGoroutines()\n-\t\t\tb.updateIngressLocked()\n+\t\t\tb.updateIngressAndServiceHashLocked(prefs)\n \n \t\t\tif tt.hi != nil {\n \t\t\t\tif tt.hi.IngressEnabled != tt.wantIngress {\n@@ -5265,6 +5322,12 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t\tif tt.hi.WireIngress != tt.wantWireIngress {\n \t\t\t\t\tt.Errorf(\"WireIngress = %v, want %v\", tt.hi.WireIngress, tt.wantWireIngress)\n \t\t\t\t}\n+\t\t\t\tb.mu.Lock()\n+\t\t\t\tsvcHash := b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\t\t\t\tb.mu.Unlock()\n+\t\t\t\tif tt.hi.ServicesHash != svcHash {\n+\t\t\t\t\tt.Errorf(\"ServicesHash = %v, want %v\", tt.hi.ServicesHash, svcHash)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tstartedGoroutine := b.goTracker.StartedGoroutines() != was\n---\n\n\n---\n\nChoice B:\nprober/prober.go\n@@ -559,8 +559,8 @@ func (p *Prober) RunHandler(w http.ResponseWriter, r *http.Request) error {\n \t\t\tPreviousSuccessRatio:  prevInfo.RecentSuccessRatio(),\n \t\t\tPreviousMedianLatency: prevInfo.RecentMedianLatency(),\n \t\t}\n-\t\tw.WriteHeader(respStatus)\n \t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tw.WriteHeader(respStatus)\n \t\tif err := json.NewEncoder(w).Encode(resp); err != nil {\n \t\t\treturn tsweb.Error(http.StatusInternalServerError, \"error encoding JSON response\", err)\n \t\t}\n---\nprober/prober_test.go\n@@ -598,6 +598,9 @@ func TestProberRunHandler(t *testing.T) {\n \t\t\t\t}\n \n \t\t\t\tif reqJSON {\n+\t\t\t\t\tif w.Header().Get(\"Content-Type\") != \"application/json\" {\n+\t\t\t\t\t\tt.Errorf(\"unexpected content type: got %q, want application/json\", w.Header().Get(\"Content-Type\"))\n+\t\t\t\t\t}\n \t\t\t\t\tvar gotJSON RunHandlerResponse\n \t\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), &gotJSON); err != nil {\n \t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, w.Body.String())\n---\n\n\n---\n\nChoice C:\nclientupdate/clientupdate.go\n@@ -28,6 +28,7 @@ import (\n \t\"strings\"\n \n \t\"tailscale.com/hostinfo\"\n+\t\"tailscale.com/types/lazy\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/cmpver\"\n \t\"tailscale.com/version\"\n@@ -249,9 +250,13 @@ func (up *Updater) getUpdateFunction() (fn updateFunction, canAutoUpdate bool) {\n \treturn nil, false\n }\n \n+var canAutoUpdateCache lazy.SyncValue[bool]\n+\n // CanAutoUpdate reports whether auto-updating via the clientupdate package\n // is supported for the current os/distro.\n-func CanAutoUpdate() bool {\n+func CanAutoUpdate() bool { return canAutoUpdateCache.Get(canAutoUpdateUncached) }\n+\n+func canAutoUpdateUncached() bool {\n \tif version.IsMacSysExt() {\n \t\t// Macsys uses Sparkle for auto-updates, which doesn't have an update\n \t\t// function in this package.\n---\nipn/ipnlocal/local.go\n@@ -3479,18 +3479,20 @@ func (b *LocalBackend) onTailnetDefaultAutoUpdate(au bool) {\n \t\t// can still manually enable auto-updates on this node.\n \t\treturn\n \t}\n-\tb.logf(\"using tailnet default auto-update setting: %v\", au)\n-\tprefsClone := prefs.AsStruct()\n-\tprefsClone.AutoUpdate.Apply = opt.NewBool(au)\n-\t_, err := b.editPrefsLockedOnEntry(&ipn.MaskedPrefs{\n-\t\tPrefs: *prefsClone,\n-\t\tAutoUpdateSet: ipn.AutoUpdatePrefsMask{\n-\t\t\tApplySet: true,\n-\t\t},\n-\t}, unlock)\n-\tif err != nil {\n-\t\tb.logf(\"failed to apply tailnet-wide default for auto-updates (%v): %v\", au, err)\n-\t\treturn\n+\tif clientupdate.CanAutoUpdate() {\n+\t\tb.logf(\"using tailnet default auto-update setting: %v\", au)\n+\t\tprefsClone := prefs.AsStruct()\n+\t\tprefsClone.AutoUpdate.Apply = opt.NewBool(au)\n+\t\t_, err := b.editPrefsLockedOnEntry(&ipn.MaskedPrefs{\n+\t\t\tPrefs: *prefsClone,\n+\t\t\tAutoUpdateSet: ipn.AutoUpdatePrefsMask{\n+\t\t\t\tApplySet: true,\n+\t\t\t},\n+\t\t}, unlock)\n+\t\tif err != nil {\n+\t\t\tb.logf(\"failed to apply tailnet-wide default for auto-updates (%v): %v\", au, err)\n+\t\t\treturn\n+\t\t}\n \t}\n }\n \n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/drive.go\n@@ -4,6 +4,7 @@\n package ipnlocal\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"slices\"\n@@ -338,7 +339,7 @@ func (b *LocalBackend) driveRemotesFromPeers(nm *netmap.NetworkMap) []*drive.Rem\n \t\t\t\t// Check that the peer is allowed to share with us.\n \t\t\t\taddresses := peer.Addresses()\n \t\t\t\tfor _, p := range addresses.All() {\n-\t\t\t\t\tif cn.PeerHasCap(p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n+\t\t\t\t\tif cn.PeerHasCap(context.Background(), p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n---\nipn/ipnlocal/local.go\n@@ -96,6 +96,7 @@ import (\n \t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/util/clientmetric\"\n+\t\"tailscale.com/util/ctxkey\"\n \t\"tailscale.com/util/deephash\"\n \t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/goroutines\"\n@@ -1463,15 +1464,19 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+var nodeCtxLockedKey = ctxkey.New(\"localNodeContext-locked\", false)\n+\n+var ctxNodeContextLocked = nodeCtxLockedKey.WithValue(context.Background(), true)\n+\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(context.Context, tailcfg.NodeView) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tif pred(ctxNodeContextLocked, peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n@@ -6652,9 +6657,11 @@ func (b *LocalBackend) TestOnlyPublicKeys() (machineKey key.MachinePublic, nodeK\n \n // PeerHasCap reports whether the peer with the given Tailscale IP addresses\n // contains the given capability string, with any value(s).\n-func (b *localNodeContext) PeerHasCap(addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n-\tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n+func (b *localNodeContext) PeerHasCap(ctx context.Context, addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n+\tif !nodeCtxLockedKey.Value(ctx) {\n+\t\tb.mu.Lock()\n+\t\tdefer b.mu.Unlock()\n+\t}\n \treturn b.peerHasCapLocked(addr, wantCap)\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n+\tpeers := cn.AppendMatchingPeers(nil, func(ctx context.Context, p tailcfg.NodeView) bool {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n \t\tif self != p.User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(ctx, p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n@@ -241,7 +241,7 @@ func (b *LocalBackend) taildropTargetStatus(p tailcfg.NodeView) ipnstate.Taildro\n \t}\n \tif nm.User() != p.User() {\n \t\t// Different user must have the explicit file sharing target capability\n-\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(context.Background(), p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn ipnstate.TaildropTargetOwnedByOtherUser\n \t\t}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nRegistering a new store is cheap, it just adds a map entry. No need to lazy-init it with sync.Once and an intermediate slice holding init functions.\r\n\r\nUpdates #cleanup\n\n---\n\nChoice A:\ncmd/tsidp/tsidp.go\n@@ -795,7 +795,7 @@ type oidcTokenResponse struct {\n \tIDToken      string `json:\"id_token\"`\n \tTokenType    string `json:\"token_type\"`\n \tAccessToken  string `json:\"access_token\"`\n-\tRefreshToken string `json:\"refresh_token\"`\n+\tRefreshToken string `json:\"refresh_token,omitempty\"`\n \tExpiresIn    int    `json:\"expires_in\"`\n }\n \n---\n\n\n---\n\nChoice B:\ncmd/k8s-operator/depaware.txt\n@@ -840,7 +840,7 @@ tailscale.com/cmd/k8s-operator dependencies: (generated by github.com/tailscale/\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/cmd/k8s-operator+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\ncmd/tailscaled/depaware.txt\n@@ -318,7 +318,7 @@ tailscale.com/cmd/tailscaled dependencies: (generated by github.com/tailscale/de\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/cmd/tailscaled+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\nipn/ipnlocal/local.go\n@@ -64,6 +64,7 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4886,7 +4887,6 @@ func (b *LocalBackend) authReconfig() {\n \tnm := cn.NetMap()\n \thasPAC := b.prevIfState.HasPAC()\n \tdisableSubnetsIfPAC := cn.SelfHasCap(tailcfg.NodeAttrDisableSubnetsIfPAC)\n-\tuserDialUseRoutes := cn.SelfHasCap(tailcfg.NodeAttrUserDialUseRoutes)\n \tdohURL, dohURLOK := cn.exitNodeCanProxyDNS(prefs.ExitNodeID())\n \tdcfg := cn.dnsConfigForNetmap(prefs, b.keyExpired, b.logf, version.OS())\n \t// If the current node is an app connector, ensure the app connector machine is started\n@@ -4947,7 +4947,7 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif userDialUseRoutes {\n+\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n \t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n \t} else {\n \t\tb.dialer.SetRoutes(nil, nil)\n---\nnet/dns/resolver/forwarder.go\n@@ -17,6 +17,7 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"net/url\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n@@ -740,18 +741,35 @@ func (f *forwarder) sendUDP(ctx context.Context, fq *forwardQuery, rr resolverAn\n \treturn out, nil\n }\n \n+var optDNSForwardUseRoutes = envknob.RegisterOptBool(\"TS_DEBUG_DNS_FORWARD_USE_ROUTES\")\n+\n+// ShouldUseRoutes reports whether the DNS resolver should consider routes when dialing\n+// upstream nameservers via TCP.\n+//\n+// If true, routes should be considered ([tsdial.Dialer.UserDial]), otherwise defer\n+// to the system routes ([tsdial.Dialer.SystemDial]).\n+//\n+// TODO(nickkhyl): Update [tsdial.Dialer] to reuse the bart.Table we create in net/tstun.Wrapper\n+// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n+// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n+//\n+// See tailscale/tailscale#12027.\n+func ShouldUseRoutes(knobs *controlknobs.Knobs) bool {\n+\tswitch runtime.GOOS {\n+\tcase \"android\", \"ios\":\n+\t\t// On mobile platforms with lower memory limits (e.g., 50MB on iOS),\n+\t\t// this behavior is still gated by the \"user-dial-routes\" nodeAttr.\n+\t\treturn knobs != nil && knobs.UserDialUseRoutes.Load()\n+\tdefault:\n+\t\t// On all other platforms, it is the default behavior,\n+\t\t// but it can be overridden with the \"TS_DEBUG_DNS_FORWARD_USE_ROUTES\" env var.\n+\t\tdoNotUseRoutes := optDNSForwardUseRoutes().EqualBool(false)\n+\t\treturn !doNotUseRoutes\n+\t}\n+}\n+\n func (f *forwarder) getDialerType() netx.DialFunc {\n-\tif f.controlKnobs != nil && f.controlKnobs.UserDialUseRoutes.Load() {\n-\t\t// It is safe to use UserDial as it dials external servers without going through Tailscale\n-\t\t// and closes connections on interface change in the same way as SystemDial does,\n-\t\t// thus preventing DNS resolution issues when switching between WiFi and cellular,\n-\t\t// but can also dial an internal DNS server on the Tailnet or via a subnet router.\n-\t\t//\n-\t\t// TODO(nickkhyl): Update tsdial.Dialer to reuse the bart.Table we create in net/tstun.Wrapper\n-\t\t// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n-\t\t// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n-\t\t//\n-\t\t// See https://github.com/tailscale/tailscale/issues/12027.\n+\tif ShouldUseRoutes(f.controlKnobs) {\n \t\treturn f.dialer.UserDial\n \t}\n \treturn f.dialer.SystemDial\n---\nnet/tsdial/tsdial.go\n@@ -151,6 +151,7 @@ func (d *Dialer) SetRoutes(routes, localRoutes []netip.Prefix) {\n \t\tfor _, r := range localRoutes {\n \t\t\trt.Insert(r, false)\n \t\t}\n+\t\td.logf(\"tsdial: bart table size: %d\", rt.Size())\n \t}\n \n \td.routes.Store(rt)\n---\ntsnet/depaware.txt\n@@ -271,7 +271,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\n\n\n---\n\nChoice C:\ncmd/containerboot/healthz.go\n@@ -47,10 +47,10 @@ func (h *healthz) update(healthy bool) {\n \th.hasAddrs = healthy\n }\n \n-// healthHandlers registers a simple health handler at /healthz.\n+// registerHealthHandlers registers a simple health handler at /healthz.\n // A containerized tailscale instance is considered healthy if\n // it has at least one tailnet IP address.\n-func healthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n+func registerHealthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n \th := &healthz{podIPv4: podIPv4}\n \tmux.Handle(\"GET /healthz\", h)\n \treturn h\n---\ncmd/containerboot/main.go\n@@ -195,18 +195,21 @@ func run() error {\n \t\treturn fmt.Errorf(\"failed to bring up tailscale: %w\", err)\n \t}\n \tkillTailscaled := func() {\n+\t\t// The default termination grace period for a Pod is 30s. We wait 25s at\n+\t\t// most so that we still reserve some of that budget for tailscaled\n+\t\t// to receive and react to a SIGTERM before the SIGKILL that k8s\n+\t\t// will send at the end of the grace period.\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)\n+\t\tdefer cancel()\n+\n+\t\tif err := ensureServicesNotAdvertised(ctx, client); err != nil {\n+\t\t\tlog.Printf(\"Error ensuring services are not advertised: %v\", err)\n+\t\t}\n+\n \t\tif hasKubeStateStore(cfg) {\n \t\t\t// Check we're not shutting tailscaled down while it's still writing\n \t\t\t// state. If we authenticate and fail to write all the state, we'll\n \t\t\t// never recover automatically.\n-\t\t\t//\n-\t\t\t// The default termination grace period for a Pod is 30s. We wait 25s at\n-\t\t\t// most so that we still reserve some of that budget for tailscaled\n-\t\t\t// to receive and react to a SIGTERM before the SIGKILL that k8s\n-\t\t\t// will send at the end of the grace period.\n-\t\t\tctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)\n-\t\t\tdefer cancel()\n-\n \t\t\tlog.Printf(\"Checking for consistent state\")\n \t\t\terr := kc.waitForConsistentState(ctx)\n \t\t\tif err != nil {\n@@ -226,7 +229,7 @@ func run() error {\n \t\tmux := http.NewServeMux()\n \n \t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.HealthCheckAddrPort)\n-\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \n \t\tclose := runHTTPServer(mux, cfg.HealthCheckAddrPort)\n \t\tdefer close()\n@@ -237,15 +240,16 @@ func run() error {\n \n \t\tif cfg.localMetricsEnabled() {\n \t\t\tlog.Printf(\"Running metrics endpoint at %s/metrics\", cfg.LocalAddrPort)\n-\t\t\tmetricsHandlers(mux, client, cfg.DebugAddrPort)\n+\t\t\tregisterMetricsHandlers(mux, client, cfg.DebugAddrPort)\n \t\t}\n \n \t\tif cfg.localHealthEnabled() {\n \t\t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.LocalAddrPort)\n-\t\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \t\t}\n-\t\tif cfg.EgressProxiesCfgPath != \"\" {\n-\t\t\tlog.Printf(\"Running preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n+\n+\t\tif cfg.egressSvcsTerminateEPEnabled() {\n+\t\t\tlog.Printf(\"Running egress preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n \t\t\tep.registerHandlers(mux)\n \t\t}\n \n---\ncmd/containerboot/metrics.go\n@@ -62,13 +62,13 @@ func (m *metrics) handleDebug(w http.ResponseWriter, r *http.Request) {\n \tproxy(w, r, debugURL, http.DefaultClient.Do)\n }\n \n-// metricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n+// registerMetricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n // requests to tailscaled's /localapi/v0/usermetrics API.\n //\n // In 1.78.x and 1.80.x, it also proxies debug paths to tailscaled's debug\n // endpoint if configured to ease migration for a breaking change serving user\n // metrics instead of debug metrics on the \"metrics\" port.\n-func metricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n+func registerMetricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n \tm := &metrics{\n \t\tlc:            lc,\n \t\tdebugEndpoint: debugAddrPort,\n---\ncmd/containerboot/serve.go\n@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"log\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -169,3 +170,46 @@ func readServeConfig(path, certDomain string) (*ipn.ServeConfig, error) {\n \t}\n \treturn &sc, nil\n }\n+\n+func ensureServicesNotAdvertised(ctx context.Context, lc *local.Client) error {\n+\tprefs, err := lc.GetPrefs(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"error getting prefs: %w\", err)\n+\t}\n+\tif len(prefs.AdvertiseServices) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tlog.Printf(\"serve proxy: unadvertising services: %v\", prefs.AdvertiseServices)\n+\tif _, err := lc.EditPrefs(ctx, &ipn.MaskedPrefs{\n+\t\tAdvertiseServicesSet: true,\n+\t\tPrefs: ipn.Prefs{\n+\t\t\tAdvertiseServices: nil,\n+\t\t},\n+\t}); err != nil {\n+\t\t// EditPrefs only returns an error if it fails _set_ its local prefs.\n+\t\t// If it fails to _persist_ the prefs in state, we don't get an error\n+\t\t// and we continue waiting below, as control will failover as usual.\n+\t\treturn fmt.Errorf(\"error setting prefs AdvertiseServices: %w\", err)\n+\t}\n+\n+\t// Services use the same (failover XOR regional routing) mechanism that\n+\t// HA subnet routers use. Unfortunately we don't yet get a reliable signal\n+\t// from control that it's responded to our unadvertisement, so the best we\n+\t// can do is wait for 20 seconds, where 15s is the approximate maximum time\n+\t// it should take for control to choose a new primary, and 5s is for buffer.\n+\t//\n+\t// Note: There is no guarantee that clients have been _informed_ of the new\n+\t// primary no matter how long we wait. We would need a mechanism to await\n+\t// netmap updates for peers to know for sure.\n+\t//\n+\t// See https://tailscale.com/kb/1115/high-availability for more details.\n+\t// TODO(tomhjp): Wait for a netmap update instead of sleeping when control\n+\t// supports that.\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\treturn nil\n+\tcase <-time.After(20 * time.Second):\n+\t\treturn nil\n+\t}\n+}\n---\ncmd/k8s-operator/proxygroup_specs.go\n@@ -197,6 +197,16 @@ func pgStatefulSet(pg *tsapi.ProxyGroup, namespace, image, tsFirewallMode string\n \t// This mechanism currently (2025-01-26) rely on the local health check being accessible on the Pod's\n \t// IP, so they are not supported for ProxyGroups where users have configured TS_LOCAL_ADDR_PORT to a custom\n \t// value.\n+\t//\n+\t// NB: For _Ingress_ ProxyGroups, we run shutdown logic within containerboot\n+\t// in reaction to a SIGTERM signal instead of using a pre-stop hook. This is\n+\t// because Ingress pods need to unadvertise services, and it's preferable to\n+\t// avoid triggering those side-effects from a GET request that would be\n+\t// accessible to the whole cluster network (in the absence of NetworkPolicy\n+\t// rules).\n+\t//\n+\t// TODO(tomhjp): add a readiness probe or gate to Ingress Pods. There is a\n+\t// small window where the Pod is marked ready but routing can still fail.\n \tif pg.Spec.Type == tsapi.ProxyGroupTypeEgress && !hasLocalAddrPortSet(proxyClass) {\n \t\tc.Lifecycle = &corev1.Lifecycle{\n \t\t\tPreStop: &corev1.LifecycleHandler{\n---\n\n\n---\n\nChoice D:\nipn/store/store_aws.go\n@@ -12,10 +12,6 @@ import (\n )\n \n func init() {\n-\tregisterAvailableExternalStores = append(registerAvailableExternalStores, registerAWSStore)\n-}\n-\n-func registerAWSStore() {\n \tRegister(\"arn:\", func(logf logger.Logf, arg string) (ipn.StateStore, error) {\n \t\tssmARN, opts, err := awsstore.ParseARNAndOpts(arg)\n \t\tif err != nil {\n---\nipn/store/store_kube.go\n@@ -14,10 +14,6 @@ import (\n )\n \n func init() {\n-\tregisterAvailableExternalStores = append(registerAvailableExternalStores, registerKubeStore)\n-}\n-\n-func registerKubeStore() {\n \tRegister(\"kube:\", func(logf logger.Logf, path string) (ipn.StateStore, error) {\n \t\tsecretName := strings.TrimPrefix(path, \"kube:\")\n \t\treturn kubestore.New(logf, secretName)\n---\nipn/store/stores.go\n@@ -26,16 +26,8 @@ import (\n // The arg is of the form \"prefix:rest\", where prefix was previously registered with Register.\n type Provider func(logf logger.Logf, arg string) (ipn.StateStore, error)\n \n-var regOnce sync.Once\n-\n-var registerAvailableExternalStores []func()\n-\n-func registerDefaultStores() {\n+func init() {\n \tRegister(\"mem:\", mem.New)\n-\n-\tfor _, f := range registerAvailableExternalStores {\n-\t\tf()\n-\t}\n }\n \n var knownStores map[string]Provider\n@@ -55,7 +47,6 @@ var knownStores map[string]Provider\n //     the suffix is a Kubernetes secret name\n //   - In all other cases, the path is treated as a filepath.\n func New(logf logger.Logf, path string) (ipn.StateStore, error) {\n-\tregOnce.Do(registerDefaultStores)\n \tfor prefix, sf := range knownStores {\n \t\tif strings.HasPrefix(path, prefix) {\n \t\t\t// We can't strip the prefix here as some NewStoreFunc (like arn:)\n---\nipn/store/stores_test.go\n@@ -4,6 +4,7 @@\n package store\n \n import (\n+\t\"maps\"\n \t\"path/filepath\"\n \t\"testing\"\n \n@@ -14,10 +15,9 @@ import (\n )\n \n func TestNewStore(t *testing.T) {\n-\tregOnce.Do(registerDefaultStores)\n+\toldKnownStores := maps.Clone(knownStores)\n \tt.Cleanup(func() {\n-\t\tknownStores = map[string]Provider{}\n-\t\tregisterDefaultStores()\n+\t\tknownStores = oldKnownStores\n \t})\n \tknownStores = map[string]Provider{}\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdate proxy-to-grafana to strip X-Webauth prefixed headers passed by the client in *every* request, not just those to /login.\r\n\r\n`/api/` routes will also accept these headers to authenticate users, necessitating their removal to prevent forgery.\r\n\r\nUpdates tailscale/corp#28687\n\n---\n\nChoice A:\ncmd/tailscale/cli/file.go\n@@ -15,8 +15,10 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"os\"\n+\t\"os/user\"\n \t\"path\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"sync/atomic\"\n \t\"time\"\n@@ -452,6 +454,7 @@ var fileGetCmd = &ffcli.Command{\n \toverwrite:  overwrite existing file\n \trename:     write to a new number-suffixed filename`)\n \t\tffcomplete.Flag(fs, \"conflict\", ffcomplete.Fixed(\"skip\", \"overwrite\", \"rename\"))\n+\t\tfs.StringVar(&getArgs.chown, \"chown\", \"\", \"sets owner:group for received files\")\n \t\treturn fs\n \t})(),\n }\n@@ -461,6 +464,7 @@ var getArgs = struct {\n \tloop     bool\n \tverbose  bool\n \tconflict onConflict\n+\tchown    string\n }{conflict: skipOnExist}\n \n func numberedFileName(dir, name string, i int) string {\n@@ -512,7 +516,7 @@ func openFileOrSubstitute(dir, base string, action onConflict) (*os.File, error)\n \t}\n }\n \n-func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targetFile string, size int64, err error) {\n+func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string, chown string) (targetFile string, size int64, err error) {\n \trc, size, err := localClient.GetWaitingFile(ctx, wf.Name)\n \tif err != nil {\n \t\treturn \"\", 0, fmt.Errorf(\"opening inbox file %q: %w\", wf.Name, err)\n@@ -531,10 +535,51 @@ func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targe\n \t\tf.Close()\n \t\treturn \"\", 0, fmt.Errorf(\"failed to write %v: %v\", f.Name(), err)\n \t}\n+\tif chown != \"\" {\n+\t\tusr, grp, _ := strings.Cut(chown, \":\")\n+\n+\t\t// Set default values to allow for partial changes (e.g. `user` or `:staff`)\n+\t\tuid, gid, err := fileStat(f)\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to stat file: %v\", err)\n+\t\t}\n+\n+\t\tif usr != \"\" {\n+\t\t\tif uid, err = strconv.Atoi(usr); err != nil {\n+\t\t\t\tuser, err := user.Lookup(usr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup user: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif uid, err = strconv.Atoi(user.Uid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert uid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif grp != \"\" {\n+\t\t\tif gid, err = strconv.Atoi(grp); err != nil {\n+\t\t\t\tgroup, err := user.LookupGroup(grp)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup group: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif gid, err = strconv.Atoi(group.Gid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert gid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif err := f.Chown(uid, gid); err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to chown file: %v\", err)\n+\t\t}\n+\t}\n \treturn f.Name(), size, f.Close()\n }\n \n-func runFileGetOneBatch(ctx context.Context, dir string) []error {\n+func runFileGetOneBatch(ctx context.Context, dir, chown string) []error {\n \tvar wfs []apitype.WaitingFile\n \tvar err error\n \tvar errs []error\n@@ -563,7 +608,7 @@ func runFileGetOneBatch(ctx context.Context, dir string) []error {\n \t\t\terrs = append(errs, fmt.Errorf(\"too many errors in runFileGetOneBatch(). %d files unexamined\", len(wfs)-i))\n \t\t\tbreak\n \t\t}\n-\t\twrittenFile, size, err := receiveFile(ctx, wf, dir)\n+\t\twrittenFile, size, err := receiveFile(ctx, wf, dir, chown)\n \t\tif err != nil {\n \t\t\terrs = append(errs, err)\n \t\t\tcontinue\n@@ -602,7 +647,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t}\n \tif getArgs.loop {\n \t\tfor {\n-\t\t\terrs := runFileGetOneBatch(ctx, dir)\n+\t\t\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \t\t\tfor _, err := range errs {\n \t\t\t\toutln(err)\n \t\t\t}\n@@ -621,7 +666,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t\t\t}\n \t\t}\n \t}\n-\terrs := runFileGetOneBatch(ctx, dir)\n+\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \tif len(errs) == 0 {\n \t\treturn nil\n \t}\n@@ -635,6 +680,9 @@ func wipeInbox(ctx context.Context) error {\n \tif getArgs.wait {\n \t\treturn errors.New(\"can't use --wait with /dev/null target\")\n \t}\n+\tif getArgs.chown != \"\" {\n+\t\treturn errors.New(\"can't use --chown with /dev/null target\")\n+\t}\n \twfs, err := localClient.WaitingFiles(ctx)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting WaitingFiles: %w\", err)\n---\ncmd/tailscale/cli/file_stub.go\n@@ -0,0 +1,16 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build windows || wasm || plan9 || tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(_f *os.File) (int, int, error) {\n+\treturn -1, -1, errors.New(\"Not implemented\")\n+}\n---\ncmd/tailscale/cli/file_unix.go\n@@ -0,0 +1,26 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build !windows && !wasm && !plan9 && !tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(f *os.File) (int, int, error) {\n+\tif f == nil {\n+\t\treturn -1, -1, errors.New(\"file cannot be nil\")\n+\t}\n+\n+\tvar stat syscall.Stat_t\n+\tif err := syscall.Stat(f.Name(), &stat); err != nil {\n+\t\treturn -1, -1, err\n+\t}\n+\n+\treturn int(stat.Uid), int(stat.Gid), nil\n+}\n---\n\n\n---\n\nChoice B:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/init@28deaeda66b76a05916b6923827895f2b14ab387 # v3.28.16\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/autobuild@28deaeda66b76a05916b6923827895f2b14ab387 # v3.28.16\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/analyze@28deaeda66b76a05916b6923827895f2b14ab387 # v3.28.16\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local_test.go\n@@ -15,7 +15,6 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n-\t\"runtime\"\n \t\"slices\"\n \t\"strings\"\n \t\"sync\"\n@@ -2597,9 +2596,6 @@ func TestPreferencePolicyInfo(t *testing.T) {\n }\n \n func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n-\tif runtime.GOOS == \"darwin\" {\n-\t\tt.Skip(\"test known broken on macOS; see https://github.com/tailscale/tailscale/issues/15691\")\n-\t}\n \ttests := []struct {\n \t\tbefore, after  opt.Bool\n \t\tcontainer      opt.Bool\n@@ -2669,7 +2665,7 @@ func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n \t\t\t// On platforms that don't support auto-update we can never\n \t\t\t// transition to auto-updates being enabled. The value should\n \t\t\t// remain unchanged after onTailnetDefaultAutoUpdate.\n-\t\t\tif !clientupdate.CanAutoUpdate() && want.EqualBool(true) {\n+\t\t\tif !clientupdate.CanAutoUpdate() {\n \t\t\t\twant = tt.before\n \t\t\t}\n \t\t\tif got := b.pm.CurrentPrefs().AutoUpdate().Apply; got != want {\n---\n\n\n---\n\nChoice D:\ncmd/proxy-to-grafana/proxy-to-grafana.go\n@@ -53,7 +53,7 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"tailscale.com/client/local\"\n+\t\"tailscale.com/client/tailscale/apitype\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/tsnet\"\n )\n@@ -195,13 +195,7 @@ func main() {\n \tlog.Fatal(http.Serve(ln, proxy))\n }\n \n-func modifyRequest(req *http.Request, localClient *local.Client) {\n-\t// with enable_login_token set to true, we get a cookie that handles\n-\t// auth for paths that are not /login\n-\tif req.URL.Path != \"/login\" {\n-\t\treturn\n-\t}\n-\n+func modifyRequest(req *http.Request, localClient whoisIdentitySource) {\n \t// Delete any existing X-Webauth-* headers to prevent possible spoofing\n \t// if getting Tailnet identity fails.\n \tfor h := range req.Header {\n@@ -210,6 +204,13 @@ func modifyRequest(req *http.Request, localClient *local.Client) {\n \t\t}\n \t}\n \n+\t// Set the X-Webauth-* headers only for the /login path\n+\t// With enable_login_token set to true, we get a cookie that handles\n+\t// auth for paths that are not /login\n+\tif req.URL.Path != \"/login\" {\n+\t\treturn\n+\t}\n+\n \tuser, role, err := getTailscaleIdentity(req.Context(), localClient, req.RemoteAddr)\n \tif err != nil {\n \t\tlog.Printf(\"error getting Tailscale user: %v\", err)\n@@ -221,7 +222,7 @@ func modifyRequest(req *http.Request, localClient *local.Client) {\n \treq.Header.Set(\"X-Webauth-Role\", role.String())\n }\n \n-func getTailscaleIdentity(ctx context.Context, localClient *local.Client, ipPort string) (*tailcfg.UserProfile, grafanaRole, error) {\n+func getTailscaleIdentity(ctx context.Context, localClient whoisIdentitySource, ipPort string) (*tailcfg.UserProfile, grafanaRole, error) {\n \twhois, err := localClient.WhoIs(ctx, ipPort)\n \tif err != nil {\n \t\treturn nil, ViewerRole, fmt.Errorf(\"failed to identify remote host: %w\", err)\n@@ -248,3 +249,7 @@ func getTailscaleIdentity(ctx context.Context, localClient *local.Client, ipPort\n \n \treturn whois.UserProfile, role, nil\n }\n+\n+type whoisIdentitySource interface {\n+\tWhoIs(ctx context.Context, ipPort string) (*apitype.WhoIsResponse, error)\n+}\n---\ncmd/proxy-to-grafana/proxy-to-grafana_test.go\n@@ -0,0 +1,77 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+package main\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+\n+\t\"tailscale.com/client/tailscale/apitype\"\n+\t\"tailscale.com/tailcfg\"\n+)\n+\n+type mockWhoisSource struct {\n+\tid *apitype.WhoIsResponse\n+}\n+\n+func (m *mockWhoisSource) WhoIs(ctx context.Context, remoteAddr string) (*apitype.WhoIsResponse, error) {\n+\tif m.id == nil {\n+\t\treturn nil, fmt.Errorf(\"missing mock identity\")\n+\t}\n+\treturn m.id, nil\n+}\n+\n+var whois = &apitype.WhoIsResponse{\n+\tUserProfile: &tailcfg.UserProfile{\n+\t\tLoginName:   \"foobar@example.com\",\n+\t\tDisplayName: \"Foobar\",\n+\t},\n+\tNode: &tailcfg.Node{\n+\t\tID: 1,\n+\t},\n+}\n+\n+func TestModifyRequest_Login(t *testing.T) {\n+\treq := httptest.NewRequest(\"GET\", \"/login\", nil)\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"foobar@example.com\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"foobar@example.com\")\n+\t}\n+\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"Viewer\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"Viewer\")\n+\t}\n+}\n+\n+func TestModifyRequest_RemoveHeaders_Login(t *testing.T) {\n+\treq := httptest.NewRequest(\"GET\", \"/login\", nil)\n+\treq.Header.Set(\"X-Webauth-User\", \"malicious@example.com\")\n+\treq.Header.Set(\"X-Webauth-Role\", \"Admin\")\n+\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"foobar@example.com\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"foobar@example.com\")\n+\t}\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"Viewer\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"Viewer\")\n+\t}\n+}\n+\n+func TestModifyRequest_RemoveHeaders_API(t *testing.T) {\n+\treq := httptest.NewRequest(\"DELETE\", \"/api/org/users/1\", nil)\n+\treq.Header.Set(\"X-Webauth-User\", \"malicious@example.com\")\n+\treq.Header.Set(\"X-Webauth-Role\", \"Admin\")\n+\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"\")\n+\t}\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"\")\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #15970\r\nUpdates #15812\r\nUpdates tailscale/corp#28449\r\n\n\n---\n\nChoice A:\nclient/systray/logo.go\n@@ -11,10 +11,12 @@ import (\n \t\"image\"\n \t\"image/color\"\n \t\"image/png\"\n+\t\"runtime\"\n \t\"sync\"\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/fogleman/gg\"\n )\n \n@@ -251,7 +253,13 @@ func (logo tsLogo) renderWithBorder(borderUnits int) *bytes.Buffer {\n \t}\n \n \tb := bytes.NewBuffer(nil)\n-\tpng.Encode(b, dc.Image())\n+\n+\t// Encode as ICO format on Windows, PNG on all other platforms.\n+\tif runtime.GOOS == \"windows\" {\n+\t\t_ = ico.Encode(b, dc.Image())\n+\t} else {\n+\t\t_ = png.Encode(b, dc.Image())\n+\t}\n \treturn b\n }\n \n---\nclient/systray/systray.go\n@@ -7,9 +7,11 @@\n package systray\n \n import (\n+\t\"bytes\"\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"image\"\n \t\"io\"\n \t\"log\"\n \t\"net/http\"\n@@ -23,6 +25,7 @@ import (\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/atotto/clipboard\"\n \tdbus \"github.com/godbus/dbus/v5\"\n \t\"github.com/toqueteos/webbrowser\"\n@@ -330,6 +333,20 @@ func setRemoteIcon(menu *systray.MenuItem, urlStr string) {\n \t\tresp, err := http.Get(urlStr)\n \t\tif err == nil && resp.StatusCode == http.StatusOK {\n \t\t\tb, _ = io.ReadAll(resp.Body)\n+\n+\t\t\t// Convert image to ICO format on Windows\n+\t\t\tif runtime.GOOS == \"windows\" {\n+\t\t\t\tim, _, err := image.Decode(bytes.NewReader(b))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tbuf := bytes.NewBuffer(nil)\n+\t\t\t\tif err := ico.Encode(buf, im); err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tb = buf.Bytes()\n+\t\t\t}\n+\n \t\t\thttpCache[urlStr] = b\n \t\t\tresp.Body.Close()\n \t\t}\n---\ngo.mod\n@@ -4,7 +4,8 @@ go 1.24.0\n \n require (\n \tfilippo.io/mkcert v1.4.4\n-\tfyne.io/systray v1.11.0\n+\tfyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a\n+\tgithub.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9\n \tgithub.com/akutz/memconn v0.1.0\n \tgithub.com/alexbrainman/sspi v0.0.0-20231016080023-1a75b4708caa\n \tgithub.com/andybalholm/brotli v1.1.0\n@@ -100,7 +101,7 @@ require (\n \tgolang.org/x/net v0.36.0\n \tgolang.org/x/oauth2 v0.26.0\n \tgolang.org/x/sync v0.11.0\n-\tgolang.org/x/sys v0.30.0\n+\tgolang.org/x/sys v0.31.0\n \tgolang.org/x/term v0.29.0\n \tgolang.org/x/time v0.10.0\n \tgolang.org/x/tools v0.30.0\n---\ngo.sum\n@@ -41,8 +41,8 @@ filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\n filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\n filippo.io/mkcert v1.4.4 h1:8eVbbwfVlaqUM7OwuftKc2nuYOoTDQWqsoXmzoXZdbc=\n filippo.io/mkcert v1.4.4/go.mod h1:VyvOchVuAye3BoUsPUOOofKygVwLV2KQMVFJNRq+1dA=\n-fyne.io/systray v1.11.0 h1:D9HISlxSkx+jHSniMBR6fCFOUjk1x/OOOJLa9lJYAKg=\n-fyne.io/systray v1.11.0/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a h1:I8mEKo5sawHu8CqYf3FSjIl9b3puXasFVn2D/hrCneY=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n github.com/4meepo/tagalign v1.3.3 h1:ZsOxcwGD/jP4U/aw7qeWu58i7dwYemfy5Y+IF1ACoNw=\n github.com/4meepo/tagalign v1.3.3/go.mod h1:Q9c1rYMZJc9dPRkbQPpcBNCLEmY2njbAsXhQOZFE2dE=\n github.com/Abirdcfly/dupword v0.0.14 h1:3U4ulkc8EUo+CaT105/GJ1BQwtgyj6+VaBVbAX11Ba8=\n@@ -67,6 +67,8 @@ github.com/Djarvur/go-err113 v0.1.0 h1:uCRZZOdMQ0TZPHYTdYpoC0bLYJKPEHPUJ8MeAa51l\n github.com/Djarvur/go-err113 v0.1.0/go.mod h1:4UJr5HIiMZrwgkSPdsjy2uOQExX/WEILpIrO9UPGuXs=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0 h1:sATXp1x6/axKxz2Gjxv8MALP0bXaNRfQinEwyfMcx8c=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0/go.mod h1:Nl76DrGNJTA1KJ0LePKBw/vznBX1EHbAZX8mwjR82nI=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9 h1:1ltqoej5GtaWF8jaiA49HwsZD459jqm9YFz9ZtMFpQA=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9/go.mod h1:7uhhqiBaR4CpN0k9rMjOtjpcfGd6DG2m04zQxKnWQ0I=\n github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\n github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\n github.com/Masterminds/semver v1.5.0 h1:H65muMkzWKEuNDnfl9d70GUjFniHKHRbFPGBuZ3QEww=\n@@ -1218,8 +1220,8 @@ golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n-golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=\n-golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=\n+golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n---\n\n\n---\n\nChoice B:\nsafesocket/safesocket.go\n@@ -61,7 +61,11 @@ func ConnectContext(ctx context.Context, path string) (net.Conn, error) {\n \t\t\tif ctx.Err() != nil {\n \t\t\t\treturn nil, ctx.Err()\n \t\t\t}\n-\t\t\ttime.Sleep(250 * time.Millisecond)\n+\t\t\tselect {\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\treturn nil, ctx.Err()\n+\t\t\tcase <-time.After(250 * time.Millisecond):\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\treturn c, err\n---\n\n\n---\n\nChoice C:\nwgengine/magicsock/endpoint.go\n@@ -820,7 +820,7 @@ func (de *endpoint) heartbeat() {\n \n \tudpAddr, _, _ := de.addrForSendLocked(now)\n \tif udpAddr.IsValid() {\n-\t\t// We have a preferred path. Ping that every 2 seconds.\n+\t\t// We have a preferred path. Ping that every 'heartbeatInterval'.\n \t\tde.startDiscoPingLocked(udpAddr, now, pingHeartbeat, 0, nil)\n \t}\n \n---\n\n\n---\n\nChoice D:\nfeature/taildrop/integration_test.go\n@@ -26,6 +26,21 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n+\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n+\ttestTaildropIntegration(t, false)\n+}\n+\n+func TestTaildropIntegration_Fresh(t *testing.T) {\n+\ttestTaildropIntegration(t, true)\n+}\n+\n+// freshProfiles is whether to start the test right away\n+// with a fresh profile. If false, tailscaled is started, stopped,\n+// and restarted again to simulate a real-world scenario where\n+// the first profile already existed.\n+//\n+// This exercises an ipnext hook ordering issue we hit earlier.\n+func testTaildropIntegration(t *testing.T, freshProfiles bool) {\n \ttstest.Parallel(t)\n \tcontrolOpt := integration.ConfigureControl(func(s *testcontrol.Server) {\n \t\ts.AllNodesSameUser = true // required for Taildrop\n@@ -39,18 +54,30 @@ func TestTaildropIntegration(t *testing.T) {\n \tn2 := integration.NewTestNode(t, env)\n \td2 := n2.StartDaemon()\n \n-\tn1.AwaitListening()\n-\tt.Logf(\"n1 is listening\")\n-\tn2.AwaitListening()\n-\tt.Logf(\"n2 is listening\")\n-\tn1.MustUp()\n-\tt.Logf(\"n1 is up\")\n-\tn2.MustUp()\n-\tt.Logf(\"n2 is up\")\n-\tn1.AwaitRunning()\n-\tt.Logf(\"n1 is running\")\n-\tn2.AwaitRunning()\n-\tt.Logf(\"n2 is running\")\n+\tawaitUp := func() {\n+\t\tt.Helper()\n+\t\tn1.AwaitListening()\n+\t\tt.Logf(\"n1 is listening\")\n+\t\tn2.AwaitListening()\n+\t\tt.Logf(\"n2 is listening\")\n+\t\tn1.MustUp()\n+\t\tt.Logf(\"n1 is up\")\n+\t\tn2.MustUp()\n+\t\tt.Logf(\"n2 is up\")\n+\t\tn1.AwaitRunning()\n+\t\tt.Logf(\"n1 is running\")\n+\t\tn2.AwaitRunning()\n+\t\tt.Logf(\"n2 is running\")\n+\t}\n+\tawaitUp()\n+\n+\tif !freshProfiles {\n+\t\td1.MustCleanShutdown(t)\n+\t\td2.MustCleanShutdown(t)\n+\t\td1 = n1.StartDaemon()\n+\t\td2 = n2.StartDaemon()\n+\t\tawaitUp()\n+\t}\n \n \tvar peerStableID tailcfg.StableNodeID\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nCurrently, `LocalBackend`/`ExtensionHost` doesn't invoke the profile change callback for the initial profile. Since the initial profile may vary depending on loaded extensions and applied policy settings, it can't be reliably determined until all extensions are initialized. Additionally, some extensions may asynchronously trigger a switch to the \"best\" profile (based on system state and policy settings) during initialization.\r\n\r\nWe intended to address these issues as part of the ongoing `profileManager`/`LocalBackend` refactoring, but the changes didn't land in time for the v1.84 release and the Taildrop refactoring.\r\n\r\nIn this PR, we update the Taildrop extension to retrieve the current profile at initialization time and handle it as a profile change.\r\n\r\nWe also defer extension initialization until `LocalBackend` has started, since the Taildrop extension already relies on this behavior (e.g., it requires clients to call `SetDirectFileRoot` before `Init`).\r\n\r\nUpdates #12614\r\nFixes #15970\n\n---\n\nChoice A:\nwgengine/magicsock/magicsock_linux.go\n@@ -66,10 +66,10 @@ var (\n \t\t// fragmented, and we don't want to handle reassembly.\n \t\tbpf.LoadAbsolute{Off: 6, Size: 2},\n \t\t// More Fragments bit set means this is part of a fragmented packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 7, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 8, SkipFalse: 0},\n \t\t// Non-zero fragment offset with MF=0 means this is the last\n \t\t// fragment of packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 6, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 7, SkipFalse: 0},\n \n \t\t// Load IP header length into X register.\n \t\tbpf.LoadMemShift{Off: 0},\n---\nwgengine/magicsock/magicsock_linux_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"net/netip\"\n \t\"testing\"\n \n+\t\"golang.org/x/net/bpf\"\n \t\"golang.org/x/sys/cpu\"\n \t\"golang.org/x/sys/unix\"\n \t\"tailscale.com/disco\"\n@@ -146,3 +147,78 @@ func TestEthernetProto(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestBpfDiscardV4(t *testing.T) {\n+\t// Good packet as a reference for what should not be rejected\n+\tudp4Packet := []byte{\n+\t\t// IPv4 header\n+\t\t0x45, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x40, 0x11, 0x00, 0x00,\n+\t\t0x7f, 0x00, 0x00, 0x01, // source ip\n+\t\t0x7f, 0x00, 0x00, 0x02, // dest ip\n+\n+\t\t// UDP header\n+\t\t0x30, 0x39, // src port\n+\t\t0xd4, 0x31, // dest port\n+\t\t0x00, 0x12, // length; 8 bytes header + 10 bytes payload = 18 bytes\n+\t\t0x00, 0x00, // checksum; unused\n+\n+\t\t// Payload: disco magic plus 32 bytes for key and 24 bytes for nonce\n+\t\t0x54, 0x53, 0xf0, 0x9f, 0x92, 0xac, 0x00, 0x01, 0x02, 0x03,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n+\t}\n+\n+\tvm, err := bpf.NewVM(magicsockFilterV4)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed creating BPF VM: %v\", err)\n+\t}\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\treplace map[int]byte\n+\t\taccept  bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"base accepted datagram\",\n+\t\t\treplace: map[int]byte{},\n+\t\t\taccept:  true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"more fragments\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t6: 0x20,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some fragment\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t7: 0x01,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t}\n+\n+\tudp4PacketChanged := make([]byte, len(udp4Packet))\n+\tcopy(udp4PacketChanged, udp4Packet)\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfor k, v := range tt.replace {\n+\t\t\t\tudp4PacketChanged[k] = v\n+\t\t\t}\n+\t\t\tret, err := vm.Run(udp4PacketChanged)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"BPF VM error: %v\", err)\n+\t\t\t}\n+\n+\t\t\tif (ret != 0) != tt.accept {\n+\t\t\t\tt.Errorf(\"expected accept=%v, got ret=%v\", tt.accept, ret)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice B:\nfeature/taildrop/ext.go\n@@ -100,6 +100,10 @@ func (e *Extension) Init(h ipnext.Host) error {\n \th.Hooks().SetPeerStatus.Add(e.setPeerStatus)\n \th.Hooks().BackendStateChange.Add(e.onBackendStateChange)\n \n+\t// TODO(nickkhyl): remove this after the profileManager refactoring.\n+\t// See tailscale/tailscale#15974.\n+\tprofile, prefs := h.Profiles().CurrentProfileState()\n+\te.onChangeProfile(profile, prefs, false)\n \treturn nil\n }\n \n---\nfeature/taildrop/integration_test.go\n@@ -26,7 +26,6 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n-\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n \ttestTaildropIntegration(t, false)\n }\n \n---\nipn/ipnext/ipnext.go\n@@ -37,7 +37,10 @@ type Extension interface {\n \t// It must be the same as the name used to register the extension.\n \tName() string\n \n-\t// Init is called to initialize the extension when LocalBackend is initialized.\n+\t// Init is called to initialize the extension when LocalBackend's\n+\t// Start method is called. Extensions are created but not initialized\n+\t// unless LocalBackend is started.\n+\t//\n \t// If the extension cannot be initialized, it must return an error,\n \t// and its Shutdown method will not be called on the host's shutdown.\n \t// Returned errors are not fatal; they are used for logging.\n@@ -333,6 +336,7 @@ type Hooks struct {\n \t// BackendStateChange is called when the backend state changes.\n \tBackendStateChange feature.Hooks[func(ipn.State)]\n \n+\t// ProfileStateChange contains callbacks that are invoked when the current login profile\n \t// or its [ipn.Prefs] change, after those changes have been made. The current login profile\n \t// may be changed either because of a profile switch, or because the profile information\n \t// was updated by [LocalBackend.SetControlClientStatus], including when the profile\n---\nipn/ipnlocal/local.go\n@@ -237,6 +237,8 @@ type LocalBackend struct {\n \t// for testing and graceful shutdown purposes.\n \tgoTracker goroutines.Tracker\n \n+\tstartOnce sync.Once // protects the one\u2011time initialization in [LocalBackend.Start]\n+\n \t// extHost is the bridge between [LocalBackend] and the registered [ipnext.Extension]s.\n \t// It may be nil in tests that use direct composite literal initialization of [LocalBackend]\n \t// instead of calling [NewLocalBackend]. A nil pointer is a valid, no-op host.\n@@ -568,8 +570,6 @@ func NewLocalBackend(logf logger.Logf, logID logid.PublicID, sys *tsd.System, lo\n \t\t\t}\n \t\t}\n \t}\n-\n-\tb.extHost.Init()\n \treturn b, nil\n }\n \n@@ -2162,6 +2162,11 @@ func (b *LocalBackend) getNewControlClientFuncLocked() clientGen {\n \treturn b.ccGen\n }\n \n+// initOnce is called on the first call to [LocalBackend.Start].\n+func (b *LocalBackend) initOnce() {\n+\tb.extHost.Init()\n+}\n+\n // Start applies the configuration specified in opts, and starts the\n // state machine.\n //\n@@ -2175,6 +2180,8 @@ func (b *LocalBackend) getNewControlClientFuncLocked() clientGen {\n func (b *LocalBackend) Start(opts ipn.Options) error {\n \tb.logf(\"Start\")\n \n+\tb.startOnce.Do(b.initOnce)\n+\n \tvar clientToShutdown controlclient.Client\n \tdefer func() {\n \t\tif clientToShutdown != nil {\n---\n\n\n---\n\nChoice C:\nprober/prober.go\n@@ -559,8 +559,8 @@ func (p *Prober) RunHandler(w http.ResponseWriter, r *http.Request) error {\n \t\t\tPreviousSuccessRatio:  prevInfo.RecentSuccessRatio(),\n \t\t\tPreviousMedianLatency: prevInfo.RecentMedianLatency(),\n \t\t}\n-\t\tw.WriteHeader(respStatus)\n \t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tw.WriteHeader(respStatus)\n \t\tif err := json.NewEncoder(w).Encode(resp); err != nil {\n \t\t\treturn tsweb.Error(http.StatusInternalServerError, \"error encoding JSON response\", err)\n \t\t}\n---\nprober/prober_test.go\n@@ -598,6 +598,9 @@ func TestProberRunHandler(t *testing.T) {\n \t\t\t\t}\n \n \t\t\t\tif reqJSON {\n+\t\t\t\t\tif w.Header().Get(\"Content-Type\") != \"application/json\" {\n+\t\t\t\t\t\tt.Errorf(\"unexpected content type: got %q, want application/json\", w.Header().Get(\"Content-Type\"))\n+\t\t\t\t\t}\n \t\t\t\t\tvar gotJSON RunHandlerResponse\n \t\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), &gotJSON); err != nil {\n \t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, w.Body.String())\n---\n\n\n---\n\nChoice D:\ngo.toolchain.rev\n@@ -1 +1 @@\n-4fdaeeb8fe43bcdb4e8cc736433b9cd9c0ddd221\n+982da8f24fa0504f2214f24b0d68b2febd5983f8\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis avoids reconfiguring the dialer unless the router config has changed.\r\n\r\nUpdates #12027\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -64,7 +64,6 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n-\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4844,12 +4843,6 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n-\t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n-\t} else {\n-\t\tb.dialer.SetRoutes(nil, nil)\n-\t}\n-\n \tb.initPeerAPIListener()\n \tb.readvertiseAppConnectorRoutes()\n }\n---\nwgengine/userspace.go\n@@ -26,6 +26,7 @@ import (\n \t\"tailscale.com/health\"\n \t\"tailscale.com/ipn/ipnstate\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/flowtrack\"\n \t\"tailscale.com/net/ipset\"\n \t\"tailscale.com/net/netmon\"\n@@ -102,6 +103,7 @@ type userspaceEngine struct {\n \ttundev           *tstun.Wrapper\n \twgdev            *device.Device\n \trouter           router.Router\n+\tdialer           *tsdial.Dialer\n \tconfListenPort   uint16 // original conf.ListenPort\n \tdns              *dns.Manager\n \tmagicConn        *magicsock.Conn\n@@ -344,6 +346,7 @@ func NewUserspaceEngine(logf logger.Logf, conf Config) (_ Engine, reterr error)\n \t\twaitCh:         make(chan struct{}),\n \t\ttundev:         tsTUNDev,\n \t\trouter:         rtr,\n+\t\tdialer:         conf.Dialer,\n \t\tconfListenPort: conf.ListenPort,\n \t\tbirdClient:     conf.BIRDClient,\n \t\tcontrolKnobs:   conf.ControlKnobs,\n@@ -1028,6 +1031,14 @@ func (e *userspaceEngine) Reconfig(cfg *wgcfg.Config, routerCfg *router.Config,\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\n+\t\tif resolver.ShouldUseRoutes(e.controlKnobs) {\n+\t\t\te.logf(\"wgengine: Reconfig: user dialer\")\n+\t\t\te.dialer.SetRoutes(routerCfg.Routes, routerCfg.LocalRoutes)\n+\t\t} else {\n+\t\t\te.dialer.SetRoutes(nil, nil)\n+\t\t}\n+\n \t\t// Keep DNS configuration after router configuration, as some\n \t\t// DNS managers refuse to apply settings if the device has no\n \t\t// assigned address.\n---\n\n\n---\n\nChoice B:\nprober/derp.go\n@@ -596,11 +596,23 @@ func (d *derpProber) updateMap(ctx context.Context) error {\n }\n \n func (d *derpProber) ProbeUDP(ipaddr string, port int) ProbeClass {\n+\tinitLabels := make(Labels)\n+\tip := net.ParseIP(ipaddr)\n+\n+\tif ip.To4() != nil {\n+\t\tinitLabels[\"address_family\"] = \"ipv4\"\n+\t} else if ip.To16() != nil { // Will return an IPv4 as 16 byte, so ensure the check for IPv4 precedes this\n+\t\tinitLabels[\"address_family\"] = \"ipv6\"\n+\t} else {\n+\t\tinitLabels[\"address_family\"] = \"unknown\"\n+\t}\n+\n \treturn ProbeClass{\n \t\tProbe: func(ctx context.Context) error {\n \t\t\treturn derpProbeUDP(ctx, ipaddr, port)\n \t\t},\n-\t\tClass: \"derp_udp\",\n+\t\tClass:  \"derp_udp\",\n+\t\tLabels: initLabels,\n \t}\n }\n \n---\nprober/prober.go\n@@ -404,10 +404,14 @@ func (p *Probe) recordEndLocked(err error) {\n \t\tp.mSeconds.WithLabelValues(\"ok\").Add(latency.Seconds())\n \t\tp.latencyHist.Value = latency\n \t\tp.latencyHist = p.latencyHist.Next()\n+\t\tp.mAttempts.WithLabelValues(\"fail\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"fail\").Add(0)\n \t} else {\n \t\tp.latency = 0\n \t\tp.mAttempts.WithLabelValues(\"fail\").Inc()\n \t\tp.mSeconds.WithLabelValues(\"fail\").Add(latency.Seconds())\n+\t\tp.mAttempts.WithLabelValues(\"ok\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"ok\").Add(0)\n \t}\n \tp.successHist.Value = p.succeeded\n \tp.successHist = p.successHist.Next()\n---\n\n\n---\n\nChoice C:\ngo.mod\n@@ -272,7 +272,7 @@ require (\n \tgithub.com/gordonklaus/ineffassign v0.1.0 // indirect\n \tgithub.com/goreleaser/chglog v0.5.0 // indirect\n \tgithub.com/goreleaser/fileglob v1.3.0 // indirect\n-\tgithub.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30\n+\tgithub.com/gorilla/csrf v1.7.3\n \tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n \tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n \tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n---\ngo.sum\n@@ -524,8 +524,8 @@ github.com/goreleaser/fileglob v1.3.0 h1:/X6J7U8lbDpQtBvGcwwPS6OpzkNVlVEsFUVRx9+\n github.com/goreleaser/fileglob v1.3.0/go.mod h1:Jx6BoXv3mbYkEzwm9THo7xbr5egkAraxkGorbJb4RxU=\n github.com/goreleaser/nfpm/v2 v2.33.1 h1:EkdAzZyVhAI9JC1vjmjjbmnNzyH1J6Cu4JCsA7YcQuc=\n github.com/goreleaser/nfpm/v2 v2.33.1/go.mod h1:8wwWWvJWmn84xo/Sqiv0aMvEGTHlHZTXTEuVSgQpkIM=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30 h1:fiJdrgVBkjZ5B1HJ2WQwNOaXB+QyYcNXTA3t1XYLz0M=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n+github.com/gorilla/csrf v1.7.3 h1:BHWt6FTLZAb2HtWT5KDBf6qgpZzvtbp9QWDRKZMXJC0=\n+github.com/gorilla/csrf v1.7.3/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n github.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\n github.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\n github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=\n---\n\n\n---\n\nChoice D:\nwgengine/magicsock/endpoint.go\n@@ -552,7 +552,7 @@ func (de *endpoint) addrForSendLocked(now mono.Time) (udpAddr, derpAddr netip.Ad\n // addrForWireGuardSendLocked returns the address that should be used for\n // sending the next packet. If a packet has never or not recently been sent to\n // the endpoint, then a randomly selected address for the endpoint is returned,\n-// as well as a bool indiciating that WireGuard discovery pings should be started.\n+// as well as a bool indicating that WireGuard discovery pings should be started.\n // If the addresses have latency information available, then the address with the\n // best latency is used.\n //\n@@ -1261,7 +1261,7 @@ func (de *endpoint) sendDiscoPingsLocked(now mono.Time, sendCallMeMaybe bool) {\n }\n \n // sendWireGuardOnlyPingsLocked evaluates all available addresses for\n-// a WireGuard only endpoint and initates an ICMP ping for useable\n+// a WireGuard only endpoint and initiates an ICMP ping for useable\n // addresses.\n func (de *endpoint) sendWireGuardOnlyPingsLocked(now mono.Time) {\n \tif runtime.GOOS == \"js\" {\n@@ -1629,7 +1629,7 @@ func (de *endpoint) handlePongConnLocked(m *disco.Pong, di *discoInfo, src netip\n \t\t\tde.c.logf(\"magicsock: disco: node %v %v now using %v mtu=%v tx=%x\", de.publicKey.ShortString(), de.discoShort(), sp.to, thisPong.wireMTU, m.TxID[:6])\n \t\t\tde.debugUpdates.Add(EndpointChange{\n \t\t\t\tWhen: time.Now(),\n-\t\t\t\tWhat: \"handlePingLocked-bestAddr-update\",\n+\t\t\t\tWhat: \"handlePongConnLocked-bestAddr-update\",\n \t\t\t\tFrom: de.bestAddr,\n \t\t\t\tTo:   thisPong,\n \t\t\t})\n@@ -1638,7 +1638,7 @@ func (de *endpoint) handlePongConnLocked(m *disco.Pong, di *discoInfo, src netip\n \t\tif de.bestAddr.AddrPort == thisPong.AddrPort {\n \t\t\tde.debugUpdates.Add(EndpointChange{\n \t\t\t\tWhen: time.Now(),\n-\t\t\t\tWhat: \"handlePingLocked-bestAddr-latency\",\n+\t\t\t\tWhat: \"handlePongConnLocked-bestAddr-latency\",\n \t\t\t\tFrom: de.bestAddr,\n \t\t\t\tTo:   thisPong,\n \t\t\t})\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nCatch failing tests that have no expected error string.\r\n\r\nUpdates #15912\n\n---\n\nChoice A:\nwgengine/netstack/netstack.go\n@@ -326,10 +326,15 @@ func Create(logf logger.Logf, tundev *tstun.Wrapper, e wgengine.Engine, mc *magi\n \tif tcpipErr != nil {\n \t\treturn nil, fmt.Errorf(\"could not disable TCP RACK: %v\", tcpipErr)\n \t}\n-\tcubicOpt := tcpip.CongestionControlOption(\"cubic\")\n-\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &cubicOpt)\n+\t// gVisor defaults to reno at the time of writing. We explicitly set reno\n+\t// congestion control in order to prevent unexpected changes. Netstack\n+\t// has an int overflow in sender congestion window arithmetic that is more\n+\t// prone to trigger with cubic congestion control.\n+\t// See https://github.com/google/gvisor/issues/11632\n+\trenoOpt := tcpip.CongestionControlOption(\"reno\")\n+\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &renoOpt)\n \tif tcpipErr != nil {\n-\t\treturn nil, fmt.Errorf(\"could not set cubic congestion control: %v\", tcpipErr)\n+\t\treturn nil, fmt.Errorf(\"could not set reno congestion control: %v\", tcpipErr)\n \t}\n \terr := setTCPBufSizes(ipstack)\n \tif err != nil {\n---\n\n\n---\n\nChoice B:\nclient/systray/systray.go\n@@ -84,12 +84,13 @@ type Menu struct {\n \tbgCancel context.CancelFunc\n \n \t// Top-level menu items\n-\tconnect    *systray.MenuItem\n-\tdisconnect *systray.MenuItem\n-\tself       *systray.MenuItem\n-\texitNodes  *systray.MenuItem\n-\tmore       *systray.MenuItem\n-\tquit       *systray.MenuItem\n+\tconnect     *systray.MenuItem\n+\tdisconnect  *systray.MenuItem\n+\tself        *systray.MenuItem\n+\texitNodes   *systray.MenuItem\n+\tmore        *systray.MenuItem\n+\trebuildMenu *systray.MenuItem\n+\tquit        *systray.MenuItem\n \n \trebuildCh  chan struct{} // triggers a menu rebuild\n \taccountsCh chan ipn.ProfileID\n@@ -295,6 +296,17 @@ func (menu *Menu) rebuild() {\n \t\t})\n \t}\n \n+\t// TODO(#15528): this menu item shouldn't be necessary at all,\n+\t// but is at least more discoverable than having users switch profiles or exit nodes.\n+\tmenu.rebuildMenu = systray.AddMenuItem(\"Rebuild menu\", \"Fix missing menu items\")\n+\tonClick(ctx, menu.rebuildMenu, func(ctx context.Context) {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\tcase menu.rebuildCh <- struct{}{}:\n+\t\t}\n+\t})\n+\tmenu.rebuildMenu.Enable()\n+\n \tmenu.quit = systray.AddMenuItem(\"Quit\", \"Quit the app\")\n \tmenu.quit.Enable()\n \n---\n\n\n---\n\nChoice C:\nprober/tls_test.go\n@@ -252,7 +252,7 @@ func TestCRL(t *testing.T) {\n \t\t\t\"NoCRL\",\n \t\t\tleafCertParsed,\n \t\t\tnil,\n-\t\t\t\"\",\n+\t\t\t\"no CRL server presented in leaf cert for\",\n \t\t},\n \t\t{\n \t\t\t\"NotBeforeCRLStaplingDate\",\n@@ -276,7 +276,7 @@ func TestCRL(t *testing.T) {\n \t\t\t\treturn\n \t\t\t}\n \n-\t\t\tif err == nil || !strings.Contains(err.Error(), tt.wantErr) {\n+\t\t\tif err == nil || tt.wantErr == \"\" || !strings.Contains(err.Error(), tt.wantErr) {\n \t\t\t\tt.Errorf(\"unexpected error %q; want %q\", err, tt.wantErr)\n \t\t\t}\n \t\t})\n---\n\n\n---\n\nChoice D:\ndocs/k8s/operator-architecture.md\n@@ -131,11 +131,11 @@ flowchart TD\n \n [Documentation][kb-operator-l7-ingress]\n \n-L7 ingress is relatively similar to L3 ingress. It is configured via an\n-`Ingress` object instead of a `Service`, and uses `tailscale serve` to accept\n-traffic instead of configuring `iptables` or `nftables` rules. Note that we use\n-tailscaled's local API (`SetServeConfig`) to set serve config, not the\n-`tailscale serve` command.\n+The L7 ingress architecture diagram is relatively similar to L3 ingress. It is\n+configured via an `Ingress` object instead of a `Service`, and uses\n+`tailscale serve` to accept traffic instead of configuring `iptables` or\n+`nftables` rules. Note that we use tailscaled's local API (`SetServeConfig`) to\n+set serve config, not the `tailscale serve` command.\n \n ```mermaid\n %%{ init: { 'theme':'neutral' } }%%\n@@ -159,6 +159,10 @@ flowchart TD\n             state-secret[\"state Secret\"]\n         end\n \n+        subgraph cluster-scope[Cluster scoped resources]\n+            ingress-class[Tailscale IngressClass]\n+        end\n+\n         subgraph defaultns[namespace=default]\n             ingress[tailscale Ingress]\n             svc[\"Service\"]\n@@ -260,6 +264,8 @@ flowchart TD\n \n ## `ProxyGroup`\n \n+### Egress\n+\n [Documentation][kb-operator-l3-egress-proxygroup]\n \n The `ProxyGroup` custom resource manages a collection of proxy Pods that\n@@ -278,8 +284,6 @@ ports via the ClusterIP Service and its EndpointSlice. The operator then\n generates the egress ConfigMap that tells the `ProxyGroup` Pods which incoming\n ports map to which egress targets.\n \n-`ProxyGroups` currently only support egress.\n-\n ```mermaid\n %%{ init: { 'theme':'neutral' } }%%\n \n@@ -364,6 +368,86 @@ flowchart LR\n \n ```\n \n+### Ingress\n+\n+A ProxyGroup can also serve as a highly available set of proxies for an\n+Ingress resource. The `-0` Pod is always the replica that will issue a certificate\n+from Let's Encrypt.\n+\n+If the same Ingress config is applied in multiple clusters, ProxyGroup proxies\n+from each cluster will be valid targets for the ts.net DNS name, and the proxy\n+each client is routed to will depend on the same rules as for [high availability][kb-ha]\n+subnet routers, and is encoded in the client's netmap.\n+\n+```mermaid\n+%%{ init: { 'theme':'neutral' } }%%\n+flowchart LR\n+    classDef tsnode color:#fff,fill:#000;\n+    classDef pod fill:#fff;\n+\n+    subgraph Key\n+        ts[Tailscale device]:::tsnode\n+        pod((Pod)):::pod\n+        blank[\" \"]-->|WireGuard traffic| blank2[\" \"]\n+        blank3[\" \"]-->|Other network traffic| blank4[\" \"]\n+    end\n+\n+    subgraph k8s[Kubernetes cluster]\n+        subgraph tailscale-ns[namespace=tailscale]\n+            operator((operator)):::tsnode\n+            ingress-sts[\"StatefulSet\"]\n+            serve-cm[serve config ConfigMap]\n+            ingress-0((\"pg-0 (dst)\")):::tsnode\n+            ingress-1((\"pg-1 (dst)\")):::tsnode\n+            tls-secret[myapp.tails.ts.net Secret]\n+        end\n+\n+        subgraph defaultns[namespace=default]\n+            ingress[myapp.tails.ts.net Ingress]\n+            svc[\"myapp Service\"]\n+            svc --> pod1((pod1))\n+            svc --> pod2((pod2))\n+        end\n+\n+        subgraph cluster[Cluster scoped resources]\n+            ingress-class[Tailscale IngressClass]\n+            pg[ProxyGroup 'pg']\n+        end\n+    end\n+\n+    control[\"Tailscale control plane\"]\n+    ts-svc[\"myapp Tailscale Service\"]\n+\n+    client[\"client (src)\"]:::tsnode -->|dials https\\://myapp.tails.ts.net/api| ingress-1\n+    ingress-0 -->|forwards traffic| svc\n+    ingress-1 -->|forwards traffic| svc\n+    control -.->|creates| ts-svc\n+    operator -.->|creates myapp Tailscale Service| control\n+    control -.->|netmap points myapp Tailscale Service to pg-1| client\n+    operator -.->|creates| ingress-sts\n+    ingress-sts -.->|manages| ingress-0\n+    ingress-sts -.->|manages| ingress-1\n+    ingress-0 -.->|issues myapp.tails.ts.net cert| le[Let's Encrypt]\n+    ingress-0 -.->|stores cert| tls-secret\n+    ingress-1 -.->|reads cert| tls-secret\n+    operator -.->|watches| ingress\n+    operator -.->|watches| pg\n+    operator -.->|creates| serve-cm\n+    serve-cm -.->|mounted| ingress-0\n+    serve-cm -.->|mounted| ingress-1\n+    ingress -.->|/api prefix| svc\n+\n+    linkStyle 0 stroke:red;\n+    linkStyle 4 stroke:red;\n+\n+    linkStyle 1 stroke:blue;\n+    linkStyle 2 stroke:blue;\n+    linkStyle 3 stroke:blue;\n+    linkStyle 5 stroke:blue;\n+    linkStyle 6 stroke:blue;\n+\n+```\n+\n ## Connector\n \n [Subnet router and exit node documentation][kb-operator-connector]\n@@ -514,4 +598,5 @@ flowchart TD\n [kb-operator-connector]: https://tailscale.com/kb/1441/kubernetes-operator-connector\n [kb-operator-app-connector]: https://tailscale.com/kb/1517/kubernetes-operator-app-connector\n [kb-operator-recorder]: https://tailscale.com/kb/1484/kubernetes-operator-deploying-tsrecorder\n+[kb-ha]: https://tailscale.com/kb/1115/high-availability\n [k8s-impersonation]: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes tailscale/corp#28524\n\n---\n\nChoice A:\ndocs/windows/policy/en-US/tailscale.adml\n@@ -16,6 +16,7 @@\n             <string id=\"SINCE_V1_62\">Tailscale version 1.62.0 and later</string>\n             <string id=\"SINCE_V1_74\">Tailscale version 1.74.0 and later</string>\n             <string id=\"SINCE_V1_78\">Tailscale version 1.78.0 and later</string>\n+            <string id=\"SINCE_V1_80\">Tailscale version 1.80.0 and later</string>\n             <string id=\"SINCE_V1_82\">Tailscale version 1.82.0 and later</string>\n             <string id=\"SINCE_V1_84\">Tailscale version 1.84.0 and later</string>\n             <string id=\"Tailscale_Category\">Tailscale</string>\n@@ -271,6 +272,12 @@ If you enable this policy, the menu item will be displayed indicating the organi\n If you disable this policy or do not configure it, the corresponding menu item will be hidden.\n \n See https://tailscale.com/kb/1315/mdm-keys#set-your-organization-name for more details.]]></string>\n+            <string id=\"OnboardingFlow\">Show the onboarding flow</string>\n+            <string id=\"OnboardingFlow_Help\"><![CDATA[This policy can be used to show or hide the onboarding flow displayed by the GUI.\n+\n+If you enable or don't configure this policy, the onboarding flow will be shown to new users who have not yet signed in to a Tailscale account.\n+\n+If you disable this policy, the onboarding flow will never be shown.]]></string>\n         </stringTable>\n         <presentationTable>\n             <presentation id=\"LoginURL\">\n---\ndocs/windows/policy/tailscale.admx\n@@ -54,6 +54,10 @@\n                   displayName=\"$(string.SINCE_V1_78)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n       </definition>\n+      <definition name=\"SINCE_V1_80\"\n+                  displayName=\"$(string.SINCE_V1_80)\">\n+        <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n+      </definition>\n       <definition name=\"SINCE_V1_82\"\n                   displayName=\"$(string.SINCE_V1_82)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n@@ -335,6 +339,16 @@\n         <string>hide</string>\n       </disabledValue>\n     </policy>\n+    <policy name=\"OnboardingFlow\" class=\"Both\" displayName=\"$(string.OnboardingFlow)\" explainText=\"$(string.OnboardingFlow_Help)\" key=\"Software\\Policies\\Tailscale\" valueName=\"OnboardingFlow\">\n+      <parentCategory ref=\"UI_Category\" />\n+      <supportedOn ref=\"SINCE_V1_80\" />\n+      <enabledValue>\n+        <string>show</string>\n+      </enabledValue>\n+      <disabledValue>\n+        <string>hide</string>\n+      </disabledValue>\n+    </policy>\n     <policy name=\"ManagedBy\" class=\"Both\" displayName=\"$(string.ManagedBy)\" explainText=\"$(string.ManagedBy_Help)\" presentation=\"$(presentation.ManagedBy)\" key=\"Software\\Policies\\Tailscale\">\n       <parentCategory ref=\"UI_Category\" />\n       <supportedOn ref=\"SINCE_V1_62\" />\n---\n\n\n---\n\nChoice B:\nipn/localapi/localapi.go\n@@ -397,6 +397,15 @@ func (h *Handler) serveBugReport(w http.ResponseWriter, r *http.Request) {\n \t// OS-specific details\n \th.logf.JSON(1, \"UserBugReportOS\", osdiag.SupportInfo(osdiag.LogSupportInfoReasonBugReport))\n \n+\t// Tailnet lock details\n+\tst := h.b.NetworkLockStatus()\n+\tif st.Enabled {\n+\t\th.logf.JSON(1, \"UserBugReportTailnetLockStatus\", st)\n+\t\tif st.NodeKeySignature != nil {\n+\t\t\th.logf(\"user bugreport tailnet lock signature: %s\", st.NodeKeySignature.String())\n+\t\t}\n+\t}\n+\n \tif defBool(r.URL.Query().Get(\"diagnose\"), false) {\n \t\th.b.Doctor(r.Context(), logger.WithPrefix(h.logf, \"diag: \"))\n \t}\n---\n\n\n---\n\nChoice C:\ntsnet/tsnet_test.go\n@@ -120,6 +120,7 @@ func startControl(t *testing.T) (controlURL string, control *testcontrol.Server)\n \t\t\tProxied: true,\n \t\t},\n \t\tMagicDNSDomain: \"tail-scale.ts.net\",\n+\t\tLogf:           t.Logf,\n \t}\n \tcontrol.HTTPTestServer = httptest.NewUnstartedServer(control)\n \tcontrol.HTTPTestServer.Start()\n@@ -221,7 +222,7 @@ func startServer(t *testing.T, ctx context.Context, controlURL, hostname string)\n \t\tgetCertForTesting: testCertRoot.getCert,\n \t}\n \tif *verboseNodes {\n-\t\ts.Logf = log.Printf\n+\t\ts.Logf = t.Logf\n \t}\n \tt.Cleanup(func() { s.Close() })\n \n---\n\n\n---\n\nChoice D:\nrelease/dist/cli/cli.go\n@@ -65,6 +65,7 @@ func CLI(getTargets func() ([]dist.Target, error)) *ffcli.Command {\n \t\t\t\t\tfs.StringVar(&buildArgs.manifest, \"manifest\", \"\", \"manifest file to write\")\n \t\t\t\t\tfs.BoolVar(&buildArgs.verbose, \"verbose\", false, \"verbose logging\")\n \t\t\t\t\tfs.StringVar(&buildArgs.webClientRoot, \"web-client-root\", \"\", \"path to root of web client source to build\")\n+\t\t\t\t\tfs.StringVar(&buildArgs.outPath, \"out\", \"\", \"path to write output artifacts (defaults to '$PWD/dist' if not set)\")\n \t\t\t\t\treturn fs\n \t\t\t\t})(),\n \t\t\t\tLongHelp: strings.TrimSpace(`\n@@ -156,6 +157,7 @@ var buildArgs struct {\n \tmanifest      string\n \tverbose       bool\n \twebClientRoot string\n+\toutPath       string\n }\n \n func runBuild(ctx context.Context, filters []string, targets []dist.Target) error {\n@@ -172,7 +174,11 @@ func runBuild(ctx context.Context, filters []string, targets []dist.Target) erro\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting working directory: %w\", err)\n \t}\n-\tb, err := dist.NewBuild(wd, filepath.Join(wd, \"dist\"))\n+\toutPath := filepath.Join(wd, \"dist\")\n+\tif buildArgs.outPath != \"\" {\n+\t\toutPath = buildArgs.outPath\n+\t}\n+\tb, err := dist.NewBuild(wd, outPath)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"creating build context: %w\", err)\n \t}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIn `tailssh.go:1284`, `(*sshSession).startNewRecording` starts a fire-and-forget goroutine that can outlive the test that triggered its creation. Among other things, it uses `ss.logf`, and may call it after the test has already returned. Since we typically use `(*testing.T).Logf` as the logger, this results in a data race and causes flaky tests.\r\n\r\nIdeally, we should fix the root cause and/or use a `goroutines.Tracker` to wait for the goroutine to complete. But with the release approaching, it might be too risky to make such changes now.\r\n\r\nAs a workaround, we update the tests to use `tstest.WhileTestRunningLogger`, which logs to `t.Logf` while the test is running and disables logging once the test finishes, avoiding the race.\r\n\r\nWhile there, we also fix `TestSSHAuthFlow` not to use `log.Printf`.\r\n\r\nUpdates #15568\r\nUpdates #7707 (probably related)\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -64,7 +64,6 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n-\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4844,12 +4843,6 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n-\t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n-\t} else {\n-\t\tb.dialer.SetRoutes(nil, nil)\n-\t}\n-\n \tb.initPeerAPIListener()\n \tb.readvertiseAppConnectorRoutes()\n }\n---\nwgengine/userspace.go\n@@ -26,6 +26,7 @@ import (\n \t\"tailscale.com/health\"\n \t\"tailscale.com/ipn/ipnstate\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/flowtrack\"\n \t\"tailscale.com/net/ipset\"\n \t\"tailscale.com/net/netmon\"\n@@ -102,6 +103,7 @@ type userspaceEngine struct {\n \ttundev           *tstun.Wrapper\n \twgdev            *device.Device\n \trouter           router.Router\n+\tdialer           *tsdial.Dialer\n \tconfListenPort   uint16 // original conf.ListenPort\n \tdns              *dns.Manager\n \tmagicConn        *magicsock.Conn\n@@ -344,6 +346,7 @@ func NewUserspaceEngine(logf logger.Logf, conf Config) (_ Engine, reterr error)\n \t\twaitCh:         make(chan struct{}),\n \t\ttundev:         tsTUNDev,\n \t\trouter:         rtr,\n+\t\tdialer:         conf.Dialer,\n \t\tconfListenPort: conf.ListenPort,\n \t\tbirdClient:     conf.BIRDClient,\n \t\tcontrolKnobs:   conf.ControlKnobs,\n@@ -1028,6 +1031,14 @@ func (e *userspaceEngine) Reconfig(cfg *wgcfg.Config, routerCfg *router.Config,\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\n+\t\tif resolver.ShouldUseRoutes(e.controlKnobs) {\n+\t\t\te.logf(\"wgengine: Reconfig: user dialer\")\n+\t\t\te.dialer.SetRoutes(routerCfg.Routes, routerCfg.LocalRoutes)\n+\t\t} else {\n+\t\t\te.dialer.SetRoutes(nil, nil)\n+\t\t}\n+\n \t\t// Keep DNS configuration after router configuration, as some\n \t\t// DNS managers refuse to apply settings if the device has no\n \t\t// assigned address.\n---\n\n\n---\n\nChoice B:\ntsnet/depaware.txt\n@@ -80,10 +80,10 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n    L    github.com/aws/smithy-go/transport/http                      from github.com/aws/aws-sdk-go-v2/aws/middleware+\n    L    github.com/aws/smithy-go/transport/http/internal/io          from github.com/aws/smithy-go/transport/http\n    L    github.com/aws/smithy-go/waiter                              from github.com/aws/aws-sdk-go-v2/service/ssm\n- LDWA    github.com/coder/websocket                                   from tailscale.com/util/eventbus\n- LDWA    github.com/coder/websocket/internal/errd                     from github.com/coder/websocket\n- LDWA    github.com/coder/websocket/internal/util                     from github.com/coder/websocket\n- LDWA    github.com/coder/websocket/internal/xsync                    from github.com/coder/websocket\n+ LDW    github.com/coder/websocket                                   from tailscale.com/util/eventbus\n+ LDW    github.com/coder/websocket/internal/errd                     from github.com/coder/websocket\n+ LDW    github.com/coder/websocket/internal/util                     from github.com/coder/websocket\n+ LDW    github.com/coder/websocket/internal/xsync                    from github.com/coder/websocket\n    L    github.com/coreos/go-iptables/iptables                       from tailscale.com/util/linuxfw\n    W \ud83d\udca3 github.com/dblohm7/wingoes                                   from github.com/dblohm7/wingoes/com+\n    W \ud83d\udca3 github.com/dblohm7/wingoes/com                               from tailscale.com/util/osdiag+\n@@ -552,7 +552,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         hash/crc32                                                   from compress/gzip+\n         hash/maphash                                                 from go4.org/mem\n         html                                                         from html/template+\n- LDWA    html/template                                                from github.com/gorilla/csrf+\n+ LDW    html/template                                                from github.com/gorilla/csrf+\n         internal/abi                                                 from crypto/x509/internal/macos+\n         internal/asan                                                from internal/runtime/maps+\n         internal/bisect                                              from internal/godebug\n@@ -639,8 +639,8 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         sync/atomic                                                  from context+\n         syscall                                                      from archive/tar+\n         text/tabwriter                                               from runtime/pprof\n- LDWA    text/template                                                from html/template\n- LDWA    text/template/parse                                          from html/template+\n+ LDW    text/template                                                from html/template\n+ LDW    text/template/parse                                          from html/template+\n         time                                                         from archive/tar+\n         unicode                                                      from bytes+\n         unicode/utf16                                                from crypto/x509+\n---\nutil/eventbus/debughttp.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !ios\n+//go:build !ios && !android\n \n package eventbus\n \n---\nutil/eventbus/debughttp_off.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build ios\n+//go:build ios || android\n \n package eventbus\n \n@@ -12,6 +12,8 @@ func registerHTTPDebugger(d *Debugger, td *tsweb.DebugHandler) {\n \t// reflection for method lookups. This forces the compiler to\n \t// retain a lot more code and information to make dynamic method\n \t// dispatch work, which is unacceptable bloat for the iOS build.\n+\t// We also disable it on Android while we're at it, as nobody\n+\t// is debugging Tailscale internals on Android.\n \t//\n \t// TODO: https://github.com/tailscale/tailscale/issues/15297 to\n \t// bring the debug UI back to iOS somehow.\n---\n\n\n---\n\nChoice C:\ndrive/driveimpl/dirfs/dirfs.go\n@@ -44,7 +44,7 @@ func (c *Child) isAvailable() bool {\n // Any attempts to perform operations on paths inside of children will result\n // in a panic, as these are not expected to be performed on this FS.\n //\n-// An FS an optionally have a StaticRoot, which will insert a folder with that\n+// An FS can optionally have a StaticRoot, which will insert a folder with that\n // StaticRoot into the tree, like this:\n //\n // -- <StaticRoot>\n---\ndrive/driveimpl/fileserver.go\n@@ -61,7 +61,7 @@ func NewFileServer() (*FileServer, error) {\n \t}, nil\n }\n \n-// generateSecretToken generates a hex-encoded 256 bit secet.\n+// generateSecretToken generates a hex-encoded 256 bit secret.\n func generateSecretToken() (string, error) {\n \ttokenBytes := make([]byte, 32)\n \t_, err := rand.Read(tokenBytes)\n---\ndrive/remote_permissions.go\n@@ -32,7 +32,7 @@ type grant struct {\n \tAccess string\n }\n \n-// ParsePermissions builds a Permissions map from a lis of raw grants.\n+// ParsePermissions builds a Permissions map from a list of raw grants.\n func ParsePermissions(rawGrants [][]byte) (Permissions, error) {\n \tpermissions := make(Permissions)\n \tfor _, rawGrant := range rawGrants {\n---\n\n\n---\n\nChoice D:\nssh/tailssh/tailssh_test.go\n@@ -16,7 +16,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"log\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n@@ -48,7 +47,6 @@ import (\n \t\"tailscale.com/tsd\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/types/key\"\n-\t\"tailscale.com/types/logger\"\n \t\"tailscale.com/types/logid\"\n \t\"tailscale.com/types/netmap\"\n \t\"tailscale.com/types/ptr\"\n@@ -230,7 +228,7 @@ func TestMatchRule(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tc := &conn{\n \t\t\t\tinfo: tt.ci,\n-\t\t\t\tsrv:  &server{logf: t.Logf},\n+\t\t\t\tsrv:  &server{logf: tstest.WhileTestRunningLogger(t)},\n \t\t\t}\n \t\t\tgot, gotUser, gotAcceptEnv, err := c.matchRule(tt.rule)\n \t\t\tif err != tt.wantErr {\n@@ -349,7 +347,7 @@ func TestEvalSSHPolicy(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tc := &conn{\n \t\t\t\tinfo: tt.ci,\n-\t\t\t\tsrv:  &server{logf: t.Logf},\n+\t\t\t\tsrv:  &server{logf: tstest.WhileTestRunningLogger(t)},\n \t\t\t}\n \t\t\tgot, gotUser, gotAcceptEnv, match := c.evalSSHPolicy(tt.policy)\n \t\t\tif match != tt.wantMatch {\n@@ -491,7 +489,7 @@ func TestSSHRecordingCancelsSessionsOnUploadFailure(t *testing.T) {\n \t})\n \n \ts := &server{\n-\t\tlogf: t.Logf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t\tlb: &localState{\n \t\t\tsshEnabled: true,\n \t\t\tmatchingRule: newSSHRule(\n@@ -553,7 +551,7 @@ func TestSSHRecordingCancelsSessionsOnUploadFailure(t *testing.T) {\n \n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n-\t\t\ts.logf = t.Logf\n+\t\t\ts.logf = tstest.WhileTestRunningLogger(t)\n \t\t\ttstest.Replace(t, &handler, tt.handler)\n \t\t\tsc, dc := memnet.NewTCPConn(src, dst, 1024)\n \t\t\tvar wg sync.WaitGroup\n@@ -621,7 +619,7 @@ func TestMultipleRecorders(t *testing.T) {\n \t})\n \n \ts := &server{\n-\t\tlogf: t.Logf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t\tlb: &localState{\n \t\t\tsshEnabled: true,\n \t\t\tmatchingRule: newSSHRule(\n@@ -714,7 +712,7 @@ func TestSSHRecordingNonInteractive(t *testing.T) {\n \t})\n \n \ts := &server{\n-\t\tlogf: t.Logf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t\tlb: &localState{\n \t\t\tsshEnabled: true,\n \t\t\tmatchingRule: newSSHRule(\n@@ -887,13 +885,15 @@ func TestSSHAuthFlow(t *testing.T) {\n \t\t},\n \t}\n \ts := &server{\n-\t\tlogf: log.Printf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t}\n \tdefer s.Shutdown()\n \tsrc, dst := must.Get(netip.ParseAddrPort(\"100.100.100.101:2231\")), must.Get(netip.ParseAddrPort(\"100.100.100.102:22\"))\n \tfor _, tc := range tests {\n \t\tfor _, authMethods := range [][]string{nil, {\"publickey\", \"password\"}, {\"password\", \"publickey\"}} {\n \t\t\tt.Run(fmt.Sprintf(\"%s-skip-none-auth-%v\", tc.name, strings.Join(authMethods, \"-then-\")), func(t *testing.T) {\n+\t\t\t\ts.logf = tstest.WhileTestRunningLogger(t)\n+\n \t\t\t\tsc, dc := memnet.NewTCPConn(src, dst, 1024)\n \t\t\t\ts.lb = tc.state\n \t\t\t\tsshUser := \"alice\"\n@@ -1036,7 +1036,7 @@ func TestSSHAuthFlow(t *testing.T) {\n }\n \n func TestSSH(t *testing.T) {\n-\tvar logf logger.Logf = t.Logf\n+\tlogf := tstest.WhileTestRunningLogger(t)\n \tsys := tsd.NewSystem()\n \teng, err := wgengine.NewFakeUserspaceEngine(logf, sys.Set, sys.HealthTracker(), sys.UserMetricsRegistry(), sys.Bus.Get())\n \tif err != nil {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nSet Cross-Origin-Opener-Policy: same-origin for all browser requests to\nprevent window.location manipulation by malicious origins.\n\nUpdates tailscale/corp#28480\n\nThank you to Triet H.M. Pham for the report.\n\nSigned-off-by: Patrick O'Doherty <patrick@tailscale.com>\n\n---\n\nChoice A:\nipn/ipnlocal/extension_host.go\n@@ -25,6 +25,7 @@ import (\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/execqueue\"\n \t\"tailscale.com/util/set\"\n+\t\"tailscale.com/util/slicesx\"\n \t\"tailscale.com/util/testenv\"\n )\n \n@@ -378,7 +379,7 @@ func (h *ExtensionHost) NotifyProfileChange(profile ipn.LoginProfileView, prefs\n \th.currentPrefs = prefs\n \th.currentProfile = profile\n \t// Get the callbacks to be invoked.\n-\tcbs := collectValues(h.profileStateChangeCbs)\n+\tcbs := slicesx.MapValues(h.profileStateChangeCbs)\n \th.mu.Unlock()\n \tfor _, cb := range cbs {\n \t\tcb(profile, prefs, sameNode)\n@@ -402,7 +403,7 @@ func (h *ExtensionHost) NotifyProfilePrefsChanged(profile ipn.LoginProfileView,\n \th.currentPrefs = newPrefs\n \th.currentProfile = profile\n \t// Get the callbacks to be invoked.\n-\tstateCbs := collectValues(h.profileStateChangeCbs)\n+\tstateCbs := slicesx.MapValues(h.profileStateChangeCbs)\n \th.mu.Unlock()\n \tfor _, cb := range stateCbs {\n \t\tcb(profile, newPrefs, true)\n@@ -443,7 +444,7 @@ func (h *ExtensionHost) DetermineBackgroundProfile(profiles ipnext.ProfileStore)\n \t// Attempt to resolve the background profile using the registered\n \t// background profile resolvers (e.g., [ipn/desktop.desktopSessionsExt] on Windows).\n \th.mu.Lock()\n-\tresolvers := collectValues(h.backgroundProfileResolvers)\n+\tresolvers := slicesx.MapValues(h.backgroundProfileResolvers)\n \th.mu.Unlock()\n \tfor _, resolver := range resolvers {\n \t\tif profile := resolver(profiles); profile.Valid() {\n@@ -481,7 +482,7 @@ func (h *ExtensionHost) NotifyNewControlClient(cc controlclient.Client, profile\n \t\treturn nil\n \t}\n \th.mu.Lock()\n-\tcbs := collectValues(h.newControlClientCbs)\n+\tcbs := slicesx.MapValues(h.newControlClientCbs)\n \th.mu.Unlock()\n \tif len(cbs) > 0 {\n \t\tccShutdownCbs = make([]func(), 0, len(cbs))\n@@ -527,7 +528,7 @@ func (h *ExtensionHost) AuditLogger() ipnauth.AuditLogFunc {\n \t}\n \n \th.mu.Lock()\n-\tproviders := collectValues(h.auditLoggers)\n+\tproviders := slicesx.MapValues(h.auditLoggers)\n \th.mu.Unlock()\n \n \tvar loggers []ipnauth.AuditLogFunc\n@@ -642,17 +643,3 @@ type execQueue interface {\n \tShutdown()\n \tWait(context.Context) error\n }\n-\n-// collectValues is like [slices.Collect] of [maps.Values],\n-// but pre-allocates the slice to avoid reallocations.\n-// It returns nil if the map is empty.\n-func collectValues[K comparable, V any](m map[K]V) []V {\n-\tif len(m) == 0 {\n-\t\treturn nil\n-\t}\n-\ts := make([]V, 0, len(m))\n-\tfor _, v := range m {\n-\t\ts = append(s, v)\n-\t}\n-\treturn s\n-}\n---\n\n\n---\n\nChoice B:\ncmd/k8s-operator/deploy/crds/tailscale.com_connectors.yaml\n@@ -32,6 +32,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_dnsconfigs.yaml\n@@ -20,6 +20,9 @@ spec:\n           jsonPath: .status.nameserver.ip\n           name: NameserverIP\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -18,6 +18,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxygroups.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .spec.type\n           name: Type\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_recorders.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .status.devices[?(@.url != \"\")].url\n           name: URL\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -61,6 +61,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -312,6 +315,9 @@ spec:\n               jsonPath: .status.nameserver.ip\n               name: NameserverIP\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -492,6 +498,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -2803,6 +2812,9 @@ spec:\n               jsonPath: .spec.type\n               name: Type\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -3013,6 +3025,9 @@ spec:\n               jsonPath: .status.devices[?(@.url != \"\")].url\n               name: URL\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n---\nk8s-operator/apis/v1alpha1/types_connector.go\n@@ -24,6 +24,7 @@ var ConnectorKind = \"Connector\"\n // +kubebuilder:printcolumn:name=\"IsExitNode\",type=\"string\",JSONPath=`.status.isExitNode`,description=\"Whether this Connector instance defines an exit node.\"\n // +kubebuilder:printcolumn:name=\"IsAppConnector\",type=\"string\",JSONPath=`.status.isAppConnector`,description=\"Whether this Connector instance is an app connector.\"\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ConnectorReady\")].reason`,description=\"Status of the deployed Connector resources.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Connector defines a Tailscale node that will be deployed in the cluster. The\n // node can be configured to act as a Tailscale subnet router and/or a Tailscale\n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -16,6 +16,7 @@ var ProxyClassKind = \"ProxyClass\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyClassReady\")].reason`,description=\"Status of the ProxyClass.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyClass describes a set of configuration parameters that can be applied to\n // proxy resources created by the Tailscale Kubernetes operator.\n---\nk8s-operator/apis/v1alpha1/types_proxygroup.go\n@@ -14,6 +14,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=pg\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyGroupReady\")].reason`,description=\"Status of the deployed ProxyGroup resources.\"\n // +kubebuilder:printcolumn:name=\"Type\",type=\"string\",JSONPath=`.spec.type`,description=\"ProxyGroup type.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyGroup defines a set of Tailscale devices that will act as proxies.\n // Currently only egress ProxyGroups are supported.\n---\nk8s-operator/apis/v1alpha1/types_recorder.go\n@@ -15,6 +15,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=rec\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"RecorderReady\")].reason`,description=\"Status of the deployed Recorder resources.\"\n // +kubebuilder:printcolumn:name=\"URL\",type=\"string\",JSONPath=`.status.devices[?(@.url != \"\")].url`,description=\"URL on which the UI is exposed if enabled.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Recorder defines a tsrecorder device for recording SSH sessions. By default,\n // it will store recordings in a local ephemeral volume. If you want to persist\n---\nk8s-operator/apis/v1alpha1/types_tsdnsconfig.go\n@@ -18,6 +18,7 @@ var DNSConfigKind = \"DNSConfig\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster,shortName=dc\n // +kubebuilder:printcolumn:name=\"NameserverIP\",type=\"string\",JSONPath=`.status.nameserver.ip`,description=\"Service IP address of the nameserver\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // DNSConfig can be deployed to cluster to make a subset of Tailscale MagicDNS\n // names resolvable by cluster workloads. Use this if: A) you need to refer to\n---\n\n\n---\n\nChoice C:\ngo.toolchain.rev\n@@ -1 +1 @@\n-16b6e4fd15c59336156cdbc977de1745ad094f2d\n+982da8f24fa0504f2214f24b0d68b2febd5983f8\n---\n\n\n---\n\nChoice D:\nsafeweb/http.go\n@@ -376,6 +376,7 @@ func (s *Server) serveBrowser(w http.ResponseWriter, r *http.Request) {\n \tw.Header().Set(\"Content-Security-Policy\", s.csp)\n \tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n \tw.Header().Set(\"Referer-Policy\", \"same-origin\")\n+\tw.Header().Set(\"Cross-Origin-Opener-Policy\", \"same-origin\")\n \tif s.SecureContext {\n \t\tw.Header().Set(\"Strict-Transport-Security\", cmp.Or(s.StrictTransportSecurityOptions, DefaultStrictTransportSecurityOptions))\n \t}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAdapted from [go/cleanup](https://docs.google.com/document/d/1b3v1xs-q-HQhOzExgDdhIiUTSiVyazW28WrZ2oDdmFc/view).\r\n\r\nFixes: #15932\n\n---\n\nChoice A:\nipn/desktop/mksyscall.go\n@@ -11,8 +11,6 @@ package desktop\n //sys registerClassEx(windowClass *_WNDCLASSEX) (atom uint16, err error) [atom==0] = user32.RegisterClassExW\n //sys createWindowEx(dwExStyle uint32, lpClassName *uint16, lpWindowName *uint16, dwStyle uint32, x int32, y int32, nWidth int32, nHeight int32, hWndParent windows.HWND, hMenu windows.Handle, hInstance windows.Handle, lpParam unsafe.Pointer) (hWnd windows.HWND, err error) [hWnd==0] = user32.CreateWindowExW\n //sys defWindowProc(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.DefWindowProcW\n-//sys setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) [res==0 && e1!=0] = user32.SetWindowLongPtrW\n-//sys getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) [res==0 && e1!=0] = user32.GetWindowLongPtrW\n //sys sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.SendMessageW\n //sys getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (ret int32) = user32.GetMessageW\n //sys translateMessage(lpMsg *_MSG) (res bool) = user32.TranslateMessage\n---\nipn/desktop/sessions_windows.go\n@@ -670,3 +670,38 @@ func (cs _WTS_CONNECTSTATE_CLASS) ToSessionStatus() SessionStatus {\n \t\treturn ClosedSession\n \t}\n }\n+\n+var (\n+\tprocGetWindowLongPtrW *windows.LazyProc\n+\tprocSetWindowLongPtrW *windows.LazyProc\n+)\n+\n+func init() {\n+\t// GetWindowLongPtrW and SetWindowLongPtrW are only available on 64-bit platforms.\n+\t// https://web.archive.org/web/20250414195520/https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw\n+\tif runtime.GOARCH == \"386\" || runtime.GOARCH == \"arm\" {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongW\")\n+\t} else {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongPtrW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongPtrW\")\n+\t}\n+}\n+\n+func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n---\nipn/desktop/zsyscall_windows.go\n@@ -48,11 +48,9 @@ var (\n \tprocDestroyWindow                      = moduser32.NewProc(\"DestroyWindow\")\n \tprocDispatchMessageW                   = moduser32.NewProc(\"DispatchMessageW\")\n \tprocGetMessageW                        = moduser32.NewProc(\"GetMessageW\")\n-\tprocGetWindowLongPtrW                  = moduser32.NewProc(\"GetWindowLongPtrW\")\n \tprocPostQuitMessage                    = moduser32.NewProc(\"PostQuitMessage\")\n \tprocRegisterClassExW                   = moduser32.NewProc(\"RegisterClassExW\")\n \tprocSendMessageW                       = moduser32.NewProc(\"SendMessageW\")\n-\tprocSetWindowLongPtrW                  = moduser32.NewProc(\"SetWindowLongPtrW\")\n \tprocTranslateMessage                   = moduser32.NewProc(\"TranslateMessage\")\n \tprocWTSRegisterSessionNotificationEx   = modwtsapi32.NewProc(\"WTSRegisterSessionNotificationEx\")\n \tprocWTSUnRegisterSessionNotificationEx = modwtsapi32.NewProc(\"WTSUnRegisterSessionNotificationEx\")\n@@ -98,15 +96,6 @@ func getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (r\n \treturn\n }\n \n-func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func postQuitMessage(exitCode int32) {\n \tsyscall.Syscall(procPostQuitMessage.Addr(), 1, uintptr(exitCode), 0, 0)\n \treturn\n@@ -127,15 +116,6 @@ func sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr)\n \treturn\n }\n \n-func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func translateMessage(lpMsg *_MSG) (res bool) {\n \tr0, _, _ := syscall.Syscall(procTranslateMessage.Addr(), 1, uintptr(unsafe.Pointer(lpMsg)), 0, 0)\n \tres = r0 != 0\n---\n\n\n---\n\nChoice B:\ndocs/commit-messages.md\n@@ -72,7 +72,7 @@ For the body (the rest of the description):\n \n - blank line after the subject (first) line\n - the text should be wrapped to ~76 characters (to appease git viewing tools, mainly), unless you really need longer lines (e.g. for ASCII art, tables, or long links)\n-- there must be a `Fixes` or `Updates` line for all non-trivial commits linking to a tracking bug. This goes after the body with a blank newline separating the two. Trivial code clean-up commits can use `Updates #cleanup` instead of an issue.\n+- there must be a `Fixes` or `Updates` line for all non-cleanup commits linking to a tracking bug. This goes after the body with a blank newline separating the two. [Cleanup commits](#is-it-a-cleanup) can use `Updates #cleanup` instead of an issue.\n - `Change-Id` lines should ideally be included in commits in the `corp` repo and are more optional in `tailscale/tailscale`. You can configure Git to do this for you by running `./tool/go run misc/install-git-hooks.go` from the root of the corp repo. This was originally a Gerrit thing and we don't use Gerrit, but it lets us tooling track commits as they're cherry-picked between branches. Also, tools like [git-cleanup](https://github.com/bradfitz/gitutil) use it to clean up your old local branches once they're merged upstream.\n - we don't use Markdown in commit messages. (Accidental Markdown like bulleted lists or even headings is fine, but not links)\n - we require `Signed-off-by` lines in public repos (such as `tailscale/tailscale`). Add them using `git commit --signoff` or `git commit -s` for short. You can use them in private repos but do not have to.\n@@ -108,6 +108,54 @@ For changes in `tailscale/tailscale` that fix a significant bug or add a new fea\n add `RELNOTE: <summary of change>` toward the end of the commit message.\n This will aid the release engineer in writing the release notes for the next release.\n \n+## Is it a #cleanup?\n+\n+Our issuebot permits writing `Updates #cleanup` instead of an actual GitHub issue number.\n+\n+But only do that if it\u2019s actually a cleanup. Don\u2019t use that as an excuse to avoid filing an issue.\n+\n+Shortcuts[^1] to file issues:\n+- [go/bugc](http://go/bugc) (corp, safe choice)\n+- [go/bugo](http://go/bugo) (open source, if you want it public to the world).\n+\n+[^1]: These shortcuts point to our Tailscale\u2019s internal URL shortener service, which you too [can run in your own Tailnet](https://tailscale.com/blog/golink).\n+\n+The following guide can help you decide whether a tracking issue is warranted.\n+\n+|     |     |\n+| --- | --- |\n+| Was there a crash/panic? | Not a cleanup. Put the panic in a bug. Talk about when it was introduced, why, why a test didn\u2019t catch it, note what followup work might need to be done. |\n+| Did a customer report it? | Not a cleanup. Make a corp bug with links to the customer ticket. |\n+| Is it from an incident, get paged? | Not a cleanup. Let\u2019s track why we got paged. |\n+| Does it change behavior? | Not a cleanup. File a bug to track why. |\n+| Adding a test for a recently fixed bug? | Not a cleanup. Use the recently fixed bug\u2019s bug number. |\n+| Does it tweak a constant/parameter? | Not a cleanup. File a bug to track the debugging/tuning effort and record past results and goals for the future state. |\n+| Fixing a regression from an earlier change? | Not a cleanup. At minimum, reference the PR that caused the regression, but if users noticed, it might warrant its own bug. |\n+| Is it part of an overall effort that\u2019ll take a hundred small steps? | Not a cleanup. The overall effort should have a tracking bug to collect all the minor efforts. |\n+| Is it a security fix? Is it a security hardening? | Not a cleanup. There should be a bug about security incidents or security hardening efforts and backporting to previous releases, etc. |\n+| Is it a feature flag being removed? | Not a cleanup. File a task to coordinate with other teams and to track the work. |\n+\n+### Actual cleanup examples\n+\n+- Fixing typos in internal comments that users would\u2019ve never seen\n+- Simple, mechanical replacement of a deprecated API to its equivalently behaving replacement\n+  - [`errors.Wrapf`](https://pkg.go.dev/github.com/pkg/errors#Wrapf) \u2192 [`fmt.Errorf(\"%w\")`](https://pkg.go.dev/fmt#Errorf)\n+  - [math/rand](https://pkg.go.dev/math/rand) \u2192 [math/rand/v2](https://pkg.go.dev/math/rand/v2)\n+- Code movement\n+- Removing dead code that doesn\u2019t change behavior (API changes, feature flags, etc)\n+- Refactoring in prep for another change (but maybe mention the upcoming change\u2019s bug as motivation)\n+- Adding a test that you just noticed was missing, not as a result of any bug or report or new feature coming\n+- Formatting (gofmt / prettifier) that was missed earlier\n+\n+### What\u2019s the point of an issue?\n+\n+- Let us capture information that is inappropriate for a commit message\n+- Let us have conversations on a change after the fact\n+- Let us track metadata on issues and decide what to backport\n+- Let us associate related changes to each other, including after the fact\n+- Lets you write the backstory once on an overall bug/effort and re-use that issue number for N future commits, without having to repeat yourself on each commit message\n+- Provides archaeological breadcrumbs to future debuggers, providing context on why things were changed\n+\n # Reverts\n \n When you use `git revert` to revert a commit, the default commit message will identify the commit SHA and message that was reverted.  You must expand this message to explain **why** it is being reverted, including a link to the associated issue.\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/drive.go\n@@ -4,6 +4,7 @@\n package ipnlocal\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"slices\"\n@@ -338,7 +339,7 @@ func (b *LocalBackend) driveRemotesFromPeers(nm *netmap.NetworkMap) []*drive.Rem\n \t\t\t\t// Check that the peer is allowed to share with us.\n \t\t\t\taddresses := peer.Addresses()\n \t\t\t\tfor _, p := range addresses.All() {\n-\t\t\t\t\tif cn.PeerHasCap(p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n+\t\t\t\t\tif cn.PeerHasCap(context.Background(), p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n---\nipn/ipnlocal/local.go\n@@ -96,6 +96,7 @@ import (\n \t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/util/clientmetric\"\n+\t\"tailscale.com/util/ctxkey\"\n \t\"tailscale.com/util/deephash\"\n \t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/goroutines\"\n@@ -1463,15 +1464,19 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+var nodeCtxLockedKey = ctxkey.New(\"localNodeContext-locked\", false)\n+\n+var ctxNodeContextLocked = nodeCtxLockedKey.WithValue(context.Background(), true)\n+\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(context.Context, tailcfg.NodeView) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tif pred(ctxNodeContextLocked, peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n@@ -6652,9 +6657,11 @@ func (b *LocalBackend) TestOnlyPublicKeys() (machineKey key.MachinePublic, nodeK\n \n // PeerHasCap reports whether the peer with the given Tailscale IP addresses\n // contains the given capability string, with any value(s).\n-func (b *localNodeContext) PeerHasCap(addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n-\tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n+func (b *localNodeContext) PeerHasCap(ctx context.Context, addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n+\tif !nodeCtxLockedKey.Value(ctx) {\n+\t\tb.mu.Lock()\n+\t\tdefer b.mu.Unlock()\n+\t}\n \treturn b.peerHasCapLocked(addr, wantCap)\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n+\tpeers := cn.AppendMatchingPeers(nil, func(ctx context.Context, p tailcfg.NodeView) bool {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n \t\tif self != p.User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(ctx, p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n@@ -241,7 +241,7 @@ func (b *LocalBackend) taildropTargetStatus(p tailcfg.NodeView) ipnstate.Taildro\n \t}\n \tif nm.User() != p.User() {\n \t\t// Different user must have the explicit file sharing target capability\n-\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(context.Background(), p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn ipnstate.TaildropTargetOwnedByOtherUser\n \t\t}\n---\n\n\n---\n\nChoice D:\nwgengine/magicsock/magicsock_linux.go\n@@ -66,10 +66,10 @@ var (\n \t\t// fragmented, and we don't want to handle reassembly.\n \t\tbpf.LoadAbsolute{Off: 6, Size: 2},\n \t\t// More Fragments bit set means this is part of a fragmented packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 7, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 8, SkipFalse: 0},\n \t\t// Non-zero fragment offset with MF=0 means this is the last\n \t\t// fragment of packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 6, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 7, SkipFalse: 0},\n \n \t\t// Load IP header length into X register.\n \t\tbpf.LoadMemShift{Off: 0},\n---\nwgengine/magicsock/magicsock_linux_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"net/netip\"\n \t\"testing\"\n \n+\t\"golang.org/x/net/bpf\"\n \t\"golang.org/x/sys/cpu\"\n \t\"golang.org/x/sys/unix\"\n \t\"tailscale.com/disco\"\n@@ -146,3 +147,78 @@ func TestEthernetProto(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestBpfDiscardV4(t *testing.T) {\n+\t// Good packet as a reference for what should not be rejected\n+\tudp4Packet := []byte{\n+\t\t// IPv4 header\n+\t\t0x45, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x40, 0x11, 0x00, 0x00,\n+\t\t0x7f, 0x00, 0x00, 0x01, // source ip\n+\t\t0x7f, 0x00, 0x00, 0x02, // dest ip\n+\n+\t\t// UDP header\n+\t\t0x30, 0x39, // src port\n+\t\t0xd4, 0x31, // dest port\n+\t\t0x00, 0x12, // length; 8 bytes header + 10 bytes payload = 18 bytes\n+\t\t0x00, 0x00, // checksum; unused\n+\n+\t\t// Payload: disco magic plus 32 bytes for key and 24 bytes for nonce\n+\t\t0x54, 0x53, 0xf0, 0x9f, 0x92, 0xac, 0x00, 0x01, 0x02, 0x03,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n+\t}\n+\n+\tvm, err := bpf.NewVM(magicsockFilterV4)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed creating BPF VM: %v\", err)\n+\t}\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\treplace map[int]byte\n+\t\taccept  bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"base accepted datagram\",\n+\t\t\treplace: map[int]byte{},\n+\t\t\taccept:  true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"more fragments\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t6: 0x20,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some fragment\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t7: 0x01,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t}\n+\n+\tudp4PacketChanged := make([]byte, len(udp4Packet))\n+\tcopy(udp4PacketChanged, udp4Packet)\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfor k, v := range tt.replace {\n+\t\t\t\tudp4PacketChanged[k] = v\n+\t\t\t}\n+\t\t\tret, err := vm.Run(udp4PacketChanged)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"BPF VM error: %v\", err)\n+\t\t\t}\n+\n+\t\t\tif (ret != 0) != tt.accept {\n+\t\t\t\tt.Errorf(\"expected accept=%v, got ret=%v\", tt.accept, ret)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n[2] commits\r\n\r\nIn this PR, we make the `user-dial-routes` nodeAttr behavior default on all platforms except for iOS and Android. It can be disabled by setting the `TS_DEBUG_DNS_FORWARD_USE_ROUTES` envknob to `0` or `false`.\r\n\r\nWe also update `(*net/tsdial.Dialer).SetRoutes()` to log the size of the resulting `bart.Table`.\r\n\r\nUpdates #12027\r\nUpdates #13837 \n\n---\n\nChoice A:\n.github/workflows/test.yml\n@@ -79,7 +79,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -157,7 +157,7 @@ jobs:\n         cache: false\n \n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -263,7 +263,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -333,7 +333,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -386,7 +386,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n---\n\n\n---\n\nChoice B:\ncmd/k8s-operator/depaware.txt\n@@ -840,7 +840,7 @@ tailscale.com/cmd/k8s-operator dependencies: (generated by github.com/tailscale/\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/cmd/k8s-operator+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\ncmd/tailscaled/depaware.txt\n@@ -318,7 +318,7 @@ tailscale.com/cmd/tailscaled dependencies: (generated by github.com/tailscale/de\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/cmd/tailscaled+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\nipn/ipnlocal/local.go\n@@ -64,6 +64,7 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4886,7 +4887,6 @@ func (b *LocalBackend) authReconfig() {\n \tnm := cn.NetMap()\n \thasPAC := b.prevIfState.HasPAC()\n \tdisableSubnetsIfPAC := cn.SelfHasCap(tailcfg.NodeAttrDisableSubnetsIfPAC)\n-\tuserDialUseRoutes := cn.SelfHasCap(tailcfg.NodeAttrUserDialUseRoutes)\n \tdohURL, dohURLOK := cn.exitNodeCanProxyDNS(prefs.ExitNodeID())\n \tdcfg := cn.dnsConfigForNetmap(prefs, b.keyExpired, b.logf, version.OS())\n \t// If the current node is an app connector, ensure the app connector machine is started\n@@ -4947,7 +4947,7 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif userDialUseRoutes {\n+\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n \t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n \t} else {\n \t\tb.dialer.SetRoutes(nil, nil)\n---\nnet/dns/resolver/forwarder.go\n@@ -17,6 +17,7 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"net/url\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n@@ -740,18 +741,35 @@ func (f *forwarder) sendUDP(ctx context.Context, fq *forwardQuery, rr resolverAn\n \treturn out, nil\n }\n \n+var optDNSForwardUseRoutes = envknob.RegisterOptBool(\"TS_DEBUG_DNS_FORWARD_USE_ROUTES\")\n+\n+// ShouldUseRoutes reports whether the DNS resolver should consider routes when dialing\n+// upstream nameservers via TCP.\n+//\n+// If true, routes should be considered ([tsdial.Dialer.UserDial]), otherwise defer\n+// to the system routes ([tsdial.Dialer.SystemDial]).\n+//\n+// TODO(nickkhyl): Update [tsdial.Dialer] to reuse the bart.Table we create in net/tstun.Wrapper\n+// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n+// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n+//\n+// See tailscale/tailscale#12027.\n+func ShouldUseRoutes(knobs *controlknobs.Knobs) bool {\n+\tswitch runtime.GOOS {\n+\tcase \"android\", \"ios\":\n+\t\t// On mobile platforms with lower memory limits (e.g., 50MB on iOS),\n+\t\t// this behavior is still gated by the \"user-dial-routes\" nodeAttr.\n+\t\treturn knobs != nil && knobs.UserDialUseRoutes.Load()\n+\tdefault:\n+\t\t// On all other platforms, it is the default behavior,\n+\t\t// but it can be overridden with the \"TS_DEBUG_DNS_FORWARD_USE_ROUTES\" env var.\n+\t\tdoNotUseRoutes := optDNSForwardUseRoutes().EqualBool(false)\n+\t\treturn !doNotUseRoutes\n+\t}\n+}\n+\n func (f *forwarder) getDialerType() netx.DialFunc {\n-\tif f.controlKnobs != nil && f.controlKnobs.UserDialUseRoutes.Load() {\n-\t\t// It is safe to use UserDial as it dials external servers without going through Tailscale\n-\t\t// and closes connections on interface change in the same way as SystemDial does,\n-\t\t// thus preventing DNS resolution issues when switching between WiFi and cellular,\n-\t\t// but can also dial an internal DNS server on the Tailnet or via a subnet router.\n-\t\t//\n-\t\t// TODO(nickkhyl): Update tsdial.Dialer to reuse the bart.Table we create in net/tstun.Wrapper\n-\t\t// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n-\t\t// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n-\t\t//\n-\t\t// See https://github.com/tailscale/tailscale/issues/12027.\n+\tif ShouldUseRoutes(f.controlKnobs) {\n \t\treturn f.dialer.UserDial\n \t}\n \treturn f.dialer.SystemDial\n---\nnet/tsdial/tsdial.go\n@@ -151,6 +151,7 @@ func (d *Dialer) SetRoutes(routes, localRoutes []netip.Prefix) {\n \t\tfor _, r := range localRoutes {\n \t\t\trt.Insert(r, false)\n \t\t}\n+\t\td.logf(\"tsdial: bart table size: %d\", rt.Size())\n \t}\n \n \td.routes.Store(rt)\n---\ntsnet/depaware.txt\n@@ -271,7 +271,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\n\n\n---\n\nChoice C:\n.github/workflows/test.yml\n@@ -305,7 +305,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: build some\n-      run: ./tool/go build ./ipn/... ./wgengine/ ./types/... ./control/controlclient\n+      run: ./tool/go build ./ipn/... ./ssh/tailssh ./wgengine/ ./types/... ./control/controlclient\n       env:\n         GOOS: ios\n         GOARCH: arm64\n@@ -375,7 +375,7 @@ jobs:\n       # some Android breakages early.\n       # TODO(bradfitz): better; see https://github.com/tailscale/tailscale/issues/4482\n     - name: build some\n-      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version\n+      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version ./ssh/tailssh\n       env:\n         GOOS: android\n         GOARCH: arm64\n---\nssh/tailssh/incubator.go\n@@ -7,7 +7,7 @@\n // and groups to the specified `--uid`, `--gid` and `--groups`, and\n // then launches the requested `--cmd`.\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd\n \n package tailssh\n \n---\nssh/tailssh/incubator_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package tailssh\n \n---\nssh/tailssh/tailssh.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n // Package tailssh is an SSH server integrated into Tailscale.\n package tailssh\n---\nssh/tailssh/user.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n package tailssh\n \n---\n\n\n---\n\nChoice D:\nwgengine/magicsock/magicsock_linux.go\n@@ -66,10 +66,10 @@ var (\n \t\t// fragmented, and we don't want to handle reassembly.\n \t\tbpf.LoadAbsolute{Off: 6, Size: 2},\n \t\t// More Fragments bit set means this is part of a fragmented packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 7, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 8, SkipFalse: 0},\n \t\t// Non-zero fragment offset with MF=0 means this is the last\n \t\t// fragment of packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 6, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 7, SkipFalse: 0},\n \n \t\t// Load IP header length into X register.\n \t\tbpf.LoadMemShift{Off: 0},\n---\nwgengine/magicsock/magicsock_linux_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"net/netip\"\n \t\"testing\"\n \n+\t\"golang.org/x/net/bpf\"\n \t\"golang.org/x/sys/cpu\"\n \t\"golang.org/x/sys/unix\"\n \t\"tailscale.com/disco\"\n@@ -146,3 +147,78 @@ func TestEthernetProto(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestBpfDiscardV4(t *testing.T) {\n+\t// Good packet as a reference for what should not be rejected\n+\tudp4Packet := []byte{\n+\t\t// IPv4 header\n+\t\t0x45, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x40, 0x11, 0x00, 0x00,\n+\t\t0x7f, 0x00, 0x00, 0x01, // source ip\n+\t\t0x7f, 0x00, 0x00, 0x02, // dest ip\n+\n+\t\t// UDP header\n+\t\t0x30, 0x39, // src port\n+\t\t0xd4, 0x31, // dest port\n+\t\t0x00, 0x12, // length; 8 bytes header + 10 bytes payload = 18 bytes\n+\t\t0x00, 0x00, // checksum; unused\n+\n+\t\t// Payload: disco magic plus 32 bytes for key and 24 bytes for nonce\n+\t\t0x54, 0x53, 0xf0, 0x9f, 0x92, 0xac, 0x00, 0x01, 0x02, 0x03,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n+\t}\n+\n+\tvm, err := bpf.NewVM(magicsockFilterV4)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed creating BPF VM: %v\", err)\n+\t}\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\treplace map[int]byte\n+\t\taccept  bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"base accepted datagram\",\n+\t\t\treplace: map[int]byte{},\n+\t\t\taccept:  true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"more fragments\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t6: 0x20,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some fragment\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t7: 0x01,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t}\n+\n+\tudp4PacketChanged := make([]byte, len(udp4Packet))\n+\tcopy(udp4PacketChanged, udp4Packet)\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfor k, v := range tt.replace {\n+\t\t\t\tudp4PacketChanged[k] = v\n+\t\t\t}\n+\t\t\tret, err := vm.Run(udp4PacketChanged)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"BPF VM error: %v\", err)\n+\t\t\t}\n+\n+\t\t\tif (ret != 0) != tt.accept {\n+\t\t\t\tt.Errorf(\"expected accept=%v, got ret=%v\", tt.accept, ret)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n`cmd/derpprobe --once` didn\u2019t respect the convention of non-zero exit status for a failed run. It would always exit zero (i.e. success), even. This patch fixes that, but only for `--once` mode.\r\n\r\nFixes: #15925\n\n---\n\nChoice A:\nnet/portmapper/igd_test.go\n@@ -18,8 +18,10 @@ import (\n \t\"tailscale.com/net/netaddr\"\n \t\"tailscale.com/net/netmon\"\n \t\"tailscale.com/syncs\"\n+\t\"tailscale.com/tstest\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/eventbus\"\n+\t\"tailscale.com/util/testenv\"\n )\n \n // TestIGD is an IGD (Internet Gateway Device) for testing. It supports fake\n@@ -64,7 +66,8 @@ type igdCounters struct {\n \tinvalidPCPMapPkt int32\n }\n \n-func NewTestIGD(logf logger.Logf, t TestIGDOptions) (*TestIGD, error) {\n+func NewTestIGD(tb testenv.TB, t TestIGDOptions) (*TestIGD, error) {\n+\tlogf := tstest.WhileTestRunningLogger(tb)\n \td := &TestIGD{\n \t\tdoPMP:  t.PMP,\n \t\tdoPCP:  t.PCP,\n@@ -265,7 +268,7 @@ func (d *TestIGD) handlePCPQuery(pkt []byte, src netip.AddrPort) {\n func newTestClient(t *testing.T, igd *TestIGD, bus *eventbus.Bus) *Client {\n \tvar c *Client\n \tc = NewClient(Config{\n-\t\tLogf:         t.Logf,\n+\t\tLogf:         tstest.WhileTestRunningLogger(t),\n \t\tNetMon:       netmon.NewStatic(),\n \t\tControlKnobs: new(controlknobs.Knobs),\n \t\tEventBus:     bus,\n---\nnet/portmapper/portmapper_test.go\n@@ -61,7 +61,7 @@ func TestClientProbeThenMap(t *testing.T) {\n }\n \n func TestProbeIntegration(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PMP: true, PCP: true, UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PMP: true, PCP: true, UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -95,7 +95,7 @@ func TestProbeIntegration(t *testing.T) {\n }\n \n func TestPCPIntegration(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PMP: false, PCP: true, UPnP: false})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PMP: false, PCP: true, UPnP: false})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -137,7 +137,7 @@ func TestGetUPnPErrorsMetric(t *testing.T) {\n }\n \n func TestUpdateEvent(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PCP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PCP: true})\n \tif err != nil {\n \t\tt.Fatalf(\"Create test gateway: %v\", err)\n \t}\n---\nnet/portmapper/select_test.go\n@@ -28,7 +28,7 @@ func TestSelectBestService(t *testing.T) {\n \t}\n \n \t// Run a fake IGD server to respond to UPnP requests.\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/portmapper/upnp_test.go\n@@ -533,7 +533,7 @@ func TestGetUPnPClient(t *testing.T) {\n }\n \n func TestGetUPnPPortMapping(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -672,7 +672,7 @@ func TestGetUPnPPortMapping_LeaseDuration(t *testing.T) {\n \t\t\t\t\"DeletePortMapping\":    \"\", // Do nothing for test\n \t\t\t}\n \n-\t\t\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\t\t\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n@@ -722,7 +722,7 @@ func TestGetUPnPPortMapping_LeaseDuration(t *testing.T) {\n //\n // See https://github.com/tailscale/tailscale/issues/10911\n func TestGetUPnPPortMapping_NoValidServices(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -753,7 +753,7 @@ func TestGetUPnPPortMapping_NoValidServices(t *testing.T) {\n \n // Tests the legacy behaviour with the pre-UPnP standard portmapping service.\n func TestGetUPnPPortMapping_Legacy(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -796,7 +796,7 @@ func TestGetUPnPPortMapping_Legacy(t *testing.T) {\n }\n \n func TestGetUPnPPortMappingNoResponses(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -912,7 +912,7 @@ func TestGetUPnPPortMapping_Invalid(t *testing.T) {\n \t\t\"127.0.0.1\",\n \t} {\n \t\tt.Run(responseAddr, func(t *testing.T) {\n-\t\t\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\t\t\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n---\ntstest/log.go\n@@ -13,6 +13,7 @@ import (\n \n \t\"go4.org/mem\"\n \t\"tailscale.com/types/logger\"\n+\t\"tailscale.com/util/testenv\"\n )\n \n type testLogWriter struct {\n@@ -149,7 +150,7 @@ func (ml *MemLogger) String() string {\n \n // WhileTestRunningLogger returns a logger.Logf that logs to t.Logf until the\n // test finishes, at which point it no longer logs anything.\n-func WhileTestRunningLogger(t testing.TB) logger.Logf {\n+func WhileTestRunningLogger(t testenv.TB) logger.Logf {\n \tvar (\n \t\tmu   sync.RWMutex\n \t\tdone bool\n---\n\n\n---\n\nChoice B:\n.github/workflows/codeql-analysis.yml\n@@ -49,7 +49,7 @@ jobs:\n \n     # Install a more recent Go that understands modern go.mod content.\n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n \n---\n.github/workflows/golangci-lint.yml\n@@ -25,7 +25,7 @@ jobs:\n     steps:\n       - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n-      - uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      - uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n         with:\n           go-version-file: go.mod\n           cache: false\n---\n.github/workflows/test.yml\n@@ -151,7 +151,7 @@ jobs:\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n         cache: false\n---\n\n\n---\n\nChoice C:\nsafesocket/safesocket.go\n@@ -61,7 +61,11 @@ func ConnectContext(ctx context.Context, path string) (net.Conn, error) {\n \t\t\tif ctx.Err() != nil {\n \t\t\t\treturn nil, ctx.Err()\n \t\t\t}\n-\t\t\ttime.Sleep(250 * time.Millisecond)\n+\t\t\tselect {\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\treturn nil, ctx.Err()\n+\t\t\tcase <-time.After(250 * time.Millisecond):\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\treturn c, err\n---\n\n\n---\n\nChoice D:\ncmd/derpprobe/derpprobe.go\n@@ -9,6 +9,7 @@ import (\n \t\"fmt\"\n \t\"log\"\n \t\"net/http\"\n+\t\"os\"\n \t\"sort\"\n \t\"time\"\n \n@@ -75,6 +76,9 @@ func main() {\n \t\tfor _, s := range st.bad {\n \t\t\tlog.Printf(\"bad: %s\", s)\n \t\t}\n+\t\tif len(st.bad) > 0 {\n+\t\t\tos.Exit(1)\n+\t\t}\n \t\treturn\n \t}\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nSo tsnet-on-Android is smaller, like iOS.\r\n\r\nUpdates #12614\r\nUpdates #15297\r\n\n\n---\n\nChoice A:\nipn/ipnlocal/extension_host_test.go\n@@ -284,7 +284,7 @@ func TestNewExtensionHost(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tt.Parallel()\n \t\t\tlogf := tstest.WhileTestRunningLogger(t)\n-\t\t\th, err := NewExtensionHost(logf, &tsd.System{}, &testBackend{}, tt.defs...)\n+\t\t\th, err := NewExtensionHost(logf, tsd.NewSystem(), &testBackend{}, tt.defs...)\n \t\t\tif gotErr := err != nil; gotErr != tt.wantErr {\n \t\t\t\tt.Errorf(\"NewExtensionHost: gotErr %v(%v); wantErr %v\", gotErr, err, tt.wantErr)\n \t\t\t}\n@@ -1118,7 +1118,7 @@ func newExtensionHostForTest[T ipnext.Extension](t *testing.T, b Backend, initia\n \t\t}\n \t\tdefs[i] = ipnext.DefinitionForTest(ext)\n \t}\n-\th, err := NewExtensionHost(logf, &tsd.System{}, b, defs...)\n+\th, err := NewExtensionHost(logf, tsd.NewSystem(), b, defs...)\n \tif err != nil {\n \t\tt.Fatalf(\"NewExtensionHost: %v\", err)\n \t}\n---\nipn/ipnlocal/state_test.go\n@@ -1397,7 +1397,7 @@ func newLocalBackendWithMockEngineAndControl(t *testing.T, enableLogging bool) (\n \tdialer := &tsdial.Dialer{Logf: logf}\n \tdialer.SetNetMon(netmon.NewStatic())\n \n-\tsys := &tsd.System{}\n+\tsys := tsd.NewSystem()\n \tsys.Set(dialer)\n \tsys.Set(dialer.NetMon())\n \n---\n\n\n---\n\nChoice B:\ntsnet/depaware.txt\n@@ -80,10 +80,10 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n    L    github.com/aws/smithy-go/transport/http                      from github.com/aws/aws-sdk-go-v2/aws/middleware+\n    L    github.com/aws/smithy-go/transport/http/internal/io          from github.com/aws/smithy-go/transport/http\n    L    github.com/aws/smithy-go/waiter                              from github.com/aws/aws-sdk-go-v2/service/ssm\n- LDWA    github.com/coder/websocket                                   from tailscale.com/util/eventbus\n- LDWA    github.com/coder/websocket/internal/errd                     from github.com/coder/websocket\n- LDWA    github.com/coder/websocket/internal/util                     from github.com/coder/websocket\n- LDWA    github.com/coder/websocket/internal/xsync                    from github.com/coder/websocket\n+ LDW    github.com/coder/websocket                                   from tailscale.com/util/eventbus\n+ LDW    github.com/coder/websocket/internal/errd                     from github.com/coder/websocket\n+ LDW    github.com/coder/websocket/internal/util                     from github.com/coder/websocket\n+ LDW    github.com/coder/websocket/internal/xsync                    from github.com/coder/websocket\n    L    github.com/coreos/go-iptables/iptables                       from tailscale.com/util/linuxfw\n    W \ud83d\udca3 github.com/dblohm7/wingoes                                   from github.com/dblohm7/wingoes/com+\n    W \ud83d\udca3 github.com/dblohm7/wingoes/com                               from tailscale.com/util/osdiag+\n@@ -552,7 +552,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         hash/crc32                                                   from compress/gzip+\n         hash/maphash                                                 from go4.org/mem\n         html                                                         from html/template+\n- LDWA    html/template                                                from github.com/gorilla/csrf+\n+ LDW    html/template                                                from github.com/gorilla/csrf+\n         internal/abi                                                 from crypto/x509/internal/macos+\n         internal/asan                                                from internal/runtime/maps+\n         internal/bisect                                              from internal/godebug\n@@ -639,8 +639,8 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         sync/atomic                                                  from context+\n         syscall                                                      from archive/tar+\n         text/tabwriter                                               from runtime/pprof\n- LDWA    text/template                                                from html/template\n- LDWA    text/template/parse                                          from html/template+\n+ LDW    text/template                                                from html/template\n+ LDW    text/template/parse                                          from html/template+\n         time                                                         from archive/tar+\n         unicode                                                      from bytes+\n         unicode/utf16                                                from crypto/x509+\n---\nutil/eventbus/debughttp.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !ios\n+//go:build !ios && !android\n \n package eventbus\n \n---\nutil/eventbus/debughttp_off.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build ios\n+//go:build ios || android\n \n package eventbus\n \n@@ -12,6 +12,8 @@ func registerHTTPDebugger(d *Debugger, td *tsweb.DebugHandler) {\n \t// reflection for method lookups. This forces the compiler to\n \t// retain a lot more code and information to make dynamic method\n \t// dispatch work, which is unacceptable bloat for the iOS build.\n+\t// We also disable it on Android while we're at it, as nobody\n+\t// is debugging Tailscale internals on Android.\n \t//\n \t// TODO: https://github.com/tailscale/tailscale/issues/15297 to\n \t// bring the debug UI back to iOS somehow.\n---\n\n\n---\n\nChoice C:\nipn/auditlog/extension.go\n@@ -22,7 +22,7 @@ import (\n )\n \n // featureName is the name of the feature implemented by this package.\n-// It is also the the [extension] name and the log prefix.\n+// It is also the [extension] name and the log prefix.\n const featureName = \"auditlog\"\n \n func init() {\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -5302,9 +5302,11 @@ func (b *LocalBackend) closePeerAPIListenersLocked() {\n const peerAPIListenAsync = runtime.GOOS == \"windows\" || runtime.GOOS == \"android\"\n \n func (b *LocalBackend) initPeerAPIListener() {\n+\tb.logf(\"[v1] initPeerAPIListener: entered\")\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tif b.shutdownCalled {\n+\t\tb.logf(\"[v1] initPeerAPIListener: shutting down\")\n \t\treturn\n \t}\n \n@@ -5314,6 +5316,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t// ResetForClientDisconnect, or Start happens when its\n \t\t// mutex was released, the netMap could be\n \t\t// nil'ed out (Issue 1996). Bail out early here if so.\n+\t\tb.logf(\"[v1] initPeerAPIListener: no netmap\")\n \t\treturn\n \t}\n \n@@ -5328,6 +5331,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t}\n \t\tif allSame {\n \t\t\t// Nothing to do.\n+\t\t\tb.logf(\"[v1] initPeerAPIListener: %d netmap addresses match existing listeners\", addrs.Len())\n \t\t\treturn\n \t\t}\n \t}\n@@ -5336,6 +5340,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \n \tselfNode := b.netMap.SelfNode\n \tif !selfNode.Valid() || b.netMap.GetAddresses().Len() == 0 {\n+\t\tb.logf(\"[v1] initPeerAPIListener: no addresses in netmap\")\n \t\treturn\n \t}\n \n@@ -5369,7 +5374,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n-\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n+\t\t\t\t\tb.logf(\"[v1] possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #12614\n\n\n---\n\nChoice A:\nssh/tailssh/tailssh_test.go\n@@ -16,7 +16,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"log\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n@@ -48,7 +47,6 @@ import (\n \t\"tailscale.com/tsd\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/types/key\"\n-\t\"tailscale.com/types/logger\"\n \t\"tailscale.com/types/logid\"\n \t\"tailscale.com/types/netmap\"\n \t\"tailscale.com/types/ptr\"\n@@ -230,7 +228,7 @@ func TestMatchRule(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tc := &conn{\n \t\t\t\tinfo: tt.ci,\n-\t\t\t\tsrv:  &server{logf: t.Logf},\n+\t\t\t\tsrv:  &server{logf: tstest.WhileTestRunningLogger(t)},\n \t\t\t}\n \t\t\tgot, gotUser, gotAcceptEnv, err := c.matchRule(tt.rule)\n \t\t\tif err != tt.wantErr {\n@@ -349,7 +347,7 @@ func TestEvalSSHPolicy(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tc := &conn{\n \t\t\t\tinfo: tt.ci,\n-\t\t\t\tsrv:  &server{logf: t.Logf},\n+\t\t\t\tsrv:  &server{logf: tstest.WhileTestRunningLogger(t)},\n \t\t\t}\n \t\t\tgot, gotUser, gotAcceptEnv, match := c.evalSSHPolicy(tt.policy)\n \t\t\tif match != tt.wantMatch {\n@@ -491,7 +489,7 @@ func TestSSHRecordingCancelsSessionsOnUploadFailure(t *testing.T) {\n \t})\n \n \ts := &server{\n-\t\tlogf: t.Logf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t\tlb: &localState{\n \t\t\tsshEnabled: true,\n \t\t\tmatchingRule: newSSHRule(\n@@ -553,7 +551,7 @@ func TestSSHRecordingCancelsSessionsOnUploadFailure(t *testing.T) {\n \n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n-\t\t\ts.logf = t.Logf\n+\t\t\ts.logf = tstest.WhileTestRunningLogger(t)\n \t\t\ttstest.Replace(t, &handler, tt.handler)\n \t\t\tsc, dc := memnet.NewTCPConn(src, dst, 1024)\n \t\t\tvar wg sync.WaitGroup\n@@ -621,7 +619,7 @@ func TestMultipleRecorders(t *testing.T) {\n \t})\n \n \ts := &server{\n-\t\tlogf: t.Logf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t\tlb: &localState{\n \t\t\tsshEnabled: true,\n \t\t\tmatchingRule: newSSHRule(\n@@ -714,7 +712,7 @@ func TestSSHRecordingNonInteractive(t *testing.T) {\n \t})\n \n \ts := &server{\n-\t\tlogf: t.Logf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t\tlb: &localState{\n \t\t\tsshEnabled: true,\n \t\t\tmatchingRule: newSSHRule(\n@@ -887,13 +885,15 @@ func TestSSHAuthFlow(t *testing.T) {\n \t\t},\n \t}\n \ts := &server{\n-\t\tlogf: log.Printf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t}\n \tdefer s.Shutdown()\n \tsrc, dst := must.Get(netip.ParseAddrPort(\"100.100.100.101:2231\")), must.Get(netip.ParseAddrPort(\"100.100.100.102:22\"))\n \tfor _, tc := range tests {\n \t\tfor _, authMethods := range [][]string{nil, {\"publickey\", \"password\"}, {\"password\", \"publickey\"}} {\n \t\t\tt.Run(fmt.Sprintf(\"%s-skip-none-auth-%v\", tc.name, strings.Join(authMethods, \"-then-\")), func(t *testing.T) {\n+\t\t\t\ts.logf = tstest.WhileTestRunningLogger(t)\n+\n \t\t\t\tsc, dc := memnet.NewTCPConn(src, dst, 1024)\n \t\t\t\ts.lb = tc.state\n \t\t\t\tsshUser := \"alice\"\n@@ -1036,7 +1036,7 @@ func TestSSHAuthFlow(t *testing.T) {\n }\n \n func TestSSH(t *testing.T) {\n-\tvar logf logger.Logf = t.Logf\n+\tlogf := tstest.WhileTestRunningLogger(t)\n \tsys := tsd.NewSystem()\n \teng, err := wgengine.NewFakeUserspaceEngine(logf, sys.Set, sys.HealthTracker(), sys.UserMetricsRegistry(), sys.Bus.Get())\n \tif err != nil {\n---\n\n\n---\n\nChoice B:\ntsnet/depaware.txt\n@@ -132,7 +132,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n    L \ud83d\udca3 github.com/mdlayher/netlink                                  from github.com/google/nftables+\n    L \ud83d\udca3 github.com/mdlayher/netlink/nlenc                            from github.com/jsimonetti/rtnetlink+\n    L    github.com/mdlayher/netlink/nltest                           from github.com/google/nftables\n-  LA    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n+   L    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n   LA \ud83d\udca3 github.com/mdlayher/socket                                   from github.com/mdlayher/netlink+\n         github.com/miekg/dns                                         from tailscale.com/net/dns/recursive\n  LDWA \ud83d\udca3 github.com/mitchellh/go-ps                                   from tailscale.com/safesocket\n---\nutil/systemd/systemd_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package systemd\n \n---\nutil/systemd/systemd_nonlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux || android\n \n package systemd\n \n---\n\n\n---\n\nChoice C:\nprober/prober_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n+\t\"net/http\"\n \t\"net/http/httptest\"\n \t\"strings\"\n \t\"sync\"\n@@ -586,30 +587,48 @@ func TestProberRunHandler(t *testing.T) {\n \t\t\t\tdefer probe.Close()\n \t\t\t\t<-probe.stopped // wait for the first run.\n \n-\t\t\t\tw := httptest.NewRecorder()\n+\t\t\t\tmux := http.NewServeMux()\n+\t\t\t\tserver := httptest.NewServer(mux)\n+\t\t\t\tdefer server.Close()\n+\n+\t\t\t\tmux.Handle(\"/prober/run/\", tsweb.StdHandler(tsweb.ReturnHandlerFunc(p.RunHandler), tsweb.HandlerOptions{}))\n+\n+\t\t\t\treq, err := http.NewRequest(\"GET\", server.URL+\"/prober/run/?name=\"+tt.name, nil)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"failed to create request: %v\", err)\n+\t\t\t\t}\n \n-\t\t\t\treq := httptest.NewRequest(\"GET\", \"/prober/run/?name=\"+tt.name, nil)\n \t\t\t\tif reqJSON {\n \t\t\t\t\treq.Header.Set(\"Accept\", \"application/json\")\n \t\t\t\t}\n-\t\t\t\ttsweb.StdHandler(tsweb.ReturnHandlerFunc(p.RunHandler), tsweb.HandlerOptions{}).ServeHTTP(w, req)\n-\t\t\t\tif w.Result().StatusCode != tt.wantResponseCode {\n-\t\t\t\t\tt.Errorf(\"unexpected response code: got %d, want %d\", w.Code, tt.wantResponseCode)\n+\n+\t\t\t\tresp, err := http.DefaultClient.Do(req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"failed to make request: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif resp.StatusCode != tt.wantResponseCode {\n+\t\t\t\t\tt.Errorf(\"unexpected response code: got %d, want %d\", resp.StatusCode, tt.wantResponseCode)\n \t\t\t\t}\n \n \t\t\t\tif reqJSON {\n-\t\t\t\t\tif w.Header().Get(\"Content-Type\") != \"application/json\" {\n-\t\t\t\t\t\tt.Errorf(\"unexpected content type: got %q, want application/json\", w.Header().Get(\"Content-Type\"))\n+\t\t\t\t\tif resp.Header.Get(\"Content-Type\") != \"application/json\" {\n+\t\t\t\t\t\tt.Errorf(\"unexpected content type: got %q, want application/json\", resp.Header.Get(\"Content-Type\"))\n \t\t\t\t\t}\n \t\t\t\t\tvar gotJSON RunHandlerResponse\n-\t\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), &gotJSON); err != nil {\n-\t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, w.Body.String())\n+\t\t\t\t\tbody, err := io.ReadAll(resp.Body)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tt.Fatalf(\"failed to read response body: %v\", err)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif err := json.Unmarshal(body, &gotJSON); err != nil {\n+\t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, body)\n \t\t\t\t\t}\n \t\t\t\t\tif diff := cmp.Diff(tt.wantJSONResponse, gotJSON, cmpopts.IgnoreFields(ProbeInfo{}, \"Start\", \"End\", \"Labels\", \"RecentLatencies\")); diff != \"\" {\n \t\t\t\t\t\tt.Errorf(\"unexpected JSON response (-want +got):\\n%s\", diff)\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tbody, _ := io.ReadAll(w.Result().Body)\n+\t\t\t\t\tbody, _ := io.ReadAll(resp.Body)\n \t\t\t\t\tif !strings.Contains(string(body), tt.wantPlaintextResponse) {\n \t\t\t\t\t\tt.Errorf(\"unexpected response body: got %q, want to contain %q\", body, tt.wantPlaintextResponse)\n \t\t\t\t\t}\n---\n\n\n---\n\nChoice D:\nnet/dns/config.go\n@@ -10,6 +10,8 @@ import (\n \t\"net/netip\"\n \t\"sort\"\n \n+\t\"tailscale.com/control/controlknobs\"\n+\t\"tailscale.com/envknob\"\n \t\"tailscale.com/net/dns/publicdns\"\n \t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/tsaddr\"\n@@ -47,11 +49,28 @@ type Config struct {\n \tOnlyIPv6 bool\n }\n \n-func (c *Config) serviceIP() netip.Addr {\n+var magicDNSDualStack = envknob.RegisterBool(\"TS_DEBUG_MAGIC_DNS_DUAL_STACK\")\n+\n+// serviceIPs returns the list of service IPs where MagicDNS is reachable.\n+//\n+// The provided knobs may be nil.\n+func (c *Config) serviceIPs(knobs *controlknobs.Knobs) []netip.Addr {\n \tif c.OnlyIPv6 {\n-\t\treturn tsaddr.TailscaleServiceIPv6()\n+\t\treturn []netip.Addr{tsaddr.TailscaleServiceIPv6()}\n \t}\n-\treturn tsaddr.TailscaleServiceIP()\n+\n+\t// TODO(bradfitz,mikeodr,raggi): include IPv6 here too; tailscale/tailscale#15404\n+\t// And add a controlknobs knob to disable dual stack.\n+\t//\n+\t// For now, opt-in for testing.\n+\tif magicDNSDualStack() {\n+\t\treturn []netip.Addr{\n+\t\t\ttsaddr.TailscaleServiceIP(),\n+\t\t\ttsaddr.TailscaleServiceIPv6(),\n+\t\t}\n+\t}\n+\n+\treturn []netip.Addr{tsaddr.TailscaleServiceIP()}\n }\n \n // WriteToBufioWriter write a debug version of c for logs to w, omitting\n---\nnet/dns/manager.go\n@@ -307,7 +307,7 @@ func (m *Manager) compileConfig(cfg Config) (rcfg resolver.Config, ocfg OSConfig\n \t\t// through quad-100.\n \t\trcfg.Routes = routes\n \t\trcfg.Routes[\".\"] = cfg.DefaultResolvers\n-\t\tocfg.Nameservers = []netip.Addr{cfg.serviceIP()}\n+\t\tocfg.Nameservers = cfg.serviceIPs(m.knobs)\n \t\treturn rcfg, ocfg, nil\n \t}\n \n@@ -345,7 +345,7 @@ func (m *Manager) compileConfig(cfg Config) (rcfg resolver.Config, ocfg OSConfig\n \t// or routes + MagicDNS, or just MagicDNS, or on an OS that cannot\n \t// split-DNS. Install a split config pointing at quad-100.\n \trcfg.Routes = routes\n-\tocfg.Nameservers = []netip.Addr{cfg.serviceIP()}\n+\tocfg.Nameservers = cfg.serviceIPs(m.knobs)\n \n \tvar baseCfg *OSConfig // base config; non-nil if/when known\n \n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAndroid is Linux, but doesn't use Linux DNS managers (or D-Bus).\n\nUpdates #12614\n\n\n---\n\nChoice A:\nipn/ipnlocal/serve.go\n@@ -632,7 +632,7 @@ func (b *LocalBackend) getServeHandler(r *http.Request) (_ ipn.HTTPHandlerView,\n \n \thostname := r.Host\n \tif r.TLS == nil {\n-\t\ttcd := \".\" + b.Status().CurrentTailnet.MagicDNSSuffix\n+\t\ttcd := \".\" + b.CurrentProfile().NetworkProfile().MagicDNSName\n \t\tif host, _, err := net.SplitHostPort(hostname); err == nil {\n \t\t\thostname = host\n \t\t}\n---\n\n\n---\n\nChoice B:\nnet/dns/debian_resolvconf.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || freebsd || openbsd\n+//go:build (linux && !android) || freebsd || openbsd\n \n package dns\n \n---\nnet/dns/direct.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android && !ios\n+\n package dns\n \n import (\n---\nnet/dns/direct_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build linux && !android\n+\n package dns\n \n import (\n---\nnet/dns/direct_notlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux && !android && !ios\n \n package dns\n \n---\nnet/dns/manager_default.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux && !freebsd && !openbsd && !windows && !darwin && !illumos && !solaris && !plan9\n+//go:build (!linux || android) && !freebsd && !openbsd && !windows && !darwin && !illumos && !solaris && !plan9\n \n package dns\n \n---\nnet/dns/manager_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build linux && !android\n+\n package dns\n \n import (\n---\nnet/dns/nm.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package dns\n \n---\nnet/dns/openresolv.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || freebsd || openbsd\n+//go:build (linux && !android) || freebsd || openbsd\n \n package dns\n \n---\nnet/dns/resolved.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package dns\n \n---\ntsnet/depaware.txt\n@@ -103,7 +103,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         github.com/go-json-experiment/json/jsontext                  from github.com/go-json-experiment/json+\n    W \ud83d\udca3 github.com/go-ole/go-ole                                     from github.com/go-ole/go-ole/oleutil+\n    W \ud83d\udca3 github.com/go-ole/go-ole/oleutil                             from tailscale.com/wgengine/winnet\n-  LA \ud83d\udca3 github.com/godbus/dbus/v5                                    from tailscale.com/net/dns\n+   L \ud83d\udca3 github.com/godbus/dbus/v5                                    from tailscale.com/net/dns\n         github.com/golang/groupcache/lru                             from tailscale.com/net/dnscache\n         github.com/google/btree                                      from gvisor.dev/gvisor/pkg/tcpip/header+\n    L    github.com/google/nftables                                   from tailscale.com/util/linuxfw\n@@ -116,8 +116,8 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n  LDW    github.com/gorilla/csrf                                      from tailscale.com/client/web\n  LDW    github.com/gorilla/securecookie                              from github.com/gorilla/csrf\n         github.com/hdevalence/ed25519consensus                       from tailscale.com/clientupdate/distsign+\n-  LA \ud83d\udca3 github.com/illarion/gonotify/v3                              from tailscale.com/net/dns\n-  LA    github.com/illarion/gonotify/v3/syscallf                     from github.com/illarion/gonotify/v3\n+   L \ud83d\udca3 github.com/illarion/gonotify/v3                              from tailscale.com/net/dns\n+   L    github.com/illarion/gonotify/v3/syscallf                     from github.com/illarion/gonotify/v3\n    L    github.com/jmespath/go-jmespath                              from github.com/aws/aws-sdk-go-v2/service/ssm\n    L \ud83d\udca3 github.com/jsimonetti/rtnetlink                              from tailscale.com/net/netmon\n    L    github.com/jsimonetti/rtnetlink/internal/unix                from github.com/jsimonetti/rtnetlink\n---\n\n\n---\n\nChoice C:\ncmd/tsidp/tsidp.go\n@@ -795,7 +795,7 @@ type oidcTokenResponse struct {\n \tIDToken      string `json:\"id_token\"`\n \tTokenType    string `json:\"token_type\"`\n \tAccessToken  string `json:\"access_token\"`\n-\tRefreshToken string `json:\"refresh_token\"`\n+\tRefreshToken string `json:\"refresh_token,omitempty\"`\n \tExpiresIn    int    `json:\"expires_in\"`\n }\n \n---\n\n\n---\n\nChoice D:\ncmd/tailscaled/tailscaled.go\n@@ -151,10 +151,33 @@ var subCommands = map[string]*func([]string) error{\n \t\"serve-taildrive\":         &serveDriveFunc,\n }\n \n-var beCLI func() // non-nil if CLI is linked in\n+var beCLI func() // non-nil if CLI is linked in with the \"ts_include_cli\" build tag\n+\n+// shouldRunCLI reports whether we should run the Tailscale CLI (cmd/tailscale)\n+// instead of the daemon (cmd/tailscaled) in the case when the two are linked\n+// together into one binary for space savings reasons.\n+func shouldRunCLI() bool {\n+\tif beCLI == nil {\n+\t\t// Not linked in with the \"ts_include_cli\" build tag.\n+\t\treturn false\n+\t}\n+\tif len(os.Args) > 0 && filepath.Base(os.Args[0]) == \"tailscale\" {\n+\t\t// The binary was named (or hardlinked) as \"tailscale\".\n+\t\treturn true\n+\t}\n+\tif envknob.Bool(\"TS_BE_CLI\") {\n+\t\t// The environment variable was set to force it.\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n \n func main() {\n \tenvknob.PanicIfAnyEnvCheckedInInit()\n+\tif shouldRunCLI() {\n+\t\tbeCLI()\n+\t\treturn\n+\t}\n \tenvknob.ApplyDiskConfig()\n \tapplyIntegrationTestEnvKnob()\n \n@@ -175,11 +198,6 @@ func main() {\n \tflag.BoolVar(&args.disableLogs, \"no-logs-no-support\", false, \"disable log uploads; this also disables any technical support\")\n \tflag.StringVar(&args.confFile, \"config\", \"\", \"path to config file, or 'vm:user-data' to use the VM's user-data (EC2)\")\n \n-\tif len(os.Args) > 0 && filepath.Base(os.Args[0]) == \"tailscale\" && beCLI != nil {\n-\t\tbeCLI()\n-\t\treturn\n-\t}\n-\n \tif len(os.Args) > 1 {\n \t\tsub := os.Args[1]\n \t\tif fp, ok := subCommands[sub]; ok {\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes #15907\n\n---\n\nChoice A:\ngo.mod\n@@ -272,7 +272,7 @@ require (\n \tgithub.com/gordonklaus/ineffassign v0.1.0 // indirect\n \tgithub.com/goreleaser/chglog v0.5.0 // indirect\n \tgithub.com/goreleaser/fileglob v1.3.0 // indirect\n-\tgithub.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30\n+\tgithub.com/gorilla/csrf v1.7.3\n \tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n \tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n \tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n---\ngo.sum\n@@ -524,8 +524,8 @@ github.com/goreleaser/fileglob v1.3.0 h1:/X6J7U8lbDpQtBvGcwwPS6OpzkNVlVEsFUVRx9+\n github.com/goreleaser/fileglob v1.3.0/go.mod h1:Jx6BoXv3mbYkEzwm9THo7xbr5egkAraxkGorbJb4RxU=\n github.com/goreleaser/nfpm/v2 v2.33.1 h1:EkdAzZyVhAI9JC1vjmjjbmnNzyH1J6Cu4JCsA7YcQuc=\n github.com/goreleaser/nfpm/v2 v2.33.1/go.mod h1:8wwWWvJWmn84xo/Sqiv0aMvEGTHlHZTXTEuVSgQpkIM=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30 h1:fiJdrgVBkjZ5B1HJ2WQwNOaXB+QyYcNXTA3t1XYLz0M=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n+github.com/gorilla/csrf v1.7.3 h1:BHWt6FTLZAb2HtWT5KDBf6qgpZzvtbp9QWDRKZMXJC0=\n+github.com/gorilla/csrf v1.7.3/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n github.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\n github.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\n github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=\n---\n\n\n---\n\nChoice B:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n---\n\n\n---\n\nChoice C:\ncmd/natc/ippool/ippool.go\n@@ -24,7 +24,6 @@ var ErrNoIPsAvailable = errors.New(\"no IPs available\")\n type IPPool struct {\n \tperPeerMap syncs.Map[tailcfg.NodeID, *perPeerState]\n \tIPSet      *netipx.IPSet\n-\tV6ULA      netip.Prefix\n }\n \n func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bool) {\n@@ -44,15 +43,13 @@ func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bo\n func (ipp *IPPool) IPForDomain(from tailcfg.NodeID, domain string) (netip.Addr, error) {\n \tnpps := &perPeerState{\n \t\tipset: ipp.IPSet,\n-\t\tv6ULA: ipp.V6ULA,\n \t}\n \tps, _ := ipp.perPeerMap.LoadOrStore(from, npps)\n \treturn ps.ipForDomain(domain)\n }\n \n // perPeerState holds the state for a single peer.\n type perPeerState struct {\n-\tv6ULA netip.Prefix\n \tipset *netipx.IPSet\n \n \tmu           sync.Mutex\n---\ncmd/natc/ippool/ippool_test.go\n@@ -19,8 +19,7 @@ func TestIPPoolExhaustion(t *testing.T) {\n \tvar ipsb netipx.IPSetBuilder\n \tipsb.AddPrefix(smallPrefix)\n \taddrPool := must.Get(ipsb.IPSet())\n-\tv6ULA := netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\")\n-\tpool := IPPool{V6ULA: v6ULA, IPSet: addrPool}\n+\tpool := IPPool{IPSet: addrPool}\n \n \tassignedIPs := make(map[netip.Addr]string)\n \n@@ -52,9 +51,6 @@ func TestIPPoolExhaustion(t *testing.T) {\n \t\tif addr.Is4() && !smallPrefix.Contains(addr) {\n \t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, smallPrefix)\n \t\t}\n-\t\tif addr.Is6() && !v6ULA.Contains(addr) {\n-\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, v6ULA)\n-\t\t}\n \t}\n \n \t// expect one error for each iteration with the 5th domain\n@@ -73,7 +69,6 @@ func TestIPPool(t *testing.T) {\n \tipsb.AddPrefix(netip.MustParsePrefix(\"100.64.1.0/24\"))\n \taddrPool := must.Get(ipsb.IPSet())\n \tpool := IPPool{\n-\t\tV6ULA: netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n \t\tIPSet: addrPool,\n \t}\n \tfrom := tailcfg.NodeID(12345)\n---\ncmd/natc/natc.go\n@@ -153,7 +153,7 @@ func main() {\n \t\twhois:      lc,\n \t\tv6ULA:      v6ULA,\n \t\tignoreDsts: ignoreDstTable,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\troutes:     routes,\n \t\tdnsAddr:    dnsAddr,\n \t\tresolver:   net.DefaultResolver,\n---\ncmd/natc/natc_test.go\n@@ -270,7 +270,7 @@ func TestDNSResponse(t *testing.T) {\n \t\tignoreDsts: &bart.Table[bool]{},\n \t\troutes:     routes,\n \t\tv6ULA:      v6ULA,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\tdnsAddr:    dnsAddr,\n \t}\n \tc.ignoreDsts.Insert(netip.MustParsePrefix(\"8.8.4.4/32\"), true)\n---\n\n\n---\n\nChoice D:\ndocs/windows/policy/en-US/tailscale.adml\n@@ -16,6 +16,7 @@\n             <string id=\"SINCE_V1_62\">Tailscale version 1.62.0 and later</string>\n             <string id=\"SINCE_V1_74\">Tailscale version 1.74.0 and later</string>\n             <string id=\"SINCE_V1_78\">Tailscale version 1.78.0 and later</string>\n+            <string id=\"SINCE_V1_80\">Tailscale version 1.80.0 and later</string>\n             <string id=\"SINCE_V1_82\">Tailscale version 1.82.0 and later</string>\n             <string id=\"SINCE_V1_84\">Tailscale version 1.84.0 and later</string>\n             <string id=\"Tailscale_Category\">Tailscale</string>\n@@ -271,6 +272,12 @@ If you enable this policy, the menu item will be displayed indicating the organi\n If you disable this policy or do not configure it, the corresponding menu item will be hidden.\n \n See https://tailscale.com/kb/1315/mdm-keys#set-your-organization-name for more details.]]></string>\n+            <string id=\"OnboardingFlow\">Show the onboarding flow</string>\n+            <string id=\"OnboardingFlow_Help\"><![CDATA[This policy can be used to show or hide the onboarding flow displayed by the GUI.\n+\n+If you enable or don't configure this policy, the onboarding flow will be shown to new users who have not yet signed in to a Tailscale account.\n+\n+If you disable this policy, the onboarding flow will never be shown.]]></string>\n         </stringTable>\n         <presentationTable>\n             <presentation id=\"LoginURL\">\n---\ndocs/windows/policy/tailscale.admx\n@@ -54,6 +54,10 @@\n                   displayName=\"$(string.SINCE_V1_78)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n       </definition>\n+      <definition name=\"SINCE_V1_80\"\n+                  displayName=\"$(string.SINCE_V1_80)\">\n+        <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n+      </definition>\n       <definition name=\"SINCE_V1_82\"\n                   displayName=\"$(string.SINCE_V1_82)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n@@ -335,6 +339,16 @@\n         <string>hide</string>\n       </disabledValue>\n     </policy>\n+    <policy name=\"OnboardingFlow\" class=\"Both\" displayName=\"$(string.OnboardingFlow)\" explainText=\"$(string.OnboardingFlow_Help)\" key=\"Software\\Policies\\Tailscale\" valueName=\"OnboardingFlow\">\n+      <parentCategory ref=\"UI_Category\" />\n+      <supportedOn ref=\"SINCE_V1_80\" />\n+      <enabledValue>\n+        <string>show</string>\n+      </enabledValue>\n+      <disabledValue>\n+        <string>hide</string>\n+      </disabledValue>\n+    </policy>\n     <policy name=\"ManagedBy\" class=\"Both\" displayName=\"$(string.ManagedBy)\" explainText=\"$(string.ManagedBy_Help)\" presentation=\"$(presentation.ManagedBy)\" key=\"Software\\Policies\\Tailscale\">\n       <parentCategory ref=\"UI_Category\" />\n       <supportedOn ref=\"SINCE_V1_62\" />\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis handle can be used in tests and debugging to identify the specific\nclient connection.\n\nUpdates tailscale/corp#28368\n\nChange-Id: I48cc573fc0bcf018c66a18e67ad6c4f248fb760c\nSigned-off-by: Brian Palmer <brianp@tailscale.com>\n\n---\n\nChoice A:\ncontrol/controlclient/direct.go\n@@ -95,15 +95,16 @@ type Direct struct {\n \tsfGroup     singleflight.Group[struct{}, *NoiseClient] // protects noiseClient creation.\n \tnoiseClient *NoiseClient\n \n-\tpersist      persist.PersistView\n-\tauthKey      string\n-\ttryingNewKey key.NodePrivate\n-\texpiry       time.Time         // or zero value if none/unknown\n-\thostinfo     *tailcfg.Hostinfo // always non-nil\n-\tnetinfo      *tailcfg.NetInfo\n-\tendpoints    []tailcfg.Endpoint\n-\ttkaHead      string\n-\tlastPingURL  string // last PingRequest.URL received, for dup suppression\n+\tpersist                 persist.PersistView\n+\tauthKey                 string\n+\ttryingNewKey            key.NodePrivate\n+\texpiry                  time.Time         // or zero value if none/unknown\n+\thostinfo                *tailcfg.Hostinfo // always non-nil\n+\tnetinfo                 *tailcfg.NetInfo\n+\tendpoints               []tailcfg.Endpoint\n+\ttkaHead                 string\n+\tlastPingURL             string // last PingRequest.URL received, for dup suppression\n+\tconnectionHandleForTest string // sent in MapRequest.ConnectionHandleForTest\n }\n \n // Observer is implemented by users of the control client (such as LocalBackend)\n@@ -403,6 +404,14 @@ func (c *Direct) SetTKAHead(tkaHead string) bool {\n \treturn true\n }\n \n+// SetConnectionHandleForTest stores a new MapRequest.ConnectionHandleForTest\n+// value for the next update.\n+func (c *Direct) SetConnectionHandleForTest(handle string) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tc.connectionHandleForTest = handle\n+}\n+\n func (c *Direct) GetPersist() persist.PersistView {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n@@ -851,6 +860,7 @@ func (c *Direct) sendMapRequest(ctx context.Context, isStreaming bool, nu Netmap\n \tserverNoiseKey := c.serverNoiseKey\n \thi := c.hostInfoLocked()\n \tbackendLogID := hi.BackendLogID\n+\tconnectionHandleForTest := c.connectionHandleForTest\n \tvar epStrs []string\n \tvar eps []netip.AddrPort\n \tvar epTypes []tailcfg.EndpointType\n@@ -891,17 +901,18 @@ func (c *Direct) sendMapRequest(ctx context.Context, isStreaming bool, nu Netmap\n \n \tnodeKey := persist.PublicNodeKey()\n \trequest := &tailcfg.MapRequest{\n-\t\tVersion:       tailcfg.CurrentCapabilityVersion,\n-\t\tKeepAlive:     true,\n-\t\tNodeKey:       nodeKey,\n-\t\tDiscoKey:      c.discoPubKey,\n-\t\tEndpoints:     eps,\n-\t\tEndpointTypes: epTypes,\n-\t\tStream:        isStreaming,\n-\t\tHostinfo:      hi,\n-\t\tDebugFlags:    c.debugFlags,\n-\t\tOmitPeers:     nu == nil,\n-\t\tTKAHead:       c.tkaHead,\n+\t\tVersion:                 tailcfg.CurrentCapabilityVersion,\n+\t\tKeepAlive:               true,\n+\t\tNodeKey:                 nodeKey,\n+\t\tDiscoKey:                c.discoPubKey,\n+\t\tEndpoints:               eps,\n+\t\tEndpointTypes:           epTypes,\n+\t\tStream:                  isStreaming,\n+\t\tHostinfo:                hi,\n+\t\tDebugFlags:              c.debugFlags,\n+\t\tOmitPeers:               nu == nil,\n+\t\tTKAHead:                 c.tkaHead,\n+\t\tConnectionHandleForTest: connectionHandleForTest,\n \t}\n \tvar extraDebugFlags []string\n \tif hi != nil && c.netMon != nil && !c.skipIPForwardingCheck &&\n---\ntailcfg/tailcfg.go\n@@ -1385,6 +1385,12 @@ type MapRequest struct {\n \t//     * \"warn-router-unhealthy\": client's Router implementation is\n \t//       having problems.\n \tDebugFlags []string `json:\",omitempty\"`\n+\n+\t// ConnectionHandleForTest, if non-empty, is an opaque string sent by the client that\n+\t// identifies this specific connection to the server. The server may choose to\n+\t// use this handle to identify the connection for debugging or testing\n+\t// purposes. It has no semantic meaning.\n+\tConnectionHandleForTest string `json:\",omitempty\"`\n }\n \n // PortRange represents a range of UDP or TCP port numbers.\n---\n\n\n---\n\nChoice B:\nipn/desktop/mksyscall.go\n@@ -11,8 +11,6 @@ package desktop\n //sys registerClassEx(windowClass *_WNDCLASSEX) (atom uint16, err error) [atom==0] = user32.RegisterClassExW\n //sys createWindowEx(dwExStyle uint32, lpClassName *uint16, lpWindowName *uint16, dwStyle uint32, x int32, y int32, nWidth int32, nHeight int32, hWndParent windows.HWND, hMenu windows.Handle, hInstance windows.Handle, lpParam unsafe.Pointer) (hWnd windows.HWND, err error) [hWnd==0] = user32.CreateWindowExW\n //sys defWindowProc(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.DefWindowProcW\n-//sys setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) [res==0 && e1!=0] = user32.SetWindowLongPtrW\n-//sys getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) [res==0 && e1!=0] = user32.GetWindowLongPtrW\n //sys sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.SendMessageW\n //sys getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (ret int32) = user32.GetMessageW\n //sys translateMessage(lpMsg *_MSG) (res bool) = user32.TranslateMessage\n---\nipn/desktop/sessions_windows.go\n@@ -670,3 +670,38 @@ func (cs _WTS_CONNECTSTATE_CLASS) ToSessionStatus() SessionStatus {\n \t\treturn ClosedSession\n \t}\n }\n+\n+var (\n+\tprocGetWindowLongPtrW *windows.LazyProc\n+\tprocSetWindowLongPtrW *windows.LazyProc\n+)\n+\n+func init() {\n+\t// GetWindowLongPtrW and SetWindowLongPtrW are only available on 64-bit platforms.\n+\t// https://web.archive.org/web/20250414195520/https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw\n+\tif runtime.GOARCH == \"386\" || runtime.GOARCH == \"arm\" {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongW\")\n+\t} else {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongPtrW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongPtrW\")\n+\t}\n+}\n+\n+func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n---\nipn/desktop/zsyscall_windows.go\n@@ -48,11 +48,9 @@ var (\n \tprocDestroyWindow                      = moduser32.NewProc(\"DestroyWindow\")\n \tprocDispatchMessageW                   = moduser32.NewProc(\"DispatchMessageW\")\n \tprocGetMessageW                        = moduser32.NewProc(\"GetMessageW\")\n-\tprocGetWindowLongPtrW                  = moduser32.NewProc(\"GetWindowLongPtrW\")\n \tprocPostQuitMessage                    = moduser32.NewProc(\"PostQuitMessage\")\n \tprocRegisterClassExW                   = moduser32.NewProc(\"RegisterClassExW\")\n \tprocSendMessageW                       = moduser32.NewProc(\"SendMessageW\")\n-\tprocSetWindowLongPtrW                  = moduser32.NewProc(\"SetWindowLongPtrW\")\n \tprocTranslateMessage                   = moduser32.NewProc(\"TranslateMessage\")\n \tprocWTSRegisterSessionNotificationEx   = modwtsapi32.NewProc(\"WTSRegisterSessionNotificationEx\")\n \tprocWTSUnRegisterSessionNotificationEx = modwtsapi32.NewProc(\"WTSUnRegisterSessionNotificationEx\")\n@@ -98,15 +96,6 @@ func getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (r\n \treturn\n }\n \n-func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func postQuitMessage(exitCode int32) {\n \tsyscall.Syscall(procPostQuitMessage.Addr(), 1, uintptr(exitCode), 0, 0)\n \treturn\n@@ -127,15 +116,6 @@ func sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr)\n \treturn\n }\n \n-func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func translateMessage(lpMsg *_MSG) (res bool) {\n \tr0, _, _ := syscall.Syscall(procTranslateMessage.Addr(), 1, uintptr(unsafe.Pointer(lpMsg)), 0, 0)\n \tres = r0 != 0\n---\n\n\n---\n\nChoice C:\nlogtail/logtail.go\n@@ -15,9 +15,7 @@ import (\n \t\"log\"\n \tmrand \"math/rand/v2\"\n \t\"net/http\"\n-\t\"net/netip\"\n \t\"os\"\n-\t\"regexp\"\n \t\"runtime\"\n \t\"slices\"\n \t\"strconv\"\n@@ -29,7 +27,6 @@ import (\n \t\"tailscale.com/envknob\"\n \t\"tailscale.com/net/netmon\"\n \t\"tailscale.com/net/sockstats\"\n-\t\"tailscale.com/net/tsaddr\"\n \t\"tailscale.com/tstime\"\n \ttslogger \"tailscale.com/types/logger\"\n \t\"tailscale.com/types/logid\"\n@@ -833,8 +830,6 @@ func (l *Logger) Logf(format string, args ...any) {\n \tfmt.Fprintf(l, format, args...)\n }\n \n-var obscureIPs = envknob.RegisterBool(\"TS_OBSCURE_LOGGED_IPS\")\n-\n // Write logs an encoded JSON blob.\n //\n // If the []byte passed to Write is not an encoded JSON blob,\n@@ -859,10 +854,6 @@ func (l *Logger) Write(buf []byte) (int, error) {\n \t\t}\n \t}\n \n-\tif obscureIPs() {\n-\t\tbuf = redactIPs(buf)\n-\t}\n-\n \tl.writeLock.Lock()\n \tdefer l.writeLock.Unlock()\n \n@@ -871,40 +862,6 @@ func (l *Logger) Write(buf []byte) (int, error) {\n \treturn inLen, err\n }\n \n-var (\n-\tregexMatchesIPv6 = regexp.MustCompile(`([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4}):([0-9a-fA-F:]{1,4})*`)\n-\tregexMatchesIPv4 = regexp.MustCompile(`(\\d{1,3})\\.(\\d{1,3})\\.\\d{1,3}\\.\\d{1,3}`)\n-)\n-\n-// redactIPs is a helper function used in Write() to redact IPs (other than tailscale IPs).\n-// This function takes a log line as a byte slice and\n-// uses regex matching to parse and find IP addresses. Based on if the IP address is IPv4 or\n-// IPv6, it parses and replaces the end of the addresses with an \"x\". This function returns the\n-// log line with the IPs redacted.\n-func redactIPs(buf []byte) []byte {\n-\tout := regexMatchesIPv6.ReplaceAllFunc(buf, func(b []byte) []byte {\n-\t\tip, err := netip.ParseAddr(string(b))\n-\t\tif err != nil || tsaddr.IsTailscaleIP(ip) {\n-\t\t\treturn b // don't change this one\n-\t\t}\n-\n-\t\tprefix := bytes.Split(b, []byte(\":\"))\n-\t\treturn bytes.Join(append(prefix[:2], []byte(\"x\")), []byte(\":\"))\n-\t})\n-\n-\tout = regexMatchesIPv4.ReplaceAllFunc(out, func(b []byte) []byte {\n-\t\tip, err := netip.ParseAddr(string(b))\n-\t\tif err != nil || tsaddr.IsTailscaleIP(ip) {\n-\t\t\treturn b // don't change this one\n-\t\t}\n-\n-\t\tprefix := bytes.Split(b, []byte(\".\"))\n-\t\treturn bytes.Join(append(prefix[:2], []byte(\"x.x\")), []byte(\".\"))\n-\t})\n-\n-\treturn []byte(out)\n-}\n-\n var (\n \topenBracketV = []byte(\"[v\")\n \tv1           = []byte(\"[v1] \")\n---\nlogtail/logtail_test.go\n@@ -15,7 +15,6 @@ import (\n \t\"time\"\n \n \t\"github.com/go-json-experiment/json/jsontext\"\n-\t\"tailscale.com/envknob\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/tstime\"\n \t\"tailscale.com/util/must\"\n@@ -316,85 +315,6 @@ func TestLoggerWriteResult(t *testing.T) {\n \t\tt.Errorf(\"mismatch.\\n got: %#q\\nwant: %#q\", back, want)\n \t}\n }\n-func TestRedact(t *testing.T) {\n-\tenvknob.Setenv(\"TS_OBSCURE_LOGGED_IPS\", \"true\")\n-\ttests := []struct {\n-\t\tin   string\n-\t\twant string\n-\t}{\n-\t\t// tests for ipv4 addresses\n-\t\t{\n-\t\t\t\"120.100.30.47\",\n-\t\t\t\"120.100.x.x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"192.167.0.1/65\",\n-\t\t\t\"192.167.x.x/65\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.0.222:41641 mtu=1360 tx=d81a8a35a0ce\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.x.x:41641 mtu=1360 tx=d81a8a35a0ce\",\n-\t\t},\n-\t\t//tests for ipv6 addresses\n-\t\t{\n-\t\t\t\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"2001:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2345:0425:2CA1:0000:0000:0567:5673:23b5\",\n-\t\t\t\"2345:0425:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2601:645:8200:edf0::c9de/64\",\n-\t\t\t\"2601:645:x/64\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 2051:0000:140F::875B:131C mtu=1360 tx=d81a8a35a0ce\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 2051:0000:x mtu=1360 tx=d81a8a35a0ce\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2601:645:8200:edf0::c9de/64 2601:645:8200:edf0:1ce9:b17d:71f5:f6a3/64\",\n-\t\t\t\"2601:645:x/64 2601:645:x/64\",\n-\t\t},\n-\t\t//tests for tailscale ip addresses\n-\t\t{\n-\t\t\t\"100.64.5.6\",\n-\t\t\t\"100.64.5.6\",\n-\t\t},\n-\t\t{\n-\t\t\t\"fd7a:115c:a1e0::/96\",\n-\t\t\t\"fd7a:115c:a1e0::/96\",\n-\t\t},\n-\t\t//tests for ipv6 and ipv4 together\n-\t\t{\n-\t\t\t\"192.167.0.1 2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"192.167.x.x 2001:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.0.222:41641 mtu=1360 tx=d81a8a35a0ce 2345:0425:2CA1::0567:5673:23b5\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.x.x:41641 mtu=1360 tx=d81a8a35a0ce 2345:0425:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"100.64.5.6 2091:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"100.64.5.6 2091:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"192.167.0.1 120.100.30.47 2041:0000:140F::875B:131B\",\n-\t\t\t\"192.167.x.x 120.100.x.x 2041:0000:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"fd7a:115c:a1e0::/96 192.167.0.1 2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"fd7a:115c:a1e0::/96 192.167.x.x 2001:0db8:x\",\n-\t\t},\n-\t}\n-\n-\tfor _, tt := range tests {\n-\t\tgotBuf := redactIPs([]byte(tt.in))\n-\t\tif string(gotBuf) != tt.want {\n-\t\t\tt.Errorf(\"for %q,\\n got: %#q\\nwant: %#q\\n\", tt.in, gotBuf, tt.want)\n-\t\t}\n-\t}\n-}\n \n func TestAppendMetadata(t *testing.T) {\n \tvar l Logger\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -958,7 +958,9 @@ func (b *LocalBackend) linkChange(delta *netmon.ChangeDelta) {\n \n \tif peerAPIListenAsync && b.netMap != nil && b.state == ipn.Running {\n \t\twant := b.netMap.GetAddresses().Len()\n-\t\tif len(b.peerAPIListeners) < want {\n+\t\thave := len(b.peerAPIListeners)\n+\t\tb.logf(\"[v1] linkChange: have %d peerAPIListeners, want %d\", have, want)\n+\t\tif have < want {\n \t\t\tb.logf(\"linkChange: peerAPIListeners too low; trying again\")\n \t\t\tb.goTracker.Go(b.initPeerAPIListener)\n \t\t}\n@@ -5369,6 +5371,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n+\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\nscripts/installer.sh\n@@ -208,8 +208,11 @@ main() {\n \t\t\t\t\tPACKAGETYPE=\"yum\"\n \t\t\t\tfi\n \t\t\t\t;;\n-\t\t\trhel)\n+\t\t\trhel|miraclelinux)\n \t\t\t\tOS=\"$ID\"\n+\t\t\t\tif [ \"$ID\" = \"miraclelinux\" ]; then\n+\t\t\t\t\tOS=\"rhel\"\n+\t\t\t\tfi\n \t\t\t\tVERSION=\"$(echo \"$VERSION_ID\" | cut -f1 -d.)\"\n \t\t\t\tPACKAGETYPE=\"dnf\"\n \t\t\t\tif [ \"$VERSION\" = \"7\" ]; then\n---\n\n\n---\n\nChoice B:\nfeature/relayserver/relayserver.go\n@@ -72,10 +72,20 @@ func (e *extension) Init(host ipnext.Host) error {\n \tprofile, prefs := host.Profiles().CurrentProfileState()\n \te.profileStateChanged(profile, prefs, false)\n \thost.Hooks().ProfileStateChange.Add(e.profileStateChanged)\n-\t// TODO(jwhited): callback for netmap/nodeattr changes (e.hasNodeAttrRelayServer)\n+\thost.Hooks().OnSelfChange.Add(e.selfNodeViewChanged)\n \treturn nil\n }\n \n+func (e *extension) selfNodeViewChanged(nodeView tailcfg.NodeView) {\n+\te.mu.Lock()\n+\tdefer e.mu.Unlock()\n+\te.hasNodeAttrRelayServer = nodeView.HasCap(tailcfg.NodeAttrRelayServer)\n+\tif !e.hasNodeAttrRelayServer && e.server != nil {\n+\t\te.server.Close()\n+\t\te.server = nil\n+\t}\n+}\n+\n func (e *extension) profileStateChanged(_ ipn.LoginProfileView, prefs ipn.PrefsView, sameNode bool) {\n \te.mu.Lock()\n \tdefer e.mu.Unlock()\n---\n\n\n---\n\nChoice C:\ntsnet/depaware.txt\n@@ -132,7 +132,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n    L \ud83d\udca3 github.com/mdlayher/netlink                                  from github.com/google/nftables+\n    L \ud83d\udca3 github.com/mdlayher/netlink/nlenc                            from github.com/jsimonetti/rtnetlink+\n    L    github.com/mdlayher/netlink/nltest                           from github.com/google/nftables\n-  LA    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n+   L    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n   LA \ud83d\udca3 github.com/mdlayher/socket                                   from github.com/mdlayher/netlink+\n         github.com/miekg/dns                                         from tailscale.com/net/dns/recursive\n  LDWA \ud83d\udca3 github.com/mitchellh/go-ps                                   from tailscale.com/safesocket\n---\nutil/systemd/systemd_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package systemd\n \n---\nutil/systemd/systemd_nonlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux || android\n \n package systemd\n \n---\n\n\n---\n\nChoice D:\nnet/netmon/state.go\n@@ -27,8 +27,9 @@ import (\n // same interface and subnet.\n var forceAllIPv6Endpoints = envknob.RegisterBool(\"TS_DEBUG_FORCE_ALL_IPV6_ENDPOINTS\")\n \n-// set a debug knob to exclude interfaces from the list of interfaces\n-var excludedInterfaces = envknob.RegisterString(\"TS_DEBUG_EXCLUDED_INTERFACES\")\n+// suppressInterfaces is a debug knob containing a list of interface names that should not be advertised as endpoints. \n+// Traffic may still flow over these interfaces if system routing makes the decision to do so.\n+var excludeInterfaces = envknob.RegisterString(\"TS_DEBUG_EXCLUDE_INTERFACES\")\n \n // LoginEndpointForProxyDetermination is the URL used for testing\n // which HTTP proxy the system should use.\n@@ -54,7 +55,7 @@ func isExcludedInterface(nif *net.Interface) bool {\n \t\treturn false\n \t}\n \n-\tremain := excludedInterfaces()\n+\tremain := excludeInterfaces()\n \tfor remain != \"\" {\n \t\tvar candidate string\n \t\tcandidate, remain, _ = strings.Cut(remain, \",\")\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #15812\nUpdates #12614\n\n\n---\n\nChoice A:\nipn/ipnlocal/ssh_stub.go\n@@ -8,6 +8,7 @@ package ipnlocal\n import (\n \t\"errors\"\n \n+\t\"golang.org/x/crypto/ssh\"\n \t\"tailscale.com/tailcfg\"\n )\n \n@@ -18,3 +19,7 @@ func (b *LocalBackend) getSSHHostKeyPublicStrings() ([]string, error) {\n func (b *LocalBackend) getSSHUsernames(*tailcfg.C2NSSHUsernamesRequest) (*tailcfg.C2NSSHUsernamesResponse, error) {\n \treturn nil, errors.New(\"not implemented\")\n }\n+\n+func (b *LocalBackend) GetSSH_HostKeys() (keys []ssh.Signer, err error) {\n+\treturn nil, errors.New(\"not implemented\")\n+}\n---\n\n\n---\n\nChoice B:\n.github/workflows/codeql-analysis.yml\n@@ -49,7 +49,7 @@ jobs:\n \n     # Install a more recent Go that understands modern go.mod content.\n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n \n---\n.github/workflows/golangci-lint.yml\n@@ -25,7 +25,7 @@ jobs:\n     steps:\n       - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n-      - uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      - uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n         with:\n           go-version-file: go.mod\n           cache: false\n---\n.github/workflows/test.yml\n@@ -151,7 +151,7 @@ jobs:\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n         cache: false\n---\n\n\n---\n\nChoice C:\ncmd/tailscale/cli/cli.go\n@@ -207,6 +207,8 @@ func noDupFlagify(c *ffcli.Command) {\n \t}\n }\n \n+var fileCmd func() *ffcli.Command\n+\n func newRootCmd() *ffcli.Command {\n \trootfs := newFlagSet(\"tailscale\")\n \trootfs.Func(\"socket\", \"path to tailscaled socket\", func(s string) error {\n@@ -247,7 +249,7 @@ change in the future.\n \t\t\tserveCmd(),\n \t\t\tversionCmd,\n \t\t\twebCmd,\n-\t\t\tfileCmd,\n+\t\t\tnilOrCall(fileCmd),\n \t\t\tbugReportCmd,\n \t\t\tcertCmd,\n \t\t\tnetlockCmd,\n@@ -286,6 +288,13 @@ func nonNilCmds(cmds ...*ffcli.Command) []*ffcli.Command {\n \treturn slicesx.AppendNonzero(cmds[:0], cmds)\n }\n \n+func nilOrCall(f func() *ffcli.Command) *ffcli.Command {\n+\tif f == nil {\n+\t\treturn nil\n+\t}\n+\treturn f()\n+}\n+\n func fatalf(format string, a ...any) {\n \tif Fatalf != nil {\n \t\tFatalf(format, a...)\n---\ncmd/tailscale/cli/file.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !ts_omit_taildrop\n+\n package cli\n \n import (\n@@ -38,14 +40,20 @@ import (\n \t\"tailscale.com/version\"\n )\n \n-var fileCmd = &ffcli.Command{\n-\tName:       \"file\",\n-\tShortUsage: \"tailscale file <cp|get> ...\",\n-\tShortHelp:  \"Send or receive files\",\n-\tSubcommands: []*ffcli.Command{\n-\t\tfileCpCmd,\n-\t\tfileGetCmd,\n-\t},\n+func init() {\n+\tfileCmd = getFileCmd\n+}\n+\n+func getFileCmd() *ffcli.Command {\n+\treturn &ffcli.Command{\n+\t\tName:       \"file\",\n+\t\tShortUsage: \"tailscale file <cp|get> ...\",\n+\t\tShortHelp:  \"Send or receive files\",\n+\t\tSubcommands: []*ffcli.Command{\n+\t\t\tfileCpCmd,\n+\t\t\tfileGetCmd,\n+\t\t},\n+\t}\n }\n \n type countingReader struct {\n---\n\n\n---\n\nChoice D:\ntstest/integration/integration.go\n@@ -770,6 +770,27 @@ func (d *Daemon) MustCleanShutdown(t testing.TB) {\n \t}\n }\n \n+// awaitTailscaledRunnable tries to run `tailscaled --version` until it\n+// works. This is an unsatisfying workaround for ETXTBSY we were seeing\n+// on GitHub Actions that aren't understood. It's not clear what's holding\n+// a writable fd to tailscaled after `go install` completes.\n+// See https://github.com/tailscale/tailscale/issues/15868.\n+func (n *TestNode) awaitTailscaledRunnable() error {\n+\tt := n.env.t\n+\tt.Helper()\n+\tif err := tstest.WaitFor(10*time.Second, func() error {\n+\t\tout, err := exec.Command(n.env.daemon, \"--version\").CombinedOutput()\n+\t\tif err == nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\tt.Logf(\"error running tailscaled --version: %v, %s\", err, out)\n+\t\treturn err\n+\t}); err != nil {\n+\t\treturn fmt.Errorf(\"gave up trying to run tailscaled: %v\", err)\n+\t}\n+\treturn nil\n+}\n+\n // StartDaemon starts the node's tailscaled, failing if it fails to start.\n // StartDaemon ensures that the process will exit when the test completes.\n func (n *TestNode) StartDaemon() *Daemon {\n@@ -778,6 +799,11 @@ func (n *TestNode) StartDaemon() *Daemon {\n \n func (n *TestNode) StartDaemonAsIPNGOOS(ipnGOOS string) *Daemon {\n \tt := n.env.t\n+\n+\tif err := n.awaitTailscaledRunnable(); err != nil {\n+\t\tt.Fatalf(\"awaitTailscaledRunnable: %v\", err)\n+\t}\n+\n \tcmd := exec.Command(n.env.daemon)\n \tcmd.Args = append(cmd.Args,\n \t\t\"--statedir=\"+n.dir,\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUntil we turn on AAAA by default (which might make some people rely on\r\nHappy Eyeballs for targets without IPv6), this lets people turn it on\r\nexplicitly if they want.\r\n\r\nWe still should add a peer cap as well in the future to let a peer\r\nexplicitly say that it's cool with IPv6.\r\n\r\nRelated: https://github.com/tailscale/tailscale/pull/9574\r\n\r\nUpdates #1813\r\nUpdaets #1152\r\n\n\n---\n\nChoice A:\ncmd/derpprobe/derpprobe.go\n@@ -9,6 +9,7 @@ import (\n \t\"fmt\"\n \t\"log\"\n \t\"net/http\"\n+\t\"os\"\n \t\"sort\"\n \t\"time\"\n \n@@ -75,6 +76,9 @@ func main() {\n \t\tfor _, s := range st.bad {\n \t\t\tlog.Printf(\"bad: %s\", s)\n \t\t}\n+\t\tif len(st.bad) > 0 {\n+\t\t\tos.Exit(1)\n+\t\t}\n \t\treturn\n \t}\n \n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -5056,6 +5056,8 @@ func dnsConfigForNetmap(nm *netmap.NetworkMap, peers map[tailcfg.NodeID]tailcfg.\n \t\t!nm.GetAddresses().ContainsFunc(tsaddr.PrefixIs4)\n \tdcfg.OnlyIPv6 = selfV6Only\n \n+\twantAAAA := nm.AllCaps.Contains(tailcfg.NodeAttrMagicDNSPeerAAAA)\n+\n \t// Populate MagicDNS records. We do this unconditionally so that\n \t// quad-100 can always respond to MagicDNS queries, even if the OS\n \t// isn't configured to make MagicDNS resolution truly\n@@ -5092,7 +5094,7 @@ func dnsConfigForNetmap(nm *netmap.NetworkMap, peers map[tailcfg.NodeID]tailcfg.\n \t\t\t// https://github.com/tailscale/tailscale/issues/1152\n \t\t\t// tracks adding the right capability reporting to\n \t\t\t// enable AAAA in MagicDNS.\n-\t\t\tif addr.Addr().Is6() && have4 {\n+\t\t\tif addr.Addr().Is6() && have4 && !wantAAAA {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tips = append(ips, addr.Addr())\n---\ntailcfg/tailcfg.go\n@@ -160,7 +160,8 @@ type CapabilityVersion int\n //   - 113: 2025-01-20: Client communicates to control whether funnel is enabled by sending Hostinfo.IngressEnabled (#14688)\n //   - 114: 2025-01-30: NodeAttrMaxKeyDuration CapMap defined, clients might use it (no tailscaled code change) (#14829)\n //   - 115: 2025-03-07: Client understands DERPRegion.NoMeasureNoHome.\n-const CurrentCapabilityVersion CapabilityVersion = 115\n+//   - 116: 2025-05-05: Client serves MagicDNS \"AAAA\" if NodeAttrMagicDNSPeerAAAA set on self node\n+const CurrentCapabilityVersion CapabilityVersion = 116\n \n // ID is an integer ID for a user, node, or login allocated by the\n // control plane.\n@@ -2493,6 +2494,10 @@ const (\n \t// NodeAttrRelayClient permits the node to act as an underlay UDP relay\n \t// client. There are no expected values for this key in NodeCapMap.\n \tNodeAttrRelayClient NodeCapability = \"relay:client\"\n+\n+\t// NodeAttrMagicDNSPeerAAAA is a capability that tells the node's MagicDNS\n+\t// server to answer AAAA queries about its peers. See tailscale/tailscale#1152.\n+\tNodeAttrMagicDNSPeerAAAA NodeCapability = \"magicdns-aaaa\"\n )\n \n // SetDNSRequest is a request to add a DNS record.\n---\n\n\n---\n\nChoice C:\nclient/local/local.go\n@@ -1504,7 +1504,7 @@ func (lc *Client) SwitchProfile(ctx context.Context, profile ipn.ProfileID) erro\n // If the profile is the current profile, an empty profile\n // will be selected as if SwitchToEmptyProfile was called.\n func (lc *Client) DeleteProfile(ctx context.Context, profile ipn.ProfileID) error {\n-\t_, err := lc.send(ctx, \"DELETE\", \"/localapi/v0/profiles\"+url.PathEscape(string(profile)), http.StatusNoContent, nil)\n+\t_, err := lc.send(ctx, \"DELETE\", \"/localapi/v0/profiles/\"+url.PathEscape(string(profile)), http.StatusNoContent, nil)\n \treturn err\n }\n \n---\n\n\n---\n\nChoice D:\nipn/localapi/localapi.go\n@@ -397,6 +397,15 @@ func (h *Handler) serveBugReport(w http.ResponseWriter, r *http.Request) {\n \t// OS-specific details\n \th.logf.JSON(1, \"UserBugReportOS\", osdiag.SupportInfo(osdiag.LogSupportInfoReasonBugReport))\n \n+\t// Tailnet lock details\n+\tst := h.b.NetworkLockStatus()\n+\tif st.Enabled {\n+\t\th.logf.JSON(1, \"UserBugReportTailnetLockStatus\", st)\n+\t\tif st.NodeKeySignature != nil {\n+\t\t\th.logf(\"user bugreport tailnet lock signature: %s\", st.NodeKeySignature.String())\n+\t\t}\n+\t}\n+\n \tif defBool(r.URL.Query().Get(\"diagnose\"), false) {\n \t\th.b.Doctor(r.Context(), logger.WithPrefix(h.logf, \"diag: \"))\n \t}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [github/codeql-action](https://github.com/github/codeql-action) from 3.28.15 to 3.28.17.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/releases\">github/codeql-action's releases</a>.</em></p>\n<blockquote>\n<h2>v3.28.17</h2>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>3.28.17 - 02 May 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.2. <a href=\"https://redirect.github.com/github/codeql-action/pull/2872\">#2872</a></li>\n</ul>\n<p>See the full <a href=\"https://github.com/github/codeql-action/blob/v3.28.17/CHANGELOG.md\">CHANGELOG.md</a> for more information.</p>\n<h2>v3.28.16</h2>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>3.28.16 - 23 Apr 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.1. <a href=\"https://redirect.github.com/github/codeql-action/pull/2863\">#2863</a></li>\n</ul>\n<p>See the full <a href=\"https://github.com/github/codeql-action/blob/v3.28.16/CHANGELOG.md\">CHANGELOG.md</a> for more information.</p>\n</blockquote>\n</details>\n<details>\n<summary>Changelog</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/blob/main/CHANGELOG.md\">github/codeql-action's changelog</a>.</em></p>\n<blockquote>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>[UNRELEASED]</h2>\n<p>No user facing changes.</p>\n<h2>3.28.17 - 02 May 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.2. <a href=\"https://redirect.github.com/github/codeql-action/pull/2872\">#2872</a></li>\n</ul>\n<h2>3.28.16 - 23 Apr 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.1. <a href=\"https://redirect.github.com/github/codeql-action/pull/2863\">#2863</a></li>\n</ul>\n<h2>3.28.15 - 07 Apr 2025</h2>\n<ul>\n<li>Fix bug where the action would fail if it tried to produce a debug artifact with more than 65535 files. <a href=\"https://redirect.github.com/github/codeql-action/pull/2842\">#2842</a></li>\n</ul>\n<h2>3.28.14 - 07 Apr 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.0. <a href=\"https://redirect.github.com/github/codeql-action/pull/2838\">#2838</a></li>\n</ul>\n<h2>3.28.13 - 24 Mar 2025</h2>\n<p>No user facing changes.</p>\n<h2>3.28.12 - 19 Mar 2025</h2>\n<ul>\n<li>Dependency caching should now cache more dependencies for Java <code>build-mode: none</code> extractions. This should speed up workflows and avoid inconsistent alerts in some cases.</li>\n<li>Update default CodeQL bundle version to 2.20.7. <a href=\"https://redirect.github.com/github/codeql-action/pull/2810\">#2810</a></li>\n</ul>\n<h2>3.28.11 - 07 Mar 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.6. <a href=\"https://redirect.github.com/github/codeql-action/pull/2793\">#2793</a></li>\n</ul>\n<h2>3.28.10 - 21 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.5. <a href=\"https://redirect.github.com/github/codeql-action/pull/2772\">#2772</a></li>\n<li>Address an issue where the CodeQL Bundle would occasionally fail to decompress on macOS. <a href=\"https://redirect.github.com/github/codeql-action/pull/2768\">#2768</a></li>\n</ul>\n<h2>3.28.9 - 07 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.4. <a href=\"https://redirect.github.com/github/codeql-action/pull/2753\">#2753</a></li>\n</ul>\n<h2>3.28.8 - 29 Jan 2025</h2>\n<ul>\n<li>Enable support for Kotlin 2.1.10 when running with CodeQL CLI v2.20.3. <a href=\"https://redirect.github.com/github/codeql-action/pull/2744\">#2744</a></li>\n</ul>\n<!-- raw HTML omitted -->\n</blockquote>\n<p>... (truncated)</p>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/github/codeql-action/commit/60168efe1c415ce0f5521ea06d5c2062adbeed1b\"><code>60168ef</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2886\">#2886</a> from github/update-v3.28.17-97a2bfd2a</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/0d5a3115da6459f8ab4333164184f8292c0c7a7f\"><code>0d5a311</code></a> Update changelog for v3.28.17</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/97a2bfd2a3d26d458da69e548f7f859d6fca634d\"><code>97a2bfd</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2872\">#2872</a> from github/update-bundle/codeql-bundle-v2.21.2</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/9aba20e4c91fd8c3a71d5ab2bdeba0da11713864\"><code>9aba20e</code></a> Merge branch 'main' into update-bundle/codeql-bundle-v2.21.2</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/81a9508deb02898c1a7be79bd5b49bb0ab9c787e\"><code>81a9508</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2876\">#2876</a> from github/henrymercer/fix-diff-informed-multiple-a...</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/1569f4c145413fbce7d6573c6ee9212d2612d27f\"><code>1569f4c</code></a> Disable diff-informed queries in code scanning config tests</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/62fbeb66b359bfbdec7d4d96af8f68aece59b4db\"><code>62fbeb6</code></a> Merge branch 'main' into henrymercer/fix-diff-informed-multiple-analyze</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/f122d1dc9eb83b12dc16b38495b667a2dddfa6f9\"><code>f122d1d</code></a> Address test failures from computing temporary directory too early</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/083772aae48a3be5654921bb6e6ccb00e0e1d563\"><code>083772a</code></a> Do not fail diff informed analyses when <code>analyze</code> is run twice in the same job</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/5db14d0471303d6eee1e2a51393f5ae1669b6703\"><code>5db14d0</code></a> Merge branch 'main' into update-bundle/codeql-bundle-v2.21.2</li>\n<li>Additional commits viewable in <a href=\"https://github.com/github/codeql-action/compare/45775bd8235c68ba998cffa5171334d58593da47...60168efe1c415ce0f5521ea06d5c2062adbeed1b\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=github/codeql-action&package-manager=github_actions&previous-version=3.28.15&new-version=3.28.17)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/init@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/autobuild@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/analyze@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n---\n\n\n---\n\nChoice B:\n.github/workflows/golangci-lint.yml\n@@ -31,9 +31,9 @@ jobs:\n           cache: false\n \n       - name: golangci-lint\n-        uses: golangci/golangci-lint-action@2226d7cb06a077cd73e56eedd38eecad18e5d837 # v6.5.0\n+        uses: golangci/golangci-lint-action@1481404843c368bc19ca9406f87d6e0fc97bdcfd # v7.0.0\n         with:\n-          version: v1.64\n+          version: v2.0.2\n \n           # Show only new issues if it's a pull request.\n           only-new-issues: true\n---\n.golangci.yml\n@@ -1,97 +1,110 @@\n+version: \"2\"\n+# Configuration for how we run golangci-lint\n+# Timeout of 5m was the default in v1.\n+run:\n+  timeout: 5m\n linters:\n   # Don't enable any linters by default; just the ones that we explicitly\n   # enable in the list below.\n-  disable-all: true\n+  default: none\n   enable:\n     - bidichk\n-    - gofmt\n-    - goimports\n     - govet\n     - misspell\n     - revive\n-\n-# Configuration for how we run golangci-lint\n-run:\n-  timeout: 5m\n-\n-issues:\n-  # Excluding configuration per-path, per-linter, per-text and per-source\n-  exclude-rules:\n-    # These are forks of an upstream package and thus are exempt from stylistic\n-    # changes that would make pulling in upstream changes harder.\n-    - path: tempfork/.*\\.go\n-      text: \"File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\"\n-    - path: util/singleflight/.*\\.go\n-      text: \"File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\"\n-\n-# Per-linter settings are contained in this top-level key\n-linters-settings:\n-  gofmt:\n-    rewrite-rules:\n-      - pattern: 'interface{}'\n-        replacement: 'any'\n-\n-  govet:\n+  settings:\n     # Matches what we use in corp as of 2023-12-07\n-    enable:\n-      - asmdecl\n-      - assign\n-      - atomic\n-      - bools\n-      - buildtag\n-      - cgocall\n-      - copylocks\n-      - deepequalerrors\n-      - errorsas\n-      - framepointer\n-      - httpresponse\n-      - ifaceassert\n-      - loopclosure\n-      - lostcancel\n-      - nilfunc\n-      - nilness\n-      - printf\n-      - reflectvaluecompare\n-      - shift\n-      - sigchanyzer\n-      - sortslice\n-      - stdmethods\n-      - stringintconv\n-      - structtag\n-      - testinggoroutine\n-      - tests\n-      - unmarshal\n-      - unreachable\n-      - unsafeptr\n-      - unusedresult\n-    settings:\n-      printf:\n-        # List of print function names to check (in addition to default)\n-        funcs:\n-          - github.com/tailscale/tailscale/types/logger.Discard\n-          # NOTE(andrew-d): this doesn't currently work because the printf\n-          # analyzer doesn't support type declarations\n-          #- github.com/tailscale/tailscale/types/logger.Logf\n-\n-  revive:\n-    enable-all-rules: false\n-    ignore-generated-header: true\n+    govet:\n+      enable:\n+        - asmdecl\n+        - assign\n+        - atomic\n+        - bools\n+        - buildtag\n+        - cgocall\n+        - copylocks\n+        - deepequalerrors\n+        - errorsas\n+        - framepointer\n+        - httpresponse\n+        - ifaceassert\n+        - loopclosure\n+        - lostcancel\n+        - nilfunc\n+        - nilness\n+        - printf\n+        - reflectvaluecompare\n+        - shift\n+        - sigchanyzer\n+        - sortslice\n+        - stdmethods\n+        - stringintconv\n+        - structtag\n+        - testinggoroutine\n+        - tests\n+        - unmarshal\n+        - unreachable\n+        - unsafeptr\n+        - unusedresult\n+      settings:\n+        printf:\n+          # List of print function names to check (in addition to default)\n+          funcs:\n+            - github.com/tailscale/tailscale/types/logger.Discard\n+            # NOTE(andrew-d): this doesn't currently work because the printf\n+            # analyzer doesn't support type declarations\n+            #- github.com/tailscale/tailscale/types/logger.Logf\n+    revive:\n+      enable-all-rules: false\n+      rules:\n+        - name: atomic\n+        - name: context-keys-type\n+        - name: defer\n+          arguments: [[\n+              # Calling 'recover' at the time a defer is registered (i.e. \"defer recover()\") has no effect.\n+              \"immediate-recover\",\n+              # Calling 'recover' outside of a deferred function has no effect\n+              \"recover\",\n+              # Returning values from a deferred function has no effect\n+              \"return\",\n+          ]]\n+        - name: duplicated-imports\n+        - name: errorf\n+        - name: string-of-int\n+        - name: time-equal\n+        - name: unconditional-recursion\n+        - name: useless-break\n+        - name: waitgroup-by-value\n+  exclusions:\n+    generated: lax\n+    presets:\n+      - comments\n+      - common-false-positives\n+      - legacy\n+      - std-error-handling\n     rules:\n-      - name: atomic\n-      - name: context-keys-type\n-      - name: defer\n-        arguments: [[\n-          # Calling 'recover' at the time a defer is registered (i.e. \"defer recover()\") has no effect.\n-          \"immediate-recover\",\n-          # Calling 'recover' outside of a deferred function has no effect\n-          \"recover\",\n-          # Returning values from a deferred function has no effect\n-          \"return\",\n-        ]]\n-      - name: duplicated-imports\n-      - name: errorf\n-      - name: string-of-int\n-      - name: time-equal\n-      - name: unconditional-recursion\n-      - name: useless-break\n-      - name: waitgroup-by-value\n+      # These are forks of an upstream package and thus are exempt from stylistic\n+      # changes that would make pulling in upstream changes harder.\n+      - path: tempfork/.*\\.go\n+        text: File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\n+      - path: util/singleflight/.*\\.go\n+        text: File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n+formatters:\n+  enable:\n+    - gofmt\n+    - goimports\n+  settings:\n+    gofmt:\n+      rewrite-rules:\n+        - pattern: interface{}\n+          replacement: any\n+  exclusions:\n+    generated: lax\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n---\n\n\n---\n\nChoice C:\nwgengine/magicsock/magicsock.go\n@@ -138,6 +138,7 @@ type Conn struct {\n \t// struct. Initialized once at construction, then constant.\n \n \teventBus               *eventbus.Bus\n+\teventClient            *eventbus.Client\n \tlogf                   logger.Logf\n \tepFunc                 func([]tailcfg.Endpoint)\n \tderpActiveFunc         func()\n@@ -547,6 +548,31 @@ func NewConn(opts Options) (*Conn, error) {\n \tc.testOnlyPacketListener = opts.TestOnlyPacketListener\n \tc.noteRecvActivity = opts.NoteRecvActivity\n \n+\t// If an event bus is enabled, subscribe to portmapping changes; otherwise\n+\t// use the callback mechanism of portmapper.Client.\n+\t//\n+\t// TODO(creachadair): Remove the switch once the event bus is mandatory.\n+\tonPortMapChanged := c.onPortMapChanged\n+\tif c.eventBus != nil {\n+\t\tc.eventClient = c.eventBus.Client(\"magicsock.Conn\")\n+\n+\t\tpmSub := eventbus.Subscribe[portmapper.Mapping](c.eventClient)\n+\t\tgo func() {\n+\t\t\tdefer pmSub.Close()\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase <-pmSub.Events():\n+\t\t\t\t\tc.onPortMapChanged()\n+\t\t\t\tcase <-pmSub.Done():\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\n+\t\t// Disable the explicit callback from the portmapper, the subscriber handles it.\n+\t\tonPortMapChanged = nil\n+\t}\n+\n \t// Don't log the same log messages possibly every few seconds in our\n \t// portmapper.\n \tportmapperLogf := logger.WithPrefix(c.logf, \"portmapper: \")\n@@ -560,7 +586,7 @@ func NewConn(opts Options) (*Conn, error) {\n \t\tNetMon:       opts.NetMon,\n \t\tDebugKnobs:   portMapOpts,\n \t\tControlKnobs: opts.ControlKnobs,\n-\t\tOnChange:     c.onPortMapChanged,\n+\t\tOnChange:     onPortMapChanged,\n \t})\n \tc.portMapper.SetGatewayLookupFunc(opts.NetMon.GatewayAndSelfIP)\n \tc.netMon = opts.NetMon\n@@ -2478,6 +2504,9 @@ func (c *connBind) Close() error {\n \tif c.closeDisco6 != nil {\n \t\tc.closeDisco6.Close()\n \t}\n+\tif c.eventClient != nil {\n+\t\tc.eventClient.Close()\n+\t}\n \t// Send an empty read result to unblock receiveDERP,\n \t// which will then check connBind.Closed.\n \t// connBind.Closed takes c.mu, but c.derpRecvCh is buffered.\n---\n\n\n---\n\nChoice D:\ncmd/natc/ippool/consensusippool.go\n@@ -10,6 +10,8 @@ import (\n \t\"fmt\"\n \t\"log\"\n \t\"net/netip\"\n+\t\"os\"\n+\t\"path/filepath\"\n \t\"time\"\n \n \t\"github.com/hashicorp/raft\"\n@@ -150,9 +152,14 @@ func (ipp *ConsensusIPPool) domainLookup(from tailcfg.NodeID, addr netip.Addr) (\n }\n \n // StartConsensus is part of the IPPool interface. It starts the raft background routines that handle consensus.\n-func (ipp *ConsensusIPPool) StartConsensus(ctx context.Context, ts *tsnet.Server, clusterTag string) error {\n+func (ipp *ConsensusIPPool) StartConsensus(ctx context.Context, ts *tsnet.Server, clusterTag string, clusterStateDir string) error {\n \tcfg := tsconsensus.DefaultConfig()\n \tcfg.ServeDebugMonitor = true\n+\tvar err error\n+\tcfg.StateDirPath, err = getStatePath(clusterStateDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tcns, err := tsconsensus.Start(ctx, ts, ipp, clusterTag, cfg)\n \tif err != nil {\n \t\treturn err\n@@ -204,6 +211,30 @@ func (ps *consensusPerPeerState) unusedIPV4(ipset *netipx.IPSet, reuseDeadline t\n \treturn netip.Addr{}, false, \"\", errors.New(\"ip pool exhausted\")\n }\n \n+func getStatePath(pathFromFlag string) (string, error) {\n+\tvar dirPath string\n+\tif pathFromFlag != \"\" {\n+\t\tdirPath = pathFromFlag\n+\t} else {\n+\t\tconfDir, err := os.UserConfigDir()\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tdirPath = filepath.Join(confDir, \"nat-connector-cluster-state\")\n+\t}\n+\n+\tif err := os.MkdirAll(dirPath, 0700); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif fi, err := os.Stat(dirPath); err != nil {\n+\t\treturn \"\", err\n+\t} else if !fi.IsDir() {\n+\t\treturn \"\", fmt.Errorf(\"%v is not a directory\", dirPath)\n+\t}\n+\n+\treturn dirPath, nil\n+}\n+\n // isCloseToExpiry returns true if the lastUsed and now times are more than\n // half the lifetime apart\n func isCloseToExpiry(lastUsed, now time.Time, lifetime time.Duration) bool {\n---\ncmd/natc/natc.go\n@@ -59,6 +59,7 @@ func main() {\n \t\twgPort          = fs.Uint(\"wg-port\", 0, \"udp port for wireguard and peer to peer traffic\")\n \t\tclusterTag      = fs.String(\"cluster-tag\", \"\", \"optionally run in a consensus cluster with other nodes with this tag\")\n \t\tserver          = fs.String(\"login-server\", ipn.DefaultControlURL, \"the base URL of control server\")\n+\t\tclusterStateDir = fs.String(\"cluster-state-dir\", \"\", \"path to directory in which to store raft state\")\n \t)\n \tff.Parse(fs, os.Args[1:], ff.WithEnvVarPrefix(\"TS_NATC\"))\n \n@@ -155,7 +156,7 @@ func main() {\n \tvar ipp ippool.IPPool\n \tif *clusterTag != \"\" {\n \t\tcipp := ippool.NewConsensusIPPool(addrPool)\n-\t\terr = cipp.StartConsensus(ctx, ts, *clusterTag)\n+\t\terr = cipp.StartConsensus(ctx, ts, *clusterTag, *clusterStateDir)\n \t\tif err != nil {\n \t\t\tlog.Fatalf(\"StartConsensus: %v\", err)\n \t\t}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis is a hack, but should suffice and be fast enough.\n\nI really want to figure out what's keeping that writable fd open.\n\nFixes #15868\n\n\n---\n\nChoice A:\ntstest/integration/integration.go\n@@ -770,6 +770,27 @@ func (d *Daemon) MustCleanShutdown(t testing.TB) {\n \t}\n }\n \n+// awaitTailscaledRunnable tries to run `tailscaled --version` until it\n+// works. This is an unsatisfying workaround for ETXTBSY we were seeing\n+// on GitHub Actions that aren't understood. It's not clear what's holding\n+// a writable fd to tailscaled after `go install` completes.\n+// See https://github.com/tailscale/tailscale/issues/15868.\n+func (n *TestNode) awaitTailscaledRunnable() error {\n+\tt := n.env.t\n+\tt.Helper()\n+\tif err := tstest.WaitFor(10*time.Second, func() error {\n+\t\tout, err := exec.Command(n.env.daemon, \"--version\").CombinedOutput()\n+\t\tif err == nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\tt.Logf(\"error running tailscaled --version: %v, %s\", err, out)\n+\t\treturn err\n+\t}); err != nil {\n+\t\treturn fmt.Errorf(\"gave up trying to run tailscaled: %v\", err)\n+\t}\n+\treturn nil\n+}\n+\n // StartDaemon starts the node's tailscaled, failing if it fails to start.\n // StartDaemon ensures that the process will exit when the test completes.\n func (n *TestNode) StartDaemon() *Daemon {\n@@ -778,6 +799,11 @@ func (n *TestNode) StartDaemon() *Daemon {\n \n func (n *TestNode) StartDaemonAsIPNGOOS(ipnGOOS string) *Daemon {\n \tt := n.env.t\n+\n+\tif err := n.awaitTailscaledRunnable(); err != nil {\n+\t\tt.Fatalf(\"awaitTailscaledRunnable: %v\", err)\n+\t}\n+\n \tcmd := exec.Command(n.env.daemon)\n \tcmd.Args = append(cmd.Args,\n \t\t\"--statedir=\"+n.dir,\n---\n\n\n---\n\nChoice B:\nnet/portmapper/igd_test.go\n@@ -18,8 +18,10 @@ import (\n \t\"tailscale.com/net/netaddr\"\n \t\"tailscale.com/net/netmon\"\n \t\"tailscale.com/syncs\"\n+\t\"tailscale.com/tstest\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/eventbus\"\n+\t\"tailscale.com/util/testenv\"\n )\n \n // TestIGD is an IGD (Internet Gateway Device) for testing. It supports fake\n@@ -64,7 +66,8 @@ type igdCounters struct {\n \tinvalidPCPMapPkt int32\n }\n \n-func NewTestIGD(logf logger.Logf, t TestIGDOptions) (*TestIGD, error) {\n+func NewTestIGD(tb testenv.TB, t TestIGDOptions) (*TestIGD, error) {\n+\tlogf := tstest.WhileTestRunningLogger(tb)\n \td := &TestIGD{\n \t\tdoPMP:  t.PMP,\n \t\tdoPCP:  t.PCP,\n@@ -265,7 +268,7 @@ func (d *TestIGD) handlePCPQuery(pkt []byte, src netip.AddrPort) {\n func newTestClient(t *testing.T, igd *TestIGD, bus *eventbus.Bus) *Client {\n \tvar c *Client\n \tc = NewClient(Config{\n-\t\tLogf:         t.Logf,\n+\t\tLogf:         tstest.WhileTestRunningLogger(t),\n \t\tNetMon:       netmon.NewStatic(),\n \t\tControlKnobs: new(controlknobs.Knobs),\n \t\tEventBus:     bus,\n---\nnet/portmapper/portmapper_test.go\n@@ -61,7 +61,7 @@ func TestClientProbeThenMap(t *testing.T) {\n }\n \n func TestProbeIntegration(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PMP: true, PCP: true, UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PMP: true, PCP: true, UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -95,7 +95,7 @@ func TestProbeIntegration(t *testing.T) {\n }\n \n func TestPCPIntegration(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PMP: false, PCP: true, UPnP: false})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PMP: false, PCP: true, UPnP: false})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -137,7 +137,7 @@ func TestGetUPnPErrorsMetric(t *testing.T) {\n }\n \n func TestUpdateEvent(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PCP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PCP: true})\n \tif err != nil {\n \t\tt.Fatalf(\"Create test gateway: %v\", err)\n \t}\n---\nnet/portmapper/select_test.go\n@@ -28,7 +28,7 @@ func TestSelectBestService(t *testing.T) {\n \t}\n \n \t// Run a fake IGD server to respond to UPnP requests.\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/portmapper/upnp_test.go\n@@ -533,7 +533,7 @@ func TestGetUPnPClient(t *testing.T) {\n }\n \n func TestGetUPnPPortMapping(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -672,7 +672,7 @@ func TestGetUPnPPortMapping_LeaseDuration(t *testing.T) {\n \t\t\t\t\"DeletePortMapping\":    \"\", // Do nothing for test\n \t\t\t}\n \n-\t\t\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\t\t\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n@@ -722,7 +722,7 @@ func TestGetUPnPPortMapping_LeaseDuration(t *testing.T) {\n //\n // See https://github.com/tailscale/tailscale/issues/10911\n func TestGetUPnPPortMapping_NoValidServices(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -753,7 +753,7 @@ func TestGetUPnPPortMapping_NoValidServices(t *testing.T) {\n \n // Tests the legacy behaviour with the pre-UPnP standard portmapping service.\n func TestGetUPnPPortMapping_Legacy(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -796,7 +796,7 @@ func TestGetUPnPPortMapping_Legacy(t *testing.T) {\n }\n \n func TestGetUPnPPortMappingNoResponses(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -912,7 +912,7 @@ func TestGetUPnPPortMapping_Invalid(t *testing.T) {\n \t\t\"127.0.0.1\",\n \t} {\n \t\tt.Run(responseAddr, func(t *testing.T) {\n-\t\t\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\t\t\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n---\ntstest/log.go\n@@ -13,6 +13,7 @@ import (\n \n \t\"go4.org/mem\"\n \t\"tailscale.com/types/logger\"\n+\t\"tailscale.com/util/testenv\"\n )\n \n type testLogWriter struct {\n@@ -149,7 +150,7 @@ func (ml *MemLogger) String() string {\n \n // WhileTestRunningLogger returns a logger.Logf that logs to t.Logf until the\n // test finishes, at which point it no longer logs anything.\n-func WhileTestRunningLogger(t testing.TB) logger.Logf {\n+func WhileTestRunningLogger(t testenv.TB) logger.Logf {\n \tvar (\n \t\tmu   sync.RWMutex\n \t\tdone bool\n---\n\n\n---\n\nChoice C:\nfeature/relayserver/relayserver.go\n@@ -72,10 +72,20 @@ func (e *extension) Init(host ipnext.Host) error {\n \tprofile, prefs := host.Profiles().CurrentProfileState()\n \te.profileStateChanged(profile, prefs, false)\n \thost.Hooks().ProfileStateChange.Add(e.profileStateChanged)\n-\t// TODO(jwhited): callback for netmap/nodeattr changes (e.hasNodeAttrRelayServer)\n+\thost.Hooks().OnSelfChange.Add(e.selfNodeViewChanged)\n \treturn nil\n }\n \n+func (e *extension) selfNodeViewChanged(nodeView tailcfg.NodeView) {\n+\te.mu.Lock()\n+\tdefer e.mu.Unlock()\n+\te.hasNodeAttrRelayServer = nodeView.HasCap(tailcfg.NodeAttrRelayServer)\n+\tif !e.hasNodeAttrRelayServer && e.server != nil {\n+\t\te.server.Close()\n+\t\te.server = nil\n+\t}\n+}\n+\n func (e *extension) profileStateChanged(_ ipn.LoginProfileView, prefs ipn.PrefsView, sameNode bool) {\n \te.mu.Lock()\n \tdefer e.mu.Unlock()\n---\n\n\n---\n\nChoice D:\ncmd/derper/cert_test.go\n@@ -140,6 +140,15 @@ func TestPinnedCertRawIP(t *testing.T) {\n \tvar hs http.Server\n \ths.Handler = mux\n \ths.TLSConfig = cp.TLSConfig()\n+\tgetCert := hs.TLSConfig.GetCertificate\n+\ths.TLSConfig.GetCertificate=func(hi *tls.ClientHelloInfo) (*tls.Certificate, error) {\n+\t\tcert, err := getCert(hi)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tcert.Certificate = append(cert.Certificate, ds.MetaCert())\n+\t\treturn cert, nil\n+\t}\n \tgo hs.ServeTLS(ln, \"\", \"\")\n \n \tlnPort := ln.Addr().(*net.TCPAddr).Port\n---\nnet/tlsdial/tlsdial.go\n@@ -263,7 +263,7 @@ func SetConfigExpectedCertHash(c *tls.Config, wantFullCertSHA256Hex string) {\n \t\tif len(rawCerts) == 0 {\n \t\t\treturn errors.New(\"no certs presented\")\n \t\t}\n-\t\tif len(rawCerts) > 1 {\n+\t\tif len(rawCerts) > 2 {\n \t\t\treturn errors.New(\"unexpected multiple certs presented\")\n \t\t}\n \t\tif fmt.Sprintf(\"%02x\", sha256.Sum256(rawCerts[0])) != wantFullCertSHA256Hex {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nrelayManager will eventually be responsible for handling the allocation and handshaking of UDP relay server endpoints.\r\n\r\nrelay servers are endpoint-independent, and Conn must already maintain handshake state for all endpoints. This justifies a new data structure to fill these roles.\r\n\r\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\nipn/ipnlocal/extension_host_test.go\n@@ -284,7 +284,7 @@ func TestNewExtensionHost(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tt.Parallel()\n \t\t\tlogf := tstest.WhileTestRunningLogger(t)\n-\t\t\th, err := NewExtensionHost(logf, &tsd.System{}, &testBackend{}, tt.defs...)\n+\t\t\th, err := NewExtensionHost(logf, tsd.NewSystem(), &testBackend{}, tt.defs...)\n \t\t\tif gotErr := err != nil; gotErr != tt.wantErr {\n \t\t\t\tt.Errorf(\"NewExtensionHost: gotErr %v(%v); wantErr %v\", gotErr, err, tt.wantErr)\n \t\t\t}\n@@ -1118,7 +1118,7 @@ func newExtensionHostForTest[T ipnext.Extension](t *testing.T, b Backend, initia\n \t\t}\n \t\tdefs[i] = ipnext.DefinitionForTest(ext)\n \t}\n-\th, err := NewExtensionHost(logf, &tsd.System{}, b, defs...)\n+\th, err := NewExtensionHost(logf, tsd.NewSystem(), b, defs...)\n \tif err != nil {\n \t\tt.Fatalf(\"NewExtensionHost: %v\", err)\n \t}\n---\nipn/ipnlocal/state_test.go\n@@ -1397,7 +1397,7 @@ func newLocalBackendWithMockEngineAndControl(t *testing.T, enableLogging bool) (\n \tdialer := &tsdial.Dialer{Logf: logf}\n \tdialer.SetNetMon(netmon.NewStatic())\n \n-\tsys := &tsd.System{}\n+\tsys := tsd.NewSystem()\n \tsys.Set(dialer)\n \tsys.Set(dialer.NetMon())\n \n---\n\n\n---\n\nChoice B:\nwgengine/magicsock/magicsock.go\n@@ -317,7 +317,11 @@ type Conn struct {\n \t// by node key, node ID, and discovery key.\n \tpeerMap peerMap\n \n-\t// discoInfo is the state for an active DiscoKey.\n+\t// relayManager manages allocation and handshaking of\n+\t// [tailscale.com/net/udprelay.Server] endpoints.\n+\trelayManager relayManager\n+\n+\t// discoInfo is the state for an active peer DiscoKey.\n \tdiscoInfo map[key.DiscoPublic]*discoInfo\n \n \t// netInfoFunc is a callback that provides a tailcfg.NetInfo when\n@@ -1628,9 +1632,11 @@ func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey ke\n \tvar di *discoInfo\n \tswitch {\n \tcase isRelayHandshakeMsg:\n-\t\t// TODO(jwhited): consider caching relay server disco shared keys\n-\t\tdi = &discoInfo{\n-\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n+\t\tvar ok bool\n+\t\tdi, ok = c.relayManager.discoInfo(dstDisco)\n+\t\tif !ok {\n+\t\t\tc.mu.Unlock()\n+\t\t\treturn false, errors.New(\"unknown relay server\")\n \t\t}\n \tcase c.peerMap.knownPeerDiscoKey(dstDisco):\n \t\tdi = c.discoInfoForKnownPeerLocked(dstDisco)\n@@ -1806,7 +1812,7 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \tswitch {\n \tcase shouldBeRelayHandshakeMsg:\n \t\tvar ok bool\n-\t\tdi, ok = c.discoInfoForRelayHandshakeLocked(sender, geneve.VNI)\n+\t\tdi, ok = c.relayManager.discoInfo(sender)\n \t\tif !ok {\n \t\t\tif debugDisco() {\n \t\t\t\tc.logf(\"magicsock: disco: ignoring disco-looking relay handshake frame, no active handshakes with key %v over VNI %d\", sender.ShortString(), geneve.VNI)\n@@ -1882,15 +1888,15 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t}\n \n \tif shouldBeRelayHandshakeMsg {\n-\t\t_, ok := dm.(*disco.BindUDPRelayEndpointChallenge)\n+\t\tchallenge, ok := dm.(*disco.BindUDPRelayEndpointChallenge)\n \t\tif !ok {\n \t\t\t// We successfully parsed the disco message, but it wasn't a\n \t\t\t// challenge. We should never receive other message types\n \t\t\t// from a relay server with the Geneve header control bit set.\n \t\t\tc.logf(\"[unexpected] %T packets should not come from a relay server with Geneve control bit set\", dm)\n \t\t\treturn\n \t\t}\n-\t\t// TODO(jwhited): handle the challenge on the associated [*endpoint]\n+\t\tc.relayManager.handleBindUDPRelayEndpointChallenge(challenge, di, src, geneve.VNI)\n \t\treturn\n \t}\n \n@@ -1909,18 +1915,28 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t\t\t}\n \t\t\treturn true\n \t\t})\n-\tcase *disco.CallMeMaybe:\n+\tcase *disco.CallMeMaybe, *disco.CallMeMaybeVia:\n+\t\tvar via *disco.CallMeMaybeVia\n+\t\tisVia := false\n+\t\tmsgType := \"CallMeMaybe\"\n+\t\tcmm, ok := dm.(*disco.CallMeMaybe)\n+\t\tif !ok {\n+\t\t\tvia = dm.(*disco.CallMeMaybeVia)\n+\t\t\tmsgType = \"CallMeMaybeVia\"\n+\t\t\tisVia = true\n+\t\t}\n+\n \t\tmetricRecvDiscoCallMeMaybe.Add(1)\n \t\tif !isDERP || derpNodeSrc.IsZero() {\n-\t\t\t// CallMeMaybe messages should only come via DERP.\n-\t\t\tc.logf(\"[unexpected] CallMeMaybe packets should only come via DERP\")\n+\t\t\t// CallMeMaybe{Via} messages should only come via DERP.\n+\t\t\tc.logf(\"[unexpected] %s packets should only come via DERP\", msgType)\n \t\t\treturn\n \t\t}\n \t\tnodeKey := derpNodeSrc\n \t\tep, ok := c.peerMap.endpointForNodeKey(nodeKey)\n \t\tif !ok {\n \t\t\tmetricRecvDiscoCallMeMaybeBadNode.Add(1)\n-\t\t\tc.logf(\"magicsock: disco: ignoring CallMeMaybe from %v; %v is unknown\", sender.ShortString(), derpNodeSrc.ShortString())\n+\t\t\tc.logf(\"magicsock: disco: ignoring %s from %v; %v is unknown\", msgType, sender.ShortString(), derpNodeSrc.ShortString())\n \t\t\treturn\n \t\t}\n \t\tepDisco := ep.disco.Load()\n@@ -1929,14 +1945,23 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t\t}\n \t\tif epDisco.key != di.discoKey {\n \t\t\tmetricRecvDiscoCallMeMaybeBadDisco.Add(1)\n-\t\t\tc.logf(\"[unexpected] CallMeMaybe from peer via DERP whose netmap discokey != disco source\")\n+\t\t\tc.logf(\"[unexpected] %s from peer via DERP whose netmap discokey != disco source\", msgType)\n \t\t\treturn\n \t\t}\n-\t\tc.dlogf(\"[v1] magicsock: disco: %v<-%v (%v, %v)  got call-me-maybe, %d endpoints\",\n-\t\t\tc.discoShort, epDisco.short,\n-\t\t\tep.publicKey.ShortString(), derpStr(src.String()),\n-\t\t\tlen(dm.MyNumber))\n-\t\tgo ep.handleCallMeMaybe(dm)\n+\t\tif isVia {\n+\t\t\tc.dlogf(\"[v1] magicsock: disco: %v<-%v via %v (%v, %v)  got call-me-maybe-via, %d endpoints\",\n+\t\t\t\tc.discoShort, epDisco.short, via.ServerDisco.ShortString(),\n+\t\t\t\tep.publicKey.ShortString(), derpStr(src.String()),\n+\t\t\t\tlen(via.AddrPorts))\n+\t\t\tc.relayManager.handleCallMeMaybeVia(via)\n+\t\t} else {\n+\t\t\tc.dlogf(\"[v1] magicsock: disco: %v<-%v (%v, %v)  got call-me-maybe, %d endpoints\",\n+\t\t\t\tc.discoShort, epDisco.short,\n+\t\t\t\tep.publicKey.ShortString(), derpStr(src.String()),\n+\t\t\t\tlen(cmm.MyNumber))\n+\t\t\tgo ep.handleCallMeMaybe(cmm)\n+\t\t}\n+\n \t}\n \treturn\n }\n@@ -2108,15 +2133,6 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \t}\n }\n \n-// discoInfoForRelayHandshakeLocked returns a [*discoInfo] for k and vni if one\n-// is known, i.e. an [endpoint] has an in-progress handshake with k over vni.\n-//\n-// c.mu must be held\n-func (c *Conn) discoInfoForRelayHandshakeLocked(k key.DiscoPublic, vni uint32) (*discoInfo, bool) {\n-\t// TODO(jwhited): implement\n-\treturn nil, false\n-}\n-\n // discoInfoForKnownPeerLocked returns the previous or new discoInfo for k.\n //\n // Callers must only pass key.DiscoPublic's that are present in and\n---\nwgengine/magicsock/relaymanager.go\n@@ -0,0 +1,51 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package magicsock\n+\n+import (\n+\t\"net/netip\"\n+\t\"sync\"\n+\n+\t\"tailscale.com/disco\"\n+\t\"tailscale.com/types/key\"\n+)\n+\n+// relayManager manages allocation and handshaking of\n+// [tailscale.com/net/udprelay.Server] endpoints. The zero value is ready for\n+// use.\n+type relayManager struct {\n+\tmu                     sync.Mutex // guards the following fields\n+\tdiscoInfoByServerDisco map[key.DiscoPublic]*discoInfo\n+}\n+\n+func (h *relayManager) initLocked() {\n+\tif h.discoInfoByServerDisco != nil {\n+\t\treturn\n+\t}\n+\th.discoInfoByServerDisco = make(map[key.DiscoPublic]*discoInfo)\n+}\n+\n+// discoInfo returns a [*discoInfo] for 'serverDisco' if there is an\n+// active/ongoing handshake with it, otherwise it returns nil, false.\n+func (h *relayManager) discoInfo(serverDisco key.DiscoPublic) (_ *discoInfo, ok bool) {\n+\th.mu.Lock()\n+\tdefer h.mu.Unlock()\n+\th.initLocked()\n+\tdi, ok := h.discoInfoByServerDisco[serverDisco]\n+\treturn di, ok\n+}\n+\n+func (h *relayManager) handleCallMeMaybeVia(dm *disco.CallMeMaybeVia) {\n+\th.mu.Lock()\n+\tdefer h.mu.Unlock()\n+\th.initLocked()\n+\t// TODO(jwhited): implement\n+}\n+\n+func (h *relayManager) handleBindUDPRelayEndpointChallenge(dm *disco.BindUDPRelayEndpointChallenge, di *discoInfo, src netip.AddrPort, vni uint32) {\n+\th.mu.Lock()\n+\tdefer h.mu.Unlock()\n+\th.initLocked()\n+\t// TODO(jwhited): implement\n+}\n---\n\n\n---\n\nChoice C:\nclient/tailscale/acl.go\n@@ -50,6 +50,18 @@ type NodeAttrGrant struct {\n \tAttr []string `json:\"attr,omitempty\"`\n }\n \n+// ACLAttrConfig defines the configuration for a custom attribute.\n+type ACLAttrConfig struct {\n+\t// Type specifies the attribute type. Valid values: \"string\", \"number\", \"bool\".\n+\tType string `json:\"type,omitempty\"`\n+\n+\t// AllowSetByNode allows nodes to set this attribute themselves.\n+\tAllowSetByNode bool `json:\"allowSetByNode,omitempty\"`\n+\n+\t// BroadcastToPeers lists target nodes to receive this attribute value.\n+\tBroadcastToPeers []string `json:\"broadcastToPeers,omitempty\"`\n+}\n+\n // ACLDetails contains all the details for an ACL.\n type ACLDetails struct {\n \tTests     []ACLTest           `json:\"tests,omitempty\"`\n@@ -58,6 +70,9 @@ type ACLDetails struct {\n \tTagOwners map[string][]string `json:\"tagowners,omitempty\"`\n \tHosts     map[string]string   `json:\"hosts,omitempty\"`\n \tNodeAttrs []NodeAttrGrant     `json:\"nodeAttrs,omitempty\"`\n+\n+\t// AttrConfig maps attribute names to their configuration.\n+\tAttrConfig map[string]ACLAttrConfig `json:\"attrConfig,omitempty\"`\n }\n \n // ACL contains an ACLDetails and metadata.\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/peerapi.go\n@@ -1135,7 +1135,7 @@ func (h *peerAPIHandler) handleServeDrive(w http.ResponseWriter, r *http.Request\n \n \tp, err := drive.ParsePermissions(rawPerms)\n \tif err != nil {\n-\t\th.logf(\"taildrive: error parsing permissions: %w\", err.Error())\n+\t\th.logf(\"taildrive: error parsing permissions: %v\", err)\n \t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n \t\treturn\n \t}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nConn.handleDiscoMessage() now makes a distinction between relay handshake disco messages and peer disco messages.\r\n\r\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\nclient/systray/logo.go\n@@ -11,10 +11,12 @@ import (\n \t\"image\"\n \t\"image/color\"\n \t\"image/png\"\n+\t\"runtime\"\n \t\"sync\"\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/fogleman/gg\"\n )\n \n@@ -251,7 +253,13 @@ func (logo tsLogo) renderWithBorder(borderUnits int) *bytes.Buffer {\n \t}\n \n \tb := bytes.NewBuffer(nil)\n-\tpng.Encode(b, dc.Image())\n+\n+\t// Encode as ICO format on Windows, PNG on all other platforms.\n+\tif runtime.GOOS == \"windows\" {\n+\t\t_ = ico.Encode(b, dc.Image())\n+\t} else {\n+\t\t_ = png.Encode(b, dc.Image())\n+\t}\n \treturn b\n }\n \n---\nclient/systray/systray.go\n@@ -7,9 +7,11 @@\n package systray\n \n import (\n+\t\"bytes\"\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"image\"\n \t\"io\"\n \t\"log\"\n \t\"net/http\"\n@@ -23,6 +25,7 @@ import (\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/atotto/clipboard\"\n \tdbus \"github.com/godbus/dbus/v5\"\n \t\"github.com/toqueteos/webbrowser\"\n@@ -330,6 +333,20 @@ func setRemoteIcon(menu *systray.MenuItem, urlStr string) {\n \t\tresp, err := http.Get(urlStr)\n \t\tif err == nil && resp.StatusCode == http.StatusOK {\n \t\t\tb, _ = io.ReadAll(resp.Body)\n+\n+\t\t\t// Convert image to ICO format on Windows\n+\t\t\tif runtime.GOOS == \"windows\" {\n+\t\t\t\tim, _, err := image.Decode(bytes.NewReader(b))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tbuf := bytes.NewBuffer(nil)\n+\t\t\t\tif err := ico.Encode(buf, im); err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tb = buf.Bytes()\n+\t\t\t}\n+\n \t\t\thttpCache[urlStr] = b\n \t\t\tresp.Body.Close()\n \t\t}\n---\ngo.mod\n@@ -4,7 +4,8 @@ go 1.24.0\n \n require (\n \tfilippo.io/mkcert v1.4.4\n-\tfyne.io/systray v1.11.0\n+\tfyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a\n+\tgithub.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9\n \tgithub.com/akutz/memconn v0.1.0\n \tgithub.com/alexbrainman/sspi v0.0.0-20231016080023-1a75b4708caa\n \tgithub.com/andybalholm/brotli v1.1.0\n@@ -100,7 +101,7 @@ require (\n \tgolang.org/x/net v0.36.0\n \tgolang.org/x/oauth2 v0.26.0\n \tgolang.org/x/sync v0.11.0\n-\tgolang.org/x/sys v0.30.0\n+\tgolang.org/x/sys v0.31.0\n \tgolang.org/x/term v0.29.0\n \tgolang.org/x/time v0.10.0\n \tgolang.org/x/tools v0.30.0\n---\ngo.sum\n@@ -41,8 +41,8 @@ filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\n filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\n filippo.io/mkcert v1.4.4 h1:8eVbbwfVlaqUM7OwuftKc2nuYOoTDQWqsoXmzoXZdbc=\n filippo.io/mkcert v1.4.4/go.mod h1:VyvOchVuAye3BoUsPUOOofKygVwLV2KQMVFJNRq+1dA=\n-fyne.io/systray v1.11.0 h1:D9HISlxSkx+jHSniMBR6fCFOUjk1x/OOOJLa9lJYAKg=\n-fyne.io/systray v1.11.0/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a h1:I8mEKo5sawHu8CqYf3FSjIl9b3puXasFVn2D/hrCneY=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n github.com/4meepo/tagalign v1.3.3 h1:ZsOxcwGD/jP4U/aw7qeWu58i7dwYemfy5Y+IF1ACoNw=\n github.com/4meepo/tagalign v1.3.3/go.mod h1:Q9c1rYMZJc9dPRkbQPpcBNCLEmY2njbAsXhQOZFE2dE=\n github.com/Abirdcfly/dupword v0.0.14 h1:3U4ulkc8EUo+CaT105/GJ1BQwtgyj6+VaBVbAX11Ba8=\n@@ -67,6 +67,8 @@ github.com/Djarvur/go-err113 v0.1.0 h1:uCRZZOdMQ0TZPHYTdYpoC0bLYJKPEHPUJ8MeAa51l\n github.com/Djarvur/go-err113 v0.1.0/go.mod h1:4UJr5HIiMZrwgkSPdsjy2uOQExX/WEILpIrO9UPGuXs=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0 h1:sATXp1x6/axKxz2Gjxv8MALP0bXaNRfQinEwyfMcx8c=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0/go.mod h1:Nl76DrGNJTA1KJ0LePKBw/vznBX1EHbAZX8mwjR82nI=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9 h1:1ltqoej5GtaWF8jaiA49HwsZD459jqm9YFz9ZtMFpQA=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9/go.mod h1:7uhhqiBaR4CpN0k9rMjOtjpcfGd6DG2m04zQxKnWQ0I=\n github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\n github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\n github.com/Masterminds/semver v1.5.0 h1:H65muMkzWKEuNDnfl9d70GUjFniHKHRbFPGBuZ3QEww=\n@@ -1218,8 +1220,8 @@ golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n-golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=\n-golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=\n+golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/peerapi.go\n@@ -417,7 +417,7 @@ func (h *peerAPIHandler) handleServeIngress(w http.ResponseWriter, r *http.Reque\n \t}\n \tlogAndError := func(code int, publicMsg string) {\n \t\th.logf(\"ingress: bad request from %v: %s\", h.remoteAddr, publicMsg)\n-\t\thttp.Error(w, publicMsg, http.StatusMethodNotAllowed)\n+\t\thttp.Error(w, publicMsg, code)\n \t}\n \tbad := func(publicMsg string) {\n \t\tlogAndError(http.StatusBadRequest, publicMsg)\n---\n\n\n---\n\nChoice C:\ncmd/tailscale/cli/cli_test.go\n@@ -1659,3 +1659,51 @@ func TestSingleUseStringFlag(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestSingleUseStringFlagsSetTwice(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tflagName string\n+\t\tvals     []string\n+\t\tsetup    func(*upArgsT) flag.Value\n+\t}{\n+\t\t{\n+\t\t\tname:     \"advertise-tags\",\n+\t\t\tflagName: \"advertise-tags\",\n+\t\t\tvals:     []string{\"tag:foo\", \"tag:bar\"},\n+\t\t\tsetup: func(u *upArgsT) flag.Value {\n+\t\t\t\treturn &u.advertiseTags\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"advertise-routes\",\n+\t\t\tflagName: \"advertise-routes\",\n+\t\t\tvals:     []string{\"10.0.0.0/8\", \"192.168.0.0/16\"},\n+\t\t\tsetup: func(u *upArgsT) flag.Value {\n+\t\t\t\treturn &u.advertiseRoutes\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tvar upArgs upArgsT\n+\t\t\tfs := flag.NewFlagSet(\"test\", flag.ContinueOnError)\n+\t\t\tfs.SetOutput(io.Discard)\n+\n+\t\t\tfs.Var(tt.setup(&upArgs), tt.flagName, \"\")\n+\t\t\targs := []string{\n+\t\t\t\tfmt.Sprintf(\"--%s=%s\", tt.flagName, tt.vals[0]),\n+\t\t\t\tfmt.Sprintf(\"--%s=%s\", tt.flagName, tt.vals[1]),\n+\t\t\t}\n+\n+\t\t\terr := fs.Parse(args)\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatal(\"expected error when setting flag twice, got nil\")\n+\t\t\t}\n+\t\t\tif !strings.Contains(err.Error(), \"flag can only be specified once\") {\n+\t\t\t\tt.Errorf(\"unexpected error message: %v\", err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice D:\nwgengine/magicsock/magicsock.go\n@@ -1627,13 +1627,13 @@ func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey ke\n \t}\n \tvar di *discoInfo\n \tswitch {\n-\tcase c.peerMap.knownPeerDiscoKey(dstDisco):\n-\t\tdi = c.discoInfoForKnownPeerLocked(dstDisco)\n \tcase isRelayHandshakeMsg:\n \t\t// TODO(jwhited): consider caching relay server disco shared keys\n \t\tdi = &discoInfo{\n \t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n \t\t}\n+\tcase c.peerMap.knownPeerDiscoKey(dstDisco):\n+\t\tdi = c.discoInfoForKnownPeerLocked(dstDisco)\n \tdefault:\n \t\t// This is an attempt to send to an unknown peer that is not a relay\n \t\t// server. This can happen when a call to the current function, which is\n@@ -1768,10 +1768,22 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \tif !isDiscoMsg {\n \t\treturn\n \t}\n+\tvar geneve packet.GeneveHeader\n \tif isGeneveEncap {\n-\t\t// TODO(jwhited): decode Geneve header\n+\t\terr := geneve.Decode(msg)\n+\t\tif err != nil {\n+\t\t\t// Decode only returns an error when 'msg' is too short, and\n+\t\t\t// 'isGeneveEncap' indicates it's a sufficient length.\n+\t\t\tc.logf(\"[unexpected] geneve header decoding error: %v\", err)\n+\t\t\treturn\n+\t\t}\n \t\tmsg = msg[packet.GeneveFixedHeaderLength:]\n \t}\n+\t// The control bit should only be set for relay handshake messages\n+\t// terminating on or originating from a UDP relay server. We have yet to\n+\t// open the encrypted payload to determine the [disco.MessageType], but\n+\t// we assert it should be handshake-related.\n+\tshouldBeRelayHandshakeMsg := isGeneveEncap && geneve.Control\n \n \tsender := key.DiscoPublicFromRaw32(mem.B(msg[len(disco.Magic):discoHeaderLen]))\n \n@@ -1790,11 +1802,20 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t\treturn\n \t}\n \n-\tif !c.peerMap.knownPeerDiscoKey(sender) {\n-\t\t// Geneve encapsulated disco used for udp relay handshakes are not known\n-\t\t// \"peer\" keys as they are dynamically discovered by UDP relay endpoint\n-\t\t// allocation or [disco.CallMeMaybeVia] reception.\n-\t\t// TODO(jwhited): handle relay handshake messsages instead of early return\n+\tvar di *discoInfo\n+\tswitch {\n+\tcase shouldBeRelayHandshakeMsg:\n+\t\tvar ok bool\n+\t\tdi, ok = c.discoInfoForRelayHandshakeLocked(sender, geneve.VNI)\n+\t\tif !ok {\n+\t\t\tif debugDisco() {\n+\t\t\t\tc.logf(\"magicsock: disco: ignoring disco-looking relay handshake frame, no active handshakes with key %v over VNI %d\", sender.ShortString(), geneve.VNI)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\tcase c.peerMap.knownPeerDiscoKey(sender):\n+\t\tdi = c.discoInfoForKnownPeerLocked(sender)\n+\tdefault:\n \t\tmetricRecvDiscoBadPeer.Add(1)\n \t\tif debugDisco() {\n \t\t\tc.logf(\"magicsock: disco: ignoring disco-looking frame, don't know of key %v\", sender.ShortString())\n@@ -1803,25 +1824,21 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t}\n \n \tisDERP := src.Addr() == tailcfg.DerpMagicIPAddr\n-\tif !isDERP {\n+\tif !isDERP && !shouldBeRelayHandshakeMsg {\n \t\t// Record receive time for UDP transport packets.\n \t\tpi, ok := c.peerMap.byIPPort[src]\n \t\tif ok {\n \t\t\tpi.ep.lastRecvUDPAny.StoreAtomic(mono.Now())\n \t\t}\n \t}\n \n-\t// We're now reasonably sure we're expecting communication from\n-\t// this peer, do the heavy crypto lifting to see what they want.\n-\t//\n-\t// From here on, peerNode and de are non-nil.\n-\n-\tdi := c.discoInfoForKnownPeerLocked(sender)\n+\t// We're now reasonably sure we're expecting communication from 'sender',\n+\t// do the heavy crypto lifting to see what they want.\n \n \tsealedBox := msg[discoHeaderLen:]\n \tpayload, ok := di.sharedKey.Open(sealedBox)\n \tif !ok {\n-\t\t// This might be have been intended for a previous\n+\t\t// This might have been intended for a previous\n \t\t// disco key.  When we restart we get a new disco key\n \t\t// and old packets might've still been in flight (or\n \t\t// scheduled). This is particularly the case for LANs\n@@ -1864,6 +1881,19 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t\tmetricRecvDiscoUDP.Add(1)\n \t}\n \n+\tif shouldBeRelayHandshakeMsg {\n+\t\t_, ok := dm.(*disco.BindUDPRelayEndpointChallenge)\n+\t\tif !ok {\n+\t\t\t// We successfully parsed the disco message, but it wasn't a\n+\t\t\t// challenge. We should never receive other message types\n+\t\t\t// from a relay server with the Geneve header control bit set.\n+\t\t\tc.logf(\"[unexpected] %T packets should not come from a relay server with Geneve control bit set\", dm)\n+\t\t\treturn\n+\t\t}\n+\t\t// TODO(jwhited): handle the challenge on the associated [*endpoint]\n+\t\treturn\n+\t}\n+\n \tswitch dm := dm.(type) {\n \tcase *disco.Ping:\n \t\tmetricRecvDiscoPing.Add(1)\n@@ -2078,6 +2108,15 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \t}\n }\n \n+// discoInfoForRelayHandshakeLocked returns a [*discoInfo] for k and vni if one\n+// is known, i.e. an [endpoint] has an in-progress handshake with k over vni.\n+//\n+// c.mu must be held\n+func (c *Conn) discoInfoForRelayHandshakeLocked(k key.DiscoPublic, vni uint32) (*discoInfo, bool) {\n+\t// TODO(jwhited): implement\n+\treturn nil, false\n+}\n+\n // discoInfoForKnownPeerLocked returns the previous or new discoInfo for k.\n //\n // Callers must only pass key.DiscoPublic's that are present in and\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes #15818\n\n\n---\n\nChoice A:\ncmd/tailscaled/tailscaled.go\n@@ -151,10 +151,33 @@ var subCommands = map[string]*func([]string) error{\n \t\"serve-taildrive\":         &serveDriveFunc,\n }\n \n-var beCLI func() // non-nil if CLI is linked in\n+var beCLI func() // non-nil if CLI is linked in with the \"ts_include_cli\" build tag\n+\n+// shouldRunCLI reports whether we should run the Tailscale CLI (cmd/tailscale)\n+// instead of the daemon (cmd/tailscaled) in the case when the two are linked\n+// together into one binary for space savings reasons.\n+func shouldRunCLI() bool {\n+\tif beCLI == nil {\n+\t\t// Not linked in with the \"ts_include_cli\" build tag.\n+\t\treturn false\n+\t}\n+\tif len(os.Args) > 0 && filepath.Base(os.Args[0]) == \"tailscale\" {\n+\t\t// The binary was named (or hardlinked) as \"tailscale\".\n+\t\treturn true\n+\t}\n+\tif envknob.Bool(\"TS_BE_CLI\") {\n+\t\t// The environment variable was set to force it.\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n \n func main() {\n \tenvknob.PanicIfAnyEnvCheckedInInit()\n+\tif shouldRunCLI() {\n+\t\tbeCLI()\n+\t\treturn\n+\t}\n \tenvknob.ApplyDiskConfig()\n \tapplyIntegrationTestEnvKnob()\n \n@@ -175,11 +198,6 @@ func main() {\n \tflag.BoolVar(&args.disableLogs, \"no-logs-no-support\", false, \"disable log uploads; this also disables any technical support\")\n \tflag.StringVar(&args.confFile, \"config\", \"\", \"path to config file, or 'vm:user-data' to use the VM's user-data (EC2)\")\n \n-\tif len(os.Args) > 0 && filepath.Base(os.Args[0]) == \"tailscale\" && beCLI != nil {\n-\t\tbeCLI()\n-\t\treturn\n-\t}\n-\n \tif len(os.Args) > 1 {\n \t\tsub := os.Args[1]\n \t\tif fp, ok := subCommands[sub]; ok {\n---\n\n\n---\n\nChoice B:\ncmd/tsidp/README.md\n@@ -35,7 +35,7 @@\n \n    ```bash\n    docker run -d \\\n-     --name `tsidp` \\\n+     --name tsidp \\\n      -p 443:443 \\\n      -e TS_AUTHKEY=YOUR_TAILSCALE_AUTHKEY \\\n      -e TS_HOSTNAME=idp \\\n---\n\n\n---\n\nChoice C:\n.github/CONTRIBUTING.md\n@@ -0,0 +1,17 @@\n+PRs welcome! But please file bugs first and explain the problem or\n+motivation. For new or changed functionality, strike up a discussion\n+and get agreement on the design/solution before spending too much time writing\n+code.\n+\n+Commit messages should [reference\n+bugs](https://docs.github.com/en/github/writing-on-github/autolinked-references-and-urls).\n+\n+We require [Developer Certificate of\n+Origin](https://en.wikipedia.org/wiki/Developer_Certificate_of_Origin) (DCO)\n+`Signed-off-by` lines in commits. (`git commit -s`)\n+\n+Please squash your code review edits & force push. Multiple commits in\n+a PR are fine, but only if they're each logically separate and all tests pass\n+at each stage. No fixup commits.\n+\n+See [commit-messages.md](docs/commit-messages.md) (or skim `git log`) for our commit message style.\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local_test.go\n@@ -15,6 +15,7 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n+\t\"runtime\"\n \t\"slices\"\n \t\"strings\"\n \t\"sync\"\n@@ -2596,6 +2597,9 @@ func TestPreferencePolicyInfo(t *testing.T) {\n }\n \n func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n+\tif runtime.GOOS == \"darwin\" {\n+\t\tt.Skip(\"test known broken on macOS; see https://github.com/tailscale/tailscale/issues/15691\")\n+\t}\n \ttests := []struct {\n \t\tbefore, after  opt.Bool\n \t\tcontainer      opt.Bool\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis fixes a refactoring bug introduced in 8b72dd7873201\n\nTests (that failed on this) are coming in a separate change.\n\nUpdates #15812\n\n\n---\n\nChoice A:\nflake.lock\n@@ -36,11 +36,11 @@\n     },\n     \"nixpkgs\": {\n       \"locked\": {\n-        \"lastModified\": 1724748588,\n-        \"narHash\": \"sha256-NlpGA4+AIf1dKNq76ps90rxowlFXUsV9x7vK/mN37JM=\",\n+        \"lastModified\": 1743938762,\n+        \"narHash\": \"sha256-UgFYn8sGv9B8PoFpUfCa43CjMZBl1x/ShQhRDHBFQdI=\",\n         \"owner\": \"NixOS\",\n         \"repo\": \"nixpkgs\",\n-        \"rev\": \"a6292e34000dc93d43bccf78338770c1c5ec8a99\",\n+        \"rev\": \"74a40410369a1c35ee09b8a1abee6f4acbedc059\",\n         \"type\": \"github\"\n       },\n       \"original\": {\n---\nflake.nix\n@@ -68,14 +68,14 @@\n     # you're an end user you should be prepared for this flake to not\n     # build periodically.\n     tailscale = pkgs:\n-      pkgs.buildGo123Module rec {\n+      pkgs.buildGo124Module rec {\n         name = \"tailscale\";\n \n         src = ./.;\n         vendorHash = pkgs.lib.fileContents ./go.mod.sri;\n         nativeBuildInputs = pkgs.lib.optionals pkgs.stdenv.isLinux [pkgs.makeWrapper];\n         ldflags = [\"-X tailscale.com/version.gitCommitStamp=${tailscaleRev}\"];\n-        CGO_ENABLED = 0;\n+        env.CGO_ENABLED = 0;\n         subPackages = [\"cmd/tailscale\" \"cmd/tailscaled\"];\n         doCheck = false;\n \n@@ -118,7 +118,7 @@\n           gotools\n           graphviz\n           perl\n-          go_1_23\n+          go_1_24\n           yarn\n \n           # qemu and e2fsprogs are needed for natlab\n@@ -130,4 +130,4 @@\n   in\n     flake-utils.lib.eachDefaultSystem (system: flakeForSystem nixpkgs system);\n }\n-# nix-direnv cache busting line: sha256-xO1DuLWi6/lpA9ubA2ZYVJM+CkVNA5IaVGZxX9my0j0=\n+# nix-direnv cache busting line: sha256-av4kr09rjNRmag94ziNjJuI/cg8b8lAD3Tk24t/ezH4=\n---\ngo.mod.sri\n@@ -1 +1 @@\n-sha256-xO1DuLWi6/lpA9ubA2ZYVJM+CkVNA5IaVGZxX9my0j0=\n+sha256-av4kr09rjNRmag94ziNjJuI/cg8b8lAD3Tk24t/ezH4=\n\\ No newline at end of file\n---\nshell.nix\n@@ -16,4 +16,4 @@\n ) {\n   src =  ./.;\n }).shellNix\n-# nix-direnv cache busting line: sha256-xO1DuLWi6/lpA9ubA2ZYVJM+CkVNA5IaVGZxX9my0j0=\n+# nix-direnv cache busting line: sha256-av4kr09rjNRmag94ziNjJuI/cg8b8lAD3Tk24t/ezH4=\n---\n\n\n---\n\nChoice B:\n.github/workflows/golangci-lint.yml\n@@ -31,9 +31,9 @@ jobs:\n           cache: false\n \n       - name: golangci-lint\n-        uses: golangci/golangci-lint-action@2226d7cb06a077cd73e56eedd38eecad18e5d837 # v6.5.0\n+        uses: golangci/golangci-lint-action@1481404843c368bc19ca9406f87d6e0fc97bdcfd # v7.0.0\n         with:\n-          version: v1.64\n+          version: v2.0.2\n \n           # Show only new issues if it's a pull request.\n           only-new-issues: true\n---\n.golangci.yml\n@@ -1,97 +1,110 @@\n+version: \"2\"\n+# Configuration for how we run golangci-lint\n+# Timeout of 5m was the default in v1.\n+run:\n+  timeout: 5m\n linters:\n   # Don't enable any linters by default; just the ones that we explicitly\n   # enable in the list below.\n-  disable-all: true\n+  default: none\n   enable:\n     - bidichk\n-    - gofmt\n-    - goimports\n     - govet\n     - misspell\n     - revive\n-\n-# Configuration for how we run golangci-lint\n-run:\n-  timeout: 5m\n-\n-issues:\n-  # Excluding configuration per-path, per-linter, per-text and per-source\n-  exclude-rules:\n-    # These are forks of an upstream package and thus are exempt from stylistic\n-    # changes that would make pulling in upstream changes harder.\n-    - path: tempfork/.*\\.go\n-      text: \"File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\"\n-    - path: util/singleflight/.*\\.go\n-      text: \"File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\"\n-\n-# Per-linter settings are contained in this top-level key\n-linters-settings:\n-  gofmt:\n-    rewrite-rules:\n-      - pattern: 'interface{}'\n-        replacement: 'any'\n-\n-  govet:\n+  settings:\n     # Matches what we use in corp as of 2023-12-07\n-    enable:\n-      - asmdecl\n-      - assign\n-      - atomic\n-      - bools\n-      - buildtag\n-      - cgocall\n-      - copylocks\n-      - deepequalerrors\n-      - errorsas\n-      - framepointer\n-      - httpresponse\n-      - ifaceassert\n-      - loopclosure\n-      - lostcancel\n-      - nilfunc\n-      - nilness\n-      - printf\n-      - reflectvaluecompare\n-      - shift\n-      - sigchanyzer\n-      - sortslice\n-      - stdmethods\n-      - stringintconv\n-      - structtag\n-      - testinggoroutine\n-      - tests\n-      - unmarshal\n-      - unreachable\n-      - unsafeptr\n-      - unusedresult\n-    settings:\n-      printf:\n-        # List of print function names to check (in addition to default)\n-        funcs:\n-          - github.com/tailscale/tailscale/types/logger.Discard\n-          # NOTE(andrew-d): this doesn't currently work because the printf\n-          # analyzer doesn't support type declarations\n-          #- github.com/tailscale/tailscale/types/logger.Logf\n-\n-  revive:\n-    enable-all-rules: false\n-    ignore-generated-header: true\n+    govet:\n+      enable:\n+        - asmdecl\n+        - assign\n+        - atomic\n+        - bools\n+        - buildtag\n+        - cgocall\n+        - copylocks\n+        - deepequalerrors\n+        - errorsas\n+        - framepointer\n+        - httpresponse\n+        - ifaceassert\n+        - loopclosure\n+        - lostcancel\n+        - nilfunc\n+        - nilness\n+        - printf\n+        - reflectvaluecompare\n+        - shift\n+        - sigchanyzer\n+        - sortslice\n+        - stdmethods\n+        - stringintconv\n+        - structtag\n+        - testinggoroutine\n+        - tests\n+        - unmarshal\n+        - unreachable\n+        - unsafeptr\n+        - unusedresult\n+      settings:\n+        printf:\n+          # List of print function names to check (in addition to default)\n+          funcs:\n+            - github.com/tailscale/tailscale/types/logger.Discard\n+            # NOTE(andrew-d): this doesn't currently work because the printf\n+            # analyzer doesn't support type declarations\n+            #- github.com/tailscale/tailscale/types/logger.Logf\n+    revive:\n+      enable-all-rules: false\n+      rules:\n+        - name: atomic\n+        - name: context-keys-type\n+        - name: defer\n+          arguments: [[\n+              # Calling 'recover' at the time a defer is registered (i.e. \"defer recover()\") has no effect.\n+              \"immediate-recover\",\n+              # Calling 'recover' outside of a deferred function has no effect\n+              \"recover\",\n+              # Returning values from a deferred function has no effect\n+              \"return\",\n+          ]]\n+        - name: duplicated-imports\n+        - name: errorf\n+        - name: string-of-int\n+        - name: time-equal\n+        - name: unconditional-recursion\n+        - name: useless-break\n+        - name: waitgroup-by-value\n+  exclusions:\n+    generated: lax\n+    presets:\n+      - comments\n+      - common-false-positives\n+      - legacy\n+      - std-error-handling\n     rules:\n-      - name: atomic\n-      - name: context-keys-type\n-      - name: defer\n-        arguments: [[\n-          # Calling 'recover' at the time a defer is registered (i.e. \"defer recover()\") has no effect.\n-          \"immediate-recover\",\n-          # Calling 'recover' outside of a deferred function has no effect\n-          \"recover\",\n-          # Returning values from a deferred function has no effect\n-          \"return\",\n-        ]]\n-      - name: duplicated-imports\n-      - name: errorf\n-      - name: string-of-int\n-      - name: time-equal\n-      - name: unconditional-recursion\n-      - name: useless-break\n-      - name: waitgroup-by-value\n+      # These are forks of an upstream package and thus are exempt from stylistic\n+      # changes that would make pulling in upstream changes harder.\n+      - path: tempfork/.*\\.go\n+        text: File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\n+      - path: util/singleflight/.*\\.go\n+        text: File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n+formatters:\n+  enable:\n+    - gofmt\n+    - goimports\n+  settings:\n+    gofmt:\n+      rewrite-rules:\n+        - pattern: interface{}\n+          replacement: any\n+  exclusions:\n+    generated: lax\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/c2n.go\n@@ -240,13 +240,14 @@ func handleC2NAppConnectorDomainRoutesGet(b *LocalBackend, w http.ResponseWriter\n \tb.logf(\"c2n: GET /appconnector/routes received\")\n \n \tvar res tailcfg.C2NAppConnectorDomainRoutesResponse\n-\tif b.appConnector == nil {\n+\tappConnector := b.AppConnector()\n+\tif appConnector == nil {\n \t\tw.Header().Set(\"Content-Type\", \"application/json\")\n \t\tjson.NewEncoder(w).Encode(res)\n \t\treturn\n \t}\n \n-\tres.Domains = b.appConnector.DomainRoutes()\n+\tres.Domains = appConnector.DomainRoutes()\n \n \tw.Header().Set(\"Content-Type\", \"application/json\")\n \tjson.NewEncoder(w).Encode(res)\n---\nipn/ipnlocal/local.go\n@@ -4150,8 +4150,8 @@ func (b *LocalBackend) SetUseExitNodeEnabled(v bool) (ipn.PrefsView, error) {\n // AdvertiseRoutes has been set in the MaskedPrefs.\n func (b *LocalBackend) MaybeClearAppConnector(mp *ipn.MaskedPrefs) error {\n \tvar err error\n-\tif b.appConnector != nil && mp.AdvertiseRoutesSet {\n-\t\terr = b.appConnector.ClearRoutes()\n+\tif ac := b.AppConnector(); ac != nil && mp.AdvertiseRoutesSet {\n+\t\terr = ac.ClearRoutes()\n \t\tif err != nil {\n \t\t\tb.logf(\"appc: clear routes error: %v\", err)\n \t\t}\n@@ -4755,9 +4755,7 @@ func (b *LocalBackend) readvertiseAppConnectorRoutes() {\n \t//\n \t// Grab a copy of the field, since b.mu only guards access to the\n \t// b.appConnector field itself.\n-\tb.mu.Lock()\n-\tappConnector := b.appConnector\n-\tb.mu.Unlock()\n+\tappConnector := b.AppConnector()\n \n \tif appConnector == nil {\n \t\treturn\n@@ -6432,6 +6430,15 @@ func (b *LocalBackend) OfferingAppConnector() bool {\n \treturn b.appConnector != nil\n }\n \n+// AppConnector returns the current AppConnector, or nil if not configured.\n+//\n+// TODO(nickkhyl): move app connectors to [nodeBackend], or perhaps a feature package?\n+func (b *LocalBackend) AppConnector() *appc.AppConnector {\n+\tb.mu.Lock()\n+\tdefer b.mu.Unlock()\n+\treturn b.appConnector\n+}\n+\n // allowExitNodeDNSProxyToServeName reports whether the Exit Node DNS\n // proxy is allowed to serve responses for the provided DNS name.\n func (b *LocalBackend) allowExitNodeDNSProxyToServeName(name string) bool {\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/taildrop.go\n@@ -194,8 +194,8 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n-\t\tif self != p.User() {\n-\t\t\treturn false\n+\t\tif self == p.User() {\n+\t\t\treturn true\n \t\t}\n \t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nConn.sendDiscoMessage() now verifies if the destination disco key is associated with any known peer(s) in a thread-safe manner.\r\n\r\nUpdates #15844\n\n---\n\nChoice A:\nwgengine/magicsock/magicsock.go\n@@ -1625,6 +1625,25 @@ func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey ke\n \t\tc.mu.Unlock()\n \t\treturn false, errConnClosed\n \t}\n+\tvar di *discoInfo\n+\tswitch {\n+\tcase c.peerMap.knownPeerDiscoKey(dstDisco):\n+\t\tdi = c.discoInfoForKnownPeerLocked(dstDisco)\n+\tcase isRelayHandshakeMsg:\n+\t\t// TODO(jwhited): consider caching relay server disco shared keys\n+\t\tdi = &discoInfo{\n+\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n+\t\t}\n+\tdefault:\n+\t\t// This is an attempt to send to an unknown peer that is not a relay\n+\t\t// server. This can happen when a call to the current function, which is\n+\t\t// often via a new goroutine, races with applying a change in the\n+\t\t// netmap, e.g. the associated peer(s) for dstDisco goes away.\n+\t\tc.mu.Unlock()\n+\t\treturn false, errors.New(\"unknown peer\")\n+\t}\n+\tc.mu.Unlock()\n+\n \tpkt := make([]byte, 0, 512) // TODO: size it correctly? pool? if it matters.\n \tif geneveVNI != nil {\n \t\tgh := packet.GeneveHeader{\n@@ -1641,23 +1660,6 @@ func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey ke\n \t}\n \tpkt = append(pkt, disco.Magic...)\n \tpkt = c.discoPublic.AppendTo(pkt)\n-\tvar di *discoInfo\n-\tif !isRelayHandshakeMsg {\n-\t\tdi = c.discoInfoLocked(dstDisco)\n-\t} else {\n-\t\t// c.discoInfoLocked() caches [*discoInfo] for dstDisco. It assumes that\n-\t\t// dstDisco is a known Tailscale peer, and will be cleaned around\n-\t\t// network map changes. In the case of a relay handshake message,\n-\t\t// dstDisco belongs to a relay server with a disco key that is\n-\t\t// discovered at endpoint allocation time or [disco.CallMeMaybeVia]\n-\t\t// reception time. There is no clear ending to its lifetime, so we\n-\t\t// can't cache with the same strategy. Instead, generate the shared\n-\t\t// key on the fly for now.\n-\t\tdi = &discoInfo{\n-\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n-\t\t}\n-\t}\n-\tc.mu.Unlock()\n \n \tif isDERP {\n \t\tmetricSendDiscoDERP.Add(1)\n@@ -1814,7 +1816,7 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t//\n \t// From here on, peerNode and de are non-nil.\n \n-\tdi := c.discoInfoLocked(sender)\n+\tdi := c.discoInfoForKnownPeerLocked(sender)\n \n \tsealedBox := msg[discoHeaderLen:]\n \tpayload, ok := di.sharedKey.Open(sealedBox)\n@@ -2076,10 +2078,15 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \t}\n }\n \n-// discoInfoLocked returns the previous or new discoInfo for k.\n+// discoInfoForKnownPeerLocked returns the previous or new discoInfo for k.\n+//\n+// Callers must only pass key.DiscoPublic's that are present in and\n+// lifetime-managed via [Conn].peerMap. UDP relay server disco keys are discovered\n+// at relay endpoint allocation time or [disco.CallMeMaybeVia] reception time\n+// and therefore must never pass through this method.\n //\n // c.mu must be held.\n-func (c *Conn) discoInfoLocked(k key.DiscoPublic) *discoInfo {\n+func (c *Conn) discoInfoForKnownPeerLocked(k key.DiscoPublic) *discoInfo {\n \tdi, ok := c.discoInfo[k]\n \tif !ok {\n \t\tdi = &discoInfo{\n---\n\n\n---\n\nChoice B:\ncmd/containerboot/healthz.go\n@@ -47,10 +47,10 @@ func (h *healthz) update(healthy bool) {\n \th.hasAddrs = healthy\n }\n \n-// healthHandlers registers a simple health handler at /healthz.\n+// registerHealthHandlers registers a simple health handler at /healthz.\n // A containerized tailscale instance is considered healthy if\n // it has at least one tailnet IP address.\n-func healthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n+func registerHealthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n \th := &healthz{podIPv4: podIPv4}\n \tmux.Handle(\"GET /healthz\", h)\n \treturn h\n---\ncmd/containerboot/main.go\n@@ -195,18 +195,21 @@ func run() error {\n \t\treturn fmt.Errorf(\"failed to bring up tailscale: %w\", err)\n \t}\n \tkillTailscaled := func() {\n+\t\t// The default termination grace period for a Pod is 30s. We wait 25s at\n+\t\t// most so that we still reserve some of that budget for tailscaled\n+\t\t// to receive and react to a SIGTERM before the SIGKILL that k8s\n+\t\t// will send at the end of the grace period.\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)\n+\t\tdefer cancel()\n+\n+\t\tif err := ensureServicesNotAdvertised(ctx, client); err != nil {\n+\t\t\tlog.Printf(\"Error ensuring services are not advertised: %v\", err)\n+\t\t}\n+\n \t\tif hasKubeStateStore(cfg) {\n \t\t\t// Check we're not shutting tailscaled down while it's still writing\n \t\t\t// state. If we authenticate and fail to write all the state, we'll\n \t\t\t// never recover automatically.\n-\t\t\t//\n-\t\t\t// The default termination grace period for a Pod is 30s. We wait 25s at\n-\t\t\t// most so that we still reserve some of that budget for tailscaled\n-\t\t\t// to receive and react to a SIGTERM before the SIGKILL that k8s\n-\t\t\t// will send at the end of the grace period.\n-\t\t\tctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)\n-\t\t\tdefer cancel()\n-\n \t\t\tlog.Printf(\"Checking for consistent state\")\n \t\t\terr := kc.waitForConsistentState(ctx)\n \t\t\tif err != nil {\n@@ -226,7 +229,7 @@ func run() error {\n \t\tmux := http.NewServeMux()\n \n \t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.HealthCheckAddrPort)\n-\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \n \t\tclose := runHTTPServer(mux, cfg.HealthCheckAddrPort)\n \t\tdefer close()\n@@ -237,15 +240,16 @@ func run() error {\n \n \t\tif cfg.localMetricsEnabled() {\n \t\t\tlog.Printf(\"Running metrics endpoint at %s/metrics\", cfg.LocalAddrPort)\n-\t\t\tmetricsHandlers(mux, client, cfg.DebugAddrPort)\n+\t\t\tregisterMetricsHandlers(mux, client, cfg.DebugAddrPort)\n \t\t}\n \n \t\tif cfg.localHealthEnabled() {\n \t\t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.LocalAddrPort)\n-\t\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \t\t}\n-\t\tif cfg.EgressProxiesCfgPath != \"\" {\n-\t\t\tlog.Printf(\"Running preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n+\n+\t\tif cfg.egressSvcsTerminateEPEnabled() {\n+\t\t\tlog.Printf(\"Running egress preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n \t\t\tep.registerHandlers(mux)\n \t\t}\n \n---\ncmd/containerboot/metrics.go\n@@ -62,13 +62,13 @@ func (m *metrics) handleDebug(w http.ResponseWriter, r *http.Request) {\n \tproxy(w, r, debugURL, http.DefaultClient.Do)\n }\n \n-// metricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n+// registerMetricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n // requests to tailscaled's /localapi/v0/usermetrics API.\n //\n // In 1.78.x and 1.80.x, it also proxies debug paths to tailscaled's debug\n // endpoint if configured to ease migration for a breaking change serving user\n // metrics instead of debug metrics on the \"metrics\" port.\n-func metricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n+func registerMetricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n \tm := &metrics{\n \t\tlc:            lc,\n \t\tdebugEndpoint: debugAddrPort,\n---\ncmd/containerboot/serve.go\n@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"log\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -169,3 +170,46 @@ func readServeConfig(path, certDomain string) (*ipn.ServeConfig, error) {\n \t}\n \treturn &sc, nil\n }\n+\n+func ensureServicesNotAdvertised(ctx context.Context, lc *local.Client) error {\n+\tprefs, err := lc.GetPrefs(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"error getting prefs: %w\", err)\n+\t}\n+\tif len(prefs.AdvertiseServices) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tlog.Printf(\"serve proxy: unadvertising services: %v\", prefs.AdvertiseServices)\n+\tif _, err := lc.EditPrefs(ctx, &ipn.MaskedPrefs{\n+\t\tAdvertiseServicesSet: true,\n+\t\tPrefs: ipn.Prefs{\n+\t\t\tAdvertiseServices: nil,\n+\t\t},\n+\t}); err != nil {\n+\t\t// EditPrefs only returns an error if it fails _set_ its local prefs.\n+\t\t// If it fails to _persist_ the prefs in state, we don't get an error\n+\t\t// and we continue waiting below, as control will failover as usual.\n+\t\treturn fmt.Errorf(\"error setting prefs AdvertiseServices: %w\", err)\n+\t}\n+\n+\t// Services use the same (failover XOR regional routing) mechanism that\n+\t// HA subnet routers use. Unfortunately we don't yet get a reliable signal\n+\t// from control that it's responded to our unadvertisement, so the best we\n+\t// can do is wait for 20 seconds, where 15s is the approximate maximum time\n+\t// it should take for control to choose a new primary, and 5s is for buffer.\n+\t//\n+\t// Note: There is no guarantee that clients have been _informed_ of the new\n+\t// primary no matter how long we wait. We would need a mechanism to await\n+\t// netmap updates for peers to know for sure.\n+\t//\n+\t// See https://tailscale.com/kb/1115/high-availability for more details.\n+\t// TODO(tomhjp): Wait for a netmap update instead of sleeping when control\n+\t// supports that.\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\treturn nil\n+\tcase <-time.After(20 * time.Second):\n+\t\treturn nil\n+\t}\n+}\n---\ncmd/k8s-operator/proxygroup_specs.go\n@@ -197,6 +197,16 @@ func pgStatefulSet(pg *tsapi.ProxyGroup, namespace, image, tsFirewallMode string\n \t// This mechanism currently (2025-01-26) rely on the local health check being accessible on the Pod's\n \t// IP, so they are not supported for ProxyGroups where users have configured TS_LOCAL_ADDR_PORT to a custom\n \t// value.\n+\t//\n+\t// NB: For _Ingress_ ProxyGroups, we run shutdown logic within containerboot\n+\t// in reaction to a SIGTERM signal instead of using a pre-stop hook. This is\n+\t// because Ingress pods need to unadvertise services, and it's preferable to\n+\t// avoid triggering those side-effects from a GET request that would be\n+\t// accessible to the whole cluster network (in the absence of NetworkPolicy\n+\t// rules).\n+\t//\n+\t// TODO(tomhjp): add a readiness probe or gate to Ingress Pods. There is a\n+\t// small window where the Pod is marked ready but routing can still fail.\n \tif pg.Spec.Type == tsapi.ProxyGroupTypeEgress && !hasLocalAddrPortSet(proxyClass) {\n \t\tc.Lifecycle = &corev1.Lifecycle{\n \t\t\tPreStop: &corev1.LifecycleHandler{\n---\n\n\n---\n\nChoice C:\nwgengine/userspace.go\n@@ -1580,6 +1580,12 @@ type fwdDNSLinkSelector struct {\n }\n \n func (ls fwdDNSLinkSelector) PickLink(ip netip.Addr) (linkName string) {\n+\t// sandboxed macOS does not automatically bind to the loopback interface so\n+\t// we must be explicit about it.\n+\tif runtime.GOOS == \"darwin\" && ip.IsLoopback() {\n+\t\treturn \"lo0\"\n+\t}\n+\n \tif ls.ue.isDNSIPOverTailscale.Load()(ip) {\n \t\treturn ls.tunName\n \t}\n---\n\n\n---\n\nChoice D:\nhealth/health.go\n@@ -1054,13 +1054,18 @@ func (t *Tracker) stringsLocked() []string {\n \n \twarnLen := len(result)\n \tfor _, c := range t.controlMessages {\n+\t\tvar msg string\n \t\tif c.Title != \"\" && c.Text != \"\" {\n-\t\t\tresult = append(result, c.Title+\": \"+c.Text)\n+\t\t\tmsg = c.Title + \": \" + c.Text\n \t\t} else if c.Title != \"\" {\n-\t\t\tresult = append(result, c.Title)\n+\t\t\tmsg = c.Title + \".\"\n \t\t} else if c.Text != \"\" {\n-\t\t\tresult = append(result, c.Text)\n+\t\t\tmsg = c.Text\n \t\t}\n+\t\tif c.PrimaryAction != nil {\n+\t\t\tmsg = msg + \" \" + c.PrimaryAction.Label + \": \" + c.PrimaryAction.URL\n+\t\t}\n+\t\tresult = append(result, msg)\n \t}\n \tsort.Strings(result[warnLen:])\n \n---\nhealth/health_test.go\n@@ -467,29 +467,48 @@ func TestControlHealth(t *testing.T) {\n \tbaseWarns := ht.CurrentState().Warnings\n \tbaseStrs := ht.Strings()\n \n-\tht.SetControlHealth(map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n+\tmsgs := map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n \t\t\"control-health-test\": {\n \t\t\tTitle: \"Control health message\",\n-\t\t\tText:  \"Extra help\",\n+\t\t\tText:  \"Extra help.\",\n \t\t},\n \t\t\"control-health-title\": {\n \t\t\tTitle: \"Control health title only\",\n \t\t},\n-\t})\n+\t\t\"control-health-with-action\": {\n+\t\t\tTitle: \"Control health message\",\n+\t\t\tText:  \"Extra help.\",\n+\t\t\tPrimaryAction: &tailcfg.DisplayMessageAction{\n+\t\t\t\tURL:   \"http://www.example.com\",\n+\t\t\t\tLabel: \"Learn more\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\tht.SetControlHealth(msgs)\n \n \tt.Run(\"Warnings\", func(t *testing.T) {\n \t\twantWarns := map[WarnableCode]UnhealthyState{\n \t\t\t\"control-health-test\": {\n \t\t\t\tWarnableCode: \"control-health-test\",\n \t\t\t\tSeverity:     SeverityMedium,\n \t\t\t\tTitle:        \"Control health message\",\n-\t\t\t\tText:         \"Extra help\",\n+\t\t\t\tText:         \"Extra help.\",\n \t\t\t},\n \t\t\t\"control-health-title\": {\n \t\t\t\tWarnableCode: \"control-health-title\",\n \t\t\t\tSeverity:     SeverityMedium,\n \t\t\t\tTitle:        \"Control health title only\",\n \t\t\t},\n+\t\t\t\"control-health-with-action\": {\n+\t\t\t\tWarnableCode: \"control-health-with-action\",\n+\t\t\t\tSeverity:     SeverityMedium,\n+\t\t\t\tTitle:        \"Control health message\",\n+\t\t\t\tText:         \"Extra help.\",\n+\t\t\t\tPrimaryAction: &UnhealthyStateAction{\n+\t\t\t\t\tURL:   \"http://www.example.com\",\n+\t\t\t\t\tLabel: \"Learn more\",\n+\t\t\t\t},\n+\t\t\t},\n \t\t}\n \t\tstate := ht.CurrentState()\n \t\tgotWarns := maps.Clone(state.Warnings)\n@@ -505,8 +524,9 @@ func TestControlHealth(t *testing.T) {\n \n \tt.Run(\"Strings()\", func(t *testing.T) {\n \t\twantStrs := []string{\n-\t\t\t\"Control health message: Extra help\",\n-\t\t\t\"Control health title only\",\n+\t\t\t\"Control health message: Extra help.\",\n+\t\t\t\"Control health message: Extra help. Learn more: http://www.example.com\",\n+\t\t\t\"Control health title only.\",\n \t\t}\n \t\tvar gotStrs []string\n \t\tfor _, s := range ht.Strings() {\n@@ -527,8 +547,7 @@ func TestControlHealth(t *testing.T) {\n \t\t\tType: MetricLabelWarning,\n \t\t}).String()\n \t\twant := strconv.Itoa(\n-\t\t\t2 + // from SetControlHealth\n-\t\t\t\tlen(baseStrs),\n+\t\t\tlen(msgs) + len(baseStrs),\n \t\t)\n \t\tif got != want {\n \t\t\tt.Errorf(\"metricsHealthMessage.Get(warning) = %q, want %q\", got, want)\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis fixes the Taildrop deadlock from 8b72dd787320.\n\nFixes #15824\n\n\n---\n\nChoice A:\ncmd/natc/ippool/consensusippool.go\n@@ -10,6 +10,8 @@ import (\n \t\"fmt\"\n \t\"log\"\n \t\"net/netip\"\n+\t\"os\"\n+\t\"path/filepath\"\n \t\"time\"\n \n \t\"github.com/hashicorp/raft\"\n@@ -150,9 +152,14 @@ func (ipp *ConsensusIPPool) domainLookup(from tailcfg.NodeID, addr netip.Addr) (\n }\n \n // StartConsensus is part of the IPPool interface. It starts the raft background routines that handle consensus.\n-func (ipp *ConsensusIPPool) StartConsensus(ctx context.Context, ts *tsnet.Server, clusterTag string) error {\n+func (ipp *ConsensusIPPool) StartConsensus(ctx context.Context, ts *tsnet.Server, clusterTag string, clusterStateDir string) error {\n \tcfg := tsconsensus.DefaultConfig()\n \tcfg.ServeDebugMonitor = true\n+\tvar err error\n+\tcfg.StateDirPath, err = getStatePath(clusterStateDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tcns, err := tsconsensus.Start(ctx, ts, ipp, clusterTag, cfg)\n \tif err != nil {\n \t\treturn err\n@@ -204,6 +211,30 @@ func (ps *consensusPerPeerState) unusedIPV4(ipset *netipx.IPSet, reuseDeadline t\n \treturn netip.Addr{}, false, \"\", errors.New(\"ip pool exhausted\")\n }\n \n+func getStatePath(pathFromFlag string) (string, error) {\n+\tvar dirPath string\n+\tif pathFromFlag != \"\" {\n+\t\tdirPath = pathFromFlag\n+\t} else {\n+\t\tconfDir, err := os.UserConfigDir()\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tdirPath = filepath.Join(confDir, \"nat-connector-cluster-state\")\n+\t}\n+\n+\tif err := os.MkdirAll(dirPath, 0700); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif fi, err := os.Stat(dirPath); err != nil {\n+\t\treturn \"\", err\n+\t} else if !fi.IsDir() {\n+\t\treturn \"\", fmt.Errorf(\"%v is not a directory\", dirPath)\n+\t}\n+\n+\treturn dirPath, nil\n+}\n+\n // isCloseToExpiry returns true if the lastUsed and now times are more than\n // half the lifetime apart\n func isCloseToExpiry(lastUsed, now time.Time, lifetime time.Duration) bool {\n---\ncmd/natc/natc.go\n@@ -59,6 +59,7 @@ func main() {\n \t\twgPort          = fs.Uint(\"wg-port\", 0, \"udp port for wireguard and peer to peer traffic\")\n \t\tclusterTag      = fs.String(\"cluster-tag\", \"\", \"optionally run in a consensus cluster with other nodes with this tag\")\n \t\tserver          = fs.String(\"login-server\", ipn.DefaultControlURL, \"the base URL of control server\")\n+\t\tclusterStateDir = fs.String(\"cluster-state-dir\", \"\", \"path to directory in which to store raft state\")\n \t)\n \tff.Parse(fs, os.Args[1:], ff.WithEnvVarPrefix(\"TS_NATC\"))\n \n@@ -155,7 +156,7 @@ func main() {\n \tvar ipp ippool.IPPool\n \tif *clusterTag != \"\" {\n \t\tcipp := ippool.NewConsensusIPPool(addrPool)\n-\t\terr = cipp.StartConsensus(ctx, ts, *clusterTag)\n+\t\terr = cipp.StartConsensus(ctx, ts, *clusterTag, *clusterStateDir)\n \t\tif err != nil {\n \t\t\tlog.Fatalf(\"StartConsensus: %v\", err)\n \t\t}\n---\n\n\n---\n\nChoice B:\nnet/portmapper/igd_test.go\n@@ -18,8 +18,10 @@ import (\n \t\"tailscale.com/net/netaddr\"\n \t\"tailscale.com/net/netmon\"\n \t\"tailscale.com/syncs\"\n+\t\"tailscale.com/tstest\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/eventbus\"\n+\t\"tailscale.com/util/testenv\"\n )\n \n // TestIGD is an IGD (Internet Gateway Device) for testing. It supports fake\n@@ -64,7 +66,8 @@ type igdCounters struct {\n \tinvalidPCPMapPkt int32\n }\n \n-func NewTestIGD(logf logger.Logf, t TestIGDOptions) (*TestIGD, error) {\n+func NewTestIGD(tb testenv.TB, t TestIGDOptions) (*TestIGD, error) {\n+\tlogf := tstest.WhileTestRunningLogger(tb)\n \td := &TestIGD{\n \t\tdoPMP:  t.PMP,\n \t\tdoPCP:  t.PCP,\n@@ -265,7 +268,7 @@ func (d *TestIGD) handlePCPQuery(pkt []byte, src netip.AddrPort) {\n func newTestClient(t *testing.T, igd *TestIGD, bus *eventbus.Bus) *Client {\n \tvar c *Client\n \tc = NewClient(Config{\n-\t\tLogf:         t.Logf,\n+\t\tLogf:         tstest.WhileTestRunningLogger(t),\n \t\tNetMon:       netmon.NewStatic(),\n \t\tControlKnobs: new(controlknobs.Knobs),\n \t\tEventBus:     bus,\n---\nnet/portmapper/portmapper_test.go\n@@ -61,7 +61,7 @@ func TestClientProbeThenMap(t *testing.T) {\n }\n \n func TestProbeIntegration(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PMP: true, PCP: true, UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PMP: true, PCP: true, UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -95,7 +95,7 @@ func TestProbeIntegration(t *testing.T) {\n }\n \n func TestPCPIntegration(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PMP: false, PCP: true, UPnP: false})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PMP: false, PCP: true, UPnP: false})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -137,7 +137,7 @@ func TestGetUPnPErrorsMetric(t *testing.T) {\n }\n \n func TestUpdateEvent(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PCP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PCP: true})\n \tif err != nil {\n \t\tt.Fatalf(\"Create test gateway: %v\", err)\n \t}\n---\nnet/portmapper/select_test.go\n@@ -28,7 +28,7 @@ func TestSelectBestService(t *testing.T) {\n \t}\n \n \t// Run a fake IGD server to respond to UPnP requests.\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/portmapper/upnp_test.go\n@@ -533,7 +533,7 @@ func TestGetUPnPClient(t *testing.T) {\n }\n \n func TestGetUPnPPortMapping(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -672,7 +672,7 @@ func TestGetUPnPPortMapping_LeaseDuration(t *testing.T) {\n \t\t\t\t\"DeletePortMapping\":    \"\", // Do nothing for test\n \t\t\t}\n \n-\t\t\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\t\t\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n@@ -722,7 +722,7 @@ func TestGetUPnPPortMapping_LeaseDuration(t *testing.T) {\n //\n // See https://github.com/tailscale/tailscale/issues/10911\n func TestGetUPnPPortMapping_NoValidServices(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -753,7 +753,7 @@ func TestGetUPnPPortMapping_NoValidServices(t *testing.T) {\n \n // Tests the legacy behaviour with the pre-UPnP standard portmapping service.\n func TestGetUPnPPortMapping_Legacy(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -796,7 +796,7 @@ func TestGetUPnPPortMapping_Legacy(t *testing.T) {\n }\n \n func TestGetUPnPPortMappingNoResponses(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -912,7 +912,7 @@ func TestGetUPnPPortMapping_Invalid(t *testing.T) {\n \t\t\"127.0.0.1\",\n \t} {\n \t\tt.Run(responseAddr, func(t *testing.T) {\n-\t\t\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\t\t\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n---\ntstest/log.go\n@@ -13,6 +13,7 @@ import (\n \n \t\"go4.org/mem\"\n \t\"tailscale.com/types/logger\"\n+\t\"tailscale.com/util/testenv\"\n )\n \n type testLogWriter struct {\n@@ -149,7 +150,7 @@ func (ml *MemLogger) String() string {\n \n // WhileTestRunningLogger returns a logger.Logf that logs to t.Logf until the\n // test finishes, at which point it no longer logs anything.\n-func WhileTestRunningLogger(t testing.TB) logger.Logf {\n+func WhileTestRunningLogger(t testenv.TB) logger.Logf {\n \tvar (\n \t\tmu   sync.RWMutex\n \t\tdone bool\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local.go\n@@ -1463,15 +1463,30 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n+// AppendMatchingPeers returns base with all peers that match pred appended.\n+//\n+// It acquires b.mu to read the netmap but releases it before calling pred.\n func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+\tvar peers []tailcfg.NodeView\n+\n \tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n-\tret := base\n-\tif b.netMap == nil {\n-\t\treturn ret\n+\tif b.netMap != nil {\n+\t\t// All fields on b.netMap are immutable, so this is\n+\t\t// safe to copy and use outside the lock.\n+\t\tpeers = b.netMap.Peers\n \t}\n-\tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\tb.mu.Unlock()\n+\n+\tret := base\n+\tfor _, peer := range peers {\n+\t\t// The peers in b.netMap don't contain updates made via\n+\t\t// UpdateNetmapDelta. So only use PeerView in b.netMap for its NodeID,\n+\t\t// and then look up the latest copy in b.peers which is updated in\n+\t\t// response to UpdateNetmapDelta edits.\n+\t\tb.mu.Lock()\n+\t\tpeer, ok := b.peers[peer.ID()]\n+\t\tb.mu.Unlock()\n+\t\tif ok && pred(peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/cert.go\n@@ -484,14 +484,15 @@ var getCertPEM = func(ctx context.Context, b *LocalBackend, cs certStore, logf l\n \t// In case this method was triggered multiple times in parallel (when\n \t// serving incoming requests), check whether one of the other goroutines\n \t// already renewed the cert before us.\n-\tif p, err := getCertPEMCached(cs, domain, now); err == nil {\n+\tprevious, err := getCertPEMCached(cs, domain, now)\n+\tif err == nil {\n \t\t// shouldStartDomainRenewal caches its result so it's OK to call this\n \t\t// frequently.\n-\t\tshouldRenew, err := b.shouldStartDomainRenewal(cs, domain, now, p, minValidity)\n+\t\tshouldRenew, err := b.shouldStartDomainRenewal(cs, domain, now, previous, minValidity)\n \t\tif err != nil {\n \t\t\tlogf(\"error checking for certificate renewal: %v\", err)\n \t\t} else if !shouldRenew {\n-\t\t\treturn p, nil\n+\t\t\treturn previous, nil\n \t\t}\n \t} else if !errors.Is(err, ipn.ErrStateNotExist) && !errors.Is(err, errCertExpired) {\n \t\treturn nil, err\n@@ -536,7 +537,17 @@ var getCertPEM = func(ctx context.Context, b *LocalBackend, cs certStore, logf l\n \t\treturn nil, err\n \t}\n \n-\torder, err := ac.AuthorizeOrder(ctx, []acme.AuthzID{{Type: \"dns\", Value: domain}})\n+\t// If we have a previous cert, include it in the order. Assuming we're\n+\t// within the ARI renewal window this should exclude us from LE rate\n+\t// limits.\n+\tvar opts []acme.OrderOption\n+\tif previous != nil {\n+\t\tprevCrt, err := previous.parseCertificate()\n+\t\tif err == nil {\n+\t\t\topts = append(opts, acme.WithOrderReplacesCert(prevCrt))\n+\t\t}\n+\t}\n+\torder, err := ac.AuthorizeOrder(ctx, []acme.AuthzID{{Type: \"dns\", Value: domain}}, opts...)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAnd also validate opts for unknown types, before other side effects.\n\nFixes #15833\n\n\n---\n\nChoice A:\ntailcfg/tailcfg.go\n@@ -1462,6 +1462,13 @@ const (\n \t// user groups as Kubernetes user groups. This capability is read by\n \t// peers that are Tailscale Kubernetes operator instances.\n \tPeerCapabilityKubernetes PeerCapability = \"tailscale.com/cap/kubernetes\"\n+\n+\t// PeerCapabilityRelay grants the ability for a peer to allocate relay\n+\t// endpoints.\n+\tPeerCapabilityRelay PeerCapability = \"tailscale.com/cap/relay\"\n+\t// PeerCapabilityRelayTarget grants the current node the ability to allocate\n+\t// relay endpoints to the peer which has this capability.\n+\tPeerCapabilityRelayTarget PeerCapability = \"tailscale.com/cap/relay-target\"\n )\n \n // NodeCapMap is a map of capabilities to their optional values. It is valid for\n---\n\n\n---\n\nChoice B:\ntsnet/tsnet.go\n@@ -1101,13 +1101,33 @@ type FunnelOption interface {\n \tfunnelOption()\n }\n \n-type funnelOnly int\n+type funnelOnly struct{}\n \n func (funnelOnly) funnelOption() {}\n \n // FunnelOnly configures the listener to only respond to connections from Tailscale Funnel.\n // The local tailnet will not be able to connect to the listener.\n-func FunnelOnly() FunnelOption { return funnelOnly(1) }\n+func FunnelOnly() FunnelOption { return funnelOnly{} }\n+\n+type funnelTLSConfig struct{ conf *tls.Config }\n+\n+func (f funnelTLSConfig) funnelOption() {}\n+\n+// FunnelTLSConfig configures the TLS configuration for [Server.ListenFunnel]\n+//\n+// This is rarely needed but can permit requiring client certificates, specific\n+// ciphers suites, etc.\n+//\n+// The provided conf should at least be able to get a certificate, setting\n+// GetCertificate, Certificates or GetConfigForClient appropriately.\n+// The most common configuration is to set GetCertificate to\n+// Server.LocalClient's GetCertificate method.\n+//\n+// Unless [FunnelOnly] is also used, the configuration is also used for\n+// in-tailnet connections that don't arrive over Funnel.\n+func FunnelTLSConfig(conf *tls.Config) FunnelOption {\n+\treturn funnelTLSConfig{conf: conf}\n+}\n \n // ListenFunnel announces on the public internet using Tailscale Funnel.\n //\n@@ -1140,6 +1160,26 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t\treturn nil, err\n \t}\n \n+\t// Process, validate opts.\n+\tlnOn := listenOnBoth\n+\tvar tlsConfig *tls.Config\n+\tfor _, opt := range opts {\n+\t\tswitch v := opt.(type) {\n+\t\tcase funnelTLSConfig:\n+\t\t\tif v.conf == nil {\n+\t\t\t\treturn nil, errors.New(\"invalid nil FunnelTLSConfig\")\n+\t\t\t}\n+\t\t\ttlsConfig = v.conf\n+\t\tcase funnelOnly:\n+\t\t\tlnOn = listenOnFunnel\n+\t\tdefault:\n+\t\t\treturn nil, fmt.Errorf(\"unknown opts FunnelOption type %T\", v)\n+\t\t}\n+\t}\n+\tif tlsConfig == nil {\n+\t\ttlsConfig = &tls.Config{GetCertificate: s.getCert}\n+\t}\n+\n \tctx := context.Background()\n \tst, err := s.Up(ctx)\n \tif err != nil {\n@@ -1177,19 +1217,11 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t}\n \n \t// Start a funnel listener.\n-\tlnOn := listenOnBoth\n-\tfor _, opt := range opts {\n-\t\tif _, ok := opt.(funnelOnly); ok {\n-\t\t\tlnOn = listenOnFunnel\n-\t\t}\n-\t}\n \tln, err := s.listen(network, addr, lnOn)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn tls.NewListener(ln, &tls.Config{\n-\t\tGetCertificate: s.getCert,\n-\t}), nil\n+\treturn tls.NewListener(ln, tlsConfig), nil\n }\n \n type listenOn string\n---\n\n\n---\n\nChoice C:\n.github/workflows/golangci-lint.yml\n@@ -31,9 +31,9 @@ jobs:\n           cache: false\n \n       - name: golangci-lint\n-        uses: golangci/golangci-lint-action@2226d7cb06a077cd73e56eedd38eecad18e5d837 # v6.5.0\n+        uses: golangci/golangci-lint-action@1481404843c368bc19ca9406f87d6e0fc97bdcfd # v7.0.0\n         with:\n-          version: v1.64\n+          version: v2.0.2\n \n           # Show only new issues if it's a pull request.\n           only-new-issues: true\n---\n.golangci.yml\n@@ -1,97 +1,110 @@\n+version: \"2\"\n+# Configuration for how we run golangci-lint\n+# Timeout of 5m was the default in v1.\n+run:\n+  timeout: 5m\n linters:\n   # Don't enable any linters by default; just the ones that we explicitly\n   # enable in the list below.\n-  disable-all: true\n+  default: none\n   enable:\n     - bidichk\n-    - gofmt\n-    - goimports\n     - govet\n     - misspell\n     - revive\n-\n-# Configuration for how we run golangci-lint\n-run:\n-  timeout: 5m\n-\n-issues:\n-  # Excluding configuration per-path, per-linter, per-text and per-source\n-  exclude-rules:\n-    # These are forks of an upstream package and thus are exempt from stylistic\n-    # changes that would make pulling in upstream changes harder.\n-    - path: tempfork/.*\\.go\n-      text: \"File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\"\n-    - path: util/singleflight/.*\\.go\n-      text: \"File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\"\n-\n-# Per-linter settings are contained in this top-level key\n-linters-settings:\n-  gofmt:\n-    rewrite-rules:\n-      - pattern: 'interface{}'\n-        replacement: 'any'\n-\n-  govet:\n+  settings:\n     # Matches what we use in corp as of 2023-12-07\n-    enable:\n-      - asmdecl\n-      - assign\n-      - atomic\n-      - bools\n-      - buildtag\n-      - cgocall\n-      - copylocks\n-      - deepequalerrors\n-      - errorsas\n-      - framepointer\n-      - httpresponse\n-      - ifaceassert\n-      - loopclosure\n-      - lostcancel\n-      - nilfunc\n-      - nilness\n-      - printf\n-      - reflectvaluecompare\n-      - shift\n-      - sigchanyzer\n-      - sortslice\n-      - stdmethods\n-      - stringintconv\n-      - structtag\n-      - testinggoroutine\n-      - tests\n-      - unmarshal\n-      - unreachable\n-      - unsafeptr\n-      - unusedresult\n-    settings:\n-      printf:\n-        # List of print function names to check (in addition to default)\n-        funcs:\n-          - github.com/tailscale/tailscale/types/logger.Discard\n-          # NOTE(andrew-d): this doesn't currently work because the printf\n-          # analyzer doesn't support type declarations\n-          #- github.com/tailscale/tailscale/types/logger.Logf\n-\n-  revive:\n-    enable-all-rules: false\n-    ignore-generated-header: true\n+    govet:\n+      enable:\n+        - asmdecl\n+        - assign\n+        - atomic\n+        - bools\n+        - buildtag\n+        - cgocall\n+        - copylocks\n+        - deepequalerrors\n+        - errorsas\n+        - framepointer\n+        - httpresponse\n+        - ifaceassert\n+        - loopclosure\n+        - lostcancel\n+        - nilfunc\n+        - nilness\n+        - printf\n+        - reflectvaluecompare\n+        - shift\n+        - sigchanyzer\n+        - sortslice\n+        - stdmethods\n+        - stringintconv\n+        - structtag\n+        - testinggoroutine\n+        - tests\n+        - unmarshal\n+        - unreachable\n+        - unsafeptr\n+        - unusedresult\n+      settings:\n+        printf:\n+          # List of print function names to check (in addition to default)\n+          funcs:\n+            - github.com/tailscale/tailscale/types/logger.Discard\n+            # NOTE(andrew-d): this doesn't currently work because the printf\n+            # analyzer doesn't support type declarations\n+            #- github.com/tailscale/tailscale/types/logger.Logf\n+    revive:\n+      enable-all-rules: false\n+      rules:\n+        - name: atomic\n+        - name: context-keys-type\n+        - name: defer\n+          arguments: [[\n+              # Calling 'recover' at the time a defer is registered (i.e. \"defer recover()\") has no effect.\n+              \"immediate-recover\",\n+              # Calling 'recover' outside of a deferred function has no effect\n+              \"recover\",\n+              # Returning values from a deferred function has no effect\n+              \"return\",\n+          ]]\n+        - name: duplicated-imports\n+        - name: errorf\n+        - name: string-of-int\n+        - name: time-equal\n+        - name: unconditional-recursion\n+        - name: useless-break\n+        - name: waitgroup-by-value\n+  exclusions:\n+    generated: lax\n+    presets:\n+      - comments\n+      - common-false-positives\n+      - legacy\n+      - std-error-handling\n     rules:\n-      - name: atomic\n-      - name: context-keys-type\n-      - name: defer\n-        arguments: [[\n-          # Calling 'recover' at the time a defer is registered (i.e. \"defer recover()\") has no effect.\n-          \"immediate-recover\",\n-          # Calling 'recover' outside of a deferred function has no effect\n-          \"recover\",\n-          # Returning values from a deferred function has no effect\n-          \"return\",\n-        ]]\n-      - name: duplicated-imports\n-      - name: errorf\n-      - name: string-of-int\n-      - name: time-equal\n-      - name: unconditional-recursion\n-      - name: useless-break\n-      - name: waitgroup-by-value\n+      # These are forks of an upstream package and thus are exempt from stylistic\n+      # changes that would make pulling in upstream changes harder.\n+      - path: tempfork/.*\\.go\n+        text: File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\n+      - path: util/singleflight/.*\\.go\n+        text: File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n+formatters:\n+  enable:\n+    - gofmt\n+    - goimports\n+  settings:\n+    gofmt:\n+      rewrite-rules:\n+        - pattern: interface{}\n+          replacement: any\n+  exclusions:\n+    generated: lax\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n---\n\n\n---\n\nChoice D:\nprober/prober.go\n@@ -559,8 +559,8 @@ func (p *Prober) RunHandler(w http.ResponseWriter, r *http.Request) error {\n \t\t\tPreviousSuccessRatio:  prevInfo.RecentSuccessRatio(),\n \t\t\tPreviousMedianLatency: prevInfo.RecentMedianLatency(),\n \t\t}\n-\t\tw.WriteHeader(respStatus)\n \t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tw.WriteHeader(respStatus)\n \t\tif err := json.NewEncoder(w).Encode(resp); err != nil {\n \t\t\treturn tsweb.Error(http.StatusInternalServerError, \"error encoding JSON response\", err)\n \t\t}\n---\nprober/prober_test.go\n@@ -598,6 +598,9 @@ func TestProberRunHandler(t *testing.T) {\n \t\t\t\t}\n \n \t\t\t\tif reqJSON {\n+\t\t\t\t\tif w.Header().Get(\"Content-Type\") != \"application/json\" {\n+\t\t\t\t\t\tt.Errorf(\"unexpected content type: got %q, want application/json\", w.Header().Get(\"Content-Type\"))\n+\t\t\t\t\t}\n \t\t\t\t\tvar gotJSON RunHandlerResponse\n \t\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), &gotJSON); err != nil {\n \t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, w.Body.String())\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nInstead of using the version package (which depends on tailcfg.CurrentCapabilityVersion) to get the git commit hash, do it directly using debug.BuildInfo. This way, when changing struct fields in tailcfg, we can successfully `go generate` it without compiler errors.\r\n\r\nUpdates #9634\r\nUpdates https://github.com/tailscale/corp/issues/26717\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -1463,15 +1463,30 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n+// AppendMatchingPeers returns base with all peers that match pred appended.\n+//\n+// It acquires b.mu to read the netmap but releases it before calling pred.\n func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+\tvar peers []tailcfg.NodeView\n+\n \tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n-\tret := base\n-\tif b.netMap == nil {\n-\t\treturn ret\n+\tif b.netMap != nil {\n+\t\t// All fields on b.netMap are immutable, so this is\n+\t\t// safe to copy and use outside the lock.\n+\t\tpeers = b.netMap.Peers\n \t}\n-\tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\tb.mu.Unlock()\n+\n+\tret := base\n+\tfor _, peer := range peers {\n+\t\t// The peers in b.netMap don't contain updates made via\n+\t\t// UpdateNetmapDelta. So only use PeerView in b.netMap for its NodeID,\n+\t\t// and then look up the latest copy in b.peers which is updated in\n+\t\t// response to UpdateNetmapDelta edits.\n+\t\tb.mu.Lock()\n+\t\tpeer, ok := b.peers[peer.ID()]\n+\t\tb.mu.Unlock()\n+\t\tif ok && pred(peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice B:\ntool/gocross/gocross.go\n@@ -15,9 +15,9 @@ import (\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"runtime/debug\"\n \n \t\"tailscale.com/atomicfile\"\n-\t\"tailscale.com/version\"\n )\n \n func main() {\n@@ -28,8 +28,19 @@ func main() {\n \t\t// any time.\n \t\tswitch os.Args[1] {\n \t\tcase \"gocross-version\":\n-\t\t\tfmt.Println(version.GetMeta().GitCommit)\n-\t\t\tos.Exit(0)\n+\t\t\tbi, ok := debug.ReadBuildInfo()\n+\t\t\tif !ok {\n+\t\t\t\tfmt.Fprintln(os.Stderr, \"failed getting build info\")\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\tfor _, s := range bi.Settings {\n+\t\t\t\tif s.Key == \"vcs.revision\" {\n+\t\t\t\t\tfmt.Println(s.Value)\n+\t\t\t\t\tos.Exit(0)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfmt.Fprintln(os.Stderr, \"did not find vcs.revision in build info\")\n+\t\t\tos.Exit(1)\n \t\tcase \"is-gocross\":\n \t\t\t// This subcommand exits with an error code when called on a\n \t\t\t// regular go binary, so it can be used to detect when `go` is\n@@ -85,9 +96,9 @@ func main() {\n \t\tpath := filepath.Join(toolchain, \"bin\") + string(os.PathListSeparator) + os.Getenv(\"PATH\")\n \t\tenv.Set(\"PATH\", path)\n \n-\t\tdebug(\"Input: %s\\n\", formatArgv(os.Args))\n-\t\tdebug(\"Command: %s\\n\", formatArgv(newArgv))\n-\t\tdebug(\"Set the following flags/envvars:\\n%s\\n\", env.Diff())\n+\t\tdebugf(\"Input: %s\\n\", formatArgv(os.Args))\n+\t\tdebugf(\"Command: %s\\n\", formatArgv(newArgv))\n+\t\tdebugf(\"Set the following flags/envvars:\\n%s\\n\", env.Diff())\n \n \t\targs = newArgv\n \t\tif err := env.Apply(); err != nil {\n@@ -103,7 +114,7 @@ func main() {\n //go:embed gocross-wrapper.sh\n var wrapperScript []byte\n \n-func debug(format string, args ...any) {\n+func debugf(format string, args ...any) {\n \tdebug := os.Getenv(\"GOCROSS_DEBUG\")\n \tvar (\n \t\tout *os.File\n---\ntool/gocross/gocross_test.go\n@@ -0,0 +1,19 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package main\n+\n+import (\n+\t\"testing\"\n+\n+\t\"tailscale.com/tstest/deptest\"\n+)\n+\n+func TestDeps(t *testing.T) {\n+\tdeptest.DepChecker{\n+\t\tBadDeps: map[string]string{\n+\t\t\t\"tailscale.com/tailcfg\": \"circular dependency via go generate\",\n+\t\t\t\"tailscale.com/version\": \"circular dependency via go generate\",\n+\t\t},\n+\t}.Check(t)\n+}\n---\n\n\n---\n\nChoice C:\nclientupdate/clientupdate_windows.go\n@@ -16,6 +16,7 @@ import (\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"strings\"\n+\t\"time\"\n \n \t\"github.com/google/uuid\"\n \t\"golang.org/x/sys/windows\"\n@@ -34,6 +35,12 @@ const (\n \t// It is used to re-launch the GUI process (tailscale-ipn.exe) after\n \t// install is complete.\n \twinExePathEnv = \"TS_UPDATE_WIN_EXE_PATH\"\n+\t// winVersionEnv is the environment variable that is set along with\n+\t// winMSIEnv and carries the version of tailscale that is being installed.\n+\t// It is used for logging purposes.\n+\twinVersionEnv = \"TS_UPDATE_WIN_VERSION\"\n+\t// updaterPrefix is the prefix for the temporary executable created by [makeSelfCopy].\n+\tupdaterPrefix = \"tailscale-updater\"\n )\n \n func makeSelfCopy() (origPathExe, tmpPathExe string, err error) {\n@@ -46,7 +53,7 @@ func makeSelfCopy() (origPathExe, tmpPathExe string, err error) {\n \t\treturn \"\", \"\", err\n \t}\n \tdefer f.Close()\n-\tf2, err := os.CreateTemp(\"\", \"tailscale-updater-*.exe\")\n+\tf2, err := os.CreateTemp(\"\", updaterPrefix+\"-*.exe\")\n \tif err != nil {\n \t\treturn \"\", \"\", err\n \t}\n@@ -137,7 +144,7 @@ you can run the command prompt as Administrator one of these ways:\n \tup.Logf(\"authenticode verification succeeded\")\n \n \tup.Logf(\"making tailscale.exe copy to switch to...\")\n-\tup.cleanupOldDownloads(filepath.Join(os.TempDir(), \"tailscale-updater-*.exe\"))\n+\tup.cleanupOldDownloads(filepath.Join(os.TempDir(), updaterPrefix+\"-*.exe\"))\n \tselfOrig, selfCopy, err := makeSelfCopy()\n \tif err != nil {\n \t\treturn err\n@@ -146,7 +153,7 @@ you can run the command prompt as Administrator one of these ways:\n \tup.Logf(\"running tailscale.exe copy for final install...\")\n \n \tcmd := exec.Command(selfCopy, \"update\")\n-\tcmd.Env = append(os.Environ(), winMSIEnv+\"=\"+msiTarget, winExePathEnv+\"=\"+selfOrig)\n+\tcmd.Env = append(os.Environ(), winMSIEnv+\"=\"+msiTarget, winExePathEnv+\"=\"+selfOrig, winVersionEnv+\"=\"+ver)\n \tcmd.Stdout = up.Stderr\n \tcmd.Stderr = up.Stderr\n \tcmd.Stdin = os.Stdin\n@@ -162,23 +169,62 @@ you can run the command prompt as Administrator one of these ways:\n func (up *Updater) installMSI(msi string) error {\n \tvar err error\n \tfor tries := 0; tries < 2; tries++ {\n-\t\tcmd := exec.Command(\"msiexec.exe\", \"/i\", filepath.Base(msi), \"/quiet\", \"/norestart\", \"/qn\")\n+\t\t// msiexec.exe requires exclusive access to the log file, so create a dedicated one for each run.\n+\t\tinstallLogPath := up.startNewLogFile(\"tailscale-installer\", os.Getenv(winVersionEnv))\n+\t\tup.Logf(\"Install log: %s\", installLogPath)\n+\t\tcmd := exec.Command(\"msiexec.exe\", \"/i\", filepath.Base(msi), \"/quiet\", \"/norestart\", \"/qn\", \"/L*v\", installLogPath)\n \t\tcmd.Dir = filepath.Dir(msi)\n \t\tcmd.Stdout = up.Stdout\n \t\tcmd.Stderr = up.Stderr\n \t\tcmd.Stdin = os.Stdin\n \t\terr = cmd.Run()\n-\t\tif err == nil {\n-\t\t\tbreak\n+\t\tswitch err := err.(type) {\n+\t\tcase nil:\n+\t\t\t// Success.\n+\t\t\treturn nil\n+\t\tcase *exec.ExitError:\n+\t\t\t// For possible error codes returned by Windows Installer, see\n+\t\t\t// https://web.archive.org/web/20250409144914/https://learn.microsoft.com/en-us/windows/win32/msi/error-codes\n+\t\t\tswitch windows.Errno(err.ExitCode()) {\n+\t\t\tcase windows.ERROR_SUCCESS_REBOOT_REQUIRED:\n+\t\t\t\t// In most cases, updating Tailscale should not require a reboot.\n+\t\t\t\t// If it does, it might be because we failed to close the GUI\n+\t\t\t\t// and the installer couldn't replace tailscale-ipn.exe.\n+\t\t\t\t// The old GUI will continue to run until the next reboot.\n+\t\t\t\t// Not ideal, but also not a retryable error.\n+\t\t\t\tup.Logf(\"[unexpected] reboot required\")\n+\t\t\t\treturn nil\n+\t\t\tcase windows.ERROR_SUCCESS_REBOOT_INITIATED:\n+\t\t\t\t// Same as above, but perhaps the device is configured to prompt\n+\t\t\t\t// the user to reboot and the user has chosen to reboot now.\n+\t\t\t\tup.Logf(\"[unexpected] reboot initiated\")\n+\t\t\t\treturn nil\n+\t\t\tcase windows.ERROR_INSTALL_ALREADY_RUNNING:\n+\t\t\t\t// The Windows Installer service is currently busy.\n+\t\t\t\t// It could be our own install initiated by user/MDM/GP, another MSI install or perhaps a Windows Update install.\n+\t\t\t\t// Anyway, we can't do anything about it right now. The user (or tailscaled) can retry later.\n+\t\t\t\t// Retrying now will likely fail, and is risky since we might uninstall the current version\n+\t\t\t\t// and then fail to install the new one, leaving the user with no Tailscale at all.\n+\t\t\t\t//\n+\t\t\t\t// TODO(nickkhyl,awly): should we check if this is actually a downgrade before uninstalling the current version?\n+\t\t\t\t// Also, maybe keep retrying the install longer if we uninstalled the current version due to a failed install attempt?\n+\t\t\t\tup.Logf(\"another installation is already in progress\")\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\tdefault:\n+\t\t\t// Everything else is a retryable error.\n \t\t}\n+\n \t\tup.Logf(\"Install attempt failed: %v\", err)\n \t\tuninstallVersion := up.currentVersion\n \t\tif v := os.Getenv(\"TS_DEBUG_UNINSTALL_VERSION\"); v != \"\" {\n \t\t\tuninstallVersion = v\n \t\t}\n+\t\tuninstallLogPath := up.startNewLogFile(\"tailscale-uninstaller\", uninstallVersion)\n \t\t// Assume it's a downgrade, which msiexec won't permit. Uninstall our current version first.\n \t\tup.Logf(\"Uninstalling current version %q for downgrade...\", uninstallVersion)\n-\t\tcmd = exec.Command(\"msiexec.exe\", \"/x\", msiUUIDForVersion(uninstallVersion), \"/norestart\", \"/qn\")\n+\t\tup.Logf(\"Uninstall log: %s\", uninstallLogPath)\n+\t\tcmd = exec.Command(\"msiexec.exe\", \"/x\", msiUUIDForVersion(uninstallVersion), \"/norestart\", \"/qn\", \"/L*v\", uninstallLogPath)\n \t\tcmd.Stdout = up.Stdout\n \t\tcmd.Stderr = up.Stderr\n \t\tcmd.Stdin = os.Stdin\n@@ -205,12 +251,14 @@ func (up *Updater) switchOutputToFile() (io.Closer, error) {\n \tvar logFilePath string\n \texePath, err := os.Executable()\n \tif err != nil {\n-\t\tlogFilePath = filepath.Join(os.TempDir(), \"tailscale-updater.log\")\n+\t\tlogFilePath = up.startNewLogFile(updaterPrefix, os.Getenv(winVersionEnv))\n \t} else {\n-\t\tlogFilePath = strings.TrimSuffix(exePath, \".exe\") + \".log\"\n+\t\t// Use the same suffix as the self-copy executable.\n+\t\tsuffix := strings.TrimSuffix(strings.TrimPrefix(filepath.Base(exePath), updaterPrefix), \".exe\")\n+\t\tlogFilePath = up.startNewLogFile(updaterPrefix, os.Getenv(winVersionEnv)+suffix)\n \t}\n \n-\tup.Logf(\"writing update output to %q\", logFilePath)\n+\tup.Logf(\"writing update output to: %s\", logFilePath)\n \tlogFile, err := os.Create(logFilePath)\n \tif err != nil {\n \t\treturn nil, err\n@@ -223,3 +271,20 @@ func (up *Updater) switchOutputToFile() (io.Closer, error) {\n \tup.Stderr = logFile\n \treturn logFile, nil\n }\n+\n+// startNewLogFile returns a name for a new log file.\n+// It cleans up any old log files with the same baseNamePrefix.\n+func (up *Updater) startNewLogFile(baseNamePrefix, baseNameSuffix string) string {\n+\tbaseName := fmt.Sprintf(\"%s-%s-%s.log\", baseNamePrefix,\n+\t\ttime.Now().Format(\"20060102T150405\"), baseNameSuffix)\n+\n+\tdir := filepath.Join(os.Getenv(\"ProgramData\"), \"Tailscale\", \"Logs\")\n+\tif err := os.MkdirAll(dir, 0700); err != nil {\n+\t\tup.Logf(\"failed to create log directory: %v\", err)\n+\t\treturn filepath.Join(os.TempDir(), baseName)\n+\t}\n+\n+\t// TODO(nickkhyl): preserve up to N old log files?\n+\tup.cleanupOldDownloads(filepath.Join(dir, baseNamePrefix+\"-*.log\"))\n+\treturn filepath.Join(dir, baseName)\n+}\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/file.go\n@@ -15,8 +15,10 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"os\"\n+\t\"os/user\"\n \t\"path\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"sync/atomic\"\n \t\"time\"\n@@ -452,6 +454,7 @@ var fileGetCmd = &ffcli.Command{\n \toverwrite:  overwrite existing file\n \trename:     write to a new number-suffixed filename`)\n \t\tffcomplete.Flag(fs, \"conflict\", ffcomplete.Fixed(\"skip\", \"overwrite\", \"rename\"))\n+\t\tfs.StringVar(&getArgs.chown, \"chown\", \"\", \"sets owner:group for received files\")\n \t\treturn fs\n \t})(),\n }\n@@ -461,6 +464,7 @@ var getArgs = struct {\n \tloop     bool\n \tverbose  bool\n \tconflict onConflict\n+\tchown    string\n }{conflict: skipOnExist}\n \n func numberedFileName(dir, name string, i int) string {\n@@ -512,7 +516,7 @@ func openFileOrSubstitute(dir, base string, action onConflict) (*os.File, error)\n \t}\n }\n \n-func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targetFile string, size int64, err error) {\n+func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string, chown string) (targetFile string, size int64, err error) {\n \trc, size, err := localClient.GetWaitingFile(ctx, wf.Name)\n \tif err != nil {\n \t\treturn \"\", 0, fmt.Errorf(\"opening inbox file %q: %w\", wf.Name, err)\n@@ -531,10 +535,51 @@ func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targe\n \t\tf.Close()\n \t\treturn \"\", 0, fmt.Errorf(\"failed to write %v: %v\", f.Name(), err)\n \t}\n+\tif chown != \"\" {\n+\t\tusr, grp, _ := strings.Cut(chown, \":\")\n+\n+\t\t// Set default values to allow for partial changes (e.g. `user` or `:staff`)\n+\t\tuid, gid, err := fileStat(f)\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to stat file: %v\", err)\n+\t\t}\n+\n+\t\tif usr != \"\" {\n+\t\t\tif uid, err = strconv.Atoi(usr); err != nil {\n+\t\t\t\tuser, err := user.Lookup(usr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup user: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif uid, err = strconv.Atoi(user.Uid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert uid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif grp != \"\" {\n+\t\t\tif gid, err = strconv.Atoi(grp); err != nil {\n+\t\t\t\tgroup, err := user.LookupGroup(grp)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup group: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif gid, err = strconv.Atoi(group.Gid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert gid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif err := f.Chown(uid, gid); err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to chown file: %v\", err)\n+\t\t}\n+\t}\n \treturn f.Name(), size, f.Close()\n }\n \n-func runFileGetOneBatch(ctx context.Context, dir string) []error {\n+func runFileGetOneBatch(ctx context.Context, dir, chown string) []error {\n \tvar wfs []apitype.WaitingFile\n \tvar err error\n \tvar errs []error\n@@ -563,7 +608,7 @@ func runFileGetOneBatch(ctx context.Context, dir string) []error {\n \t\t\terrs = append(errs, fmt.Errorf(\"too many errors in runFileGetOneBatch(). %d files unexamined\", len(wfs)-i))\n \t\t\tbreak\n \t\t}\n-\t\twrittenFile, size, err := receiveFile(ctx, wf, dir)\n+\t\twrittenFile, size, err := receiveFile(ctx, wf, dir, chown)\n \t\tif err != nil {\n \t\t\terrs = append(errs, err)\n \t\t\tcontinue\n@@ -602,7 +647,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t}\n \tif getArgs.loop {\n \t\tfor {\n-\t\t\terrs := runFileGetOneBatch(ctx, dir)\n+\t\t\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \t\t\tfor _, err := range errs {\n \t\t\t\toutln(err)\n \t\t\t}\n@@ -621,7 +666,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t\t\t}\n \t\t}\n \t}\n-\terrs := runFileGetOneBatch(ctx, dir)\n+\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \tif len(errs) == 0 {\n \t\treturn nil\n \t}\n@@ -635,6 +680,9 @@ func wipeInbox(ctx context.Context) error {\n \tif getArgs.wait {\n \t\treturn errors.New(\"can't use --wait with /dev/null target\")\n \t}\n+\tif getArgs.chown != \"\" {\n+\t\treturn errors.New(\"can't use --chown with /dev/null target\")\n+\t}\n \twfs, err := localClient.WaitingFiles(ctx)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting WaitingFiles: %w\", err)\n---\ncmd/tailscale/cli/file_stub.go\n@@ -0,0 +1,16 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build windows || wasm || plan9 || tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(_f *os.File) (int, int, error) {\n+\treturn -1, -1, errors.New(\"Not implemented\")\n+}\n---\ncmd/tailscale/cli/file_unix.go\n@@ -0,0 +1,26 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build !windows && !wasm && !plan9 && !tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(f *os.File) (int, int, error) {\n+\tif f == nil {\n+\t\treturn -1, -1, errors.New(\"file cannot be nil\")\n+\t}\n+\n+\tvar stat syscall.Stat_t\n+\tif err := syscall.Stat(f.Name(), &stat); err != nil {\n+\t\treturn -1, -1, err\n+\t}\n+\n+\treturn int(stat.Uid), int(stat.Gid), nil\n+}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes #15824\n\n\n---\n\nChoice A:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/drive.go\n@@ -4,6 +4,7 @@\n package ipnlocal\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"slices\"\n@@ -338,7 +339,7 @@ func (b *LocalBackend) driveRemotesFromPeers(nm *netmap.NetworkMap) []*drive.Rem\n \t\t\t\t// Check that the peer is allowed to share with us.\n \t\t\t\taddresses := peer.Addresses()\n \t\t\t\tfor _, p := range addresses.All() {\n-\t\t\t\t\tif cn.PeerHasCap(p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n+\t\t\t\t\tif cn.PeerHasCap(context.Background(), p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n---\nipn/ipnlocal/local.go\n@@ -96,6 +96,7 @@ import (\n \t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/util/clientmetric\"\n+\t\"tailscale.com/util/ctxkey\"\n \t\"tailscale.com/util/deephash\"\n \t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/goroutines\"\n@@ -1463,15 +1464,19 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+var nodeCtxLockedKey = ctxkey.New(\"localNodeContext-locked\", false)\n+\n+var ctxNodeContextLocked = nodeCtxLockedKey.WithValue(context.Background(), true)\n+\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(context.Context, tailcfg.NodeView) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tif pred(ctxNodeContextLocked, peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n@@ -6652,9 +6657,11 @@ func (b *LocalBackend) TestOnlyPublicKeys() (machineKey key.MachinePublic, nodeK\n \n // PeerHasCap reports whether the peer with the given Tailscale IP addresses\n // contains the given capability string, with any value(s).\n-func (b *localNodeContext) PeerHasCap(addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n-\tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n+func (b *localNodeContext) PeerHasCap(ctx context.Context, addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n+\tif !nodeCtxLockedKey.Value(ctx) {\n+\t\tb.mu.Lock()\n+\t\tdefer b.mu.Unlock()\n+\t}\n \treturn b.peerHasCapLocked(addr, wantCap)\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n+\tpeers := cn.AppendMatchingPeers(nil, func(ctx context.Context, p tailcfg.NodeView) bool {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n \t\tif self != p.User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(ctx, p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n@@ -241,7 +241,7 @@ func (b *LocalBackend) taildropTargetStatus(p tailcfg.NodeView) ipnstate.Taildro\n \t}\n \tif nm.User() != p.User() {\n \t\t// Different user must have the explicit file sharing target capability\n-\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(context.Background(), p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn ipnstate.TaildropTargetOwnedByOtherUser\n \t\t}\n---\n\n\n---\n\nChoice C:\ntsconsensus/tsconsensus_test.go\n@@ -26,6 +26,7 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/raft\"\n \t\"tailscale.com/client/tailscale\"\n+\t\"tailscale.com/cmd/testwrapper/flakytest\"\n \t\"tailscale.com/ipn/store/mem\"\n \t\"tailscale.com/net/netns\"\n \t\"tailscale.com/tailcfg\"\n@@ -574,6 +575,7 @@ func TestRejoin(t *testing.T) {\n }\n \n func TestOnlyTaggedPeersCanDialRaftPort(t *testing.T) {\n+\tflakytest.Mark(t, \"https://github.com/tailscale/tailscale/issues/15627\")\n \ttestConfig(t)\n \tctx := context.Background()\n \tclusterTag := \"tag:whatever\"\n@@ -631,6 +633,7 @@ func TestOnlyTaggedPeersCanDialRaftPort(t *testing.T) {\n }\n \n func TestOnlyTaggedPeersCanBeDialed(t *testing.T) {\n+\tflakytest.Mark(t, \"https://github.com/tailscale/tailscale/issues/15627\")\n \ttestConfig(t)\n \tctx := context.Background()\n \tclusterTag := \"tag:whatever\"\n---\n\n\n---\n\nChoice D:\nfeature/relayserver/relayserver.go\n@@ -72,10 +72,20 @@ func (e *extension) Init(host ipnext.Host) error {\n \tprofile, prefs := host.Profiles().CurrentProfileState()\n \te.profileStateChanged(profile, prefs, false)\n \thost.Hooks().ProfileStateChange.Add(e.profileStateChanged)\n-\t// TODO(jwhited): callback for netmap/nodeattr changes (e.hasNodeAttrRelayServer)\n+\thost.Hooks().OnSelfChange.Add(e.selfNodeViewChanged)\n \treturn nil\n }\n \n+func (e *extension) selfNodeViewChanged(nodeView tailcfg.NodeView) {\n+\te.mu.Lock()\n+\tdefer e.mu.Unlock()\n+\te.hasNodeAttrRelayServer = nodeView.HasCap(tailcfg.NodeAttrRelayServer)\n+\tif !e.hasNodeAttrRelayServer && e.server != nil {\n+\t\te.server.Close()\n+\t\te.server = nil\n+\t}\n+}\n+\n func (e *extension) profileStateChanged(_ ipn.LoginProfileView, prefs ipn.PrefsView, sameNode bool) {\n \te.mu.Lock()\n \tdefer e.mu.Unlock()\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nWe update `(*localNodeContext).AppendMatchingPeers`'s predicate to take a short-lived `PeerInfo` struct instead of `tailcfg.NodeView`. This allows the predicate to use `(*PeerInfo).HasCap()`, instead of calling back to `localNodeContext` causing the deadlock.\r\n\r\nFixes #15824\n\n---\n\nChoice A:\ntstest/integration/integration_test.go\n@@ -1942,6 +1942,8 @@ func (n *testNode) AwaitIP6() netip.Addr {\n \n // AwaitRunning waits for n to reach the IPN state \"Running\".\n func (n *testNode) AwaitRunning() {\n+\tt := n.env.t\n+\tt.Helper()\n \tn.AwaitBackendState(\"Running\")\n }\n \n@@ -2015,7 +2017,7 @@ func (n *testNode) Status() (*ipnstate.Status, error) {\n \t}\n \tst := new(ipnstate.Status)\n \tif err := json.Unmarshal(out, st); err != nil {\n-\t\treturn nil, fmt.Errorf(\"decoding tailscale status JSON: %w\", err)\n+\t\treturn nil, fmt.Errorf(\"decoding tailscale status JSON: %w\\njson:\\n%s\", err, out)\n \t}\n \treturn st, nil\n }\n---\n\n\n---\n\nChoice B:\ncmd/k8s-operator/deploy/crds/tailscale.com_connectors.yaml\n@@ -32,6 +32,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_dnsconfigs.yaml\n@@ -20,6 +20,9 @@ spec:\n           jsonPath: .status.nameserver.ip\n           name: NameserverIP\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -18,6 +18,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxygroups.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .spec.type\n           name: Type\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_recorders.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .status.devices[?(@.url != \"\")].url\n           name: URL\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -61,6 +61,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -312,6 +315,9 @@ spec:\n               jsonPath: .status.nameserver.ip\n               name: NameserverIP\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -492,6 +498,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -2803,6 +2812,9 @@ spec:\n               jsonPath: .spec.type\n               name: Type\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -3013,6 +3025,9 @@ spec:\n               jsonPath: .status.devices[?(@.url != \"\")].url\n               name: URL\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n---\nk8s-operator/apis/v1alpha1/types_connector.go\n@@ -24,6 +24,7 @@ var ConnectorKind = \"Connector\"\n // +kubebuilder:printcolumn:name=\"IsExitNode\",type=\"string\",JSONPath=`.status.isExitNode`,description=\"Whether this Connector instance defines an exit node.\"\n // +kubebuilder:printcolumn:name=\"IsAppConnector\",type=\"string\",JSONPath=`.status.isAppConnector`,description=\"Whether this Connector instance is an app connector.\"\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ConnectorReady\")].reason`,description=\"Status of the deployed Connector resources.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Connector defines a Tailscale node that will be deployed in the cluster. The\n // node can be configured to act as a Tailscale subnet router and/or a Tailscale\n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -16,6 +16,7 @@ var ProxyClassKind = \"ProxyClass\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyClassReady\")].reason`,description=\"Status of the ProxyClass.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyClass describes a set of configuration parameters that can be applied to\n // proxy resources created by the Tailscale Kubernetes operator.\n---\nk8s-operator/apis/v1alpha1/types_proxygroup.go\n@@ -14,6 +14,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=pg\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyGroupReady\")].reason`,description=\"Status of the deployed ProxyGroup resources.\"\n // +kubebuilder:printcolumn:name=\"Type\",type=\"string\",JSONPath=`.spec.type`,description=\"ProxyGroup type.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyGroup defines a set of Tailscale devices that will act as proxies.\n // Currently only egress ProxyGroups are supported.\n---\nk8s-operator/apis/v1alpha1/types_recorder.go\n@@ -15,6 +15,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=rec\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"RecorderReady\")].reason`,description=\"Status of the deployed Recorder resources.\"\n // +kubebuilder:printcolumn:name=\"URL\",type=\"string\",JSONPath=`.status.devices[?(@.url != \"\")].url`,description=\"URL on which the UI is exposed if enabled.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Recorder defines a tsrecorder device for recording SSH sessions. By default,\n // it will store recordings in a local ephemeral volume. If you want to persist\n---\nk8s-operator/apis/v1alpha1/types_tsdnsconfig.go\n@@ -18,6 +18,7 @@ var DNSConfigKind = \"DNSConfig\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster,shortName=dc\n // +kubebuilder:printcolumn:name=\"NameserverIP\",type=\"string\",JSONPath=`.status.nameserver.ip`,description=\"Service IP address of the nameserver\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // DNSConfig can be deployed to cluster to make a subset of Tailscale MagicDNS\n // names resolvable by cluster workloads. Use this if: A) you need to refer to\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local.go\n@@ -1463,18 +1463,60 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+// PeerContext provides contextual information about a peer.\n+type PeerContext interface {\n+\tNode() tailcfg.NodeView\n+\tCaps() tailcfg.PeerCapMap\n+}\n+\n+// peerContext is a short-lived struct containing information about a peer.\n+// It is not safe for concurrent use and [localNodeContext]'s mutex must be held\n+// when using it. Therefore, it must not be retained or used outside the scope\n+// of the predicate or callback it was passed to.\n+type peerContext struct {\n+\tself *localNodeContext\n+\tpeer tailcfg.NodeView\n+}\n+\n+func (p peerContext) Node() tailcfg.NodeView {\n+\tif p.self == nil {\n+\t\tpanic(\"peerInfo used outside of its scope\")\n+\t}\n+\treturn p.peer\n+}\n+\n+// HasCap reports whether the peer has the specified capability.\n+// It panics if used outside of the PeerInfo's scope.\n+func (p peerContext) Caps() tailcfg.PeerCapMap {\n+\tif p.self == nil {\n+\t\tpanic(\"peerInfo used outside of its scope\")\n+\t}\n+\tif p.peer.Addresses().Len() == 0 {\n+\t\treturn nil\n+\t}\n+\treturn p.self.peerCapsLocked(p.peer.Addresses().At(0).Addr())\n+}\n+\n+// AppendMatchingPeers appends to base all peers in the netmap that match the predicate.\n+// The predicate is called with the node context's internal mutex locked,\n+// so it must not call back into the backend or the node context.\n+// The PeerInfo struct is only valid during the predicate call,\n+// and must not be retained or used outside of it.\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(PeerContext) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n+\tpi := &peerContext{self: b}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tpi.peer = peer\n+\t\tif pred(pi) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n+\tpi.self = nil\n \treturn ret\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n-\t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n+\tpeers := cn.AppendMatchingPeers(nil, func(p PeerContext) bool {\n+\t\tif !p.Node().Valid() || p.Node().Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n-\t\tif self != p.User() {\n+\t\tif self != p.Node().User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Caps().HasCapability(tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -4968,7 +4968,7 @@ func (b *LocalBackend) authReconfig() {\n \t\treturn\n \t}\n \n-\toneCGNATRoute := shouldUseOneCGNATRoute(b.logf, b.sys.ControlKnobs(), version.OS())\n+\toneCGNATRoute := shouldUseOneCGNATRoute(b.logf, b.sys.NetMon.Get(), b.sys.ControlKnobs(), version.OS())\n \trcfg := b.routerConfig(cfg, prefs, oneCGNATRoute)\n \n \terr = b.e.Reconfig(cfg, rcfg, dcfg)\n@@ -4992,7 +4992,7 @@ func (b *LocalBackend) authReconfig() {\n //\n // The versionOS is a Tailscale-style version (\"iOS\", \"macOS\") and not\n // a runtime.GOOS.\n-func shouldUseOneCGNATRoute(logf logger.Logf, controlKnobs *controlknobs.Knobs, versionOS string) bool {\n+func shouldUseOneCGNATRoute(logf logger.Logf, mon *netmon.Monitor, controlKnobs *controlknobs.Knobs, versionOS string) bool {\n \tif controlKnobs != nil {\n \t\t// Explicit enabling or disabling always take precedence.\n \t\tif v, ok := controlKnobs.OneCGNAT.Load().Get(); ok {\n@@ -5007,7 +5007,7 @@ func shouldUseOneCGNATRoute(logf logger.Logf, controlKnobs *controlknobs.Knobs,\n \t// use fine-grained routes if another interfaces is also using the CGNAT\n \t// IP range.\n \tif versionOS == \"macOS\" {\n-\t\thasCGNATInterface, err := netmon.HasCGNATInterface()\n+\t\thasCGNATInterface, err := mon.HasCGNATInterface()\n \t\tif err != nil {\n \t\t\tlogf(\"shouldUseOneCGNATRoute: Could not determine if any interfaces use CGNAT: %v\", err)\n \t\t\treturn false\n---\nipn/ipnlocal/peerapi.go\n@@ -481,7 +481,7 @@ func (h *peerAPIHandler) handleServeInterfaces(w http.ResponseWriter, r *http.Re\n \t\tfmt.Fprintf(w, \"<h3>Could not get the default route: %s</h3>\\n\", html.EscapeString(err.Error()))\n \t}\n \n-\tif hasCGNATInterface, err := netmon.HasCGNATInterface(); hasCGNATInterface {\n+\tif hasCGNATInterface, err := h.ps.b.sys.NetMon.Get().HasCGNATInterface(); hasCGNATInterface {\n \t\tfmt.Fprintln(w, \"<p>There is another interface using the CGNAT range.</p>\")\n \t} else if err != nil {\n \t\tfmt.Fprintf(w, \"<p>Could not check for CGNAT interfaces: %s</p>\\n\", html.EscapeString(err.Error()))\n---\nnet/netmon/interfaces_test.go\n@@ -13,7 +13,7 @@ import (\n )\n \n func TestGetState(t *testing.T) {\n-\tst, err := getState()\n+\tst, err := getState(\"\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/netmon/netmon.go\n@@ -161,7 +161,7 @@ func (m *Monitor) InterfaceState() *State {\n }\n \n func (m *Monitor) interfaceStateUncached() (*State, error) {\n-\treturn getState()\n+\treturn getState(m.tsIfName)\n }\n \n // SetTailscaleInterfaceName sets the name of the Tailscale interface. For\n---\nnet/netmon/state.go\n@@ -461,21 +461,22 @@ func isTailscaleInterface(name string, ips []netip.Prefix) bool {\n // getPAC, if non-nil, returns the current PAC file URL.\n var getPAC func() string\n \n-// GetState returns the state of all the current machine's network interfaces.\n+// getState returns the state of all the current machine's network interfaces.\n //\n // It does not set the returned State.IsExpensive. The caller can populate that.\n //\n-// Deprecated: use netmon.Monitor.InterfaceState instead.\n-func getState() (*State, error) {\n+// optTSInterfaceName is the name of the Tailscale interface, if known.\n+func getState(optTSInterfaceName string) (*State, error) {\n \ts := &State{\n \t\tInterfaceIPs: make(map[string][]netip.Prefix),\n \t\tInterface:    make(map[string]Interface),\n \t}\n \tif err := ForeachInterface(func(ni Interface, pfxs []netip.Prefix) {\n+\t\tisTSInterfaceName := optTSInterfaceName != \"\" && ni.Name == optTSInterfaceName\n \t\tifUp := ni.IsUp()\n \t\ts.Interface[ni.Name] = ni\n \t\ts.InterfaceIPs[ni.Name] = append(s.InterfaceIPs[ni.Name], pfxs...)\n-\t\tif !ifUp || isTailscaleInterface(ni.Name, pfxs) {\n+\t\tif !ifUp || isTSInterfaceName || isTailscaleInterface(ni.Name, pfxs) {\n \t\t\treturn\n \t\t}\n \t\tfor _, pfx := range pfxs {\n@@ -755,11 +756,12 @@ func DefaultRoute() (DefaultRouteDetails, error) {\n \n // HasCGNATInterface reports whether there are any non-Tailscale interfaces that\n // use a CGNAT IP range.\n-func HasCGNATInterface() (bool, error) {\n+func (m *Monitor) HasCGNATInterface() (bool, error) {\n \thasCGNATInterface := false\n \tcgnatRange := tsaddr.CGNATRange()\n \terr := ForeachInterface(func(i Interface, pfxs []netip.Prefix) {\n-\t\tif hasCGNATInterface || !i.IsUp() || isTailscaleInterface(i.Name, pfxs) {\n+\t\tisTSInterfaceName := m.tsIfName != \"\" && i.Name == m.tsIfName\n+\t\tif hasCGNATInterface || !i.IsUp() || isTSInterfaceName || isTailscaleInterface(i.Name, pfxs) {\n \t\t\treturn\n \t\t}\n \t\tfor _, pfx := range pfxs {\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #5902\n\n---\n\nChoice A:\ndocs/k8s/operator-architecture.md\n@@ -131,11 +131,11 @@ flowchart TD\n \n [Documentation][kb-operator-l7-ingress]\n \n-L7 ingress is relatively similar to L3 ingress. It is configured via an\n-`Ingress` object instead of a `Service`, and uses `tailscale serve` to accept\n-traffic instead of configuring `iptables` or `nftables` rules. Note that we use\n-tailscaled's local API (`SetServeConfig`) to set serve config, not the\n-`tailscale serve` command.\n+The L7 ingress architecture diagram is relatively similar to L3 ingress. It is\n+configured via an `Ingress` object instead of a `Service`, and uses\n+`tailscale serve` to accept traffic instead of configuring `iptables` or\n+`nftables` rules. Note that we use tailscaled's local API (`SetServeConfig`) to\n+set serve config, not the `tailscale serve` command.\n \n ```mermaid\n %%{ init: { 'theme':'neutral' } }%%\n@@ -159,6 +159,10 @@ flowchart TD\n             state-secret[\"state Secret\"]\n         end\n \n+        subgraph cluster-scope[Cluster scoped resources]\n+            ingress-class[Tailscale IngressClass]\n+        end\n+\n         subgraph defaultns[namespace=default]\n             ingress[tailscale Ingress]\n             svc[\"Service\"]\n@@ -260,6 +264,8 @@ flowchart TD\n \n ## `ProxyGroup`\n \n+### Egress\n+\n [Documentation][kb-operator-l3-egress-proxygroup]\n \n The `ProxyGroup` custom resource manages a collection of proxy Pods that\n@@ -278,8 +284,6 @@ ports via the ClusterIP Service and its EndpointSlice. The operator then\n generates the egress ConfigMap that tells the `ProxyGroup` Pods which incoming\n ports map to which egress targets.\n \n-`ProxyGroups` currently only support egress.\n-\n ```mermaid\n %%{ init: { 'theme':'neutral' } }%%\n \n@@ -364,6 +368,86 @@ flowchart LR\n \n ```\n \n+### Ingress\n+\n+A ProxyGroup can also serve as a highly available set of proxies for an\n+Ingress resource. The `-0` Pod is always the replica that will issue a certificate\n+from Let's Encrypt.\n+\n+If the same Ingress config is applied in multiple clusters, ProxyGroup proxies\n+from each cluster will be valid targets for the ts.net DNS name, and the proxy\n+each client is routed to will depend on the same rules as for [high availability][kb-ha]\n+subnet routers, and is encoded in the client's netmap.\n+\n+```mermaid\n+%%{ init: { 'theme':'neutral' } }%%\n+flowchart LR\n+    classDef tsnode color:#fff,fill:#000;\n+    classDef pod fill:#fff;\n+\n+    subgraph Key\n+        ts[Tailscale device]:::tsnode\n+        pod((Pod)):::pod\n+        blank[\" \"]-->|WireGuard traffic| blank2[\" \"]\n+        blank3[\" \"]-->|Other network traffic| blank4[\" \"]\n+    end\n+\n+    subgraph k8s[Kubernetes cluster]\n+        subgraph tailscale-ns[namespace=tailscale]\n+            operator((operator)):::tsnode\n+            ingress-sts[\"StatefulSet\"]\n+            serve-cm[serve config ConfigMap]\n+            ingress-0((\"pg-0 (dst)\")):::tsnode\n+            ingress-1((\"pg-1 (dst)\")):::tsnode\n+            tls-secret[myapp.tails.ts.net Secret]\n+        end\n+\n+        subgraph defaultns[namespace=default]\n+            ingress[myapp.tails.ts.net Ingress]\n+            svc[\"myapp Service\"]\n+            svc --> pod1((pod1))\n+            svc --> pod2((pod2))\n+        end\n+\n+        subgraph cluster[Cluster scoped resources]\n+            ingress-class[Tailscale IngressClass]\n+            pg[ProxyGroup 'pg']\n+        end\n+    end\n+\n+    control[\"Tailscale control plane\"]\n+    ts-svc[\"myapp Tailscale Service\"]\n+\n+    client[\"client (src)\"]:::tsnode -->|dials https\\://myapp.tails.ts.net/api| ingress-1\n+    ingress-0 -->|forwards traffic| svc\n+    ingress-1 -->|forwards traffic| svc\n+    control -.->|creates| ts-svc\n+    operator -.->|creates myapp Tailscale Service| control\n+    control -.->|netmap points myapp Tailscale Service to pg-1| client\n+    operator -.->|creates| ingress-sts\n+    ingress-sts -.->|manages| ingress-0\n+    ingress-sts -.->|manages| ingress-1\n+    ingress-0 -.->|issues myapp.tails.ts.net cert| le[Let's Encrypt]\n+    ingress-0 -.->|stores cert| tls-secret\n+    ingress-1 -.->|reads cert| tls-secret\n+    operator -.->|watches| ingress\n+    operator -.->|watches| pg\n+    operator -.->|creates| serve-cm\n+    serve-cm -.->|mounted| ingress-0\n+    serve-cm -.->|mounted| ingress-1\n+    ingress -.->|/api prefix| svc\n+\n+    linkStyle 0 stroke:red;\n+    linkStyle 4 stroke:red;\n+\n+    linkStyle 1 stroke:blue;\n+    linkStyle 2 stroke:blue;\n+    linkStyle 3 stroke:blue;\n+    linkStyle 5 stroke:blue;\n+    linkStyle 6 stroke:blue;\n+\n+```\n+\n ## Connector\n \n [Subnet router and exit node documentation][kb-operator-connector]\n@@ -514,4 +598,5 @@ flowchart TD\n [kb-operator-connector]: https://tailscale.com/kb/1441/kubernetes-operator-connector\n [kb-operator-app-connector]: https://tailscale.com/kb/1517/kubernetes-operator-app-connector\n [kb-operator-recorder]: https://tailscale.com/kb/1484/kubernetes-operator-deploying-tsrecorder\n+[kb-ha]: https://tailscale.com/kb/1115/high-availability\n [k8s-impersonation]: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation\n---\n\n\n---\n\nChoice B:\n.github/workflows/test.yml\n@@ -305,7 +305,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: build some\n-      run: ./tool/go build ./ipn/... ./wgengine/ ./types/... ./control/controlclient\n+      run: ./tool/go build ./ipn/... ./ssh/tailssh ./wgengine/ ./types/... ./control/controlclient\n       env:\n         GOOS: ios\n         GOARCH: arm64\n@@ -375,7 +375,7 @@ jobs:\n       # some Android breakages early.\n       # TODO(bradfitz): better; see https://github.com/tailscale/tailscale/issues/4482\n     - name: build some\n-      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version\n+      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version ./ssh/tailssh\n       env:\n         GOOS: android\n         GOARCH: arm64\n---\nssh/tailssh/incubator.go\n@@ -7,7 +7,7 @@\n // and groups to the specified `--uid`, `--gid` and `--groups`, and\n // then launches the requested `--cmd`.\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd\n \n package tailssh\n \n---\nssh/tailssh/incubator_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package tailssh\n \n---\nssh/tailssh/tailssh.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n // Package tailssh is an SSH server integrated into Tailscale.\n package tailssh\n---\nssh/tailssh/user.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n package tailssh\n \n---\n\n\n---\n\nChoice C:\ncmd/k8s-operator/depaware.txt\n@@ -840,7 +840,7 @@ tailscale.com/cmd/k8s-operator dependencies: (generated by github.com/tailscale/\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/cmd/k8s-operator+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\ncmd/tailscaled/depaware.txt\n@@ -318,7 +318,7 @@ tailscale.com/cmd/tailscaled dependencies: (generated by github.com/tailscale/de\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/cmd/tailscaled+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\nipn/ipnlocal/local.go\n@@ -64,6 +64,7 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4886,7 +4887,6 @@ func (b *LocalBackend) authReconfig() {\n \tnm := cn.NetMap()\n \thasPAC := b.prevIfState.HasPAC()\n \tdisableSubnetsIfPAC := cn.SelfHasCap(tailcfg.NodeAttrDisableSubnetsIfPAC)\n-\tuserDialUseRoutes := cn.SelfHasCap(tailcfg.NodeAttrUserDialUseRoutes)\n \tdohURL, dohURLOK := cn.exitNodeCanProxyDNS(prefs.ExitNodeID())\n \tdcfg := cn.dnsConfigForNetmap(prefs, b.keyExpired, b.logf, version.OS())\n \t// If the current node is an app connector, ensure the app connector machine is started\n@@ -4947,7 +4947,7 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif userDialUseRoutes {\n+\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n \t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n \t} else {\n \t\tb.dialer.SetRoutes(nil, nil)\n---\nnet/dns/resolver/forwarder.go\n@@ -17,6 +17,7 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"net/url\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n@@ -740,18 +741,35 @@ func (f *forwarder) sendUDP(ctx context.Context, fq *forwardQuery, rr resolverAn\n \treturn out, nil\n }\n \n+var optDNSForwardUseRoutes = envknob.RegisterOptBool(\"TS_DEBUG_DNS_FORWARD_USE_ROUTES\")\n+\n+// ShouldUseRoutes reports whether the DNS resolver should consider routes when dialing\n+// upstream nameservers via TCP.\n+//\n+// If true, routes should be considered ([tsdial.Dialer.UserDial]), otherwise defer\n+// to the system routes ([tsdial.Dialer.SystemDial]).\n+//\n+// TODO(nickkhyl): Update [tsdial.Dialer] to reuse the bart.Table we create in net/tstun.Wrapper\n+// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n+// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n+//\n+// See tailscale/tailscale#12027.\n+func ShouldUseRoutes(knobs *controlknobs.Knobs) bool {\n+\tswitch runtime.GOOS {\n+\tcase \"android\", \"ios\":\n+\t\t// On mobile platforms with lower memory limits (e.g., 50MB on iOS),\n+\t\t// this behavior is still gated by the \"user-dial-routes\" nodeAttr.\n+\t\treturn knobs != nil && knobs.UserDialUseRoutes.Load()\n+\tdefault:\n+\t\t// On all other platforms, it is the default behavior,\n+\t\t// but it can be overridden with the \"TS_DEBUG_DNS_FORWARD_USE_ROUTES\" env var.\n+\t\tdoNotUseRoutes := optDNSForwardUseRoutes().EqualBool(false)\n+\t\treturn !doNotUseRoutes\n+\t}\n+}\n+\n func (f *forwarder) getDialerType() netx.DialFunc {\n-\tif f.controlKnobs != nil && f.controlKnobs.UserDialUseRoutes.Load() {\n-\t\t// It is safe to use UserDial as it dials external servers without going through Tailscale\n-\t\t// and closes connections on interface change in the same way as SystemDial does,\n-\t\t// thus preventing DNS resolution issues when switching between WiFi and cellular,\n-\t\t// but can also dial an internal DNS server on the Tailnet or via a subnet router.\n-\t\t//\n-\t\t// TODO(nickkhyl): Update tsdial.Dialer to reuse the bart.Table we create in net/tstun.Wrapper\n-\t\t// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n-\t\t// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n-\t\t//\n-\t\t// See https://github.com/tailscale/tailscale/issues/12027.\n+\tif ShouldUseRoutes(f.controlKnobs) {\n \t\treturn f.dialer.UserDial\n \t}\n \treturn f.dialer.SystemDial\n---\nnet/tsdial/tsdial.go\n@@ -151,6 +151,7 @@ func (d *Dialer) SetRoutes(routes, localRoutes []netip.Prefix) {\n \t\tfor _, r := range localRoutes {\n \t\t\trt.Insert(r, false)\n \t\t}\n+\t\td.logf(\"tsdial: bart table size: %d\", rt.Size())\n \t}\n \n \td.routes.Store(rt)\n---\ntsnet/depaware.txt\n@@ -271,7 +271,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/set.go\n@@ -83,7 +83,7 @@ func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n \tsetf.BoolVar(&setArgs.advertiseConnector, \"advertise-connector\", false, \"offer to be an app connector for domain specific internet traffic for the tailnet\")\n \tsetf.BoolVar(&setArgs.updateCheck, \"update-check\", true, \"notify about available Tailscale updates\")\n \tsetf.BoolVar(&setArgs.updateApply, \"auto-update\", false, \"automatically update to the latest available version\")\n-\tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, hidden+\"allow management plane to gather device posture information\")\n+\tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, \"allow management plane to gather device posture information\")\n \tsetf.BoolVar(&setArgs.runWebClient, \"webclient\", false, \"expose the web interface for managing this node over Tailscale at port 5252\")\n \tsetf.StringVar(&setArgs.relayServerPort, \"relay-server-port\", \"\", hidden+\"UDP port number (0 will pick a random unused port) for the relay server to bind to, on all interfaces, or empty string to disable relay server functionality\")\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/corp#27759\n\n---\n\nChoice A:\ncmd/natc/ippool/ippool.go\n@@ -24,7 +24,6 @@ var ErrNoIPsAvailable = errors.New(\"no IPs available\")\n type IPPool struct {\n \tperPeerMap syncs.Map[tailcfg.NodeID, *perPeerState]\n \tIPSet      *netipx.IPSet\n-\tV6ULA      netip.Prefix\n }\n \n func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bool) {\n@@ -44,15 +43,13 @@ func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bo\n func (ipp *IPPool) IPForDomain(from tailcfg.NodeID, domain string) (netip.Addr, error) {\n \tnpps := &perPeerState{\n \t\tipset: ipp.IPSet,\n-\t\tv6ULA: ipp.V6ULA,\n \t}\n \tps, _ := ipp.perPeerMap.LoadOrStore(from, npps)\n \treturn ps.ipForDomain(domain)\n }\n \n // perPeerState holds the state for a single peer.\n type perPeerState struct {\n-\tv6ULA netip.Prefix\n \tipset *netipx.IPSet\n \n \tmu           sync.Mutex\n---\ncmd/natc/ippool/ippool_test.go\n@@ -19,8 +19,7 @@ func TestIPPoolExhaustion(t *testing.T) {\n \tvar ipsb netipx.IPSetBuilder\n \tipsb.AddPrefix(smallPrefix)\n \taddrPool := must.Get(ipsb.IPSet())\n-\tv6ULA := netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\")\n-\tpool := IPPool{V6ULA: v6ULA, IPSet: addrPool}\n+\tpool := IPPool{IPSet: addrPool}\n \n \tassignedIPs := make(map[netip.Addr]string)\n \n@@ -52,9 +51,6 @@ func TestIPPoolExhaustion(t *testing.T) {\n \t\tif addr.Is4() && !smallPrefix.Contains(addr) {\n \t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, smallPrefix)\n \t\t}\n-\t\tif addr.Is6() && !v6ULA.Contains(addr) {\n-\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, v6ULA)\n-\t\t}\n \t}\n \n \t// expect one error for each iteration with the 5th domain\n@@ -73,7 +69,6 @@ func TestIPPool(t *testing.T) {\n \tipsb.AddPrefix(netip.MustParsePrefix(\"100.64.1.0/24\"))\n \taddrPool := must.Get(ipsb.IPSet())\n \tpool := IPPool{\n-\t\tV6ULA: netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n \t\tIPSet: addrPool,\n \t}\n \tfrom := tailcfg.NodeID(12345)\n---\ncmd/natc/natc.go\n@@ -153,7 +153,7 @@ func main() {\n \t\twhois:      lc,\n \t\tv6ULA:      v6ULA,\n \t\tignoreDsts: ignoreDstTable,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\troutes:     routes,\n \t\tdnsAddr:    dnsAddr,\n \t\tresolver:   net.DefaultResolver,\n---\ncmd/natc/natc_test.go\n@@ -270,7 +270,7 @@ func TestDNSResponse(t *testing.T) {\n \t\tignoreDsts: &bart.Table[bool]{},\n \t\troutes:     routes,\n \t\tv6ULA:      v6ULA,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\tdnsAddr:    dnsAddr,\n \t}\n \tc.ignoreDsts.Insert(netip.MustParsePrefix(\"8.8.4.4/32\"), true)\n---\n\n\n---\n\nChoice B:\nwgengine/magicsock/magicsock.go\n@@ -317,7 +317,11 @@ type Conn struct {\n \t// by node key, node ID, and discovery key.\n \tpeerMap peerMap\n \n-\t// discoInfo is the state for an active DiscoKey.\n+\t// relayManager manages allocation and handshaking of\n+\t// [tailscale.com/net/udprelay.Server] endpoints.\n+\trelayManager relayManager\n+\n+\t// discoInfo is the state for an active peer DiscoKey.\n \tdiscoInfo map[key.DiscoPublic]*discoInfo\n \n \t// netInfoFunc is a callback that provides a tailcfg.NetInfo when\n@@ -1628,9 +1632,11 @@ func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey ke\n \tvar di *discoInfo\n \tswitch {\n \tcase isRelayHandshakeMsg:\n-\t\t// TODO(jwhited): consider caching relay server disco shared keys\n-\t\tdi = &discoInfo{\n-\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n+\t\tvar ok bool\n+\t\tdi, ok = c.relayManager.discoInfo(dstDisco)\n+\t\tif !ok {\n+\t\t\tc.mu.Unlock()\n+\t\t\treturn false, errors.New(\"unknown relay server\")\n \t\t}\n \tcase c.peerMap.knownPeerDiscoKey(dstDisco):\n \t\tdi = c.discoInfoForKnownPeerLocked(dstDisco)\n@@ -1806,7 +1812,7 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \tswitch {\n \tcase shouldBeRelayHandshakeMsg:\n \t\tvar ok bool\n-\t\tdi, ok = c.discoInfoForRelayHandshakeLocked(sender, geneve.VNI)\n+\t\tdi, ok = c.relayManager.discoInfo(sender)\n \t\tif !ok {\n \t\t\tif debugDisco() {\n \t\t\t\tc.logf(\"magicsock: disco: ignoring disco-looking relay handshake frame, no active handshakes with key %v over VNI %d\", sender.ShortString(), geneve.VNI)\n@@ -1882,15 +1888,15 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t}\n \n \tif shouldBeRelayHandshakeMsg {\n-\t\t_, ok := dm.(*disco.BindUDPRelayEndpointChallenge)\n+\t\tchallenge, ok := dm.(*disco.BindUDPRelayEndpointChallenge)\n \t\tif !ok {\n \t\t\t// We successfully parsed the disco message, but it wasn't a\n \t\t\t// challenge. We should never receive other message types\n \t\t\t// from a relay server with the Geneve header control bit set.\n \t\t\tc.logf(\"[unexpected] %T packets should not come from a relay server with Geneve control bit set\", dm)\n \t\t\treturn\n \t\t}\n-\t\t// TODO(jwhited): handle the challenge on the associated [*endpoint]\n+\t\tc.relayManager.handleBindUDPRelayEndpointChallenge(challenge, di, src, geneve.VNI)\n \t\treturn\n \t}\n \n@@ -1909,18 +1915,28 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t\t\t}\n \t\t\treturn true\n \t\t})\n-\tcase *disco.CallMeMaybe:\n+\tcase *disco.CallMeMaybe, *disco.CallMeMaybeVia:\n+\t\tvar via *disco.CallMeMaybeVia\n+\t\tisVia := false\n+\t\tmsgType := \"CallMeMaybe\"\n+\t\tcmm, ok := dm.(*disco.CallMeMaybe)\n+\t\tif !ok {\n+\t\t\tvia = dm.(*disco.CallMeMaybeVia)\n+\t\t\tmsgType = \"CallMeMaybeVia\"\n+\t\t\tisVia = true\n+\t\t}\n+\n \t\tmetricRecvDiscoCallMeMaybe.Add(1)\n \t\tif !isDERP || derpNodeSrc.IsZero() {\n-\t\t\t// CallMeMaybe messages should only come via DERP.\n-\t\t\tc.logf(\"[unexpected] CallMeMaybe packets should only come via DERP\")\n+\t\t\t// CallMeMaybe{Via} messages should only come via DERP.\n+\t\t\tc.logf(\"[unexpected] %s packets should only come via DERP\", msgType)\n \t\t\treturn\n \t\t}\n \t\tnodeKey := derpNodeSrc\n \t\tep, ok := c.peerMap.endpointForNodeKey(nodeKey)\n \t\tif !ok {\n \t\t\tmetricRecvDiscoCallMeMaybeBadNode.Add(1)\n-\t\t\tc.logf(\"magicsock: disco: ignoring CallMeMaybe from %v; %v is unknown\", sender.ShortString(), derpNodeSrc.ShortString())\n+\t\t\tc.logf(\"magicsock: disco: ignoring %s from %v; %v is unknown\", msgType, sender.ShortString(), derpNodeSrc.ShortString())\n \t\t\treturn\n \t\t}\n \t\tepDisco := ep.disco.Load()\n@@ -1929,14 +1945,23 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t\t}\n \t\tif epDisco.key != di.discoKey {\n \t\t\tmetricRecvDiscoCallMeMaybeBadDisco.Add(1)\n-\t\t\tc.logf(\"[unexpected] CallMeMaybe from peer via DERP whose netmap discokey != disco source\")\n+\t\t\tc.logf(\"[unexpected] %s from peer via DERP whose netmap discokey != disco source\", msgType)\n \t\t\treturn\n \t\t}\n-\t\tc.dlogf(\"[v1] magicsock: disco: %v<-%v (%v, %v)  got call-me-maybe, %d endpoints\",\n-\t\t\tc.discoShort, epDisco.short,\n-\t\t\tep.publicKey.ShortString(), derpStr(src.String()),\n-\t\t\tlen(dm.MyNumber))\n-\t\tgo ep.handleCallMeMaybe(dm)\n+\t\tif isVia {\n+\t\t\tc.dlogf(\"[v1] magicsock: disco: %v<-%v via %v (%v, %v)  got call-me-maybe-via, %d endpoints\",\n+\t\t\t\tc.discoShort, epDisco.short, via.ServerDisco.ShortString(),\n+\t\t\t\tep.publicKey.ShortString(), derpStr(src.String()),\n+\t\t\t\tlen(via.AddrPorts))\n+\t\t\tc.relayManager.handleCallMeMaybeVia(via)\n+\t\t} else {\n+\t\t\tc.dlogf(\"[v1] magicsock: disco: %v<-%v (%v, %v)  got call-me-maybe, %d endpoints\",\n+\t\t\t\tc.discoShort, epDisco.short,\n+\t\t\t\tep.publicKey.ShortString(), derpStr(src.String()),\n+\t\t\t\tlen(cmm.MyNumber))\n+\t\t\tgo ep.handleCallMeMaybe(cmm)\n+\t\t}\n+\n \t}\n \treturn\n }\n@@ -2108,15 +2133,6 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \t}\n }\n \n-// discoInfoForRelayHandshakeLocked returns a [*discoInfo] for k and vni if one\n-// is known, i.e. an [endpoint] has an in-progress handshake with k over vni.\n-//\n-// c.mu must be held\n-func (c *Conn) discoInfoForRelayHandshakeLocked(k key.DiscoPublic, vni uint32) (*discoInfo, bool) {\n-\t// TODO(jwhited): implement\n-\treturn nil, false\n-}\n-\n // discoInfoForKnownPeerLocked returns the previous or new discoInfo for k.\n //\n // Callers must only pass key.DiscoPublic's that are present in and\n---\nwgengine/magicsock/relaymanager.go\n@@ -0,0 +1,51 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package magicsock\n+\n+import (\n+\t\"net/netip\"\n+\t\"sync\"\n+\n+\t\"tailscale.com/disco\"\n+\t\"tailscale.com/types/key\"\n+)\n+\n+// relayManager manages allocation and handshaking of\n+// [tailscale.com/net/udprelay.Server] endpoints. The zero value is ready for\n+// use.\n+type relayManager struct {\n+\tmu                     sync.Mutex // guards the following fields\n+\tdiscoInfoByServerDisco map[key.DiscoPublic]*discoInfo\n+}\n+\n+func (h *relayManager) initLocked() {\n+\tif h.discoInfoByServerDisco != nil {\n+\t\treturn\n+\t}\n+\th.discoInfoByServerDisco = make(map[key.DiscoPublic]*discoInfo)\n+}\n+\n+// discoInfo returns a [*discoInfo] for 'serverDisco' if there is an\n+// active/ongoing handshake with it, otherwise it returns nil, false.\n+func (h *relayManager) discoInfo(serverDisco key.DiscoPublic) (_ *discoInfo, ok bool) {\n+\th.mu.Lock()\n+\tdefer h.mu.Unlock()\n+\th.initLocked()\n+\tdi, ok := h.discoInfoByServerDisco[serverDisco]\n+\treturn di, ok\n+}\n+\n+func (h *relayManager) handleCallMeMaybeVia(dm *disco.CallMeMaybeVia) {\n+\th.mu.Lock()\n+\tdefer h.mu.Unlock()\n+\th.initLocked()\n+\t// TODO(jwhited): implement\n+}\n+\n+func (h *relayManager) handleBindUDPRelayEndpointChallenge(dm *disco.BindUDPRelayEndpointChallenge, di *discoInfo, src netip.AddrPort, vni uint32) {\n+\th.mu.Lock()\n+\tdefer h.mu.Unlock()\n+\th.initLocked()\n+\t// TODO(jwhited): implement\n+}\n---\n\n\n---\n\nChoice C:\ncmd/k8s-operator/depaware.txt\n@@ -840,7 +840,7 @@ tailscale.com/cmd/k8s-operator dependencies: (generated by github.com/tailscale/\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/cmd/k8s-operator+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\ncmd/tailscaled/depaware.txt\n@@ -318,7 +318,7 @@ tailscale.com/cmd/tailscaled dependencies: (generated by github.com/tailscale/de\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/cmd/tailscaled+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\nipn/ipnlocal/local.go\n@@ -64,6 +64,7 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4886,7 +4887,6 @@ func (b *LocalBackend) authReconfig() {\n \tnm := cn.NetMap()\n \thasPAC := b.prevIfState.HasPAC()\n \tdisableSubnetsIfPAC := cn.SelfHasCap(tailcfg.NodeAttrDisableSubnetsIfPAC)\n-\tuserDialUseRoutes := cn.SelfHasCap(tailcfg.NodeAttrUserDialUseRoutes)\n \tdohURL, dohURLOK := cn.exitNodeCanProxyDNS(prefs.ExitNodeID())\n \tdcfg := cn.dnsConfigForNetmap(prefs, b.keyExpired, b.logf, version.OS())\n \t// If the current node is an app connector, ensure the app connector machine is started\n@@ -4947,7 +4947,7 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif userDialUseRoutes {\n+\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n \t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n \t} else {\n \t\tb.dialer.SetRoutes(nil, nil)\n---\nnet/dns/resolver/forwarder.go\n@@ -17,6 +17,7 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"net/url\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n@@ -740,18 +741,35 @@ func (f *forwarder) sendUDP(ctx context.Context, fq *forwardQuery, rr resolverAn\n \treturn out, nil\n }\n \n+var optDNSForwardUseRoutes = envknob.RegisterOptBool(\"TS_DEBUG_DNS_FORWARD_USE_ROUTES\")\n+\n+// ShouldUseRoutes reports whether the DNS resolver should consider routes when dialing\n+// upstream nameservers via TCP.\n+//\n+// If true, routes should be considered ([tsdial.Dialer.UserDial]), otherwise defer\n+// to the system routes ([tsdial.Dialer.SystemDial]).\n+//\n+// TODO(nickkhyl): Update [tsdial.Dialer] to reuse the bart.Table we create in net/tstun.Wrapper\n+// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n+// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n+//\n+// See tailscale/tailscale#12027.\n+func ShouldUseRoutes(knobs *controlknobs.Knobs) bool {\n+\tswitch runtime.GOOS {\n+\tcase \"android\", \"ios\":\n+\t\t// On mobile platforms with lower memory limits (e.g., 50MB on iOS),\n+\t\t// this behavior is still gated by the \"user-dial-routes\" nodeAttr.\n+\t\treturn knobs != nil && knobs.UserDialUseRoutes.Load()\n+\tdefault:\n+\t\t// On all other platforms, it is the default behavior,\n+\t\t// but it can be overridden with the \"TS_DEBUG_DNS_FORWARD_USE_ROUTES\" env var.\n+\t\tdoNotUseRoutes := optDNSForwardUseRoutes().EqualBool(false)\n+\t\treturn !doNotUseRoutes\n+\t}\n+}\n+\n func (f *forwarder) getDialerType() netx.DialFunc {\n-\tif f.controlKnobs != nil && f.controlKnobs.UserDialUseRoutes.Load() {\n-\t\t// It is safe to use UserDial as it dials external servers without going through Tailscale\n-\t\t// and closes connections on interface change in the same way as SystemDial does,\n-\t\t// thus preventing DNS resolution issues when switching between WiFi and cellular,\n-\t\t// but can also dial an internal DNS server on the Tailnet or via a subnet router.\n-\t\t//\n-\t\t// TODO(nickkhyl): Update tsdial.Dialer to reuse the bart.Table we create in net/tstun.Wrapper\n-\t\t// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n-\t\t// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n-\t\t//\n-\t\t// See https://github.com/tailscale/tailscale/issues/12027.\n+\tif ShouldUseRoutes(f.controlKnobs) {\n \t\treturn f.dialer.UserDial\n \t}\n \treturn f.dialer.SystemDial\n---\nnet/tsdial/tsdial.go\n@@ -151,6 +151,7 @@ func (d *Dialer) SetRoutes(routes, localRoutes []netip.Prefix) {\n \t\tfor _, r := range localRoutes {\n \t\t\trt.Insert(r, false)\n \t\t}\n+\t\td.logf(\"tsdial: bart table size: %d\", rt.Size())\n \t}\n \n \td.routes.Store(rt)\n---\ntsnet/depaware.txt\n@@ -271,7 +271,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\n\n\n---\n\nChoice D:\ncontrol/controlclient/map_test.go\n@@ -17,6 +17,7 @@ import (\n \t\"github.com/google/go-cmp/cmp\"\n \t\"go4.org/mem\"\n \t\"tailscale.com/control/controlknobs\"\n+\t\"tailscale.com/health\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/tstime\"\n@@ -1136,3 +1137,34 @@ func BenchmarkMapSessionDelta(b *testing.B) {\n \t\t})\n \t}\n }\n+\n+// TestNetmapHealthIntegration checks that we get the expected health warnings\n+// from processing a map response and passing the NetworkMap to a health tracker\n+func TestNetmapHealthIntegration(t *testing.T) {\n+\tms := newTestMapSession(t, nil)\n+\tht := health.Tracker{}\n+\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tnm := ms.netmapForResponse(&tailcfg.MapResponse{\n+\t\tHealth: []string{\"Test message\"},\n+\t})\n+\tht.SetControlHealth(nm.ControlHealth)\n+\n+\tstate := ht.CurrentState()\n+\twarning, ok := state.Warnings[\"control-health\"]\n+\n+\tif !ok {\n+\t\tt.Fatal(\"no warning found in current state with code 'control-health'\")\n+\t}\n+\tif got, want := warning.Title, \"Coordination server reports an issue\"; got != want {\n+\t\tt.Errorf(\"warning.Title = %q, want %q\", got, want)\n+\t}\n+\tif got, want := warning.Severity, health.SeverityMedium; got != want {\n+\t\tt.Errorf(\"warning.Severity = %s, want %s\", got, want)\n+\t}\n+\tif got, want := warning.Text, \"The coordination server is reporting an health issue: Test message\"; got != want {\n+\t\tt.Errorf(\"warning.Text = %q, want %q\", got, want)\n+\t}\n+}\n---\nhealth/health.go\n@@ -402,7 +402,7 @@ func (t *Tracker) setUnhealthyLocked(w *Warnable, args Args) {\n \t\t\t// executed immediately. Otherwise, the callback should be enqueued to run once the Warnable\n \t\t\t// becomes visible.\n \t\t\tif w.IsVisible(ws, t.now) {\n-\t\t\t\tgo cb(w, w.unhealthyState(ws))\n+\t\t\t\tcb(w, w.unhealthyState(ws))\n \t\t\t\tcontinue\n \t\t\t}\n \n@@ -415,7 +415,7 @@ func (t *Tracker) setUnhealthyLocked(w *Warnable, args Args) {\n \t\t\t\t// Check if the Warnable is still unhealthy, as it could have become healthy between the time\n \t\t\t\t// the timer was set for and the time it was executed.\n \t\t\t\tif t.warnableVal[w] != nil {\n-\t\t\t\t\tgo cb(w, w.unhealthyState(ws))\n+\t\t\t\t\tcb(w, w.unhealthyState(ws))\n \t\t\t\t\tdelete(t.pendingVisibleTimers, w)\n \t\t\t\t}\n \t\t\t})\n@@ -449,7 +449,7 @@ func (t *Tracker) setHealthyLocked(w *Warnable) {\n \t}\n \n \tfor _, cb := range t.watchers {\n-\t\tgo cb(w, nil)\n+\t\tcb(w, nil)\n \t}\n }\n \n@@ -483,6 +483,16 @@ func (t *Tracker) AppendWarnableDebugFlags(base []string) []string {\n // The provided callback function will be executed in its own goroutine. The returned function can be used\n // to unregister the callback.\n func (t *Tracker) RegisterWatcher(cb func(w *Warnable, r *UnhealthyState)) (unregister func()) {\n+\treturn t.registerSyncWatcher(func(w *Warnable, r *UnhealthyState) {\n+\t\tgo cb(w, r)\n+\t})\n+}\n+\n+// registerSyncWatcher adds a function that will be called whenever the health\n+// state of any Warnable changes. The provided callback function will be\n+// executed synchronously. Call RegisterWatcher to register any callbacks that\n+// won't return from execution immediately.\n+func (t *Tracker) registerSyncWatcher(cb func(w *Warnable, r *UnhealthyState)) (unregister func()) {\n \tif t.nil() {\n \t\treturn func() {}\n \t}\n---\nhealth/health_test.go\n@@ -451,3 +451,88 @@ func TestNoDERPHomeWarnableManual(t *testing.T) {\n \t\tt.Fatalf(\"got unexpected noDERPHomeWarnable warnable: %v\", ws)\n \t}\n }\n+\n+func TestControlHealth(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\tstate := ht.CurrentState()\n+\twarning, ok := state.Warnings[\"control-health\"]\n+\n+\tif !ok {\n+\t\tt.Fatal(\"no warning found in current state with code 'control-health'\")\n+\t}\n+\tif got, want := warning.Title, \"Coordination server reports an issue\"; got != want {\n+\t\tt.Errorf(\"warning.Title = %q, want %q\", got, want)\n+\t}\n+\tif got, want := warning.Severity, SeverityMedium; got != want {\n+\t\tt.Errorf(\"warning.Severity = %s, want %s\", got, want)\n+\t}\n+\tif got, want := warning.Text, \"The coordination server is reporting an health issue: Test message\"; got != want {\n+\t\tt.Errorf(\"warning.Text = %q, want %q\", got, want)\n+\t}\n+}\n+\n+func TestControlHealthNotifiesOnChange(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tif !gotNotified {\n+\t\tt.Errorf(\"watcher did not get called, want it to be called\")\n+\t}\n+}\n+\n+func TestControlHealthNoNotifyOnUnchanged(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\t// Set up an existing control health issue\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\t// Now register our watcher\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\t// Send the same control health message again - should not notify\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tif gotNotified {\n+\t\tt.Errorf(\"watcher got called, want it to not be called\")\n+\t}\n+}\n+\n+func TestControlHealthIgnoredOutsideMapPoll(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tstate := ht.CurrentState()\n+\t_, ok := state.Warnings[\"control-health\"]\n+\n+\tif ok {\n+\t\tt.Error(\"got a warning with code 'control-health', want none\")\n+\t}\n+\n+\tif gotNotified {\n+\t\tt.Error(\"watcher got called, want it to not be called\")\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nTS_CONTROL_IS_PLAINTEXT_HTTP no longer does anything as of\n8fd471ce5748d2129dba584b4fa14b0d29229299\n\nUpdates #13597\n\n\n---\n\nChoice A:\ntstest/integration/integration.go\n@@ -684,7 +684,6 @@ func (n *TestNode) StartDaemonAsIPNGOOS(ipnGOOS string) *Daemon {\n \t\tcmd.Args = append(cmd.Args, \"--config=\"+n.configFile)\n \t}\n \tcmd.Env = append(os.Environ(),\n-\t\t\"TS_CONTROL_IS_PLAINTEXT_HTTP=1\",\n \t\t\"TS_DEBUG_PERMIT_HTTP_C2N=1\",\n \t\t\"TS_LOG_TARGET=\"+n.env.LogCatcherServer.URL,\n \t\t\"HTTP_PROXY=\"+n.env.TrafficTrapServer.URL,\n---\n\n\n---\n\nChoice B:\ncontrol/controlclient/map_test.go\n@@ -17,6 +17,7 @@ import (\n \t\"github.com/google/go-cmp/cmp\"\n \t\"go4.org/mem\"\n \t\"tailscale.com/control/controlknobs\"\n+\t\"tailscale.com/health\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/tstime\"\n@@ -1136,3 +1137,34 @@ func BenchmarkMapSessionDelta(b *testing.B) {\n \t\t})\n \t}\n }\n+\n+// TestNetmapHealthIntegration checks that we get the expected health warnings\n+// from processing a map response and passing the NetworkMap to a health tracker\n+func TestNetmapHealthIntegration(t *testing.T) {\n+\tms := newTestMapSession(t, nil)\n+\tht := health.Tracker{}\n+\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tnm := ms.netmapForResponse(&tailcfg.MapResponse{\n+\t\tHealth: []string{\"Test message\"},\n+\t})\n+\tht.SetControlHealth(nm.ControlHealth)\n+\n+\tstate := ht.CurrentState()\n+\twarning, ok := state.Warnings[\"control-health\"]\n+\n+\tif !ok {\n+\t\tt.Fatal(\"no warning found in current state with code 'control-health'\")\n+\t}\n+\tif got, want := warning.Title, \"Coordination server reports an issue\"; got != want {\n+\t\tt.Errorf(\"warning.Title = %q, want %q\", got, want)\n+\t}\n+\tif got, want := warning.Severity, health.SeverityMedium; got != want {\n+\t\tt.Errorf(\"warning.Severity = %s, want %s\", got, want)\n+\t}\n+\tif got, want := warning.Text, \"The coordination server is reporting an health issue: Test message\"; got != want {\n+\t\tt.Errorf(\"warning.Text = %q, want %q\", got, want)\n+\t}\n+}\n---\nhealth/health.go\n@@ -402,7 +402,7 @@ func (t *Tracker) setUnhealthyLocked(w *Warnable, args Args) {\n \t\t\t// executed immediately. Otherwise, the callback should be enqueued to run once the Warnable\n \t\t\t// becomes visible.\n \t\t\tif w.IsVisible(ws, t.now) {\n-\t\t\t\tgo cb(w, w.unhealthyState(ws))\n+\t\t\t\tcb(w, w.unhealthyState(ws))\n \t\t\t\tcontinue\n \t\t\t}\n \n@@ -415,7 +415,7 @@ func (t *Tracker) setUnhealthyLocked(w *Warnable, args Args) {\n \t\t\t\t// Check if the Warnable is still unhealthy, as it could have become healthy between the time\n \t\t\t\t// the timer was set for and the time it was executed.\n \t\t\t\tif t.warnableVal[w] != nil {\n-\t\t\t\t\tgo cb(w, w.unhealthyState(ws))\n+\t\t\t\t\tcb(w, w.unhealthyState(ws))\n \t\t\t\t\tdelete(t.pendingVisibleTimers, w)\n \t\t\t\t}\n \t\t\t})\n@@ -449,7 +449,7 @@ func (t *Tracker) setHealthyLocked(w *Warnable) {\n \t}\n \n \tfor _, cb := range t.watchers {\n-\t\tgo cb(w, nil)\n+\t\tcb(w, nil)\n \t}\n }\n \n@@ -483,6 +483,16 @@ func (t *Tracker) AppendWarnableDebugFlags(base []string) []string {\n // The provided callback function will be executed in its own goroutine. The returned function can be used\n // to unregister the callback.\n func (t *Tracker) RegisterWatcher(cb func(w *Warnable, r *UnhealthyState)) (unregister func()) {\n+\treturn t.registerSyncWatcher(func(w *Warnable, r *UnhealthyState) {\n+\t\tgo cb(w, r)\n+\t})\n+}\n+\n+// registerSyncWatcher adds a function that will be called whenever the health\n+// state of any Warnable changes. The provided callback function will be\n+// executed synchronously. Call RegisterWatcher to register any callbacks that\n+// won't return from execution immediately.\n+func (t *Tracker) registerSyncWatcher(cb func(w *Warnable, r *UnhealthyState)) (unregister func()) {\n \tif t.nil() {\n \t\treturn func() {}\n \t}\n---\nhealth/health_test.go\n@@ -451,3 +451,88 @@ func TestNoDERPHomeWarnableManual(t *testing.T) {\n \t\tt.Fatalf(\"got unexpected noDERPHomeWarnable warnable: %v\", ws)\n \t}\n }\n+\n+func TestControlHealth(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\tstate := ht.CurrentState()\n+\twarning, ok := state.Warnings[\"control-health\"]\n+\n+\tif !ok {\n+\t\tt.Fatal(\"no warning found in current state with code 'control-health'\")\n+\t}\n+\tif got, want := warning.Title, \"Coordination server reports an issue\"; got != want {\n+\t\tt.Errorf(\"warning.Title = %q, want %q\", got, want)\n+\t}\n+\tif got, want := warning.Severity, SeverityMedium; got != want {\n+\t\tt.Errorf(\"warning.Severity = %s, want %s\", got, want)\n+\t}\n+\tif got, want := warning.Text, \"The coordination server is reporting an health issue: Test message\"; got != want {\n+\t\tt.Errorf(\"warning.Text = %q, want %q\", got, want)\n+\t}\n+}\n+\n+func TestControlHealthNotifiesOnChange(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tif !gotNotified {\n+\t\tt.Errorf(\"watcher did not get called, want it to be called\")\n+\t}\n+}\n+\n+func TestControlHealthNoNotifyOnUnchanged(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\t// Set up an existing control health issue\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\t// Now register our watcher\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\t// Send the same control health message again - should not notify\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tif gotNotified {\n+\t\tt.Errorf(\"watcher got called, want it to not be called\")\n+\t}\n+}\n+\n+func TestControlHealthIgnoredOutsideMapPoll(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tstate := ht.CurrentState()\n+\t_, ok := state.Warnings[\"control-health\"]\n+\n+\tif ok {\n+\t\tt.Error(\"got a warning with code 'control-health', want none\")\n+\t}\n+\n+\tif gotNotified {\n+\t\tt.Error(\"watcher got called, want it to not be called\")\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\ncmd/k8s-operator/proxygroup.go\n@@ -461,15 +461,15 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \n \t\tvar existingCfgSecret *corev1.Secret // unmodified copy of secret\n \t\tif err := r.Get(ctx, client.ObjectKeyFromObject(cfgSecret), cfgSecret); err == nil {\n-\t\t\tlogger.Debugf(\"secret %s/%s already exists\", cfgSecret.GetNamespace(), cfgSecret.GetName())\n+\t\t\tlogger.Debugf(\"Secret %s/%s already exists\", cfgSecret.GetNamespace(), cfgSecret.GetName())\n \t\t\texistingCfgSecret = cfgSecret.DeepCopy()\n \t\t} else if !apierrors.IsNotFound(err) {\n \t\t\treturn \"\", err\n \t\t}\n \n \t\tvar authKey string\n \t\tif existingCfgSecret == nil {\n-\t\t\tlogger.Debugf(\"creating authkey for new ProxyGroup proxy\")\n+\t\t\tlogger.Debugf(\"Creating authkey for new ProxyGroup proxy\")\n \t\t\ttags := pg.Spec.Tags.Stringify()\n \t\t\tif len(tags) == 0 {\n \t\t\t\ttags = r.defaultTags\n@@ -490,7 +490,7 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t\tif err != nil {\n \t\t\t\treturn \"\", fmt.Errorf(\"error marshalling tailscaled config: %w\", err)\n \t\t\t}\n-\t\t\tmak.Set(&cfgSecret.StringData, tsoperator.TailscaledConfigFileName(cap), string(cfgJSON))\n+\t\t\tmak.Set(&cfgSecret.Data, tsoperator.TailscaledConfigFileName(cap), cfgJSON)\n \t\t}\n \n \t\t// The config sha256 sum is a value for a hash annotation used to trigger\n@@ -520,12 +520,14 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t}\n \n \t\tif existingCfgSecret != nil {\n-\t\t\tlogger.Debugf(\"patching the existing ProxyGroup config Secret %s\", cfgSecret.Name)\n-\t\t\tif err := r.Patch(ctx, cfgSecret, client.MergeFrom(existingCfgSecret)); err != nil {\n-\t\t\t\treturn \"\", err\n+\t\t\tif !apiequality.Semantic.DeepEqual(existingCfgSecret, cfgSecret) {\n+\t\t\t\tlogger.Debugf(\"Updating the existing ProxyGroup config Secret %s\", cfgSecret.Name)\n+\t\t\t\tif err := r.Update(ctx, cfgSecret); err != nil {\n+\t\t\t\t\treturn \"\", err\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n-\t\t\tlogger.Debugf(\"creating a new config Secret %s for the ProxyGroup\", cfgSecret.Name)\n+\t\t\tlogger.Debugf(\"Creating a new config Secret %s for the ProxyGroup\", cfgSecret.Name)\n \t\t\tif err := r.Create(ctx, cfgSecret); err != nil {\n \t\t\t\treturn \"\", err\n \t\t\t}\n---\ncmd/k8s-operator/proxygroup_test.go\n@@ -475,8 +475,6 @@ func TestIngressAdvertiseServicesConfigPreserved(t *testing.T) {\n \t\t\tName:      pgConfigSecretName(pgName, 0),\n \t\t\tNamespace: tsNamespace,\n \t\t},\n-\t\t// Write directly to Data because the fake client doesn't copy the write-only\n-\t\t// StringData field across to Data for us.\n \t\tData: map[string][]byte{\n \t\t\ttsoperator.TailscaledConfigFileName(106): existingConfigBytes,\n \t\t},\n@@ -514,10 +512,10 @@ func TestIngressAdvertiseServicesConfigPreserved(t *testing.T) {\n \t\t\tNamespace:       tsNamespace,\n \t\t\tResourceVersion: \"2\",\n \t\t},\n-\t\tStringData: map[string]string{\n-\t\t\ttsoperator.TailscaledConfigFileName(106): string(expectedConfigBytes),\n+\t\tData: map[string][]byte{\n+\t\t\ttsoperator.TailscaledConfigFileName(106): expectedConfigBytes,\n \t\t},\n-\t}, omitSecretData)\n+\t})\n }\n \n func verifyProxyGroupCounts(t *testing.T, r *ProxyGroupReconciler, wantIngress, wantEgress int) {\n@@ -620,11 +618,3 @@ func addNodeIDToStateSecrets(t *testing.T, fc client.WithWatch, pg *tsapi.ProxyG\n \t\t})\n \t}\n }\n-\n-// The operator mostly writes to StringData and reads from Data, but the fake\n-// client doesn't copy StringData across to Data on write. When comparing actual\n-// vs expected Secrets, use this function to only check what the operator writes\n-// to StringData.\n-func omitSecretData(secret *corev1.Secret) {\n-\tsecret.Data = nil\n-}\n---\n\n\n---\n\nChoice D:\nipn/localapi/localapi.go\n@@ -397,6 +397,15 @@ func (h *Handler) serveBugReport(w http.ResponseWriter, r *http.Request) {\n \t// OS-specific details\n \th.logf.JSON(1, \"UserBugReportOS\", osdiag.SupportInfo(osdiag.LogSupportInfoReasonBugReport))\n \n+\t// Tailnet lock details\n+\tst := h.b.NetworkLockStatus()\n+\tif st.Enabled {\n+\t\th.logf.JSON(1, \"UserBugReportTailnetLockStatus\", st)\n+\t\tif st.NodeKeySignature != nil {\n+\t\t\th.logf(\"user bugreport tailnet lock signature: %s\", st.NodeKeySignature.String())\n+\t\t}\n+\t}\n+\n \tif defBool(r.URL.Query().Get(\"diagnose\"), false) {\n \t\th.b.Doctor(r.Context(), logger.WithPrefix(h.logf, \"diag: \"))\n \t}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\ncmd/k8s-operator/proxygroup.go\n@@ -461,15 +461,15 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \n \t\tvar existingCfgSecret *corev1.Secret // unmodified copy of secret\n \t\tif err := r.Get(ctx, client.ObjectKeyFromObject(cfgSecret), cfgSecret); err == nil {\n-\t\t\tlogger.Debugf(\"secret %s/%s already exists\", cfgSecret.GetNamespace(), cfgSecret.GetName())\n+\t\t\tlogger.Debugf(\"Secret %s/%s already exists\", cfgSecret.GetNamespace(), cfgSecret.GetName())\n \t\t\texistingCfgSecret = cfgSecret.DeepCopy()\n \t\t} else if !apierrors.IsNotFound(err) {\n \t\t\treturn \"\", err\n \t\t}\n \n \t\tvar authKey string\n \t\tif existingCfgSecret == nil {\n-\t\t\tlogger.Debugf(\"creating authkey for new ProxyGroup proxy\")\n+\t\t\tlogger.Debugf(\"Creating authkey for new ProxyGroup proxy\")\n \t\t\ttags := pg.Spec.Tags.Stringify()\n \t\t\tif len(tags) == 0 {\n \t\t\t\ttags = r.defaultTags\n@@ -490,7 +490,7 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t\tif err != nil {\n \t\t\t\treturn \"\", fmt.Errorf(\"error marshalling tailscaled config: %w\", err)\n \t\t\t}\n-\t\t\tmak.Set(&cfgSecret.StringData, tsoperator.TailscaledConfigFileName(cap), string(cfgJSON))\n+\t\t\tmak.Set(&cfgSecret.Data, tsoperator.TailscaledConfigFileName(cap), cfgJSON)\n \t\t}\n \n \t\t// The config sha256 sum is a value for a hash annotation used to trigger\n@@ -520,12 +520,14 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t}\n \n \t\tif existingCfgSecret != nil {\n-\t\t\tlogger.Debugf(\"patching the existing ProxyGroup config Secret %s\", cfgSecret.Name)\n-\t\t\tif err := r.Patch(ctx, cfgSecret, client.MergeFrom(existingCfgSecret)); err != nil {\n-\t\t\t\treturn \"\", err\n+\t\t\tif !apiequality.Semantic.DeepEqual(existingCfgSecret, cfgSecret) {\n+\t\t\t\tlogger.Debugf(\"Updating the existing ProxyGroup config Secret %s\", cfgSecret.Name)\n+\t\t\t\tif err := r.Update(ctx, cfgSecret); err != nil {\n+\t\t\t\t\treturn \"\", err\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n-\t\t\tlogger.Debugf(\"creating a new config Secret %s for the ProxyGroup\", cfgSecret.Name)\n+\t\t\tlogger.Debugf(\"Creating a new config Secret %s for the ProxyGroup\", cfgSecret.Name)\n \t\t\tif err := r.Create(ctx, cfgSecret); err != nil {\n \t\t\t\treturn \"\", err\n \t\t\t}\n---\ncmd/k8s-operator/proxygroup_test.go\n@@ -475,8 +475,6 @@ func TestIngressAdvertiseServicesConfigPreserved(t *testing.T) {\n \t\t\tName:      pgConfigSecretName(pgName, 0),\n \t\t\tNamespace: tsNamespace,\n \t\t},\n-\t\t// Write directly to Data because the fake client doesn't copy the write-only\n-\t\t// StringData field across to Data for us.\n \t\tData: map[string][]byte{\n \t\t\ttsoperator.TailscaledConfigFileName(106): existingConfigBytes,\n \t\t},\n@@ -514,10 +512,10 @@ func TestIngressAdvertiseServicesConfigPreserved(t *testing.T) {\n \t\t\tNamespace:       tsNamespace,\n \t\t\tResourceVersion: \"2\",\n \t\t},\n-\t\tStringData: map[string]string{\n-\t\t\ttsoperator.TailscaledConfigFileName(106): string(expectedConfigBytes),\n+\t\tData: map[string][]byte{\n+\t\t\ttsoperator.TailscaledConfigFileName(106): expectedConfigBytes,\n \t\t},\n-\t}, omitSecretData)\n+\t})\n }\n \n func verifyProxyGroupCounts(t *testing.T, r *ProxyGroupReconciler, wantIngress, wantEgress int) {\n@@ -620,11 +618,3 @@ func addNodeIDToStateSecrets(t *testing.T, fc client.WithWatch, pg *tsapi.ProxyG\n \t\t})\n \t}\n }\n-\n-// The operator mostly writes to StringData and reads from Data, but the fake\n-// client doesn't copy StringData across to Data on write. When comparing actual\n-// vs expected Secrets, use this function to only check what the operator writes\n-// to StringData.\n-func omitSecretData(secret *corev1.Secret) {\n-\tsecret.Data = nil\n-}\n---\n\n\n---\n\nChoice B:\ncmd/k8s-operator/deploy/chart/templates/deployment.yaml\n@@ -64,6 +64,8 @@ spec:\n               value: operator\n             - name: OPERATOR_LOGGING\n               value: {{ .Values.operatorConfig.logging }}\n+            - name: OPERATOR_EPHEMERAL\n+              value: \"{{ .Values.operatorConfig.ephemeral }}\"\n             - name: OPERATOR_NAMESPACE\n               valueFrom:\n                 fieldRef:\n---\ncmd/k8s-operator/deploy/chart/values.yaml\n@@ -36,6 +36,10 @@ operatorConfig:\n   # Multiple tags are defined as array items and passed to the operator as a comma-separated string\n   defaultTags:\n     - \"tag:k8s-operator\"\n+  \n+  # When true, the operator will use an ephemeral auth key\n+  # https://tailscale.com/kb/1111/ephemeral-nodes/\n+  ephemeral: false\n \n   image:\n     # Repository defaults to DockerHub, but images are also synced to ghcr.io/tailscale/k8s-operator.\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -2215,6 +2215,14 @@ spec:\n                         https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n                         Defaults to false.\n                       type: boolean\n+                    ephemeral:\n+                      description: |-\n+                        Ephemeral can be set to true to make the proxy instance register\n+                        as an ephemeral node. Ephemeral nodes are automatically deleted\n+                        from the tailnet when they are offline for a while.\n+                        https://tailscale.com/kb/1111/ephemeral-nodes/\n+                        Defaults to false.\n+                      type: boolean\n                 useLetsEncryptStagingEnvironment:\n                   description: |-\n                     Set UseLetsEncryptStagingEnvironment to true to issue TLS\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -2684,6 +2684,14 @@ spec:\n                                             https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n                                             Defaults to false.\n                                         type: boolean\n+                                    ephemeral:\n+                                        description: |-\n+                                            Ephemeral can be set to true to make the proxy instance register\n+                                            as an ephemeral node. Ephemeral nodes are automatically deleted\n+                                            from the tailnet when they are offline for a while.\n+                                            https://tailscale.com/kb/1111/ephemeral-nodes/\n+                                            Defaults to false.\n+                                        type: boolean\n                                 type: object\n                             useLetsEncryptStagingEnvironment:\n                                 description: |-\n@@ -5009,6 +5017,8 @@ spec:\n                       value: operator\n                     - name: OPERATOR_LOGGING\n                       value: info\n+                    - name: OPERATOR_EPHEMERAL\n+                      value: \"false\"\n                     - name: OPERATOR_NAMESPACE\n                       valueFrom:\n                         fieldRef:\n---\ncmd/k8s-operator/operator.go\n@@ -139,6 +139,7 @@ func initTSNet(zlog *zap.SugaredLogger) (*tsnet.Server, tsClient) {\n \t\thostname         = defaultEnv(\"OPERATOR_HOSTNAME\", \"tailscale-operator\")\n \t\tkubeSecret       = defaultEnv(\"OPERATOR_SECRET\", \"\")\n \t\toperatorTags     = defaultEnv(\"OPERATOR_INITIAL_TAGS\", \"tag:k8s-operator\")\n+\t\tephemeral        = defaultBool(\"OPERATOR_EPHEMERAL\", false)\n \t)\n \tstartlog := zlog.Named(\"startup\")\n \tif clientIDPath == \"\" || clientSecretPath == \"\" {\n@@ -196,6 +197,7 @@ waitOnline:\n \t\t\t\t\tCreate: tailscale.KeyDeviceCreateCapabilities{\n \t\t\t\t\t\tReusable:      false,\n \t\t\t\t\t\tPreauthorized: true,\n+\t\t\t\t\t\tEphemeral:     ephemeral,\n \t\t\t\t\t\tTags:          strings.Split(operatorTags, \",\"),\n \t\t\t\t\t},\n \t\t\t\t},\n---\ncmd/k8s-operator/proxygroup.go\n@@ -477,7 +477,11 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t\tif len(tags) == 0 {\n \t\t\t\ttags = r.defaultTags\n \t\t\t}\n-\t\t\tauthKey, err = newAuthKey(ctx, r.tsClient, tags)\n+\t\t\tephemeral := false\n+\t\t\tif proxyClass != nil && proxyClass.Spec.TailscaleConfig != nil {\n+\t\t\t\tephemeral = proxyClass.Spec.TailscaleConfig.Ephemeral\n+\t\t\t}\n+\t\t\tauthKey, err = newAuthKey(ctx, r.tsClient, tags, ephemeral)\n \t\t\tif err != nil {\n \t\t\t\treturn \"\", err\n \t\t\t}\n---\ncmd/k8s-operator/sts.go\n@@ -376,7 +376,7 @@ func (a *tailscaleSTSReconciler) createOrGetSecret(ctx context.Context, logger *\n \t\tif len(tags) == 0 {\n \t\t\ttags = a.defaultTags\n \t\t}\n-\t\tauthKey, err = newAuthKey(ctx, a.tsClient, tags)\n+\t\tauthKey, err = newAuthKey(ctx, a.tsClient, tags, shouldUseEphemeral(stsC.ProxyClass))\n \t\tif err != nil {\n \t\t\treturn \"\", \"\", nil, err\n \t\t}\n@@ -511,12 +511,13 @@ func deviceInfo(sec *corev1.Secret, podUID string, log *zap.SugaredLogger) (dev\n \treturn dev, nil\n }\n \n-func newAuthKey(ctx context.Context, tsClient tsClient, tags []string) (string, error) {\n+func newAuthKey(ctx context.Context, tsClient tsClient, tags []string, ephemeral bool) (string, error) {\n \tcaps := tailscale.KeyCapabilities{\n \t\tDevices: tailscale.KeyDeviceCapabilities{\n \t\t\tCreate: tailscale.KeyDeviceCreateCapabilities{\n \t\t\t\tReusable:      false,\n \t\t\t\tPreauthorized: true,\n+\t\t\t\tEphemeral:     ephemeral,\n \t\t\t\tTags:          tags,\n \t\t\t},\n \t\t},\n@@ -1022,6 +1023,10 @@ func shouldAcceptRoutes(pc *tsapi.ProxyClass) bool {\n \treturn pc != nil && pc.Spec.TailscaleConfig != nil && pc.Spec.TailscaleConfig.AcceptRoutes\n }\n \n+func shouldUseEphemeral(pc *tsapi.ProxyClass) bool {\n+\treturn pc != nil && pc.Spec.TailscaleConfig != nil && pc.Spec.TailscaleConfig.Ephemeral\n+}\n+\n // ptrObject is a type constraint for pointer types that implement\n // client.Object.\n type ptrObject[T any] interface {\n---\ncmd/k8s-operator/tsrecorder.go\n@@ -289,7 +289,7 @@ func (r *RecorderReconciler) ensureAuthSecretCreated(ctx context.Context, tsr *t\n \tif len(tags) == 0 {\n \t\ttags = tsapi.Tags{\"tag:k8s\"}\n \t}\n-\tauthKey, err := newAuthKey(ctx, r.tsClient, tags.Stringify())\n+\tauthKey, err := newAuthKey(ctx, r.tsClient, tags.Stringify(), false)\n \tif err != nil {\n \t\treturn err\n \t}\n---\nk8s-operator/api.md\n@@ -1013,5 +1013,6 @@ _Appears in:_\n | Field | Description | Default | Validation |\n | --- | --- | --- | --- |\n | `acceptRoutes` _boolean_ | AcceptRoutes can be set to true to make the proxy instance accept<br />routes advertized by other nodes on the tailnet, such as subnet<br />routes.<br />This is equivalent of passing --accept-routes flag to a tailscale Linux client.<br />https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices<br />Defaults to false. |  |  |\n+| `ephemeral` _boolean_ | Ephemeral can be set to true to make the proxy instance register<br />as an ephemeral node. Ephemeral nodes are automatically deleted<br />from the tailnet when they are offline for a while.<br />https://tailscale.com/kb/1111/ephemeral-nodes/<br />Defaults to false. |  |  |\n \n \n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -91,6 +91,13 @@ type TailscaleConfig struct {\n \t// https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n \t// Defaults to false.\n \tAcceptRoutes bool `json:\"acceptRoutes,omitempty\"`\n+\n+\t// Ephemeral can be set to true to make the proxy instance register\n+\t// as an ephemeral node. Ephemeral nodes are automatically deleted\n+\t// from the tailnet when they are offline for a while.\n+\t// https://tailscale.com/kb/1111/ephemeral-nodes/\n+\t// Defaults to false.\n+\tEphemeral bool `json:\"ephemeral,omitempty\"`\n }\n \n type StatefulSet struct {\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/peerapi.go\n@@ -417,7 +417,7 @@ func (h *peerAPIHandler) handleServeIngress(w http.ResponseWriter, r *http.Reque\n \t}\n \tlogAndError := func(code int, publicMsg string) {\n \t\th.logf(\"ingress: bad request from %v: %s\", h.remoteAddr, publicMsg)\n-\t\thttp.Error(w, publicMsg, http.StatusMethodNotAllowed)\n+\t\thttp.Error(w, publicMsg, code)\n \t}\n \tbad := func(publicMsg string) {\n \t\tlogAndError(http.StatusBadRequest, publicMsg)\n---\n\n\n---\n\nChoice D:\nwgengine/magicsock/endpoint.go\n@@ -1111,7 +1111,7 @@ func (de *endpoint) sendDiscoPing(ep netip.AddrPort, discoKey key.DiscoPublic, t\n \tsize = min(size, MaxDiscoPingSize)\n \tpadding := max(size-discoPingSize, 0)\n \n-\tsent, _ := de.c.sendDiscoMessage(ep, de.publicKey, discoKey, &disco.Ping{\n+\tsent, _ := de.c.sendDiscoMessage(ep, nil, de.publicKey, discoKey, &disco.Ping{\n \t\tTxID:    [12]byte(txid),\n \t\tNodeKey: de.c.publicKeyAtomic.Load(),\n \t\tPadding: padding,\n---\nwgengine/magicsock/magicsock.go\n@@ -1602,23 +1602,60 @@ var debugIPv4DiscoPingPenalty = envknob.RegisterDuration(\"TS_DISCO_PONG_IPV4_DEL\n //\n // If dst is a DERP IP:port, then dstKey must be non-zero.\n //\n+// If geneveVNI is non-nil, then the [disco.Message] will be preceded by a\n+// Geneve header with the supplied VNI set.\n+//\n // The dstKey should only be non-zero if the dstDisco key\n // unambiguously maps to exactly one peer.\n-func (c *Conn) sendDiscoMessage(dst netip.AddrPort, dstKey key.NodePublic, dstDisco key.DiscoPublic, m disco.Message, logLevel discoLogLevel) (sent bool, err error) {\n+func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey key.NodePublic, dstDisco key.DiscoPublic, m disco.Message, logLevel discoLogLevel) (sent bool, err error) {\n \tisDERP := dst.Addr() == tailcfg.DerpMagicIPAddr\n \tif _, isPong := m.(*disco.Pong); isPong && !isDERP && dst.Addr().Is4() {\n \t\ttime.Sleep(debugIPv4DiscoPingPenalty())\n \t}\n \n+\tisRelayHandshakeMsg := false\n+\tswitch m.(type) {\n+\tcase *disco.BindUDPRelayEndpoint, *disco.BindUDPRelayEndpointAnswer:\n+\t\tisRelayHandshakeMsg = true\n+\t}\n+\n \tc.mu.Lock()\n \tif c.closed {\n \t\tc.mu.Unlock()\n \t\treturn false, errConnClosed\n \t}\n \tpkt := make([]byte, 0, 512) // TODO: size it correctly? pool? if it matters.\n+\tif geneveVNI != nil {\n+\t\tgh := packet.GeneveHeader{\n+\t\t\tVersion:  0,\n+\t\t\tProtocol: packet.GeneveProtocolDisco,\n+\t\t\tVNI:      *geneveVNI,\n+\t\t\tControl:  isRelayHandshakeMsg,\n+\t\t}\n+\t\tpkt = append(pkt, make([]byte, packet.GeneveFixedHeaderLength)...)\n+\t\terr := gh.Encode(pkt)\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t}\n \tpkt = append(pkt, disco.Magic...)\n \tpkt = c.discoPublic.AppendTo(pkt)\n-\tdi := c.discoInfoLocked(dstDisco)\n+\tvar di *discoInfo\n+\tif !isRelayHandshakeMsg {\n+\t\tdi = c.discoInfoLocked(dstDisco)\n+\t} else {\n+\t\t// c.discoInfoLocked() caches [*discoInfo] for dstDisco. It assumes that\n+\t\t// dstDisco is a known Tailscale peer, and will be cleaned around\n+\t\t// network map changes. In the case of a relay handshake message,\n+\t\t// dstDisco belongs to a relay server with a disco key that is\n+\t\t// discovered at endpoint allocation time or [disco.CallMeMaybeVia]\n+\t\t// reception time. There is no clear ending to its lifetime, so we\n+\t\t// can't cache with the same strategy. Instead, generate the shared\n+\t\t// key on the fly for now.\n+\t\tdi = &discoInfo{\n+\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n+\t\t}\n+\t}\n \tc.mu.Unlock()\n \n \tif isDERP {\n@@ -1943,7 +1980,7 @@ func (c *Conn) handlePingLocked(dm *disco.Ping, src netip.AddrPort, di *discoInf\n \n \tipDst := src\n \tdiscoDest := di.discoKey\n-\tgo c.sendDiscoMessage(ipDst, dstKey, discoDest, &disco.Pong{\n+\tgo c.sendDiscoMessage(ipDst, nil, dstKey, discoDest, &disco.Pong{\n \t\tTxID: dm.TxID,\n \t\tSrc:  src,\n \t}, discoVerboseLog)\n@@ -1988,12 +2025,12 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \tfor _, ep := range c.lastEndpoints {\n \t\teps = append(eps, ep.Addr)\n \t}\n-\tgo de.c.sendDiscoMessage(derpAddr, de.publicKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n+\tgo de.c.sendDiscoMessage(derpAddr, nil, de.publicKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n \tif debugSendCallMeUnknownPeer() {\n \t\t// Send a callMeMaybe packet to a non-existent peer\n \t\tunknownKey := key.NewNode().Public()\n \t\tc.logf(\"magicsock: sending CallMeMaybe to unknown peer per TS_DEBUG_SEND_CALLME_UNKNOWN_PEER\")\n-\t\tgo de.c.sendDiscoMessage(derpAddr, unknownKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n+\t\tgo de.c.sendDiscoMessage(derpAddr, nil, unknownKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n \t}\n }\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nSpotted after Brad showed me this utility in #15806.\r\n\r\nUpdates #cleanup\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -1463,15 +1463,30 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n+// AppendMatchingPeers returns base with all peers that match pred appended.\n+//\n+// It acquires b.mu to read the netmap but releases it before calling pred.\n func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+\tvar peers []tailcfg.NodeView\n+\n \tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n-\tret := base\n-\tif b.netMap == nil {\n-\t\treturn ret\n+\tif b.netMap != nil {\n+\t\t// All fields on b.netMap are immutable, so this is\n+\t\t// safe to copy and use outside the lock.\n+\t\tpeers = b.netMap.Peers\n \t}\n-\tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\tb.mu.Unlock()\n+\n+\tret := base\n+\tfor _, peer := range peers {\n+\t\t// The peers in b.netMap don't contain updates made via\n+\t\t// UpdateNetmapDelta. So only use PeerView in b.netMap for its NodeID,\n+\t\t// and then look up the latest copy in b.peers which is updated in\n+\t\t// response to UpdateNetmapDelta edits.\n+\t\tb.mu.Lock()\n+\t\tpeer, ok := b.peers[peer.ID()]\n+\t\tb.mu.Unlock()\n+\t\tif ok && pred(peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice B:\ntypes/logger/logger.go\n@@ -323,6 +323,7 @@ func (fn ArgWriter) Format(f fmt.State, _ rune) {\n \tbw.Reset(f)\n \tfn(bw)\n \tbw.Flush()\n+\tbw.Reset(io.Discard)\n \targBufioPool.Put(bw)\n }\n \n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/peerapi.go\n@@ -1135,7 +1135,7 @@ func (h *peerAPIHandler) handleServeDrive(w http.ResponseWriter, r *http.Request\n \n \tp, err := drive.ParsePermissions(rawPerms)\n \tif err != nil {\n-\t\th.logf(\"taildrive: error parsing permissions: %w\", err.Error())\n+\t\th.logf(\"taildrive: error parsing permissions: %v\", err)\n \t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n \t\treturn\n \t}\n---\n\n\n---\n\nChoice D:\n.github/workflows/golangci-lint.yml\n@@ -31,7 +31,7 @@ jobs:\n           cache: false\n \n       - name: golangci-lint\n-        uses: golangci/golangci-lint-action@2226d7cb06a077cd73e56eedd38eecad18e5d837 # v6.5.0\n+        uses: golangci/golangci-lint-action@55c2c1448f86e01eaae002a5a3a9624417608d84 # v6.5.2\n         with:\n           version: v1.64\n \n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/corp#15664\n\n\n---\n\nChoice A:\nclient/systray/logo.go\n@@ -11,10 +11,12 @@ import (\n \t\"image\"\n \t\"image/color\"\n \t\"image/png\"\n+\t\"runtime\"\n \t\"sync\"\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/fogleman/gg\"\n )\n \n@@ -251,7 +253,13 @@ func (logo tsLogo) renderWithBorder(borderUnits int) *bytes.Buffer {\n \t}\n \n \tb := bytes.NewBuffer(nil)\n-\tpng.Encode(b, dc.Image())\n+\n+\t// Encode as ICO format on Windows, PNG on all other platforms.\n+\tif runtime.GOOS == \"windows\" {\n+\t\t_ = ico.Encode(b, dc.Image())\n+\t} else {\n+\t\t_ = png.Encode(b, dc.Image())\n+\t}\n \treturn b\n }\n \n---\nclient/systray/systray.go\n@@ -7,9 +7,11 @@\n package systray\n \n import (\n+\t\"bytes\"\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"image\"\n \t\"io\"\n \t\"log\"\n \t\"net/http\"\n@@ -23,6 +25,7 @@ import (\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/atotto/clipboard\"\n \tdbus \"github.com/godbus/dbus/v5\"\n \t\"github.com/toqueteos/webbrowser\"\n@@ -330,6 +333,20 @@ func setRemoteIcon(menu *systray.MenuItem, urlStr string) {\n \t\tresp, err := http.Get(urlStr)\n \t\tif err == nil && resp.StatusCode == http.StatusOK {\n \t\t\tb, _ = io.ReadAll(resp.Body)\n+\n+\t\t\t// Convert image to ICO format on Windows\n+\t\t\tif runtime.GOOS == \"windows\" {\n+\t\t\t\tim, _, err := image.Decode(bytes.NewReader(b))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tbuf := bytes.NewBuffer(nil)\n+\t\t\t\tif err := ico.Encode(buf, im); err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tb = buf.Bytes()\n+\t\t\t}\n+\n \t\t\thttpCache[urlStr] = b\n \t\t\tresp.Body.Close()\n \t\t}\n---\ngo.mod\n@@ -4,7 +4,8 @@ go 1.24.0\n \n require (\n \tfilippo.io/mkcert v1.4.4\n-\tfyne.io/systray v1.11.0\n+\tfyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a\n+\tgithub.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9\n \tgithub.com/akutz/memconn v0.1.0\n \tgithub.com/alexbrainman/sspi v0.0.0-20231016080023-1a75b4708caa\n \tgithub.com/andybalholm/brotli v1.1.0\n@@ -100,7 +101,7 @@ require (\n \tgolang.org/x/net v0.36.0\n \tgolang.org/x/oauth2 v0.26.0\n \tgolang.org/x/sync v0.11.0\n-\tgolang.org/x/sys v0.30.0\n+\tgolang.org/x/sys v0.31.0\n \tgolang.org/x/term v0.29.0\n \tgolang.org/x/time v0.10.0\n \tgolang.org/x/tools v0.30.0\n---\ngo.sum\n@@ -41,8 +41,8 @@ filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\n filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\n filippo.io/mkcert v1.4.4 h1:8eVbbwfVlaqUM7OwuftKc2nuYOoTDQWqsoXmzoXZdbc=\n filippo.io/mkcert v1.4.4/go.mod h1:VyvOchVuAye3BoUsPUOOofKygVwLV2KQMVFJNRq+1dA=\n-fyne.io/systray v1.11.0 h1:D9HISlxSkx+jHSniMBR6fCFOUjk1x/OOOJLa9lJYAKg=\n-fyne.io/systray v1.11.0/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a h1:I8mEKo5sawHu8CqYf3FSjIl9b3puXasFVn2D/hrCneY=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n github.com/4meepo/tagalign v1.3.3 h1:ZsOxcwGD/jP4U/aw7qeWu58i7dwYemfy5Y+IF1ACoNw=\n github.com/4meepo/tagalign v1.3.3/go.mod h1:Q9c1rYMZJc9dPRkbQPpcBNCLEmY2njbAsXhQOZFE2dE=\n github.com/Abirdcfly/dupword v0.0.14 h1:3U4ulkc8EUo+CaT105/GJ1BQwtgyj6+VaBVbAX11Ba8=\n@@ -67,6 +67,8 @@ github.com/Djarvur/go-err113 v0.1.0 h1:uCRZZOdMQ0TZPHYTdYpoC0bLYJKPEHPUJ8MeAa51l\n github.com/Djarvur/go-err113 v0.1.0/go.mod h1:4UJr5HIiMZrwgkSPdsjy2uOQExX/WEILpIrO9UPGuXs=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0 h1:sATXp1x6/axKxz2Gjxv8MALP0bXaNRfQinEwyfMcx8c=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0/go.mod h1:Nl76DrGNJTA1KJ0LePKBw/vznBX1EHbAZX8mwjR82nI=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9 h1:1ltqoej5GtaWF8jaiA49HwsZD459jqm9YFz9ZtMFpQA=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9/go.mod h1:7uhhqiBaR4CpN0k9rMjOtjpcfGd6DG2m04zQxKnWQ0I=\n github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\n github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\n github.com/Masterminds/semver v1.5.0 h1:H65muMkzWKEuNDnfl9d70GUjFniHKHRbFPGBuZ3QEww=\n@@ -1218,8 +1220,8 @@ golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n-golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=\n-golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=\n+golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n---\n\n\n---\n\nChoice B:\ncmd/proxy-to-grafana/proxy-to-grafana.go\n@@ -53,7 +53,7 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"tailscale.com/client/local\"\n+\t\"tailscale.com/client/tailscale/apitype\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/tsnet\"\n )\n@@ -195,13 +195,7 @@ func main() {\n \tlog.Fatal(http.Serve(ln, proxy))\n }\n \n-func modifyRequest(req *http.Request, localClient *local.Client) {\n-\t// with enable_login_token set to true, we get a cookie that handles\n-\t// auth for paths that are not /login\n-\tif req.URL.Path != \"/login\" {\n-\t\treturn\n-\t}\n-\n+func modifyRequest(req *http.Request, localClient whoisIdentitySource) {\n \t// Delete any existing X-Webauth-* headers to prevent possible spoofing\n \t// if getting Tailnet identity fails.\n \tfor h := range req.Header {\n@@ -210,6 +204,13 @@ func modifyRequest(req *http.Request, localClient *local.Client) {\n \t\t}\n \t}\n \n+\t// Set the X-Webauth-* headers only for the /login path\n+\t// With enable_login_token set to true, we get a cookie that handles\n+\t// auth for paths that are not /login\n+\tif req.URL.Path != \"/login\" {\n+\t\treturn\n+\t}\n+\n \tuser, role, err := getTailscaleIdentity(req.Context(), localClient, req.RemoteAddr)\n \tif err != nil {\n \t\tlog.Printf(\"error getting Tailscale user: %v\", err)\n@@ -221,7 +222,7 @@ func modifyRequest(req *http.Request, localClient *local.Client) {\n \treq.Header.Set(\"X-Webauth-Role\", role.String())\n }\n \n-func getTailscaleIdentity(ctx context.Context, localClient *local.Client, ipPort string) (*tailcfg.UserProfile, grafanaRole, error) {\n+func getTailscaleIdentity(ctx context.Context, localClient whoisIdentitySource, ipPort string) (*tailcfg.UserProfile, grafanaRole, error) {\n \twhois, err := localClient.WhoIs(ctx, ipPort)\n \tif err != nil {\n \t\treturn nil, ViewerRole, fmt.Errorf(\"failed to identify remote host: %w\", err)\n@@ -248,3 +249,7 @@ func getTailscaleIdentity(ctx context.Context, localClient *local.Client, ipPort\n \n \treturn whois.UserProfile, role, nil\n }\n+\n+type whoisIdentitySource interface {\n+\tWhoIs(ctx context.Context, ipPort string) (*apitype.WhoIsResponse, error)\n+}\n---\ncmd/proxy-to-grafana/proxy-to-grafana_test.go\n@@ -0,0 +1,77 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+package main\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+\n+\t\"tailscale.com/client/tailscale/apitype\"\n+\t\"tailscale.com/tailcfg\"\n+)\n+\n+type mockWhoisSource struct {\n+\tid *apitype.WhoIsResponse\n+}\n+\n+func (m *mockWhoisSource) WhoIs(ctx context.Context, remoteAddr string) (*apitype.WhoIsResponse, error) {\n+\tif m.id == nil {\n+\t\treturn nil, fmt.Errorf(\"missing mock identity\")\n+\t}\n+\treturn m.id, nil\n+}\n+\n+var whois = &apitype.WhoIsResponse{\n+\tUserProfile: &tailcfg.UserProfile{\n+\t\tLoginName:   \"foobar@example.com\",\n+\t\tDisplayName: \"Foobar\",\n+\t},\n+\tNode: &tailcfg.Node{\n+\t\tID: 1,\n+\t},\n+}\n+\n+func TestModifyRequest_Login(t *testing.T) {\n+\treq := httptest.NewRequest(\"GET\", \"/login\", nil)\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"foobar@example.com\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"foobar@example.com\")\n+\t}\n+\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"Viewer\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"Viewer\")\n+\t}\n+}\n+\n+func TestModifyRequest_RemoveHeaders_Login(t *testing.T) {\n+\treq := httptest.NewRequest(\"GET\", \"/login\", nil)\n+\treq.Header.Set(\"X-Webauth-User\", \"malicious@example.com\")\n+\treq.Header.Set(\"X-Webauth-Role\", \"Admin\")\n+\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"foobar@example.com\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"foobar@example.com\")\n+\t}\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"Viewer\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"Viewer\")\n+\t}\n+}\n+\n+func TestModifyRequest_RemoveHeaders_API(t *testing.T) {\n+\treq := httptest.NewRequest(\"DELETE\", \"/api/org/users/1\", nil)\n+\treq.Header.Set(\"X-Webauth-User\", \"malicious@example.com\")\n+\treq.Header.Set(\"X-Webauth-Role\", \"Admin\")\n+\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"\")\n+\t}\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"\")\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\nlogtail/logtail.go\n@@ -15,9 +15,7 @@ import (\n \t\"log\"\n \tmrand \"math/rand/v2\"\n \t\"net/http\"\n-\t\"net/netip\"\n \t\"os\"\n-\t\"regexp\"\n \t\"runtime\"\n \t\"slices\"\n \t\"strconv\"\n@@ -29,7 +27,6 @@ import (\n \t\"tailscale.com/envknob\"\n \t\"tailscale.com/net/netmon\"\n \t\"tailscale.com/net/sockstats\"\n-\t\"tailscale.com/net/tsaddr\"\n \t\"tailscale.com/tstime\"\n \ttslogger \"tailscale.com/types/logger\"\n \t\"tailscale.com/types/logid\"\n@@ -833,8 +830,6 @@ func (l *Logger) Logf(format string, args ...any) {\n \tfmt.Fprintf(l, format, args...)\n }\n \n-var obscureIPs = envknob.RegisterBool(\"TS_OBSCURE_LOGGED_IPS\")\n-\n // Write logs an encoded JSON blob.\n //\n // If the []byte passed to Write is not an encoded JSON blob,\n@@ -859,10 +854,6 @@ func (l *Logger) Write(buf []byte) (int, error) {\n \t\t}\n \t}\n \n-\tif obscureIPs() {\n-\t\tbuf = redactIPs(buf)\n-\t}\n-\n \tl.writeLock.Lock()\n \tdefer l.writeLock.Unlock()\n \n@@ -871,40 +862,6 @@ func (l *Logger) Write(buf []byte) (int, error) {\n \treturn inLen, err\n }\n \n-var (\n-\tregexMatchesIPv6 = regexp.MustCompile(`([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4}):([0-9a-fA-F:]{1,4})*`)\n-\tregexMatchesIPv4 = regexp.MustCompile(`(\\d{1,3})\\.(\\d{1,3})\\.\\d{1,3}\\.\\d{1,3}`)\n-)\n-\n-// redactIPs is a helper function used in Write() to redact IPs (other than tailscale IPs).\n-// This function takes a log line as a byte slice and\n-// uses regex matching to parse and find IP addresses. Based on if the IP address is IPv4 or\n-// IPv6, it parses and replaces the end of the addresses with an \"x\". This function returns the\n-// log line with the IPs redacted.\n-func redactIPs(buf []byte) []byte {\n-\tout := regexMatchesIPv6.ReplaceAllFunc(buf, func(b []byte) []byte {\n-\t\tip, err := netip.ParseAddr(string(b))\n-\t\tif err != nil || tsaddr.IsTailscaleIP(ip) {\n-\t\t\treturn b // don't change this one\n-\t\t}\n-\n-\t\tprefix := bytes.Split(b, []byte(\":\"))\n-\t\treturn bytes.Join(append(prefix[:2], []byte(\"x\")), []byte(\":\"))\n-\t})\n-\n-\tout = regexMatchesIPv4.ReplaceAllFunc(out, func(b []byte) []byte {\n-\t\tip, err := netip.ParseAddr(string(b))\n-\t\tif err != nil || tsaddr.IsTailscaleIP(ip) {\n-\t\t\treturn b // don't change this one\n-\t\t}\n-\n-\t\tprefix := bytes.Split(b, []byte(\".\"))\n-\t\treturn bytes.Join(append(prefix[:2], []byte(\"x.x\")), []byte(\".\"))\n-\t})\n-\n-\treturn []byte(out)\n-}\n-\n var (\n \topenBracketV = []byte(\"[v\")\n \tv1           = []byte(\"[v1] \")\n---\nlogtail/logtail_test.go\n@@ -15,7 +15,6 @@ import (\n \t\"time\"\n \n \t\"github.com/go-json-experiment/json/jsontext\"\n-\t\"tailscale.com/envknob\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/tstime\"\n \t\"tailscale.com/util/must\"\n@@ -316,85 +315,6 @@ func TestLoggerWriteResult(t *testing.T) {\n \t\tt.Errorf(\"mismatch.\\n got: %#q\\nwant: %#q\", back, want)\n \t}\n }\n-func TestRedact(t *testing.T) {\n-\tenvknob.Setenv(\"TS_OBSCURE_LOGGED_IPS\", \"true\")\n-\ttests := []struct {\n-\t\tin   string\n-\t\twant string\n-\t}{\n-\t\t// tests for ipv4 addresses\n-\t\t{\n-\t\t\t\"120.100.30.47\",\n-\t\t\t\"120.100.x.x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"192.167.0.1/65\",\n-\t\t\t\"192.167.x.x/65\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.0.222:41641 mtu=1360 tx=d81a8a35a0ce\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.x.x:41641 mtu=1360 tx=d81a8a35a0ce\",\n-\t\t},\n-\t\t//tests for ipv6 addresses\n-\t\t{\n-\t\t\t\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"2001:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2345:0425:2CA1:0000:0000:0567:5673:23b5\",\n-\t\t\t\"2345:0425:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2601:645:8200:edf0::c9de/64\",\n-\t\t\t\"2601:645:x/64\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 2051:0000:140F::875B:131C mtu=1360 tx=d81a8a35a0ce\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 2051:0000:x mtu=1360 tx=d81a8a35a0ce\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2601:645:8200:edf0::c9de/64 2601:645:8200:edf0:1ce9:b17d:71f5:f6a3/64\",\n-\t\t\t\"2601:645:x/64 2601:645:x/64\",\n-\t\t},\n-\t\t//tests for tailscale ip addresses\n-\t\t{\n-\t\t\t\"100.64.5.6\",\n-\t\t\t\"100.64.5.6\",\n-\t\t},\n-\t\t{\n-\t\t\t\"fd7a:115c:a1e0::/96\",\n-\t\t\t\"fd7a:115c:a1e0::/96\",\n-\t\t},\n-\t\t//tests for ipv6 and ipv4 together\n-\t\t{\n-\t\t\t\"192.167.0.1 2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"192.167.x.x 2001:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.0.222:41641 mtu=1360 tx=d81a8a35a0ce 2345:0425:2CA1::0567:5673:23b5\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.x.x:41641 mtu=1360 tx=d81a8a35a0ce 2345:0425:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"100.64.5.6 2091:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"100.64.5.6 2091:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"192.167.0.1 120.100.30.47 2041:0000:140F::875B:131B\",\n-\t\t\t\"192.167.x.x 120.100.x.x 2041:0000:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"fd7a:115c:a1e0::/96 192.167.0.1 2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"fd7a:115c:a1e0::/96 192.167.x.x 2001:0db8:x\",\n-\t\t},\n-\t}\n-\n-\tfor _, tt := range tests {\n-\t\tgotBuf := redactIPs([]byte(tt.in))\n-\t\tif string(gotBuf) != tt.want {\n-\t\t\tt.Errorf(\"for %q,\\n got: %#q\\nwant: %#q\\n\", tt.in, gotBuf, tt.want)\n-\t\t}\n-\t}\n-}\n \n func TestAppendMetadata(t *testing.T) {\n \tvar l Logger\n---\n\n\n---\n\nChoice D:\ngo.toolchain.rev\n@@ -1 +1 @@\n-4fdaeeb8fe43bcdb4e8cc736433b9cd9c0ddd221\n+982da8f24fa0504f2214f24b0d68b2febd5983f8\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [github/codeql-action](https://github.com/github/codeql-action) from 3.28.15 to 3.28.16.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/releases\">github/codeql-action's releases</a>.</em></p>\n<blockquote>\n<h2>v3.28.16</h2>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>3.28.16 - 23 Apr 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.1. <a href=\"https://redirect.github.com/github/codeql-action/pull/2863\">#2863</a></li>\n</ul>\n<p>See the full <a href=\"https://github.com/github/codeql-action/blob/v3.28.16/CHANGELOG.md\">CHANGELOG.md</a> for more information.</p>\n</blockquote>\n</details>\n<details>\n<summary>Changelog</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/blob/main/CHANGELOG.md\">github/codeql-action's changelog</a>.</em></p>\n<blockquote>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>[UNRELEASED]</h2>\n<p>No user facing changes.</p>\n<h2>3.28.16 - 23 Apr 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.1. <a href=\"https://redirect.github.com/github/codeql-action/pull/2863\">#2863</a></li>\n</ul>\n<h2>3.28.15 - 07 Apr 2025</h2>\n<ul>\n<li>Fix bug where the action would fail if it tried to produce a debug artifact with more than 65535 files. <a href=\"https://redirect.github.com/github/codeql-action/pull/2842\">#2842</a></li>\n</ul>\n<h2>3.28.14 - 07 Apr 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.0. <a href=\"https://redirect.github.com/github/codeql-action/pull/2838\">#2838</a></li>\n</ul>\n<h2>3.28.13 - 24 Mar 2025</h2>\n<p>No user facing changes.</p>\n<h2>3.28.12 - 19 Mar 2025</h2>\n<ul>\n<li>Dependency caching should now cache more dependencies for Java <code>build-mode: none</code> extractions. This should speed up workflows and avoid inconsistent alerts in some cases.</li>\n<li>Update default CodeQL bundle version to 2.20.7. <a href=\"https://redirect.github.com/github/codeql-action/pull/2810\">#2810</a></li>\n</ul>\n<h2>3.28.11 - 07 Mar 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.6. <a href=\"https://redirect.github.com/github/codeql-action/pull/2793\">#2793</a></li>\n</ul>\n<h2>3.28.10 - 21 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.5. <a href=\"https://redirect.github.com/github/codeql-action/pull/2772\">#2772</a></li>\n<li>Address an issue where the CodeQL Bundle would occasionally fail to decompress on macOS. <a href=\"https://redirect.github.com/github/codeql-action/pull/2768\">#2768</a></li>\n</ul>\n<h2>3.28.9 - 07 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.4. <a href=\"https://redirect.github.com/github/codeql-action/pull/2753\">#2753</a></li>\n</ul>\n<h2>3.28.8 - 29 Jan 2025</h2>\n<ul>\n<li>Enable support for Kotlin 2.1.10 when running with CodeQL CLI v2.20.3. <a href=\"https://redirect.github.com/github/codeql-action/pull/2744\">#2744</a></li>\n</ul>\n<h2>3.28.7 - 29 Jan 2025</h2>\n<p>No user facing changes.</p>\n<!-- raw HTML omitted -->\n</blockquote>\n<p>... (truncated)</p>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/github/codeql-action/commit/28deaeda66b76a05916b6923827895f2b14ab387\"><code>28deaed</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2865\">#2865</a> from github/update-v3.28.16-2a8cbadc0</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/03c5d71c11f6cb2c5ba7eef371219a862be30193\"><code>03c5d71</code></a> Update changelog for v3.28.16</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/2a8cbadc02bb64a7fd15d37c977acbad02496c80\"><code>2a8cbad</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2863\">#2863</a> from github/update-bundle/codeql-bundle-v2.21.1</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/f76eaf51a636a5c1d927998267d92d6475363ace\"><code>f76eaf5</code></a> Add changelog note</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/e63b3f5166c15fda4eb17886f01abe9445dd13f5\"><code>e63b3f5</code></a> Update default bundle to codeql-bundle-v2.21.1</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/4c3e5362829f0b0bb62ff5f6c938d7f95574c306\"><code>4c3e536</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2853\">#2853</a> from github/dependabot/npm_and_yarn/npm-7d84c66b66</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/56dd02f26d99811d607284494ff84b7d862fe837\"><code>56dd02f</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2852\">#2852</a> from github/dependabot/github_actions/actions-457587...</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/192406dd845fb2228fcea74898b98df2a6cdcef6\"><code>192406d</code></a> Merge branch 'main' into dependabot/github_actions/actions-4575878e06</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/c7dbb2084ed1bb623fbbb3976cd6dbae6daaf1fe\"><code>c7dbb20</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2857\">#2857</a> from github/nickfyson/address-vulns</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/9a45cd8c5025281c30bbb652197ace083c291e49\"><code>9a45cd8</code></a> move use of input variables into env vars</li>\n<li>Additional commits viewable in <a href=\"https://github.com/github/codeql-action/compare/45775bd8235c68ba998cffa5171334d58593da47...28deaeda66b76a05916b6923827895f2b14ab387\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=github/codeql-action&package-manager=github_actions&previous-version=3.28.15&new-version=3.28.16)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/init@28deaeda66b76a05916b6923827895f2b14ab387 # v3.28.16\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/autobuild@28deaeda66b76a05916b6923827895f2b14ab387 # v3.28.16\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/analyze@28deaeda66b76a05916b6923827895f2b14ab387 # v3.28.16\n---\n\n\n---\n\nChoice B:\nfeature/capture/dissector/ts-dissector.lua\n@@ -1,5 +1,5 @@\n function hasbit(x, p)\n-  return x % (p + p) >= p       \n+  return bit.band(x, p) ~= 0\n end\n \n tsdebug_ll = Proto(\"tsdebug\", \"Tailscale debug\")\n@@ -128,6 +128,10 @@ function tsdisco_frame.dissector(buffer, pinfo, tree)\n     if     message_type == 1 then subtree:add(DISCO_TYPE, \"Ping\")\n     elseif message_type == 2 then subtree:add(DISCO_TYPE, \"Pong\")\n     elseif message_type == 3 then subtree:add(DISCO_TYPE, \"Call me maybe\")\n+    elseif message_type == 4 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint\")\n+    elseif message_type == 5 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint Challenge\")\n+    elseif message_type == 6 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint Answer\")\n+    elseif message_type == 7 then subtree:add(DISCO_TYPE, \"Call me maybe via\")\n     end\n \n     -- Message version\n---\n\n\n---\n\nChoice C:\ncontrol/controlhttp/client.go\n@@ -96,6 +96,9 @@ func (a *Dialer) httpsFallbackDelay() time.Duration {\n var _ = envknob.RegisterBool(\"TS_USE_CONTROL_DIAL_PLAN\") // to record at init time whether it's in use\n \n func (a *Dialer) dial(ctx context.Context) (*ClientConn, error) {\n+\n+\ta.logPort80Failure.Store(true)\n+\n \t// If we don't have a dial plan, just fall back to dialing the single\n \t// host we know about.\n \tuseDialPlan := envknob.BoolDefaultTrue(\"TS_USE_CONTROL_DIAL_PLAN\")\n@@ -278,7 +281,9 @@ func (d *Dialer) forceNoise443() bool {\n \t\t// This heuristic works around networks where port 80 is MITMed and\n \t\t// appears to work for a bit post-Upgrade but then gets closed,\n \t\t// such as seen in https://github.com/tailscale/tailscale/issues/13597.\n-\t\td.logf(\"controlhttp: forcing port 443 dial due to recent noise dial\")\n+\t\tif d.logPort80Failure.CompareAndSwap(true, false) {\n+\t\t\td.logf(\"controlhttp: forcing port 443 dial due to recent noise dial\")\n+\t\t}\n \t\treturn true\n \t}\n \n---\ncontrol/controlhttp/constants.go\n@@ -6,6 +6,7 @@ package controlhttp\n import (\n \t\"net/http\"\n \t\"net/url\"\n+\t\"sync/atomic\"\n \t\"time\"\n \n \t\"tailscale.com/health\"\n@@ -90,6 +91,11 @@ type Dialer struct {\n \n \tproxyFunc func(*http.Request) (*url.URL, error) // or nil\n \n+\t// logPort80Failure is whether we should log about port 80 interceptions\n+\t// and forcing a port 443 dial. We do this only once per \"dial\" method\n+\t// which can result in many concurrent racing dialHost calls.\n+\tlogPort80Failure atomic.Bool\n+\n \t// For tests only\n \tdrainFinished        chan struct{}\n \tomitCertErrorLogging bool\n---\n\n\n---\n\nChoice D:\ngo.toolchain.rev\n@@ -1 +1 @@\n-982da8f24fa0504f2214f24b0d68b2febd5983f8\n+98e8c99c256a5aeaa13725d2e43fdd7f465ba200\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes #15794\n\n\n---\n\nChoice A:\ncmd/natc/natc.go\n@@ -13,6 +13,7 @@ import (\n \t\"flag\"\n \t\"fmt\"\n \t\"log\"\n+\t\"math/rand/v2\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/netip\"\n@@ -438,7 +439,7 @@ func (c *connector) handleTCPFlow(src, dst netip.AddrPort) (handler func(net.Con\n \t\treturn nil, false\n \t}\n \treturn func(conn net.Conn) {\n-\t\tproxyTCPConn(conn, domain)\n+\t\tproxyTCPConn(conn, domain, c)\n \t}, true\n }\n \n@@ -456,16 +457,34 @@ func (c *connector) ignoreDestination(dstAddrs []netip.Addr) bool {\n \treturn false\n }\n \n-func proxyTCPConn(c net.Conn, dest string) {\n+func proxyTCPConn(c net.Conn, dest string, ctor *connector) {\n \tif c.RemoteAddr() == nil {\n \t\tlog.Printf(\"proxyTCPConn: nil RemoteAddr\")\n \t\tc.Close()\n \t\treturn\n \t}\n-\taddrPortStr := c.LocalAddr().String()\n-\t_, port, err := net.SplitHostPort(addrPortStr)\n+\tladdr, err := netip.ParseAddrPort(c.LocalAddr().String())\n \tif err != nil {\n-\t\tlog.Printf(\"tcpRoundRobinHandler.Handle: bogus addrPort %q\", addrPortStr)\n+\t\tlog.Printf(\"proxyTCPConn: ParseAddrPort failed: %v\", err)\n+\t\tc.Close()\n+\t\treturn\n+\t}\n+\n+\tdaddrs, err := ctor.resolver.LookupNetIP(context.TODO(), \"ip\", dest)\n+\tif err != nil {\n+\t\tlog.Printf(\"proxyTCPConn: LookupNetIP failed: %v\", err)\n+\t\tc.Close()\n+\t\treturn\n+\t}\n+\n+\tif len(daddrs) == 0 {\n+\t\tlog.Printf(\"proxyTCPConn: no IP addresses found for %s\", dest)\n+\t\tc.Close()\n+\t\treturn\n+\t}\n+\n+\tif ctor.ignoreDestination(daddrs) {\n+\t\tlog.Printf(\"proxyTCPConn: closing connection to ignored destination %s (%v)\", dest, daddrs)\n \t\tc.Close()\n \t\treturn\n \t}\n@@ -475,10 +494,37 @@ func proxyTCPConn(c net.Conn, dest string) {\n \t\t\treturn netutil.NewOneConnListener(c, nil), nil\n \t\t},\n \t}\n-\t// XXX(raggi): if the connection here resolves to an ignored destination,\n-\t// the connection should be closed/failed.\n-\tp.AddRoute(addrPortStr, &tcpproxy.DialProxy{\n-\t\tAddr: fmt.Sprintf(\"%s:%s\", dest, port),\n+\n+\t// TODO(raggi): more code could avoid this shuffle, but avoiding allocations\n+\t// for now most of the time daddrs will be short.\n+\trand.Shuffle(len(daddrs), func(i, j int) {\n+\t\tdaddrs[i], daddrs[j] = daddrs[j], daddrs[i]\n \t})\n+\tdaddr := daddrs[0]\n+\n+\t// Try to match the upstream and downstream protocols (v4/v6)\n+\tif laddr.Addr().Is6() {\n+\t\tfor _, addr := range daddrs {\n+\t\t\tif addr.Is6() {\n+\t\t\t\tdaddr = addr\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tfor _, addr := range daddrs {\n+\t\t\tif addr.Is4() {\n+\t\t\t\tdaddr = addr\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// TODO(raggi): drop this library, it ends up being allocation and\n+\t// indirection heavy and really doesn't help us here.\n+\tdsockaddrs := netip.AddrPortFrom(daddr, laddr.Port()).String()\n+\tp.AddRoute(dsockaddrs, &tcpproxy.DialProxy{\n+\t\tAddr: dsockaddrs,\n+\t})\n+\n \tp.Start()\n }\n---\n\n\n---\n\nChoice B:\nposture/serialnumber_stub.go\n@@ -1,13 +1,12 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-// android: not implemented\n // js: not implemented\n // plan9: not implemented\n // solaris: currently unsupported by go-smbios:\n // https://github.com/digitalocean/go-smbios/pull/21\n \n-//go:build android || solaris || plan9 || js || wasm || tamago || aix || (darwin && !cgo && !ios)\n+//go:build solaris || plan9 || js || wasm || tamago || aix || (darwin && !cgo && !ios)\n \n package posture\n \n---\nposture/serialnumber_syspolicy.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build android || ios\n+\n package posture\n \n import (\n@@ -10,9 +12,9 @@ import (\n \t\"tailscale.com/util/syspolicy\"\n )\n \n-// GetSerialNumbers returns the serial number of the iOS/tvOS device as reported by an\n+// GetSerialNumbers returns the serial number of the device as reported by an\n // MDM solution. It requires configuration via the DeviceSerialNumber system policy.\n-// This is the only way to gather serial numbers on iOS and tvOS.\n+// This is the only way to gather serial numbers on iOS, tvOS and Android.\n func GetSerialNumbers(_ logger.Logf) ([]string, error) {\n \ts, err := syspolicy.GetString(syspolicy.DeviceSerialNumber, \"\")\n \tif err != nil {\n---\nutil/syspolicy/policy_keys.go\n@@ -126,8 +126,8 @@ const (\n \t// The default is \"user-decides\" unless otherwise stated.\n \tPostureChecking Key = \"PostureChecking\"\n \t// DeviceSerialNumber is the serial number of the device that is running Tailscale.\n-\t// This is used on iOS/tvOS to allow IT administrators to manually give us a serial number via MDM.\n-\t// We are unable to programmatically get the serial number from IOKit due to sandboxing restrictions.\n+\t// This is used on Android, iOS and tvOS to allow IT administrators to manually give us a serial number via MDM.\n+\t// We are unable to programmatically get the serial number on mobile due to sandboxing restrictions.\n \tDeviceSerialNumber Key = \"DeviceSerialNumber\"\n \n \t// ManagedByOrganizationName indicates the name of the organization managing the Tailscale\n---\n\n\n---\n\nChoice C:\nnet/portmapper/igd_test.go\n@@ -18,8 +18,10 @@ import (\n \t\"tailscale.com/net/netaddr\"\n \t\"tailscale.com/net/netmon\"\n \t\"tailscale.com/syncs\"\n+\t\"tailscale.com/tstest\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/eventbus\"\n+\t\"tailscale.com/util/testenv\"\n )\n \n // TestIGD is an IGD (Internet Gateway Device) for testing. It supports fake\n@@ -64,7 +66,8 @@ type igdCounters struct {\n \tinvalidPCPMapPkt int32\n }\n \n-func NewTestIGD(logf logger.Logf, t TestIGDOptions) (*TestIGD, error) {\n+func NewTestIGD(tb testenv.TB, t TestIGDOptions) (*TestIGD, error) {\n+\tlogf := tstest.WhileTestRunningLogger(tb)\n \td := &TestIGD{\n \t\tdoPMP:  t.PMP,\n \t\tdoPCP:  t.PCP,\n@@ -265,7 +268,7 @@ func (d *TestIGD) handlePCPQuery(pkt []byte, src netip.AddrPort) {\n func newTestClient(t *testing.T, igd *TestIGD, bus *eventbus.Bus) *Client {\n \tvar c *Client\n \tc = NewClient(Config{\n-\t\tLogf:         t.Logf,\n+\t\tLogf:         tstest.WhileTestRunningLogger(t),\n \t\tNetMon:       netmon.NewStatic(),\n \t\tControlKnobs: new(controlknobs.Knobs),\n \t\tEventBus:     bus,\n---\nnet/portmapper/portmapper_test.go\n@@ -61,7 +61,7 @@ func TestClientProbeThenMap(t *testing.T) {\n }\n \n func TestProbeIntegration(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PMP: true, PCP: true, UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PMP: true, PCP: true, UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -95,7 +95,7 @@ func TestProbeIntegration(t *testing.T) {\n }\n \n func TestPCPIntegration(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PMP: false, PCP: true, UPnP: false})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PMP: false, PCP: true, UPnP: false})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -137,7 +137,7 @@ func TestGetUPnPErrorsMetric(t *testing.T) {\n }\n \n func TestUpdateEvent(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PCP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PCP: true})\n \tif err != nil {\n \t\tt.Fatalf(\"Create test gateway: %v\", err)\n \t}\n---\nnet/portmapper/select_test.go\n@@ -28,7 +28,7 @@ func TestSelectBestService(t *testing.T) {\n \t}\n \n \t// Run a fake IGD server to respond to UPnP requests.\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/portmapper/upnp_test.go\n@@ -533,7 +533,7 @@ func TestGetUPnPClient(t *testing.T) {\n }\n \n func TestGetUPnPPortMapping(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -672,7 +672,7 @@ func TestGetUPnPPortMapping_LeaseDuration(t *testing.T) {\n \t\t\t\t\"DeletePortMapping\":    \"\", // Do nothing for test\n \t\t\t}\n \n-\t\t\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\t\t\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n@@ -722,7 +722,7 @@ func TestGetUPnPPortMapping_LeaseDuration(t *testing.T) {\n //\n // See https://github.com/tailscale/tailscale/issues/10911\n func TestGetUPnPPortMapping_NoValidServices(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -753,7 +753,7 @@ func TestGetUPnPPortMapping_NoValidServices(t *testing.T) {\n \n // Tests the legacy behaviour with the pre-UPnP standard portmapping service.\n func TestGetUPnPPortMapping_Legacy(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -796,7 +796,7 @@ func TestGetUPnPPortMapping_Legacy(t *testing.T) {\n }\n \n func TestGetUPnPPortMappingNoResponses(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -912,7 +912,7 @@ func TestGetUPnPPortMapping_Invalid(t *testing.T) {\n \t\t\"127.0.0.1\",\n \t} {\n \t\tt.Run(responseAddr, func(t *testing.T) {\n-\t\t\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\t\t\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n---\ntstest/log.go\n@@ -13,6 +13,7 @@ import (\n \n \t\"go4.org/mem\"\n \t\"tailscale.com/types/logger\"\n+\t\"tailscale.com/util/testenv\"\n )\n \n type testLogWriter struct {\n@@ -149,7 +150,7 @@ func (ml *MemLogger) String() string {\n \n // WhileTestRunningLogger returns a logger.Logf that logs to t.Logf until the\n // test finishes, at which point it no longer logs anything.\n-func WhileTestRunningLogger(t testing.TB) logger.Logf {\n+func WhileTestRunningLogger(t testenv.TB) logger.Logf {\n \tvar (\n \t\tmu   sync.RWMutex\n \t\tdone bool\n---\n\n\n---\n\nChoice D:\ngo.toolchain.rev\n@@ -1 +1 @@\n-16b6e4fd15c59336156cdbc977de1745ad094f2d\n+982da8f24fa0504f2214f24b0d68b2febd5983f8\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIt was only used once, uselessly, in a test. So fix that.\n\nUpdates #5590 (which deprecated it, 2.5 years ago)\n\n\n---\n\nChoice A:\nutil/mak/mak.go\n@@ -5,11 +5,6 @@\n // things, notably to maps, but also slices.\n package mak\n \n-import (\n-\t\"fmt\"\n-\t\"reflect\"\n-)\n-\n // Set populates an entry in a map, making the map if necessary.\n //\n // That is, it assigns (*m)[k] = v, making *m if it was nil.\n@@ -20,35 +15,6 @@ func Set[K comparable, V any, T ~map[K]V](m *T, k K, v V) {\n \t(*m)[k] = v\n }\n \n-// NonNil takes a pointer to a Go data structure\n-// (currently only a slice or a map) and makes sure it's non-nil for\n-// JSON serialization. (In particular, JavaScript clients usually want\n-// the field to be defined after they decode the JSON.)\n-//\n-// Deprecated: use NonNilSliceForJSON or NonNilMapForJSON instead.\n-func NonNil(ptr any) {\n-\tif ptr == nil {\n-\t\tpanic(\"nil interface\")\n-\t}\n-\trv := reflect.ValueOf(ptr)\n-\tif rv.Kind() != reflect.Ptr {\n-\t\tpanic(fmt.Sprintf(\"kind %v, not Ptr\", rv.Kind()))\n-\t}\n-\tif rv.Pointer() == 0 {\n-\t\tpanic(\"nil pointer\")\n-\t}\n-\trv = rv.Elem()\n-\tif rv.Pointer() != 0 {\n-\t\treturn\n-\t}\n-\tswitch rv.Type().Kind() {\n-\tcase reflect.Slice:\n-\t\trv.Set(reflect.MakeSlice(rv.Type(), 0, 0))\n-\tcase reflect.Map:\n-\t\trv.Set(reflect.MakeMap(rv.Type()))\n-\t}\n-}\n-\n // NonNilSliceForJSON makes sure that *slicePtr is non-nil so it will\n // won't be omitted from JSON serialization and possibly confuse JavaScript\n // clients expecting it to be present.\n---\nutil/mak/mak_test.go\n@@ -40,35 +40,6 @@ func TestSet(t *testing.T) {\n \t})\n }\n \n-func TestNonNil(t *testing.T) {\n-\tvar s []string\n-\tNonNil(&s)\n-\tif len(s) != 0 {\n-\t\tt.Errorf(\"slice len = %d; want 0\", len(s))\n-\t}\n-\tif s == nil {\n-\t\tt.Error(\"slice still nil\")\n-\t}\n-\n-\ts = append(s, \"foo\")\n-\tNonNil(&s)\n-\tif len(s) != 1 {\n-\t\tt.Errorf(\"len = %d; want 1\", len(s))\n-\t}\n-\tif s[0] != \"foo\" {\n-\t\tt.Errorf(\"value = %q; want foo\", s)\n-\t}\n-\n-\tvar m map[string]string\n-\tNonNil(&m)\n-\tif len(m) != 0 {\n-\t\tt.Errorf(\"map len = %d; want 0\", len(s))\n-\t}\n-\tif m == nil {\n-\t\tt.Error(\"map still nil\")\n-\t}\n-}\n-\n func TestNonNilMapForJSON(t *testing.T) {\n \ttype M map[string]int\n \tvar m M\n---\n\n\n---\n\nChoice B:\ncmd/tailscale/cli/netcheck.go\n@@ -55,7 +55,10 @@ func runNetcheck(ctx context.Context, args []string) error {\n \n \t// Ensure that we close the portmapper after running a netcheck; this\n \t// will release any port mappings created.\n-\tpm := portmapper.NewClient(logf, netMon, nil, nil, nil)\n+\tpm := portmapper.NewClient(portmapper.Config{\n+\t\tLogf:   logf,\n+\t\tNetMon: netMon,\n+\t})\n \tdefer pm.Close()\n \n \tc := &netcheck.Client{\n---\nipn/localapi/localapi.go\n@@ -818,19 +818,25 @@ func (h *Handler) serveDebugPortmap(w http.ResponseWriter, r *http.Request) {\n \tdone := make(chan bool, 1)\n \n \tvar c *portmapper.Client\n-\tc = portmapper.NewClient(logger.WithPrefix(logf, \"portmapper: \"), h.b.NetMon(), debugKnobs, h.b.ControlKnobs(), func() {\n-\t\tlogf(\"portmapping changed.\")\n-\t\tlogf(\"have mapping: %v\", c.HaveMapping())\n-\n-\t\tif ext, ok := c.GetCachedMappingOrStartCreatingOne(); ok {\n-\t\t\tlogf(\"cb: mapping: %v\", ext)\n-\t\t\tselect {\n-\t\t\tcase done <- true:\n-\t\t\tdefault:\n+\tc = portmapper.NewClient(portmapper.Config{\n+\t\tLogf:         logger.WithPrefix(logf, \"portmapper: \"),\n+\t\tNetMon:       h.b.NetMon(),\n+\t\tDebugKnobs:   debugKnobs,\n+\t\tControlKnobs: h.b.ControlKnobs(),\n+\t\tOnChange: func() {\n+\t\t\tlogf(\"portmapping changed.\")\n+\t\t\tlogf(\"have mapping: %v\", c.HaveMapping())\n+\n+\t\t\tif ext, ok := c.GetCachedMappingOrStartCreatingOne(); ok {\n+\t\t\t\tlogf(\"cb: mapping: %v\", ext)\n+\t\t\t\tselect {\n+\t\t\t\tcase done <- true:\n+\t\t\t\tdefault:\n+\t\t\t\t}\n+\t\t\t\treturn\n \t\t\t}\n-\t\t\treturn\n-\t\t}\n-\t\tlogf(\"cb: no mapping\")\n+\t\t\tlogf(\"cb: no mapping\")\n+\t\t},\n \t})\n \tdefer c.Close()\n \n---\nnet/portmapper/igd_test.go\n@@ -260,9 +260,14 @@ func (d *TestIGD) handlePCPQuery(pkt []byte, src netip.AddrPort) {\n \n func newTestClient(t *testing.T, igd *TestIGD) *Client {\n \tvar c *Client\n-\tc = NewClient(t.Logf, netmon.NewStatic(), nil, new(controlknobs.Knobs), func() {\n-\t\tt.Logf(\"port map changed\")\n-\t\tt.Logf(\"have mapping: %v\", c.HaveMapping())\n+\tc = NewClient(Config{\n+\t\tLogf:         t.Logf,\n+\t\tNetMon:       netmon.NewStatic(),\n+\t\tControlKnobs: new(controlknobs.Knobs),\n+\t\tOnChange: func() {\n+\t\t\tt.Logf(\"port map changed\")\n+\t\t\tt.Logf(\"have mapping: %v\", c.HaveMapping())\n+\t\t},\n \t})\n \tc.testPxPPort = igd.TestPxPPort()\n \tc.testUPnPPort = igd.TestUPnPPort()\n---\nnet/portmapper/portmapper.go\n@@ -201,32 +201,45 @@ func (m *pmpMapping) Release(ctx context.Context) {\n \tuc.WriteToUDPAddrPort(pkt, m.gw)\n }\n \n-// NewClient returns a new portmapping client.\n-//\n-// The netMon parameter is required.\n-//\n-// The debug argument allows configuring the behaviour of the portmapper for\n-// debugging; if nil, a sensible set of defaults will be used.\n-//\n-// The controlKnobs, if non-nil, specifies the control knobs from the control\n-// plane that might disable portmapping.\n-//\n-// The optional onChange argument specifies a func to run in a new goroutine\n-// whenever the port mapping status has changed. If nil, it doesn't make a\n-// callback.\n-func NewClient(logf logger.Logf, netMon *netmon.Monitor, debug *DebugKnobs, controlKnobs *controlknobs.Knobs, onChange func()) *Client {\n-\tif netMon == nil {\n+// Config carries the settings for a [Client].\n+type Config struct {\n+\t// Logf is called to generate text logs for the client. If nil, logger.Discard is used.\n+\tLogf logger.Logf\n+\n+\t// NetMon is the network monitor used by the client. It must be non-nil.\n+\tNetMon *netmon.Monitor\n+\n+\t// DebugKnobs, if non-nil, configure the behaviour of the portmapper for\n+\t// debugging.  If nil, a sensible set of defaults will be used.\n+\tDebugKnobs *DebugKnobs\n+\n+\t// ControlKnobs, if non-nil, specifies knobs from the control plane that\n+\t// might disable port mapping.\n+\tControlKnobs *controlknobs.Knobs\n+\n+\t// OnChange is called to run in a new goroutine whenever the port mapping\n+\t// status has changed. If nil, no callback is issued.\n+\tOnChange func()\n+}\n+\n+// NewClient constructs a new portmapping [Client] from c. It will panic if any\n+// required parameters are omitted.\n+func NewClient(c Config) *Client {\n+\tif c.NetMon == nil {\n \t\tpanic(\"nil netMon\")\n \t}\n \tret := &Client{\n-\t\tlogf:         logf,\n-\t\tnetMon:       netMon,\n+\t\tlogf:         c.Logf,\n+\t\tnetMon:       c.NetMon,\n \t\tipAndGateway: netmon.LikelyHomeRouterIP, // TODO(bradfitz): move this to method on netMon\n-\t\tonChange:     onChange,\n-\t\tcontrolKnobs: controlKnobs,\n+\t\tonChange:     c.OnChange,\n+\t\tcontrolKnobs: c.ControlKnobs,\n+\t}\n+\tif ret.logf == nil {\n+\t\tret.logf = logger.Discard\n \t}\n-\tif debug != nil {\n-\t\tret.debug = *debug\n+\tif c.DebugKnobs != nil {\n+\t\tret.debug = *c.DebugKnobs\n \t}\n \treturn ret\n }\n---\nnet/portmapper/portmapper_test.go\n@@ -18,7 +18,7 @@ func TestCreateOrGetMapping(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tc.SetLocalPort(1234)\n \tfor i := range 2 {\n@@ -34,7 +34,7 @@ func TestClientProbe(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tfor i := range 3 {\n \t\tif i > 0 {\n@@ -49,7 +49,7 @@ func TestClientProbeThenMap(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tc.debug.VerboseLogs = true\n \tc.SetLocalPort(1234)\n---\nwgengine/magicsock/magicsock.go\n@@ -544,7 +544,13 @@ func NewConn(opts Options) (*Conn, error) {\n \tportMapOpts := &portmapper.DebugKnobs{\n \t\tDisableAll: func() bool { return opts.DisablePortMapper || c.onlyTCP443.Load() },\n \t}\n-\tc.portMapper = portmapper.NewClient(portmapperLogf, opts.NetMon, portMapOpts, opts.ControlKnobs, c.onPortMapChanged)\n+\tc.portMapper = portmapper.NewClient(portmapper.Config{\n+\t\tLogf:         portmapperLogf,\n+\t\tNetMon:       opts.NetMon,\n+\t\tDebugKnobs:   portMapOpts,\n+\t\tControlKnobs: opts.ControlKnobs,\n+\t\tOnChange:     c.onPortMapChanged,\n+\t})\n \tc.portMapper.SetGatewayLookupFunc(opts.NetMon.GatewayAndSelfIP)\n \tc.netMon = opts.NetMon\n \tc.health = opts.HealthTracker\n---\n\n\n---\n\nChoice C:\nwgengine/netstack/netstack.go\n@@ -326,10 +326,15 @@ func Create(logf logger.Logf, tundev *tstun.Wrapper, e wgengine.Engine, mc *magi\n \tif tcpipErr != nil {\n \t\treturn nil, fmt.Errorf(\"could not disable TCP RACK: %v\", tcpipErr)\n \t}\n-\tcubicOpt := tcpip.CongestionControlOption(\"cubic\")\n-\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &cubicOpt)\n+\t// gVisor defaults to reno at the time of writing. We explicitly set reno\n+\t// congestion control in order to prevent unexpected changes. Netstack\n+\t// has an int overflow in sender congestion window arithmetic that is more\n+\t// prone to trigger with cubic congestion control.\n+\t// See https://github.com/google/gvisor/issues/11632\n+\trenoOpt := tcpip.CongestionControlOption(\"reno\")\n+\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &renoOpt)\n \tif tcpipErr != nil {\n-\t\treturn nil, fmt.Errorf(\"could not set cubic congestion control: %v\", tcpipErr)\n+\t\treturn nil, fmt.Errorf(\"could not set reno congestion control: %v\", tcpipErr)\n \t}\n \terr := setTCPBufSizes(ipstack)\n \tif err != nil {\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -5918,19 +5918,22 @@ func (b *LocalBackend) requestEngineStatusAndWait() {\n \tb.logf(\"requestEngineStatusAndWait: got status update.\")\n }\n \n+// [controlclient.Auto] implements [auditlog.Transport].\n+var _ auditlog.Transport = (*controlclient.Auto)(nil)\n+\n // setControlClientLocked sets the control client to cc,\n // which may be nil.\n //\n // b.mu must be held.\n func (b *LocalBackend) setControlClientLocked(cc controlclient.Client) {\n \tb.cc = cc\n \tb.ccAuto, _ = cc.(*controlclient.Auto)\n-\tif b.auditLogger != nil {\n+\tif t, ok := b.cc.(auditlog.Transport); ok && b.auditLogger != nil {\n \t\tif err := b.auditLogger.SetProfileID(b.pm.CurrentProfile().ID()); err != nil {\n \t\t\tb.logf(\"audit logger set profile ID failure: %v\", err)\n \t\t}\n \n-\t\tif err := b.auditLogger.Start(b.ccAuto); err != nil {\n+\t\tif err := b.auditLogger.Start(t); err != nil {\n \t\t\tb.logf(\"audit logger start failure: %v\", err)\n \t\t}\n \t}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThe previous strategy assumed clients maintained adequate state to understand the relationship between endpoint allocation and the server it was allocated on.\r\n\r\nmagicsock will not have awareness of the server's disco key pre-allocation, it only understands peerAPI address at this point. The second client to allocate on the same server could trigger re-allocation, breaking a functional relay server endpoint.\r\n\r\nIf magicsock needs to force reallocation we can add opt-in behaviors for this later.\r\n\r\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\ncmd/proxy-to-grafana/proxy-to-grafana.go\n@@ -53,7 +53,7 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"tailscale.com/client/local\"\n+\t\"tailscale.com/client/tailscale/apitype\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/tsnet\"\n )\n@@ -195,13 +195,7 @@ func main() {\n \tlog.Fatal(http.Serve(ln, proxy))\n }\n \n-func modifyRequest(req *http.Request, localClient *local.Client) {\n-\t// with enable_login_token set to true, we get a cookie that handles\n-\t// auth for paths that are not /login\n-\tif req.URL.Path != \"/login\" {\n-\t\treturn\n-\t}\n-\n+func modifyRequest(req *http.Request, localClient whoisIdentitySource) {\n \t// Delete any existing X-Webauth-* headers to prevent possible spoofing\n \t// if getting Tailnet identity fails.\n \tfor h := range req.Header {\n@@ -210,6 +204,13 @@ func modifyRequest(req *http.Request, localClient *local.Client) {\n \t\t}\n \t}\n \n+\t// Set the X-Webauth-* headers only for the /login path\n+\t// With enable_login_token set to true, we get a cookie that handles\n+\t// auth for paths that are not /login\n+\tif req.URL.Path != \"/login\" {\n+\t\treturn\n+\t}\n+\n \tuser, role, err := getTailscaleIdentity(req.Context(), localClient, req.RemoteAddr)\n \tif err != nil {\n \t\tlog.Printf(\"error getting Tailscale user: %v\", err)\n@@ -221,7 +222,7 @@ func modifyRequest(req *http.Request, localClient *local.Client) {\n \treq.Header.Set(\"X-Webauth-Role\", role.String())\n }\n \n-func getTailscaleIdentity(ctx context.Context, localClient *local.Client, ipPort string) (*tailcfg.UserProfile, grafanaRole, error) {\n+func getTailscaleIdentity(ctx context.Context, localClient whoisIdentitySource, ipPort string) (*tailcfg.UserProfile, grafanaRole, error) {\n \twhois, err := localClient.WhoIs(ctx, ipPort)\n \tif err != nil {\n \t\treturn nil, ViewerRole, fmt.Errorf(\"failed to identify remote host: %w\", err)\n@@ -248,3 +249,7 @@ func getTailscaleIdentity(ctx context.Context, localClient *local.Client, ipPort\n \n \treturn whois.UserProfile, role, nil\n }\n+\n+type whoisIdentitySource interface {\n+\tWhoIs(ctx context.Context, ipPort string) (*apitype.WhoIsResponse, error)\n+}\n---\ncmd/proxy-to-grafana/proxy-to-grafana_test.go\n@@ -0,0 +1,77 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+package main\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+\n+\t\"tailscale.com/client/tailscale/apitype\"\n+\t\"tailscale.com/tailcfg\"\n+)\n+\n+type mockWhoisSource struct {\n+\tid *apitype.WhoIsResponse\n+}\n+\n+func (m *mockWhoisSource) WhoIs(ctx context.Context, remoteAddr string) (*apitype.WhoIsResponse, error) {\n+\tif m.id == nil {\n+\t\treturn nil, fmt.Errorf(\"missing mock identity\")\n+\t}\n+\treturn m.id, nil\n+}\n+\n+var whois = &apitype.WhoIsResponse{\n+\tUserProfile: &tailcfg.UserProfile{\n+\t\tLoginName:   \"foobar@example.com\",\n+\t\tDisplayName: \"Foobar\",\n+\t},\n+\tNode: &tailcfg.Node{\n+\t\tID: 1,\n+\t},\n+}\n+\n+func TestModifyRequest_Login(t *testing.T) {\n+\treq := httptest.NewRequest(\"GET\", \"/login\", nil)\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"foobar@example.com\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"foobar@example.com\")\n+\t}\n+\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"Viewer\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"Viewer\")\n+\t}\n+}\n+\n+func TestModifyRequest_RemoveHeaders_Login(t *testing.T) {\n+\treq := httptest.NewRequest(\"GET\", \"/login\", nil)\n+\treq.Header.Set(\"X-Webauth-User\", \"malicious@example.com\")\n+\treq.Header.Set(\"X-Webauth-Role\", \"Admin\")\n+\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"foobar@example.com\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"foobar@example.com\")\n+\t}\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"Viewer\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"Viewer\")\n+\t}\n+}\n+\n+func TestModifyRequest_RemoveHeaders_API(t *testing.T) {\n+\treq := httptest.NewRequest(\"DELETE\", \"/api/org/users/1\", nil)\n+\treq.Header.Set(\"X-Webauth-User\", \"malicious@example.com\")\n+\treq.Header.Set(\"X-Webauth-Role\", \"Admin\")\n+\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"\")\n+\t}\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"\")\n+\t}\n+}\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -4968,7 +4968,7 @@ func (b *LocalBackend) authReconfig() {\n \t\treturn\n \t}\n \n-\toneCGNATRoute := shouldUseOneCGNATRoute(b.logf, b.sys.ControlKnobs(), version.OS())\n+\toneCGNATRoute := shouldUseOneCGNATRoute(b.logf, b.sys.NetMon.Get(), b.sys.ControlKnobs(), version.OS())\n \trcfg := b.routerConfig(cfg, prefs, oneCGNATRoute)\n \n \terr = b.e.Reconfig(cfg, rcfg, dcfg)\n@@ -4992,7 +4992,7 @@ func (b *LocalBackend) authReconfig() {\n //\n // The versionOS is a Tailscale-style version (\"iOS\", \"macOS\") and not\n // a runtime.GOOS.\n-func shouldUseOneCGNATRoute(logf logger.Logf, controlKnobs *controlknobs.Knobs, versionOS string) bool {\n+func shouldUseOneCGNATRoute(logf logger.Logf, mon *netmon.Monitor, controlKnobs *controlknobs.Knobs, versionOS string) bool {\n \tif controlKnobs != nil {\n \t\t// Explicit enabling or disabling always take precedence.\n \t\tif v, ok := controlKnobs.OneCGNAT.Load().Get(); ok {\n@@ -5007,7 +5007,7 @@ func shouldUseOneCGNATRoute(logf logger.Logf, controlKnobs *controlknobs.Knobs,\n \t// use fine-grained routes if another interfaces is also using the CGNAT\n \t// IP range.\n \tif versionOS == \"macOS\" {\n-\t\thasCGNATInterface, err := netmon.HasCGNATInterface()\n+\t\thasCGNATInterface, err := mon.HasCGNATInterface()\n \t\tif err != nil {\n \t\t\tlogf(\"shouldUseOneCGNATRoute: Could not determine if any interfaces use CGNAT: %v\", err)\n \t\t\treturn false\n---\nipn/ipnlocal/peerapi.go\n@@ -481,7 +481,7 @@ func (h *peerAPIHandler) handleServeInterfaces(w http.ResponseWriter, r *http.Re\n \t\tfmt.Fprintf(w, \"<h3>Could not get the default route: %s</h3>\\n\", html.EscapeString(err.Error()))\n \t}\n \n-\tif hasCGNATInterface, err := netmon.HasCGNATInterface(); hasCGNATInterface {\n+\tif hasCGNATInterface, err := h.ps.b.sys.NetMon.Get().HasCGNATInterface(); hasCGNATInterface {\n \t\tfmt.Fprintln(w, \"<p>There is another interface using the CGNAT range.</p>\")\n \t} else if err != nil {\n \t\tfmt.Fprintf(w, \"<p>Could not check for CGNAT interfaces: %s</p>\\n\", html.EscapeString(err.Error()))\n---\nnet/netmon/interfaces_test.go\n@@ -13,7 +13,7 @@ import (\n )\n \n func TestGetState(t *testing.T) {\n-\tst, err := getState()\n+\tst, err := getState(\"\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/netmon/netmon.go\n@@ -161,7 +161,7 @@ func (m *Monitor) InterfaceState() *State {\n }\n \n func (m *Monitor) interfaceStateUncached() (*State, error) {\n-\treturn getState()\n+\treturn getState(m.tsIfName)\n }\n \n // SetTailscaleInterfaceName sets the name of the Tailscale interface. For\n---\nnet/netmon/state.go\n@@ -461,21 +461,22 @@ func isTailscaleInterface(name string, ips []netip.Prefix) bool {\n // getPAC, if non-nil, returns the current PAC file URL.\n var getPAC func() string\n \n-// GetState returns the state of all the current machine's network interfaces.\n+// getState returns the state of all the current machine's network interfaces.\n //\n // It does not set the returned State.IsExpensive. The caller can populate that.\n //\n-// Deprecated: use netmon.Monitor.InterfaceState instead.\n-func getState() (*State, error) {\n+// optTSInterfaceName is the name of the Tailscale interface, if known.\n+func getState(optTSInterfaceName string) (*State, error) {\n \ts := &State{\n \t\tInterfaceIPs: make(map[string][]netip.Prefix),\n \t\tInterface:    make(map[string]Interface),\n \t}\n \tif err := ForeachInterface(func(ni Interface, pfxs []netip.Prefix) {\n+\t\tisTSInterfaceName := optTSInterfaceName != \"\" && ni.Name == optTSInterfaceName\n \t\tifUp := ni.IsUp()\n \t\ts.Interface[ni.Name] = ni\n \t\ts.InterfaceIPs[ni.Name] = append(s.InterfaceIPs[ni.Name], pfxs...)\n-\t\tif !ifUp || isTailscaleInterface(ni.Name, pfxs) {\n+\t\tif !ifUp || isTSInterfaceName || isTailscaleInterface(ni.Name, pfxs) {\n \t\t\treturn\n \t\t}\n \t\tfor _, pfx := range pfxs {\n@@ -755,11 +756,12 @@ func DefaultRoute() (DefaultRouteDetails, error) {\n \n // HasCGNATInterface reports whether there are any non-Tailscale interfaces that\n // use a CGNAT IP range.\n-func HasCGNATInterface() (bool, error) {\n+func (m *Monitor) HasCGNATInterface() (bool, error) {\n \thasCGNATInterface := false\n \tcgnatRange := tsaddr.CGNATRange()\n \terr := ForeachInterface(func(i Interface, pfxs []netip.Prefix) {\n-\t\tif hasCGNATInterface || !i.IsUp() || isTailscaleInterface(i.Name, pfxs) {\n+\t\tisTSInterfaceName := m.tsIfName != \"\" && i.Name == m.tsIfName\n+\t\tif hasCGNATInterface || !i.IsUp() || isTSInterfaceName || isTailscaleInterface(i.Name, pfxs) {\n \t\t\treturn\n \t\t}\n \t\tfor _, pfx := range pfxs {\n---\n\n\n---\n\nChoice C:\nnet/udprelay/server.go\n@@ -454,9 +454,10 @@ func (s *Server) packetReadLoop() {\n \n var ErrServerClosed = errors.New(\"server closed\")\n \n-// AllocateEndpoint allocates a ServerEndpoint for the provided pair of\n-// key.DiscoPublic's. It returns an error (ErrServerClosed) if the server has\n-// been closed.\n+// AllocateEndpoint allocates a [ServerEndpoint] for the provided pair of\n+// [key.DiscoPublic]'s. If an allocation already exists for discoA and discoB it\n+// is returned without modification/reallocation. AllocateEndpoint returns\n+// [ErrServerClosed] if the server has been closed.\n func (s *Server) AllocateEndpoint(discoA, discoB key.DiscoPublic) (ServerEndpoint, error) {\n \ts.mu.Lock()\n \tdefer s.mu.Unlock()\n@@ -471,36 +472,19 @@ func (s *Server) AllocateEndpoint(discoA, discoB key.DiscoPublic) (ServerEndpoin\n \tpair := newPairOfDiscoPubKeys(discoA, discoB)\n \te, ok := s.byDisco[pair]\n \tif ok {\n-\t\tif !e.isBound() {\n-\t\t\t// If the endpoint is not yet bound this is likely an allocation\n-\t\t\t// race between two clients on the same Server. Instead of\n-\t\t\t// re-allocating we return the existing allocation. We do not reset\n-\t\t\t// e.allocatedAt in case a client is \"stuck\" in an allocation\n-\t\t\t// loop and will not be able to complete a handshake, for whatever\n-\t\t\t// reason. Once the endpoint expires a new endpoint will be\n-\t\t\t// allocated. Clients can resolve duplicate ServerEndpoint details\n-\t\t\t// via ServerEndpoint.LamportID.\n-\t\t\t//\n-\t\t\t// TODO: consider ServerEndpoint.BindLifetime -= time.Now()-e.allocatedAt\n-\t\t\t// to give the client a more accurate picture of the bind window.\n-\t\t\t// Or, some threshold to trigger re-allocation if too much time has\n-\t\t\t// already passed since it was originally allocated.\n-\t\t\treturn ServerEndpoint{\n-\t\t\t\tServerDisco:         s.discoPublic,\n-\t\t\t\tAddrPorts:           s.addrPorts,\n-\t\t\t\tVNI:                 e.vni,\n-\t\t\t\tLamportID:           e.lamportID,\n-\t\t\t\tBindLifetime:        tstime.GoDuration{Duration: s.bindLifetime},\n-\t\t\t\tSteadyStateLifetime: tstime.GoDuration{Duration: s.steadyStateLifetime},\n-\t\t\t}, nil\n-\t\t}\n-\t\t// If an endpoint exists for the pair of key.DiscoPublic's, and is\n-\t\t// already bound, delete it. We will re-allocate a new endpoint. Chances\n-\t\t// are clients cannot make use of the existing, bound allocation if\n-\t\t// they are requesting a new one.\n-\t\tdelete(s.byDisco, pair)\n-\t\tdelete(s.byVNI, e.vni)\n-\t\ts.vniPool = append(s.vniPool, e.vni)\n+\t\t// Return the existing allocation. Clients can resolve duplicate\n+\t\t// [ServerEndpoint]'s via [ServerEndpoint.LamportID].\n+\t\t//\n+\t\t// TODO: consider ServerEndpoint.BindLifetime -= time.Now()-e.allocatedAt\n+\t\t// to give the client a more accurate picture of the bind window.\n+\t\treturn ServerEndpoint{\n+\t\t\tServerDisco:         s.discoPublic,\n+\t\t\tAddrPorts:           s.addrPorts,\n+\t\t\tVNI:                 e.vni,\n+\t\t\tLamportID:           e.lamportID,\n+\t\t\tBindLifetime:        tstime.GoDuration{Duration: s.bindLifetime},\n+\t\t\tSteadyStateLifetime: tstime.GoDuration{Duration: s.steadyStateLifetime},\n+\t\t}, nil\n \t}\n \n \tif len(s.vniPool) == 0 {\n---\nnet/udprelay/server_test.go\n@@ -174,8 +174,7 @@ func TestServer(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \n-\t// We expect the same endpoint details as the 3-way bind handshake has not\n-\t// yet been completed for both relay client parties.\n+\t// We expect the same endpoint details pre-handshake.\n \tif diff := cmp.Diff(dupEndpoint, endpoint, cmpopts.EquateComparable(netip.AddrPort{}, key.DiscoPublic{})); diff != \"\" {\n \t\tt.Fatalf(\"wrong dupEndpoint (-got +want)\\n%s\", diff)\n \t}\n@@ -191,6 +190,15 @@ func TestServer(t *testing.T) {\n \ttcA.handshake(t)\n \ttcB.handshake(t)\n \n+\tdupEndpoint, err = server.AllocateEndpoint(discoA.Public(), discoB.Public())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// We expect the same endpoint details post-handshake.\n+\tif diff := cmp.Diff(dupEndpoint, endpoint, cmpopts.EquateComparable(netip.AddrPort{}, key.DiscoPublic{})); diff != \"\" {\n+\t\tt.Fatalf(\"wrong dupEndpoint (-got +want)\\n%s\", diff)\n+\t}\n+\n \ttxToB := []byte{1, 2, 3}\n \ttcA.writeDataPkt(t, txToB)\n \trxFromA := tcB.readDataPkt(t)\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/up_test.go\n@@ -0,0 +1,55 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package cli\n+\n+import (\n+\t\"flag\"\n+\t\"testing\"\n+\n+\t\"tailscale.com/util/set\"\n+)\n+\n+// validUpFlags are the only flags that are valid for tailscale up. The up\n+// command is frozen: no new preferences can be added. Instead, add them to\n+// tailscale set.\n+// See tailscale/tailscale#15460.\n+var validUpFlags = set.Of(\n+\t\"accept-dns\",\n+\t\"accept-risk\",\n+\t\"accept-routes\",\n+\t\"advertise-connector\",\n+\t\"advertise-exit-node\",\n+\t\"advertise-routes\",\n+\t\"advertise-tags\",\n+\t\"auth-key\",\n+\t\"exit-node\",\n+\t\"exit-node-allow-lan-access\",\n+\t\"force-reauth\",\n+\t\"host-routes\",\n+\t\"hostname\",\n+\t\"json\",\n+\t\"login-server\",\n+\t\"netfilter-mode\",\n+\t\"nickname\",\n+\t\"operator\",\n+\t\"posture-checking\",\n+\t\"qr\",\n+\t\"reset\",\n+\t\"shields-up\",\n+\t\"snat-subnet-routes\",\n+\t\"ssh\",\n+\t\"stateful-filtering\",\n+\t\"timeout\",\n+\t\"unattended\",\n+)\n+\n+// TestUpFlagSetIsFrozen complains when new flags are added to tailscale up.\n+func TestUpFlagSetIsFrozen(t *testing.T) {\n+\tupFlagSet.VisitAll(func(f *flag.Flag) {\n+\t\tname := f.Name\n+\t\tif !validUpFlags.Contains(name) {\n+\t\t\tt.Errorf(\"--%s flag added to tailscale up, new prefs go in tailscale set: see tailscale/tailscale#15460\", name)\n+\t\t}\n+\t})\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis message type is currently unused and considered experimental.\r\n\r\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\nfeature/relayserver/relayserver.go\n@@ -142,7 +142,7 @@ func handlePeerAPIRelayAllocateEndpoint(h ipnlocal.PeerAPIHandler, w http.Respon\n \n \thttpErrAndLog := func(message string, code int) {\n \t\thttp.Error(w, message, code)\n-\t\te.logf(\"peerapi: request from %v returned code %d: %s\", h.RemoteAddr(), code, message)\n+\t\th.Logf(\"relayserver: request from %v returned code %d: %s\", h.RemoteAddr(), code, message)\n \t}\n \n \tif !h.PeerCaps().HasCapability(tailcfg.PeerCapabilityRelay) {\n---\n\n\n---\n\nChoice B:\ndisco/disco.go\n@@ -25,6 +25,7 @@ import (\n \t\"fmt\"\n \t\"net\"\n \t\"net/netip\"\n+\t\"time\"\n \n \t\"go4.org/mem\"\n \t\"tailscale.com/types/key\"\n@@ -47,6 +48,7 @@ const (\n \tTypeBindUDPRelayEndpoint          = MessageType(0x04)\n \tTypeBindUDPRelayEndpointChallenge = MessageType(0x05)\n \tTypeBindUDPRelayEndpointAnswer    = MessageType(0x06)\n+\tTypeCallMeMaybeVia                = MessageType(0x07)\n )\n \n const v0 = byte(0)\n@@ -93,6 +95,8 @@ func Parse(p []byte) (Message, error) {\n \t\treturn parseBindUDPRelayEndpointChallenge(ver, p)\n \tcase TypeBindUDPRelayEndpointAnswer:\n \t\treturn parseBindUDPRelayEndpointAnswer(ver, p)\n+\tcase TypeCallMeMaybeVia:\n+\t\treturn parseCallMeMaybeVia(ver, p)\n \tdefault:\n \t\treturn nil, fmt.Errorf(\"unknown message type 0x%02x\", byte(t))\n \t}\n@@ -392,3 +396,94 @@ func parseBindUDPRelayEndpointAnswer(ver uint8, p []byte) (m *BindUDPRelayEndpoi\n \tcopy(m.Answer[:], p[:])\n \treturn m, nil\n }\n+\n+// CallMeMaybeVia is a message sent only over DERP to request that the recipient\n+// try to open up a magicsock path back to the sender. The 'Via' in\n+// CallMeMaybeVia highlights that candidate paths are served through an\n+// intermediate relay, likely a [tailscale.com/net/udprelay.Server].\n+//\n+// Usage of the candidate paths in magicsock requires a 3-way handshake\n+// involving [BindUDPRelayEndpoint], [BindUDPRelayEndpointChallenge], and\n+// [BindUDPRelayEndpointAnswer].\n+//\n+// CallMeMaybeVia mirrors [tailscale.com/net/udprelay.ServerEndpoint], which\n+// contains field documentation.\n+//\n+// The recipient may choose to not open a path back if it's already happy with\n+// its path. Direct connections, e.g. [CallMeMaybe]-signaled, take priority over\n+// CallMeMaybeVia paths.\n+//\n+// This message type is currently considered experimental and is not yet tied to\n+// a [tailscale.com/tailcfg.CapabilityVersion].\n+type CallMeMaybeVia struct {\n+\t// ServerDisco is [tailscale.com/net/udprelay.ServerEndpoint.ServerDisco]\n+\tServerDisco key.DiscoPublic\n+\t// LamportID is [tailscale.com/net/udprelay.ServerEndpoint.LamportID]\n+\tLamportID uint64\n+\t// VNI is [tailscale.com/net/udprelay.ServerEndpoint.VNI]\n+\tVNI uint32\n+\t// BindLifetime is [tailscale.com/net/udprelay.ServerEndpoint.BindLifetime]\n+\tBindLifetime time.Duration\n+\t// SteadyStateLifetime is [tailscale.com/net/udprelay.ServerEndpoint.SteadyStateLifetime]\n+\tSteadyStateLifetime time.Duration\n+\t// AddrPorts is [tailscale.com/net/udprelay.ServerEndpoint.AddrPorts]\n+\tAddrPorts []netip.AddrPort\n+}\n+\n+const cmmvDataLenMinusEndpoints = key.DiscoPublicRawLen + // ServerDisco\n+\t8 + // LamportID\n+\t4 + // VNI\n+\t8 + // BindLifetime\n+\t8 // SteadyStateLifetime\n+\n+func (m *CallMeMaybeVia) AppendMarshal(b []byte) []byte {\n+\tendpointsLen := epLength * len(m.AddrPorts)\n+\tret, p := appendMsgHeader(b, TypeCallMeMaybeVia, v0, cmmvDataLenMinusEndpoints+endpointsLen)\n+\tdisco := m.ServerDisco.AppendTo(nil)\n+\tcopy(p, disco)\n+\tp = p[key.DiscoPublicRawLen:]\n+\tbinary.BigEndian.PutUint64(p[:8], m.LamportID)\n+\tp = p[8:]\n+\tbinary.BigEndian.PutUint32(p[:4], m.VNI)\n+\tp = p[4:]\n+\tbinary.BigEndian.PutUint64(p[:8], uint64(m.BindLifetime))\n+\tp = p[8:]\n+\tbinary.BigEndian.PutUint64(p[:8], uint64(m.SteadyStateLifetime))\n+\tp = p[8:]\n+\tfor _, ipp := range m.AddrPorts {\n+\t\ta := ipp.Addr().As16()\n+\t\tcopy(p, a[:])\n+\t\tbinary.BigEndian.PutUint16(p[16:18], ipp.Port())\n+\t\tp = p[epLength:]\n+\t}\n+\treturn ret\n+}\n+\n+func parseCallMeMaybeVia(ver uint8, p []byte) (m *CallMeMaybeVia, err error) {\n+\tm = new(CallMeMaybeVia)\n+\tif len(p) < cmmvDataLenMinusEndpoints+epLength ||\n+\t\t(len(p)-cmmvDataLenMinusEndpoints)%epLength != 0 ||\n+\t\tver != 0 {\n+\t\treturn m, nil\n+\t}\n+\tm.ServerDisco = key.DiscoPublicFromRaw32(mem.B(p[:key.DiscoPublicRawLen]))\n+\tp = p[key.DiscoPublicRawLen:]\n+\tm.LamportID = binary.BigEndian.Uint64(p[:8])\n+\tp = p[8:]\n+\tm.VNI = binary.BigEndian.Uint32(p[:4])\n+\tp = p[4:]\n+\tm.BindLifetime = time.Duration(binary.BigEndian.Uint64(p[:8]))\n+\tp = p[8:]\n+\tm.SteadyStateLifetime = time.Duration(binary.BigEndian.Uint64(p[:8]))\n+\tp = p[8:]\n+\tm.AddrPorts = make([]netip.AddrPort, 0, len(p)-cmmvDataLenMinusEndpoints/epLength)\n+\tfor len(p) > 0 {\n+\t\tvar a [16]byte\n+\t\tcopy(a[:], p)\n+\t\tm.AddrPorts = append(m.AddrPorts, netip.AddrPortFrom(\n+\t\t\tnetip.AddrFrom16(a).Unmap(),\n+\t\t\tbinary.BigEndian.Uint16(p[16:18])))\n+\t\tp = p[epLength:]\n+\t}\n+\treturn m, nil\n+}\n---\ndisco/disco_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \n \t\"go4.org/mem\"\n \t\"tailscale.com/types/key\"\n@@ -106,6 +107,21 @@ func TestMarshalAndParse(t *testing.T) {\n \t\t\t},\n \t\t\twant: \"06 00 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f\",\n \t\t},\n+\t\t{\n+\t\t\tname: \"call_me_maybe_via\",\n+\t\t\tm: &CallMeMaybeVia{\n+\t\t\t\tServerDisco:         key.DiscoPublicFromRaw32(mem.B([]byte{1: 1, 2: 2, 30: 30, 31: 31})),\n+\t\t\t\tLamportID:           123,\n+\t\t\t\tVNI:                 456,\n+\t\t\t\tBindLifetime:        time.Second,\n+\t\t\t\tSteadyStateLifetime: time.Minute,\n+\t\t\t\tAddrPorts: []netip.AddrPort{\n+\t\t\t\t\tnetip.MustParseAddrPort(\"1.2.3.4:567\"),\n+\t\t\t\t\tnetip.MustParseAddrPort(\"[2001::3456]:789\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twant: \"07 00 00 01 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 1e 1f 00 00 00 00 00 00 00 7b 00 00 01 c8 00 00 00 00 3b 9a ca 00 00 00 00 0d f8 47 58 00 00 00 00 00 00 00 00 00 00 00 ff ff 01 02 03 04 02 37 20 01 00 00 00 00 00 00 00 00 00 00 00 00 34 56 03 15\",\n+\t\t},\n \t}\n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n---\n\n\n---\n\nChoice C:\ngo.toolchain.rev\n@@ -1 +1 @@\n-982da8f24fa0504f2214f24b0d68b2febd5983f8\n+98e8c99c256a5aeaa13725d2e43fdd7f465ba200\n---\n\n\n---\n\nChoice D:\ntailcfg/tailcfg.go\n@@ -2446,6 +2446,14 @@ const (\n \t// native tailnet. This is currently only sent to Hello, in its\n \t// peer node list.\n \tNodeAttrNativeIPV4 NodeCapability = \"native-ipv4\"\n+\n+\t// NodeAttrRelayServer permits the node to act as an underlay UDP relay\n+\t// server. There are no expected values for this key in NodeCapMap.\n+\tNodeAttrRelayServer NodeCapability = \"relay:server\"\n+\n+\t// NodeAttrRelayClient permits the node to act as an underlay UDP relay\n+\t// client. There are no expected values for this key in NodeCapMap.\n+\tNodeAttrRelayClient NodeCapability = \"relay:client\"\n )\n \n // SetDNSRequest is a request to add a DNS record.\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis is the same version as before, but the old one confuses govulncheck.\r\n\r\nUpdates #cleanup\n\n---\n\nChoice A:\ngo.mod\n@@ -272,7 +272,7 @@ require (\n \tgithub.com/gordonklaus/ineffassign v0.1.0 // indirect\n \tgithub.com/goreleaser/chglog v0.5.0 // indirect\n \tgithub.com/goreleaser/fileglob v1.3.0 // indirect\n-\tgithub.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30\n+\tgithub.com/gorilla/csrf v1.7.3\n \tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n \tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n \tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n---\ngo.sum\n@@ -524,8 +524,8 @@ github.com/goreleaser/fileglob v1.3.0 h1:/X6J7U8lbDpQtBvGcwwPS6OpzkNVlVEsFUVRx9+\n github.com/goreleaser/fileglob v1.3.0/go.mod h1:Jx6BoXv3mbYkEzwm9THo7xbr5egkAraxkGorbJb4RxU=\n github.com/goreleaser/nfpm/v2 v2.33.1 h1:EkdAzZyVhAI9JC1vjmjjbmnNzyH1J6Cu4JCsA7YcQuc=\n github.com/goreleaser/nfpm/v2 v2.33.1/go.mod h1:8wwWWvJWmn84xo/Sqiv0aMvEGTHlHZTXTEuVSgQpkIM=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30 h1:fiJdrgVBkjZ5B1HJ2WQwNOaXB+QyYcNXTA3t1XYLz0M=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n+github.com/gorilla/csrf v1.7.3 h1:BHWt6FTLZAb2HtWT5KDBf6qgpZzvtbp9QWDRKZMXJC0=\n+github.com/gorilla/csrf v1.7.3/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n github.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\n github.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\n github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=\n---\n\n\n---\n\nChoice B:\nfeature/taildrop/ext.go\n@@ -100,6 +100,10 @@ func (e *Extension) Init(h ipnext.Host) error {\n \th.Hooks().SetPeerStatus.Add(e.setPeerStatus)\n \th.Hooks().BackendStateChange.Add(e.onBackendStateChange)\n \n+\t// TODO(nickkhyl): remove this after the profileManager refactoring.\n+\t// See tailscale/tailscale#15974.\n+\tprofile, prefs := h.Profiles().CurrentProfileState()\n+\te.onChangeProfile(profile, prefs, false)\n \treturn nil\n }\n \n---\nfeature/taildrop/integration_test.go\n@@ -26,7 +26,6 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n-\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n \ttestTaildropIntegration(t, false)\n }\n \n---\nipn/ipnext/ipnext.go\n@@ -37,7 +37,10 @@ type Extension interface {\n \t// It must be the same as the name used to register the extension.\n \tName() string\n \n-\t// Init is called to initialize the extension when LocalBackend is initialized.\n+\t// Init is called to initialize the extension when LocalBackend's\n+\t// Start method is called. Extensions are created but not initialized\n+\t// unless LocalBackend is started.\n+\t//\n \t// If the extension cannot be initialized, it must return an error,\n \t// and its Shutdown method will not be called on the host's shutdown.\n \t// Returned errors are not fatal; they are used for logging.\n@@ -333,6 +336,7 @@ type Hooks struct {\n \t// BackendStateChange is called when the backend state changes.\n \tBackendStateChange feature.Hooks[func(ipn.State)]\n \n+\t// ProfileStateChange contains callbacks that are invoked when the current login profile\n \t// or its [ipn.Prefs] change, after those changes have been made. The current login profile\n \t// may be changed either because of a profile switch, or because the profile information\n \t// was updated by [LocalBackend.SetControlClientStatus], including when the profile\n---\nipn/ipnlocal/local.go\n@@ -237,6 +237,8 @@ type LocalBackend struct {\n \t// for testing and graceful shutdown purposes.\n \tgoTracker goroutines.Tracker\n \n+\tstartOnce sync.Once // protects the one\u2011time initialization in [LocalBackend.Start]\n+\n \t// extHost is the bridge between [LocalBackend] and the registered [ipnext.Extension]s.\n \t// It may be nil in tests that use direct composite literal initialization of [LocalBackend]\n \t// instead of calling [NewLocalBackend]. A nil pointer is a valid, no-op host.\n@@ -568,8 +570,6 @@ func NewLocalBackend(logf logger.Logf, logID logid.PublicID, sys *tsd.System, lo\n \t\t\t}\n \t\t}\n \t}\n-\n-\tb.extHost.Init()\n \treturn b, nil\n }\n \n@@ -2162,6 +2162,11 @@ func (b *LocalBackend) getNewControlClientFuncLocked() clientGen {\n \treturn b.ccGen\n }\n \n+// initOnce is called on the first call to [LocalBackend.Start].\n+func (b *LocalBackend) initOnce() {\n+\tb.extHost.Init()\n+}\n+\n // Start applies the configuration specified in opts, and starts the\n // state machine.\n //\n@@ -2175,6 +2180,8 @@ func (b *LocalBackend) getNewControlClientFuncLocked() clientGen {\n func (b *LocalBackend) Start(opts ipn.Options) error {\n \tb.logf(\"Start\")\n \n+\tb.startOnce.Do(b.initOnce)\n+\n \tvar clientToShutdown controlclient.Client\n \tdefer func() {\n \t\tif clientToShutdown != nil {\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local.go\n@@ -2404,11 +2404,9 @@ func (b *LocalBackend) Start(opts ipn.Options) error {\n \t}\n \n \tvar auditLogShutdown func()\n-\t// Audit logging is only available if the client has set up a proper persistent\n-\t// store for the logs in sys.\n \tstore, ok := b.sys.AuditLogStore.GetOK()\n \tif !ok {\n-\t\tb.logf(\"auditlog: [unexpected] no persistent audit log storage configured.  using memory store.\")\n+\t\t// Use memory store by default if no explicit store is provided.\n \t\tstore = auditlog.NewLogStore(&memstore.Store{})\n \t}\n \n---\n\n\n---\n\nChoice D:\nfeature/relayserver/relayserver.go\n@@ -142,7 +142,7 @@ func handlePeerAPIRelayAllocateEndpoint(h ipnlocal.PeerAPIHandler, w http.Respon\n \n \thttpErrAndLog := func(message string, code int) {\n \t\thttp.Error(w, message, code)\n-\t\te.logf(\"peerapi: request from %v returned code %d: %s\", h.RemoteAddr(), code, message)\n+\t\th.Logf(\"relayserver: request from %v returned code %d: %s\", h.RemoteAddr(), code, message)\n \t}\n \n \tif !h.PeerCaps().HasCapability(tailcfg.PeerCapabilityRelay) {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThese were likely added after everything else was updated to use `tsd.NewSystem`, in a feature branch, and before it was merged back into main.\r\n\r\nUpdates #15160\n\n---\n\nChoice A:\nnet/netmon/interfaces_test.go\n@@ -13,7 +13,7 @@ import (\n )\n \n func TestGetState(t *testing.T) {\n-\tst, err := GetState()\n+\tst, err := getState()\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/netmon/netmon.go\n@@ -161,7 +161,7 @@ func (m *Monitor) InterfaceState() *State {\n }\n \n func (m *Monitor) interfaceStateUncached() (*State, error) {\n-\treturn GetState()\n+\treturn getState()\n }\n \n // SetTailscaleInterfaceName sets the name of the Tailscale interface. For\n---\nnet/netmon/state.go\n@@ -466,7 +466,7 @@ var getPAC func() string\n // It does not set the returned State.IsExpensive. The caller can populate that.\n //\n // Deprecated: use netmon.Monitor.InterfaceState instead.\n-func GetState() (*State, error) {\n+func getState() (*State, error) {\n \ts := &State{\n \t\tInterfaceIPs: make(map[string][]netip.Prefix),\n \t\tInterface:    make(map[string]Interface),\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -4968,7 +4968,7 @@ func (b *LocalBackend) authReconfig() {\n \t\treturn\n \t}\n \n-\toneCGNATRoute := shouldUseOneCGNATRoute(b.logf, b.sys.ControlKnobs(), version.OS())\n+\toneCGNATRoute := shouldUseOneCGNATRoute(b.logf, b.sys.NetMon.Get(), b.sys.ControlKnobs(), version.OS())\n \trcfg := b.routerConfig(cfg, prefs, oneCGNATRoute)\n \n \terr = b.e.Reconfig(cfg, rcfg, dcfg)\n@@ -4992,7 +4992,7 @@ func (b *LocalBackend) authReconfig() {\n //\n // The versionOS is a Tailscale-style version (\"iOS\", \"macOS\") and not\n // a runtime.GOOS.\n-func shouldUseOneCGNATRoute(logf logger.Logf, controlKnobs *controlknobs.Knobs, versionOS string) bool {\n+func shouldUseOneCGNATRoute(logf logger.Logf, mon *netmon.Monitor, controlKnobs *controlknobs.Knobs, versionOS string) bool {\n \tif controlKnobs != nil {\n \t\t// Explicit enabling or disabling always take precedence.\n \t\tif v, ok := controlKnobs.OneCGNAT.Load().Get(); ok {\n@@ -5007,7 +5007,7 @@ func shouldUseOneCGNATRoute(logf logger.Logf, controlKnobs *controlknobs.Knobs,\n \t// use fine-grained routes if another interfaces is also using the CGNAT\n \t// IP range.\n \tif versionOS == \"macOS\" {\n-\t\thasCGNATInterface, err := netmon.HasCGNATInterface()\n+\t\thasCGNATInterface, err := mon.HasCGNATInterface()\n \t\tif err != nil {\n \t\t\tlogf(\"shouldUseOneCGNATRoute: Could not determine if any interfaces use CGNAT: %v\", err)\n \t\t\treturn false\n---\nipn/ipnlocal/peerapi.go\n@@ -481,7 +481,7 @@ func (h *peerAPIHandler) handleServeInterfaces(w http.ResponseWriter, r *http.Re\n \t\tfmt.Fprintf(w, \"<h3>Could not get the default route: %s</h3>\\n\", html.EscapeString(err.Error()))\n \t}\n \n-\tif hasCGNATInterface, err := netmon.HasCGNATInterface(); hasCGNATInterface {\n+\tif hasCGNATInterface, err := h.ps.b.sys.NetMon.Get().HasCGNATInterface(); hasCGNATInterface {\n \t\tfmt.Fprintln(w, \"<p>There is another interface using the CGNAT range.</p>\")\n \t} else if err != nil {\n \t\tfmt.Fprintf(w, \"<p>Could not check for CGNAT interfaces: %s</p>\\n\", html.EscapeString(err.Error()))\n---\nnet/netmon/interfaces_test.go\n@@ -13,7 +13,7 @@ import (\n )\n \n func TestGetState(t *testing.T) {\n-\tst, err := getState()\n+\tst, err := getState(\"\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/netmon/netmon.go\n@@ -161,7 +161,7 @@ func (m *Monitor) InterfaceState() *State {\n }\n \n func (m *Monitor) interfaceStateUncached() (*State, error) {\n-\treturn getState()\n+\treturn getState(m.tsIfName)\n }\n \n // SetTailscaleInterfaceName sets the name of the Tailscale interface. For\n---\nnet/netmon/state.go\n@@ -461,21 +461,22 @@ func isTailscaleInterface(name string, ips []netip.Prefix) bool {\n // getPAC, if non-nil, returns the current PAC file URL.\n var getPAC func() string\n \n-// GetState returns the state of all the current machine's network interfaces.\n+// getState returns the state of all the current machine's network interfaces.\n //\n // It does not set the returned State.IsExpensive. The caller can populate that.\n //\n-// Deprecated: use netmon.Monitor.InterfaceState instead.\n-func getState() (*State, error) {\n+// optTSInterfaceName is the name of the Tailscale interface, if known.\n+func getState(optTSInterfaceName string) (*State, error) {\n \ts := &State{\n \t\tInterfaceIPs: make(map[string][]netip.Prefix),\n \t\tInterface:    make(map[string]Interface),\n \t}\n \tif err := ForeachInterface(func(ni Interface, pfxs []netip.Prefix) {\n+\t\tisTSInterfaceName := optTSInterfaceName != \"\" && ni.Name == optTSInterfaceName\n \t\tifUp := ni.IsUp()\n \t\ts.Interface[ni.Name] = ni\n \t\ts.InterfaceIPs[ni.Name] = append(s.InterfaceIPs[ni.Name], pfxs...)\n-\t\tif !ifUp || isTailscaleInterface(ni.Name, pfxs) {\n+\t\tif !ifUp || isTSInterfaceName || isTailscaleInterface(ni.Name, pfxs) {\n \t\t\treturn\n \t\t}\n \t\tfor _, pfx := range pfxs {\n@@ -755,11 +756,12 @@ func DefaultRoute() (DefaultRouteDetails, error) {\n \n // HasCGNATInterface reports whether there are any non-Tailscale interfaces that\n // use a CGNAT IP range.\n-func HasCGNATInterface() (bool, error) {\n+func (m *Monitor) HasCGNATInterface() (bool, error) {\n \thasCGNATInterface := false\n \tcgnatRange := tsaddr.CGNATRange()\n \terr := ForeachInterface(func(i Interface, pfxs []netip.Prefix) {\n-\t\tif hasCGNATInterface || !i.IsUp() || isTailscaleInterface(i.Name, pfxs) {\n+\t\tisTSInterfaceName := m.tsIfName != \"\" && i.Name == m.tsIfName\n+\t\tif hasCGNATInterface || !i.IsUp() || isTSInterfaceName || isTailscaleInterface(i.Name, pfxs) {\n \t\t\treturn\n \t\t}\n \t\tfor _, pfx := range pfxs {\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/extension_host_test.go\n@@ -284,7 +284,7 @@ func TestNewExtensionHost(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tt.Parallel()\n \t\t\tlogf := tstest.WhileTestRunningLogger(t)\n-\t\t\th, err := NewExtensionHost(logf, &tsd.System{}, &testBackend{}, tt.defs...)\n+\t\t\th, err := NewExtensionHost(logf, tsd.NewSystem(), &testBackend{}, tt.defs...)\n \t\t\tif gotErr := err != nil; gotErr != tt.wantErr {\n \t\t\t\tt.Errorf(\"NewExtensionHost: gotErr %v(%v); wantErr %v\", gotErr, err, tt.wantErr)\n \t\t\t}\n@@ -1118,7 +1118,7 @@ func newExtensionHostForTest[T ipnext.Extension](t *testing.T, b Backend, initia\n \t\t}\n \t\tdefs[i] = ipnext.DefinitionForTest(ext)\n \t}\n-\th, err := NewExtensionHost(logf, &tsd.System{}, b, defs...)\n+\th, err := NewExtensionHost(logf, tsd.NewSystem(), b, defs...)\n \tif err != nil {\n \t\tt.Fatalf(\"NewExtensionHost: %v\", err)\n \t}\n---\nipn/ipnlocal/state_test.go\n@@ -1397,7 +1397,7 @@ func newLocalBackendWithMockEngineAndControl(t *testing.T, enableLogging bool) (\n \tdialer := &tsdial.Dialer{Logf: logf}\n \tdialer.SetNetMon(netmon.NewStatic())\n \n-\tsys := &tsd.System{}\n+\tsys := tsd.NewSystem()\n \tsys.Set(dialer)\n \tsys.Set(dialer.NetMon())\n \n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local_test.go\n@@ -15,6 +15,7 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n+\t\"runtime\"\n \t\"slices\"\n \t\"strings\"\n \t\"sync\"\n@@ -2596,6 +2597,9 @@ func TestPreferencePolicyInfo(t *testing.T) {\n }\n \n func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n+\tif runtime.GOOS == \"darwin\" {\n+\t\tt.Skip(\"test known broken on macOS; see https://github.com/tailscale/tailscale/issues/15691\")\n+\t}\n \ttests := []struct {\n \t\tbefore, after  opt.Bool\n \t\tcontainer      opt.Bool\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThe `EventBus` in `net/portmapper.Config` is still optional and `Client.updates` can be `nil`.\r\n\r\nUpdates #15772\n\n---\n\nChoice A:\nnet/udprelay/server.go\n@@ -454,9 +454,10 @@ func (s *Server) packetReadLoop() {\n \n var ErrServerClosed = errors.New(\"server closed\")\n \n-// AllocateEndpoint allocates a ServerEndpoint for the provided pair of\n-// key.DiscoPublic's. It returns an error (ErrServerClosed) if the server has\n-// been closed.\n+// AllocateEndpoint allocates a [ServerEndpoint] for the provided pair of\n+// [key.DiscoPublic]'s. If an allocation already exists for discoA and discoB it\n+// is returned without modification/reallocation. AllocateEndpoint returns\n+// [ErrServerClosed] if the server has been closed.\n func (s *Server) AllocateEndpoint(discoA, discoB key.DiscoPublic) (ServerEndpoint, error) {\n \ts.mu.Lock()\n \tdefer s.mu.Unlock()\n@@ -471,36 +472,19 @@ func (s *Server) AllocateEndpoint(discoA, discoB key.DiscoPublic) (ServerEndpoin\n \tpair := newPairOfDiscoPubKeys(discoA, discoB)\n \te, ok := s.byDisco[pair]\n \tif ok {\n-\t\tif !e.isBound() {\n-\t\t\t// If the endpoint is not yet bound this is likely an allocation\n-\t\t\t// race between two clients on the same Server. Instead of\n-\t\t\t// re-allocating we return the existing allocation. We do not reset\n-\t\t\t// e.allocatedAt in case a client is \"stuck\" in an allocation\n-\t\t\t// loop and will not be able to complete a handshake, for whatever\n-\t\t\t// reason. Once the endpoint expires a new endpoint will be\n-\t\t\t// allocated. Clients can resolve duplicate ServerEndpoint details\n-\t\t\t// via ServerEndpoint.LamportID.\n-\t\t\t//\n-\t\t\t// TODO: consider ServerEndpoint.BindLifetime -= time.Now()-e.allocatedAt\n-\t\t\t// to give the client a more accurate picture of the bind window.\n-\t\t\t// Or, some threshold to trigger re-allocation if too much time has\n-\t\t\t// already passed since it was originally allocated.\n-\t\t\treturn ServerEndpoint{\n-\t\t\t\tServerDisco:         s.discoPublic,\n-\t\t\t\tAddrPorts:           s.addrPorts,\n-\t\t\t\tVNI:                 e.vni,\n-\t\t\t\tLamportID:           e.lamportID,\n-\t\t\t\tBindLifetime:        tstime.GoDuration{Duration: s.bindLifetime},\n-\t\t\t\tSteadyStateLifetime: tstime.GoDuration{Duration: s.steadyStateLifetime},\n-\t\t\t}, nil\n-\t\t}\n-\t\t// If an endpoint exists for the pair of key.DiscoPublic's, and is\n-\t\t// already bound, delete it. We will re-allocate a new endpoint. Chances\n-\t\t// are clients cannot make use of the existing, bound allocation if\n-\t\t// they are requesting a new one.\n-\t\tdelete(s.byDisco, pair)\n-\t\tdelete(s.byVNI, e.vni)\n-\t\ts.vniPool = append(s.vniPool, e.vni)\n+\t\t// Return the existing allocation. Clients can resolve duplicate\n+\t\t// [ServerEndpoint]'s via [ServerEndpoint.LamportID].\n+\t\t//\n+\t\t// TODO: consider ServerEndpoint.BindLifetime -= time.Now()-e.allocatedAt\n+\t\t// to give the client a more accurate picture of the bind window.\n+\t\treturn ServerEndpoint{\n+\t\t\tServerDisco:         s.discoPublic,\n+\t\t\tAddrPorts:           s.addrPorts,\n+\t\t\tVNI:                 e.vni,\n+\t\t\tLamportID:           e.lamportID,\n+\t\t\tBindLifetime:        tstime.GoDuration{Duration: s.bindLifetime},\n+\t\t\tSteadyStateLifetime: tstime.GoDuration{Duration: s.steadyStateLifetime},\n+\t\t}, nil\n \t}\n \n \tif len(s.vniPool) == 0 {\n---\nnet/udprelay/server_test.go\n@@ -174,8 +174,7 @@ func TestServer(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \n-\t// We expect the same endpoint details as the 3-way bind handshake has not\n-\t// yet been completed for both relay client parties.\n+\t// We expect the same endpoint details pre-handshake.\n \tif diff := cmp.Diff(dupEndpoint, endpoint, cmpopts.EquateComparable(netip.AddrPort{}, key.DiscoPublic{})); diff != \"\" {\n \t\tt.Fatalf(\"wrong dupEndpoint (-got +want)\\n%s\", diff)\n \t}\n@@ -191,6 +190,15 @@ func TestServer(t *testing.T) {\n \ttcA.handshake(t)\n \ttcB.handshake(t)\n \n+\tdupEndpoint, err = server.AllocateEndpoint(discoA.Public(), discoB.Public())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// We expect the same endpoint details post-handshake.\n+\tif diff := cmp.Diff(dupEndpoint, endpoint, cmpopts.EquateComparable(netip.AddrPort{}, key.DiscoPublic{})); diff != \"\" {\n+\t\tt.Fatalf(\"wrong dupEndpoint (-got +want)\\n%s\", diff)\n+\t}\n+\n \ttxToB := []byte{1, 2, 3}\n \ttcA.writeDataPkt(t, txToB)\n \trxFromA := tcB.readDataPkt(t)\n---\n\n\n---\n\nChoice B:\ntsnet/tsnet.go\n@@ -1101,13 +1101,33 @@ type FunnelOption interface {\n \tfunnelOption()\n }\n \n-type funnelOnly int\n+type funnelOnly struct{}\n \n func (funnelOnly) funnelOption() {}\n \n // FunnelOnly configures the listener to only respond to connections from Tailscale Funnel.\n // The local tailnet will not be able to connect to the listener.\n-func FunnelOnly() FunnelOption { return funnelOnly(1) }\n+func FunnelOnly() FunnelOption { return funnelOnly{} }\n+\n+type funnelTLSConfig struct{ conf *tls.Config }\n+\n+func (f funnelTLSConfig) funnelOption() {}\n+\n+// FunnelTLSConfig configures the TLS configuration for [Server.ListenFunnel]\n+//\n+// This is rarely needed but can permit requiring client certificates, specific\n+// ciphers suites, etc.\n+//\n+// The provided conf should at least be able to get a certificate, setting\n+// GetCertificate, Certificates or GetConfigForClient appropriately.\n+// The most common configuration is to set GetCertificate to\n+// Server.LocalClient's GetCertificate method.\n+//\n+// Unless [FunnelOnly] is also used, the configuration is also used for\n+// in-tailnet connections that don't arrive over Funnel.\n+func FunnelTLSConfig(conf *tls.Config) FunnelOption {\n+\treturn funnelTLSConfig{conf: conf}\n+}\n \n // ListenFunnel announces on the public internet using Tailscale Funnel.\n //\n@@ -1140,6 +1160,26 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t\treturn nil, err\n \t}\n \n+\t// Process, validate opts.\n+\tlnOn := listenOnBoth\n+\tvar tlsConfig *tls.Config\n+\tfor _, opt := range opts {\n+\t\tswitch v := opt.(type) {\n+\t\tcase funnelTLSConfig:\n+\t\t\tif v.conf == nil {\n+\t\t\t\treturn nil, errors.New(\"invalid nil FunnelTLSConfig\")\n+\t\t\t}\n+\t\t\ttlsConfig = v.conf\n+\t\tcase funnelOnly:\n+\t\t\tlnOn = listenOnFunnel\n+\t\tdefault:\n+\t\t\treturn nil, fmt.Errorf(\"unknown opts FunnelOption type %T\", v)\n+\t\t}\n+\t}\n+\tif tlsConfig == nil {\n+\t\ttlsConfig = &tls.Config{GetCertificate: s.getCert}\n+\t}\n+\n \tctx := context.Background()\n \tst, err := s.Up(ctx)\n \tif err != nil {\n@@ -1177,19 +1217,11 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t}\n \n \t// Start a funnel listener.\n-\tlnOn := listenOnBoth\n-\tfor _, opt := range opts {\n-\t\tif _, ok := opt.(funnelOnly); ok {\n-\t\t\tlnOn = listenOnFunnel\n-\t\t}\n-\t}\n \tln, err := s.listen(network, addr, lnOn)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn tls.NewListener(ln, &tls.Config{\n-\t\tGetCertificate: s.getCert,\n-\t}), nil\n+\treturn tls.NewListener(ln, tlsConfig), nil\n }\n \n type listenOn string\n---\n\n\n---\n\nChoice C:\nnet/portmapper/portmapper.go\n@@ -508,11 +508,13 @@ func (c *Client) createMapping() {\n \t\t}\n \t\treturn\n \t}\n-\tc.updates.Publish(Mapping{\n-\t\tExternal:  mapping.External(),\n-\t\tType:      mapping.MappingType(),\n-\t\tGoodUntil: mapping.GoodUntil(),\n-\t})\n+\tif c.updates != nil {\n+\t\tc.updates.Publish(Mapping{\n+\t\t\tExternal:  mapping.External(),\n+\t\t\tType:      mapping.MappingType(),\n+\t\t\tGoodUntil: mapping.GoodUntil(),\n+\t\t})\n+\t}\n \tif c.onChange != nil {\n \t\tgo c.onChange()\n \t}\n---\n\n\n---\n\nChoice D:\nnet/netmon/state.go\n@@ -27,8 +27,9 @@ import (\n // same interface and subnet.\n var forceAllIPv6Endpoints = envknob.RegisterBool(\"TS_DEBUG_FORCE_ALL_IPV6_ENDPOINTS\")\n \n-// set a debug knob to exclude interfaces from the list of interfaces\n-var excludedInterfaces = envknob.RegisterString(\"TS_DEBUG_EXCLUDED_INTERFACES\")\n+// suppressInterfaces is a debug knob containing a list of interface names that should not be advertised as endpoints. \n+// Traffic may still flow over these interfaces if system routing makes the decision to do so.\n+var excludeInterfaces = envknob.RegisterString(\"TS_DEBUG_EXCLUDE_INTERFACES\")\n \n // LoginEndpointForProxyDetermination is the URL used for testing\n // which HTTP proxy the system should use.\n@@ -54,7 +55,7 @@ func isExcludedInterface(nif *net.Interface) bool {\n \t\treturn false\n \t}\n \n-\tremain := excludedInterfaces()\n+\tremain := excludeInterfaces()\n \tfor remain != \"\" {\n \t\tvar candidate string\n \t\tcandidate, remain, _ = strings.Cut(remain, \",\")\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis was recently added, use it to be consistent.\r\n\r\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\ncmd/tailscale/cli/set.go\n@@ -11,6 +11,7 @@ import (\n \t\"net/netip\"\n \t\"os/exec\"\n \t\"runtime\"\n+\t\"strconv\"\n \t\"strings\"\n \n \t\"github.com/peterbourgon/ff/v3/ffcli\"\n@@ -22,6 +23,7 @@ import (\n \t\"tailscale.com/net/tsaddr\"\n \t\"tailscale.com/safesocket\"\n \t\"tailscale.com/types/opt\"\n+\t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/version\"\n )\n@@ -62,6 +64,7 @@ type setArgsT struct {\n \tsnat                   bool\n \tstatefulFiltering      bool\n \tnetfilterMode          string\n+\trelayServerPort        string\n }\n \n func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n@@ -82,6 +85,7 @@ func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n \tsetf.BoolVar(&setArgs.updateApply, \"auto-update\", false, \"automatically update to the latest available version\")\n \tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, hidden+\"allow management plane to gather device posture information\")\n \tsetf.BoolVar(&setArgs.runWebClient, \"webclient\", false, \"expose the web interface for managing this node over Tailscale at port 5252\")\n+\tsetf.StringVar(&setArgs.relayServerPort, \"relay-server-port\", \"\", hidden+\"UDP port number (0 will pick a random unused port) for the relay server to bind to, on all interfaces, or empty string to disable relay server functionality\")\n \n \tffcomplete.Flag(setf, \"exit-node\", func(args []string) ([]string, ffcomplete.ShellCompDirective, error) {\n \t\tst, err := localClient.Status(context.Background())\n@@ -233,6 +237,15 @@ func runSet(ctx context.Context, args []string) (retErr error) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tif setArgs.relayServerPort != \"\" {\n+\t\tuport, err := strconv.ParseUint(setArgs.relayServerPort, 10, 16)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"failed to set relay server port: %v\", err)\n+\t\t}\n+\t\tmaskedPrefs.Prefs.RelayServerPort = ptr.To(int(uport))\n+\t}\n+\n \tcheckPrefs := curPrefs.Clone()\n \tcheckPrefs.ApplyEdits(maskedPrefs)\n \tif err := localClient.CheckPrefs(ctx, checkPrefs); err != nil {\n---\ncmd/tailscale/cli/up.go\n@@ -773,6 +773,7 @@ func init() {\n \taddPrefFlagMapping(\"auto-update\", \"AutoUpdate.Apply\")\n \taddPrefFlagMapping(\"advertise-connector\", \"AppConnector\")\n \taddPrefFlagMapping(\"posture-checking\", \"PostureChecking\")\n+\taddPrefFlagMapping(\"relay-server-port\", \"RelayServerPort\")\n }\n \n func addPrefFlagMapping(flagName string, prefNames ...string) {\n---\nipn/ipn_clone.go\n@@ -61,6 +61,9 @@ func (src *Prefs) Clone() *Prefs {\n \t\t\t}\n \t\t}\n \t}\n+\tif dst.RelayServerPort != nil {\n+\t\tdst.RelayServerPort = ptr.To(*src.RelayServerPort)\n+\t}\n \tdst.Persist = src.Persist.Clone()\n \treturn dst\n }\n@@ -96,6 +99,7 @@ var _PrefsCloneNeedsRegeneration = Prefs(struct {\n \tPostureChecking        bool\n \tNetfilterKind          string\n \tDriveShares            []*drive.Share\n+\tRelayServerPort        *int\n \tAllowSingleHosts       marshalAsTrueInJSON\n \tPersist                *persist.Persist\n }{})\n---\nipn/ipn_view.go\n@@ -166,6 +166,10 @@ func (v PrefsView) NetfilterKind() string                 { return v.\u0436.Netfilte\n func (v PrefsView) DriveShares() views.SliceView[*drive.Share, drive.ShareView] {\n \treturn views.SliceOfViews[*drive.Share, drive.ShareView](v.\u0436.DriveShares)\n }\n+func (v PrefsView) RelayServerPort() views.ValuePointer[int] {\n+\treturn views.ValuePointerOf(v.\u0436.RelayServerPort)\n+}\n+\n func (v PrefsView) AllowSingleHosts() marshalAsTrueInJSON { return v.\u0436.AllowSingleHosts }\n func (v PrefsView) Persist() persist.PersistView          { return v.\u0436.Persist.View() }\n \n@@ -200,6 +204,7 @@ var _PrefsViewNeedsRegeneration = Prefs(struct {\n \tPostureChecking        bool\n \tNetfilterKind          string\n \tDriveShares            []*drive.Share\n+\tRelayServerPort        *int\n \tAllowSingleHosts       marshalAsTrueInJSON\n \tPersist                *persist.Persist\n }{})\n---\nipn/prefs.go\n@@ -246,6 +246,14 @@ type Prefs struct {\n \t// by name.\n \tDriveShares []*drive.Share\n \n+\t// RelayServerPort is the UDP port number for the relay server to bind to,\n+\t// on all interfaces. A non-nil zero value signifies a random unused port\n+\t// should be used. A nil value signifies relay server functionality\n+\t// should be disabled. This field is currently experimental, and therefore\n+\t// no guarantees are made about its current naming and functionality when\n+\t// non-nil/enabled.\n+\tRelayServerPort *int `json:\",omitempty\"`\n+\n \t// AllowSingleHosts was a legacy field that was always true\n \t// for the past 4.5 years. It controlled whether Tailscale\n \t// peers got /32 or /127 routes for each other.\n@@ -337,6 +345,7 @@ type MaskedPrefs struct {\n \tPostureCheckingSet        bool                `json:\",omitempty\"`\n \tNetfilterKindSet          bool                `json:\",omitempty\"`\n \tDriveSharesSet            bool                `json:\",omitempty\"`\n+\tRelayServerPortSet        bool                `json:\",omitempty\"`\n }\n \n // SetsInternal reports whether mp has any of the Internal*Set field bools set\n@@ -555,6 +564,9 @@ func (p *Prefs) pretty(goos string) string {\n \t}\n \tsb.WriteString(p.AutoUpdate.Pretty())\n \tsb.WriteString(p.AppConnector.Pretty())\n+\tif p.RelayServerPort != nil {\n+\t\tfmt.Fprintf(&sb, \"relayServerPort=%d \", *p.RelayServerPort)\n+\t}\n \tif p.Persist != nil {\n \t\tsb.WriteString(p.Persist.Pretty())\n \t} else {\n@@ -616,7 +628,8 @@ func (p *Prefs) Equals(p2 *Prefs) bool {\n \t\tp.AppConnector == p2.AppConnector &&\n \t\tp.PostureChecking == p2.PostureChecking &&\n \t\tslices.EqualFunc(p.DriveShares, p2.DriveShares, drive.SharesEqual) &&\n-\t\tp.NetfilterKind == p2.NetfilterKind\n+\t\tp.NetfilterKind == p2.NetfilterKind &&\n+\t\tcompareIntPtrs(p.RelayServerPort, p2.RelayServerPort)\n }\n \n func (au AutoUpdatePrefs) Pretty() string {\n@@ -636,6 +649,16 @@ func (ap AppConnectorPrefs) Pretty() string {\n \treturn \"\"\n }\n \n+func compareIntPtrs(a, b *int) bool {\n+\tif (a == nil) != (b == nil) {\n+\t\treturn false\n+\t}\n+\tif a == nil {\n+\t\treturn true\n+\t}\n+\treturn *a == *b\n+}\n+\n // NewPrefs returns the default preferences to use.\n func NewPrefs() *Prefs {\n \t// Provide default values for options which might be missing\n---\nipn/prefs_test.go\n@@ -65,6 +65,7 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\"PostureChecking\",\n \t\t\"NetfilterKind\",\n \t\t\"DriveShares\",\n+\t\t\"RelayServerPort\",\n \t\t\"AllowSingleHosts\",\n \t\t\"Persist\",\n \t}\n@@ -73,6 +74,9 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\thave, prefsHandles)\n \t}\n \n+\trelayServerPort := func(port int) *int {\n+\t\treturn &port\n+\t}\n \tnets := func(strs ...string) (ns []netip.Prefix) {\n \t\tfor _, s := range strs {\n \t\t\tn, err := netip.ParsePrefix(s)\n@@ -341,6 +345,16 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\t&Prefs{AdvertiseServices: []string{\"svc:tux\", \"svc:amelie\"}},\n \t\t\tfalse,\n \t\t},\n+\t\t{\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(0)},\n+\t\t\t&Prefs{RelayServerPort: nil},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(0)},\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(1)},\n+\t\t\tfalse,\n+\t\t},\n \t}\n \tfor i, tt := range tests {\n \t\tgot := tt.a.Equals(tt.b)\n---\n\n\n---\n\nChoice B:\ncmd/derper/cert_test.go\n@@ -140,6 +140,15 @@ func TestPinnedCertRawIP(t *testing.T) {\n \tvar hs http.Server\n \ths.Handler = mux\n \ths.TLSConfig = cp.TLSConfig()\n+\tgetCert := hs.TLSConfig.GetCertificate\n+\ths.TLSConfig.GetCertificate=func(hi *tls.ClientHelloInfo) (*tls.Certificate, error) {\n+\t\tcert, err := getCert(hi)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tcert.Certificate = append(cert.Certificate, ds.MetaCert())\n+\t\treturn cert, nil\n+\t}\n \tgo hs.ServeTLS(ln, \"\", \"\")\n \n \tlnPort := ln.Addr().(*net.TCPAddr).Port\n---\nnet/tlsdial/tlsdial.go\n@@ -263,7 +263,7 @@ func SetConfigExpectedCertHash(c *tls.Config, wantFullCertSHA256Hex string) {\n \t\tif len(rawCerts) == 0 {\n \t\t\treturn errors.New(\"no certs presented\")\n \t\t}\n-\t\tif len(rawCerts) > 1 {\n+\t\tif len(rawCerts) > 2 {\n \t\t\treturn errors.New(\"unexpected multiple certs presented\")\n \t\t}\n \t\tif fmt.Sprintf(\"%02x\", sha256.Sum256(rawCerts[0])) != wantFullCertSHA256Hex {\n---\n\n\n---\n\nChoice C:\nhostinfo/hostinfo.go\n@@ -43,7 +43,7 @@ func RegisterHostinfoNewHook(f func(*tailcfg.Hostinfo)) {\n \n // New returns a partially populated Hostinfo for the current host.\n func New() *tailcfg.Hostinfo {\n-\thostname, _ := os.Hostname()\n+\thostname, _ := Hostname()\n \thostname = dnsname.FirstLabel(hostname)\n \thi := &tailcfg.Hostinfo{\n \t\tIPNVersion:      version.Long(),\n@@ -509,3 +509,21 @@ func IsInVM86() bool {\n \t\treturn New().DeviceModel == copyV86DeviceModel\n \t})\n }\n+\n+type hostnameQuery func() (string, error)\n+\n+var hostnameFn atomic.Value // of func() (string, error)\n+\n+// SetHostNameFn sets a custom function for querying the system hostname.\n+func SetHostnameFn(fn hostnameQuery) {\n+\thostnameFn.Store(fn)\n+}\n+\n+// Hostname returns the system hostname using the function\n+// set by SetHostNameFn.  We will fallback to os.Hostname.\n+func Hostname() (string, error) {\n+\tif fn, ok := hostnameFn.Load().(hostnameQuery); ok && fn != nil {\n+\t\treturn fn()\n+\t}\n+\treturn os.Hostname()\n+}\n---\nhostinfo/hostinfo_test.go\n@@ -5,6 +5,7 @@ package hostinfo\n \n import (\n \t\"encoding/json\"\n+\t\"os\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -49,3 +50,31 @@ func TestEtcAptSourceFileIsDisabled(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestCustomHostnameFunc(t *testing.T) {\n+\twant := \"custom-hostname\"\n+\tSetHostnameFn(func() (string, error) {\n+\t\treturn want, nil\n+\t})\n+\n+\tgot, err := Hostname()\n+\tif err != nil {\n+\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+\n+\tif got != want {\n+\t\tt.Errorf(\"got %q, want %q\", got, want)\n+\t}\n+\n+\tSetHostnameFn(os.Hostname)\n+\tgot, err = Hostname()\n+\twant, _ = os.Hostname()\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+\tif got != want {\n+\t\tt.Errorf(\"got %q, want %q\", got, want)\n+\t}\n+\n+}\n---\nipn/ipnlocal/local.go\n@@ -1245,7 +1245,7 @@ func (b *LocalBackend) UpdateStatus(sb *ipnstate.StatusBuilder) {\n \t\t\t}\n \n \t\t} else {\n-\t\t\tss.HostName, _ = os.Hostname()\n+\t\t\tss.HostName, _ = hostinfo.Hostname()\n \t\t}\n \t\tfor _, pln := range b.peerAPIListeners {\n \t\t\tss.PeerAPIURL = append(ss.PeerAPIURL, pln.urlStr)\n---\n\n\n---\n\nChoice D:\nfeature/relayserver/relayserver.go\n@@ -142,7 +142,7 @@ func handlePeerAPIRelayAllocateEndpoint(h ipnlocal.PeerAPIHandler, w http.Respon\n \n \thttpErrAndLog := func(message string, code int) {\n \t\thttp.Error(w, message, code)\n-\t\te.logf(\"peerapi: request from %v returned code %d: %s\", h.RemoteAddr(), code, message)\n+\t\th.Logf(\"relayserver: request from %v returned code %d: %s\", h.RemoteAddr(), code, message)\n \t}\n \n \tif !h.PeerCaps().HasCapability(tailcfg.PeerCapabilityRelay) {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBoth are populated from the current netmap's `MagicDNSSuffix`. But building a full `ipnstate.Status` (with peers!) is expensive and unnecessary.\r\n\r\nUpdates #cleanup\n\n---\n\nChoice A:\nnet/routetable/routetable_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package routetable\n \n---\nnet/routetable/routetable_other.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux && !darwin && !freebsd\n+//go:build android || (!linux && !darwin && !freebsd)\n \n package routetable\n \n---\nnet/tstun/linkattrs_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android\n+\n package tstun\n \n import (\n---\nnet/tstun/linkattrs_notlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux || android\n \n package tstun\n \n---\nwgengine/router/router_android.go\n@@ -0,0 +1,29 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build android\n+\n+package router\n+\n+import (\n+\t\"github.com/tailscale/wireguard-go/tun\"\n+\t\"tailscale.com/health\"\n+\t\"tailscale.com/net/netmon\"\n+\t\"tailscale.com/types/logger\"\n+)\n+\n+func newUserspaceRouter(logf logger.Logf, tunDev tun.Device, netMon *netmon.Monitor, health *health.Tracker) (Router, error) {\n+\t// Note, this codepath is _not_ used when building the android app\n+\t// from github.com/tailscale/tailscale-android. The android app\n+\t// constructs its own wgengine with a custom router implementation\n+\t// that plugs into Android networking APIs.\n+\t//\n+\t// In practice, the only place this fake router gets used is when\n+\t// you build a tsnet app for android, in which case we don't want\n+\t// to touch the OS network stack and a no-op router is correct.\n+\treturn NewFake(logf), nil\n+}\n+\n+func cleanUp(logf logger.Logf, interfaceName string) {\n+\t// Nothing to do here.\n+}\n---\nwgengine/router/router_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android\n+\n package router\n \n import (\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/serve.go\n@@ -632,7 +632,7 @@ func (b *LocalBackend) getServeHandler(r *http.Request) (_ ipn.HTTPHandlerView,\n \n \thostname := r.Host\n \tif r.TLS == nil {\n-\t\ttcd := \".\" + b.Status().CurrentTailnet.MagicDNSSuffix\n+\t\ttcd := \".\" + b.CurrentProfile().NetworkProfile().MagicDNSName\n \t\tif host, _, err := net.SplitHostPort(hostname); err == nil {\n \t\t\thostname = host\n \t\t}\n---\n\n\n---\n\nChoice C:\ntsnet/tsnet_test.go\n@@ -120,6 +120,7 @@ func startControl(t *testing.T) (controlURL string, control *testcontrol.Server)\n \t\t\tProxied: true,\n \t\t},\n \t\tMagicDNSDomain: \"tail-scale.ts.net\",\n+\t\tLogf:           t.Logf,\n \t}\n \tcontrol.HTTPTestServer = httptest.NewUnstartedServer(control)\n \tcontrol.HTTPTestServer.Start()\n@@ -221,7 +222,7 @@ func startServer(t *testing.T, ctx context.Context, controlURL, hostname string)\n \t\tgetCertForTesting: testCertRoot.getCert,\n \t}\n \tif *verboseNodes {\n-\t\ts.Logf = log.Printf\n+\t\ts.Logf = t.Logf\n \t}\n \tt.Cleanup(func() { s.Close() })\n \n---\n\n\n---\n\nChoice D:\ncmd/derper/cert_test.go\n@@ -140,6 +140,15 @@ func TestPinnedCertRawIP(t *testing.T) {\n \tvar hs http.Server\n \ths.Handler = mux\n \ths.TLSConfig = cp.TLSConfig()\n+\tgetCert := hs.TLSConfig.GetCertificate\n+\ths.TLSConfig.GetCertificate=func(hi *tls.ClientHelloInfo) (*tls.Certificate, error) {\n+\t\tcert, err := getCert(hi)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tcert.Certificate = append(cert.Certificate, ds.MetaCert())\n+\t\treturn cert, nil\n+\t}\n \tgo hs.ServeTLS(ln, \"\", \"\")\n \n \tlnPort := ln.Addr().(*net.TCPAddr).Port\n---\nnet/tlsdial/tlsdial.go\n@@ -263,7 +263,7 @@ func SetConfigExpectedCertHash(c *tls.Config, wantFullCertSHA256Hex string) {\n \t\tif len(rawCerts) == 0 {\n \t\t\treturn errors.New(\"no certs presented\")\n \t\t}\n-\t\tif len(rawCerts) > 1 {\n+\t\tif len(rawCerts) > 2 {\n \t\t\treturn errors.New(\"unexpected multiple certs presented\")\n \t\t}\n \t\tif fmt.Sprintf(\"%02x\", sha256.Sum256(rawCerts[0])) != wantFullCertSHA256Hex {\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThe encoding/json/v2 effort may end up changing\r\nthe default represention of time.Duration in JSON. See https://go.dev/issue/71631\r\n\r\nThe GoDuration type allows us to explicitly use\r\nthe time.Duration.String representation regardless of whether we serialize with v1 or v2 of encoding/json.\r\n\r\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\n.github/workflows/test.yml\n@@ -79,7 +79,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -157,7 +157,7 @@ jobs:\n         cache: false\n \n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -263,7 +263,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -333,7 +333,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -386,7 +386,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n---\n\n\n---\n\nChoice B:\ntstime/tstime.go\n@@ -6,6 +6,7 @@ package tstime\n \n import (\n \t\"context\"\n+\t\"encoding\"\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n@@ -183,3 +184,40 @@ func (StdClock) AfterFunc(d time.Duration, f func()) TimerController {\n func (StdClock) Since(t time.Time) time.Duration {\n \treturn time.Since(t)\n }\n+\n+// GoDuration is a [time.Duration] but JSON serializes with [time.Duration.String].\n+//\n+// Note that this format is specific to Go and non-standard,\n+// but excels in being most humanly readable compared to alternatives.\n+// The wider industry still lacks consensus for the representation\n+// of a time duration in humanly-readable text.\n+// See https://go.dev/issue/71631 for more discussion.\n+//\n+// Regardless of how the industry evolves into the future,\n+// this type explicitly uses the Go format.\n+type GoDuration struct{ time.Duration }\n+\n+var (\n+\t_ encoding.TextAppender    = (*GoDuration)(nil)\n+\t_ encoding.TextMarshaler   = (*GoDuration)(nil)\n+\t_ encoding.TextUnmarshaler = (*GoDuration)(nil)\n+)\n+\n+func (d GoDuration) AppendText(b []byte) ([]byte, error) {\n+\t// The String method is inlineable (see https://go.dev/cl/520602),\n+\t// so this may not allocate since the string does not escape.\n+\treturn append(b, d.String()...), nil\n+}\n+\n+func (d GoDuration) MarshalText() ([]byte, error) {\n+\treturn []byte(d.String()), nil\n+}\n+\n+func (d *GoDuration) UnmarshalText(b []byte) error {\n+\td2, err := time.ParseDuration(string(b))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\td.Duration = d2\n+\treturn nil\n+}\n---\ntstime/tstime_test.go\n@@ -4,8 +4,11 @@\n package tstime\n \n import (\n+\t\"encoding/json\"\n \t\"testing\"\n \t\"time\"\n+\n+\t\"tailscale.com/util/must\"\n )\n \n func TestParseDuration(t *testing.T) {\n@@ -34,3 +37,17 @@ func TestParseDuration(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestGoDuration(t *testing.T) {\n+\twantDur := GoDuration{time.Hour + time.Minute + time.Second + time.Millisecond + time.Microsecond + time.Nanosecond}\n+\tgotJSON := string(must.Get(json.Marshal(wantDur)))\n+\twantJSON := `\"1h1m1.001001001s\"`\n+\tif gotJSON != wantJSON {\n+\t\tt.Errorf(\"json.Marshal(%v) = %s, want %s\", wantDur, gotJSON, wantJSON)\n+\t}\n+\tvar gotDur GoDuration\n+\tmust.Do(json.Unmarshal([]byte(wantJSON), &gotDur))\n+\tif gotDur != wantDur {\n+\t\tt.Errorf(\"json.Unmarshal(%s) = %v, want %v\", wantJSON, gotDur, wantDur)\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/init@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/autobuild@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/analyze@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n---\n\n\n---\n\nChoice D:\nnet/netmon/interfaces_test.go\n@@ -13,7 +13,7 @@ import (\n )\n \n func TestGetState(t *testing.T) {\n-\tst, err := GetState()\n+\tst, err := getState()\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/netmon/netmon.go\n@@ -161,7 +161,7 @@ func (m *Monitor) InterfaceState() *State {\n }\n \n func (m *Monitor) interfaceStateUncached() (*State, error) {\n-\treturn GetState()\n+\treturn getState()\n }\n \n // SetTailscaleInterfaceName sets the name of the Tailscale interface. For\n---\nnet/netmon/state.go\n@@ -466,7 +466,7 @@ var getPAC func() string\n // It does not set the returned State.IsExpensive. The caller can populate that.\n //\n // Deprecated: use netmon.Monitor.InterfaceState instead.\n-func GetState() (*State, error) {\n+func getState() (*State, error) {\n \ts := &State{\n \t\tInterfaceIPs: make(map[string][]netip.Prefix),\n \t\tInterface:    make(map[string]Interface),\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nServerEndpoint contains fields that naturally encode as JSON numbers, e.g. uint64 and time.Duration types. These should never be expressed as floats, and in some cases (VNI) they have specific bits limits.\r\n\r\nServerEndpoint is currently experimental, therefore breaking changes are tolerable.\r\n\r\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\ntstest/integration/integration.go\n@@ -684,7 +684,6 @@ func (n *TestNode) StartDaemonAsIPNGOOS(ipnGOOS string) *Daemon {\n \t\tcmd.Args = append(cmd.Args, \"--config=\"+n.configFile)\n \t}\n \tcmd.Env = append(os.Environ(),\n-\t\t\"TS_CONTROL_IS_PLAINTEXT_HTTP=1\",\n \t\t\"TS_DEBUG_PERMIT_HTTP_C2N=1\",\n \t\t\"TS_LOG_TARGET=\"+n.env.LogCatcherServer.URL,\n \t\t\"HTTP_PROXY=\"+n.env.TrafficTrapServer.URL,\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local_test.go\n@@ -15,7 +15,6 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n-\t\"runtime\"\n \t\"slices\"\n \t\"strings\"\n \t\"sync\"\n@@ -2597,9 +2596,6 @@ func TestPreferencePolicyInfo(t *testing.T) {\n }\n \n func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n-\tif runtime.GOOS == \"darwin\" {\n-\t\tt.Skip(\"test known broken on macOS; see https://github.com/tailscale/tailscale/issues/15691\")\n-\t}\n \ttests := []struct {\n \t\tbefore, after  opt.Bool\n \t\tcontainer      opt.Bool\n@@ -2669,7 +2665,7 @@ func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n \t\t\t// On platforms that don't support auto-update we can never\n \t\t\t// transition to auto-updates being enabled. The value should\n \t\t\t// remain unchanged after onTailnetDefaultAutoUpdate.\n-\t\t\tif !clientupdate.CanAutoUpdate() && want.EqualBool(true) {\n+\t\t\tif !clientupdate.CanAutoUpdate() {\n \t\t\t\twant = tt.before\n \t\t\t}\n \t\t\tif got := b.pm.CurrentPrefs().AutoUpdate().Apply; got != want {\n---\n\n\n---\n\nChoice C:\ntool/gocross/gocross.go\n@@ -15,9 +15,9 @@ import (\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"runtime/debug\"\n \n \t\"tailscale.com/atomicfile\"\n-\t\"tailscale.com/version\"\n )\n \n func main() {\n@@ -28,8 +28,19 @@ func main() {\n \t\t// any time.\n \t\tswitch os.Args[1] {\n \t\tcase \"gocross-version\":\n-\t\t\tfmt.Println(version.GetMeta().GitCommit)\n-\t\t\tos.Exit(0)\n+\t\t\tbi, ok := debug.ReadBuildInfo()\n+\t\t\tif !ok {\n+\t\t\t\tfmt.Fprintln(os.Stderr, \"failed getting build info\")\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\tfor _, s := range bi.Settings {\n+\t\t\t\tif s.Key == \"vcs.revision\" {\n+\t\t\t\t\tfmt.Println(s.Value)\n+\t\t\t\t\tos.Exit(0)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfmt.Fprintln(os.Stderr, \"did not find vcs.revision in build info\")\n+\t\t\tos.Exit(1)\n \t\tcase \"is-gocross\":\n \t\t\t// This subcommand exits with an error code when called on a\n \t\t\t// regular go binary, so it can be used to detect when `go` is\n@@ -85,9 +96,9 @@ func main() {\n \t\tpath := filepath.Join(toolchain, \"bin\") + string(os.PathListSeparator) + os.Getenv(\"PATH\")\n \t\tenv.Set(\"PATH\", path)\n \n-\t\tdebug(\"Input: %s\\n\", formatArgv(os.Args))\n-\t\tdebug(\"Command: %s\\n\", formatArgv(newArgv))\n-\t\tdebug(\"Set the following flags/envvars:\\n%s\\n\", env.Diff())\n+\t\tdebugf(\"Input: %s\\n\", formatArgv(os.Args))\n+\t\tdebugf(\"Command: %s\\n\", formatArgv(newArgv))\n+\t\tdebugf(\"Set the following flags/envvars:\\n%s\\n\", env.Diff())\n \n \t\targs = newArgv\n \t\tif err := env.Apply(); err != nil {\n@@ -103,7 +114,7 @@ func main() {\n //go:embed gocross-wrapper.sh\n var wrapperScript []byte\n \n-func debug(format string, args ...any) {\n+func debugf(format string, args ...any) {\n \tdebug := os.Getenv(\"GOCROSS_DEBUG\")\n \tvar (\n \t\tout *os.File\n---\ntool/gocross/gocross_test.go\n@@ -0,0 +1,19 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package main\n+\n+import (\n+\t\"testing\"\n+\n+\t\"tailscale.com/tstest/deptest\"\n+)\n+\n+func TestDeps(t *testing.T) {\n+\tdeptest.DepChecker{\n+\t\tBadDeps: map[string]string{\n+\t\t\t\"tailscale.com/tailcfg\": \"circular dependency via go generate\",\n+\t\t\t\"tailscale.com/version\": \"circular dependency via go generate\",\n+\t\t},\n+\t}.Check(t)\n+}\n---\n\n\n---\n\nChoice D:\nnet/udprelay/server.go\n@@ -21,6 +21,7 @@ import (\n \t\"go4.org/mem\"\n \t\"tailscale.com/disco\"\n \t\"tailscale.com/net/packet\"\n+\t\"tailscale.com/tstime\"\n \t\"tailscale.com/types/key\"\n )\n \n@@ -114,12 +115,12 @@ type ServerEndpoint struct {\n \t// BindLifetime is amount of time post-allocation the Server will consider\n \t// the endpoint active while it has yet to be bound via 3-way bind handshake\n \t// from both client parties.\n-\tBindLifetime time.Duration\n+\tBindLifetime tstime.GoDuration\n \n \t// SteadyStateLifetime is the amount of time post 3-way bind handshake from\n \t// both client parties the Server will consider the endpoint active lacking\n \t// bidirectional data flow.\n-\tSteadyStateLifetime time.Duration\n+\tSteadyStateLifetime tstime.GoDuration\n }\n \n // serverEndpoint contains Server-internal ServerEndpoint state. serverEndpoint\n@@ -489,8 +490,8 @@ func (s *Server) AllocateEndpoint(discoA, discoB key.DiscoPublic) (ServerEndpoin\n \t\t\t\tAddrPorts:           s.addrPorts,\n \t\t\t\tVNI:                 e.vni,\n \t\t\t\tLamportID:           e.lamportID,\n-\t\t\t\tBindLifetime:        s.bindLifetime,\n-\t\t\t\tSteadyStateLifetime: s.steadyStateLifetime,\n+\t\t\t\tBindLifetime:        tstime.GoDuration{Duration: s.bindLifetime},\n+\t\t\t\tSteadyStateLifetime: tstime.GoDuration{Duration: s.steadyStateLifetime},\n \t\t\t}, nil\n \t\t}\n \t\t// If an endpoint exists for the pair of key.DiscoPublic's, and is\n@@ -526,7 +527,7 @@ func (s *Server) AllocateEndpoint(discoA, discoB key.DiscoPublic) (ServerEndpoin\n \t\tAddrPorts:           s.addrPorts,\n \t\tVNI:                 e.vni,\n \t\tLamportID:           e.lamportID,\n-\t\tBindLifetime:        s.bindLifetime,\n-\t\tSteadyStateLifetime: s.steadyStateLifetime,\n+\t\tBindLifetime:        tstime.GoDuration{Duration: s.bindLifetime},\n+\t\tSteadyStateLifetime: tstime.GoDuration{Duration: s.steadyStateLifetime},\n \t}, nil\n }\n---\nnet/udprelay/server_test.go\n@@ -5,6 +5,8 @@ package udprelay\n \n import (\n \t\"bytes\"\n+\t\"encoding/json\"\n+\t\"math\"\n \t\"net\"\n \t\"net/netip\"\n \t\"testing\"\n@@ -15,6 +17,7 @@ import (\n \t\"go4.org/mem\"\n \t\"tailscale.com/disco\"\n \t\"tailscale.com/net/packet\"\n+\t\"tailscale.com/tstime\"\n \t\"tailscale.com/types/key\"\n )\n \n@@ -202,3 +205,96 @@ func TestServer(t *testing.T) {\n \t\tt.Fatal(\"unexpected msg B->A\")\n \t}\n }\n+\n+func TestServerEndpointJSONUnmarshal(t *testing.T) {\n+\ttests := []struct {\n+\t\tname    string\n+\t\tjson    []byte\n+\t\twantErr bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"valid\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid ServerDisco\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"1\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid LamportID\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":1.1,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid AddrPorts\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid VNI\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":18446744073709551615,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid BindLifetime\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"5\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid SteadyStateLifetime\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tvar out ServerEndpoint\n+\t\t\terr := json.Unmarshal(tt.json, &out)\n+\t\t\tif tt.wantErr != (err != nil) {\n+\t\t\t\tt.Fatalf(\"wantErr: %v (err == nil): %v\", tt.wantErr, err == nil)\n+\t\t\t}\n+\t\t\tif tt.wantErr {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestServerEndpointJSONMarshal(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\tserverEndpoint ServerEndpoint\n+\t}{\n+\t\t{\n+\t\t\tname: \"valid roundtrip\",\n+\t\t\tserverEndpoint: ServerEndpoint{\n+\t\t\t\tServerDisco:         key.NewDisco().Public(),\n+\t\t\t\tLamportID:           uint64(math.MaxUint64),\n+\t\t\t\tAddrPorts:           []netip.AddrPort{netip.MustParseAddrPort(\"127.0.0.1:1\"), netip.MustParseAddrPort(\"127.0.0.2:2\")},\n+\t\t\t\tVNI:                 1<<24 - 1,\n+\t\t\t\tBindLifetime:        tstime.GoDuration{Duration: defaultBindLifetime},\n+\t\t\t\tSteadyStateLifetime: tstime.GoDuration{Duration: defaultSteadyStateLifetime},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tb, err := json.Marshal(&tt.serverEndpoint)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tvar got ServerEndpoint\n+\t\t\terr = json.Unmarshal(b, &got)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif diff := cmp.Diff(got, tt.serverEndpoint, cmpopts.EquateComparable(netip.AddrPort{}, key.DiscoPublic{})); diff != \"\" {\n+\t\t\t\tt.Fatalf(\"ServerEndpoint unequal (-got +want)\\n%s\", diff)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nWe added this helper in 1e2e319e7d26. Remove this copy.\n\nUpdates #cleanup\n\n\n---\n\nChoice A:\ngo.mod\n@@ -272,7 +272,7 @@ require (\n \tgithub.com/gordonklaus/ineffassign v0.1.0 // indirect\n \tgithub.com/goreleaser/chglog v0.5.0 // indirect\n \tgithub.com/goreleaser/fileglob v1.3.0 // indirect\n-\tgithub.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30\n+\tgithub.com/gorilla/csrf v1.7.3\n \tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n \tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n \tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n---\ngo.sum\n@@ -524,8 +524,8 @@ github.com/goreleaser/fileglob v1.3.0 h1:/X6J7U8lbDpQtBvGcwwPS6OpzkNVlVEsFUVRx9+\n github.com/goreleaser/fileglob v1.3.0/go.mod h1:Jx6BoXv3mbYkEzwm9THo7xbr5egkAraxkGorbJb4RxU=\n github.com/goreleaser/nfpm/v2 v2.33.1 h1:EkdAzZyVhAI9JC1vjmjjbmnNzyH1J6Cu4JCsA7YcQuc=\n github.com/goreleaser/nfpm/v2 v2.33.1/go.mod h1:8wwWWvJWmn84xo/Sqiv0aMvEGTHlHZTXTEuVSgQpkIM=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30 h1:fiJdrgVBkjZ5B1HJ2WQwNOaXB+QyYcNXTA3t1XYLz0M=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n+github.com/gorilla/csrf v1.7.3 h1:BHWt6FTLZAb2HtWT5KDBf6qgpZzvtbp9QWDRKZMXJC0=\n+github.com/gorilla/csrf v1.7.3/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n github.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\n github.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\n github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/extension_host.go\n@@ -25,6 +25,7 @@ import (\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/execqueue\"\n \t\"tailscale.com/util/set\"\n+\t\"tailscale.com/util/slicesx\"\n \t\"tailscale.com/util/testenv\"\n )\n \n@@ -378,7 +379,7 @@ func (h *ExtensionHost) NotifyProfileChange(profile ipn.LoginProfileView, prefs\n \th.currentPrefs = prefs\n \th.currentProfile = profile\n \t// Get the callbacks to be invoked.\n-\tcbs := collectValues(h.profileStateChangeCbs)\n+\tcbs := slicesx.MapValues(h.profileStateChangeCbs)\n \th.mu.Unlock()\n \tfor _, cb := range cbs {\n \t\tcb(profile, prefs, sameNode)\n@@ -402,7 +403,7 @@ func (h *ExtensionHost) NotifyProfilePrefsChanged(profile ipn.LoginProfileView,\n \th.currentPrefs = newPrefs\n \th.currentProfile = profile\n \t// Get the callbacks to be invoked.\n-\tstateCbs := collectValues(h.profileStateChangeCbs)\n+\tstateCbs := slicesx.MapValues(h.profileStateChangeCbs)\n \th.mu.Unlock()\n \tfor _, cb := range stateCbs {\n \t\tcb(profile, newPrefs, true)\n@@ -443,7 +444,7 @@ func (h *ExtensionHost) DetermineBackgroundProfile(profiles ipnext.ProfileStore)\n \t// Attempt to resolve the background profile using the registered\n \t// background profile resolvers (e.g., [ipn/desktop.desktopSessionsExt] on Windows).\n \th.mu.Lock()\n-\tresolvers := collectValues(h.backgroundProfileResolvers)\n+\tresolvers := slicesx.MapValues(h.backgroundProfileResolvers)\n \th.mu.Unlock()\n \tfor _, resolver := range resolvers {\n \t\tif profile := resolver(profiles); profile.Valid() {\n@@ -481,7 +482,7 @@ func (h *ExtensionHost) NotifyNewControlClient(cc controlclient.Client, profile\n \t\treturn nil\n \t}\n \th.mu.Lock()\n-\tcbs := collectValues(h.newControlClientCbs)\n+\tcbs := slicesx.MapValues(h.newControlClientCbs)\n \th.mu.Unlock()\n \tif len(cbs) > 0 {\n \t\tccShutdownCbs = make([]func(), 0, len(cbs))\n@@ -527,7 +528,7 @@ func (h *ExtensionHost) AuditLogger() ipnauth.AuditLogFunc {\n \t}\n \n \th.mu.Lock()\n-\tproviders := collectValues(h.auditLoggers)\n+\tproviders := slicesx.MapValues(h.auditLoggers)\n \th.mu.Unlock()\n \n \tvar loggers []ipnauth.AuditLogFunc\n@@ -642,17 +643,3 @@ type execQueue interface {\n \tShutdown()\n \tWait(context.Context) error\n }\n-\n-// collectValues is like [slices.Collect] of [maps.Values],\n-// but pre-allocates the slice to avoid reallocations.\n-// It returns nil if the map is empty.\n-func collectValues[K comparable, V any](m map[K]V) []V {\n-\tif len(m) == 0 {\n-\t\treturn nil\n-\t}\n-\ts := make([]V, 0, len(m))\n-\tfor _, v := range m {\n-\t\ts = append(s, v)\n-\t}\n-\treturn s\n-}\n---\n\n\n---\n\nChoice C:\ngo.mod\n@@ -77,7 +77,7 @@ require (\n \tgithub.com/tailscale/certstore v0.1.1-0.20231202035212-d3fa0460f47e\n \tgithub.com/tailscale/depaware v0.0.0-20250112153213-b748de04d81b\n \tgithub.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41\n-\tgithub.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca\n+\tgithub.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869\n \tgithub.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05\n \tgithub.com/tailscale/hujson v0.0.0-20221223112325-20486734a56a\n \tgithub.com/tailscale/mkctr v0.0.0-20250228050937-c75ea1476830\n---\ngo.sum\n@@ -910,8 +910,8 @@ github.com/tailscale/go-winio v0.0.0-20231025203758-c4f33415bf55 h1:Gzfnfk2TWrk8\n github.com/tailscale/go-winio v0.0.0-20231025203758-c4f33415bf55/go.mod h1:4k4QO+dQ3R5FofL+SanAUZe+/QfeK0+OIuwDIRu2vSg=\n github.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41 h1:/V2rCMMWcsjYaYO2MeovLw+ClP63OtXgCF2Y1eb8+Ns=\n github.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41/go.mod h1:/roCdA6gg6lQyw/Oz6gIIGu3ggJKYhF+WC/AQReE5XQ=\n-github.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca h1:ecjHwH73Yvqf/oIdQ2vxAX+zc6caQsYdPzsxNW1J3G8=\n-github.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca/go.mod h1:ikbF+YT089eInTp9f2vmvy4+ZVnW5hzX1q2WknxSprQ=\n+github.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869 h1:SRL6irQkKGQKKLzvQP/ke/2ZuB7Py5+XuqtOgSj+iMM=\n+github.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869/go.mod h1:ikbF+YT089eInTp9f2vmvy4+ZVnW5hzX1q2WknxSprQ=\n github.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05 h1:4chzWmimtJPxRs2O36yuGRW3f9SYV+bMTTvMBI0EKio=\n github.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05/go.mod h1:PdCqy9JzfWMJf1H5UJW2ip33/d4YkoKN0r67yKH1mG8=\n github.com/tailscale/hujson v0.0.0-20221223112325-20486734a56a h1:SJy1Pu0eH1C29XwJucQo73FrleVK6t4kYz4NVhp34Yw=\n---\ntempfork/acme/acme.go\n@@ -270,10 +270,7 @@ func (c *Client) FetchRenewalInfo(ctx context.Context, leaf []byte) (*RenewalInf\n \t\treturn nil, fmt.Errorf(\"parsing leaf certificate: %w\", err)\n \t}\n \n-\trenewalURL, err := c.getRenewalURL(parsedLeaf)\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"generating renewal info URL: %w\", err)\n-\t}\n+\trenewalURL := c.getRenewalURL(parsedLeaf)\n \n \tres, err := c.get(ctx, renewalURL, wantStatus(http.StatusOK))\n \tif err != nil {\n@@ -288,16 +285,20 @@ func (c *Client) FetchRenewalInfo(ctx context.Context, leaf []byte) (*RenewalInf\n \treturn &info, nil\n }\n \n-func (c *Client) getRenewalURL(cert *x509.Certificate) (string, error) {\n+func (c *Client) getRenewalURL(cert *x509.Certificate) string {\n \t// See https://www.ietf.org/archive/id/draft-ietf-acme-ari-04.html#name-the-renewalinfo-resource\n \t// for how the request URL is built.\n \turl := c.dir.RenewalInfoURL\n \tif !strings.HasSuffix(url, \"/\") {\n \t\turl += \"/\"\n \t}\n+\treturn url + certRenewalIdentifier(cert)\n+}\n+\n+func certRenewalIdentifier(cert *x509.Certificate) string {\n \taki := base64.RawURLEncoding.EncodeToString(cert.AuthorityKeyId)\n \tserial := base64.RawURLEncoding.EncodeToString(cert.SerialNumber.Bytes())\n-\treturn fmt.Sprintf(\"%s%s.%s\", url, aki, serial), nil\n+\treturn aki + \".\" + serial\n }\n \n // AcceptTOS always returns true to indicate the acceptance of a CA's Terms of Service\n---\ntempfork/acme/acme_test.go\n@@ -549,10 +549,7 @@ func TestGetRenewalURL(t *testing.T) {\n \t}\n \n \tclient := newTestClientWithMockDirectory()\n-\turlString, err := client.getRenewalURL(parsedLeaf)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\turlString := client.getRenewalURL(parsedLeaf)\n \n \tparsedURL, err := url.Parse(urlString)\n \tif err != nil {\n---\ntempfork/acme/rfc8555.go\n@@ -7,6 +7,7 @@ package acme\n import (\n \t\"context\"\n \t\"crypto\"\n+\t\"crypto/x509\"\n \t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"encoding/pem\"\n@@ -205,6 +206,7 @@ func (c *Client) AuthorizeOrder(ctx context.Context, id []AuthzID, opt ...OrderO\n \t\tIdentifiers []wireAuthzID `json:\"identifiers\"`\n \t\tNotBefore   string        `json:\"notBefore,omitempty\"`\n \t\tNotAfter    string        `json:\"notAfter,omitempty\"`\n+\t\tReplaces    string        `json:\"replaces,omitempty\"`\n \t}{}\n \tfor _, v := range id {\n \t\treq.Identifiers = append(req.Identifiers, wireAuthzID{\n@@ -218,6 +220,14 @@ func (c *Client) AuthorizeOrder(ctx context.Context, id []AuthzID, opt ...OrderO\n \t\t\treq.NotBefore = time.Time(o).Format(time.RFC3339)\n \t\tcase orderNotAfterOpt:\n \t\t\treq.NotAfter = time.Time(o).Format(time.RFC3339)\n+\t\tcase orderReplacesCert:\n+\t\t\treq.Replaces = certRenewalIdentifier(o.cert)\n+\t\tcase orderReplacesCertDER:\n+\t\t\tcert, err := x509.ParseCertificate(o)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"failed to parse certificate being replaced: %w\", err)\n+\t\t\t}\n+\t\t\treq.Replaces = certRenewalIdentifier(cert)\n \t\tdefault:\n \t\t\t// Package's fault if we let this happen.\n \t\t\tpanic(fmt.Sprintf(\"unsupported order option type %T\", o))\n---\ntempfork/acme/rfc8555_test.go\n@@ -766,10 +766,17 @@ func TestRFC_AuthorizeOrder(t *testing.T) {\n \ts.start()\n \tdefer s.close()\n \n+\tprevCertDER, _ := pem.Decode([]byte(leafPEM))\n+\tprevCert, err := x509.ParseCertificate(prevCertDER.Bytes)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n \tcl := &Client{Key: testKeyEC, DirectoryURL: s.url(\"/\")}\n \to, err := cl.AuthorizeOrder(context.Background(), DomainIDs(\"example.org\"),\n \t\tWithOrderNotBefore(time.Date(2019, 8, 31, 0, 0, 0, 0, time.UTC)),\n \t\tWithOrderNotAfter(time.Date(2019, 9, 2, 0, 0, 0, 0, time.UTC)),\n+\t\tWithOrderReplacesCert(prevCert),\n \t)\n \tif err != nil {\n \t\tt.Fatal(err)\n---\ntempfork/acme/types.go\n@@ -391,6 +391,30 @@ type orderNotAfterOpt time.Time\n \n func (orderNotAfterOpt) privateOrderOpt() {}\n \n+// WithOrderReplacesCert indicates that this Order is for a replacement of an\n+// existing certificate.\n+// See https://datatracker.ietf.org/doc/html/draft-ietf-acme-ari-03#section-5\n+func WithOrderReplacesCert(cert *x509.Certificate) OrderOption {\n+\treturn orderReplacesCert{cert}\n+}\n+\n+type orderReplacesCert struct {\n+\tcert *x509.Certificate\n+}\n+\n+func (orderReplacesCert) privateOrderOpt() {}\n+\n+// WithOrderReplacesCertDER indicates that this Order is for a replacement of\n+// an existing DER-encoded certificate.\n+// See https://datatracker.ietf.org/doc/html/draft-ietf-acme-ari-03#section-5\n+func WithOrderReplacesCertDER(der []byte) OrderOption {\n+\treturn orderReplacesCertDER(der)\n+}\n+\n+type orderReplacesCertDER []byte\n+\n+func (orderReplacesCertDER) privateOrderOpt() {}\n+\n // Authorization encodes an authorization response.\n type Authorization struct {\n \t// URI uniquely identifies a authorization.\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/set.go\n@@ -83,7 +83,7 @@ func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n \tsetf.BoolVar(&setArgs.advertiseConnector, \"advertise-connector\", false, \"offer to be an app connector for domain specific internet traffic for the tailnet\")\n \tsetf.BoolVar(&setArgs.updateCheck, \"update-check\", true, \"notify about available Tailscale updates\")\n \tsetf.BoolVar(&setArgs.updateApply, \"auto-update\", false, \"automatically update to the latest available version\")\n-\tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, hidden+\"allow management plane to gather device posture information\")\n+\tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, \"allow management plane to gather device posture information\")\n \tsetf.BoolVar(&setArgs.runWebClient, \"webclient\", false, \"expose the web interface for managing this node over Tailscale at port 5252\")\n \tsetf.StringVar(&setArgs.relayServerPort, \"relay-server-port\", \"\", hidden+\"UDP port number (0 will pick a random unused port) for the relay server to bind to, on all interfaces, or empty string to disable relay server functionality\")\n \n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nCherry-picked from 62182fc37d44c0a8185b7d96f30465710dd68b66.\r\n\r\nUpdates google/gvisor#11632\r\nUpdates tailscale/corp#27717\n\n---\n\nChoice A:\n.github/workflows/golangci-lint.yml\n@@ -31,7 +31,7 @@ jobs:\n           cache: false\n \n       - name: golangci-lint\n-        uses: golangci/golangci-lint-action@2226d7cb06a077cd73e56eedd38eecad18e5d837 # v6.5.0\n+        uses: golangci/golangci-lint-action@55c2c1448f86e01eaae002a5a3a9624417608d84 # v6.5.2\n         with:\n           version: v1.64\n \n---\n\n\n---\n\nChoice B:\ncmd/tailscale/cli/debug.go\n@@ -136,6 +136,17 @@ func debugCmd() *ffcli.Command {\n \t\t\t\tExec:       runLocalCreds,\n \t\t\t\tShortHelp:  \"Print how to access Tailscale LocalAPI\",\n \t\t\t},\n+\t\t\t{\n+\t\t\t\tName:       \"localapi\",\n+\t\t\t\tShortUsage: \"tailscale debug localapi [<method>] <path> [<body| \\\"-\\\">]\",\n+\t\t\t\tExec:       runLocalAPI,\n+\t\t\t\tShortHelp:  \"Call a LocalAPI method directly\",\n+\t\t\t\tFlagSet: (func() *flag.FlagSet {\n+\t\t\t\t\tfs := newFlagSet(\"localapi\")\n+\t\t\t\t\tfs.BoolVar(&localAPIFlags.verbose, \"v\", false, \"verbose; dump HTTP headers\")\n+\t\t\t\t\treturn fs\n+\t\t\t\t})(),\n+\t\t\t},\n \t\t\t{\n \t\t\t\tName:       \"restun\",\n \t\t\t\tShortUsage: \"tailscale debug restun\",\n@@ -451,6 +462,81 @@ func runLocalCreds(ctx context.Context, args []string) error {\n \treturn nil\n }\n \n+func looksLikeHTTPMethod(s string) bool {\n+\tif len(s) > len(\"OPTIONS\") {\n+\t\treturn false\n+\t}\n+\tfor _, r := range s {\n+\t\tif r < 'A' || r > 'Z' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+var localAPIFlags struct {\n+\tverbose bool\n+}\n+\n+func runLocalAPI(ctx context.Context, args []string) error {\n+\tif len(args) == 0 {\n+\t\treturn errors.New(\"expected at least one argument\")\n+\t}\n+\tmethod := \"GET\"\n+\tif looksLikeHTTPMethod(args[0]) {\n+\t\tmethod = args[0]\n+\t\targs = args[1:]\n+\t\tif len(args) == 0 {\n+\t\t\treturn errors.New(\"expected at least one argument after method\")\n+\t\t}\n+\t}\n+\tpath := args[0]\n+\tif !strings.HasPrefix(path, \"/localapi/\") {\n+\t\tif !strings.Contains(path, \"/\") {\n+\t\t\tpath = \"/localapi/v0/\" + path\n+\t\t} else {\n+\t\t\tpath = \"/localapi/\" + path\n+\t\t}\n+\t}\n+\n+\tvar body io.Reader\n+\tif len(args) > 1 {\n+\t\tif args[1] == \"-\" {\n+\t\t\tfmt.Fprintf(Stderr, \"# reading request body from stdin...\\n\")\n+\t\t\tall, err := io.ReadAll(os.Stdin)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"reading Stdin: %q\", err)\n+\t\t\t}\n+\t\t\tbody = bytes.NewReader(all)\n+\t\t} else {\n+\t\t\tbody = strings.NewReader(args[1])\n+\t\t}\n+\t}\n+\treq, err := http.NewRequest(method, \"http://local-tailscaled.sock\"+path, body)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tfmt.Fprintf(Stderr, \"# doing request %s %s\\n\", method, path)\n+\n+\tres, err := localClient.DoLocalRequest(req)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tis2xx := res.StatusCode >= 200 && res.StatusCode <= 299\n+\tif localAPIFlags.verbose {\n+\t\tres.Write(Stdout)\n+\t} else {\n+\t\tif !is2xx {\n+\t\t\tfmt.Fprintf(Stderr, \"# Response status %s\\n\", res.Status)\n+\t\t}\n+\t\tio.Copy(Stdout, res.Body)\n+\t}\n+\tif is2xx {\n+\t\treturn nil\n+\t}\n+\treturn errors.New(res.Status)\n+}\n+\n type localClientRoundTripper struct{}\n \n func (localClientRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n---\n\n\n---\n\nChoice C:\nwgengine/netstack/netstack.go\n@@ -326,10 +326,15 @@ func Create(logf logger.Logf, tundev *tstun.Wrapper, e wgengine.Engine, mc *magi\n \tif tcpipErr != nil {\n \t\treturn nil, fmt.Errorf(\"could not disable TCP RACK: %v\", tcpipErr)\n \t}\n-\tcubicOpt := tcpip.CongestionControlOption(\"cubic\")\n-\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &cubicOpt)\n+\t// gVisor defaults to reno at the time of writing. We explicitly set reno\n+\t// congestion control in order to prevent unexpected changes. Netstack\n+\t// has an int overflow in sender congestion window arithmetic that is more\n+\t// prone to trigger with cubic congestion control.\n+\t// See https://github.com/google/gvisor/issues/11632\n+\trenoOpt := tcpip.CongestionControlOption(\"reno\")\n+\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &renoOpt)\n \tif tcpipErr != nil {\n-\t\treturn nil, fmt.Errorf(\"could not set cubic congestion control: %v\", tcpipErr)\n+\t\treturn nil, fmt.Errorf(\"could not set reno congestion control: %v\", tcpipErr)\n \t}\n \terr := setTCPBufSizes(ipstack)\n \tif err != nil {\n---\n\n\n---\n\nChoice D:\nutil/mak/mak.go\n@@ -5,11 +5,6 @@\n // things, notably to maps, but also slices.\n package mak\n \n-import (\n-\t\"fmt\"\n-\t\"reflect\"\n-)\n-\n // Set populates an entry in a map, making the map if necessary.\n //\n // That is, it assigns (*m)[k] = v, making *m if it was nil.\n@@ -20,35 +15,6 @@ func Set[K comparable, V any, T ~map[K]V](m *T, k K, v V) {\n \t(*m)[k] = v\n }\n \n-// NonNil takes a pointer to a Go data structure\n-// (currently only a slice or a map) and makes sure it's non-nil for\n-// JSON serialization. (In particular, JavaScript clients usually want\n-// the field to be defined after they decode the JSON.)\n-//\n-// Deprecated: use NonNilSliceForJSON or NonNilMapForJSON instead.\n-func NonNil(ptr any) {\n-\tif ptr == nil {\n-\t\tpanic(\"nil interface\")\n-\t}\n-\trv := reflect.ValueOf(ptr)\n-\tif rv.Kind() != reflect.Ptr {\n-\t\tpanic(fmt.Sprintf(\"kind %v, not Ptr\", rv.Kind()))\n-\t}\n-\tif rv.Pointer() == 0 {\n-\t\tpanic(\"nil pointer\")\n-\t}\n-\trv = rv.Elem()\n-\tif rv.Pointer() != 0 {\n-\t\treturn\n-\t}\n-\tswitch rv.Type().Kind() {\n-\tcase reflect.Slice:\n-\t\trv.Set(reflect.MakeSlice(rv.Type(), 0, 0))\n-\tcase reflect.Map:\n-\t\trv.Set(reflect.MakeMap(rv.Type()))\n-\t}\n-}\n-\n // NonNilSliceForJSON makes sure that *slicePtr is non-nil so it will\n // won't be omitted from JSON serialization and possibly confuse JavaScript\n // clients expecting it to be present.\n---\nutil/mak/mak_test.go\n@@ -40,35 +40,6 @@ func TestSet(t *testing.T) {\n \t})\n }\n \n-func TestNonNil(t *testing.T) {\n-\tvar s []string\n-\tNonNil(&s)\n-\tif len(s) != 0 {\n-\t\tt.Errorf(\"slice len = %d; want 0\", len(s))\n-\t}\n-\tif s == nil {\n-\t\tt.Error(\"slice still nil\")\n-\t}\n-\n-\ts = append(s, \"foo\")\n-\tNonNil(&s)\n-\tif len(s) != 1 {\n-\t\tt.Errorf(\"len = %d; want 1\", len(s))\n-\t}\n-\tif s[0] != \"foo\" {\n-\t\tt.Errorf(\"value = %q; want foo\", s)\n-\t}\n-\n-\tvar m map[string]string\n-\tNonNil(&m)\n-\tif len(m) != 0 {\n-\t\tt.Errorf(\"map len = %d; want 0\", len(s))\n-\t}\n-\tif m == nil {\n-\t\tt.Error(\"map still nil\")\n-\t}\n-}\n-\n func TestNonNilMapForJSON(t *testing.T) {\n \ttype M map[string]int\n \tvar m M\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nas discovered by https://github.com/tailscale/tailscale/issues/14891, specifying an ingress resource containing a an empty path (a.k.a., `path: \"\"`) results in an unclear error message and an non-functional ingress.\r\n\r\nOther ingress controllers (e.g., [Nginx Ingress Controller](https://docs.nginx.com/nginx-ingress-controller/configuration/ingress-resources/basic-configuration/#restrictions)) handle this behaviour by setting the path to `path: \"/\"` if found to be empty. This PR solves the problem by doing just that whilst also creating an event on the ingress resource to highlight this:\r\n\r\n```\r\nconfigured backend is missing a path, defaulting to '/'\r\n```\r\n\r\nFixes: https://github.com/tailscale/tailscale/issues/14908\n\n---\n\nChoice A:\ntsnet/tsnet.go\n@@ -1101,13 +1101,33 @@ type FunnelOption interface {\n \tfunnelOption()\n }\n \n-type funnelOnly int\n+type funnelOnly struct{}\n \n func (funnelOnly) funnelOption() {}\n \n // FunnelOnly configures the listener to only respond to connections from Tailscale Funnel.\n // The local tailnet will not be able to connect to the listener.\n-func FunnelOnly() FunnelOption { return funnelOnly(1) }\n+func FunnelOnly() FunnelOption { return funnelOnly{} }\n+\n+type funnelTLSConfig struct{ conf *tls.Config }\n+\n+func (f funnelTLSConfig) funnelOption() {}\n+\n+// FunnelTLSConfig configures the TLS configuration for [Server.ListenFunnel]\n+//\n+// This is rarely needed but can permit requiring client certificates, specific\n+// ciphers suites, etc.\n+//\n+// The provided conf should at least be able to get a certificate, setting\n+// GetCertificate, Certificates or GetConfigForClient appropriately.\n+// The most common configuration is to set GetCertificate to\n+// Server.LocalClient's GetCertificate method.\n+//\n+// Unless [FunnelOnly] is also used, the configuration is also used for\n+// in-tailnet connections that don't arrive over Funnel.\n+func FunnelTLSConfig(conf *tls.Config) FunnelOption {\n+\treturn funnelTLSConfig{conf: conf}\n+}\n \n // ListenFunnel announces on the public internet using Tailscale Funnel.\n //\n@@ -1140,6 +1160,26 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t\treturn nil, err\n \t}\n \n+\t// Process, validate opts.\n+\tlnOn := listenOnBoth\n+\tvar tlsConfig *tls.Config\n+\tfor _, opt := range opts {\n+\t\tswitch v := opt.(type) {\n+\t\tcase funnelTLSConfig:\n+\t\t\tif v.conf == nil {\n+\t\t\t\treturn nil, errors.New(\"invalid nil FunnelTLSConfig\")\n+\t\t\t}\n+\t\t\ttlsConfig = v.conf\n+\t\tcase funnelOnly:\n+\t\t\tlnOn = listenOnFunnel\n+\t\tdefault:\n+\t\t\treturn nil, fmt.Errorf(\"unknown opts FunnelOption type %T\", v)\n+\t\t}\n+\t}\n+\tif tlsConfig == nil {\n+\t\ttlsConfig = &tls.Config{GetCertificate: s.getCert}\n+\t}\n+\n \tctx := context.Background()\n \tst, err := s.Up(ctx)\n \tif err != nil {\n@@ -1177,19 +1217,11 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t}\n \n \t// Start a funnel listener.\n-\tlnOn := listenOnBoth\n-\tfor _, opt := range opts {\n-\t\tif _, ok := opt.(funnelOnly); ok {\n-\t\t\tlnOn = listenOnFunnel\n-\t\t}\n-\t}\n \tln, err := s.listen(network, addr, lnOn)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn tls.NewListener(ln, &tls.Config{\n-\t\tGetCertificate: s.getCert,\n-\t}), nil\n+\treturn tls.NewListener(ln, tlsConfig), nil\n }\n \n type listenOn string\n---\n\n\n---\n\nChoice B:\n.github/workflows/test.yml\n@@ -305,7 +305,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: build some\n-      run: ./tool/go build ./ipn/... ./wgengine/ ./types/... ./control/controlclient\n+      run: ./tool/go build ./ipn/... ./ssh/tailssh ./wgengine/ ./types/... ./control/controlclient\n       env:\n         GOOS: ios\n         GOARCH: arm64\n@@ -375,7 +375,7 @@ jobs:\n       # some Android breakages early.\n       # TODO(bradfitz): better; see https://github.com/tailscale/tailscale/issues/4482\n     - name: build some\n-      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version\n+      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version ./ssh/tailssh\n       env:\n         GOOS: android\n         GOARCH: arm64\n---\nssh/tailssh/incubator.go\n@@ -7,7 +7,7 @@\n // and groups to the specified `--uid`, `--gid` and `--groups`, and\n // then launches the requested `--cmd`.\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd\n \n package tailssh\n \n---\nssh/tailssh/incubator_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package tailssh\n \n---\nssh/tailssh/tailssh.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n // Package tailssh is an SSH server integrated into Tailscale.\n package tailssh\n---\nssh/tailssh/user.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n package tailssh\n \n---\n\n\n---\n\nChoice C:\nwgengine/magicsock/endpoint.go\n@@ -1111,7 +1111,7 @@ func (de *endpoint) sendDiscoPing(ep netip.AddrPort, discoKey key.DiscoPublic, t\n \tsize = min(size, MaxDiscoPingSize)\n \tpadding := max(size-discoPingSize, 0)\n \n-\tsent, _ := de.c.sendDiscoMessage(ep, de.publicKey, discoKey, &disco.Ping{\n+\tsent, _ := de.c.sendDiscoMessage(ep, nil, de.publicKey, discoKey, &disco.Ping{\n \t\tTxID:    [12]byte(txid),\n \t\tNodeKey: de.c.publicKeyAtomic.Load(),\n \t\tPadding: padding,\n---\nwgengine/magicsock/magicsock.go\n@@ -1602,23 +1602,60 @@ var debugIPv4DiscoPingPenalty = envknob.RegisterDuration(\"TS_DISCO_PONG_IPV4_DEL\n //\n // If dst is a DERP IP:port, then dstKey must be non-zero.\n //\n+// If geneveVNI is non-nil, then the [disco.Message] will be preceded by a\n+// Geneve header with the supplied VNI set.\n+//\n // The dstKey should only be non-zero if the dstDisco key\n // unambiguously maps to exactly one peer.\n-func (c *Conn) sendDiscoMessage(dst netip.AddrPort, dstKey key.NodePublic, dstDisco key.DiscoPublic, m disco.Message, logLevel discoLogLevel) (sent bool, err error) {\n+func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey key.NodePublic, dstDisco key.DiscoPublic, m disco.Message, logLevel discoLogLevel) (sent bool, err error) {\n \tisDERP := dst.Addr() == tailcfg.DerpMagicIPAddr\n \tif _, isPong := m.(*disco.Pong); isPong && !isDERP && dst.Addr().Is4() {\n \t\ttime.Sleep(debugIPv4DiscoPingPenalty())\n \t}\n \n+\tisRelayHandshakeMsg := false\n+\tswitch m.(type) {\n+\tcase *disco.BindUDPRelayEndpoint, *disco.BindUDPRelayEndpointAnswer:\n+\t\tisRelayHandshakeMsg = true\n+\t}\n+\n \tc.mu.Lock()\n \tif c.closed {\n \t\tc.mu.Unlock()\n \t\treturn false, errConnClosed\n \t}\n \tpkt := make([]byte, 0, 512) // TODO: size it correctly? pool? if it matters.\n+\tif geneveVNI != nil {\n+\t\tgh := packet.GeneveHeader{\n+\t\t\tVersion:  0,\n+\t\t\tProtocol: packet.GeneveProtocolDisco,\n+\t\t\tVNI:      *geneveVNI,\n+\t\t\tControl:  isRelayHandshakeMsg,\n+\t\t}\n+\t\tpkt = append(pkt, make([]byte, packet.GeneveFixedHeaderLength)...)\n+\t\terr := gh.Encode(pkt)\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t}\n \tpkt = append(pkt, disco.Magic...)\n \tpkt = c.discoPublic.AppendTo(pkt)\n-\tdi := c.discoInfoLocked(dstDisco)\n+\tvar di *discoInfo\n+\tif !isRelayHandshakeMsg {\n+\t\tdi = c.discoInfoLocked(dstDisco)\n+\t} else {\n+\t\t// c.discoInfoLocked() caches [*discoInfo] for dstDisco. It assumes that\n+\t\t// dstDisco is a known Tailscale peer, and will be cleaned around\n+\t\t// network map changes. In the case of a relay handshake message,\n+\t\t// dstDisco belongs to a relay server with a disco key that is\n+\t\t// discovered at endpoint allocation time or [disco.CallMeMaybeVia]\n+\t\t// reception time. There is no clear ending to its lifetime, so we\n+\t\t// can't cache with the same strategy. Instead, generate the shared\n+\t\t// key on the fly for now.\n+\t\tdi = &discoInfo{\n+\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n+\t\t}\n+\t}\n \tc.mu.Unlock()\n \n \tif isDERP {\n@@ -1943,7 +1980,7 @@ func (c *Conn) handlePingLocked(dm *disco.Ping, src netip.AddrPort, di *discoInf\n \n \tipDst := src\n \tdiscoDest := di.discoKey\n-\tgo c.sendDiscoMessage(ipDst, dstKey, discoDest, &disco.Pong{\n+\tgo c.sendDiscoMessage(ipDst, nil, dstKey, discoDest, &disco.Pong{\n \t\tTxID: dm.TxID,\n \t\tSrc:  src,\n \t}, discoVerboseLog)\n@@ -1988,12 +2025,12 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \tfor _, ep := range c.lastEndpoints {\n \t\teps = append(eps, ep.Addr)\n \t}\n-\tgo de.c.sendDiscoMessage(derpAddr, de.publicKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n+\tgo de.c.sendDiscoMessage(derpAddr, nil, de.publicKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n \tif debugSendCallMeUnknownPeer() {\n \t\t// Send a callMeMaybe packet to a non-existent peer\n \t\tunknownKey := key.NewNode().Public()\n \t\tc.logf(\"magicsock: sending CallMeMaybe to unknown peer per TS_DEBUG_SEND_CALLME_UNKNOWN_PEER\")\n-\t\tgo de.c.sendDiscoMessage(derpAddr, unknownKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n+\t\tgo de.c.sendDiscoMessage(derpAddr, nil, unknownKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n \t}\n }\n \n---\n\n\n---\n\nChoice D:\ncmd/k8s-operator/ingress.go\n@@ -292,9 +292,15 @@ func validateIngressClass(ctx context.Context, cl client.Client) error {\n \n func handlersForIngress(ctx context.Context, ing *networkingv1.Ingress, cl client.Client, rec record.EventRecorder, tlsHost string, logger *zap.SugaredLogger) (handlers map[string]*ipn.HTTPHandler, err error) {\n \taddIngressBackend := func(b *networkingv1.IngressBackend, path string) {\n+\t\tif path == \"\" {\n+\t\t\tpath = \"/\"\n+\t\t\trec.Eventf(ing, corev1.EventTypeNormal, \"PathUndefined\", \"configured backend is missing a path, defaulting to '/'\")\n+\t\t}\n+\n \t\tif b == nil {\n \t\t\treturn\n \t\t}\n+\n \t\tif b.Service == nil {\n \t\t\trec.Eventf(ing, corev1.EventTypeWarning, \"InvalidIngressBackend\", \"backend for path %q is missing service\", path)\n \t\t\treturn\n---\ncmd/k8s-operator/ingress_test.go\n@@ -16,6 +16,7 @@ import (\n \tapiextensionsv1 \"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1\"\n \tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \t\"k8s.io/apimachinery/pkg/types\"\n+\t\"k8s.io/client-go/tools/record\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n \t\"tailscale.com/ipn\"\n@@ -487,6 +488,138 @@ func TestIngressLetsEncryptStaging(t *testing.T) {\n \t}\n }\n \n+func TestEmptyPath(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname           string\n+\t\tpaths          []networkingv1.HTTPIngressPath\n+\t\texpectedEvents []string\n+\t}{\n+\t\t{\n+\t\t\tname: \"empty_path_with_prefix_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypePrefix),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty_path_with_implementation_specific_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty_path_with_exact_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeExact),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Warning UnsupportedPathTypeExact Exact path type strict matching is currently not supported and requests will be routed as for Prefix path type. This behaviour might change in the future.\",\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"two_competing_but_not_identical_paths_including_one_empty\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"/\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range testCases {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfc := fake.NewFakeClient(ingressClass())\n+\t\t\tft := &fakeTSClient{}\n+\t\t\tfr := record.NewFakeRecorder(3) // bump this if you expect a test case to throw more events\n+\t\t\tfakeTsnetServer := &fakeTSNetServer{certDomains: []string{\"foo.com\"}}\n+\t\t\tzl, err := zap.NewDevelopment()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tingR := &IngressReconciler{\n+\t\t\t\trecorder: fr,\n+\t\t\t\tClient:   fc,\n+\t\t\t\tssr: &tailscaleSTSReconciler{\n+\t\t\t\t\tClient:            fc,\n+\t\t\t\t\ttsClient:          ft,\n+\t\t\t\t\ttsnetServer:       fakeTsnetServer,\n+\t\t\t\t\tdefaultTags:       []string{\"tag:k8s\"},\n+\t\t\t\t\toperatorNamespace: \"operator-ns\",\n+\t\t\t\t\tproxyImage:        \"tailscale/tailscale\",\n+\t\t\t\t},\n+\t\t\t\tlogger: zl.Sugar(),\n+\t\t\t}\n+\n+\t\t\t// 1. Resources get created for regular Ingress\n+\t\t\tmustCreate(t, fc, ingressWithPaths(tt.paths))\n+\t\t\tmustCreate(t, fc, service())\n+\n+\t\t\texpectReconciled(t, ingR, \"default\", \"test\")\n+\n+\t\t\tfullName, shortName := findGenName(t, fc, \"default\", \"test\", \"ingress\")\n+\t\t\tmustCreate(t, fc, &corev1.Pod{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tName:      fullName,\n+\t\t\t\t\tNamespace: \"operator-ns\",\n+\t\t\t\t\tUID:       \"test-uid\",\n+\t\t\t\t},\n+\t\t\t})\n+\t\t\topts := configOpts{\n+\t\t\t\tstsName:    shortName,\n+\t\t\t\tsecretName: fullName,\n+\t\t\t\tnamespace:  \"default\",\n+\t\t\t\tparentType: \"ingress\",\n+\t\t\t\thostname:   \"foo\",\n+\t\t\t\tapp:        kubetypes.AppIngressResource,\n+\t\t\t}\n+\t\t\tserveConfig := &ipn.ServeConfig{\n+\t\t\t\tTCP: map[uint16]*ipn.TCPPortHandler{443: {HTTPS: true}},\n+\t\t\t\tWeb: map[ipn.HostPort]*ipn.WebServerConfig{\"${TS_CERT_DOMAIN}:443\": {Handlers: map[string]*ipn.HTTPHandler{\"/\": {Proxy: \"http://1.2.3.4:8080/\"}}}},\n+\t\t\t}\n+\t\t\topts.serveConfig = serveConfig\n+\n+\t\t\texpectEqual(t, fc, expectedSecret(t, fc, opts))\n+\t\t\texpectEqual(t, fc, expectedHeadlessService(shortName, \"ingress\"))\n+\t\t\texpectEqual(t, fc, expectedSTSUserspace(t, fc, opts), removeHashAnnotation, removeResourceReqs)\n+\n+\t\t\texpectEvents(t, fr, tt.expectedEvents)\n+\t\t})\n+\t}\n+}\n+\n+// ptrPathType is a helper function to return a pointer to the pathtype string (required for TestEmptyPath)\n+func ptrPathType(p networkingv1.PathType) *networkingv1.PathType {\n+\treturn &p\n+}\n+\n func ingressClass() *networkingv1.IngressClass {\n \treturn &networkingv1.IngressClass{\n \t\tObjectMeta: metav1.ObjectMeta{Name: \"tailscale\"},\n@@ -520,16 +653,47 @@ func ingress() *networkingv1.Ingress {\n \t\t},\n \t\tSpec: networkingv1.IngressSpec{\n \t\t\tIngressClassName: ptr.To(\"tailscale\"),\n-\t\t\tDefaultBackend: &networkingv1.IngressBackend{\n-\t\t\t\tService: &networkingv1.IngressServiceBackend{\n-\t\t\t\t\tName: \"test\",\n-\t\t\t\t\tPort: networkingv1.ServiceBackendPort{\n-\t\t\t\t\t\tNumber: 8080,\n+\t\t\tDefaultBackend:   backend(),\n+\t\t\tTLS: []networkingv1.IngressTLS{\n+\t\t\t\t{Hosts: []string{\"default-test\"}},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func ingressWithPaths(paths []networkingv1.HTTPIngressPath) *networkingv1.Ingress {\n+\treturn &networkingv1.Ingress{\n+\t\tTypeMeta: metav1.TypeMeta{Kind: \"Ingress\", APIVersion: \"networking.k8s.io/v1\"},\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      \"test\",\n+\t\t\tNamespace: \"default\",\n+\t\t\tUID:       types.UID(\"1234-UID\"),\n+\t\t},\n+\t\tSpec: networkingv1.IngressSpec{\n+\t\t\tIngressClassName: ptr.To(\"tailscale\"),\n+\t\t\tRules: []networkingv1.IngressRule{\n+\t\t\t\t{\n+\t\t\t\t\tHost: \"foo.tailnetxyz.ts.net\",\n+\t\t\t\t\tIngressRuleValue: networkingv1.IngressRuleValue{\n+\t\t\t\t\t\tHTTP: &networkingv1.HTTPIngressRuleValue{\n+\t\t\t\t\t\t\tPaths: paths,\n+\t\t\t\t\t\t},\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n \t\t\tTLS: []networkingv1.IngressTLS{\n-\t\t\t\t{Hosts: []string{\"default-test\"}},\n+\t\t\t\t{Hosts: []string{\"foo.tailnetxyz.ts.net\"}},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func backend() *networkingv1.IngressBackend {\n+\treturn &networkingv1.IngressBackend{\n+\t\tService: &networkingv1.IngressServiceBackend{\n+\t\t\tName: \"test\",\n+\t\t\tPort: networkingv1.ServiceBackendPort{\n+\t\t\t\tNumber: 8080,\n \t\t\t},\n \t\t},\n \t}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nhttps://github.com/tailscale/tailscale/pull/15395 changed the logic to skip `EditPrefs` when the platform doesn't support auto-updates. But the old logic would only fail `EditPrefs` if the auto-update value was `true`. If it was `false`, `EditPrefs` would succeed and store `false` in prefs. The new logic will keep the value `unset` even if the tailnet default is `false`.\r\n\r\nFixes #15691\n\n---\n\nChoice A:\nipn/ipnlocal/local_test.go\n@@ -15,7 +15,6 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n-\t\"runtime\"\n \t\"slices\"\n \t\"strings\"\n \t\"sync\"\n@@ -2597,9 +2596,6 @@ func TestPreferencePolicyInfo(t *testing.T) {\n }\n \n func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n-\tif runtime.GOOS == \"darwin\" {\n-\t\tt.Skip(\"test known broken on macOS; see https://github.com/tailscale/tailscale/issues/15691\")\n-\t}\n \ttests := []struct {\n \t\tbefore, after  opt.Bool\n \t\tcontainer      opt.Bool\n@@ -2669,7 +2665,7 @@ func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n \t\t\t// On platforms that don't support auto-update we can never\n \t\t\t// transition to auto-updates being enabled. The value should\n \t\t\t// remain unchanged after onTailnetDefaultAutoUpdate.\n-\t\t\tif !clientupdate.CanAutoUpdate() && want.EqualBool(true) {\n+\t\t\tif !clientupdate.CanAutoUpdate() {\n \t\t\t\twant = tt.before\n \t\t\t}\n \t\t\tif got := b.pm.CurrentPrefs().AutoUpdate().Apply; got != want {\n---\n\n\n---\n\nChoice B:\ncontrol/controlclient/direct.go\n@@ -95,15 +95,16 @@ type Direct struct {\n \tsfGroup     singleflight.Group[struct{}, *NoiseClient] // protects noiseClient creation.\n \tnoiseClient *NoiseClient\n \n-\tpersist      persist.PersistView\n-\tauthKey      string\n-\ttryingNewKey key.NodePrivate\n-\texpiry       time.Time         // or zero value if none/unknown\n-\thostinfo     *tailcfg.Hostinfo // always non-nil\n-\tnetinfo      *tailcfg.NetInfo\n-\tendpoints    []tailcfg.Endpoint\n-\ttkaHead      string\n-\tlastPingURL  string // last PingRequest.URL received, for dup suppression\n+\tpersist                 persist.PersistView\n+\tauthKey                 string\n+\ttryingNewKey            key.NodePrivate\n+\texpiry                  time.Time         // or zero value if none/unknown\n+\thostinfo                *tailcfg.Hostinfo // always non-nil\n+\tnetinfo                 *tailcfg.NetInfo\n+\tendpoints               []tailcfg.Endpoint\n+\ttkaHead                 string\n+\tlastPingURL             string // last PingRequest.URL received, for dup suppression\n+\tconnectionHandleForTest string // sent in MapRequest.ConnectionHandleForTest\n }\n \n // Observer is implemented by users of the control client (such as LocalBackend)\n@@ -403,6 +404,14 @@ func (c *Direct) SetTKAHead(tkaHead string) bool {\n \treturn true\n }\n \n+// SetConnectionHandleForTest stores a new MapRequest.ConnectionHandleForTest\n+// value for the next update.\n+func (c *Direct) SetConnectionHandleForTest(handle string) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tc.connectionHandleForTest = handle\n+}\n+\n func (c *Direct) GetPersist() persist.PersistView {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n@@ -851,6 +860,7 @@ func (c *Direct) sendMapRequest(ctx context.Context, isStreaming bool, nu Netmap\n \tserverNoiseKey := c.serverNoiseKey\n \thi := c.hostInfoLocked()\n \tbackendLogID := hi.BackendLogID\n+\tconnectionHandleForTest := c.connectionHandleForTest\n \tvar epStrs []string\n \tvar eps []netip.AddrPort\n \tvar epTypes []tailcfg.EndpointType\n@@ -891,17 +901,18 @@ func (c *Direct) sendMapRequest(ctx context.Context, isStreaming bool, nu Netmap\n \n \tnodeKey := persist.PublicNodeKey()\n \trequest := &tailcfg.MapRequest{\n-\t\tVersion:       tailcfg.CurrentCapabilityVersion,\n-\t\tKeepAlive:     true,\n-\t\tNodeKey:       nodeKey,\n-\t\tDiscoKey:      c.discoPubKey,\n-\t\tEndpoints:     eps,\n-\t\tEndpointTypes: epTypes,\n-\t\tStream:        isStreaming,\n-\t\tHostinfo:      hi,\n-\t\tDebugFlags:    c.debugFlags,\n-\t\tOmitPeers:     nu == nil,\n-\t\tTKAHead:       c.tkaHead,\n+\t\tVersion:                 tailcfg.CurrentCapabilityVersion,\n+\t\tKeepAlive:               true,\n+\t\tNodeKey:                 nodeKey,\n+\t\tDiscoKey:                c.discoPubKey,\n+\t\tEndpoints:               eps,\n+\t\tEndpointTypes:           epTypes,\n+\t\tStream:                  isStreaming,\n+\t\tHostinfo:                hi,\n+\t\tDebugFlags:              c.debugFlags,\n+\t\tOmitPeers:               nu == nil,\n+\t\tTKAHead:                 c.tkaHead,\n+\t\tConnectionHandleForTest: connectionHandleForTest,\n \t}\n \tvar extraDebugFlags []string\n \tif hi != nil && c.netMon != nil && !c.skipIPForwardingCheck &&\n---\ntailcfg/tailcfg.go\n@@ -1385,6 +1385,12 @@ type MapRequest struct {\n \t//     * \"warn-router-unhealthy\": client's Router implementation is\n \t//       having problems.\n \tDebugFlags []string `json:\",omitempty\"`\n+\n+\t// ConnectionHandleForTest, if non-empty, is an opaque string sent by the client that\n+\t// identifies this specific connection to the server. The server may choose to\n+\t// use this handle to identify the connection for debugging or testing\n+\t// purposes. It has no semantic meaning.\n+\tConnectionHandleForTest string `json:\",omitempty\"`\n }\n \n // PortRange represents a range of UDP or TCP port numbers.\n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n---\n\n\n---\n\nChoice D:\ncmd/k8s-operator/ingress.go\n@@ -292,9 +292,15 @@ func validateIngressClass(ctx context.Context, cl client.Client) error {\n \n func handlersForIngress(ctx context.Context, ing *networkingv1.Ingress, cl client.Client, rec record.EventRecorder, tlsHost string, logger *zap.SugaredLogger) (handlers map[string]*ipn.HTTPHandler, err error) {\n \taddIngressBackend := func(b *networkingv1.IngressBackend, path string) {\n+\t\tif path == \"\" {\n+\t\t\tpath = \"/\"\n+\t\t\trec.Eventf(ing, corev1.EventTypeNormal, \"PathUndefined\", \"configured backend is missing a path, defaulting to '/'\")\n+\t\t}\n+\n \t\tif b == nil {\n \t\t\treturn\n \t\t}\n+\n \t\tif b.Service == nil {\n \t\t\trec.Eventf(ing, corev1.EventTypeWarning, \"InvalidIngressBackend\", \"backend for path %q is missing service\", path)\n \t\t\treturn\n---\ncmd/k8s-operator/ingress_test.go\n@@ -16,6 +16,7 @@ import (\n \tapiextensionsv1 \"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1\"\n \tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \t\"k8s.io/apimachinery/pkg/types\"\n+\t\"k8s.io/client-go/tools/record\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n \t\"tailscale.com/ipn\"\n@@ -487,6 +488,138 @@ func TestIngressLetsEncryptStaging(t *testing.T) {\n \t}\n }\n \n+func TestEmptyPath(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname           string\n+\t\tpaths          []networkingv1.HTTPIngressPath\n+\t\texpectedEvents []string\n+\t}{\n+\t\t{\n+\t\t\tname: \"empty_path_with_prefix_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypePrefix),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty_path_with_implementation_specific_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty_path_with_exact_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeExact),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Warning UnsupportedPathTypeExact Exact path type strict matching is currently not supported and requests will be routed as for Prefix path type. This behaviour might change in the future.\",\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"two_competing_but_not_identical_paths_including_one_empty\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"/\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range testCases {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfc := fake.NewFakeClient(ingressClass())\n+\t\t\tft := &fakeTSClient{}\n+\t\t\tfr := record.NewFakeRecorder(3) // bump this if you expect a test case to throw more events\n+\t\t\tfakeTsnetServer := &fakeTSNetServer{certDomains: []string{\"foo.com\"}}\n+\t\t\tzl, err := zap.NewDevelopment()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tingR := &IngressReconciler{\n+\t\t\t\trecorder: fr,\n+\t\t\t\tClient:   fc,\n+\t\t\t\tssr: &tailscaleSTSReconciler{\n+\t\t\t\t\tClient:            fc,\n+\t\t\t\t\ttsClient:          ft,\n+\t\t\t\t\ttsnetServer:       fakeTsnetServer,\n+\t\t\t\t\tdefaultTags:       []string{\"tag:k8s\"},\n+\t\t\t\t\toperatorNamespace: \"operator-ns\",\n+\t\t\t\t\tproxyImage:        \"tailscale/tailscale\",\n+\t\t\t\t},\n+\t\t\t\tlogger: zl.Sugar(),\n+\t\t\t}\n+\n+\t\t\t// 1. Resources get created for regular Ingress\n+\t\t\tmustCreate(t, fc, ingressWithPaths(tt.paths))\n+\t\t\tmustCreate(t, fc, service())\n+\n+\t\t\texpectReconciled(t, ingR, \"default\", \"test\")\n+\n+\t\t\tfullName, shortName := findGenName(t, fc, \"default\", \"test\", \"ingress\")\n+\t\t\tmustCreate(t, fc, &corev1.Pod{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tName:      fullName,\n+\t\t\t\t\tNamespace: \"operator-ns\",\n+\t\t\t\t\tUID:       \"test-uid\",\n+\t\t\t\t},\n+\t\t\t})\n+\t\t\topts := configOpts{\n+\t\t\t\tstsName:    shortName,\n+\t\t\t\tsecretName: fullName,\n+\t\t\t\tnamespace:  \"default\",\n+\t\t\t\tparentType: \"ingress\",\n+\t\t\t\thostname:   \"foo\",\n+\t\t\t\tapp:        kubetypes.AppIngressResource,\n+\t\t\t}\n+\t\t\tserveConfig := &ipn.ServeConfig{\n+\t\t\t\tTCP: map[uint16]*ipn.TCPPortHandler{443: {HTTPS: true}},\n+\t\t\t\tWeb: map[ipn.HostPort]*ipn.WebServerConfig{\"${TS_CERT_DOMAIN}:443\": {Handlers: map[string]*ipn.HTTPHandler{\"/\": {Proxy: \"http://1.2.3.4:8080/\"}}}},\n+\t\t\t}\n+\t\t\topts.serveConfig = serveConfig\n+\n+\t\t\texpectEqual(t, fc, expectedSecret(t, fc, opts))\n+\t\t\texpectEqual(t, fc, expectedHeadlessService(shortName, \"ingress\"))\n+\t\t\texpectEqual(t, fc, expectedSTSUserspace(t, fc, opts), removeHashAnnotation, removeResourceReqs)\n+\n+\t\t\texpectEvents(t, fr, tt.expectedEvents)\n+\t\t})\n+\t}\n+}\n+\n+// ptrPathType is a helper function to return a pointer to the pathtype string (required for TestEmptyPath)\n+func ptrPathType(p networkingv1.PathType) *networkingv1.PathType {\n+\treturn &p\n+}\n+\n func ingressClass() *networkingv1.IngressClass {\n \treturn &networkingv1.IngressClass{\n \t\tObjectMeta: metav1.ObjectMeta{Name: \"tailscale\"},\n@@ -520,16 +653,47 @@ func ingress() *networkingv1.Ingress {\n \t\t},\n \t\tSpec: networkingv1.IngressSpec{\n \t\t\tIngressClassName: ptr.To(\"tailscale\"),\n-\t\t\tDefaultBackend: &networkingv1.IngressBackend{\n-\t\t\t\tService: &networkingv1.IngressServiceBackend{\n-\t\t\t\t\tName: \"test\",\n-\t\t\t\t\tPort: networkingv1.ServiceBackendPort{\n-\t\t\t\t\t\tNumber: 8080,\n+\t\t\tDefaultBackend:   backend(),\n+\t\t\tTLS: []networkingv1.IngressTLS{\n+\t\t\t\t{Hosts: []string{\"default-test\"}},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func ingressWithPaths(paths []networkingv1.HTTPIngressPath) *networkingv1.Ingress {\n+\treturn &networkingv1.Ingress{\n+\t\tTypeMeta: metav1.TypeMeta{Kind: \"Ingress\", APIVersion: \"networking.k8s.io/v1\"},\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      \"test\",\n+\t\t\tNamespace: \"default\",\n+\t\t\tUID:       types.UID(\"1234-UID\"),\n+\t\t},\n+\t\tSpec: networkingv1.IngressSpec{\n+\t\t\tIngressClassName: ptr.To(\"tailscale\"),\n+\t\t\tRules: []networkingv1.IngressRule{\n+\t\t\t\t{\n+\t\t\t\t\tHost: \"foo.tailnetxyz.ts.net\",\n+\t\t\t\t\tIngressRuleValue: networkingv1.IngressRuleValue{\n+\t\t\t\t\t\tHTTP: &networkingv1.HTTPIngressRuleValue{\n+\t\t\t\t\t\t\tPaths: paths,\n+\t\t\t\t\t\t},\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n \t\t\tTLS: []networkingv1.IngressTLS{\n-\t\t\t\t{Hosts: []string{\"default-test\"}},\n+\t\t\t\t{Hosts: []string{\"foo.tailnetxyz.ts.net\"}},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func backend() *networkingv1.IngressBackend {\n+\treturn &networkingv1.IngressBackend{\n+\t\tService: &networkingv1.IngressServiceBackend{\n+\t\t\tName: \"test\",\n+\t\t\tPort: networkingv1.ServiceBackendPort{\n+\t\t\t\tNumber: 8080,\n \t\t\t},\n \t\t},\n \t}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #cleanup\n\n---\n\nChoice A:\nnet/routetable/routetable_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package routetable\n \n---\nnet/routetable/routetable_other.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux && !darwin && !freebsd\n+//go:build android || (!linux && !darwin && !freebsd)\n \n package routetable\n \n---\nnet/tstun/linkattrs_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android\n+\n package tstun\n \n import (\n---\nnet/tstun/linkattrs_notlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux || android\n \n package tstun\n \n---\nwgengine/router/router_android.go\n@@ -0,0 +1,29 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build android\n+\n+package router\n+\n+import (\n+\t\"github.com/tailscale/wireguard-go/tun\"\n+\t\"tailscale.com/health\"\n+\t\"tailscale.com/net/netmon\"\n+\t\"tailscale.com/types/logger\"\n+)\n+\n+func newUserspaceRouter(logf logger.Logf, tunDev tun.Device, netMon *netmon.Monitor, health *health.Tracker) (Router, error) {\n+\t// Note, this codepath is _not_ used when building the android app\n+\t// from github.com/tailscale/tailscale-android. The android app\n+\t// constructs its own wgengine with a custom router implementation\n+\t// that plugs into Android networking APIs.\n+\t//\n+\t// In practice, the only place this fake router gets used is when\n+\t// you build a tsnet app for android, in which case we don't want\n+\t// to touch the OS network stack and a no-op router is correct.\n+\treturn NewFake(logf), nil\n+}\n+\n+func cleanUp(logf logger.Logf, interfaceName string) {\n+\t// Nothing to do here.\n+}\n---\nwgengine/router/router_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android\n+\n package router\n \n import (\n---\n\n\n---\n\nChoice B:\nipn/auditlog/extension.go\n@@ -22,7 +22,7 @@ import (\n )\n \n // featureName is the name of the feature implemented by this package.\n-// It is also the the [extension] name and the log prefix.\n+// It is also the [extension] name and the log prefix.\n const featureName = \"auditlog\"\n \n func init() {\n---\n\n\n---\n\nChoice C:\nnet/netmon/state.go\n@@ -27,8 +27,9 @@ import (\n // same interface and subnet.\n var forceAllIPv6Endpoints = envknob.RegisterBool(\"TS_DEBUG_FORCE_ALL_IPV6_ENDPOINTS\")\n \n-// set a debug knob to exclude interfaces from the list of interfaces\n-var excludedInterfaces = envknob.RegisterString(\"TS_DEBUG_EXCLUDED_INTERFACES\")\n+// suppressInterfaces is a debug knob containing a list of interface names that should not be advertised as endpoints. \n+// Traffic may still flow over these interfaces if system routing makes the decision to do so.\n+var excludeInterfaces = envknob.RegisterString(\"TS_DEBUG_EXCLUDE_INTERFACES\")\n \n // LoginEndpointForProxyDetermination is the URL used for testing\n // which HTTP proxy the system should use.\n@@ -54,7 +55,7 @@ func isExcludedInterface(nif *net.Interface) bool {\n \t\treturn false\n \t}\n \n-\tremain := excludedInterfaces()\n+\tremain := excludeInterfaces()\n \tfor remain != \"\" {\n \t\tvar candidate string\n \t\tcandidate, remain, _ = strings.Cut(remain, \",\")\n---\n\n\n---\n\nChoice D:\nbuild_dist.sh\n@@ -28,18 +28,26 @@ EOF\n \texit 0\n fi\n \n-tags=\"\"\n+tags=\"${TAGS:-}\"\n ldflags=\"-X tailscale.com/version.longStamp=${VERSION_LONG} -X tailscale.com/version.shortStamp=${VERSION_SHORT}\"\n \n # build_dist.sh arguments must precede go build arguments.\n while [ \"$#\" -gt 1 ]; do\n \tcase \"$1\" in\n \t--extra-small)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --extra-small or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\tldflags=\"$ldflags -w -s\"\n \t\ttags=\"${tags:+$tags,}ts_omit_aws,ts_omit_bird,ts_omit_tap,ts_omit_kube,ts_omit_completion,ts_omit_ssh,ts_omit_wakeonlan,ts_omit_capture\"\n \t\t;;\n \t--box)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --box or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\ttags=\"${tags:+$tags,}ts_include_cli\"\n \t\t;;\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n`[G,S]etWindowLongPtrW` are not available on 32-bit Windows, where `[G,S]etWindowLongW` should be used instead. The initial revision of #14945 imported the `win` package for calling and other Win32 API functions, which exported the correct API depending on the platform. However, the same logic wasn't implemented when we removed the win package dependency in a later revision, resulting in panics on Windows 10 x86 (there's no 32-bit Windows 11).\r\n\r\nIn this PR, we update the `ipn/desktop` package to use either `[G,S]etWindowLongPtrW` or `[G,S]etWindowLongW` depending on the platform.\r\n\r\nFixes #15684\r\n\r\nSigned-off-by: Nick Khyl <nickk@tailscale.com>\r\n\r\n(cherry picked from commit 60614fa)\n\n---\n\nChoice A:\nipn/desktop/mksyscall.go\n@@ -11,8 +11,6 @@ package desktop\n //sys registerClassEx(windowClass *_WNDCLASSEX) (atom uint16, err error) [atom==0] = user32.RegisterClassExW\n //sys createWindowEx(dwExStyle uint32, lpClassName *uint16, lpWindowName *uint16, dwStyle uint32, x int32, y int32, nWidth int32, nHeight int32, hWndParent windows.HWND, hMenu windows.Handle, hInstance windows.Handle, lpParam unsafe.Pointer) (hWnd windows.HWND, err error) [hWnd==0] = user32.CreateWindowExW\n //sys defWindowProc(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.DefWindowProcW\n-//sys setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) [res==0 && e1!=0] = user32.SetWindowLongPtrW\n-//sys getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) [res==0 && e1!=0] = user32.GetWindowLongPtrW\n //sys sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.SendMessageW\n //sys getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (ret int32) = user32.GetMessageW\n //sys translateMessage(lpMsg *_MSG) (res bool) = user32.TranslateMessage\n---\nipn/desktop/sessions_windows.go\n@@ -670,3 +670,38 @@ func (cs _WTS_CONNECTSTATE_CLASS) ToSessionStatus() SessionStatus {\n \t\treturn ClosedSession\n \t}\n }\n+\n+var (\n+\tprocGetWindowLongPtrW *windows.LazyProc\n+\tprocSetWindowLongPtrW *windows.LazyProc\n+)\n+\n+func init() {\n+\t// GetWindowLongPtrW and SetWindowLongPtrW are only available on 64-bit platforms.\n+\t// https://web.archive.org/web/20250414195520/https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw\n+\tif runtime.GOARCH == \"386\" || runtime.GOARCH == \"arm\" {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongW\")\n+\t} else {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongPtrW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongPtrW\")\n+\t}\n+}\n+\n+func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n---\nipn/desktop/zsyscall_windows.go\n@@ -48,11 +48,9 @@ var (\n \tprocDestroyWindow                      = moduser32.NewProc(\"DestroyWindow\")\n \tprocDispatchMessageW                   = moduser32.NewProc(\"DispatchMessageW\")\n \tprocGetMessageW                        = moduser32.NewProc(\"GetMessageW\")\n-\tprocGetWindowLongPtrW                  = moduser32.NewProc(\"GetWindowLongPtrW\")\n \tprocPostQuitMessage                    = moduser32.NewProc(\"PostQuitMessage\")\n \tprocRegisterClassExW                   = moduser32.NewProc(\"RegisterClassExW\")\n \tprocSendMessageW                       = moduser32.NewProc(\"SendMessageW\")\n-\tprocSetWindowLongPtrW                  = moduser32.NewProc(\"SetWindowLongPtrW\")\n \tprocTranslateMessage                   = moduser32.NewProc(\"TranslateMessage\")\n \tprocWTSRegisterSessionNotificationEx   = modwtsapi32.NewProc(\"WTSRegisterSessionNotificationEx\")\n \tprocWTSUnRegisterSessionNotificationEx = modwtsapi32.NewProc(\"WTSUnRegisterSessionNotificationEx\")\n@@ -98,15 +96,6 @@ func getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (r\n \treturn\n }\n \n-func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func postQuitMessage(exitCode int32) {\n \tsyscall.Syscall(procPostQuitMessage.Addr(), 1, uintptr(exitCode), 0, 0)\n \treturn\n@@ -127,15 +116,6 @@ func sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr)\n \treturn\n }\n \n-func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func translateMessage(lpMsg *_MSG) (res bool) {\n \tr0, _, _ := syscall.Syscall(procTranslateMessage.Addr(), 1, uintptr(unsafe.Pointer(lpMsg)), 0, 0)\n \tres = r0 != 0\n---\n\n\n---\n\nChoice B:\ntstest/integration/integration.go\n@@ -770,6 +770,27 @@ func (d *Daemon) MustCleanShutdown(t testing.TB) {\n \t}\n }\n \n+// awaitTailscaledRunnable tries to run `tailscaled --version` until it\n+// works. This is an unsatisfying workaround for ETXTBSY we were seeing\n+// on GitHub Actions that aren't understood. It's not clear what's holding\n+// a writable fd to tailscaled after `go install` completes.\n+// See https://github.com/tailscale/tailscale/issues/15868.\n+func (n *TestNode) awaitTailscaledRunnable() error {\n+\tt := n.env.t\n+\tt.Helper()\n+\tif err := tstest.WaitFor(10*time.Second, func() error {\n+\t\tout, err := exec.Command(n.env.daemon, \"--version\").CombinedOutput()\n+\t\tif err == nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\tt.Logf(\"error running tailscaled --version: %v, %s\", err, out)\n+\t\treturn err\n+\t}); err != nil {\n+\t\treturn fmt.Errorf(\"gave up trying to run tailscaled: %v\", err)\n+\t}\n+\treturn nil\n+}\n+\n // StartDaemon starts the node's tailscaled, failing if it fails to start.\n // StartDaemon ensures that the process will exit when the test completes.\n func (n *TestNode) StartDaemon() *Daemon {\n@@ -778,6 +799,11 @@ func (n *TestNode) StartDaemon() *Daemon {\n \n func (n *TestNode) StartDaemonAsIPNGOOS(ipnGOOS string) *Daemon {\n \tt := n.env.t\n+\n+\tif err := n.awaitTailscaledRunnable(); err != nil {\n+\t\tt.Fatalf(\"awaitTailscaledRunnable: %v\", err)\n+\t}\n+\n \tcmd := exec.Command(n.env.daemon)\n \tcmd.Args = append(cmd.Args,\n \t\t\"--statedir=\"+n.dir,\n---\n\n\n---\n\nChoice C:\ncmd/natc/ippool/consensusippool.go\n@@ -10,6 +10,8 @@ import (\n \t\"fmt\"\n \t\"log\"\n \t\"net/netip\"\n+\t\"os\"\n+\t\"path/filepath\"\n \t\"time\"\n \n \t\"github.com/hashicorp/raft\"\n@@ -150,9 +152,14 @@ func (ipp *ConsensusIPPool) domainLookup(from tailcfg.NodeID, addr netip.Addr) (\n }\n \n // StartConsensus is part of the IPPool interface. It starts the raft background routines that handle consensus.\n-func (ipp *ConsensusIPPool) StartConsensus(ctx context.Context, ts *tsnet.Server, clusterTag string) error {\n+func (ipp *ConsensusIPPool) StartConsensus(ctx context.Context, ts *tsnet.Server, clusterTag string, clusterStateDir string) error {\n \tcfg := tsconsensus.DefaultConfig()\n \tcfg.ServeDebugMonitor = true\n+\tvar err error\n+\tcfg.StateDirPath, err = getStatePath(clusterStateDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tcns, err := tsconsensus.Start(ctx, ts, ipp, clusterTag, cfg)\n \tif err != nil {\n \t\treturn err\n@@ -204,6 +211,30 @@ func (ps *consensusPerPeerState) unusedIPV4(ipset *netipx.IPSet, reuseDeadline t\n \treturn netip.Addr{}, false, \"\", errors.New(\"ip pool exhausted\")\n }\n \n+func getStatePath(pathFromFlag string) (string, error) {\n+\tvar dirPath string\n+\tif pathFromFlag != \"\" {\n+\t\tdirPath = pathFromFlag\n+\t} else {\n+\t\tconfDir, err := os.UserConfigDir()\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tdirPath = filepath.Join(confDir, \"nat-connector-cluster-state\")\n+\t}\n+\n+\tif err := os.MkdirAll(dirPath, 0700); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif fi, err := os.Stat(dirPath); err != nil {\n+\t\treturn \"\", err\n+\t} else if !fi.IsDir() {\n+\t\treturn \"\", fmt.Errorf(\"%v is not a directory\", dirPath)\n+\t}\n+\n+\treturn dirPath, nil\n+}\n+\n // isCloseToExpiry returns true if the lastUsed and now times are more than\n // half the lifetime apart\n func isCloseToExpiry(lastUsed, now time.Time, lifetime time.Duration) bool {\n---\ncmd/natc/natc.go\n@@ -59,6 +59,7 @@ func main() {\n \t\twgPort          = fs.Uint(\"wg-port\", 0, \"udp port for wireguard and peer to peer traffic\")\n \t\tclusterTag      = fs.String(\"cluster-tag\", \"\", \"optionally run in a consensus cluster with other nodes with this tag\")\n \t\tserver          = fs.String(\"login-server\", ipn.DefaultControlURL, \"the base URL of control server\")\n+\t\tclusterStateDir = fs.String(\"cluster-state-dir\", \"\", \"path to directory in which to store raft state\")\n \t)\n \tff.Parse(fs, os.Args[1:], ff.WithEnvVarPrefix(\"TS_NATC\"))\n \n@@ -155,7 +156,7 @@ func main() {\n \tvar ipp ippool.IPPool\n \tif *clusterTag != \"\" {\n \t\tcipp := ippool.NewConsensusIPPool(addrPool)\n-\t\terr = cipp.StartConsensus(ctx, ts, *clusterTag)\n+\t\terr = cipp.StartConsensus(ctx, ts, *clusterTag, *clusterStateDir)\n \t\tif err != nil {\n \t\t\tlog.Fatalf(\"StartConsensus: %v\", err)\n \t\t}\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/debug.go\n@@ -136,6 +136,17 @@ func debugCmd() *ffcli.Command {\n \t\t\t\tExec:       runLocalCreds,\n \t\t\t\tShortHelp:  \"Print how to access Tailscale LocalAPI\",\n \t\t\t},\n+\t\t\t{\n+\t\t\t\tName:       \"localapi\",\n+\t\t\t\tShortUsage: \"tailscale debug localapi [<method>] <path> [<body| \\\"-\\\">]\",\n+\t\t\t\tExec:       runLocalAPI,\n+\t\t\t\tShortHelp:  \"Call a LocalAPI method directly\",\n+\t\t\t\tFlagSet: (func() *flag.FlagSet {\n+\t\t\t\t\tfs := newFlagSet(\"localapi\")\n+\t\t\t\t\tfs.BoolVar(&localAPIFlags.verbose, \"v\", false, \"verbose; dump HTTP headers\")\n+\t\t\t\t\treturn fs\n+\t\t\t\t})(),\n+\t\t\t},\n \t\t\t{\n \t\t\t\tName:       \"restun\",\n \t\t\t\tShortUsage: \"tailscale debug restun\",\n@@ -451,6 +462,81 @@ func runLocalCreds(ctx context.Context, args []string) error {\n \treturn nil\n }\n \n+func looksLikeHTTPMethod(s string) bool {\n+\tif len(s) > len(\"OPTIONS\") {\n+\t\treturn false\n+\t}\n+\tfor _, r := range s {\n+\t\tif r < 'A' || r > 'Z' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+var localAPIFlags struct {\n+\tverbose bool\n+}\n+\n+func runLocalAPI(ctx context.Context, args []string) error {\n+\tif len(args) == 0 {\n+\t\treturn errors.New(\"expected at least one argument\")\n+\t}\n+\tmethod := \"GET\"\n+\tif looksLikeHTTPMethod(args[0]) {\n+\t\tmethod = args[0]\n+\t\targs = args[1:]\n+\t\tif len(args) == 0 {\n+\t\t\treturn errors.New(\"expected at least one argument after method\")\n+\t\t}\n+\t}\n+\tpath := args[0]\n+\tif !strings.HasPrefix(path, \"/localapi/\") {\n+\t\tif !strings.Contains(path, \"/\") {\n+\t\t\tpath = \"/localapi/v0/\" + path\n+\t\t} else {\n+\t\t\tpath = \"/localapi/\" + path\n+\t\t}\n+\t}\n+\n+\tvar body io.Reader\n+\tif len(args) > 1 {\n+\t\tif args[1] == \"-\" {\n+\t\t\tfmt.Fprintf(Stderr, \"# reading request body from stdin...\\n\")\n+\t\t\tall, err := io.ReadAll(os.Stdin)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"reading Stdin: %q\", err)\n+\t\t\t}\n+\t\t\tbody = bytes.NewReader(all)\n+\t\t} else {\n+\t\t\tbody = strings.NewReader(args[1])\n+\t\t}\n+\t}\n+\treq, err := http.NewRequest(method, \"http://local-tailscaled.sock\"+path, body)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tfmt.Fprintf(Stderr, \"# doing request %s %s\\n\", method, path)\n+\n+\tres, err := localClient.DoLocalRequest(req)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tis2xx := res.StatusCode >= 200 && res.StatusCode <= 299\n+\tif localAPIFlags.verbose {\n+\t\tres.Write(Stdout)\n+\t} else {\n+\t\tif !is2xx {\n+\t\t\tfmt.Fprintf(Stderr, \"# Response status %s\\n\", res.Status)\n+\t\t}\n+\t\tio.Copy(Stdout, res.Body)\n+\t}\n+\tif is2xx {\n+\t\treturn nil\n+\t}\n+\treturn errors.New(res.Status)\n+}\n+\n type localClientRoundTripper struct{}\n \n func (localClientRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #15691\n\n\n---\n\nChoice A:\nipn/ipnlocal/local_test.go\n@@ -15,6 +15,7 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n+\t\"runtime\"\n \t\"slices\"\n \t\"strings\"\n \t\"sync\"\n@@ -2596,6 +2597,9 @@ func TestPreferencePolicyInfo(t *testing.T) {\n }\n \n func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n+\tif runtime.GOOS == \"darwin\" {\n+\t\tt.Skip(\"test known broken on macOS; see https://github.com/tailscale/tailscale/issues/15691\")\n+\t}\n \ttests := []struct {\n \t\tbefore, after  opt.Bool\n \t\tcontainer      opt.Bool\n---\n\n\n---\n\nChoice B:\ncmd/tailscale/cli/up_test.go\n@@ -0,0 +1,55 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package cli\n+\n+import (\n+\t\"flag\"\n+\t\"testing\"\n+\n+\t\"tailscale.com/util/set\"\n+)\n+\n+// validUpFlags are the only flags that are valid for tailscale up. The up\n+// command is frozen: no new preferences can be added. Instead, add them to\n+// tailscale set.\n+// See tailscale/tailscale#15460.\n+var validUpFlags = set.Of(\n+\t\"accept-dns\",\n+\t\"accept-risk\",\n+\t\"accept-routes\",\n+\t\"advertise-connector\",\n+\t\"advertise-exit-node\",\n+\t\"advertise-routes\",\n+\t\"advertise-tags\",\n+\t\"auth-key\",\n+\t\"exit-node\",\n+\t\"exit-node-allow-lan-access\",\n+\t\"force-reauth\",\n+\t\"host-routes\",\n+\t\"hostname\",\n+\t\"json\",\n+\t\"login-server\",\n+\t\"netfilter-mode\",\n+\t\"nickname\",\n+\t\"operator\",\n+\t\"posture-checking\",\n+\t\"qr\",\n+\t\"reset\",\n+\t\"shields-up\",\n+\t\"snat-subnet-routes\",\n+\t\"ssh\",\n+\t\"stateful-filtering\",\n+\t\"timeout\",\n+\t\"unattended\",\n+)\n+\n+// TestUpFlagSetIsFrozen complains when new flags are added to tailscale up.\n+func TestUpFlagSetIsFrozen(t *testing.T) {\n+\tupFlagSet.VisitAll(func(f *flag.Flag) {\n+\t\tname := f.Name\n+\t\tif !validUpFlags.Contains(name) {\n+\t\t\tt.Errorf(\"--%s flag added to tailscale up, new prefs go in tailscale set: see tailscale/tailscale#15460\", name)\n+\t\t}\n+\t})\n+}\n---\n\n\n---\n\nChoice C:\nipn/desktop/mksyscall.go\n@@ -11,8 +11,6 @@ package desktop\n //sys registerClassEx(windowClass *_WNDCLASSEX) (atom uint16, err error) [atom==0] = user32.RegisterClassExW\n //sys createWindowEx(dwExStyle uint32, lpClassName *uint16, lpWindowName *uint16, dwStyle uint32, x int32, y int32, nWidth int32, nHeight int32, hWndParent windows.HWND, hMenu windows.Handle, hInstance windows.Handle, lpParam unsafe.Pointer) (hWnd windows.HWND, err error) [hWnd==0] = user32.CreateWindowExW\n //sys defWindowProc(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.DefWindowProcW\n-//sys setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) [res==0 && e1!=0] = user32.SetWindowLongPtrW\n-//sys getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) [res==0 && e1!=0] = user32.GetWindowLongPtrW\n //sys sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.SendMessageW\n //sys getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (ret int32) = user32.GetMessageW\n //sys translateMessage(lpMsg *_MSG) (res bool) = user32.TranslateMessage\n---\nipn/desktop/sessions_windows.go\n@@ -670,3 +670,38 @@ func (cs _WTS_CONNECTSTATE_CLASS) ToSessionStatus() SessionStatus {\n \t\treturn ClosedSession\n \t}\n }\n+\n+var (\n+\tprocGetWindowLongPtrW *windows.LazyProc\n+\tprocSetWindowLongPtrW *windows.LazyProc\n+)\n+\n+func init() {\n+\t// GetWindowLongPtrW and SetWindowLongPtrW are only available on 64-bit platforms.\n+\t// https://web.archive.org/web/20250414195520/https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw\n+\tif runtime.GOARCH == \"386\" || runtime.GOARCH == \"arm\" {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongW\")\n+\t} else {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongPtrW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongPtrW\")\n+\t}\n+}\n+\n+func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n---\nipn/desktop/zsyscall_windows.go\n@@ -48,11 +48,9 @@ var (\n \tprocDestroyWindow                      = moduser32.NewProc(\"DestroyWindow\")\n \tprocDispatchMessageW                   = moduser32.NewProc(\"DispatchMessageW\")\n \tprocGetMessageW                        = moduser32.NewProc(\"GetMessageW\")\n-\tprocGetWindowLongPtrW                  = moduser32.NewProc(\"GetWindowLongPtrW\")\n \tprocPostQuitMessage                    = moduser32.NewProc(\"PostQuitMessage\")\n \tprocRegisterClassExW                   = moduser32.NewProc(\"RegisterClassExW\")\n \tprocSendMessageW                       = moduser32.NewProc(\"SendMessageW\")\n-\tprocSetWindowLongPtrW                  = moduser32.NewProc(\"SetWindowLongPtrW\")\n \tprocTranslateMessage                   = moduser32.NewProc(\"TranslateMessage\")\n \tprocWTSRegisterSessionNotificationEx   = modwtsapi32.NewProc(\"WTSRegisterSessionNotificationEx\")\n \tprocWTSUnRegisterSessionNotificationEx = modwtsapi32.NewProc(\"WTSUnRegisterSessionNotificationEx\")\n@@ -98,15 +96,6 @@ func getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (r\n \treturn\n }\n \n-func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func postQuitMessage(exitCode int32) {\n \tsyscall.Syscall(procPostQuitMessage.Addr(), 1, uintptr(exitCode), 0, 0)\n \treturn\n@@ -127,15 +116,6 @@ func sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr)\n \treturn\n }\n \n-func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func translateMessage(lpMsg *_MSG) (res bool) {\n \tr0, _, _ := syscall.Syscall(procTranslateMessage.Addr(), 1, uintptr(unsafe.Pointer(lpMsg)), 0, 0)\n \tres = r0 != 0\n---\n\n\n---\n\nChoice D:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/init@28deaeda66b76a05916b6923827895f2b14ab387 # v3.28.16\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/autobuild@28deaeda66b76a05916b6923827895f2b14ab387 # v3.28.16\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/analyze@28deaeda66b76a05916b6923827895f2b14ab387 # v3.28.16\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nQuery for the const quad-100 reverse DNS name, for which a forward record will also be served. This test was previously dependent on search domain behavior, and now it is not.\r\n\r\nUpdates #15607\n\n---\n\nChoice A:\nlogtail/logtail.go\n@@ -15,9 +15,7 @@ import (\n \t\"log\"\n \tmrand \"math/rand/v2\"\n \t\"net/http\"\n-\t\"net/netip\"\n \t\"os\"\n-\t\"regexp\"\n \t\"runtime\"\n \t\"slices\"\n \t\"strconv\"\n@@ -29,7 +27,6 @@ import (\n \t\"tailscale.com/envknob\"\n \t\"tailscale.com/net/netmon\"\n \t\"tailscale.com/net/sockstats\"\n-\t\"tailscale.com/net/tsaddr\"\n \t\"tailscale.com/tstime\"\n \ttslogger \"tailscale.com/types/logger\"\n \t\"tailscale.com/types/logid\"\n@@ -833,8 +830,6 @@ func (l *Logger) Logf(format string, args ...any) {\n \tfmt.Fprintf(l, format, args...)\n }\n \n-var obscureIPs = envknob.RegisterBool(\"TS_OBSCURE_LOGGED_IPS\")\n-\n // Write logs an encoded JSON blob.\n //\n // If the []byte passed to Write is not an encoded JSON blob,\n@@ -859,10 +854,6 @@ func (l *Logger) Write(buf []byte) (int, error) {\n \t\t}\n \t}\n \n-\tif obscureIPs() {\n-\t\tbuf = redactIPs(buf)\n-\t}\n-\n \tl.writeLock.Lock()\n \tdefer l.writeLock.Unlock()\n \n@@ -871,40 +862,6 @@ func (l *Logger) Write(buf []byte) (int, error) {\n \treturn inLen, err\n }\n \n-var (\n-\tregexMatchesIPv6 = regexp.MustCompile(`([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4}):([0-9a-fA-F:]{1,4})*`)\n-\tregexMatchesIPv4 = regexp.MustCompile(`(\\d{1,3})\\.(\\d{1,3})\\.\\d{1,3}\\.\\d{1,3}`)\n-)\n-\n-// redactIPs is a helper function used in Write() to redact IPs (other than tailscale IPs).\n-// This function takes a log line as a byte slice and\n-// uses regex matching to parse and find IP addresses. Based on if the IP address is IPv4 or\n-// IPv6, it parses and replaces the end of the addresses with an \"x\". This function returns the\n-// log line with the IPs redacted.\n-func redactIPs(buf []byte) []byte {\n-\tout := regexMatchesIPv6.ReplaceAllFunc(buf, func(b []byte) []byte {\n-\t\tip, err := netip.ParseAddr(string(b))\n-\t\tif err != nil || tsaddr.IsTailscaleIP(ip) {\n-\t\t\treturn b // don't change this one\n-\t\t}\n-\n-\t\tprefix := bytes.Split(b, []byte(\":\"))\n-\t\treturn bytes.Join(append(prefix[:2], []byte(\"x\")), []byte(\":\"))\n-\t})\n-\n-\tout = regexMatchesIPv4.ReplaceAllFunc(out, func(b []byte) []byte {\n-\t\tip, err := netip.ParseAddr(string(b))\n-\t\tif err != nil || tsaddr.IsTailscaleIP(ip) {\n-\t\t\treturn b // don't change this one\n-\t\t}\n-\n-\t\tprefix := bytes.Split(b, []byte(\".\"))\n-\t\treturn bytes.Join(append(prefix[:2], []byte(\"x.x\")), []byte(\".\"))\n-\t})\n-\n-\treturn []byte(out)\n-}\n-\n var (\n \topenBracketV = []byte(\"[v\")\n \tv1           = []byte(\"[v1] \")\n---\nlogtail/logtail_test.go\n@@ -15,7 +15,6 @@ import (\n \t\"time\"\n \n \t\"github.com/go-json-experiment/json/jsontext\"\n-\t\"tailscale.com/envknob\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/tstime\"\n \t\"tailscale.com/util/must\"\n@@ -316,85 +315,6 @@ func TestLoggerWriteResult(t *testing.T) {\n \t\tt.Errorf(\"mismatch.\\n got: %#q\\nwant: %#q\", back, want)\n \t}\n }\n-func TestRedact(t *testing.T) {\n-\tenvknob.Setenv(\"TS_OBSCURE_LOGGED_IPS\", \"true\")\n-\ttests := []struct {\n-\t\tin   string\n-\t\twant string\n-\t}{\n-\t\t// tests for ipv4 addresses\n-\t\t{\n-\t\t\t\"120.100.30.47\",\n-\t\t\t\"120.100.x.x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"192.167.0.1/65\",\n-\t\t\t\"192.167.x.x/65\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.0.222:41641 mtu=1360 tx=d81a8a35a0ce\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.x.x:41641 mtu=1360 tx=d81a8a35a0ce\",\n-\t\t},\n-\t\t//tests for ipv6 addresses\n-\t\t{\n-\t\t\t\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"2001:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2345:0425:2CA1:0000:0000:0567:5673:23b5\",\n-\t\t\t\"2345:0425:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2601:645:8200:edf0::c9de/64\",\n-\t\t\t\"2601:645:x/64\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 2051:0000:140F::875B:131C mtu=1360 tx=d81a8a35a0ce\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 2051:0000:x mtu=1360 tx=d81a8a35a0ce\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2601:645:8200:edf0::c9de/64 2601:645:8200:edf0:1ce9:b17d:71f5:f6a3/64\",\n-\t\t\t\"2601:645:x/64 2601:645:x/64\",\n-\t\t},\n-\t\t//tests for tailscale ip addresses\n-\t\t{\n-\t\t\t\"100.64.5.6\",\n-\t\t\t\"100.64.5.6\",\n-\t\t},\n-\t\t{\n-\t\t\t\"fd7a:115c:a1e0::/96\",\n-\t\t\t\"fd7a:115c:a1e0::/96\",\n-\t\t},\n-\t\t//tests for ipv6 and ipv4 together\n-\t\t{\n-\t\t\t\"192.167.0.1 2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"192.167.x.x 2001:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.0.222:41641 mtu=1360 tx=d81a8a35a0ce 2345:0425:2CA1::0567:5673:23b5\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.x.x:41641 mtu=1360 tx=d81a8a35a0ce 2345:0425:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"100.64.5.6 2091:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"100.64.5.6 2091:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"192.167.0.1 120.100.30.47 2041:0000:140F::875B:131B\",\n-\t\t\t\"192.167.x.x 120.100.x.x 2041:0000:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"fd7a:115c:a1e0::/96 192.167.0.1 2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"fd7a:115c:a1e0::/96 192.167.x.x 2001:0db8:x\",\n-\t\t},\n-\t}\n-\n-\tfor _, tt := range tests {\n-\t\tgotBuf := redactIPs([]byte(tt.in))\n-\t\tif string(gotBuf) != tt.want {\n-\t\t\tt.Errorf(\"for %q,\\n got: %#q\\nwant: %#q\\n\", tt.in, gotBuf, tt.want)\n-\t\t}\n-\t}\n-}\n \n func TestAppendMetadata(t *testing.T) {\n \tvar l Logger\n---\n\n\n---\n\nChoice B:\ntstest/integration/integration_test.go\n@@ -51,7 +51,6 @@ import (\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/types/opt\"\n \t\"tailscale.com/types/ptr\"\n-\t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/must\"\n \t\"tailscale.com/util/rands\"\n \t\"tailscale.com/version\"\n@@ -1140,18 +1139,9 @@ func TestDNSOverTCPIntervalResolver(t *testing.T) {\n \n \tn1.AwaitResponding()\n \tn1.MustUp()\n-\n-\twantIP4 := n1.AwaitIP4()\n \tn1.AwaitRunning()\n \n-\tstatus, err := n1.Status()\n-\tif err != nil {\n-\t\tt.Fatalf(\"failed to get node status: %v\", err)\n-\t}\n-\tselfDNSName, err := dnsname.ToFQDN(status.Self.DNSName)\n-\tif err != nil {\n-\t\tt.Fatalf(\"error converting self dns name to fqdn: %v\", err)\n-\t}\n+\tconst dnsSymbolicFQDN = \"magicdns.localhost-tailscale-daemon.\"\n \n \tcases := []struct {\n \t\tnetwork     string\n@@ -1167,9 +1157,9 @@ func TestDNSOverTCPIntervalResolver(t *testing.T) {\n \t\t},\n \t}\n \tfor _, c := range cases {\n-\t\terr = tstest.WaitFor(time.Second*5, func() error {\n+\t\terr := tstest.WaitFor(time.Second*5, func() error {\n \t\t\tm := new(dns.Msg)\n-\t\t\tm.SetQuestion(selfDNSName.WithTrailingDot(), dns.TypeA)\n+\t\t\tm.SetQuestion(dnsSymbolicFQDN, dns.TypeA)\n \t\t\tconn, err := net.DialTimeout(c.network, net.JoinHostPort(c.serviceAddr.String(), \"53\"), time.Second*1)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n@@ -1194,8 +1184,8 @@ func TestDNSOverTCPIntervalResolver(t *testing.T) {\n \t\t\t\treturn fmt.Errorf(\"unexpected answer type: %s\", resp.Answer[0])\n \t\t\t}\n \t\t\tgotAddr = answer.A\n-\t\t\tif !bytes.Equal(gotAddr, wantIP4.AsSlice()) {\n-\t\t\t\treturn fmt.Errorf(\"got (%s) != want (%s)\", gotAddr, wantIP4)\n+\t\t\tif !bytes.Equal(gotAddr, tsaddr.TailscaleServiceIP().AsSlice()) {\n+\t\t\t\treturn fmt.Errorf(\"got (%s) != want (%s)\", gotAddr, tsaddr.TailscaleServiceIP())\n \t\t\t}\n \t\t\treturn nil\n \t\t})\n---\n\n\n---\n\nChoice C:\nprober/prober.go\n@@ -559,8 +559,8 @@ func (p *Prober) RunHandler(w http.ResponseWriter, r *http.Request) error {\n \t\t\tPreviousSuccessRatio:  prevInfo.RecentSuccessRatio(),\n \t\t\tPreviousMedianLatency: prevInfo.RecentMedianLatency(),\n \t\t}\n-\t\tw.WriteHeader(respStatus)\n \t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tw.WriteHeader(respStatus)\n \t\tif err := json.NewEncoder(w).Encode(resp); err != nil {\n \t\t\treturn tsweb.Error(http.StatusInternalServerError, \"error encoding JSON response\", err)\n \t\t}\n---\nprober/prober_test.go\n@@ -598,6 +598,9 @@ func TestProberRunHandler(t *testing.T) {\n \t\t\t\t}\n \n \t\t\t\tif reqJSON {\n+\t\t\t\t\tif w.Header().Get(\"Content-Type\") != \"application/json\" {\n+\t\t\t\t\t\tt.Errorf(\"unexpected content type: got %q, want application/json\", w.Header().Get(\"Content-Type\"))\n+\t\t\t\t\t}\n \t\t\t\t\tvar gotJSON RunHandlerResponse\n \t\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), &gotJSON); err != nil {\n \t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, w.Body.String())\n---\n\n\n---\n\nChoice D:\ncmd/tsidp/Dockerfile\n@@ -31,11 +31,11 @@ WORKDIR /app\n \n # Environment variables\n ENV TAILSCALE_USE_WIP_CODE=1 \\\n-    TS_HOSTNAME=tsidp \\\n+    TS_HOSTNAME=idp \\\n     TS_STATE_DIR=/var/lib/tsidp\n \n # Expose the default port\n EXPOSE 443\n \n # Run the application\n-ENTRYPOINT [\"/app/tsidp\"]\n\\ No newline at end of file\n+ENTRYPOINT [\"/bin/sh\", \"-c\", \"/app/tsidp --hostname=${TS_HOSTNAME} --dir=${TS_STATE_DIR}\"]\n---\ncmd/tsidp/README.md\n@@ -38,7 +38,7 @@\n      --name `tsidp` \\\n      -p 443:443 \\\n      -e TS_AUTHKEY=YOUR_TAILSCALE_AUTHKEY \\\n-     -e TS_HOSTNAME=tsidp \\\n+     -e TS_HOSTNAME=idp \\\n      -v tsidp-data:/var/lib/tsidp \\\n      tsidp:latest\n    ```\n@@ -48,7 +48,7 @@\n    docker logs tsidp\n    ```\n \n-   Visit `https://tsidp.tailnet.ts.net` to confirm the service is running.\n+   Visit `https://idp.tailnet.ts.net` to confirm the service is running.\n \n ## Usage Example: Proxmox Integration\n \n@@ -82,13 +82,14 @@ The `tsidp` server supports several command-line flags:\n - `--port`: Port to listen on (default: 443)\n - `--local-port`: Allow requests from localhost\n - `--use-local-tailscaled`: Use local tailscaled instead of tsnet\n+- `--hostname`: tsnet hostname\n - `--dir`: tsnet state directory\n \n ## Environment Variables\n \n - `TS_AUTHKEY`: Your Tailscale authentication key (required)\n-- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\")\n-- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\")\n+- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\", Docker only)\n+- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\", Docker only)\n - `TAILSCALE_USE_WIP_CODE`: Enable work-in-progress code (default: \"1\")\n \n ## Support\n@@ -97,4 +98,4 @@ This is an [experimental](https://tailscale.com/kb/1167/release-stages#experimen\n \n ## License\n \n-BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n\\ No newline at end of file\n+BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n---\ncmd/tsidp/tsidp.go\n@@ -65,6 +65,7 @@ var (\n \tflagLocalPort          = flag.Int(\"local-port\", -1, \"allow requests from localhost\")\n \tflagUseLocalTailscaled = flag.Bool(\"use-local-tailscaled\", false, \"use local tailscaled instead of tsnet\")\n \tflagFunnel             = flag.Bool(\"funnel\", false, \"use Tailscale Funnel to make tsidp available on the public internet\")\n+\tflagHostname           = flag.String(\"hostname\", \"idp\", \"tsnet hostname to use instead of idp\")\n \tflagDir                = flag.String(\"dir\", \"\", \"tsnet state directory; a default one will be created if not provided\")\n )\n \n@@ -121,7 +122,7 @@ func main() {\n \t\tdefer cleanup()\n \t} else {\n \t\tts := &tsnet.Server{\n-\t\t\tHostname: \"idp\",\n+\t\t\tHostname: *flagHostname,\n \t\t\tDir:      *flagDir,\n \t\t}\n \t\tif *flagVerbose {\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n`[G,S]etWindowLongPtrW` are not available on 32-bit Windows, where `[G,S]etWindowLongW` should be used instead. The initial revision of #14945 imported the win package for calling and other Win32 API functions, which exported the correct API depending on the platform. However, the same logic wasn't implemented when we removed the win package dependency in a later revision, resulting in panics on Windows 10 x86 (there's no 32-bit Windows 11).\r\n\r\nIn this PR, we update the `ipn/desktop` package to use either `[G,S]etWindowLongPtrW` or `[G,S]etWindowLongW` depending on the platform.\r\n\r\nFixes #15684\n\n---\n\nChoice A:\nwgengine/magicsock/magicsock_linux.go\n@@ -66,10 +66,10 @@ var (\n \t\t// fragmented, and we don't want to handle reassembly.\n \t\tbpf.LoadAbsolute{Off: 6, Size: 2},\n \t\t// More Fragments bit set means this is part of a fragmented packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 7, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 8, SkipFalse: 0},\n \t\t// Non-zero fragment offset with MF=0 means this is the last\n \t\t// fragment of packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 6, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 7, SkipFalse: 0},\n \n \t\t// Load IP header length into X register.\n \t\tbpf.LoadMemShift{Off: 0},\n---\nwgengine/magicsock/magicsock_linux_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"net/netip\"\n \t\"testing\"\n \n+\t\"golang.org/x/net/bpf\"\n \t\"golang.org/x/sys/cpu\"\n \t\"golang.org/x/sys/unix\"\n \t\"tailscale.com/disco\"\n@@ -146,3 +147,78 @@ func TestEthernetProto(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestBpfDiscardV4(t *testing.T) {\n+\t// Good packet as a reference for what should not be rejected\n+\tudp4Packet := []byte{\n+\t\t// IPv4 header\n+\t\t0x45, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x40, 0x11, 0x00, 0x00,\n+\t\t0x7f, 0x00, 0x00, 0x01, // source ip\n+\t\t0x7f, 0x00, 0x00, 0x02, // dest ip\n+\n+\t\t// UDP header\n+\t\t0x30, 0x39, // src port\n+\t\t0xd4, 0x31, // dest port\n+\t\t0x00, 0x12, // length; 8 bytes header + 10 bytes payload = 18 bytes\n+\t\t0x00, 0x00, // checksum; unused\n+\n+\t\t// Payload: disco magic plus 32 bytes for key and 24 bytes for nonce\n+\t\t0x54, 0x53, 0xf0, 0x9f, 0x92, 0xac, 0x00, 0x01, 0x02, 0x03,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n+\t}\n+\n+\tvm, err := bpf.NewVM(magicsockFilterV4)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed creating BPF VM: %v\", err)\n+\t}\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\treplace map[int]byte\n+\t\taccept  bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"base accepted datagram\",\n+\t\t\treplace: map[int]byte{},\n+\t\t\taccept:  true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"more fragments\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t6: 0x20,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some fragment\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t7: 0x01,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t}\n+\n+\tudp4PacketChanged := make([]byte, len(udp4Packet))\n+\tcopy(udp4PacketChanged, udp4Packet)\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfor k, v := range tt.replace {\n+\t\t\t\tudp4PacketChanged[k] = v\n+\t\t\t}\n+\t\t\tret, err := vm.Run(udp4PacketChanged)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"BPF VM error: %v\", err)\n+\t\t\t}\n+\n+\t\t\tif (ret != 0) != tt.accept {\n+\t\t\t\tt.Errorf(\"expected accept=%v, got ret=%v\", tt.accept, ret)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice B:\nipn/ipnext/ipnext.go\n@@ -114,7 +114,7 @@ func RegisterExtension(name string, newExt NewExtensionFn) {\n \t\tpanic(fmt.Sprintf(\"ipnext: newExt is nil: %q\", name))\n \t}\n \tif extensions.Contains(name) {\n-\t\tpanic(fmt.Sprintf(\"ipnext: duplicate extensions: %q\", name))\n+\t\tpanic(fmt.Sprintf(\"ipnext: duplicate extension name %q\", name))\n \t}\n \textensions.Set(name, &Definition{name, newExt})\n }\n---\nipn/ipnlocal/extension_host.go\n@@ -22,6 +22,7 @@ import (\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/execqueue\"\n+\t\"tailscale.com/util/mak\"\n \t\"tailscale.com/util/testenv\"\n )\n \n@@ -97,7 +98,8 @@ type ExtensionHost struct {\n \tinitialized atomic.Bool\n \t// activeExtensions is a subset of allExtensions that have been initialized and are ready to use.\n \tactiveExtensions []ipnext.Extension\n-\t// extensionsByName are the activeExtensions indexed by their names.\n+\t// extensionsByName are the extensions indexed by their names.\n+\t// They are not necessarily initialized (in activeExtensions) yet.\n \textensionsByName map[string]ipnext.Extension\n \t// postInitWorkQueue is a queue of functions to be executed\n \t// by the workQueue after all extensions have been initialized.\n@@ -184,6 +186,24 @@ func newExtensionHost(logf logger.Logf, b Backend, overrideExts ...*ipnext.Defin\n \t\t\treturn nil, fmt.Errorf(\"failed to create %q extension: %v\", d.Name(), err)\n \t\t}\n \t\thost.allExtensions = append(host.allExtensions, ext)\n+\n+\t\tif d.Name() != ext.Name() {\n+\t\t\treturn nil, fmt.Errorf(\"extension name %q does not match the registered name %q\", ext.Name(), d.Name())\n+\t\t}\n+\n+\t\tif _, ok := host.extensionsByName[ext.Name()]; ok {\n+\t\t\treturn nil, fmt.Errorf(\"duplicate extension name %q\", ext.Name())\n+\t\t} else {\n+\t\t\tmak.Set(&host.extensionsByName, ext.Name(), ext)\n+\t\t}\n+\n+\t\ttyp := reflect.TypeOf(ext)\n+\t\tif _, ok := host.extByType.Load(typ); ok {\n+\t\t\tif _, ok := ext.(interface{ PermitDoubleRegister() }); !ok {\n+\t\t\t\treturn nil, fmt.Errorf(\"duplicate extension type %T\", ext)\n+\t\t\t}\n+\t\t}\n+\t\thost.extByType.Store(typ, ext)\n \t}\n \treturn host, nil\n }\n@@ -215,10 +235,6 @@ func (h *ExtensionHost) init() {\n \tdefer h.initDone.Store(true)\n \n \t// Initialize the extensions in the order they were registered.\n-\th.mu.Lock()\n-\th.activeExtensions = make([]ipnext.Extension, 0, len(h.allExtensions))\n-\th.extensionsByName = make(map[string]ipnext.Extension, len(h.allExtensions))\n-\th.mu.Unlock()\n \tfor _, ext := range h.allExtensions {\n \t\t// Do not hold the lock while calling [ipnext.Extension.Init].\n \t\t// Extensions call back into the host to register their callbacks,\n@@ -240,8 +256,6 @@ func (h *ExtensionHost) init() {\n \t\t// We'd like to make them visible to other extensions that are initialized later.\n \t\th.mu.Lock()\n \t\th.activeExtensions = append(h.activeExtensions, ext)\n-\t\th.extensionsByName[ext.Name()] = ext\n-\t\th.extByType.Store(reflect.TypeOf(ext), ext)\n \t\th.mu.Unlock()\n \t}\n \n---\nipn/ipnlocal/extension_host_test.go\n@@ -30,6 +30,7 @@ import (\n \t\"tailscale.com/tstime\"\n \t\"tailscale.com/types/key\"\n \t\"tailscale.com/types/lazy\"\n+\t\"tailscale.com/types/logger\"\n \t\"tailscale.com/types/persist\"\n \t\"tailscale.com/util/must\"\n )\n@@ -1042,6 +1043,38 @@ func TestNilExtensionHostMethodCall(t *testing.T) {\n \t}\n }\n \n+// extBeforeStartExtension is a test extension used by TestGetExtBeforeStart.\n+// It is registered with the [ipnext.RegisterExtension].\n+type extBeforeStartExtension struct{}\n+\n+func init() {\n+\tipnext.RegisterExtension(\"ext-before-start\", mkExtBeforeStartExtension)\n+}\n+\n+func mkExtBeforeStartExtension(logger.Logf, ipnext.SafeBackend) (ipnext.Extension, error) {\n+\treturn extBeforeStartExtension{}, nil\n+}\n+\n+func (extBeforeStartExtension) Name() string { return \"ext-before-start\" }\n+func (extBeforeStartExtension) Init(ipnext.Host) error {\n+\treturn nil\n+}\n+func (extBeforeStartExtension) Shutdown() error {\n+\treturn nil\n+}\n+\n+// TestGetExtBeforeStart verifies that an extension registered via\n+// RegisterExtension can be retrieved with GetExt before the host is started\n+// (via LocalBackend.Start)\n+func TestGetExtBeforeStart(t *testing.T) {\n+\tlb := newTestBackend(t)\n+\t// Now call GetExt without calling Start on the LocalBackend.\n+\t_, ok := GetExt[extBeforeStartExtension](lb)\n+\tif !ok {\n+\t\tt.Fatal(\"didn't find extension\")\n+\t}\n+}\n+\n // checkMethodCallWithZeroArgs calls the method m on the receiver r\n // with zero values for all its arguments, except the receiver itself.\n // It returns the result of the method call, or fails the test if the call panics.\n@@ -1151,6 +1184,10 @@ type testExtension struct {\n \n var _ ipnext.Extension = (*testExtension)(nil)\n \n+// PermitDoubleRegister is a sentinel method whose existence tells the\n+// ExtensionHost to permit it to be registered multiple times.\n+func (*testExtension) PermitDoubleRegister() {}\n+\n func (e *testExtension) setT(t *testing.T) {\n \te.t = t\n }\n---\n\n\n---\n\nChoice C:\nipn/desktop/mksyscall.go\n@@ -11,8 +11,6 @@ package desktop\n //sys registerClassEx(windowClass *_WNDCLASSEX) (atom uint16, err error) [atom==0] = user32.RegisterClassExW\n //sys createWindowEx(dwExStyle uint32, lpClassName *uint16, lpWindowName *uint16, dwStyle uint32, x int32, y int32, nWidth int32, nHeight int32, hWndParent windows.HWND, hMenu windows.Handle, hInstance windows.Handle, lpParam unsafe.Pointer) (hWnd windows.HWND, err error) [hWnd==0] = user32.CreateWindowExW\n //sys defWindowProc(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.DefWindowProcW\n-//sys setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) [res==0 && e1!=0] = user32.SetWindowLongPtrW\n-//sys getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) [res==0 && e1!=0] = user32.GetWindowLongPtrW\n //sys sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.SendMessageW\n //sys getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (ret int32) = user32.GetMessageW\n //sys translateMessage(lpMsg *_MSG) (res bool) = user32.TranslateMessage\n---\nipn/desktop/sessions_windows.go\n@@ -670,3 +670,38 @@ func (cs _WTS_CONNECTSTATE_CLASS) ToSessionStatus() SessionStatus {\n \t\treturn ClosedSession\n \t}\n }\n+\n+var (\n+\tprocGetWindowLongPtrW *windows.LazyProc\n+\tprocSetWindowLongPtrW *windows.LazyProc\n+)\n+\n+func init() {\n+\t// GetWindowLongPtrW and SetWindowLongPtrW are only available on 64-bit platforms.\n+\t// https://web.archive.org/web/20250414195520/https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw\n+\tif runtime.GOARCH == \"386\" || runtime.GOARCH == \"arm\" {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongW\")\n+\t} else {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongPtrW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongPtrW\")\n+\t}\n+}\n+\n+func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n---\nipn/desktop/zsyscall_windows.go\n@@ -48,11 +48,9 @@ var (\n \tprocDestroyWindow                      = moduser32.NewProc(\"DestroyWindow\")\n \tprocDispatchMessageW                   = moduser32.NewProc(\"DispatchMessageW\")\n \tprocGetMessageW                        = moduser32.NewProc(\"GetMessageW\")\n-\tprocGetWindowLongPtrW                  = moduser32.NewProc(\"GetWindowLongPtrW\")\n \tprocPostQuitMessage                    = moduser32.NewProc(\"PostQuitMessage\")\n \tprocRegisterClassExW                   = moduser32.NewProc(\"RegisterClassExW\")\n \tprocSendMessageW                       = moduser32.NewProc(\"SendMessageW\")\n-\tprocSetWindowLongPtrW                  = moduser32.NewProc(\"SetWindowLongPtrW\")\n \tprocTranslateMessage                   = moduser32.NewProc(\"TranslateMessage\")\n \tprocWTSRegisterSessionNotificationEx   = modwtsapi32.NewProc(\"WTSRegisterSessionNotificationEx\")\n \tprocWTSUnRegisterSessionNotificationEx = modwtsapi32.NewProc(\"WTSUnRegisterSessionNotificationEx\")\n@@ -98,15 +96,6 @@ func getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (r\n \treturn\n }\n \n-func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func postQuitMessage(exitCode int32) {\n \tsyscall.Syscall(procPostQuitMessage.Addr(), 1, uintptr(exitCode), 0, 0)\n \treturn\n@@ -127,15 +116,6 @@ func sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr)\n \treturn\n }\n \n-func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func translateMessage(lpMsg *_MSG) (res bool) {\n \tr0, _, _ := syscall.Syscall(procTranslateMessage.Addr(), 1, uintptr(unsafe.Pointer(lpMsg)), 0, 0)\n \tres = r0 != 0\n---\n\n\n---\n\nChoice D:\nwgengine/netstack/netstack.go\n@@ -326,10 +326,15 @@ func Create(logf logger.Logf, tundev *tstun.Wrapper, e wgengine.Engine, mc *magi\n \tif tcpipErr != nil {\n \t\treturn nil, fmt.Errorf(\"could not disable TCP RACK: %v\", tcpipErr)\n \t}\n-\tcubicOpt := tcpip.CongestionControlOption(\"cubic\")\n-\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &cubicOpt)\n+\t// gVisor defaults to reno at the time of writing. We explicitly set reno\n+\t// congestion control in order to prevent unexpected changes. Netstack\n+\t// has an int overflow in sender congestion window arithmetic that is more\n+\t// prone to trigger with cubic congestion control.\n+\t// See https://github.com/google/gvisor/issues/11632\n+\trenoOpt := tcpip.CongestionControlOption(\"reno\")\n+\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &renoOpt)\n \tif tcpipErr != nil {\n-\t\treturn nil, fmt.Errorf(\"could not set cubic congestion control: %v\", tcpipErr)\n+\t\treturn nil, fmt.Errorf(\"could not set reno congestion control: %v\", tcpipErr)\n \t}\n \terr := setTCPBufSizes(ipstack)\n \tif err != nil {\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nperPeerState no longer needs to know the v6ULA.\r\n\r\nUpdates #14667\n\n---\n\nChoice A:\ntstest/integration/testcontrol/testcontrol.go\n@@ -839,15 +839,17 @@ func (s *Server) serveMap(w http.ResponseWriter, r *http.Request, mkey key.Machi\n \n \tw.WriteHeader(200)\n \tfor {\n-\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n-\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n-\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif streaming {\n+\t\t// Only send raw map responses to the streaming poll, to avoid a\n+\t\t// non-streaming map request beating the streaming poll in a race and\n+\t\t// potentially dropping the map response.\n+\t\tif streaming {\n+\t\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n+\t\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n+\t\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treturn\n \t\t}\n \n \t\tif s.canGenerateAutomaticMapResponseFor(req.NodeKey) {\n---\n\n\n---\n\nChoice B:\nipn/auditlog/extension.go\n@@ -22,7 +22,7 @@ import (\n )\n \n // featureName is the name of the feature implemented by this package.\n-// It is also the the [extension] name and the log prefix.\n+// It is also the [extension] name and the log prefix.\n const featureName = \"auditlog\"\n \n func init() {\n---\n\n\n---\n\nChoice C:\nnet/dns/debian_resolvconf.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || freebsd || openbsd\n+//go:build (linux && !android) || freebsd || openbsd\n \n package dns\n \n---\nnet/dns/direct.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android && !ios\n+\n package dns\n \n import (\n---\nnet/dns/direct_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build linux && !android\n+\n package dns\n \n import (\n---\nnet/dns/direct_notlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux && !android && !ios\n \n package dns\n \n---\nnet/dns/manager_default.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux && !freebsd && !openbsd && !windows && !darwin && !illumos && !solaris && !plan9\n+//go:build (!linux || android) && !freebsd && !openbsd && !windows && !darwin && !illumos && !solaris && !plan9\n \n package dns\n \n---\nnet/dns/manager_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build linux && !android\n+\n package dns\n \n import (\n---\nnet/dns/nm.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package dns\n \n---\nnet/dns/openresolv.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || freebsd || openbsd\n+//go:build (linux && !android) || freebsd || openbsd\n \n package dns\n \n---\nnet/dns/resolved.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package dns\n \n---\ntsnet/depaware.txt\n@@ -103,7 +103,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         github.com/go-json-experiment/json/jsontext                  from github.com/go-json-experiment/json+\n    W \ud83d\udca3 github.com/go-ole/go-ole                                     from github.com/go-ole/go-ole/oleutil+\n    W \ud83d\udca3 github.com/go-ole/go-ole/oleutil                             from tailscale.com/wgengine/winnet\n-  LA \ud83d\udca3 github.com/godbus/dbus/v5                                    from tailscale.com/net/dns\n+   L \ud83d\udca3 github.com/godbus/dbus/v5                                    from tailscale.com/net/dns\n         github.com/golang/groupcache/lru                             from tailscale.com/net/dnscache\n         github.com/google/btree                                      from gvisor.dev/gvisor/pkg/tcpip/header+\n    L    github.com/google/nftables                                   from tailscale.com/util/linuxfw\n@@ -116,8 +116,8 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n  LDW    github.com/gorilla/csrf                                      from tailscale.com/client/web\n  LDW    github.com/gorilla/securecookie                              from github.com/gorilla/csrf\n         github.com/hdevalence/ed25519consensus                       from tailscale.com/clientupdate/distsign+\n-  LA \ud83d\udca3 github.com/illarion/gonotify/v3                              from tailscale.com/net/dns\n-  LA    github.com/illarion/gonotify/v3/syscallf                     from github.com/illarion/gonotify/v3\n+   L \ud83d\udca3 github.com/illarion/gonotify/v3                              from tailscale.com/net/dns\n+   L    github.com/illarion/gonotify/v3/syscallf                     from github.com/illarion/gonotify/v3\n    L    github.com/jmespath/go-jmespath                              from github.com/aws/aws-sdk-go-v2/service/ssm\n    L \ud83d\udca3 github.com/jsimonetti/rtnetlink                              from tailscale.com/net/netmon\n    L    github.com/jsimonetti/rtnetlink/internal/unix                from github.com/jsimonetti/rtnetlink\n---\n\n\n---\n\nChoice D:\ncmd/natc/ippool/ippool.go\n@@ -24,7 +24,6 @@ var ErrNoIPsAvailable = errors.New(\"no IPs available\")\n type IPPool struct {\n \tperPeerMap syncs.Map[tailcfg.NodeID, *perPeerState]\n \tIPSet      *netipx.IPSet\n-\tV6ULA      netip.Prefix\n }\n \n func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bool) {\n@@ -44,15 +43,13 @@ func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bo\n func (ipp *IPPool) IPForDomain(from tailcfg.NodeID, domain string) (netip.Addr, error) {\n \tnpps := &perPeerState{\n \t\tipset: ipp.IPSet,\n-\t\tv6ULA: ipp.V6ULA,\n \t}\n \tps, _ := ipp.perPeerMap.LoadOrStore(from, npps)\n \treturn ps.ipForDomain(domain)\n }\n \n // perPeerState holds the state for a single peer.\n type perPeerState struct {\n-\tv6ULA netip.Prefix\n \tipset *netipx.IPSet\n \n \tmu           sync.Mutex\n---\ncmd/natc/ippool/ippool_test.go\n@@ -19,8 +19,7 @@ func TestIPPoolExhaustion(t *testing.T) {\n \tvar ipsb netipx.IPSetBuilder\n \tipsb.AddPrefix(smallPrefix)\n \taddrPool := must.Get(ipsb.IPSet())\n-\tv6ULA := netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\")\n-\tpool := IPPool{V6ULA: v6ULA, IPSet: addrPool}\n+\tpool := IPPool{IPSet: addrPool}\n \n \tassignedIPs := make(map[netip.Addr]string)\n \n@@ -52,9 +51,6 @@ func TestIPPoolExhaustion(t *testing.T) {\n \t\tif addr.Is4() && !smallPrefix.Contains(addr) {\n \t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, smallPrefix)\n \t\t}\n-\t\tif addr.Is6() && !v6ULA.Contains(addr) {\n-\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, v6ULA)\n-\t\t}\n \t}\n \n \t// expect one error for each iteration with the 5th domain\n@@ -73,7 +69,6 @@ func TestIPPool(t *testing.T) {\n \tipsb.AddPrefix(netip.MustParsePrefix(\"100.64.1.0/24\"))\n \taddrPool := must.Get(ipsb.IPSet())\n \tpool := IPPool{\n-\t\tV6ULA: netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n \t\tIPSet: addrPool,\n \t}\n \tfrom := tailcfg.NodeID(12345)\n---\ncmd/natc/natc.go\n@@ -153,7 +153,7 @@ func main() {\n \t\twhois:      lc,\n \t\tv6ULA:      v6ULA,\n \t\tignoreDsts: ignoreDstTable,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\troutes:     routes,\n \t\tdnsAddr:    dnsAddr,\n \t\tresolver:   net.DefaultResolver,\n---\ncmd/natc/natc_test.go\n@@ -270,7 +270,7 @@ func TestDNSResponse(t *testing.T) {\n \t\tignoreDsts: &bart.Table[bool]{},\n \t\troutes:     routes,\n \t\tv6ULA:      v6ULA,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\tdnsAddr:    dnsAddr,\n \t}\n \tc.ignoreDsts.Insert(netip.MustParsePrefix(\"8.8.4.4/32\"), true)\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #15680\n\n---\n\nChoice A:\ngo.mod\n@@ -98,14 +98,14 @@ require (\n \tgo.uber.org/zap v1.27.0\n \tgo4.org/mem v0.0.0-20240501181205-ae6ca9944745\n \tgo4.org/netipx v0.0.0-20231129151722-fdeea329fbba\n-\tgolang.org/x/crypto v0.35.0\n+\tgolang.org/x/crypto v0.37.0\n \tgolang.org/x/exp v0.0.0-20250210185358-939b2ce775ac\n \tgolang.org/x/mod v0.23.0\n \tgolang.org/x/net v0.36.0\n \tgolang.org/x/oauth2 v0.26.0\n-\tgolang.org/x/sync v0.11.0\n-\tgolang.org/x/sys v0.31.0\n-\tgolang.org/x/term v0.29.0\n+\tgolang.org/x/sync v0.13.0\n+\tgolang.org/x/sys v0.32.0\n+\tgolang.org/x/term v0.31.0\n \tgolang.org/x/time v0.10.0\n \tgolang.org/x/tools v0.30.0\n \tgolang.zx2c4.com/wintun v0.0.0-20230126152724-0fa3db229ce2\n@@ -392,7 +392,7 @@ require (\n \tgo.uber.org/multierr v1.11.0 // indirect\n \tgolang.org/x/exp/typeparams v0.0.0-20240314144324-c7f7c6466f7f // indirect\n \tgolang.org/x/image v0.24.0 // indirect\n-\tgolang.org/x/text v0.22.0 // indirect\n+\tgolang.org/x/text v0.24.0 // indirect\n \tgomodules.xyz/jsonpatch/v2 v2.4.0 // indirect\n \tgoogle.golang.org/protobuf v1.35.1 // indirect\n \tgopkg.in/inf.v0 v0.9.1 // indirect\n---\ngo.sum\n@@ -1087,8 +1087,8 @@ golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5y\n golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=\n golang.org/x/crypto v0.1.0/go.mod h1:RecgLatLF4+eUMCP1PoPZQb+cVrJcOPbHkTkbkB9sbw=\n golang.org/x/crypto v0.3.0/go.mod h1:hebNnKkNXi2UzZN1eVRvBB7co0a+JxK6XbPiWVs/3J4=\n-golang.org/x/crypto v0.35.0 h1:b15kiHdrGCHrP6LvwaQ3c03kgNhhiMgvlhxHQhmg2Xs=\n-golang.org/x/crypto v0.35.0/go.mod h1:dy7dXNW32cAb/6/PRuTNsix8T+vJAqvuIy5Bli/x0YQ=\n+golang.org/x/crypto v0.37.0 h1:kJNSjF/Xp7kU0iB2Z+9viTPMW4EqqsrywMXLJOOsXSE=\n+golang.org/x/crypto v0.37.0/go.mod h1:vg+k43peMZ0pUMhYmVAWysMK35e6ioLh3wB8ZCAfbVc=\n golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\n golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\n golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\n@@ -1200,8 +1200,8 @@ golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJ\n golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n-golang.org/x/sync v0.11.0 h1:GGz8+XQP4FvTTrjZPzNKTMFtSXH80RAzG+5ghFPgK9w=\n-golang.org/x/sync v0.11.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\n+golang.org/x/sync v0.13.0 h1:AauUjRAJ9OSnvULf/ARrrVywoJDy0YS2AwQ98I37610=\n+golang.org/x/sync v0.13.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=\n golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n@@ -1264,16 +1264,16 @@ golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n-golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=\n-golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n+golang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=\n+golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.2.0/go.mod h1:TVmDHMZPmdnySmBfhjOoOdhjzdE1h4u1VwSiw2l1Nuc=\n golang.org/x/term v0.4.0/go.mod h1:9P2UbLfCdcvo3p/nzKvsmas4TnlujnuoV9hGgYzW1lQ=\n golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\n-golang.org/x/term v0.29.0 h1:L6pJp37ocefwRRtYPKSWOWzOtWSxVajvz2ldH/xi3iU=\n-golang.org/x/term v0.29.0/go.mod h1:6bl4lRlvVuDgSf3179VpIxBF0o10JUpXWOnI7nErv7s=\n+golang.org/x/term v0.31.0 h1:erwDkOK1Msy6offm1mOgvspSkslFnIGsFnxOKoufg3o=\n+golang.org/x/term v0.31.0/go.mod h1:R4BeIy7D95HzImkxGkTW1UQTtP54tio2RyHz7PwK0aw=\n golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n@@ -1284,8 +1284,8 @@ golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\n golang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n golang.org/x/text v0.6.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n-golang.org/x/text v0.22.0 h1:bofq7m3/HAFvbF51jz3Q9wLg3jkvSPuiZu/pD1XwgtM=\n-golang.org/x/text v0.22.0/go.mod h1:YRoo4H8PVmsu+E3Ou7cqLVH8oXWIHVoX0jqUWALQhfY=\n+golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=\n+golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=\n golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n---\n\n\n---\n\nChoice B:\nwgengine/magicsock/endpoint.go\n@@ -552,7 +552,7 @@ func (de *endpoint) addrForSendLocked(now mono.Time) (udpAddr, derpAddr netip.Ad\n // addrForWireGuardSendLocked returns the address that should be used for\n // sending the next packet. If a packet has never or not recently been sent to\n // the endpoint, then a randomly selected address for the endpoint is returned,\n-// as well as a bool indiciating that WireGuard discovery pings should be started.\n+// as well as a bool indicating that WireGuard discovery pings should be started.\n // If the addresses have latency information available, then the address with the\n // best latency is used.\n //\n@@ -1261,7 +1261,7 @@ func (de *endpoint) sendDiscoPingsLocked(now mono.Time, sendCallMeMaybe bool) {\n }\n \n // sendWireGuardOnlyPingsLocked evaluates all available addresses for\n-// a WireGuard only endpoint and initates an ICMP ping for useable\n+// a WireGuard only endpoint and initiates an ICMP ping for useable\n // addresses.\n func (de *endpoint) sendWireGuardOnlyPingsLocked(now mono.Time) {\n \tif runtime.GOOS == \"js\" {\n@@ -1629,7 +1629,7 @@ func (de *endpoint) handlePongConnLocked(m *disco.Pong, di *discoInfo, src netip\n \t\t\tde.c.logf(\"magicsock: disco: node %v %v now using %v mtu=%v tx=%x\", de.publicKey.ShortString(), de.discoShort(), sp.to, thisPong.wireMTU, m.TxID[:6])\n \t\t\tde.debugUpdates.Add(EndpointChange{\n \t\t\t\tWhen: time.Now(),\n-\t\t\t\tWhat: \"handlePingLocked-bestAddr-update\",\n+\t\t\t\tWhat: \"handlePongConnLocked-bestAddr-update\",\n \t\t\t\tFrom: de.bestAddr,\n \t\t\t\tTo:   thisPong,\n \t\t\t})\n@@ -1638,7 +1638,7 @@ func (de *endpoint) handlePongConnLocked(m *disco.Pong, di *discoInfo, src netip\n \t\tif de.bestAddr.AddrPort == thisPong.AddrPort {\n \t\t\tde.debugUpdates.Add(EndpointChange{\n \t\t\t\tWhen: time.Now(),\n-\t\t\t\tWhat: \"handlePingLocked-bestAddr-latency\",\n+\t\t\t\tWhat: \"handlePongConnLocked-bestAddr-latency\",\n \t\t\t\tFrom: de.bestAddr,\n \t\t\t\tTo:   thisPong,\n \t\t\t})\n---\n\n\n---\n\nChoice C:\nprober/derp.go\n@@ -596,11 +596,23 @@ func (d *derpProber) updateMap(ctx context.Context) error {\n }\n \n func (d *derpProber) ProbeUDP(ipaddr string, port int) ProbeClass {\n+\tinitLabels := make(Labels)\n+\tip := net.ParseIP(ipaddr)\n+\n+\tif ip.To4() != nil {\n+\t\tinitLabels[\"address_family\"] = \"ipv4\"\n+\t} else if ip.To16() != nil { // Will return an IPv4 as 16 byte, so ensure the check for IPv4 precedes this\n+\t\tinitLabels[\"address_family\"] = \"ipv6\"\n+\t} else {\n+\t\tinitLabels[\"address_family\"] = \"unknown\"\n+\t}\n+\n \treturn ProbeClass{\n \t\tProbe: func(ctx context.Context) error {\n \t\t\treturn derpProbeUDP(ctx, ipaddr, port)\n \t\t},\n-\t\tClass: \"derp_udp\",\n+\t\tClass:  \"derp_udp\",\n+\t\tLabels: initLabels,\n \t}\n }\n \n---\nprober/prober.go\n@@ -404,10 +404,14 @@ func (p *Probe) recordEndLocked(err error) {\n \t\tp.mSeconds.WithLabelValues(\"ok\").Add(latency.Seconds())\n \t\tp.latencyHist.Value = latency\n \t\tp.latencyHist = p.latencyHist.Next()\n+\t\tp.mAttempts.WithLabelValues(\"fail\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"fail\").Add(0)\n \t} else {\n \t\tp.latency = 0\n \t\tp.mAttempts.WithLabelValues(\"fail\").Inc()\n \t\tp.mSeconds.WithLabelValues(\"fail\").Add(latency.Seconds())\n+\t\tp.mAttempts.WithLabelValues(\"ok\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"ok\").Add(0)\n \t}\n \tp.successHist.Value = p.succeeded\n \tp.successHist = p.successHist.Next()\n---\n\n\n---\n\nChoice D:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates google/gvisor#11632\r\nUpdates tailscale/corp#27717\n\n---\n\nChoice A:\nwgengine/netstack/netstack.go\n@@ -327,10 +327,15 @@ func Create(logf logger.Logf, tundev *tstun.Wrapper, e wgengine.Engine, mc *magi\n \tif tcpipErr != nil {\n \t\treturn nil, fmt.Errorf(\"could not disable TCP RACK: %v\", tcpipErr)\n \t}\n-\tcubicOpt := tcpip.CongestionControlOption(\"cubic\")\n-\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &cubicOpt)\n+\t// gVisor defaults to reno at the time of writing. We explicitly set reno\n+\t// congestion control in order to prevent unexpected changes. Netstack\n+\t// has an int overflow in sender congestion window arithmetic that is more\n+\t// prone to trigger with cubic congestion control.\n+\t// See https://github.com/google/gvisor/issues/11632\n+\trenoOpt := tcpip.CongestionControlOption(\"reno\")\n+\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &renoOpt)\n \tif tcpipErr != nil {\n-\t\treturn nil, fmt.Errorf(\"could not set cubic congestion control: %v\", tcpipErr)\n+\t\treturn nil, fmt.Errorf(\"could not set reno congestion control: %v\", tcpipErr)\n \t}\n \terr := setTCPBufSizes(ipstack)\n \tif err != nil {\n---\n\n\n---\n\nChoice B:\nwgengine/userspace.go\n@@ -1580,6 +1580,12 @@ type fwdDNSLinkSelector struct {\n }\n \n func (ls fwdDNSLinkSelector) PickLink(ip netip.Addr) (linkName string) {\n+\t// sandboxed macOS does not automatically bind to the loopback interface so\n+\t// we must be explicit about it.\n+\tif runtime.GOOS == \"darwin\" && ip.IsLoopback() {\n+\t\treturn \"lo0\"\n+\t}\n+\n \tif ls.ue.isDNSIPOverTailscale.Load()(ip) {\n \t\treturn ls.tunName\n \t}\n---\n\n\n---\n\nChoice C:\ntailcfg/tailcfg.go\n@@ -1462,6 +1462,13 @@ const (\n \t// user groups as Kubernetes user groups. This capability is read by\n \t// peers that are Tailscale Kubernetes operator instances.\n \tPeerCapabilityKubernetes PeerCapability = \"tailscale.com/cap/kubernetes\"\n+\n+\t// PeerCapabilityRelay grants the ability for a peer to allocate relay\n+\t// endpoints.\n+\tPeerCapabilityRelay PeerCapability = \"tailscale.com/cap/relay\"\n+\t// PeerCapabilityRelayTarget grants the current node the ability to allocate\n+\t// relay endpoints to the peer which has this capability.\n+\tPeerCapabilityRelayTarget PeerCapability = \"tailscale.com/cap/relay-target\"\n )\n \n // NodeCapMap is a map of capabilities to their optional values. It is valid for\n---\n\n\n---\n\nChoice D:\nutil/set/smallset.go\n@@ -50,6 +50,15 @@ func (s SmallSet[T]) Contains(e T) bool {\n \treturn e != zero && s.one == e\n }\n \n+// SoleElement returns the single value in the set, if the set has exactly one\n+// element.\n+//\n+// If the set is empty or has more than one element, ok will be false and e will\n+// be the zero value of T.\n+func (s SmallSet[T]) SoleElement() (e T, ok bool) {\n+\treturn s.one, s.Len() == 1\n+}\n+\n // Add adds e to the set.\n //\n // When storing a SmallSet in a map as a value type, it is important to\n@@ -61,10 +70,15 @@ func (s *SmallSet[T]) Add(e T) {\n \t\ts.m.Add(e)\n \t\treturn\n \t}\n-\t// Size zero to one non-zero element.\n-\tif s.one == zero && e != zero {\n-\t\ts.one = e\n-\t\treturn\n+\t// Non-zero elements can go into s.one.\n+\tif e != zero {\n+\t\tif s.one == zero {\n+\t\t\ts.one = e // Len 0 to Len 1\n+\t\t\treturn\n+\t\t}\n+\t\tif s.one == e {\n+\t\t\treturn // dup\n+\t\t}\n \t}\n \t// Need to make a multi map, either\n \t// because we now have two items, or\n@@ -73,7 +87,7 @@ func (s *SmallSet[T]) Add(e T) {\n \tif s.one != zero {\n \t\ts.m.Add(s.one) // move single item to multi\n \t}\n-\ts.m.Add(e) // add new item\n+\ts.m.Add(e) // add new item, possibly zero\n \ts.one = zero\n }\n \n---\nutil/set/smallset_test.go\n@@ -84,8 +84,43 @@ func TestSmallSet(t *testing.T) {\n \t\t\t\t\t\t\tt.Errorf(\"contains(%v) mismatch after ops %s: normal=%v, small=%v\", e, name(), normal.Contains(e), small.Contains(e))\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\n+\t\t\t\t\tif err := small.checkInvariants(); err != nil {\n+\t\t\t\t\t\tt.Errorf(\"checkInvariants failed after ops %s: %v\", name(), err)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif !t.Failed() {\n+\t\t\t\t\t\tsole, ok := small.SoleElement()\n+\t\t\t\t\t\tif ok != (small.Len() == 1) {\n+\t\t\t\t\t\t\tt.Errorf(\"SoleElement ok mismatch after ops %s: SoleElement ok=%v, want=%v\", name(), ok, !ok)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif ok && sole != smallEle[0] {\n+\t\t\t\t\t\t\tt.Errorf(\"SoleElement value mismatch after ops %s: SoleElement=%v, want=%v\", name(), sole, smallEle[0])\n+\t\t\t\t\t\t\tt.Errorf(\"Internals: %+v\", small)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (s *SmallSet[T]) checkInvariants() error {\n+\tvar zero T\n+\tif s.m != nil && s.one != zero {\n+\t\treturn fmt.Errorf(\"both m and one are non-zero\")\n+\t}\n+\tif s.m != nil {\n+\t\tswitch len(s.m) {\n+\t\tcase 0:\n+\t\t\treturn fmt.Errorf(\"m is non-nil but empty\")\n+\t\tcase 1:\n+\t\t\tfor k := range s.m {\n+\t\t\t\tif k != zero {\n+\t\t\t\t\treturn fmt.Errorf(\"m contains exactly 1 non-zero element, %v\", k)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n+\treturn nil\n }\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [github.com/gorilla/csrf](https://github.com/gorilla/csrf) from 1.7.3-0.20250123201450-9dd6af1f6d30 to 1.7.3.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/gorilla/csrf/releases\">github.com/gorilla/csrf's releases</a>.</em></p>\n<blockquote>\n<h2>v1.7.3</h2>\n<p>This Release fixes the following:</p>\n<ul>\n<li>CVE-2025-24358</li>\n</ul>\n<p><strong>Full Changelog</strong>: <a href=\"https://github.com/gorilla/csrf/compare/v1.7.2...v1.7.3\">https://github.com/gorilla/csrf/compare/v1.7.2...v1.7.3</a></p>\n</blockquote>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li>See full diff in <a href=\"https://github.com/gorilla/csrf/commits/v1.7.3\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=github.com/gorilla/csrf&package-manager=go_modules&previous-version=1.7.3-0.20250123201450-9dd6af1f6d30&new-version=1.7.3)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\nYou can disable automated security fix PRs for this repo from the [Security Alerts page](https://github.com/tailscale/tailscale/network/alerts).\n\n</details>\n\n---\n\nChoice A:\ncontrol/controlclient/direct.go\n@@ -95,15 +95,16 @@ type Direct struct {\n \tsfGroup     singleflight.Group[struct{}, *NoiseClient] // protects noiseClient creation.\n \tnoiseClient *NoiseClient\n \n-\tpersist      persist.PersistView\n-\tauthKey      string\n-\ttryingNewKey key.NodePrivate\n-\texpiry       time.Time         // or zero value if none/unknown\n-\thostinfo     *tailcfg.Hostinfo // always non-nil\n-\tnetinfo      *tailcfg.NetInfo\n-\tendpoints    []tailcfg.Endpoint\n-\ttkaHead      string\n-\tlastPingURL  string // last PingRequest.URL received, for dup suppression\n+\tpersist                 persist.PersistView\n+\tauthKey                 string\n+\ttryingNewKey            key.NodePrivate\n+\texpiry                  time.Time         // or zero value if none/unknown\n+\thostinfo                *tailcfg.Hostinfo // always non-nil\n+\tnetinfo                 *tailcfg.NetInfo\n+\tendpoints               []tailcfg.Endpoint\n+\ttkaHead                 string\n+\tlastPingURL             string // last PingRequest.URL received, for dup suppression\n+\tconnectionHandleForTest string // sent in MapRequest.ConnectionHandleForTest\n }\n \n // Observer is implemented by users of the control client (such as LocalBackend)\n@@ -403,6 +404,14 @@ func (c *Direct) SetTKAHead(tkaHead string) bool {\n \treturn true\n }\n \n+// SetConnectionHandleForTest stores a new MapRequest.ConnectionHandleForTest\n+// value for the next update.\n+func (c *Direct) SetConnectionHandleForTest(handle string) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tc.connectionHandleForTest = handle\n+}\n+\n func (c *Direct) GetPersist() persist.PersistView {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n@@ -851,6 +860,7 @@ func (c *Direct) sendMapRequest(ctx context.Context, isStreaming bool, nu Netmap\n \tserverNoiseKey := c.serverNoiseKey\n \thi := c.hostInfoLocked()\n \tbackendLogID := hi.BackendLogID\n+\tconnectionHandleForTest := c.connectionHandleForTest\n \tvar epStrs []string\n \tvar eps []netip.AddrPort\n \tvar epTypes []tailcfg.EndpointType\n@@ -891,17 +901,18 @@ func (c *Direct) sendMapRequest(ctx context.Context, isStreaming bool, nu Netmap\n \n \tnodeKey := persist.PublicNodeKey()\n \trequest := &tailcfg.MapRequest{\n-\t\tVersion:       tailcfg.CurrentCapabilityVersion,\n-\t\tKeepAlive:     true,\n-\t\tNodeKey:       nodeKey,\n-\t\tDiscoKey:      c.discoPubKey,\n-\t\tEndpoints:     eps,\n-\t\tEndpointTypes: epTypes,\n-\t\tStream:        isStreaming,\n-\t\tHostinfo:      hi,\n-\t\tDebugFlags:    c.debugFlags,\n-\t\tOmitPeers:     nu == nil,\n-\t\tTKAHead:       c.tkaHead,\n+\t\tVersion:                 tailcfg.CurrentCapabilityVersion,\n+\t\tKeepAlive:               true,\n+\t\tNodeKey:                 nodeKey,\n+\t\tDiscoKey:                c.discoPubKey,\n+\t\tEndpoints:               eps,\n+\t\tEndpointTypes:           epTypes,\n+\t\tStream:                  isStreaming,\n+\t\tHostinfo:                hi,\n+\t\tDebugFlags:              c.debugFlags,\n+\t\tOmitPeers:               nu == nil,\n+\t\tTKAHead:                 c.tkaHead,\n+\t\tConnectionHandleForTest: connectionHandleForTest,\n \t}\n \tvar extraDebugFlags []string\n \tif hi != nil && c.netMon != nil && !c.skipIPForwardingCheck &&\n---\ntailcfg/tailcfg.go\n@@ -1385,6 +1385,12 @@ type MapRequest struct {\n \t//     * \"warn-router-unhealthy\": client's Router implementation is\n \t//       having problems.\n \tDebugFlags []string `json:\",omitempty\"`\n+\n+\t// ConnectionHandleForTest, if non-empty, is an opaque string sent by the client that\n+\t// identifies this specific connection to the server. The server may choose to\n+\t// use this handle to identify the connection for debugging or testing\n+\t// purposes. It has no semantic meaning.\n+\tConnectionHandleForTest string `json:\",omitempty\"`\n }\n \n // PortRange represents a range of UDP or TCP port numbers.\n---\n\n\n---\n\nChoice B:\ngo.mod\n@@ -272,7 +272,7 @@ require (\n \tgithub.com/gordonklaus/ineffassign v0.1.0 // indirect\n \tgithub.com/goreleaser/chglog v0.5.0 // indirect\n \tgithub.com/goreleaser/fileglob v1.3.0 // indirect\n-\tgithub.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30\n+\tgithub.com/gorilla/csrf v1.7.3\n \tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n \tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n \tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n---\ngo.sum\n@@ -524,8 +524,8 @@ github.com/goreleaser/fileglob v1.3.0 h1:/X6J7U8lbDpQtBvGcwwPS6OpzkNVlVEsFUVRx9+\n github.com/goreleaser/fileglob v1.3.0/go.mod h1:Jx6BoXv3mbYkEzwm9THo7xbr5egkAraxkGorbJb4RxU=\n github.com/goreleaser/nfpm/v2 v2.33.1 h1:EkdAzZyVhAI9JC1vjmjjbmnNzyH1J6Cu4JCsA7YcQuc=\n github.com/goreleaser/nfpm/v2 v2.33.1/go.mod h1:8wwWWvJWmn84xo/Sqiv0aMvEGTHlHZTXTEuVSgQpkIM=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30 h1:fiJdrgVBkjZ5B1HJ2WQwNOaXB+QyYcNXTA3t1XYLz0M=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n+github.com/gorilla/csrf v1.7.3 h1:BHWt6FTLZAb2HtWT5KDBf6qgpZzvtbp9QWDRKZMXJC0=\n+github.com/gorilla/csrf v1.7.3/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n github.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\n github.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\n github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=\n---\n\n\n---\n\nChoice C:\ncmd/k8s-operator/proxygroup.go\n@@ -461,15 +461,15 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \n \t\tvar existingCfgSecret *corev1.Secret // unmodified copy of secret\n \t\tif err := r.Get(ctx, client.ObjectKeyFromObject(cfgSecret), cfgSecret); err == nil {\n-\t\t\tlogger.Debugf(\"secret %s/%s already exists\", cfgSecret.GetNamespace(), cfgSecret.GetName())\n+\t\t\tlogger.Debugf(\"Secret %s/%s already exists\", cfgSecret.GetNamespace(), cfgSecret.GetName())\n \t\t\texistingCfgSecret = cfgSecret.DeepCopy()\n \t\t} else if !apierrors.IsNotFound(err) {\n \t\t\treturn \"\", err\n \t\t}\n \n \t\tvar authKey string\n \t\tif existingCfgSecret == nil {\n-\t\t\tlogger.Debugf(\"creating authkey for new ProxyGroup proxy\")\n+\t\t\tlogger.Debugf(\"Creating authkey for new ProxyGroup proxy\")\n \t\t\ttags := pg.Spec.Tags.Stringify()\n \t\t\tif len(tags) == 0 {\n \t\t\t\ttags = r.defaultTags\n@@ -490,7 +490,7 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t\tif err != nil {\n \t\t\t\treturn \"\", fmt.Errorf(\"error marshalling tailscaled config: %w\", err)\n \t\t\t}\n-\t\t\tmak.Set(&cfgSecret.StringData, tsoperator.TailscaledConfigFileName(cap), string(cfgJSON))\n+\t\t\tmak.Set(&cfgSecret.Data, tsoperator.TailscaledConfigFileName(cap), cfgJSON)\n \t\t}\n \n \t\t// The config sha256 sum is a value for a hash annotation used to trigger\n@@ -520,12 +520,14 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t}\n \n \t\tif existingCfgSecret != nil {\n-\t\t\tlogger.Debugf(\"patching the existing ProxyGroup config Secret %s\", cfgSecret.Name)\n-\t\t\tif err := r.Patch(ctx, cfgSecret, client.MergeFrom(existingCfgSecret)); err != nil {\n-\t\t\t\treturn \"\", err\n+\t\t\tif !apiequality.Semantic.DeepEqual(existingCfgSecret, cfgSecret) {\n+\t\t\t\tlogger.Debugf(\"Updating the existing ProxyGroup config Secret %s\", cfgSecret.Name)\n+\t\t\t\tif err := r.Update(ctx, cfgSecret); err != nil {\n+\t\t\t\t\treturn \"\", err\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n-\t\t\tlogger.Debugf(\"creating a new config Secret %s for the ProxyGroup\", cfgSecret.Name)\n+\t\t\tlogger.Debugf(\"Creating a new config Secret %s for the ProxyGroup\", cfgSecret.Name)\n \t\t\tif err := r.Create(ctx, cfgSecret); err != nil {\n \t\t\t\treturn \"\", err\n \t\t\t}\n---\ncmd/k8s-operator/proxygroup_test.go\n@@ -475,8 +475,6 @@ func TestIngressAdvertiseServicesConfigPreserved(t *testing.T) {\n \t\t\tName:      pgConfigSecretName(pgName, 0),\n \t\t\tNamespace: tsNamespace,\n \t\t},\n-\t\t// Write directly to Data because the fake client doesn't copy the write-only\n-\t\t// StringData field across to Data for us.\n \t\tData: map[string][]byte{\n \t\t\ttsoperator.TailscaledConfigFileName(106): existingConfigBytes,\n \t\t},\n@@ -514,10 +512,10 @@ func TestIngressAdvertiseServicesConfigPreserved(t *testing.T) {\n \t\t\tNamespace:       tsNamespace,\n \t\t\tResourceVersion: \"2\",\n \t\t},\n-\t\tStringData: map[string]string{\n-\t\t\ttsoperator.TailscaledConfigFileName(106): string(expectedConfigBytes),\n+\t\tData: map[string][]byte{\n+\t\t\ttsoperator.TailscaledConfigFileName(106): expectedConfigBytes,\n \t\t},\n-\t}, omitSecretData)\n+\t})\n }\n \n func verifyProxyGroupCounts(t *testing.T, r *ProxyGroupReconciler, wantIngress, wantEgress int) {\n@@ -620,11 +618,3 @@ func addNodeIDToStateSecrets(t *testing.T, fc client.WithWatch, pg *tsapi.ProxyG\n \t\t})\n \t}\n }\n-\n-// The operator mostly writes to StringData and reads from Data, but the fake\n-// client doesn't copy StringData across to Data on write. When comparing actual\n-// vs expected Secrets, use this function to only check what the operator writes\n-// to StringData.\n-func omitSecretData(secret *corev1.Secret) {\n-\tsecret.Data = nil\n-}\n---\n\n\n---\n\nChoice D:\nipn/store/kubestore/store_kube.go\n@@ -143,15 +143,6 @@ func (s *Store) WriteTLSCertAndKey(domain string, cert, key []byte) (err error)\n \tif err := dnsname.ValidHostname(domain); err != nil {\n \t\treturn fmt.Errorf(\"invalid domain name %q: %w\", domain, err)\n \t}\n-\tdefer func() {\n-\t\t// TODO(irbekrm): a read between these two separate writes would\n-\t\t// get a mismatched cert and key.  Allow writing both cert and\n-\t\t// key to the memory store in a single, lock-protected operation.\n-\t\tif err == nil {\n-\t\t\ts.memory.WriteState(ipn.StateKey(domain+\".crt\"), cert)\n-\t\t\ts.memory.WriteState(ipn.StateKey(domain+\".key\"), key)\n-\t\t}\n-\t}()\n \tsecretName := s.secretName\n \tdata := map[string][]byte{\n \t\tdomain + \".crt\": cert,\n@@ -166,36 +157,45 @@ func (s *Store) WriteTLSCertAndKey(domain string, cert, key []byte) (err error)\n \t\t\tkeyTLSKey:  key,\n \t\t}\n \t}\n-\treturn s.updateSecret(data, secretName)\n+\tif err := s.updateSecret(data, secretName); err != nil {\n+\t\treturn fmt.Errorf(\"error writing TLS cert and key to Secret: %w\", err)\n+\t}\n+\t// TODO(irbekrm): certs for write replicas are currently not\n+\t// written to memory to avoid out of sync memory state after\n+\t// Ingress resources have been recreated.  This means that TLS\n+\t// certs for write replicas are retrieved from the Secret on\n+\t// each HTTPS request.  This is a temporary solution till we\n+\t// implement a Secret watch.\n+\tif s.certShareMode != \"rw\" {\n+\t\ts.memory.WriteState(ipn.StateKey(domain+\".crt\"), cert)\n+\t\ts.memory.WriteState(ipn.StateKey(domain+\".key\"), key)\n+\t}\n+\treturn nil\n }\n \n // ReadTLSCertAndKey reads a TLS cert and key from memory or from a\n // domain-specific Secret. It first checks the in-memory store, if not found in\n // memory and running cert store in read-only mode, looks up a Secret.\n+// Note that write replicas of HA Ingress always retrieve TLS certs from Secrets.\n func (s *Store) ReadTLSCertAndKey(domain string) (cert, key []byte, err error) {\n \tif err := dnsname.ValidHostname(domain); err != nil {\n \t\treturn nil, nil, fmt.Errorf(\"invalid domain name %q: %w\", domain, err)\n \t}\n \tcertKey := domain + \".crt\"\n \tkeyKey := domain + \".key\"\n-\n \tcert, err = s.memory.ReadState(ipn.StateKey(certKey))\n \tif err == nil {\n \t\tkey, err = s.memory.ReadState(ipn.StateKey(keyKey))\n \t\tif err == nil {\n \t\t\treturn cert, key, nil\n \t\t}\n \t}\n-\tif s.certShareMode != \"ro\" {\n+\tif s.certShareMode == \"\" {\n \t\treturn nil, nil, ipn.ErrStateNotExist\n \t}\n-\t// If we are in cert share read only mode, it is possible that a write\n-\t// replica just issued the TLS cert for this DNS name and it has not\n-\t// been loaded to store yet, so check the Secret.\n \n \tctx, cancel := context.WithTimeout(context.Background(), timeout)\n \tdefer cancel()\n-\n \tsecret, err := s.client.GetSecret(ctx, domain)\n \tif err != nil {\n \t\tif kubeclient.IsNotFoundErr(err) {\n@@ -212,9 +212,18 @@ func (s *Store) ReadTLSCertAndKey(domain string) (cert, key []byte, err error) {\n \t}\n \t// TODO(irbekrm): a read between these two separate writes would\n \t// get a mismatched cert and key.  Allow writing both cert and\n-\t// key to the memory store in a single lock-protected operation.\n-\ts.memory.WriteState(ipn.StateKey(certKey), cert)\n-\ts.memory.WriteState(ipn.StateKey(keyKey), key)\n+\t// key to the memory store in a single, lock-protected operation.\n+\t//\n+\t// TODO(irbekrm): currently certs for write replicas of HA Ingress get\n+\t// retrieved from the cluster Secret on each HTTPS request to avoid a\n+\t// situation when after Ingress recreation stale certs are read from\n+\t// memory.\n+\t// Fix this by watching Secrets to ensure that memory store gets updated\n+\t// when Secrets are deleted.\n+\tif s.certShareMode == \"ro\" {\n+\t\ts.memory.WriteState(ipn.StateKey(certKey), cert)\n+\t\ts.memory.WriteState(ipn.StateKey(keyKey), key)\n+\t}\n \treturn cert, key, nil\n }\n \n---\nipn/store/kubestore/store_kube_test.go\n@@ -201,10 +201,6 @@ func TestWriteTLSCertAndKey(t *testing.T) {\n \t\t\t\t\"tls.crt\": []byte(testCert),\n \t\t\t\t\"tls.key\": []byte(testKey),\n \t\t\t},\n-\t\t\twantMemoryStore: map[ipn.StateKey][]byte{\n-\t\t\t\t\"my-app.tailnetxyz.ts.net.crt\": []byte(testCert),\n-\t\t\t\t\"my-app.tailnetxyz.ts.net.key\": []byte(testKey),\n-\t\t\t},\n \t\t},\n \t\t{\n \t\t\tname: \"cert_share_mode_write_update_existing\",\n@@ -219,10 +215,6 @@ func TestWriteTLSCertAndKey(t *testing.T) {\n \t\t\t\t\"tls.crt\": []byte(testCert),\n \t\t\t\t\"tls.key\": []byte(testKey),\n \t\t\t},\n-\t\t\twantMemoryStore: map[ipn.StateKey][]byte{\n-\t\t\t\t\"my-app.tailnetxyz.ts.net.crt\": []byte(testCert),\n-\t\t\t\t\"my-app.tailnetxyz.ts.net.key\": []byte(testKey),\n-\t\t\t},\n \t\t},\n \t\t{\n \t\t\tname: \"update_existing\",\n@@ -367,7 +359,7 @@ func TestReadTLSCertAndKey(t *testing.T) {\n \t\twantMemoryStore map[ipn.StateKey][]byte\n \t}{\n \t\t{\n-\t\t\tname: \"found\",\n+\t\t\tname: \"found_in_memory\",\n \t\t\tmemoryStore: map[ipn.StateKey][]byte{\n \t\t\t\t\"my-app.tailnetxyz.ts.net.crt\": []byte(testCert),\n \t\t\t\t\"my-app.tailnetxyz.ts.net.key\": []byte(testKey),\n@@ -381,7 +373,7 @@ func TestReadTLSCertAndKey(t *testing.T) {\n \t\t\t},\n \t\t},\n \t\t{\n-\t\t\tname:    \"not_found\",\n+\t\t\tname:    \"not_found_in_memory\",\n \t\t\tdomain:  testDomain,\n \t\t\twantErr: ipn.ErrStateNotExist,\n \t\t},\n@@ -400,6 +392,17 @@ func TestReadTLSCertAndKey(t *testing.T) {\n \t\t\t\t\"my-app.tailnetxyz.ts.net.key\": []byte(testKey),\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname:          \"cert_share_rw_mode_found_in_secret\",\n+\t\t\tcertShareMode: \"rw\",\n+\t\t\tdomain:        testDomain,\n+\t\t\tsecretData: map[string][]byte{\n+\t\t\t\t\"tls.crt\": []byte(testCert),\n+\t\t\t\t\"tls.key\": []byte(testKey),\n+\t\t\t},\n+\t\t\twantCert: []byte(testCert),\n+\t\t\twantKey:  []byte(testKey),\n+\t\t},\n \t\t{\n \t\t\tname:          \"cert_share_ro_mode_found_in_memory\",\n \t\t\tcertShareMode: \"ro\",\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes #15669\r\nSigned-off-by: Erisa A <erisa@tailscale.com>\n\n---\n\nChoice A:\nutil/mak/mak.go\n@@ -5,11 +5,6 @@\n // things, notably to maps, but also slices.\n package mak\n \n-import (\n-\t\"fmt\"\n-\t\"reflect\"\n-)\n-\n // Set populates an entry in a map, making the map if necessary.\n //\n // That is, it assigns (*m)[k] = v, making *m if it was nil.\n@@ -20,35 +15,6 @@ func Set[K comparable, V any, T ~map[K]V](m *T, k K, v V) {\n \t(*m)[k] = v\n }\n \n-// NonNil takes a pointer to a Go data structure\n-// (currently only a slice or a map) and makes sure it's non-nil for\n-// JSON serialization. (In particular, JavaScript clients usually want\n-// the field to be defined after they decode the JSON.)\n-//\n-// Deprecated: use NonNilSliceForJSON or NonNilMapForJSON instead.\n-func NonNil(ptr any) {\n-\tif ptr == nil {\n-\t\tpanic(\"nil interface\")\n-\t}\n-\trv := reflect.ValueOf(ptr)\n-\tif rv.Kind() != reflect.Ptr {\n-\t\tpanic(fmt.Sprintf(\"kind %v, not Ptr\", rv.Kind()))\n-\t}\n-\tif rv.Pointer() == 0 {\n-\t\tpanic(\"nil pointer\")\n-\t}\n-\trv = rv.Elem()\n-\tif rv.Pointer() != 0 {\n-\t\treturn\n-\t}\n-\tswitch rv.Type().Kind() {\n-\tcase reflect.Slice:\n-\t\trv.Set(reflect.MakeSlice(rv.Type(), 0, 0))\n-\tcase reflect.Map:\n-\t\trv.Set(reflect.MakeMap(rv.Type()))\n-\t}\n-}\n-\n // NonNilSliceForJSON makes sure that *slicePtr is non-nil so it will\n // won't be omitted from JSON serialization and possibly confuse JavaScript\n // clients expecting it to be present.\n---\nutil/mak/mak_test.go\n@@ -40,35 +40,6 @@ func TestSet(t *testing.T) {\n \t})\n }\n \n-func TestNonNil(t *testing.T) {\n-\tvar s []string\n-\tNonNil(&s)\n-\tif len(s) != 0 {\n-\t\tt.Errorf(\"slice len = %d; want 0\", len(s))\n-\t}\n-\tif s == nil {\n-\t\tt.Error(\"slice still nil\")\n-\t}\n-\n-\ts = append(s, \"foo\")\n-\tNonNil(&s)\n-\tif len(s) != 1 {\n-\t\tt.Errorf(\"len = %d; want 1\", len(s))\n-\t}\n-\tif s[0] != \"foo\" {\n-\t\tt.Errorf(\"value = %q; want foo\", s)\n-\t}\n-\n-\tvar m map[string]string\n-\tNonNil(&m)\n-\tif len(m) != 0 {\n-\t\tt.Errorf(\"map len = %d; want 0\", len(s))\n-\t}\n-\tif m == nil {\n-\t\tt.Error(\"map still nil\")\n-\t}\n-}\n-\n func TestNonNilMapForJSON(t *testing.T) {\n \ttype M map[string]int\n \tvar m M\n---\n\n\n---\n\nChoice B:\n.github/workflows/test.yml\n@@ -305,7 +305,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: build some\n-      run: ./tool/go build ./ipn/... ./wgengine/ ./types/... ./control/controlclient\n+      run: ./tool/go build ./ipn/... ./ssh/tailssh ./wgengine/ ./types/... ./control/controlclient\n       env:\n         GOOS: ios\n         GOARCH: arm64\n@@ -375,7 +375,7 @@ jobs:\n       # some Android breakages early.\n       # TODO(bradfitz): better; see https://github.com/tailscale/tailscale/issues/4482\n     - name: build some\n-      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version\n+      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version ./ssh/tailssh\n       env:\n         GOOS: android\n         GOARCH: arm64\n---\nssh/tailssh/incubator.go\n@@ -7,7 +7,7 @@\n // and groups to the specified `--uid`, `--gid` and `--groups`, and\n // then launches the requested `--cmd`.\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd\n \n package tailssh\n \n---\nssh/tailssh/incubator_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package tailssh\n \n---\nssh/tailssh/tailssh.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n // Package tailssh is an SSH server integrated into Tailscale.\n package tailssh\n---\nssh/tailssh/user.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n package tailssh\n \n---\n\n\n---\n\nChoice C:\nscripts/installer.sh\n@@ -208,8 +208,11 @@ main() {\n \t\t\t\t\tPACKAGETYPE=\"yum\"\n \t\t\t\tfi\n \t\t\t\t;;\n-\t\t\trhel)\n+\t\t\trhel|miraclelinux)\n \t\t\t\tOS=\"$ID\"\n+\t\t\t\tif [ \"$ID\" = \"miraclelinux\" ]; then\n+\t\t\t\t\tOS=\"rhel\"\n+\t\t\t\tfi\n \t\t\t\tVERSION=\"$(echo \"$VERSION_ID\" | cut -f1 -d.)\"\n \t\t\t\tPACKAGETYPE=\"dnf\"\n \t\t\t\tif [ \"$VERSION\" = \"7\" ]; then\n---\n\n\n---\n\nChoice D:\ngo.toolchain.rev\n@@ -1 +1 @@\n-4fdaeeb8fe43bcdb4e8cc736433b9cd9c0ddd221\n+16b6e4fd15c59336156cdbc977de1745ad094f2d\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis had two different 'commit messages' sections with differently capitalized headers - merge those into one.\r\n\r\nUpdates#cleanup\n\n---\n\nChoice A:\nbuild_dist.sh\n@@ -28,18 +28,26 @@ EOF\n \texit 0\n fi\n \n-tags=\"\"\n+tags=\"${TAGS:-}\"\n ldflags=\"-X tailscale.com/version.longStamp=${VERSION_LONG} -X tailscale.com/version.shortStamp=${VERSION_SHORT}\"\n \n # build_dist.sh arguments must precede go build arguments.\n while [ \"$#\" -gt 1 ]; do\n \tcase \"$1\" in\n \t--extra-small)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --extra-small or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\tldflags=\"$ldflags -w -s\"\n \t\ttags=\"${tags:+$tags,}ts_omit_aws,ts_omit_bird,ts_omit_tap,ts_omit_kube,ts_omit_completion,ts_omit_ssh,ts_omit_wakeonlan,ts_omit_capture\"\n \t\t;;\n \t--box)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --box or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\ttags=\"${tags:+$tags,}ts_include_cli\"\n \t\t;;\n---\n\n\n---\n\nChoice B:\nipn/store/store_aws.go\n@@ -12,10 +12,6 @@ import (\n )\n \n func init() {\n-\tregisterAvailableExternalStores = append(registerAvailableExternalStores, registerAWSStore)\n-}\n-\n-func registerAWSStore() {\n \tRegister(\"arn:\", func(logf logger.Logf, arg string) (ipn.StateStore, error) {\n \t\tssmARN, opts, err := awsstore.ParseARNAndOpts(arg)\n \t\tif err != nil {\n---\nipn/store/store_kube.go\n@@ -14,10 +14,6 @@ import (\n )\n \n func init() {\n-\tregisterAvailableExternalStores = append(registerAvailableExternalStores, registerKubeStore)\n-}\n-\n-func registerKubeStore() {\n \tRegister(\"kube:\", func(logf logger.Logf, path string) (ipn.StateStore, error) {\n \t\tsecretName := strings.TrimPrefix(path, \"kube:\")\n \t\treturn kubestore.New(logf, secretName)\n---\nipn/store/stores.go\n@@ -26,16 +26,8 @@ import (\n // The arg is of the form \"prefix:rest\", where prefix was previously registered with Register.\n type Provider func(logf logger.Logf, arg string) (ipn.StateStore, error)\n \n-var regOnce sync.Once\n-\n-var registerAvailableExternalStores []func()\n-\n-func registerDefaultStores() {\n+func init() {\n \tRegister(\"mem:\", mem.New)\n-\n-\tfor _, f := range registerAvailableExternalStores {\n-\t\tf()\n-\t}\n }\n \n var knownStores map[string]Provider\n@@ -55,7 +47,6 @@ var knownStores map[string]Provider\n //     the suffix is a Kubernetes secret name\n //   - In all other cases, the path is treated as a filepath.\n func New(logf logger.Logf, path string) (ipn.StateStore, error) {\n-\tregOnce.Do(registerDefaultStores)\n \tfor prefix, sf := range knownStores {\n \t\tif strings.HasPrefix(path, prefix) {\n \t\t\t// We can't strip the prefix here as some NewStoreFunc (like arn:)\n---\nipn/store/stores_test.go\n@@ -4,6 +4,7 @@\n package store\n \n import (\n+\t\"maps\"\n \t\"path/filepath\"\n \t\"testing\"\n \n@@ -14,10 +15,9 @@ import (\n )\n \n func TestNewStore(t *testing.T) {\n-\tregOnce.Do(registerDefaultStores)\n+\toldKnownStores := maps.Clone(knownStores)\n \tt.Cleanup(func() {\n-\t\tknownStores = map[string]Provider{}\n-\t\tregisterDefaultStores()\n+\t\tknownStores = oldKnownStores\n \t})\n \tknownStores = map[string]Provider{}\n \n---\n\n\n---\n\nChoice C:\ndocs/commit-messages.md\n@@ -1,16 +1,12 @@\n # Commit messages\n \n+There are different styles of commit messages followed by different projects.\n This is Tailscale's style guide for writing git commit messages.\n-\n As with all style guides, many things here are subjective and exist primarily to\n codify existing conventions and promote uniformity and thus ease of reading by\n others. Others have stronger reasons, such as interop with tooling or making\n future git archaeology easier.\n \n-# Commit Messages\n-\n-There are different styles of commit messages followed by different projects.\n-\n Our commit message style is largely based on the Go language's style, which\n shares much in common with the Linux kernel's git commit message style (for\n which git was invented):\n---\n\n\n---\n\nChoice D:\nwgengine/userspace.go\n@@ -1580,6 +1580,12 @@ type fwdDNSLinkSelector struct {\n }\n \n func (ls fwdDNSLinkSelector) PickLink(ip netip.Addr) (linkName string) {\n+\t// sandboxed macOS does not automatically bind to the loopback interface so\n+\t// we must be explicit about it.\n+\tif runtime.GOOS == \"darwin\" && ip.IsLoopback() {\n+\t\treturn \"lo0\"\n+\t}\n+\n \tif ls.ue.isDNSIPOverTailscale.Load()(ip) {\n \t\treturn ls.tunName\n \t}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAllow builds to be outputted to a specific directory. By default, or if unset, artifacts are written to PWD/dist.\r\n\r\nUpdates #27638\n\n---\n\nChoice A:\nrelease/dist/cli/cli.go\n@@ -65,6 +65,7 @@ func CLI(getTargets func() ([]dist.Target, error)) *ffcli.Command {\n \t\t\t\t\tfs.StringVar(&buildArgs.manifest, \"manifest\", \"\", \"manifest file to write\")\n \t\t\t\t\tfs.BoolVar(&buildArgs.verbose, \"verbose\", false, \"verbose logging\")\n \t\t\t\t\tfs.StringVar(&buildArgs.webClientRoot, \"web-client-root\", \"\", \"path to root of web client source to build\")\n+\t\t\t\t\tfs.StringVar(&buildArgs.outPath, \"out\", \"\", \"path to write output artifacts (defaults to '$PWD/dist' if not set)\")\n \t\t\t\t\treturn fs\n \t\t\t\t})(),\n \t\t\t\tLongHelp: strings.TrimSpace(`\n@@ -156,6 +157,7 @@ var buildArgs struct {\n \tmanifest      string\n \tverbose       bool\n \twebClientRoot string\n+\toutPath       string\n }\n \n func runBuild(ctx context.Context, filters []string, targets []dist.Target) error {\n@@ -172,7 +174,11 @@ func runBuild(ctx context.Context, filters []string, targets []dist.Target) erro\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting working directory: %w\", err)\n \t}\n-\tb, err := dist.NewBuild(wd, filepath.Join(wd, \"dist\"))\n+\toutPath := filepath.Join(wd, \"dist\")\n+\tif buildArgs.outPath != \"\" {\n+\t\toutPath = buildArgs.outPath\n+\t}\n+\tb, err := dist.NewBuild(wd, outPath)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"creating build context: %w\", err)\n \t}\n---\n\n\n---\n\nChoice B:\nfeature/taildrop/integration_test.go\n@@ -26,6 +26,21 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n+\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n+\ttestTaildropIntegration(t, false)\n+}\n+\n+func TestTaildropIntegration_Fresh(t *testing.T) {\n+\ttestTaildropIntegration(t, true)\n+}\n+\n+// freshProfiles is whether to start the test right away\n+// with a fresh profile. If false, tailscaled is started, stopped,\n+// and restarted again to simulate a real-world scenario where\n+// the first profile already existed.\n+//\n+// This exercises an ipnext hook ordering issue we hit earlier.\n+func testTaildropIntegration(t *testing.T, freshProfiles bool) {\n \ttstest.Parallel(t)\n \tcontrolOpt := integration.ConfigureControl(func(s *testcontrol.Server) {\n \t\ts.AllNodesSameUser = true // required for Taildrop\n@@ -39,18 +54,30 @@ func TestTaildropIntegration(t *testing.T) {\n \tn2 := integration.NewTestNode(t, env)\n \td2 := n2.StartDaemon()\n \n-\tn1.AwaitListening()\n-\tt.Logf(\"n1 is listening\")\n-\tn2.AwaitListening()\n-\tt.Logf(\"n2 is listening\")\n-\tn1.MustUp()\n-\tt.Logf(\"n1 is up\")\n-\tn2.MustUp()\n-\tt.Logf(\"n2 is up\")\n-\tn1.AwaitRunning()\n-\tt.Logf(\"n1 is running\")\n-\tn2.AwaitRunning()\n-\tt.Logf(\"n2 is running\")\n+\tawaitUp := func() {\n+\t\tt.Helper()\n+\t\tn1.AwaitListening()\n+\t\tt.Logf(\"n1 is listening\")\n+\t\tn2.AwaitListening()\n+\t\tt.Logf(\"n2 is listening\")\n+\t\tn1.MustUp()\n+\t\tt.Logf(\"n1 is up\")\n+\t\tn2.MustUp()\n+\t\tt.Logf(\"n2 is up\")\n+\t\tn1.AwaitRunning()\n+\t\tt.Logf(\"n1 is running\")\n+\t\tn2.AwaitRunning()\n+\t\tt.Logf(\"n2 is running\")\n+\t}\n+\tawaitUp()\n+\n+\tif !freshProfiles {\n+\t\td1.MustCleanShutdown(t)\n+\t\td2.MustCleanShutdown(t)\n+\t\td1 = n1.StartDaemon()\n+\t\td2 = n2.StartDaemon()\n+\t\tawaitUp()\n+\t}\n \n \tvar peerStableID tailcfg.StableNodeID\n \n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/init@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/autobuild@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/analyze@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/drive.go\n@@ -4,6 +4,7 @@\n package ipnlocal\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"slices\"\n@@ -338,7 +339,7 @@ func (b *LocalBackend) driveRemotesFromPeers(nm *netmap.NetworkMap) []*drive.Rem\n \t\t\t\t// Check that the peer is allowed to share with us.\n \t\t\t\taddresses := peer.Addresses()\n \t\t\t\tfor _, p := range addresses.All() {\n-\t\t\t\t\tif cn.PeerHasCap(p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n+\t\t\t\t\tif cn.PeerHasCap(context.Background(), p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n---\nipn/ipnlocal/local.go\n@@ -96,6 +96,7 @@ import (\n \t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/util/clientmetric\"\n+\t\"tailscale.com/util/ctxkey\"\n \t\"tailscale.com/util/deephash\"\n \t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/goroutines\"\n@@ -1463,15 +1464,19 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+var nodeCtxLockedKey = ctxkey.New(\"localNodeContext-locked\", false)\n+\n+var ctxNodeContextLocked = nodeCtxLockedKey.WithValue(context.Background(), true)\n+\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(context.Context, tailcfg.NodeView) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tif pred(ctxNodeContextLocked, peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n@@ -6652,9 +6657,11 @@ func (b *LocalBackend) TestOnlyPublicKeys() (machineKey key.MachinePublic, nodeK\n \n // PeerHasCap reports whether the peer with the given Tailscale IP addresses\n // contains the given capability string, with any value(s).\n-func (b *localNodeContext) PeerHasCap(addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n-\tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n+func (b *localNodeContext) PeerHasCap(ctx context.Context, addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n+\tif !nodeCtxLockedKey.Value(ctx) {\n+\t\tb.mu.Lock()\n+\t\tdefer b.mu.Unlock()\n+\t}\n \treturn b.peerHasCapLocked(addr, wantCap)\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n+\tpeers := cn.AppendMatchingPeers(nil, func(ctx context.Context, p tailcfg.NodeView) bool {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n \t\tif self != p.User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(ctx, p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n@@ -241,7 +241,7 @@ func (b *LocalBackend) taildropTargetStatus(p tailcfg.NodeView) ipnstate.Taildro\n \t}\n \tif nm.User() != p.User() {\n \t\t// Different user must have the explicit file sharing target capability\n-\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(context.Background(), p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn ipnstate.TaildropTargetOwnedByOtherUser\n \t\t}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [github/codeql-action](https://github.com/github/codeql-action) from 3.28.14 to 3.28.15.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/releases\">github/codeql-action's releases</a>.</em></p>\n<blockquote>\n<h2>v3.28.15</h2>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>3.28.15 - 07 Apr 2025</h2>\n<ul>\n<li>Fix bug where the action would fail if it tried to produce a debug artifact with more than 65535 files. <a href=\"https://redirect.github.com/github/codeql-action/pull/2842\">#2842</a></li>\n</ul>\n<p>See the full <a href=\"https://github.com/github/codeql-action/blob/v3.28.15/CHANGELOG.md\">CHANGELOG.md</a> for more information.</p>\n</blockquote>\n</details>\n<details>\n<summary>Changelog</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/blob/main/CHANGELOG.md\">github/codeql-action's changelog</a>.</em></p>\n<blockquote>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>[UNRELEASED]</h2>\n<p>No user facing changes.</p>\n<h2>3.28.15 - 07 Apr 2025</h2>\n<ul>\n<li>Fix bug where the action would fail if it tried to produce a debug artifact with more than 65535 files. <a href=\"https://redirect.github.com/github/codeql-action/pull/2842\">#2842</a></li>\n</ul>\n<h2>3.28.14 - 07 Apr 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.0. <a href=\"https://redirect.github.com/github/codeql-action/pull/2838\">#2838</a></li>\n</ul>\n<h2>3.28.13 - 24 Mar 2025</h2>\n<p>No user facing changes.</p>\n<h2>3.28.12 - 19 Mar 2025</h2>\n<ul>\n<li>Dependency caching should now cache more dependencies for Java <code>build-mode: none</code> extractions. This should speed up workflows and avoid inconsistent alerts in some cases.</li>\n<li>Update default CodeQL bundle version to 2.20.7. <a href=\"https://redirect.github.com/github/codeql-action/pull/2810\">#2810</a></li>\n</ul>\n<h2>3.28.11 - 07 Mar 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.6. <a href=\"https://redirect.github.com/github/codeql-action/pull/2793\">#2793</a></li>\n</ul>\n<h2>3.28.10 - 21 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.5. <a href=\"https://redirect.github.com/github/codeql-action/pull/2772\">#2772</a></li>\n<li>Address an issue where the CodeQL Bundle would occasionally fail to decompress on macOS. <a href=\"https://redirect.github.com/github/codeql-action/pull/2768\">#2768</a></li>\n</ul>\n<h2>3.28.9 - 07 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.4. <a href=\"https://redirect.github.com/github/codeql-action/pull/2753\">#2753</a></li>\n</ul>\n<h2>3.28.8 - 29 Jan 2025</h2>\n<ul>\n<li>Enable support for Kotlin 2.1.10 when running with CodeQL CLI v2.20.3. <a href=\"https://redirect.github.com/github/codeql-action/pull/2744\">#2744</a></li>\n</ul>\n<h2>3.28.7 - 29 Jan 2025</h2>\n<p>No user facing changes.</p>\n<h2>3.28.6 - 27 Jan 2025</h2>\n<ul>\n<li>Re-enable debug artifact upload for CLI versions 2.20.3 or greater. <a href=\"https://redirect.github.com/github/codeql-action/pull/2726\">#2726</a></li>\n</ul>\n<!-- raw HTML omitted -->\n</blockquote>\n<p>... (truncated)</p>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/github/codeql-action/commit/45775bd8235c68ba998cffa5171334d58593da47\"><code>45775bd</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2854\">#2854</a> from github/update-v3.28.15-a35ae8c38</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/dd78aab4078b17a672a66d6a80a990beb672ede1\"><code>dd78aab</code></a> Update CHANGELOG.md with bug fix details</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/e40af591743761de70080085b4e6ce37f7f6e657\"><code>e40af59</code></a> Update changelog for v3.28.15</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/a35ae8c380fa35365cd546f9a397a46f60dd82cf\"><code>a35ae8c</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2843\">#2843</a> from github/cklin/diff-informed-compat</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/bb59df6c174a91d88eec1c48f2ab0ef7b5f96e99\"><code>bb59df6</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2842\">#2842</a> from github/henrymercer/zip64</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/4b508f59648bef88ef72c74f1ffff531fda55ea8\"><code>4b508f5</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2845\">#2845</a> from github/mergeback/v3.28.14-to-main-fc7e4a0f</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/ca00afb5f1457cf1c85da6cda07d73e720ff061a\"><code>ca00afb</code></a> Update checked-in dependencies</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/2969c78ce0262bf75658058604498d2b4bdb0b9b\"><code>2969c78</code></a> Update changelog and version after v3.28.14</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/a8be43c24e13329b9e2174ec1941e06e03636dcc\"><code>a8be43c</code></a> Don't throw error for ENOENT</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/94102d99b09e7d264feadfa60efe4c3f0912c7ce\"><code>94102d9</code></a> Set checkPresence in diff-range data extension</li>\n<li>Additional commits viewable in <a href=\"https://github.com/github/codeql-action/compare/fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2...45775bd8235c68ba998cffa5171334d58593da47\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=github/codeql-action&package-manager=github_actions&previous-version=3.28.14&new-version=3.28.15)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n+      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n---\n\n\n---\n\nChoice B:\nbuild_docker.sh\n@@ -16,7 +16,7 @@ eval \"$(./build_dist.sh shellvars)\"\n \n DEFAULT_TARGET=\"client\"\n DEFAULT_TAGS=\"v${VERSION_SHORT},v${VERSION_MINOR}\"\n-DEFAULT_BASE=\"tailscale/alpine-base:3.18\"\n+DEFAULT_BASE=\"tailscale/alpine-base:3.19\"\n # Set a few pre-defined OCI annotations. The source annotation is used by tools such as Renovate that scan the linked\n # Github repo to find release notes for any new image tags. Note that for official Tailscale images the default\n # annotations defined here will be overriden by release scripts that call this script.\n---\n\n\n---\n\nChoice C:\ncmd/natc/natc.go\n@@ -13,6 +13,7 @@ import (\n \t\"flag\"\n \t\"fmt\"\n \t\"log\"\n+\t\"math/rand/v2\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/netip\"\n@@ -438,7 +439,7 @@ func (c *connector) handleTCPFlow(src, dst netip.AddrPort) (handler func(net.Con\n \t\treturn nil, false\n \t}\n \treturn func(conn net.Conn) {\n-\t\tproxyTCPConn(conn, domain)\n+\t\tproxyTCPConn(conn, domain, c)\n \t}, true\n }\n \n@@ -456,16 +457,34 @@ func (c *connector) ignoreDestination(dstAddrs []netip.Addr) bool {\n \treturn false\n }\n \n-func proxyTCPConn(c net.Conn, dest string) {\n+func proxyTCPConn(c net.Conn, dest string, ctor *connector) {\n \tif c.RemoteAddr() == nil {\n \t\tlog.Printf(\"proxyTCPConn: nil RemoteAddr\")\n \t\tc.Close()\n \t\treturn\n \t}\n-\taddrPortStr := c.LocalAddr().String()\n-\t_, port, err := net.SplitHostPort(addrPortStr)\n+\tladdr, err := netip.ParseAddrPort(c.LocalAddr().String())\n \tif err != nil {\n-\t\tlog.Printf(\"tcpRoundRobinHandler.Handle: bogus addrPort %q\", addrPortStr)\n+\t\tlog.Printf(\"proxyTCPConn: ParseAddrPort failed: %v\", err)\n+\t\tc.Close()\n+\t\treturn\n+\t}\n+\n+\tdaddrs, err := ctor.resolver.LookupNetIP(context.TODO(), \"ip\", dest)\n+\tif err != nil {\n+\t\tlog.Printf(\"proxyTCPConn: LookupNetIP failed: %v\", err)\n+\t\tc.Close()\n+\t\treturn\n+\t}\n+\n+\tif len(daddrs) == 0 {\n+\t\tlog.Printf(\"proxyTCPConn: no IP addresses found for %s\", dest)\n+\t\tc.Close()\n+\t\treturn\n+\t}\n+\n+\tif ctor.ignoreDestination(daddrs) {\n+\t\tlog.Printf(\"proxyTCPConn: closing connection to ignored destination %s (%v)\", dest, daddrs)\n \t\tc.Close()\n \t\treturn\n \t}\n@@ -475,10 +494,37 @@ func proxyTCPConn(c net.Conn, dest string) {\n \t\t\treturn netutil.NewOneConnListener(c, nil), nil\n \t\t},\n \t}\n-\t// XXX(raggi): if the connection here resolves to an ignored destination,\n-\t// the connection should be closed/failed.\n-\tp.AddRoute(addrPortStr, &tcpproxy.DialProxy{\n-\t\tAddr: fmt.Sprintf(\"%s:%s\", dest, port),\n+\n+\t// TODO(raggi): more code could avoid this shuffle, but avoiding allocations\n+\t// for now most of the time daddrs will be short.\n+\trand.Shuffle(len(daddrs), func(i, j int) {\n+\t\tdaddrs[i], daddrs[j] = daddrs[j], daddrs[i]\n \t})\n+\tdaddr := daddrs[0]\n+\n+\t// Try to match the upstream and downstream protocols (v4/v6)\n+\tif laddr.Addr().Is6() {\n+\t\tfor _, addr := range daddrs {\n+\t\t\tif addr.Is6() {\n+\t\t\t\tdaddr = addr\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tfor _, addr := range daddrs {\n+\t\t\tif addr.Is4() {\n+\t\t\t\tdaddr = addr\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// TODO(raggi): drop this library, it ends up being allocation and\n+\t// indirection heavy and really doesn't help us here.\n+\tdsockaddrs := netip.AddrPortFrom(daddr, laddr.Port()).String()\n+\tp.AddRoute(dsockaddrs, &tcpproxy.DialProxy{\n+\t\tAddr: dsockaddrs,\n+\t})\n+\n \tp.Start()\n }\n---\n\n\n---\n\nChoice D:\nutil/testenv/testenv.go\n@@ -6,6 +6,7 @@\n package testenv\n \n import (\n+\t\"context\"\n \t\"flag\"\n \n \t\"tailscale.com/types/lazy\"\n@@ -19,3 +20,41 @@ func InTest() bool {\n \t\treturn flag.Lookup(\"test.v\") != nil\n \t})\n }\n+\n+// TB is testing.TB, to avoid importing \"testing\" in non-test code.\n+type TB interface {\n+\tCleanup(func())\n+\tError(args ...any)\n+\tErrorf(format string, args ...any)\n+\tFail()\n+\tFailNow()\n+\tFailed() bool\n+\tFatal(args ...any)\n+\tFatalf(format string, args ...any)\n+\tHelper()\n+\tLog(args ...any)\n+\tLogf(format string, args ...any)\n+\tName() string\n+\tSetenv(key, value string)\n+\tChdir(dir string)\n+\tSkip(args ...any)\n+\tSkipNow()\n+\tSkipf(format string, args ...any)\n+\tSkipped() bool\n+\tTempDir() string\n+\tContext() context.Context\n+}\n+\n+// InParallelTest reports whether t is running as a parallel test.\n+//\n+// Use of this function taints t such that its Parallel method (assuming t is an\n+// actual *testing.T) will panic if called after this function.\n+func InParallelTest(t TB) (isParallel bool) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tisParallel = true\n+\t\t}\n+\t}()\n+\tt.Chdir(\".\") // panics in a t.Parallel test\n+\treturn false\n+}\n---\nutil/testenv/testenv_test.go\n@@ -16,3 +16,16 @@ func TestDeps(t *testing.T) {\n \t\t},\n \t}.Check(t)\n }\n+\n+func TestInParallelTestTrue(t *testing.T) {\n+\tt.Parallel()\n+\tif !InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return true once t.Parallel has been called\")\n+\t}\n+}\n+\n+func TestInParallelTestFalse(t *testing.T) {\n+\tif InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return false before t.Parallel has been called\")\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis PR adds an 'Age' column to the ProxyGroup resource display in kubectl output.\r\nThe age is calculated from the resource's creation timestamp and will be displayed\r\nin a human-readable format (e.g. \"3h\", \"2d\", etc.).\r\n\r\nChanges:\r\n- Added kubebuilder marker for the Age column in types_proxygroup.go\r\n- The Age column uses the metadata.creationTimestamp field to calculate the resource's age\r\n\r\nFixes: #15499\n\n---\n\nChoice A:\nfeature/taildrop/integration_test.go\n@@ -26,6 +26,21 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n+\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n+\ttestTaildropIntegration(t, false)\n+}\n+\n+func TestTaildropIntegration_Fresh(t *testing.T) {\n+\ttestTaildropIntegration(t, true)\n+}\n+\n+// freshProfiles is whether to start the test right away\n+// with a fresh profile. If false, tailscaled is started, stopped,\n+// and restarted again to simulate a real-world scenario where\n+// the first profile already existed.\n+//\n+// This exercises an ipnext hook ordering issue we hit earlier.\n+func testTaildropIntegration(t *testing.T, freshProfiles bool) {\n \ttstest.Parallel(t)\n \tcontrolOpt := integration.ConfigureControl(func(s *testcontrol.Server) {\n \t\ts.AllNodesSameUser = true // required for Taildrop\n@@ -39,18 +54,30 @@ func TestTaildropIntegration(t *testing.T) {\n \tn2 := integration.NewTestNode(t, env)\n \td2 := n2.StartDaemon()\n \n-\tn1.AwaitListening()\n-\tt.Logf(\"n1 is listening\")\n-\tn2.AwaitListening()\n-\tt.Logf(\"n2 is listening\")\n-\tn1.MustUp()\n-\tt.Logf(\"n1 is up\")\n-\tn2.MustUp()\n-\tt.Logf(\"n2 is up\")\n-\tn1.AwaitRunning()\n-\tt.Logf(\"n1 is running\")\n-\tn2.AwaitRunning()\n-\tt.Logf(\"n2 is running\")\n+\tawaitUp := func() {\n+\t\tt.Helper()\n+\t\tn1.AwaitListening()\n+\t\tt.Logf(\"n1 is listening\")\n+\t\tn2.AwaitListening()\n+\t\tt.Logf(\"n2 is listening\")\n+\t\tn1.MustUp()\n+\t\tt.Logf(\"n1 is up\")\n+\t\tn2.MustUp()\n+\t\tt.Logf(\"n2 is up\")\n+\t\tn1.AwaitRunning()\n+\t\tt.Logf(\"n1 is running\")\n+\t\tn2.AwaitRunning()\n+\t\tt.Logf(\"n2 is running\")\n+\t}\n+\tawaitUp()\n+\n+\tif !freshProfiles {\n+\t\td1.MustCleanShutdown(t)\n+\t\td2.MustCleanShutdown(t)\n+\t\td1 = n1.StartDaemon()\n+\t\td2 = n2.StartDaemon()\n+\t\tawaitUp()\n+\t}\n \n \tvar peerStableID tailcfg.StableNodeID\n \n---\n\n\n---\n\nChoice B:\nwgengine/magicsock/magicsock.go\n@@ -138,6 +138,7 @@ type Conn struct {\n \t// struct. Initialized once at construction, then constant.\n \n \teventBus               *eventbus.Bus\n+\teventClient            *eventbus.Client\n \tlogf                   logger.Logf\n \tepFunc                 func([]tailcfg.Endpoint)\n \tderpActiveFunc         func()\n@@ -547,6 +548,31 @@ func NewConn(opts Options) (*Conn, error) {\n \tc.testOnlyPacketListener = opts.TestOnlyPacketListener\n \tc.noteRecvActivity = opts.NoteRecvActivity\n \n+\t// If an event bus is enabled, subscribe to portmapping changes; otherwise\n+\t// use the callback mechanism of portmapper.Client.\n+\t//\n+\t// TODO(creachadair): Remove the switch once the event bus is mandatory.\n+\tonPortMapChanged := c.onPortMapChanged\n+\tif c.eventBus != nil {\n+\t\tc.eventClient = c.eventBus.Client(\"magicsock.Conn\")\n+\n+\t\tpmSub := eventbus.Subscribe[portmapper.Mapping](c.eventClient)\n+\t\tgo func() {\n+\t\t\tdefer pmSub.Close()\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase <-pmSub.Events():\n+\t\t\t\t\tc.onPortMapChanged()\n+\t\t\t\tcase <-pmSub.Done():\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\n+\t\t// Disable the explicit callback from the portmapper, the subscriber handles it.\n+\t\tonPortMapChanged = nil\n+\t}\n+\n \t// Don't log the same log messages possibly every few seconds in our\n \t// portmapper.\n \tportmapperLogf := logger.WithPrefix(c.logf, \"portmapper: \")\n@@ -560,7 +586,7 @@ func NewConn(opts Options) (*Conn, error) {\n \t\tNetMon:       opts.NetMon,\n \t\tDebugKnobs:   portMapOpts,\n \t\tControlKnobs: opts.ControlKnobs,\n-\t\tOnChange:     c.onPortMapChanged,\n+\t\tOnChange:     onPortMapChanged,\n \t})\n \tc.portMapper.SetGatewayLookupFunc(opts.NetMon.GatewayAndSelfIP)\n \tc.netMon = opts.NetMon\n@@ -2478,6 +2504,9 @@ func (c *connBind) Close() error {\n \tif c.closeDisco6 != nil {\n \t\tc.closeDisco6.Close()\n \t}\n+\tif c.eventClient != nil {\n+\t\tc.eventClient.Close()\n+\t}\n \t// Send an empty read result to unblock receiveDERP,\n \t// which will then check connBind.Closed.\n \t// connBind.Closed takes c.mu, but c.derpRecvCh is buffered.\n---\n\n\n---\n\nChoice C:\ncmd/k8s-operator/deploy/crds/tailscale.com_connectors.yaml\n@@ -32,6 +32,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_dnsconfigs.yaml\n@@ -20,6 +20,9 @@ spec:\n           jsonPath: .status.nameserver.ip\n           name: NameserverIP\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -18,6 +18,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxygroups.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .spec.type\n           name: Type\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_recorders.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .status.devices[?(@.url != \"\")].url\n           name: URL\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -61,6 +61,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -312,6 +315,9 @@ spec:\n               jsonPath: .status.nameserver.ip\n               name: NameserverIP\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -492,6 +498,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -2803,6 +2812,9 @@ spec:\n               jsonPath: .spec.type\n               name: Type\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -3013,6 +3025,9 @@ spec:\n               jsonPath: .status.devices[?(@.url != \"\")].url\n               name: URL\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n---\nk8s-operator/apis/v1alpha1/types_connector.go\n@@ -24,6 +24,7 @@ var ConnectorKind = \"Connector\"\n // +kubebuilder:printcolumn:name=\"IsExitNode\",type=\"string\",JSONPath=`.status.isExitNode`,description=\"Whether this Connector instance defines an exit node.\"\n // +kubebuilder:printcolumn:name=\"IsAppConnector\",type=\"string\",JSONPath=`.status.isAppConnector`,description=\"Whether this Connector instance is an app connector.\"\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ConnectorReady\")].reason`,description=\"Status of the deployed Connector resources.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Connector defines a Tailscale node that will be deployed in the cluster. The\n // node can be configured to act as a Tailscale subnet router and/or a Tailscale\n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -16,6 +16,7 @@ var ProxyClassKind = \"ProxyClass\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyClassReady\")].reason`,description=\"Status of the ProxyClass.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyClass describes a set of configuration parameters that can be applied to\n // proxy resources created by the Tailscale Kubernetes operator.\n---\nk8s-operator/apis/v1alpha1/types_proxygroup.go\n@@ -14,6 +14,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=pg\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyGroupReady\")].reason`,description=\"Status of the deployed ProxyGroup resources.\"\n // +kubebuilder:printcolumn:name=\"Type\",type=\"string\",JSONPath=`.spec.type`,description=\"ProxyGroup type.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyGroup defines a set of Tailscale devices that will act as proxies.\n // Currently only egress ProxyGroups are supported.\n---\nk8s-operator/apis/v1alpha1/types_recorder.go\n@@ -15,6 +15,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=rec\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"RecorderReady\")].reason`,description=\"Status of the deployed Recorder resources.\"\n // +kubebuilder:printcolumn:name=\"URL\",type=\"string\",JSONPath=`.status.devices[?(@.url != \"\")].url`,description=\"URL on which the UI is exposed if enabled.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Recorder defines a tsrecorder device for recording SSH sessions. By default,\n // it will store recordings in a local ephemeral volume. If you want to persist\n---\nk8s-operator/apis/v1alpha1/types_tsdnsconfig.go\n@@ -18,6 +18,7 @@ var DNSConfigKind = \"DNSConfig\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster,shortName=dc\n // +kubebuilder:printcolumn:name=\"NameserverIP\",type=\"string\",JSONPath=`.status.nameserver.ip`,description=\"Service IP address of the nameserver\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // DNSConfig can be deployed to cluster to make a subset of Tailscale MagicDNS\n // names resolvable by cluster workloads. Use this if: A) you need to refer to\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -5918,19 +5918,22 @@ func (b *LocalBackend) requestEngineStatusAndWait() {\n \tb.logf(\"requestEngineStatusAndWait: got status update.\")\n }\n \n+// [controlclient.Auto] implements [auditlog.Transport].\n+var _ auditlog.Transport = (*controlclient.Auto)(nil)\n+\n // setControlClientLocked sets the control client to cc,\n // which may be nil.\n //\n // b.mu must be held.\n func (b *LocalBackend) setControlClientLocked(cc controlclient.Client) {\n \tb.cc = cc\n \tb.ccAuto, _ = cc.(*controlclient.Auto)\n-\tif b.auditLogger != nil {\n+\tif t, ok := b.cc.(auditlog.Transport); ok && b.auditLogger != nil {\n \t\tif err := b.auditLogger.SetProfileID(b.pm.CurrentProfile().ID()); err != nil {\n \t\t\tb.logf(\"audit logger set profile ID failure: %v\", err)\n \t\t}\n \n-\t\tif err := b.auditLogger.Start(b.ccAuto); err != nil {\n+\t\tif err := b.auditLogger.Start(t); err != nil {\n \t\t\tb.logf(\"audit logger start failure: %v\", err)\n \t\t}\n \t}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBump to latest 22.x LTS release for node as the 18.x line is going EOL this month.\r\n\r\nUpdates https://github.com/tailscale/corp/issues/27737\n\n---\n\nChoice A:\nipn/ipnlocal/peerapi.go\n@@ -417,7 +417,7 @@ func (h *peerAPIHandler) handleServeIngress(w http.ResponseWriter, r *http.Reque\n \t}\n \tlogAndError := func(code int, publicMsg string) {\n \t\th.logf(\"ingress: bad request from %v: %s\", h.remoteAddr, publicMsg)\n-\t\thttp.Error(w, publicMsg, http.StatusMethodNotAllowed)\n+\t\thttp.Error(w, publicMsg, code)\n \t}\n \tbad := func(publicMsg string) {\n \t\tlogAndError(http.StatusBadRequest, publicMsg)\n---\n\n\n---\n\nChoice B:\ncmd/derper/depaware.txt\n@@ -12,7 +12,7 @@ tailscale.com/cmd/derper dependencies: (generated by github.com/tailscale/depawa\n         github.com/coder/websocket/internal/util                     from github.com/coder/websocket\n         github.com/coder/websocket/internal/xsync                    from github.com/coder/websocket\n    L    github.com/coreos/go-iptables/iptables                       from tailscale.com/util/linuxfw\n-   W \ud83d\udca3 github.com/dblohm7/wingoes                                   from tailscale.com/util/winutil\n+   W \ud83d\udca3 github.com/dblohm7/wingoes                                   from tailscale.com/util/winutil+\n         github.com/fxamacker/cbor/v2                                 from tailscale.com/tka\n         github.com/go-json-experiment/json                           from tailscale.com/types/opt+\n         github.com/go-json-experiment/json/internal                  from github.com/go-json-experiment/json+\n---\nnet/tshttpproxy/tshttpproxy_windows.go\n@@ -18,6 +18,7 @@ import (\n \t\"unsafe\"\n \n \t\"github.com/alexbrainman/sspi/negotiate\"\n+\t\"github.com/dblohm7/wingoes\"\n \t\"golang.org/x/sys/windows\"\n \t\"tailscale.com/hostinfo\"\n \t\"tailscale.com/syncs\"\n@@ -97,9 +98,7 @@ func proxyFromWinHTTPOrCache(req *http.Request) (*url.URL, error) {\n \t\t}\n \t\tif err == windows.ERROR_INVALID_PARAMETER {\n \t\t\tmetricErrInvalidParameters.Add(1)\n-\t\t\t// Seen on Windows 8.1. (https://github.com/tailscale/tailscale/issues/879)\n-\t\t\t// TODO(bradfitz): figure this out.\n-\t\t\tsetNoProxyUntil(time.Hour)\n+\t\t\tsetNoProxyUntil(10 * time.Second)\n \t\t\tproxyErrorf(\"tshttpproxy: winhttp: GetProxyForURL(%q): ERROR_INVALID_PARAMETER [unexpected]\", urlStr)\n \t\t\treturn nil, nil\n \t\t}\n@@ -238,17 +237,30 @@ func (pi *winHTTPProxyInfo) free() {\n \t}\n }\n \n-var proxyForURLOpts = &winHTTPAutoProxyOptions{\n-\tDwFlags:           winHTTP_AUTOPROXY_ALLOW_AUTOCONFIG | winHTTP_AUTOPROXY_AUTO_DETECT,\n-\tDwAutoDetectFlags: winHTTP_AUTO_DETECT_TYPE_DHCP, // | winHTTP_AUTO_DETECT_TYPE_DNS_A,\n-}\n+var getProxyForURLOpts = sync.OnceValue(func() *winHTTPAutoProxyOptions {\n+\topts := &winHTTPAutoProxyOptions{\n+\t\tDwFlags:           winHTTP_AUTOPROXY_AUTO_DETECT,\n+\t\tDwAutoDetectFlags: winHTTP_AUTO_DETECT_TYPE_DHCP | winHTTP_AUTO_DETECT_TYPE_DNS_A,\n+\t}\n+\t// Support for the WINHTTP_AUTOPROXY_ALLOW_AUTOCONFIG flag was added in Windows 10, version 1703.\n+\t//\n+\t// Using it on earlier versions causes GetProxyForURL to fail with ERROR_INVALID_PARAMETER,\n+\t// which prevents proxy detection and can lead to failures reaching the control server\n+\t// on environments where a proxy is required.\n+\t//\n+\t// https://web.archive.org/web/20250529044903/https://learn.microsoft.com/en-us/windows/win32/api/winhttp/ns-winhttp-winhttp_autoproxy_options\n+\tif wingoes.IsWin10BuildOrGreater(wingoes.Win10Build1703) {\n+\t\topts.DwFlags |= winHTTP_AUTOPROXY_ALLOW_AUTOCONFIG\n+\t}\n+\treturn opts\n+})\n \n func (hi winHTTPInternet) GetProxyForURL(urlStr string) (string, error) {\n \tvar out winHTTPProxyInfo\n \terr := winHTTPGetProxyForURL(\n \t\thi,\n \t\twindows.StringToUTF16Ptr(urlStr),\n-\t\tproxyForURLOpts,\n+\t\tgetProxyForURLOpts(),\n \t\t&out,\n \t)\n \tif err != nil {\n---\n\n\n---\n\nChoice C:\ncmd/natc/natc.go\n@@ -94,18 +94,24 @@ func main() {\n \t\t}\n \t\tignoreDstTable.Insert(pfx, true)\n \t}\n-\tvar v4Prefixes []netip.Prefix\n+\tvar (\n+\t\tv4Prefixes    []netip.Prefix\n+\t\tnumV4DNSAddrs int\n+\t)\n \tfor _, s := range strings.Split(*v4PfxStr, \",\") {\n \t\tp := netip.MustParsePrefix(strings.TrimSpace(s))\n \t\tif p.Masked() != p {\n \t\t\tlog.Fatalf(\"v4 prefix %v is not a masked prefix\", p)\n \t\t}\n \t\tv4Prefixes = append(v4Prefixes, p)\n+\t\tnumIPs := 1 << (32 - p.Bits())\n+\t\tnumV4DNSAddrs += numIPs\n \t}\n \tif len(v4Prefixes) == 0 {\n \t\tlog.Fatalf(\"no v4 prefixes specified\")\n \t}\n \tdnsAddr := v4Prefixes[0].Addr()\n+\tnumV4DNSAddrs -= 1 // Subtract the dnsAddr allocated above.\n \tts := &tsnet.Server{\n \t\tHostname: *hostname,\n \t}\n@@ -153,12 +159,13 @@ func main() {\n \t}\n \n \tc := &connector{\n-\t\tts:         ts,\n-\t\tlc:         lc,\n-\t\tdnsAddr:    dnsAddr,\n-\t\tv4Ranges:   v4Prefixes,\n-\t\tv6ULA:      ula(uint16(*siteID)),\n-\t\tignoreDsts: ignoreDstTable,\n+\t\tts:            ts,\n+\t\tlc:            lc,\n+\t\tdnsAddr:       dnsAddr,\n+\t\tv4Ranges:      v4Prefixes,\n+\t\tnumV4DNSAddrs: numV4DNSAddrs,\n+\t\tv6ULA:         ula(uint16(*siteID)),\n+\t\tignoreDsts:    ignoreDstTable,\n \t}\n \tc.run(ctx)\n }\n@@ -177,6 +184,11 @@ type connector struct {\n \t// v4Ranges is the list of IPv4 ranges to advertise and assign addresses from.\n \t// These are masked prefixes.\n \tv4Ranges []netip.Prefix\n+\n+\t// numV4DNSAddrs is the total size of the IPv4 ranges in addresses, minus the\n+\t// dnsAddr allocation.\n+\tnumV4DNSAddrs int\n+\n \t// v6ULA is the ULA prefix used by the app connector to assign IPv6 addresses.\n \tv6ULA netip.Prefix\n \n@@ -502,6 +514,7 @@ type perPeerState struct {\n \tmu           sync.Mutex\n \tdomainToAddr map[string][]netip.Addr\n \taddrToDomain *bart.Table[string]\n+\tnumV4Allocs  int\n }\n \n // domainForIP returns the domain name assigned to the given IP address and\n@@ -547,17 +560,25 @@ func (ps *perPeerState) isIPUsedLocked(ip netip.Addr) bool {\n \n // unusedIPv4Locked returns an unused IPv4 address from the available ranges.\n func (ps *perPeerState) unusedIPv4Locked() netip.Addr {\n+\t// All addresses have been allocated.\n+\tif ps.numV4Allocs >= ps.c.numV4DNSAddrs {\n+\t\treturn netip.Addr{}\n+\t}\n+\n \t// TODO: skip ranges that have been exhausted\n-\tfor _, r := range ps.c.v4Ranges {\n-\t\tip := randV4(r)\n-\t\tfor r.Contains(ip) {\n+\t// TODO: implement a much more efficient algorithm for finding unused IPs,\n+\t// this is fairly crazy.\n+\tfor {\n+\t\tfor _, r := range ps.c.v4Ranges {\n+\t\t\tip := randV4(r)\n+\t\t\tif !r.Contains(ip) {\n+\t\t\t\tpanic(\"error: randV4 returned invalid address\")\n+\t\t\t}\n \t\t\tif !ps.isIPUsedLocked(ip) && ip != ps.c.dnsAddr {\n \t\t\t\treturn ip\n \t\t\t}\n-\t\t\tip = ip.Next()\n \t\t}\n \t}\n-\treturn netip.Addr{}\n }\n \n // randV4 returns a random IPv4 address within the given prefix.\n@@ -583,6 +604,7 @@ func (ps *perPeerState) assignAddrsLocked(domain string) []netip.Addr {\n \tif !v4.IsValid() {\n \t\treturn nil\n \t}\n+\tps.numV4Allocs++\n \tas16 := ps.c.v6ULA.Addr().As16()\n \tas4 := v4.As4()\n \tcopy(as16[12:], as4[:])\n---\ncmd/natc/natc_test.go\n@@ -4,6 +4,8 @@\n package main\n \n import (\n+\t\"errors\"\n+\t\"fmt\"\n \t\"net/netip\"\n \t\"slices\"\n \t\"testing\"\n@@ -225,9 +227,10 @@ func TestDNSResponse(t *testing.T) {\n \n func TestPerPeerState(t *testing.T) {\n \tc := &connector{\n-\t\tv4Ranges: []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n-\t\tv6ULA:    netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n-\t\tdnsAddr:  netip.MustParseAddr(\"100.64.1.1\"),\n+\t\tv4Ranges:      []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n+\t\tv6ULA:         netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n+\t\tdnsAddr:       netip.MustParseAddr(\"100.64.1.0\"),\n+\t\tnumV4DNSAddrs: (1<<(32-24) - 1),\n \t}\n \n \tps := &perPeerState{c: c}\n@@ -328,9 +331,10 @@ func TestIgnoreDestination(t *testing.T) {\n \n func TestConnectorGenerateDNSResponse(t *testing.T) {\n \tc := &connector{\n-\t\tv4Ranges: []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n-\t\tv6ULA:    netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n-\t\tdnsAddr:  netip.MustParseAddr(\"100.64.1.1\"),\n+\t\tv4Ranges:      []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n+\t\tv6ULA:         netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n+\t\tdnsAddr:       netip.MustParseAddr(\"100.64.1.0\"),\n+\t\tnumV4DNSAddrs: (1<<(32-24) - 1),\n \t}\n \n \treq := &dnsmessage.Message{\n@@ -363,3 +367,63 @@ func TestConnectorGenerateDNSResponse(t *testing.T) {\n \t\tt.Errorf(\"generateDNSResponse() responses differ between calls\")\n \t}\n }\n+\n+func TestIPPoolExhaustion(t *testing.T) {\n+\tsmallPrefix := netip.MustParsePrefix(\"100.64.1.0/30\") // Only 4 IPs: .0, .1, .2, .3\n+\tc := &connector{\n+\t\tv6ULA:         netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n+\t\tv4Ranges:      []netip.Prefix{smallPrefix},\n+\t\tdnsAddr:       netip.MustParseAddr(\"100.64.1.0\"),\n+\t\tnumV4DNSAddrs: 3,\n+\t}\n+\n+\tps := &perPeerState{c: c}\n+\n+\tassignedIPs := make(map[netip.Addr]string)\n+\n+\tdomains := []string{\"a.example.com\", \"b.example.com\", \"c.example.com\", \"d.example.com\"}\n+\n+\tvar errs []error\n+\n+\tfor i := 0; i < 5; i++ {\n+\t\tfor _, domain := range domains {\n+\t\t\taddrs, err := ps.ipForDomain(domain)\n+\t\t\tif err != nil {\n+\t\t\t\terrs = append(errs, fmt.Errorf(\"failed to get IP for domain %q: %w\", domain, err))\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tfor _, addr := range addrs {\n+\t\t\t\tif d, ok := assignedIPs[addr]; ok {\n+\t\t\t\t\tif d != domain {\n+\t\t\t\t\t\tt.Errorf(\"IP %s reused for domain %q, previously assigned to %q\", addr, domain, d)\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tassignedIPs[addr] = domain\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor addr, domain := range assignedIPs {\n+\t\tif addr.Is4() && !smallPrefix.Contains(addr) {\n+\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, smallPrefix)\n+\t\t}\n+\t\tif addr.Is6() && !c.v6ULA.Contains(addr) {\n+\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, c.v6ULA)\n+\t\t}\n+\t\tif addr == c.dnsAddr {\n+\t\t\tt.Errorf(\"IP %s for domain %q is the reserved DNS address\", addr, domain)\n+\t\t}\n+\t}\n+\n+\t// expect one error for each iteration with the 4th domain\n+\tif len(errs) != 5 {\n+\t\tt.Errorf(\"Expected 5 errors, got %d: %v\", len(errs), errs)\n+\t}\n+\tfor _, err := range errs {\n+\t\tif !errors.Is(err, ErrNoIPsAvailable) {\n+\t\t\tt.Errorf(\"generateDNSResponse() error = %v, want ErrNoIPsAvailable\", err)\n+\t\t}\n+\t}\n+}\n---\n\n\n---\n\nChoice D:\nclient/web/package.json\n@@ -3,7 +3,7 @@\n   \"version\": \"0.0.1\",\n   \"license\": \"BSD-3-Clause\",\n   \"engines\": {\n-    \"node\": \"18.20.4\",\n+    \"node\": \"22.14.0\",\n     \"yarn\": \"1.22.19\"\n   },\n   \"type\": \"module\",\n@@ -20,7 +20,7 @@\n     \"zustand\": \"^4.4.7\"\n   },\n   \"devDependencies\": {\n-    \"@types/node\": \"^18.16.1\",\n+    \"@types/node\": \"^22.14.0\",\n     \"@types/react\": \"^18.0.20\",\n     \"@types/react-dom\": \"^18.0.6\",\n     \"@vitejs/plugin-react-swc\": \"^3.6.0\",\n---\nclient/web/yarn.lock\n@@ -1880,12 +1880,12 @@\n   resolved \"https://registry.yarnpkg.com/@types/json5/-/json5-0.0.29.tgz#ee28707ae94e11d2b827bcbe5270bcea7f3e71ee\"\n   integrity sha512-dRLjCWHYg4oaA77cxO64oO+7JwCwnIzkZPdrrC71jQmQtlhM556pwKo5bUzqvZndkVbeFLIIi+9TC40JNF5hNQ==\n \n-\"@types/node@^18.16.1\":\n-  version \"18.19.18\"\n-  resolved \"https://registry.yarnpkg.com/@types/node/-/node-18.19.18.tgz#7526471b28828d1fef1f7e4960fb9477e6e4369c\"\n-  integrity sha512-80CP7B8y4PzZF0GWx15/gVWRrB5y/bIjNI84NK3cmQJu0WZwvmj2WMA5LcofQFVfLqqCSp545+U2LsrVzX36Zg==\n+\"@types/node@^22.14.0\":\n+  version \"22.14.0\"\n+  resolved \"https://registry.yarnpkg.com/@types/node/-/node-22.14.0.tgz#d3bfa3936fef0dbacd79ea3eb17d521c628bb47e\"\n+  integrity sha512-Kmpl+z84ILoG+3T/zQFyAJsU6EPTmOCj8/2+83fSN6djd6I4o7uOuGIH6vq3PrjY5BGitSbFuMN18j3iknubbA==\n   dependencies:\n-    undici-types \"~5.26.4\"\n+    undici-types \"~6.21.0\"\n \n \"@types/parse-json@^4.0.0\":\n   version \"4.0.2\"\n@@ -5124,10 +5124,10 @@ unbox-primitive@^1.0.2:\n     has-symbols \"^1.0.3\"\n     which-boxed-primitive \"^1.0.2\"\n \n-undici-types@~5.26.4:\n-  version \"5.26.5\"\n-  resolved \"https://registry.yarnpkg.com/undici-types/-/undici-types-5.26.5.tgz#bcd539893d00b56e964fd2657a4866b221a65617\"\n-  integrity sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA==\n+undici-types@~6.21.0:\n+  version \"6.21.0\"\n+  resolved \"https://registry.yarnpkg.com/undici-types/-/undici-types-6.21.0.tgz#691d00af3909be93a7faa13be61b3a5b50ef12cb\"\n+  integrity sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==\n \n unicode-canonical-property-names-ecmascript@^2.0.0:\n   version \"2.0.0\"\n---\ntool/node.rev\n@@ -1 +1 @@\n-18.20.4\n+22.14.0\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nupdates tailscale/tailscale#13476\r\n\r\nOn darwin, os.Hostname can be unreliable when called from a sandboxed process.  To fix this, we will allow clients to set an optional callback to query the hostname via an alternative native API like SystemConfiguration (on mac).\r\n\r\nWe will leave the default implementation as os.Hostname since this works perfectly well for everything besides sandboxed darwin clients.\n\n---\n\nChoice A:\ncmd/vnet/vnet-main.go\n@@ -7,15 +7,21 @@ package main\n \n import (\n \t\"context\"\n+\t\"encoding/binary\"\n \t\"flag\"\n+\t\"fmt\"\n+\t\"io\"\n \t\"log\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/http/httputil\"\n \t\"net/url\"\n \t\"os\"\n+\t\"path/filepath\"\n+\t\"slices\"\n \t\"time\"\n \n+\t\"github.com/coder/websocket\"\n \t\"tailscale.com/tstest/natlab/vnet\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/must\"\n@@ -31,10 +37,18 @@ var (\n \tpcapFile = flag.String(\"pcap\", \"\", \"if non-empty, filename to write pcap\")\n \tv4       = flag.Bool(\"v4\", true, \"enable IPv4\")\n \tv6       = flag.Bool(\"v6\", true, \"enable IPv6\")\n+\n+\twsproxyListen = flag.String(\"wsproxy\", \"\", \"if non-empty, TCP address to run websocket server on. See https://github.com/copy/v86/blob/master/docs/networking.md#backend-url-schemes\")\n )\n \n func main() {\n \tflag.Parse()\n+\tif *wsproxyListen != \"\" {\n+\t\tif err := runWSProxy(); err != nil {\n+\t\t\tlog.Fatalf(\"runWSProxy: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n \n \tif _, err := os.Stat(*listen); err == nil {\n \t\tos.Remove(*listen)\n@@ -137,3 +151,168 @@ func main() {\n \t\tgo s.ServeUnixConn(c.(*net.UnixConn), vnet.ProtocolQEMU)\n \t}\n }\n+\n+func runWSProxy() error {\n+\tln, err := net.Listen(\"tcp\", *wsproxyListen)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer ln.Close()\n+\n+\tlog.Printf(\"Running wsproxy mode on %v ...\", *wsproxyListen)\n+\n+\tvar hs http.Server\n+\ths.Handler = http.HandlerFunc(handleWebSocket)\n+\n+\treturn hs.Serve(ln)\n+}\n+\n+func handleWebSocket(w http.ResponseWriter, r *http.Request) {\n+\tconn, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\tif err != nil {\n+\t\tlog.Printf(\"Upgrade error: %v\", err)\n+\t\treturn\n+\t}\n+\tdefer conn.Close(websocket.StatusInternalError, \"closing\")\n+\tlog.Printf(\"WebSocket client connected: %s\", r.RemoteAddr)\n+\n+\tctx, cancel := context.WithCancel(r.Context())\n+\tdefer cancel()\n+\n+\tmessageType, firstData, err := conn.Read(ctx)\n+\tif err != nil {\n+\t\tlog.Printf(\"ReadMessage first: %v\", err)\n+\t\treturn\n+\t}\n+\tif messageType != websocket.MessageBinary {\n+\t\tlog.Printf(\"Ignoring non-binary message\")\n+\t\treturn\n+\t}\n+\tif len(firstData) < 12 {\n+\t\tlog.Printf(\"Ignoring short message\")\n+\t\treturn\n+\t}\n+\tclientMAC := vnet.MAC(firstData[6:12])\n+\n+\t// Set up a qemu-protocol Unix socket pair. We'll fake the qemu protocol here\n+\t// to avoid changing the vnet package.\n+\ttd, err := os.MkdirTemp(\"\", \"vnet\")\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"MkdirTemp: %v\", err))\n+\t}\n+\tdefer os.RemoveAll(td)\n+\n+\tunixSrv := filepath.Join(td, \"vnet.sock\")\n+\n+\tsrv, err := net.Listen(\"unix\", unixSrv)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"Listen: %v\", err))\n+\t}\n+\tdefer srv.Close()\n+\n+\tvar c vnet.Config\n+\tc.SetBlendReality(true)\n+\n+\tvar net1opt = []any{vnet.NAT(\"easy\")}\n+\tnet1opt = append(net1opt, \"2.1.1.1\", \"192.168.1.1/24\")\n+\tnet1opt = append(net1opt, \"2000:52::1/64\")\n+\n+\tc.AddNode(c.AddNetwork(net1opt...), clientMAC)\n+\n+\tvs, err := vnet.New(&c)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"newServer: %v\", err))\n+\t}\n+\tif err := vs.PopulateDERPMapIPs(); err != nil {\n+\t\tlog.Printf(\"warning: ignoring failure to populate DERP map: %v\", err)\n+\t\treturn\n+\t}\n+\n+\terrc := make(chan error, 1)\n+\tfail := func(err error) {\n+\t\tselect {\n+\t\tcase errc <- err:\n+\t\t\tlog.Printf(\"failed: %v\", err)\n+\t\tcase <-ctx.Done():\n+\t\t}\n+\t}\n+\n+\tgo func() {\n+\t\tc, err := srv.Accept()\n+\t\tif err != nil {\n+\t\t\tfail(err)\n+\t\t\treturn\n+\t\t}\n+\t\tvs.ServeUnixConn(c.(*net.UnixConn), vnet.ProtocolQEMU)\n+\t}()\n+\n+\tuc, err := net.Dial(\"unix\", unixSrv)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"Dial: %v\", err))\n+\t}\n+\tdefer uc.Close()\n+\n+\tvar frameBuf []byte\n+\twriteDataToUnixConn := func(data []byte) error {\n+\t\tframeBuf = slices.Grow(frameBuf[:0], len(data)+4)[:len(data)+4]\n+\t\tbinary.BigEndian.PutUint32(frameBuf[:4], uint32(len(data)))\n+\t\tcopy(frameBuf[4:], data)\n+\n+\t\t_, err = uc.Write(frameBuf)\n+\t\treturn err\n+\t}\n+\tif err := writeDataToUnixConn(firstData); err != nil {\n+\t\tfail(err)\n+\t\treturn\n+\t}\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tmessageType, data, err := conn.Read(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\tfail(fmt.Errorf(\"ReadMessage: %v\", err))\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif messageType != websocket.MessageBinary {\n+\t\t\t\tlog.Printf(\"Ignoring non-binary message\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif err := writeDataToUnixConn(data); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tgo func() {\n+\t\tconst maxBuf = 4096\n+\t\tframeBuf := make([]byte, maxBuf)\n+\t\tfor {\n+\t\t\t_, err := io.ReadFull(uc, frameBuf[:4])\n+\t\t\tif err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tframeLen := binary.BigEndian.Uint32(frameBuf[:4])\n+\t\t\tif frameLen > maxBuf {\n+\t\t\t\tfail(fmt.Errorf(\"frame too large: %d\", frameLen))\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif _, err := io.ReadFull(uc, frameBuf[:frameLen]); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := conn.Write(ctx, websocket.MessageBinary, frameBuf[:frameLen]); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\t<-ctx.Done()\n+}\n---\ntstest/natlab/vnet/conf.go\n@@ -121,6 +121,8 @@ func (c *Config) AddNode(opts ...any) *Node {\n \t\t\t\t\tn.err = fmt.Errorf(\"unknown NodeOption %q\", o)\n \t\t\t\t}\n \t\t\t}\n+\t\tcase MAC:\n+\t\t\tn.mac = o\n \t\tdefault:\n \t\t\tif n.err == nil {\n \t\t\t\tn.err = fmt.Errorf(\"unknown AddNode option type %T\", o)\n---\ntstest/natlab/vnet/vnet.go\n@@ -88,6 +88,9 @@ func (s *Server) PopulateDERPMapIPs() error {\n \t\t\tif n.IPv4 != \"\" {\n \t\t\t\ts.derpIPs.Add(netip.MustParseAddr(n.IPv4))\n \t\t\t}\n+\t\t\tif n.IPv6 != \"\" {\n+\t\t\t\ts.derpIPs.Add(netip.MustParseAddr(n.IPv6))\n+\t\t\t}\n \t\t}\n \t}\n \treturn nil\n---\n\n\n---\n\nChoice B:\ntsconsensus/tsconsensus_test.go\n@@ -26,6 +26,7 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/raft\"\n \t\"tailscale.com/client/tailscale\"\n+\t\"tailscale.com/cmd/testwrapper/flakytest\"\n \t\"tailscale.com/ipn/store/mem\"\n \t\"tailscale.com/net/netns\"\n \t\"tailscale.com/tailcfg\"\n@@ -574,6 +575,7 @@ func TestRejoin(t *testing.T) {\n }\n \n func TestOnlyTaggedPeersCanDialRaftPort(t *testing.T) {\n+\tflakytest.Mark(t, \"https://github.com/tailscale/tailscale/issues/15627\")\n \ttestConfig(t)\n \tctx := context.Background()\n \tclusterTag := \"tag:whatever\"\n@@ -631,6 +633,7 @@ func TestOnlyTaggedPeersCanDialRaftPort(t *testing.T) {\n }\n \n func TestOnlyTaggedPeersCanBeDialed(t *testing.T) {\n+\tflakytest.Mark(t, \"https://github.com/tailscale/tailscale/issues/15627\")\n \ttestConfig(t)\n \tctx := context.Background()\n \tclusterTag := \"tag:whatever\"\n---\n\n\n---\n\nChoice C:\nhostinfo/hostinfo.go\n@@ -43,7 +43,7 @@ func RegisterHostinfoNewHook(f func(*tailcfg.Hostinfo)) {\n \n // New returns a partially populated Hostinfo for the current host.\n func New() *tailcfg.Hostinfo {\n-\thostname, _ := os.Hostname()\n+\thostname, _ := Hostname()\n \thostname = dnsname.FirstLabel(hostname)\n \thi := &tailcfg.Hostinfo{\n \t\tIPNVersion:      version.Long(),\n@@ -509,3 +509,21 @@ func IsInVM86() bool {\n \t\treturn New().DeviceModel == copyV86DeviceModel\n \t})\n }\n+\n+type hostnameQuery func() (string, error)\n+\n+var hostnameFn atomic.Value // of func() (string, error)\n+\n+// SetHostNameFn sets a custom function for querying the system hostname.\n+func SetHostnameFn(fn hostnameQuery) {\n+\thostnameFn.Store(fn)\n+}\n+\n+// Hostname returns the system hostname using the function\n+// set by SetHostNameFn.  We will fallback to os.Hostname.\n+func Hostname() (string, error) {\n+\tif fn, ok := hostnameFn.Load().(hostnameQuery); ok && fn != nil {\n+\t\treturn fn()\n+\t}\n+\treturn os.Hostname()\n+}\n---\nhostinfo/hostinfo_test.go\n@@ -5,6 +5,7 @@ package hostinfo\n \n import (\n \t\"encoding/json\"\n+\t\"os\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -49,3 +50,31 @@ func TestEtcAptSourceFileIsDisabled(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestCustomHostnameFunc(t *testing.T) {\n+\twant := \"custom-hostname\"\n+\tSetHostnameFn(func() (string, error) {\n+\t\treturn want, nil\n+\t})\n+\n+\tgot, err := Hostname()\n+\tif err != nil {\n+\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+\n+\tif got != want {\n+\t\tt.Errorf(\"got %q, want %q\", got, want)\n+\t}\n+\n+\tSetHostnameFn(os.Hostname)\n+\tgot, err = Hostname()\n+\twant, _ = os.Hostname()\n+\n+\tif err != nil {\n+\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+\tif got != want {\n+\t\tt.Errorf(\"got %q, want %q\", got, want)\n+\t}\n+\n+}\n---\nipn/ipnlocal/local.go\n@@ -1245,7 +1245,7 @@ func (b *LocalBackend) UpdateStatus(sb *ipnstate.StatusBuilder) {\n \t\t\t}\n \n \t\t} else {\n-\t\t\tss.HostName, _ = os.Hostname()\n+\t\t\tss.HostName, _ = hostinfo.Hostname()\n \t\t}\n \t\tfor _, pln := range b.peerAPIListeners {\n \t\t\tss.PeerAPIURL = append(ss.PeerAPIURL, pln.urlStr)\n---\n\n\n---\n\nChoice D:\ncmd/k8s-operator/deploy/crds/tailscale.com_connectors.yaml\n@@ -32,6 +32,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_dnsconfigs.yaml\n@@ -20,6 +20,9 @@ spec:\n           jsonPath: .status.nameserver.ip\n           name: NameserverIP\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -18,6 +18,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxygroups.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .spec.type\n           name: Type\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_recorders.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .status.devices[?(@.url != \"\")].url\n           name: URL\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -61,6 +61,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -312,6 +315,9 @@ spec:\n               jsonPath: .status.nameserver.ip\n               name: NameserverIP\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -492,6 +498,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -2803,6 +2812,9 @@ spec:\n               jsonPath: .spec.type\n               name: Type\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -3013,6 +3025,9 @@ spec:\n               jsonPath: .status.devices[?(@.url != \"\")].url\n               name: URL\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n---\nk8s-operator/apis/v1alpha1/types_connector.go\n@@ -24,6 +24,7 @@ var ConnectorKind = \"Connector\"\n // +kubebuilder:printcolumn:name=\"IsExitNode\",type=\"string\",JSONPath=`.status.isExitNode`,description=\"Whether this Connector instance defines an exit node.\"\n // +kubebuilder:printcolumn:name=\"IsAppConnector\",type=\"string\",JSONPath=`.status.isAppConnector`,description=\"Whether this Connector instance is an app connector.\"\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ConnectorReady\")].reason`,description=\"Status of the deployed Connector resources.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Connector defines a Tailscale node that will be deployed in the cluster. The\n // node can be configured to act as a Tailscale subnet router and/or a Tailscale\n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -16,6 +16,7 @@ var ProxyClassKind = \"ProxyClass\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyClassReady\")].reason`,description=\"Status of the ProxyClass.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyClass describes a set of configuration parameters that can be applied to\n // proxy resources created by the Tailscale Kubernetes operator.\n---\nk8s-operator/apis/v1alpha1/types_proxygroup.go\n@@ -14,6 +14,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=pg\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyGroupReady\")].reason`,description=\"Status of the deployed ProxyGroup resources.\"\n // +kubebuilder:printcolumn:name=\"Type\",type=\"string\",JSONPath=`.spec.type`,description=\"ProxyGroup type.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyGroup defines a set of Tailscale devices that will act as proxies.\n // Currently only egress ProxyGroups are supported.\n---\nk8s-operator/apis/v1alpha1/types_recorder.go\n@@ -15,6 +15,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=rec\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"RecorderReady\")].reason`,description=\"Status of the deployed Recorder resources.\"\n // +kubebuilder:printcolumn:name=\"URL\",type=\"string\",JSONPath=`.status.devices[?(@.url != \"\")].url`,description=\"URL on which the UI is exposed if enabled.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Recorder defines a tsrecorder device for recording SSH sessions. By default,\n // it will store recordings in a local ephemeral volume. If you want to persist\n---\nk8s-operator/apis/v1alpha1/types_tsdnsconfig.go\n@@ -18,6 +18,7 @@ var DNSConfigKind = \"DNSConfig\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster,shortName=dc\n // +kubebuilder:printcolumn:name=\"NameserverIP\",type=\"string\",JSONPath=`.status.nameserver.ip`,description=\"Service IP address of the nameserver\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // DNSConfig can be deployed to cluster to make a subset of Tailscale MagicDNS\n // names resolvable by cluster workloads. Use this if: A) you need to refer to\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/tailscale#13452\r\n\r\nSigned-off-by: kari-ts <kari@tailscale.com>\r\n(cherry picked from commit 6fb5e3b0cb5c4540992b54af1e7ee92542ea6630)\n\n---\n\nChoice A:\ndocs/commit-messages.md\n@@ -1,16 +1,12 @@\n # Commit messages\n \n+There are different styles of commit messages followed by different projects.\n This is Tailscale's style guide for writing git commit messages.\n-\n As with all style guides, many things here are subjective and exist primarily to\n codify existing conventions and promote uniformity and thus ease of reading by\n others. Others have stronger reasons, such as interop with tooling or making\n future git archaeology easier.\n \n-# Commit Messages\n-\n-There are different styles of commit messages followed by different projects.\n-\n Our commit message style is largely based on the Go language's style, which\n shares much in common with the Linux kernel's git commit message style (for\n which git was invented):\n---\n\n\n---\n\nChoice B:\ngo.toolchain.rev\n@@ -1 +1 @@\n-4fdaeeb8fe43bcdb4e8cc736433b9cd9c0ddd221\n+982da8f24fa0504f2214f24b0d68b2febd5983f8\n---\n\n\n---\n\nChoice C:\nlogtail/logtail.go\n@@ -15,9 +15,7 @@ import (\n \t\"log\"\n \tmrand \"math/rand/v2\"\n \t\"net/http\"\n-\t\"net/netip\"\n \t\"os\"\n-\t\"regexp\"\n \t\"runtime\"\n \t\"slices\"\n \t\"strconv\"\n@@ -29,7 +27,6 @@ import (\n \t\"tailscale.com/envknob\"\n \t\"tailscale.com/net/netmon\"\n \t\"tailscale.com/net/sockstats\"\n-\t\"tailscale.com/net/tsaddr\"\n \t\"tailscale.com/tstime\"\n \ttslogger \"tailscale.com/types/logger\"\n \t\"tailscale.com/types/logid\"\n@@ -833,8 +830,6 @@ func (l *Logger) Logf(format string, args ...any) {\n \tfmt.Fprintf(l, format, args...)\n }\n \n-var obscureIPs = envknob.RegisterBool(\"TS_OBSCURE_LOGGED_IPS\")\n-\n // Write logs an encoded JSON blob.\n //\n // If the []byte passed to Write is not an encoded JSON blob,\n@@ -859,10 +854,6 @@ func (l *Logger) Write(buf []byte) (int, error) {\n \t\t}\n \t}\n \n-\tif obscureIPs() {\n-\t\tbuf = redactIPs(buf)\n-\t}\n-\n \tl.writeLock.Lock()\n \tdefer l.writeLock.Unlock()\n \n@@ -871,40 +862,6 @@ func (l *Logger) Write(buf []byte) (int, error) {\n \treturn inLen, err\n }\n \n-var (\n-\tregexMatchesIPv6 = regexp.MustCompile(`([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4}):([0-9a-fA-F:]{1,4})*`)\n-\tregexMatchesIPv4 = regexp.MustCompile(`(\\d{1,3})\\.(\\d{1,3})\\.\\d{1,3}\\.\\d{1,3}`)\n-)\n-\n-// redactIPs is a helper function used in Write() to redact IPs (other than tailscale IPs).\n-// This function takes a log line as a byte slice and\n-// uses regex matching to parse and find IP addresses. Based on if the IP address is IPv4 or\n-// IPv6, it parses and replaces the end of the addresses with an \"x\". This function returns the\n-// log line with the IPs redacted.\n-func redactIPs(buf []byte) []byte {\n-\tout := regexMatchesIPv6.ReplaceAllFunc(buf, func(b []byte) []byte {\n-\t\tip, err := netip.ParseAddr(string(b))\n-\t\tif err != nil || tsaddr.IsTailscaleIP(ip) {\n-\t\t\treturn b // don't change this one\n-\t\t}\n-\n-\t\tprefix := bytes.Split(b, []byte(\":\"))\n-\t\treturn bytes.Join(append(prefix[:2], []byte(\"x\")), []byte(\":\"))\n-\t})\n-\n-\tout = regexMatchesIPv4.ReplaceAllFunc(out, func(b []byte) []byte {\n-\t\tip, err := netip.ParseAddr(string(b))\n-\t\tif err != nil || tsaddr.IsTailscaleIP(ip) {\n-\t\t\treturn b // don't change this one\n-\t\t}\n-\n-\t\tprefix := bytes.Split(b, []byte(\".\"))\n-\t\treturn bytes.Join(append(prefix[:2], []byte(\"x.x\")), []byte(\".\"))\n-\t})\n-\n-\treturn []byte(out)\n-}\n-\n var (\n \topenBracketV = []byte(\"[v\")\n \tv1           = []byte(\"[v1] \")\n---\nlogtail/logtail_test.go\n@@ -15,7 +15,6 @@ import (\n \t\"time\"\n \n \t\"github.com/go-json-experiment/json/jsontext\"\n-\t\"tailscale.com/envknob\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/tstime\"\n \t\"tailscale.com/util/must\"\n@@ -316,85 +315,6 @@ func TestLoggerWriteResult(t *testing.T) {\n \t\tt.Errorf(\"mismatch.\\n got: %#q\\nwant: %#q\", back, want)\n \t}\n }\n-func TestRedact(t *testing.T) {\n-\tenvknob.Setenv(\"TS_OBSCURE_LOGGED_IPS\", \"true\")\n-\ttests := []struct {\n-\t\tin   string\n-\t\twant string\n-\t}{\n-\t\t// tests for ipv4 addresses\n-\t\t{\n-\t\t\t\"120.100.30.47\",\n-\t\t\t\"120.100.x.x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"192.167.0.1/65\",\n-\t\t\t\"192.167.x.x/65\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.0.222:41641 mtu=1360 tx=d81a8a35a0ce\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.x.x:41641 mtu=1360 tx=d81a8a35a0ce\",\n-\t\t},\n-\t\t//tests for ipv6 addresses\n-\t\t{\n-\t\t\t\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"2001:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2345:0425:2CA1:0000:0000:0567:5673:23b5\",\n-\t\t\t\"2345:0425:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2601:645:8200:edf0::c9de/64\",\n-\t\t\t\"2601:645:x/64\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 2051:0000:140F::875B:131C mtu=1360 tx=d81a8a35a0ce\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 2051:0000:x mtu=1360 tx=d81a8a35a0ce\",\n-\t\t},\n-\t\t{\n-\t\t\t\"2601:645:8200:edf0::c9de/64 2601:645:8200:edf0:1ce9:b17d:71f5:f6a3/64\",\n-\t\t\t\"2601:645:x/64 2601:645:x/64\",\n-\t\t},\n-\t\t//tests for tailscale ip addresses\n-\t\t{\n-\t\t\t\"100.64.5.6\",\n-\t\t\t\"100.64.5.6\",\n-\t\t},\n-\t\t{\n-\t\t\t\"fd7a:115c:a1e0::/96\",\n-\t\t\t\"fd7a:115c:a1e0::/96\",\n-\t\t},\n-\t\t//tests for ipv6 and ipv4 together\n-\t\t{\n-\t\t\t\"192.167.0.1 2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"192.167.x.x 2001:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.0.222:41641 mtu=1360 tx=d81a8a35a0ce 2345:0425:2CA1::0567:5673:23b5\",\n-\t\t\t\"node [5Btdd] d:e89a3384f526d251 now using 10.0.x.x:41641 mtu=1360 tx=d81a8a35a0ce 2345:0425:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"100.64.5.6 2091:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"100.64.5.6 2091:0db8:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"192.167.0.1 120.100.30.47 2041:0000:140F::875B:131B\",\n-\t\t\t\"192.167.x.x 120.100.x.x 2041:0000:x\",\n-\t\t},\n-\t\t{\n-\t\t\t\"fd7a:115c:a1e0::/96 192.167.0.1 2001:0db8:85a3:0000:0000:8a2e:0370:7334\",\n-\t\t\t\"fd7a:115c:a1e0::/96 192.167.x.x 2001:0db8:x\",\n-\t\t},\n-\t}\n-\n-\tfor _, tt := range tests {\n-\t\tgotBuf := redactIPs([]byte(tt.in))\n-\t\tif string(gotBuf) != tt.want {\n-\t\t\tt.Errorf(\"for %q,\\n got: %#q\\nwant: %#q\\n\", tt.in, gotBuf, tt.want)\n-\t\t}\n-\t}\n-}\n \n func TestAppendMetadata(t *testing.T) {\n \tvar l Logger\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/netcheck.go\n@@ -55,7 +55,10 @@ func runNetcheck(ctx context.Context, args []string) error {\n \n \t// Ensure that we close the portmapper after running a netcheck; this\n \t// will release any port mappings created.\n-\tpm := portmapper.NewClient(logf, netMon, nil, nil, nil)\n+\tpm := portmapper.NewClient(portmapper.Config{\n+\t\tLogf:   logf,\n+\t\tNetMon: netMon,\n+\t})\n \tdefer pm.Close()\n \n \tc := &netcheck.Client{\n---\nipn/localapi/localapi.go\n@@ -818,19 +818,25 @@ func (h *Handler) serveDebugPortmap(w http.ResponseWriter, r *http.Request) {\n \tdone := make(chan bool, 1)\n \n \tvar c *portmapper.Client\n-\tc = portmapper.NewClient(logger.WithPrefix(logf, \"portmapper: \"), h.b.NetMon(), debugKnobs, h.b.ControlKnobs(), func() {\n-\t\tlogf(\"portmapping changed.\")\n-\t\tlogf(\"have mapping: %v\", c.HaveMapping())\n-\n-\t\tif ext, ok := c.GetCachedMappingOrStartCreatingOne(); ok {\n-\t\t\tlogf(\"cb: mapping: %v\", ext)\n-\t\t\tselect {\n-\t\t\tcase done <- true:\n-\t\t\tdefault:\n+\tc = portmapper.NewClient(portmapper.Config{\n+\t\tLogf:         logger.WithPrefix(logf, \"portmapper: \"),\n+\t\tNetMon:       h.b.NetMon(),\n+\t\tDebugKnobs:   debugKnobs,\n+\t\tControlKnobs: h.b.ControlKnobs(),\n+\t\tOnChange: func() {\n+\t\t\tlogf(\"portmapping changed.\")\n+\t\t\tlogf(\"have mapping: %v\", c.HaveMapping())\n+\n+\t\t\tif ext, ok := c.GetCachedMappingOrStartCreatingOne(); ok {\n+\t\t\t\tlogf(\"cb: mapping: %v\", ext)\n+\t\t\t\tselect {\n+\t\t\t\tcase done <- true:\n+\t\t\t\tdefault:\n+\t\t\t\t}\n+\t\t\t\treturn\n \t\t\t}\n-\t\t\treturn\n-\t\t}\n-\t\tlogf(\"cb: no mapping\")\n+\t\t\tlogf(\"cb: no mapping\")\n+\t\t},\n \t})\n \tdefer c.Close()\n \n---\nnet/portmapper/igd_test.go\n@@ -260,9 +260,14 @@ func (d *TestIGD) handlePCPQuery(pkt []byte, src netip.AddrPort) {\n \n func newTestClient(t *testing.T, igd *TestIGD) *Client {\n \tvar c *Client\n-\tc = NewClient(t.Logf, netmon.NewStatic(), nil, new(controlknobs.Knobs), func() {\n-\t\tt.Logf(\"port map changed\")\n-\t\tt.Logf(\"have mapping: %v\", c.HaveMapping())\n+\tc = NewClient(Config{\n+\t\tLogf:         t.Logf,\n+\t\tNetMon:       netmon.NewStatic(),\n+\t\tControlKnobs: new(controlknobs.Knobs),\n+\t\tOnChange: func() {\n+\t\t\tt.Logf(\"port map changed\")\n+\t\t\tt.Logf(\"have mapping: %v\", c.HaveMapping())\n+\t\t},\n \t})\n \tc.testPxPPort = igd.TestPxPPort()\n \tc.testUPnPPort = igd.TestUPnPPort()\n---\nnet/portmapper/portmapper.go\n@@ -201,32 +201,45 @@ func (m *pmpMapping) Release(ctx context.Context) {\n \tuc.WriteToUDPAddrPort(pkt, m.gw)\n }\n \n-// NewClient returns a new portmapping client.\n-//\n-// The netMon parameter is required.\n-//\n-// The debug argument allows configuring the behaviour of the portmapper for\n-// debugging; if nil, a sensible set of defaults will be used.\n-//\n-// The controlKnobs, if non-nil, specifies the control knobs from the control\n-// plane that might disable portmapping.\n-//\n-// The optional onChange argument specifies a func to run in a new goroutine\n-// whenever the port mapping status has changed. If nil, it doesn't make a\n-// callback.\n-func NewClient(logf logger.Logf, netMon *netmon.Monitor, debug *DebugKnobs, controlKnobs *controlknobs.Knobs, onChange func()) *Client {\n-\tif netMon == nil {\n+// Config carries the settings for a [Client].\n+type Config struct {\n+\t// Logf is called to generate text logs for the client. If nil, logger.Discard is used.\n+\tLogf logger.Logf\n+\n+\t// NetMon is the network monitor used by the client. It must be non-nil.\n+\tNetMon *netmon.Monitor\n+\n+\t// DebugKnobs, if non-nil, configure the behaviour of the portmapper for\n+\t// debugging.  If nil, a sensible set of defaults will be used.\n+\tDebugKnobs *DebugKnobs\n+\n+\t// ControlKnobs, if non-nil, specifies knobs from the control plane that\n+\t// might disable port mapping.\n+\tControlKnobs *controlknobs.Knobs\n+\n+\t// OnChange is called to run in a new goroutine whenever the port mapping\n+\t// status has changed. If nil, no callback is issued.\n+\tOnChange func()\n+}\n+\n+// NewClient constructs a new portmapping [Client] from c. It will panic if any\n+// required parameters are omitted.\n+func NewClient(c Config) *Client {\n+\tif c.NetMon == nil {\n \t\tpanic(\"nil netMon\")\n \t}\n \tret := &Client{\n-\t\tlogf:         logf,\n-\t\tnetMon:       netMon,\n+\t\tlogf:         c.Logf,\n+\t\tnetMon:       c.NetMon,\n \t\tipAndGateway: netmon.LikelyHomeRouterIP, // TODO(bradfitz): move this to method on netMon\n-\t\tonChange:     onChange,\n-\t\tcontrolKnobs: controlKnobs,\n+\t\tonChange:     c.OnChange,\n+\t\tcontrolKnobs: c.ControlKnobs,\n+\t}\n+\tif ret.logf == nil {\n+\t\tret.logf = logger.Discard\n \t}\n-\tif debug != nil {\n-\t\tret.debug = *debug\n+\tif c.DebugKnobs != nil {\n+\t\tret.debug = *c.DebugKnobs\n \t}\n \treturn ret\n }\n---\nnet/portmapper/portmapper_test.go\n@@ -18,7 +18,7 @@ func TestCreateOrGetMapping(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tc.SetLocalPort(1234)\n \tfor i := range 2 {\n@@ -34,7 +34,7 @@ func TestClientProbe(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tfor i := range 3 {\n \t\tif i > 0 {\n@@ -49,7 +49,7 @@ func TestClientProbeThenMap(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tc.debug.VerboseLogs = true\n \tc.SetLocalPort(1234)\n---\nwgengine/magicsock/magicsock.go\n@@ -544,7 +544,13 @@ func NewConn(opts Options) (*Conn, error) {\n \tportMapOpts := &portmapper.DebugKnobs{\n \t\tDisableAll: func() bool { return opts.DisablePortMapper || c.onlyTCP443.Load() },\n \t}\n-\tc.portMapper = portmapper.NewClient(portmapperLogf, opts.NetMon, portMapOpts, opts.ControlKnobs, c.onPortMapChanged)\n+\tc.portMapper = portmapper.NewClient(portmapper.Config{\n+\t\tLogf:         portmapperLogf,\n+\t\tNetMon:       opts.NetMon,\n+\t\tDebugKnobs:   portMapOpts,\n+\t\tControlKnobs: opts.ControlKnobs,\n+\t\tOnChange:     c.onPortMapChanged,\n+\t})\n \tc.portMapper.SetGatewayLookupFunc(opts.NetMon.GatewayAndSelfIP)\n \tc.netMon = opts.NetMon\n \tc.health = opts.HealthTracker\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis reverts commit 476a4c6ff174d46ce3b125c018c07c43713e1c10.\n\nReason: redundant with `tailscale status --json | jq '.Self.Relay'`\nwhich we all forgot about. Whoops.\n\nUpdates #15625\n\n\n---\n\nChoice A:\nutil/mak/mak.go\n@@ -5,11 +5,6 @@\n // things, notably to maps, but also slices.\n package mak\n \n-import (\n-\t\"fmt\"\n-\t\"reflect\"\n-)\n-\n // Set populates an entry in a map, making the map if necessary.\n //\n // That is, it assigns (*m)[k] = v, making *m if it was nil.\n@@ -20,35 +15,6 @@ func Set[K comparable, V any, T ~map[K]V](m *T, k K, v V) {\n \t(*m)[k] = v\n }\n \n-// NonNil takes a pointer to a Go data structure\n-// (currently only a slice or a map) and makes sure it's non-nil for\n-// JSON serialization. (In particular, JavaScript clients usually want\n-// the field to be defined after they decode the JSON.)\n-//\n-// Deprecated: use NonNilSliceForJSON or NonNilMapForJSON instead.\n-func NonNil(ptr any) {\n-\tif ptr == nil {\n-\t\tpanic(\"nil interface\")\n-\t}\n-\trv := reflect.ValueOf(ptr)\n-\tif rv.Kind() != reflect.Ptr {\n-\t\tpanic(fmt.Sprintf(\"kind %v, not Ptr\", rv.Kind()))\n-\t}\n-\tif rv.Pointer() == 0 {\n-\t\tpanic(\"nil pointer\")\n-\t}\n-\trv = rv.Elem()\n-\tif rv.Pointer() != 0 {\n-\t\treturn\n-\t}\n-\tswitch rv.Type().Kind() {\n-\tcase reflect.Slice:\n-\t\trv.Set(reflect.MakeSlice(rv.Type(), 0, 0))\n-\tcase reflect.Map:\n-\t\trv.Set(reflect.MakeMap(rv.Type()))\n-\t}\n-}\n-\n // NonNilSliceForJSON makes sure that *slicePtr is non-nil so it will\n // won't be omitted from JSON serialization and possibly confuse JavaScript\n // clients expecting it to be present.\n---\nutil/mak/mak_test.go\n@@ -40,35 +40,6 @@ func TestSet(t *testing.T) {\n \t})\n }\n \n-func TestNonNil(t *testing.T) {\n-\tvar s []string\n-\tNonNil(&s)\n-\tif len(s) != 0 {\n-\t\tt.Errorf(\"slice len = %d; want 0\", len(s))\n-\t}\n-\tif s == nil {\n-\t\tt.Error(\"slice still nil\")\n-\t}\n-\n-\ts = append(s, \"foo\")\n-\tNonNil(&s)\n-\tif len(s) != 1 {\n-\t\tt.Errorf(\"len = %d; want 1\", len(s))\n-\t}\n-\tif s[0] != \"foo\" {\n-\t\tt.Errorf(\"value = %q; want foo\", s)\n-\t}\n-\n-\tvar m map[string]string\n-\tNonNil(&m)\n-\tif len(m) != 0 {\n-\t\tt.Errorf(\"map len = %d; want 0\", len(s))\n-\t}\n-\tif m == nil {\n-\t\tt.Error(\"map still nil\")\n-\t}\n-}\n-\n func TestNonNilMapForJSON(t *testing.T) {\n \ttype M map[string]int\n \tvar m M\n---\n\n\n---\n\nChoice B:\ntsnet/tsnet.go\n@@ -1101,13 +1101,33 @@ type FunnelOption interface {\n \tfunnelOption()\n }\n \n-type funnelOnly int\n+type funnelOnly struct{}\n \n func (funnelOnly) funnelOption() {}\n \n // FunnelOnly configures the listener to only respond to connections from Tailscale Funnel.\n // The local tailnet will not be able to connect to the listener.\n-func FunnelOnly() FunnelOption { return funnelOnly(1) }\n+func FunnelOnly() FunnelOption { return funnelOnly{} }\n+\n+type funnelTLSConfig struct{ conf *tls.Config }\n+\n+func (f funnelTLSConfig) funnelOption() {}\n+\n+// FunnelTLSConfig configures the TLS configuration for [Server.ListenFunnel]\n+//\n+// This is rarely needed but can permit requiring client certificates, specific\n+// ciphers suites, etc.\n+//\n+// The provided conf should at least be able to get a certificate, setting\n+// GetCertificate, Certificates or GetConfigForClient appropriately.\n+// The most common configuration is to set GetCertificate to\n+// Server.LocalClient's GetCertificate method.\n+//\n+// Unless [FunnelOnly] is also used, the configuration is also used for\n+// in-tailnet connections that don't arrive over Funnel.\n+func FunnelTLSConfig(conf *tls.Config) FunnelOption {\n+\treturn funnelTLSConfig{conf: conf}\n+}\n \n // ListenFunnel announces on the public internet using Tailscale Funnel.\n //\n@@ -1140,6 +1160,26 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t\treturn nil, err\n \t}\n \n+\t// Process, validate opts.\n+\tlnOn := listenOnBoth\n+\tvar tlsConfig *tls.Config\n+\tfor _, opt := range opts {\n+\t\tswitch v := opt.(type) {\n+\t\tcase funnelTLSConfig:\n+\t\t\tif v.conf == nil {\n+\t\t\t\treturn nil, errors.New(\"invalid nil FunnelTLSConfig\")\n+\t\t\t}\n+\t\t\ttlsConfig = v.conf\n+\t\tcase funnelOnly:\n+\t\t\tlnOn = listenOnFunnel\n+\t\tdefault:\n+\t\t\treturn nil, fmt.Errorf(\"unknown opts FunnelOption type %T\", v)\n+\t\t}\n+\t}\n+\tif tlsConfig == nil {\n+\t\ttlsConfig = &tls.Config{GetCertificate: s.getCert}\n+\t}\n+\n \tctx := context.Background()\n \tst, err := s.Up(ctx)\n \tif err != nil {\n@@ -1177,19 +1217,11 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t}\n \n \t// Start a funnel listener.\n-\tlnOn := listenOnBoth\n-\tfor _, opt := range opts {\n-\t\tif _, ok := opt.(funnelOnly); ok {\n-\t\t\tlnOn = listenOnFunnel\n-\t\t}\n-\t}\n \tln, err := s.listen(network, addr, lnOn)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn tls.NewListener(ln, &tls.Config{\n-\t\tGetCertificate: s.getCert,\n-\t}), nil\n+\treturn tls.NewListener(ln, tlsConfig), nil\n }\n \n type listenOn string\n---\n\n\n---\n\nChoice C:\ntool/gocross/gocross.go\n@@ -15,9 +15,9 @@ import (\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"runtime/debug\"\n \n \t\"tailscale.com/atomicfile\"\n-\t\"tailscale.com/version\"\n )\n \n func main() {\n@@ -28,8 +28,19 @@ func main() {\n \t\t// any time.\n \t\tswitch os.Args[1] {\n \t\tcase \"gocross-version\":\n-\t\t\tfmt.Println(version.GetMeta().GitCommit)\n-\t\t\tos.Exit(0)\n+\t\t\tbi, ok := debug.ReadBuildInfo()\n+\t\t\tif !ok {\n+\t\t\t\tfmt.Fprintln(os.Stderr, \"failed getting build info\")\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\tfor _, s := range bi.Settings {\n+\t\t\t\tif s.Key == \"vcs.revision\" {\n+\t\t\t\t\tfmt.Println(s.Value)\n+\t\t\t\t\tos.Exit(0)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfmt.Fprintln(os.Stderr, \"did not find vcs.revision in build info\")\n+\t\t\tos.Exit(1)\n \t\tcase \"is-gocross\":\n \t\t\t// This subcommand exits with an error code when called on a\n \t\t\t// regular go binary, so it can be used to detect when `go` is\n@@ -85,9 +96,9 @@ func main() {\n \t\tpath := filepath.Join(toolchain, \"bin\") + string(os.PathListSeparator) + os.Getenv(\"PATH\")\n \t\tenv.Set(\"PATH\", path)\n \n-\t\tdebug(\"Input: %s\\n\", formatArgv(os.Args))\n-\t\tdebug(\"Command: %s\\n\", formatArgv(newArgv))\n-\t\tdebug(\"Set the following flags/envvars:\\n%s\\n\", env.Diff())\n+\t\tdebugf(\"Input: %s\\n\", formatArgv(os.Args))\n+\t\tdebugf(\"Command: %s\\n\", formatArgv(newArgv))\n+\t\tdebugf(\"Set the following flags/envvars:\\n%s\\n\", env.Diff())\n \n \t\targs = newArgv\n \t\tif err := env.Apply(); err != nil {\n@@ -103,7 +114,7 @@ func main() {\n //go:embed gocross-wrapper.sh\n var wrapperScript []byte\n \n-func debug(format string, args ...any) {\n+func debugf(format string, args ...any) {\n \tdebug := os.Getenv(\"GOCROSS_DEBUG\")\n \tvar (\n \t\tout *os.File\n---\ntool/gocross/gocross_test.go\n@@ -0,0 +1,19 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package main\n+\n+import (\n+\t\"testing\"\n+\n+\t\"tailscale.com/tstest/deptest\"\n+)\n+\n+func TestDeps(t *testing.T) {\n+\tdeptest.DepChecker{\n+\t\tBadDeps: map[string]string{\n+\t\t\t\"tailscale.com/tailcfg\": \"circular dependency via go generate\",\n+\t\t\t\"tailscale.com/version\": \"circular dependency via go generate\",\n+\t\t},\n+\t}.Check(t)\n+}\n---\n\n\n---\n\nChoice D:\nipn/ipnstate/ipnstate.go\n@@ -53,9 +53,6 @@ type Status struct {\n \t// If nil, an exit node is not in use.\n \tExitNodeStatus *ExitNodeStatus `json:\"ExitNodeStatus,omitempty\"`\n \n-\t// DERPHomeRegionID is the current home DERP region ID.\n-\tDERPHomeRegionID int\n-\n \t// Health contains health check problems.\n \t// Empty means everything is good. (or at least that no known\n \t// problems are detected)\n---\nwgengine/magicsock/magicsock.go\n@@ -2892,15 +2892,11 @@ func (c *Conn) UpdateStatus(sb *ipnstate.StatusBuilder) {\n \t\t})\n \t}\n \n-\tsb.MutateStatus(func(s *ipnstate.Status) {\n-\t\ts.DERPHomeRegionID = c.myDerp\n-\t\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n-\t\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n-\t\t\t// to include all the DERP connections we have open\n-\t\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n-\t\t})\n+\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n+\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n+\t\t// to include all the DERP connections we have open\n+\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n \t})\n-\n }\n \n // SetStatistics specifies a per-connection statistics aggregator.\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIf this stops the flakes, we can follow up and try to diagnose why.\r\n\r\nUpdates #15627\n\n---\n\nChoice A:\ncmd/derper/cert_test.go\n@@ -140,6 +140,15 @@ func TestPinnedCertRawIP(t *testing.T) {\n \tvar hs http.Server\n \ths.Handler = mux\n \ths.TLSConfig = cp.TLSConfig()\n+\tgetCert := hs.TLSConfig.GetCertificate\n+\ths.TLSConfig.GetCertificate=func(hi *tls.ClientHelloInfo) (*tls.Certificate, error) {\n+\t\tcert, err := getCert(hi)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tcert.Certificate = append(cert.Certificate, ds.MetaCert())\n+\t\treturn cert, nil\n+\t}\n \tgo hs.ServeTLS(ln, \"\", \"\")\n \n \tlnPort := ln.Addr().(*net.TCPAddr).Port\n---\nnet/tlsdial/tlsdial.go\n@@ -263,7 +263,7 @@ func SetConfigExpectedCertHash(c *tls.Config, wantFullCertSHA256Hex string) {\n \t\tif len(rawCerts) == 0 {\n \t\t\treturn errors.New(\"no certs presented\")\n \t\t}\n-\t\tif len(rawCerts) > 1 {\n+\t\tif len(rawCerts) > 2 {\n \t\t\treturn errors.New(\"unexpected multiple certs presented\")\n \t\t}\n \t\tif fmt.Sprintf(\"%02x\", sha256.Sum256(rawCerts[0])) != wantFullCertSHA256Hex {\n---\n\n\n---\n\nChoice B:\nipn/localapi/localapi.go\n@@ -397,6 +397,15 @@ func (h *Handler) serveBugReport(w http.ResponseWriter, r *http.Request) {\n \t// OS-specific details\n \th.logf.JSON(1, \"UserBugReportOS\", osdiag.SupportInfo(osdiag.LogSupportInfoReasonBugReport))\n \n+\t// Tailnet lock details\n+\tst := h.b.NetworkLockStatus()\n+\tif st.Enabled {\n+\t\th.logf.JSON(1, \"UserBugReportTailnetLockStatus\", st)\n+\t\tif st.NodeKeySignature != nil {\n+\t\t\th.logf(\"user bugreport tailnet lock signature: %s\", st.NodeKeySignature.String())\n+\t\t}\n+\t}\n+\n \tif defBool(r.URL.Query().Get(\"diagnose\"), false) {\n \t\th.b.Doctor(r.Context(), logger.WithPrefix(h.logf, \"diag: \"))\n \t}\n---\n\n\n---\n\nChoice C:\ntsconsensus/tsconsensus_test.go\n@@ -26,6 +26,7 @@ import (\n \t\"github.com/hashicorp/go-hclog\"\n \t\"github.com/hashicorp/raft\"\n \t\"tailscale.com/client/tailscale\"\n+\t\"tailscale.com/cmd/testwrapper/flakytest\"\n \t\"tailscale.com/ipn/store/mem\"\n \t\"tailscale.com/net/netns\"\n \t\"tailscale.com/tailcfg\"\n@@ -574,6 +575,7 @@ func TestRejoin(t *testing.T) {\n }\n \n func TestOnlyTaggedPeersCanDialRaftPort(t *testing.T) {\n+\tflakytest.Mark(t, \"https://github.com/tailscale/tailscale/issues/15627\")\n \ttestConfig(t)\n \tctx := context.Background()\n \tclusterTag := \"tag:whatever\"\n@@ -631,6 +633,7 @@ func TestOnlyTaggedPeersCanDialRaftPort(t *testing.T) {\n }\n \n func TestOnlyTaggedPeersCanBeDialed(t *testing.T) {\n+\tflakytest.Mark(t, \"https://github.com/tailscale/tailscale/issues/15627\")\n \ttestConfig(t)\n \tctx := context.Background()\n \tclusterTag := \"tag:whatever\"\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/file.go\n@@ -15,8 +15,10 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"os\"\n+\t\"os/user\"\n \t\"path\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"sync/atomic\"\n \t\"time\"\n@@ -452,6 +454,7 @@ var fileGetCmd = &ffcli.Command{\n \toverwrite:  overwrite existing file\n \trename:     write to a new number-suffixed filename`)\n \t\tffcomplete.Flag(fs, \"conflict\", ffcomplete.Fixed(\"skip\", \"overwrite\", \"rename\"))\n+\t\tfs.StringVar(&getArgs.chown, \"chown\", \"\", \"sets owner:group for received files\")\n \t\treturn fs\n \t})(),\n }\n@@ -461,6 +464,7 @@ var getArgs = struct {\n \tloop     bool\n \tverbose  bool\n \tconflict onConflict\n+\tchown    string\n }{conflict: skipOnExist}\n \n func numberedFileName(dir, name string, i int) string {\n@@ -512,7 +516,7 @@ func openFileOrSubstitute(dir, base string, action onConflict) (*os.File, error)\n \t}\n }\n \n-func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targetFile string, size int64, err error) {\n+func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string, chown string) (targetFile string, size int64, err error) {\n \trc, size, err := localClient.GetWaitingFile(ctx, wf.Name)\n \tif err != nil {\n \t\treturn \"\", 0, fmt.Errorf(\"opening inbox file %q: %w\", wf.Name, err)\n@@ -531,10 +535,51 @@ func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targe\n \t\tf.Close()\n \t\treturn \"\", 0, fmt.Errorf(\"failed to write %v: %v\", f.Name(), err)\n \t}\n+\tif chown != \"\" {\n+\t\tusr, grp, _ := strings.Cut(chown, \":\")\n+\n+\t\t// Set default values to allow for partial changes (e.g. `user` or `:staff`)\n+\t\tuid, gid, err := fileStat(f)\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to stat file: %v\", err)\n+\t\t}\n+\n+\t\tif usr != \"\" {\n+\t\t\tif uid, err = strconv.Atoi(usr); err != nil {\n+\t\t\t\tuser, err := user.Lookup(usr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup user: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif uid, err = strconv.Atoi(user.Uid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert uid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif grp != \"\" {\n+\t\t\tif gid, err = strconv.Atoi(grp); err != nil {\n+\t\t\t\tgroup, err := user.LookupGroup(grp)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup group: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif gid, err = strconv.Atoi(group.Gid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert gid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif err := f.Chown(uid, gid); err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to chown file: %v\", err)\n+\t\t}\n+\t}\n \treturn f.Name(), size, f.Close()\n }\n \n-func runFileGetOneBatch(ctx context.Context, dir string) []error {\n+func runFileGetOneBatch(ctx context.Context, dir, chown string) []error {\n \tvar wfs []apitype.WaitingFile\n \tvar err error\n \tvar errs []error\n@@ -563,7 +608,7 @@ func runFileGetOneBatch(ctx context.Context, dir string) []error {\n \t\t\terrs = append(errs, fmt.Errorf(\"too many errors in runFileGetOneBatch(). %d files unexamined\", len(wfs)-i))\n \t\t\tbreak\n \t\t}\n-\t\twrittenFile, size, err := receiveFile(ctx, wf, dir)\n+\t\twrittenFile, size, err := receiveFile(ctx, wf, dir, chown)\n \t\tif err != nil {\n \t\t\terrs = append(errs, err)\n \t\t\tcontinue\n@@ -602,7 +647,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t}\n \tif getArgs.loop {\n \t\tfor {\n-\t\t\terrs := runFileGetOneBatch(ctx, dir)\n+\t\t\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \t\t\tfor _, err := range errs {\n \t\t\t\toutln(err)\n \t\t\t}\n@@ -621,7 +666,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t\t\t}\n \t\t}\n \t}\n-\terrs := runFileGetOneBatch(ctx, dir)\n+\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \tif len(errs) == 0 {\n \t\treturn nil\n \t}\n@@ -635,6 +680,9 @@ func wipeInbox(ctx context.Context) error {\n \tif getArgs.wait {\n \t\treturn errors.New(\"can't use --wait with /dev/null target\")\n \t}\n+\tif getArgs.chown != \"\" {\n+\t\treturn errors.New(\"can't use --chown with /dev/null target\")\n+\t}\n \twfs, err := localClient.WaitingFiles(ctx)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting WaitingFiles: %w\", err)\n---\ncmd/tailscale/cli/file_stub.go\n@@ -0,0 +1,16 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build windows || wasm || plan9 || tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(_f *os.File) (int, int, error) {\n+\treturn -1, -1, errors.New(\"Not implemented\")\n+}\n---\ncmd/tailscale/cli/file_unix.go\n@@ -0,0 +1,26 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build !windows && !wasm && !plan9 && !tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(f *os.File) (int, int, error) {\n+\tif f == nil {\n+\t\treturn -1, -1, errors.New(\"file cannot be nil\")\n+\t}\n+\n+\tvar stat syscall.Stat_t\n+\tif err := syscall.Stat(f.Name(), &stat); err != nil {\n+\t\treturn -1, -1, err\n+\t}\n+\n+\treturn int(stat.Uid), int(stat.Gid), nil\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes #15625\n\n---\n\nChoice A:\ncmd/k8s-operator/ingress.go\n@@ -292,9 +292,15 @@ func validateIngressClass(ctx context.Context, cl client.Client) error {\n \n func handlersForIngress(ctx context.Context, ing *networkingv1.Ingress, cl client.Client, rec record.EventRecorder, tlsHost string, logger *zap.SugaredLogger) (handlers map[string]*ipn.HTTPHandler, err error) {\n \taddIngressBackend := func(b *networkingv1.IngressBackend, path string) {\n+\t\tif path == \"\" {\n+\t\t\tpath = \"/\"\n+\t\t\trec.Eventf(ing, corev1.EventTypeNormal, \"PathUndefined\", \"configured backend is missing a path, defaulting to '/'\")\n+\t\t}\n+\n \t\tif b == nil {\n \t\t\treturn\n \t\t}\n+\n \t\tif b.Service == nil {\n \t\t\trec.Eventf(ing, corev1.EventTypeWarning, \"InvalidIngressBackend\", \"backend for path %q is missing service\", path)\n \t\t\treturn\n---\ncmd/k8s-operator/ingress_test.go\n@@ -16,6 +16,7 @@ import (\n \tapiextensionsv1 \"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1\"\n \tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \t\"k8s.io/apimachinery/pkg/types\"\n+\t\"k8s.io/client-go/tools/record\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n \t\"tailscale.com/ipn\"\n@@ -487,6 +488,138 @@ func TestIngressLetsEncryptStaging(t *testing.T) {\n \t}\n }\n \n+func TestEmptyPath(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname           string\n+\t\tpaths          []networkingv1.HTTPIngressPath\n+\t\texpectedEvents []string\n+\t}{\n+\t\t{\n+\t\t\tname: \"empty_path_with_prefix_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypePrefix),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty_path_with_implementation_specific_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty_path_with_exact_type\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeExact),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Warning UnsupportedPathTypeExact Exact path type strict matching is currently not supported and requests will be routed as for Prefix path type. This behaviour might change in the future.\",\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"two_competing_but_not_identical_paths_including_one_empty\",\n+\t\t\tpaths: []networkingv1.HTTPIngressPath{\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tPathType: ptrPathType(networkingv1.PathTypeImplementationSpecific),\n+\t\t\t\t\tPath:     \"/\",\n+\t\t\t\t\tBackend:  *backend(),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedEvents: []string{\n+\t\t\t\t\"Normal PathUndefined configured backend is missing a path, defaulting to '/'\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range testCases {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfc := fake.NewFakeClient(ingressClass())\n+\t\t\tft := &fakeTSClient{}\n+\t\t\tfr := record.NewFakeRecorder(3) // bump this if you expect a test case to throw more events\n+\t\t\tfakeTsnetServer := &fakeTSNetServer{certDomains: []string{\"foo.com\"}}\n+\t\t\tzl, err := zap.NewDevelopment()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tingR := &IngressReconciler{\n+\t\t\t\trecorder: fr,\n+\t\t\t\tClient:   fc,\n+\t\t\t\tssr: &tailscaleSTSReconciler{\n+\t\t\t\t\tClient:            fc,\n+\t\t\t\t\ttsClient:          ft,\n+\t\t\t\t\ttsnetServer:       fakeTsnetServer,\n+\t\t\t\t\tdefaultTags:       []string{\"tag:k8s\"},\n+\t\t\t\t\toperatorNamespace: \"operator-ns\",\n+\t\t\t\t\tproxyImage:        \"tailscale/tailscale\",\n+\t\t\t\t},\n+\t\t\t\tlogger: zl.Sugar(),\n+\t\t\t}\n+\n+\t\t\t// 1. Resources get created for regular Ingress\n+\t\t\tmustCreate(t, fc, ingressWithPaths(tt.paths))\n+\t\t\tmustCreate(t, fc, service())\n+\n+\t\t\texpectReconciled(t, ingR, \"default\", \"test\")\n+\n+\t\t\tfullName, shortName := findGenName(t, fc, \"default\", \"test\", \"ingress\")\n+\t\t\tmustCreate(t, fc, &corev1.Pod{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tName:      fullName,\n+\t\t\t\t\tNamespace: \"operator-ns\",\n+\t\t\t\t\tUID:       \"test-uid\",\n+\t\t\t\t},\n+\t\t\t})\n+\t\t\topts := configOpts{\n+\t\t\t\tstsName:    shortName,\n+\t\t\t\tsecretName: fullName,\n+\t\t\t\tnamespace:  \"default\",\n+\t\t\t\tparentType: \"ingress\",\n+\t\t\t\thostname:   \"foo\",\n+\t\t\t\tapp:        kubetypes.AppIngressResource,\n+\t\t\t}\n+\t\t\tserveConfig := &ipn.ServeConfig{\n+\t\t\t\tTCP: map[uint16]*ipn.TCPPortHandler{443: {HTTPS: true}},\n+\t\t\t\tWeb: map[ipn.HostPort]*ipn.WebServerConfig{\"${TS_CERT_DOMAIN}:443\": {Handlers: map[string]*ipn.HTTPHandler{\"/\": {Proxy: \"http://1.2.3.4:8080/\"}}}},\n+\t\t\t}\n+\t\t\topts.serveConfig = serveConfig\n+\n+\t\t\texpectEqual(t, fc, expectedSecret(t, fc, opts))\n+\t\t\texpectEqual(t, fc, expectedHeadlessService(shortName, \"ingress\"))\n+\t\t\texpectEqual(t, fc, expectedSTSUserspace(t, fc, opts), removeHashAnnotation, removeResourceReqs)\n+\n+\t\t\texpectEvents(t, fr, tt.expectedEvents)\n+\t\t})\n+\t}\n+}\n+\n+// ptrPathType is a helper function to return a pointer to the pathtype string (required for TestEmptyPath)\n+func ptrPathType(p networkingv1.PathType) *networkingv1.PathType {\n+\treturn &p\n+}\n+\n func ingressClass() *networkingv1.IngressClass {\n \treturn &networkingv1.IngressClass{\n \t\tObjectMeta: metav1.ObjectMeta{Name: \"tailscale\"},\n@@ -520,16 +653,47 @@ func ingress() *networkingv1.Ingress {\n \t\t},\n \t\tSpec: networkingv1.IngressSpec{\n \t\t\tIngressClassName: ptr.To(\"tailscale\"),\n-\t\t\tDefaultBackend: &networkingv1.IngressBackend{\n-\t\t\t\tService: &networkingv1.IngressServiceBackend{\n-\t\t\t\t\tName: \"test\",\n-\t\t\t\t\tPort: networkingv1.ServiceBackendPort{\n-\t\t\t\t\t\tNumber: 8080,\n+\t\t\tDefaultBackend:   backend(),\n+\t\t\tTLS: []networkingv1.IngressTLS{\n+\t\t\t\t{Hosts: []string{\"default-test\"}},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func ingressWithPaths(paths []networkingv1.HTTPIngressPath) *networkingv1.Ingress {\n+\treturn &networkingv1.Ingress{\n+\t\tTypeMeta: metav1.TypeMeta{Kind: \"Ingress\", APIVersion: \"networking.k8s.io/v1\"},\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      \"test\",\n+\t\t\tNamespace: \"default\",\n+\t\t\tUID:       types.UID(\"1234-UID\"),\n+\t\t},\n+\t\tSpec: networkingv1.IngressSpec{\n+\t\t\tIngressClassName: ptr.To(\"tailscale\"),\n+\t\t\tRules: []networkingv1.IngressRule{\n+\t\t\t\t{\n+\t\t\t\t\tHost: \"foo.tailnetxyz.ts.net\",\n+\t\t\t\t\tIngressRuleValue: networkingv1.IngressRuleValue{\n+\t\t\t\t\t\tHTTP: &networkingv1.HTTPIngressRuleValue{\n+\t\t\t\t\t\t\tPaths: paths,\n+\t\t\t\t\t\t},\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n \t\t\tTLS: []networkingv1.IngressTLS{\n-\t\t\t\t{Hosts: []string{\"default-test\"}},\n+\t\t\t\t{Hosts: []string{\"foo.tailnetxyz.ts.net\"}},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func backend() *networkingv1.IngressBackend {\n+\treturn &networkingv1.IngressBackend{\n+\t\tService: &networkingv1.IngressServiceBackend{\n+\t\t\tName: \"test\",\n+\t\t\tPort: networkingv1.ServiceBackendPort{\n+\t\t\t\tNumber: 8080,\n \t\t\t},\n \t\t},\n \t}\n---\n\n\n---\n\nChoice B:\nnet/dns/config.go\n@@ -10,6 +10,8 @@ import (\n \t\"net/netip\"\n \t\"sort\"\n \n+\t\"tailscale.com/control/controlknobs\"\n+\t\"tailscale.com/envknob\"\n \t\"tailscale.com/net/dns/publicdns\"\n \t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/tsaddr\"\n@@ -47,11 +49,28 @@ type Config struct {\n \tOnlyIPv6 bool\n }\n \n-func (c *Config) serviceIP() netip.Addr {\n+var magicDNSDualStack = envknob.RegisterBool(\"TS_DEBUG_MAGIC_DNS_DUAL_STACK\")\n+\n+// serviceIPs returns the list of service IPs where MagicDNS is reachable.\n+//\n+// The provided knobs may be nil.\n+func (c *Config) serviceIPs(knobs *controlknobs.Knobs) []netip.Addr {\n \tif c.OnlyIPv6 {\n-\t\treturn tsaddr.TailscaleServiceIPv6()\n+\t\treturn []netip.Addr{tsaddr.TailscaleServiceIPv6()}\n \t}\n-\treturn tsaddr.TailscaleServiceIP()\n+\n+\t// TODO(bradfitz,mikeodr,raggi): include IPv6 here too; tailscale/tailscale#15404\n+\t// And add a controlknobs knob to disable dual stack.\n+\t//\n+\t// For now, opt-in for testing.\n+\tif magicDNSDualStack() {\n+\t\treturn []netip.Addr{\n+\t\t\ttsaddr.TailscaleServiceIP(),\n+\t\t\ttsaddr.TailscaleServiceIPv6(),\n+\t\t}\n+\t}\n+\n+\treturn []netip.Addr{tsaddr.TailscaleServiceIP()}\n }\n \n // WriteToBufioWriter write a debug version of c for logs to w, omitting\n---\nnet/dns/manager.go\n@@ -307,7 +307,7 @@ func (m *Manager) compileConfig(cfg Config) (rcfg resolver.Config, ocfg OSConfig\n \t\t// through quad-100.\n \t\trcfg.Routes = routes\n \t\trcfg.Routes[\".\"] = cfg.DefaultResolvers\n-\t\tocfg.Nameservers = []netip.Addr{cfg.serviceIP()}\n+\t\tocfg.Nameservers = cfg.serviceIPs(m.knobs)\n \t\treturn rcfg, ocfg, nil\n \t}\n \n@@ -345,7 +345,7 @@ func (m *Manager) compileConfig(cfg Config) (rcfg resolver.Config, ocfg OSConfig\n \t// or routes + MagicDNS, or just MagicDNS, or on an OS that cannot\n \t// split-DNS. Install a split config pointing at quad-100.\n \trcfg.Routes = routes\n-\tocfg.Nameservers = []netip.Addr{cfg.serviceIP()}\n+\tocfg.Nameservers = cfg.serviceIPs(m.knobs)\n \n \tvar baseCfg *OSConfig // base config; non-nil if/when known\n \n---\n\n\n---\n\nChoice C:\ngo.mod\n@@ -77,7 +77,7 @@ require (\n \tgithub.com/tailscale/certstore v0.1.1-0.20231202035212-d3fa0460f47e\n \tgithub.com/tailscale/depaware v0.0.0-20250112153213-b748de04d81b\n \tgithub.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41\n-\tgithub.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca\n+\tgithub.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869\n \tgithub.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05\n \tgithub.com/tailscale/hujson v0.0.0-20221223112325-20486734a56a\n \tgithub.com/tailscale/mkctr v0.0.0-20250228050937-c75ea1476830\n---\ngo.sum\n@@ -910,8 +910,8 @@ github.com/tailscale/go-winio v0.0.0-20231025203758-c4f33415bf55 h1:Gzfnfk2TWrk8\n github.com/tailscale/go-winio v0.0.0-20231025203758-c4f33415bf55/go.mod h1:4k4QO+dQ3R5FofL+SanAUZe+/QfeK0+OIuwDIRu2vSg=\n github.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41 h1:/V2rCMMWcsjYaYO2MeovLw+ClP63OtXgCF2Y1eb8+Ns=\n github.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41/go.mod h1:/roCdA6gg6lQyw/Oz6gIIGu3ggJKYhF+WC/AQReE5XQ=\n-github.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca h1:ecjHwH73Yvqf/oIdQ2vxAX+zc6caQsYdPzsxNW1J3G8=\n-github.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca/go.mod h1:ikbF+YT089eInTp9f2vmvy4+ZVnW5hzX1q2WknxSprQ=\n+github.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869 h1:SRL6irQkKGQKKLzvQP/ke/2ZuB7Py5+XuqtOgSj+iMM=\n+github.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869/go.mod h1:ikbF+YT089eInTp9f2vmvy4+ZVnW5hzX1q2WknxSprQ=\n github.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05 h1:4chzWmimtJPxRs2O36yuGRW3f9SYV+bMTTvMBI0EKio=\n github.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05/go.mod h1:PdCqy9JzfWMJf1H5UJW2ip33/d4YkoKN0r67yKH1mG8=\n github.com/tailscale/hujson v0.0.0-20221223112325-20486734a56a h1:SJy1Pu0eH1C29XwJucQo73FrleVK6t4kYz4NVhp34Yw=\n---\ntempfork/acme/acme.go\n@@ -270,10 +270,7 @@ func (c *Client) FetchRenewalInfo(ctx context.Context, leaf []byte) (*RenewalInf\n \t\treturn nil, fmt.Errorf(\"parsing leaf certificate: %w\", err)\n \t}\n \n-\trenewalURL, err := c.getRenewalURL(parsedLeaf)\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"generating renewal info URL: %w\", err)\n-\t}\n+\trenewalURL := c.getRenewalURL(parsedLeaf)\n \n \tres, err := c.get(ctx, renewalURL, wantStatus(http.StatusOK))\n \tif err != nil {\n@@ -288,16 +285,20 @@ func (c *Client) FetchRenewalInfo(ctx context.Context, leaf []byte) (*RenewalInf\n \treturn &info, nil\n }\n \n-func (c *Client) getRenewalURL(cert *x509.Certificate) (string, error) {\n+func (c *Client) getRenewalURL(cert *x509.Certificate) string {\n \t// See https://www.ietf.org/archive/id/draft-ietf-acme-ari-04.html#name-the-renewalinfo-resource\n \t// for how the request URL is built.\n \turl := c.dir.RenewalInfoURL\n \tif !strings.HasSuffix(url, \"/\") {\n \t\turl += \"/\"\n \t}\n+\treturn url + certRenewalIdentifier(cert)\n+}\n+\n+func certRenewalIdentifier(cert *x509.Certificate) string {\n \taki := base64.RawURLEncoding.EncodeToString(cert.AuthorityKeyId)\n \tserial := base64.RawURLEncoding.EncodeToString(cert.SerialNumber.Bytes())\n-\treturn fmt.Sprintf(\"%s%s.%s\", url, aki, serial), nil\n+\treturn aki + \".\" + serial\n }\n \n // AcceptTOS always returns true to indicate the acceptance of a CA's Terms of Service\n---\ntempfork/acme/acme_test.go\n@@ -549,10 +549,7 @@ func TestGetRenewalURL(t *testing.T) {\n \t}\n \n \tclient := newTestClientWithMockDirectory()\n-\turlString, err := client.getRenewalURL(parsedLeaf)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\turlString := client.getRenewalURL(parsedLeaf)\n \n \tparsedURL, err := url.Parse(urlString)\n \tif err != nil {\n---\ntempfork/acme/rfc8555.go\n@@ -7,6 +7,7 @@ package acme\n import (\n \t\"context\"\n \t\"crypto\"\n+\t\"crypto/x509\"\n \t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"encoding/pem\"\n@@ -205,6 +206,7 @@ func (c *Client) AuthorizeOrder(ctx context.Context, id []AuthzID, opt ...OrderO\n \t\tIdentifiers []wireAuthzID `json:\"identifiers\"`\n \t\tNotBefore   string        `json:\"notBefore,omitempty\"`\n \t\tNotAfter    string        `json:\"notAfter,omitempty\"`\n+\t\tReplaces    string        `json:\"replaces,omitempty\"`\n \t}{}\n \tfor _, v := range id {\n \t\treq.Identifiers = append(req.Identifiers, wireAuthzID{\n@@ -218,6 +220,14 @@ func (c *Client) AuthorizeOrder(ctx context.Context, id []AuthzID, opt ...OrderO\n \t\t\treq.NotBefore = time.Time(o).Format(time.RFC3339)\n \t\tcase orderNotAfterOpt:\n \t\t\treq.NotAfter = time.Time(o).Format(time.RFC3339)\n+\t\tcase orderReplacesCert:\n+\t\t\treq.Replaces = certRenewalIdentifier(o.cert)\n+\t\tcase orderReplacesCertDER:\n+\t\t\tcert, err := x509.ParseCertificate(o)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"failed to parse certificate being replaced: %w\", err)\n+\t\t\t}\n+\t\t\treq.Replaces = certRenewalIdentifier(cert)\n \t\tdefault:\n \t\t\t// Package's fault if we let this happen.\n \t\t\tpanic(fmt.Sprintf(\"unsupported order option type %T\", o))\n---\ntempfork/acme/rfc8555_test.go\n@@ -766,10 +766,17 @@ func TestRFC_AuthorizeOrder(t *testing.T) {\n \ts.start()\n \tdefer s.close()\n \n+\tprevCertDER, _ := pem.Decode([]byte(leafPEM))\n+\tprevCert, err := x509.ParseCertificate(prevCertDER.Bytes)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n \tcl := &Client{Key: testKeyEC, DirectoryURL: s.url(\"/\")}\n \to, err := cl.AuthorizeOrder(context.Background(), DomainIDs(\"example.org\"),\n \t\tWithOrderNotBefore(time.Date(2019, 8, 31, 0, 0, 0, 0, time.UTC)),\n \t\tWithOrderNotAfter(time.Date(2019, 9, 2, 0, 0, 0, 0, time.UTC)),\n+\t\tWithOrderReplacesCert(prevCert),\n \t)\n \tif err != nil {\n \t\tt.Fatal(err)\n---\ntempfork/acme/types.go\n@@ -391,6 +391,30 @@ type orderNotAfterOpt time.Time\n \n func (orderNotAfterOpt) privateOrderOpt() {}\n \n+// WithOrderReplacesCert indicates that this Order is for a replacement of an\n+// existing certificate.\n+// See https://datatracker.ietf.org/doc/html/draft-ietf-acme-ari-03#section-5\n+func WithOrderReplacesCert(cert *x509.Certificate) OrderOption {\n+\treturn orderReplacesCert{cert}\n+}\n+\n+type orderReplacesCert struct {\n+\tcert *x509.Certificate\n+}\n+\n+func (orderReplacesCert) privateOrderOpt() {}\n+\n+// WithOrderReplacesCertDER indicates that this Order is for a replacement of\n+// an existing DER-encoded certificate.\n+// See https://datatracker.ietf.org/doc/html/draft-ietf-acme-ari-03#section-5\n+func WithOrderReplacesCertDER(der []byte) OrderOption {\n+\treturn orderReplacesCertDER(der)\n+}\n+\n+type orderReplacesCertDER []byte\n+\n+func (orderReplacesCertDER) privateOrderOpt() {}\n+\n // Authorization encodes an authorization response.\n type Authorization struct {\n \t// URI uniquely identifies a authorization.\n---\n\n\n---\n\nChoice D:\nipn/ipnstate/ipnstate.go\n@@ -53,6 +53,9 @@ type Status struct {\n \t// If nil, an exit node is not in use.\n \tExitNodeStatus *ExitNodeStatus `json:\"ExitNodeStatus,omitempty\"`\n \n+\t// DERPHomeRegionID is the current home DERP region ID.\n+\tDERPHomeRegionID int\n+\n \t// Health contains health check problems.\n \t// Empty means everything is good. (or at least that no known\n \t// problems are detected)\n---\nwgengine/magicsock/magicsock.go\n@@ -2892,11 +2892,15 @@ func (c *Conn) UpdateStatus(sb *ipnstate.StatusBuilder) {\n \t\t})\n \t}\n \n-\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n-\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n-\t\t// to include all the DERP connections we have open\n-\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n+\tsb.MutateStatus(func(s *ipnstate.Status) {\n+\t\ts.DERPHomeRegionID = c.myDerp\n+\t\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n+\t\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n+\t\t\t// to include all the DERP connections we have open\n+\t\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n+\t\t})\n \t})\n+\n }\n \n // SetStatistics specifies a per-connection statistics aggregator.\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nI don't know why `TestDNSOverTCPIntervalResolver` started failing on the latest 22.04 image, but this makes it pass again. Even if we'd like to understand that failure better, we might want to merge this as a workaround?\r\n\r\nUpdates #15607\n\n---\n\nChoice A:\n.github/workflows/test.yml\n@@ -39,7 +39,7 @@ concurrency:\n \n jobs:\n   race-root-integration:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     strategy:\n       fail-fast: false # don't abort the entire matrix if one element fails\n       matrix:\n@@ -74,7 +74,7 @@ jobs:\n             buildflags: \"-race\"\n             shard: '3/3'\n           - goarch: \"386\" # thanks yaml\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -187,7 +187,7 @@ jobs:\n         find $(go env GOMODCACHE)/cache -type f -mmin +90 -delete\n \n   privileged:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     container:\n       image: golang:latest\n       options: --privileged\n@@ -214,7 +214,7 @@ jobs:\n         XDG_CACHE_HOME: \"/var/lib/ghrunner/cache\"\n \n   race-build:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -258,7 +258,7 @@ jobs:\n           - goos: openbsd\n             goarch: amd64\n \n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -300,7 +300,7 @@ jobs:\n \n   ios: # similar to cross above, but iOS can't build most of the repo. So, just\n        #make it build a few smoke packages.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -328,7 +328,7 @@ jobs:\n           - goos: illumos\n             goarch: amd64\n \n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -366,7 +366,7 @@ jobs:\n     # similar to cross above, but android fails to build a few pieces of the\n     # repo. We should fix those pieces, they're small, but as a stepping stone,\n     # only test the subset of android that our past smoke test checked.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -381,7 +381,7 @@ jobs:\n         GOARCH: arm64\n \n   wasm: # builds tsconnect, which is the only wasm build we support\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -420,7 +420,7 @@ jobs:\n         find $(go env GOMODCACHE)/cache -type f -mmin +90 -delete\n \n   tailscale_go: # Subset of tests that depend on our custom Go toolchain.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -440,7 +440,7 @@ jobs:\n     # explicit 'if' condition, because the default condition for steps is\n     # 'success()', meaning \"only run this if no previous steps failed\".\n     if: github.event_name == 'pull_request'\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: build fuzzers\n       id: build\n@@ -492,7 +492,7 @@ jobs:\n         path: ${{ env.artifacts_path }}/out/artifacts\n \n   depaware:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -502,7 +502,7 @@ jobs:\n         find . -name 'depaware.txt' | xargs -n1 dirname | xargs ./tool/go run github.com/tailscale/depaware --check --internal\n \n   go_generate:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -515,7 +515,7 @@ jobs:\n         git diff --name-only --exit-code || (echo \"The files above need updating. Please run 'go generate'.\"; exit 1)\n \n   go_mod_tidy:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -527,15 +527,15 @@ jobs:\n         git diff --name-only --exit-code || (echo \"Please run 'go mod tidy'.\"; exit 1)\n \n   licenses:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: check licenses\n       run: ./scripts/check_license_headers.sh .\n \n   staticcheck:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     strategy:\n       fail-fast: false # don't abort the entire matrix if one element fails\n       matrix:\n@@ -576,7 +576,7 @@ jobs:\n       - go_mod_tidy\n       - licenses\n       - staticcheck\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: notify  \n       # Only notify slack for merged commits, not PR failures.\n@@ -605,7 +605,7 @@ jobs:\n \n   check_mergeability:\n     if: always()\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     needs:\n       - android\n       - test\n---\n\n\n---\n\nChoice B:\n.github/workflows/test.yml\n@@ -305,7 +305,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: build some\n-      run: ./tool/go build ./ipn/... ./wgengine/ ./types/... ./control/controlclient\n+      run: ./tool/go build ./ipn/... ./ssh/tailssh ./wgengine/ ./types/... ./control/controlclient\n       env:\n         GOOS: ios\n         GOARCH: arm64\n@@ -375,7 +375,7 @@ jobs:\n       # some Android breakages early.\n       # TODO(bradfitz): better; see https://github.com/tailscale/tailscale/issues/4482\n     - name: build some\n-      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version\n+      run: ./tool/go install ./net/netns ./ipn/ipnlocal ./wgengine/magicsock/ ./wgengine/ ./wgengine/router/ ./wgengine/netstack ./util/dnsname/ ./ipn/ ./net/netmon ./wgengine/router/ ./tailcfg/ ./types/logger/ ./net/dns ./hostinfo ./version ./ssh/tailssh\n       env:\n         GOOS: android\n         GOARCH: arm64\n---\nssh/tailssh/incubator.go\n@@ -7,7 +7,7 @@\n // and groups to the specified `--uid`, `--gid` and `--groups`, and\n // then launches the requested `--cmd`.\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd\n \n package tailssh\n \n---\nssh/tailssh/incubator_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package tailssh\n \n---\nssh/tailssh/tailssh.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n // Package tailssh is an SSH server integrated into Tailscale.\n package tailssh\n---\nssh/tailssh/user.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || (darwin && !ios) || freebsd || openbsd || plan9\n+//go:build (linux && !android) || (darwin && !ios) || freebsd || openbsd || plan9\n \n package tailssh\n \n---\n\n\n---\n\nChoice C:\nnet/netmon/state.go\n@@ -27,8 +27,9 @@ import (\n // same interface and subnet.\n var forceAllIPv6Endpoints = envknob.RegisterBool(\"TS_DEBUG_FORCE_ALL_IPV6_ENDPOINTS\")\n \n-// set a debug knob to exclude interfaces from the list of interfaces\n-var excludedInterfaces = envknob.RegisterString(\"TS_DEBUG_EXCLUDED_INTERFACES\")\n+// suppressInterfaces is a debug knob containing a list of interface names that should not be advertised as endpoints. \n+// Traffic may still flow over these interfaces if system routing makes the decision to do so.\n+var excludeInterfaces = envknob.RegisterString(\"TS_DEBUG_EXCLUDE_INTERFACES\")\n \n // LoginEndpointForProxyDetermination is the URL used for testing\n // which HTTP proxy the system should use.\n@@ -54,7 +55,7 @@ func isExcludedInterface(nif *net.Interface) bool {\n \t\treturn false\n \t}\n \n-\tremain := excludedInterfaces()\n+\tremain := excludeInterfaces()\n \tfor remain != \"\" {\n \t\tvar candidate string\n \t\tcandidate, remain, _ = strings.Cut(remain, \",\")\n---\n\n\n---\n\nChoice D:\ncmd/tsidp/tsidp.go\n@@ -795,7 +795,7 @@ type oidcTokenResponse struct {\n \tIDToken      string `json:\"id_token\"`\n \tTokenType    string `json:\"token_type\"`\n \tAccessToken  string `json:\"access_token\"`\n-\tRefreshToken string `json:\"refresh_token\"`\n+\tRefreshToken string `json:\"refresh_token,omitempty\"`\n \tExpiresIn    int    `json:\"expires_in\"`\n }\n \n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/tailscale#13452\n\n---\n\nChoice A:\ncmd/tsidp/tsidp.go\n@@ -795,7 +795,7 @@ type oidcTokenResponse struct {\n \tIDToken      string `json:\"id_token\"`\n \tTokenType    string `json:\"token_type\"`\n \tAccessToken  string `json:\"access_token\"`\n-\tRefreshToken string `json:\"refresh_token\"`\n+\tRefreshToken string `json:\"refresh_token,omitempty\"`\n \tExpiresIn    int    `json:\"expires_in\"`\n }\n \n---\n\n\n---\n\nChoice B:\nsyncs/syncs.go\n@@ -67,12 +67,18 @@ func (v *AtomicValue[T]) Swap(x T) (old T) {\n \tif oldV != nil {\n \t\treturn oldV.(wrappedValue[T]).v\n \t}\n-\treturn old\n+\treturn old // zero value of T\n }\n \n // CompareAndSwap executes the compare-and-swap operation for the Value.\n+// It panics if T is not comparable.\n func (v *AtomicValue[T]) CompareAndSwap(oldV, newV T) (swapped bool) {\n-\treturn v.v.CompareAndSwap(wrappedValue[T]{oldV}, wrappedValue[T]{newV})\n+\tvar zero T\n+\treturn v.v.CompareAndSwap(wrappedValue[T]{oldV}, wrappedValue[T]{newV}) ||\n+\t\t// In the edge-case where [atomic.Value.Store] is uninitialized\n+\t\t// and trying to compare with the zero value of T,\n+\t\t// then compare-and-swap with the nil any value.\n+\t\t(any(oldV) == any(zero) && v.v.CompareAndSwap(any(nil), wrappedValue[T]{newV}))\n }\n \n // MutexValue is a value protected by a mutex.\n---\nsyncs/syncs_test.go\n@@ -64,6 +64,23 @@ func TestAtomicValue(t *testing.T) {\n \t\t\tt.Fatalf(\"LoadOk = (%v, %v), want (nil, true)\", got, gotOk)\n \t\t}\n \t}\n+\n+\t{\n+\t\tc1, c2, c3 := make(chan struct{}), make(chan struct{}), make(chan struct{})\n+\t\tvar v AtomicValue[chan struct{}]\n+\t\tif v.CompareAndSwap(c1, c2) != false {\n+\t\t\tt.Fatalf(\"CompareAndSwap = true, want false\")\n+\t\t}\n+\t\tif v.CompareAndSwap(nil, c1) != true {\n+\t\t\tt.Fatalf(\"CompareAndSwap = false, want true\")\n+\t\t}\n+\t\tif v.CompareAndSwap(c2, c3) != false {\n+\t\t\tt.Fatalf(\"CompareAndSwap = true, want false\")\n+\t\t}\n+\t\tif v.CompareAndSwap(c1, c2) != true {\n+\t\t\tt.Fatalf(\"CompareAndSwap = false, want true\")\n+\t\t}\n+\t}\n }\n \n func TestMutexValue(t *testing.T) {\n---\n\n\n---\n\nChoice C:\ngo.toolchain.rev\n@@ -1 +1 @@\n-16b6e4fd15c59336156cdbc977de1745ad094f2d\n+982da8f24fa0504f2214f24b0d68b2febd5983f8\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/cli_test.go\n@@ -1659,3 +1659,51 @@ func TestSingleUseStringFlag(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestSingleUseStringFlagsSetTwice(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tflagName string\n+\t\tvals     []string\n+\t\tsetup    func(*upArgsT) flag.Value\n+\t}{\n+\t\t{\n+\t\t\tname:     \"advertise-tags\",\n+\t\t\tflagName: \"advertise-tags\",\n+\t\t\tvals:     []string{\"tag:foo\", \"tag:bar\"},\n+\t\t\tsetup: func(u *upArgsT) flag.Value {\n+\t\t\t\treturn &u.advertiseTags\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"advertise-routes\",\n+\t\t\tflagName: \"advertise-routes\",\n+\t\t\tvals:     []string{\"10.0.0.0/8\", \"192.168.0.0/16\"},\n+\t\t\tsetup: func(u *upArgsT) flag.Value {\n+\t\t\t\treturn &u.advertiseRoutes\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tvar upArgs upArgsT\n+\t\t\tfs := flag.NewFlagSet(\"test\", flag.ContinueOnError)\n+\t\t\tfs.SetOutput(io.Discard)\n+\n+\t\t\tfs.Var(tt.setup(&upArgs), tt.flagName, \"\")\n+\t\t\targs := []string{\n+\t\t\t\tfmt.Sprintf(\"--%s=%s\", tt.flagName, tt.vals[0]),\n+\t\t\t\tfmt.Sprintf(\"--%s=%s\", tt.flagName, tt.vals[1]),\n+\t\t\t}\n+\n+\t\t\terr := fs.Parse(args)\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatal(\"expected error when setting flag twice, got nil\")\n+\t\t\t}\n+\t\t\tif !strings.Contains(err.Error(), \"flag can only be specified once\") {\n+\t\t\t\tt.Errorf(\"unexpected error message: %v\", err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThe http.StatusMethodNotAllowed status code was being erroneously set instead of http.StatusBadRequest in multiple places.\r\n\r\nUpdates #cleanup\n\n---\n\nChoice A:\ncmd/tailscale/cli/cli.go\n@@ -207,6 +207,8 @@ func noDupFlagify(c *ffcli.Command) {\n \t}\n }\n \n+var fileCmd func() *ffcli.Command\n+\n func newRootCmd() *ffcli.Command {\n \trootfs := newFlagSet(\"tailscale\")\n \trootfs.Func(\"socket\", \"path to tailscaled socket\", func(s string) error {\n@@ -247,7 +249,7 @@ change in the future.\n \t\t\tserveCmd(),\n \t\t\tversionCmd,\n \t\t\twebCmd,\n-\t\t\tfileCmd,\n+\t\t\tnilOrCall(fileCmd),\n \t\t\tbugReportCmd,\n \t\t\tcertCmd,\n \t\t\tnetlockCmd,\n@@ -286,6 +288,13 @@ func nonNilCmds(cmds ...*ffcli.Command) []*ffcli.Command {\n \treturn slicesx.AppendNonzero(cmds[:0], cmds)\n }\n \n+func nilOrCall(f func() *ffcli.Command) *ffcli.Command {\n+\tif f == nil {\n+\t\treturn nil\n+\t}\n+\treturn f()\n+}\n+\n func fatalf(format string, a ...any) {\n \tif Fatalf != nil {\n \t\tFatalf(format, a...)\n---\ncmd/tailscale/cli/file.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !ts_omit_taildrop\n+\n package cli\n \n import (\n@@ -38,14 +40,20 @@ import (\n \t\"tailscale.com/version\"\n )\n \n-var fileCmd = &ffcli.Command{\n-\tName:       \"file\",\n-\tShortUsage: \"tailscale file <cp|get> ...\",\n-\tShortHelp:  \"Send or receive files\",\n-\tSubcommands: []*ffcli.Command{\n-\t\tfileCpCmd,\n-\t\tfileGetCmd,\n-\t},\n+func init() {\n+\tfileCmd = getFileCmd\n+}\n+\n+func getFileCmd() *ffcli.Command {\n+\treturn &ffcli.Command{\n+\t\tName:       \"file\",\n+\t\tShortUsage: \"tailscale file <cp|get> ...\",\n+\t\tShortHelp:  \"Send or receive files\",\n+\t\tSubcommands: []*ffcli.Command{\n+\t\t\tfileCpCmd,\n+\t\t\tfileGetCmd,\n+\t\t},\n+\t}\n }\n \n type countingReader struct {\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/peerapi.go\n@@ -417,7 +417,7 @@ func (h *peerAPIHandler) handleServeIngress(w http.ResponseWriter, r *http.Reque\n \t}\n \tlogAndError := func(code int, publicMsg string) {\n \t\th.logf(\"ingress: bad request from %v: %s\", h.remoteAddr, publicMsg)\n-\t\thttp.Error(w, publicMsg, http.StatusMethodNotAllowed)\n+\t\thttp.Error(w, publicMsg, code)\n \t}\n \tbad := func(publicMsg string) {\n \t\tlogAndError(http.StatusBadRequest, publicMsg)\n---\n\n\n---\n\nChoice C:\ndocs/windows/policy/en-US/tailscale.adml\n@@ -16,6 +16,7 @@\n             <string id=\"SINCE_V1_62\">Tailscale version 1.62.0 and later</string>\n             <string id=\"SINCE_V1_74\">Tailscale version 1.74.0 and later</string>\n             <string id=\"SINCE_V1_78\">Tailscale version 1.78.0 and later</string>\n+            <string id=\"SINCE_V1_80\">Tailscale version 1.80.0 and later</string>\n             <string id=\"SINCE_V1_82\">Tailscale version 1.82.0 and later</string>\n             <string id=\"SINCE_V1_84\">Tailscale version 1.84.0 and later</string>\n             <string id=\"Tailscale_Category\">Tailscale</string>\n@@ -271,6 +272,12 @@ If you enable this policy, the menu item will be displayed indicating the organi\n If you disable this policy or do not configure it, the corresponding menu item will be hidden.\n \n See https://tailscale.com/kb/1315/mdm-keys#set-your-organization-name for more details.]]></string>\n+            <string id=\"OnboardingFlow\">Show the onboarding flow</string>\n+            <string id=\"OnboardingFlow_Help\"><![CDATA[This policy can be used to show or hide the onboarding flow displayed by the GUI.\n+\n+If you enable or don't configure this policy, the onboarding flow will be shown to new users who have not yet signed in to a Tailscale account.\n+\n+If you disable this policy, the onboarding flow will never be shown.]]></string>\n         </stringTable>\n         <presentationTable>\n             <presentation id=\"LoginURL\">\n---\ndocs/windows/policy/tailscale.admx\n@@ -54,6 +54,10 @@\n                   displayName=\"$(string.SINCE_V1_78)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n       </definition>\n+      <definition name=\"SINCE_V1_80\"\n+                  displayName=\"$(string.SINCE_V1_80)\">\n+        <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n+      </definition>\n       <definition name=\"SINCE_V1_82\"\n                   displayName=\"$(string.SINCE_V1_82)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n@@ -335,6 +339,16 @@\n         <string>hide</string>\n       </disabledValue>\n     </policy>\n+    <policy name=\"OnboardingFlow\" class=\"Both\" displayName=\"$(string.OnboardingFlow)\" explainText=\"$(string.OnboardingFlow_Help)\" key=\"Software\\Policies\\Tailscale\" valueName=\"OnboardingFlow\">\n+      <parentCategory ref=\"UI_Category\" />\n+      <supportedOn ref=\"SINCE_V1_80\" />\n+      <enabledValue>\n+        <string>show</string>\n+      </enabledValue>\n+      <disabledValue>\n+        <string>hide</string>\n+      </disabledValue>\n+    </policy>\n     <policy name=\"ManagedBy\" class=\"Both\" displayName=\"$(string.ManagedBy)\" explainText=\"$(string.ManagedBy_Help)\" presentation=\"$(presentation.ManagedBy)\" key=\"Software\\Policies\\Tailscale\">\n       <parentCategory ref=\"UI_Category\" />\n       <supportedOn ref=\"SINCE_V1_62\" />\n---\n\n\n---\n\nChoice D:\ncmd/containerboot/healthz.go\n@@ -47,10 +47,10 @@ func (h *healthz) update(healthy bool) {\n \th.hasAddrs = healthy\n }\n \n-// healthHandlers registers a simple health handler at /healthz.\n+// registerHealthHandlers registers a simple health handler at /healthz.\n // A containerized tailscale instance is considered healthy if\n // it has at least one tailnet IP address.\n-func healthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n+func registerHealthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n \th := &healthz{podIPv4: podIPv4}\n \tmux.Handle(\"GET /healthz\", h)\n \treturn h\n---\ncmd/containerboot/main.go\n@@ -195,18 +195,21 @@ func run() error {\n \t\treturn fmt.Errorf(\"failed to bring up tailscale: %w\", err)\n \t}\n \tkillTailscaled := func() {\n+\t\t// The default termination grace period for a Pod is 30s. We wait 25s at\n+\t\t// most so that we still reserve some of that budget for tailscaled\n+\t\t// to receive and react to a SIGTERM before the SIGKILL that k8s\n+\t\t// will send at the end of the grace period.\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)\n+\t\tdefer cancel()\n+\n+\t\tif err := ensureServicesNotAdvertised(ctx, client); err != nil {\n+\t\t\tlog.Printf(\"Error ensuring services are not advertised: %v\", err)\n+\t\t}\n+\n \t\tif hasKubeStateStore(cfg) {\n \t\t\t// Check we're not shutting tailscaled down while it's still writing\n \t\t\t// state. If we authenticate and fail to write all the state, we'll\n \t\t\t// never recover automatically.\n-\t\t\t//\n-\t\t\t// The default termination grace period for a Pod is 30s. We wait 25s at\n-\t\t\t// most so that we still reserve some of that budget for tailscaled\n-\t\t\t// to receive and react to a SIGTERM before the SIGKILL that k8s\n-\t\t\t// will send at the end of the grace period.\n-\t\t\tctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)\n-\t\t\tdefer cancel()\n-\n \t\t\tlog.Printf(\"Checking for consistent state\")\n \t\t\terr := kc.waitForConsistentState(ctx)\n \t\t\tif err != nil {\n@@ -226,7 +229,7 @@ func run() error {\n \t\tmux := http.NewServeMux()\n \n \t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.HealthCheckAddrPort)\n-\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \n \t\tclose := runHTTPServer(mux, cfg.HealthCheckAddrPort)\n \t\tdefer close()\n@@ -237,15 +240,16 @@ func run() error {\n \n \t\tif cfg.localMetricsEnabled() {\n \t\t\tlog.Printf(\"Running metrics endpoint at %s/metrics\", cfg.LocalAddrPort)\n-\t\t\tmetricsHandlers(mux, client, cfg.DebugAddrPort)\n+\t\t\tregisterMetricsHandlers(mux, client, cfg.DebugAddrPort)\n \t\t}\n \n \t\tif cfg.localHealthEnabled() {\n \t\t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.LocalAddrPort)\n-\t\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \t\t}\n-\t\tif cfg.EgressProxiesCfgPath != \"\" {\n-\t\t\tlog.Printf(\"Running preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n+\n+\t\tif cfg.egressSvcsTerminateEPEnabled() {\n+\t\t\tlog.Printf(\"Running egress preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n \t\t\tep.registerHandlers(mux)\n \t\t}\n \n---\ncmd/containerboot/metrics.go\n@@ -62,13 +62,13 @@ func (m *metrics) handleDebug(w http.ResponseWriter, r *http.Request) {\n \tproxy(w, r, debugURL, http.DefaultClient.Do)\n }\n \n-// metricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n+// registerMetricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n // requests to tailscaled's /localapi/v0/usermetrics API.\n //\n // In 1.78.x and 1.80.x, it also proxies debug paths to tailscaled's debug\n // endpoint if configured to ease migration for a breaking change serving user\n // metrics instead of debug metrics on the \"metrics\" port.\n-func metricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n+func registerMetricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n \tm := &metrics{\n \t\tlc:            lc,\n \t\tdebugEndpoint: debugAddrPort,\n---\ncmd/containerboot/serve.go\n@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"log\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -169,3 +170,46 @@ func readServeConfig(path, certDomain string) (*ipn.ServeConfig, error) {\n \t}\n \treturn &sc, nil\n }\n+\n+func ensureServicesNotAdvertised(ctx context.Context, lc *local.Client) error {\n+\tprefs, err := lc.GetPrefs(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"error getting prefs: %w\", err)\n+\t}\n+\tif len(prefs.AdvertiseServices) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tlog.Printf(\"serve proxy: unadvertising services: %v\", prefs.AdvertiseServices)\n+\tif _, err := lc.EditPrefs(ctx, &ipn.MaskedPrefs{\n+\t\tAdvertiseServicesSet: true,\n+\t\tPrefs: ipn.Prefs{\n+\t\t\tAdvertiseServices: nil,\n+\t\t},\n+\t}); err != nil {\n+\t\t// EditPrefs only returns an error if it fails _set_ its local prefs.\n+\t\t// If it fails to _persist_ the prefs in state, we don't get an error\n+\t\t// and we continue waiting below, as control will failover as usual.\n+\t\treturn fmt.Errorf(\"error setting prefs AdvertiseServices: %w\", err)\n+\t}\n+\n+\t// Services use the same (failover XOR regional routing) mechanism that\n+\t// HA subnet routers use. Unfortunately we don't yet get a reliable signal\n+\t// from control that it's responded to our unadvertisement, so the best we\n+\t// can do is wait for 20 seconds, where 15s is the approximate maximum time\n+\t// it should take for control to choose a new primary, and 5s is for buffer.\n+\t//\n+\t// Note: There is no guarantee that clients have been _informed_ of the new\n+\t// primary no matter how long we wait. We would need a mechanism to await\n+\t// netmap updates for peers to know for sure.\n+\t//\n+\t// See https://tailscale.com/kb/1115/high-availability for more details.\n+\t// TODO(tomhjp): Wait for a netmap update instead of sleeping when control\n+\t// supports that.\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\treturn nil\n+\tcase <-time.After(20 * time.Second):\n+\t\treturn nil\n+\t}\n+}\n---\ncmd/k8s-operator/proxygroup_specs.go\n@@ -197,6 +197,16 @@ func pgStatefulSet(pg *tsapi.ProxyGroup, namespace, image, tsFirewallMode string\n \t// This mechanism currently (2025-01-26) rely on the local health check being accessible on the Pod's\n \t// IP, so they are not supported for ProxyGroups where users have configured TS_LOCAL_ADDR_PORT to a custom\n \t// value.\n+\t//\n+\t// NB: For _Ingress_ ProxyGroups, we run shutdown logic within containerboot\n+\t// in reaction to a SIGTERM signal instead of using a pre-stop hook. This is\n+\t// because Ingress pods need to unadvertise services, and it's preferable to\n+\t// avoid triggering those side-effects from a GET request that would be\n+\t// accessible to the whole cluster network (in the absence of NetworkPolicy\n+\t// rules).\n+\t//\n+\t// TODO(tomhjp): add a readiness probe or gate to Ingress Pods. There is a\n+\t// small window where the Pod is marked ready but routing can still fail.\n \tif pg.Spec.Type == tsapi.ProxyGroupTypeEgress && !hasLocalAddrPortSet(proxyClass) {\n \t\tc.Lifecycle = &corev1.Lifecycle{\n \t\t\tPreStop: &corev1.LifecycleHandler{\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIn this PR, we update the Windows client updater to:\r\n- Run `msiexec` with logging enabled and preserve the log file in `%ProgramData%\\Tailscale\\Logs`. The logging helps us troubleshoot issues where something goes wrong, such as the GUI not restarting properly during the update.\r\n- Preserve the updater's own log file in the same location;\r\n- Properly handle `ERROR_SUCCESS_REBOOT_REQUIRED`, `ERROR_SUCCESS_REBOOT_INITIATED`, and `ERROR_INSTALL_ALREADY_RUNNING` exit codes. The first two values indicate that installation completed successfully and no further retries are needed. The last one means the Windows Installer service is busy. Retrying immediately is likely to fail and may be risky; it could uninstall the current version without successfully installing the new one, potentially leaving the user without Tailscale.\r\n\r\nThe logging is to help us troubleshoot issues where something goes wrong, such as the GUI isn't restarted properly during the update.\r\n\r\nUpdates tailscale/corp#27496\r\nUpdates tailscale#15554\n\n---\n\nChoice A:\nipn/prefs.go\n@@ -721,9 +721,10 @@ func (p *Prefs) ControlURLOrDefault() string {\n // of the platform it's running on.\n func (p *Prefs) DefaultRouteAll(goos string) bool {\n \tswitch goos {\n-\tcase \"windows\":\n+\tcase \"windows\", \"android\", \"ios\":\n \t\treturn true\n \tcase \"darwin\":\n+\t\t// Only true for macAppStore and macsys, false for darwin tailscaled.\n \t\treturn version.IsSandboxedMacOS()\n \tdefault:\n \t\treturn false\n---\n\n\n---\n\nChoice B:\ntsnet/depaware.txt\n@@ -80,10 +80,10 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n    L    github.com/aws/smithy-go/transport/http                      from github.com/aws/aws-sdk-go-v2/aws/middleware+\n    L    github.com/aws/smithy-go/transport/http/internal/io          from github.com/aws/smithy-go/transport/http\n    L    github.com/aws/smithy-go/waiter                              from github.com/aws/aws-sdk-go-v2/service/ssm\n- LDWA    github.com/coder/websocket                                   from tailscale.com/util/eventbus\n- LDWA    github.com/coder/websocket/internal/errd                     from github.com/coder/websocket\n- LDWA    github.com/coder/websocket/internal/util                     from github.com/coder/websocket\n- LDWA    github.com/coder/websocket/internal/xsync                    from github.com/coder/websocket\n+ LDW    github.com/coder/websocket                                   from tailscale.com/util/eventbus\n+ LDW    github.com/coder/websocket/internal/errd                     from github.com/coder/websocket\n+ LDW    github.com/coder/websocket/internal/util                     from github.com/coder/websocket\n+ LDW    github.com/coder/websocket/internal/xsync                    from github.com/coder/websocket\n    L    github.com/coreos/go-iptables/iptables                       from tailscale.com/util/linuxfw\n    W \ud83d\udca3 github.com/dblohm7/wingoes                                   from github.com/dblohm7/wingoes/com+\n    W \ud83d\udca3 github.com/dblohm7/wingoes/com                               from tailscale.com/util/osdiag+\n@@ -552,7 +552,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         hash/crc32                                                   from compress/gzip+\n         hash/maphash                                                 from go4.org/mem\n         html                                                         from html/template+\n- LDWA    html/template                                                from github.com/gorilla/csrf+\n+ LDW    html/template                                                from github.com/gorilla/csrf+\n         internal/abi                                                 from crypto/x509/internal/macos+\n         internal/asan                                                from internal/runtime/maps+\n         internal/bisect                                              from internal/godebug\n@@ -639,8 +639,8 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         sync/atomic                                                  from context+\n         syscall                                                      from archive/tar+\n         text/tabwriter                                               from runtime/pprof\n- LDWA    text/template                                                from html/template\n- LDWA    text/template/parse                                          from html/template+\n+ LDW    text/template                                                from html/template\n+ LDW    text/template/parse                                          from html/template+\n         time                                                         from archive/tar+\n         unicode                                                      from bytes+\n         unicode/utf16                                                from crypto/x509+\n---\nutil/eventbus/debughttp.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !ios\n+//go:build !ios && !android\n \n package eventbus\n \n---\nutil/eventbus/debughttp_off.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build ios\n+//go:build ios || android\n \n package eventbus\n \n@@ -12,6 +12,8 @@ func registerHTTPDebugger(d *Debugger, td *tsweb.DebugHandler) {\n \t// reflection for method lookups. This forces the compiler to\n \t// retain a lot more code and information to make dynamic method\n \t// dispatch work, which is unacceptable bloat for the iOS build.\n+\t// We also disable it on Android while we're at it, as nobody\n+\t// is debugging Tailscale internals on Android.\n \t//\n \t// TODO: https://github.com/tailscale/tailscale/issues/15297 to\n \t// bring the debug UI back to iOS somehow.\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/extension_host.go\n@@ -25,6 +25,7 @@ import (\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/execqueue\"\n \t\"tailscale.com/util/set\"\n+\t\"tailscale.com/util/slicesx\"\n \t\"tailscale.com/util/testenv\"\n )\n \n@@ -378,7 +379,7 @@ func (h *ExtensionHost) NotifyProfileChange(profile ipn.LoginProfileView, prefs\n \th.currentPrefs = prefs\n \th.currentProfile = profile\n \t// Get the callbacks to be invoked.\n-\tcbs := collectValues(h.profileStateChangeCbs)\n+\tcbs := slicesx.MapValues(h.profileStateChangeCbs)\n \th.mu.Unlock()\n \tfor _, cb := range cbs {\n \t\tcb(profile, prefs, sameNode)\n@@ -402,7 +403,7 @@ func (h *ExtensionHost) NotifyProfilePrefsChanged(profile ipn.LoginProfileView,\n \th.currentPrefs = newPrefs\n \th.currentProfile = profile\n \t// Get the callbacks to be invoked.\n-\tstateCbs := collectValues(h.profileStateChangeCbs)\n+\tstateCbs := slicesx.MapValues(h.profileStateChangeCbs)\n \th.mu.Unlock()\n \tfor _, cb := range stateCbs {\n \t\tcb(profile, newPrefs, true)\n@@ -443,7 +444,7 @@ func (h *ExtensionHost) DetermineBackgroundProfile(profiles ipnext.ProfileStore)\n \t// Attempt to resolve the background profile using the registered\n \t// background profile resolvers (e.g., [ipn/desktop.desktopSessionsExt] on Windows).\n \th.mu.Lock()\n-\tresolvers := collectValues(h.backgroundProfileResolvers)\n+\tresolvers := slicesx.MapValues(h.backgroundProfileResolvers)\n \th.mu.Unlock()\n \tfor _, resolver := range resolvers {\n \t\tif profile := resolver(profiles); profile.Valid() {\n@@ -481,7 +482,7 @@ func (h *ExtensionHost) NotifyNewControlClient(cc controlclient.Client, profile\n \t\treturn nil\n \t}\n \th.mu.Lock()\n-\tcbs := collectValues(h.newControlClientCbs)\n+\tcbs := slicesx.MapValues(h.newControlClientCbs)\n \th.mu.Unlock()\n \tif len(cbs) > 0 {\n \t\tccShutdownCbs = make([]func(), 0, len(cbs))\n@@ -527,7 +528,7 @@ func (h *ExtensionHost) AuditLogger() ipnauth.AuditLogFunc {\n \t}\n \n \th.mu.Lock()\n-\tproviders := collectValues(h.auditLoggers)\n+\tproviders := slicesx.MapValues(h.auditLoggers)\n \th.mu.Unlock()\n \n \tvar loggers []ipnauth.AuditLogFunc\n@@ -642,17 +643,3 @@ type execQueue interface {\n \tShutdown()\n \tWait(context.Context) error\n }\n-\n-// collectValues is like [slices.Collect] of [maps.Values],\n-// but pre-allocates the slice to avoid reallocations.\n-// It returns nil if the map is empty.\n-func collectValues[K comparable, V any](m map[K]V) []V {\n-\tif len(m) == 0 {\n-\t\treturn nil\n-\t}\n-\ts := make([]V, 0, len(m))\n-\tfor _, v := range m {\n-\t\ts = append(s, v)\n-\t}\n-\treturn s\n-}\n---\n\n\n---\n\nChoice D:\nclientupdate/clientupdate_windows.go\n@@ -16,6 +16,7 @@ import (\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"strings\"\n+\t\"time\"\n \n \t\"github.com/google/uuid\"\n \t\"golang.org/x/sys/windows\"\n@@ -34,6 +35,12 @@ const (\n \t// It is used to re-launch the GUI process (tailscale-ipn.exe) after\n \t// install is complete.\n \twinExePathEnv = \"TS_UPDATE_WIN_EXE_PATH\"\n+\t// winVersionEnv is the environment variable that is set along with\n+\t// winMSIEnv and carries the version of tailscale that is being installed.\n+\t// It is used for logging purposes.\n+\twinVersionEnv = \"TS_UPDATE_WIN_VERSION\"\n+\t// updaterPrefix is the prefix for the temporary executable created by [makeSelfCopy].\n+\tupdaterPrefix = \"tailscale-updater\"\n )\n \n func makeSelfCopy() (origPathExe, tmpPathExe string, err error) {\n@@ -46,7 +53,7 @@ func makeSelfCopy() (origPathExe, tmpPathExe string, err error) {\n \t\treturn \"\", \"\", err\n \t}\n \tdefer f.Close()\n-\tf2, err := os.CreateTemp(\"\", \"tailscale-updater-*.exe\")\n+\tf2, err := os.CreateTemp(\"\", updaterPrefix+\"-*.exe\")\n \tif err != nil {\n \t\treturn \"\", \"\", err\n \t}\n@@ -137,7 +144,7 @@ you can run the command prompt as Administrator one of these ways:\n \tup.Logf(\"authenticode verification succeeded\")\n \n \tup.Logf(\"making tailscale.exe copy to switch to...\")\n-\tup.cleanupOldDownloads(filepath.Join(os.TempDir(), \"tailscale-updater-*.exe\"))\n+\tup.cleanupOldDownloads(filepath.Join(os.TempDir(), updaterPrefix+\"-*.exe\"))\n \tselfOrig, selfCopy, err := makeSelfCopy()\n \tif err != nil {\n \t\treturn err\n@@ -146,7 +153,7 @@ you can run the command prompt as Administrator one of these ways:\n \tup.Logf(\"running tailscale.exe copy for final install...\")\n \n \tcmd := exec.Command(selfCopy, \"update\")\n-\tcmd.Env = append(os.Environ(), winMSIEnv+\"=\"+msiTarget, winExePathEnv+\"=\"+selfOrig)\n+\tcmd.Env = append(os.Environ(), winMSIEnv+\"=\"+msiTarget, winExePathEnv+\"=\"+selfOrig, winVersionEnv+\"=\"+ver)\n \tcmd.Stdout = up.Stderr\n \tcmd.Stderr = up.Stderr\n \tcmd.Stdin = os.Stdin\n@@ -162,23 +169,62 @@ you can run the command prompt as Administrator one of these ways:\n func (up *Updater) installMSI(msi string) error {\n \tvar err error\n \tfor tries := 0; tries < 2; tries++ {\n-\t\tcmd := exec.Command(\"msiexec.exe\", \"/i\", filepath.Base(msi), \"/quiet\", \"/norestart\", \"/qn\")\n+\t\t// msiexec.exe requires exclusive access to the log file, so create a dedicated one for each run.\n+\t\tinstallLogPath := up.startNewLogFile(\"tailscale-installer\", os.Getenv(winVersionEnv))\n+\t\tup.Logf(\"Install log: %s\", installLogPath)\n+\t\tcmd := exec.Command(\"msiexec.exe\", \"/i\", filepath.Base(msi), \"/quiet\", \"/norestart\", \"/qn\", \"/L*v\", installLogPath)\n \t\tcmd.Dir = filepath.Dir(msi)\n \t\tcmd.Stdout = up.Stdout\n \t\tcmd.Stderr = up.Stderr\n \t\tcmd.Stdin = os.Stdin\n \t\terr = cmd.Run()\n-\t\tif err == nil {\n-\t\t\tbreak\n+\t\tswitch err := err.(type) {\n+\t\tcase nil:\n+\t\t\t// Success.\n+\t\t\treturn nil\n+\t\tcase *exec.ExitError:\n+\t\t\t// For possible error codes returned by Windows Installer, see\n+\t\t\t// https://web.archive.org/web/20250409144914/https://learn.microsoft.com/en-us/windows/win32/msi/error-codes\n+\t\t\tswitch windows.Errno(err.ExitCode()) {\n+\t\t\tcase windows.ERROR_SUCCESS_REBOOT_REQUIRED:\n+\t\t\t\t// In most cases, updating Tailscale should not require a reboot.\n+\t\t\t\t// If it does, it might be because we failed to close the GUI\n+\t\t\t\t// and the installer couldn't replace tailscale-ipn.exe.\n+\t\t\t\t// The old GUI will continue to run until the next reboot.\n+\t\t\t\t// Not ideal, but also not a retryable error.\n+\t\t\t\tup.Logf(\"[unexpected] reboot required\")\n+\t\t\t\treturn nil\n+\t\t\tcase windows.ERROR_SUCCESS_REBOOT_INITIATED:\n+\t\t\t\t// Same as above, but perhaps the device is configured to prompt\n+\t\t\t\t// the user to reboot and the user has chosen to reboot now.\n+\t\t\t\tup.Logf(\"[unexpected] reboot initiated\")\n+\t\t\t\treturn nil\n+\t\t\tcase windows.ERROR_INSTALL_ALREADY_RUNNING:\n+\t\t\t\t// The Windows Installer service is currently busy.\n+\t\t\t\t// It could be our own install initiated by user/MDM/GP, another MSI install or perhaps a Windows Update install.\n+\t\t\t\t// Anyway, we can't do anything about it right now. The user (or tailscaled) can retry later.\n+\t\t\t\t// Retrying now will likely fail, and is risky since we might uninstall the current version\n+\t\t\t\t// and then fail to install the new one, leaving the user with no Tailscale at all.\n+\t\t\t\t//\n+\t\t\t\t// TODO(nickkhyl,awly): should we check if this is actually a downgrade before uninstalling the current version?\n+\t\t\t\t// Also, maybe keep retrying the install longer if we uninstalled the current version due to a failed install attempt?\n+\t\t\t\tup.Logf(\"another installation is already in progress\")\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\tdefault:\n+\t\t\t// Everything else is a retryable error.\n \t\t}\n+\n \t\tup.Logf(\"Install attempt failed: %v\", err)\n \t\tuninstallVersion := up.currentVersion\n \t\tif v := os.Getenv(\"TS_DEBUG_UNINSTALL_VERSION\"); v != \"\" {\n \t\t\tuninstallVersion = v\n \t\t}\n+\t\tuninstallLogPath := up.startNewLogFile(\"tailscale-uninstaller\", uninstallVersion)\n \t\t// Assume it's a downgrade, which msiexec won't permit. Uninstall our current version first.\n \t\tup.Logf(\"Uninstalling current version %q for downgrade...\", uninstallVersion)\n-\t\tcmd = exec.Command(\"msiexec.exe\", \"/x\", msiUUIDForVersion(uninstallVersion), \"/norestart\", \"/qn\")\n+\t\tup.Logf(\"Uninstall log: %s\", uninstallLogPath)\n+\t\tcmd = exec.Command(\"msiexec.exe\", \"/x\", msiUUIDForVersion(uninstallVersion), \"/norestart\", \"/qn\", \"/L*v\", uninstallLogPath)\n \t\tcmd.Stdout = up.Stdout\n \t\tcmd.Stderr = up.Stderr\n \t\tcmd.Stdin = os.Stdin\n@@ -205,12 +251,14 @@ func (up *Updater) switchOutputToFile() (io.Closer, error) {\n \tvar logFilePath string\n \texePath, err := os.Executable()\n \tif err != nil {\n-\t\tlogFilePath = filepath.Join(os.TempDir(), \"tailscale-updater.log\")\n+\t\tlogFilePath = up.startNewLogFile(updaterPrefix, os.Getenv(winVersionEnv))\n \t} else {\n-\t\tlogFilePath = strings.TrimSuffix(exePath, \".exe\") + \".log\"\n+\t\t// Use the same suffix as the self-copy executable.\n+\t\tsuffix := strings.TrimSuffix(strings.TrimPrefix(filepath.Base(exePath), updaterPrefix), \".exe\")\n+\t\tlogFilePath = up.startNewLogFile(updaterPrefix, os.Getenv(winVersionEnv)+suffix)\n \t}\n \n-\tup.Logf(\"writing update output to %q\", logFilePath)\n+\tup.Logf(\"writing update output to: %s\", logFilePath)\n \tlogFile, err := os.Create(logFilePath)\n \tif err != nil {\n \t\treturn nil, err\n@@ -223,3 +271,20 @@ func (up *Updater) switchOutputToFile() (io.Closer, error) {\n \tup.Stderr = logFile\n \treturn logFile, nil\n }\n+\n+// startNewLogFile returns a name for a new log file.\n+// It cleans up any old log files with the same baseNamePrefix.\n+func (up *Updater) startNewLogFile(baseNamePrefix, baseNameSuffix string) string {\n+\tbaseName := fmt.Sprintf(\"%s-%s-%s.log\", baseNamePrefix,\n+\t\ttime.Now().Format(\"20060102T150405\"), baseNameSuffix)\n+\n+\tdir := filepath.Join(os.Getenv(\"ProgramData\"), \"Tailscale\", \"Logs\")\n+\tif err := os.MkdirAll(dir, 0700); err != nil {\n+\t\tup.Logf(\"failed to create log directory: %v\", err)\n+\t\treturn filepath.Join(os.TempDir(), baseName)\n+\t}\n+\n+\t// TODO(nickkhyl): preserve up to N old log files?\n+\tup.cleanupOldDownloads(filepath.Join(dir, baseNamePrefix+\"-*.log\"))\n+\treturn filepath.Join(dir, baseName)\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis makes sure that the log target override is respected even if a custom HTTP client is passed to logpolicy.\r\n\r\nUpdates tailscale/maple#29\n\n---\n\nChoice A:\nprober/derp.go\n@@ -596,11 +596,23 @@ func (d *derpProber) updateMap(ctx context.Context) error {\n }\n \n func (d *derpProber) ProbeUDP(ipaddr string, port int) ProbeClass {\n+\tinitLabels := make(Labels)\n+\tip := net.ParseIP(ipaddr)\n+\n+\tif ip.To4() != nil {\n+\t\tinitLabels[\"address_family\"] = \"ipv4\"\n+\t} else if ip.To16() != nil { // Will return an IPv4 as 16 byte, so ensure the check for IPv4 precedes this\n+\t\tinitLabels[\"address_family\"] = \"ipv6\"\n+\t} else {\n+\t\tinitLabels[\"address_family\"] = \"unknown\"\n+\t}\n+\n \treturn ProbeClass{\n \t\tProbe: func(ctx context.Context) error {\n \t\t\treturn derpProbeUDP(ctx, ipaddr, port)\n \t\t},\n-\t\tClass: \"derp_udp\",\n+\t\tClass:  \"derp_udp\",\n+\t\tLabels: initLabels,\n \t}\n }\n \n---\nprober/prober.go\n@@ -404,10 +404,14 @@ func (p *Probe) recordEndLocked(err error) {\n \t\tp.mSeconds.WithLabelValues(\"ok\").Add(latency.Seconds())\n \t\tp.latencyHist.Value = latency\n \t\tp.latencyHist = p.latencyHist.Next()\n+\t\tp.mAttempts.WithLabelValues(\"fail\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"fail\").Add(0)\n \t} else {\n \t\tp.latency = 0\n \t\tp.mAttempts.WithLabelValues(\"fail\").Inc()\n \t\tp.mSeconds.WithLabelValues(\"fail\").Add(latency.Seconds())\n+\t\tp.mAttempts.WithLabelValues(\"ok\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"ok\").Add(0)\n \t}\n \tp.successHist.Value = p.succeeded\n \tp.successHist = p.successHist.Next()\n---\n\n\n---\n\nChoice B:\nlogpolicy/logpolicy.go\n@@ -518,8 +518,9 @@ type Options struct {\n \tMaxUploadSize int\n }\n \n-// New returns a new log policy (a logger and its instance ID).\n-func (opts Options) New() *Policy {\n+// init initializes the log policy and returns a logtail.Config and the\n+// Policy.\n+func (opts Options) init(disableLogging bool) (*logtail.Config, *Policy) {\n \tif hostinfo.IsNATLabGuestVM() {\n \t\t// In NATLab Gokrazy instances, tailscaled comes up concurently with\n \t\t// DHCP and the doesn't have DNS for a while. Wait for DHCP first.\n@@ -628,7 +629,7 @@ func (opts Options) New() *Policy {\n \t\tconf.IncludeProcSequence = true\n \t}\n \n-\tif envknob.NoLogsNoSupport() || testenv.InTest() || runtime.GOOS == \"plan9\" {\n+\tif disableLogging {\n \t\topts.Logf(\"You have disabled logging. Tailscale will not be able to provide support.\")\n \t\tconf.HTTPC = &http.Client{Transport: noopPretendSuccessTransport{}}\n \t} else {\n@@ -637,14 +638,15 @@ func (opts Options) New() *Policy {\n \t\tattachFilchBuffer(&conf, opts.Dir, opts.CmdName, opts.MaxBufferSize, opts.Logf)\n \t\tconf.HTTPC = opts.HTTPC\n \n+\t\tlogHost := logtail.DefaultHost\n+\t\tif val := getLogTarget(); val != \"\" {\n+\t\t\topts.Logf(\"You have enabled a non-default log target. Doing without being told to by Tailscale staff or your network administrator will make getting support difficult.\")\n+\t\t\tconf.BaseURL = val\n+\t\t\tu, _ := url.Parse(val)\n+\t\t\tlogHost = u.Host\n+\t\t}\n+\n \t\tif conf.HTTPC == nil {\n-\t\t\tlogHost := logtail.DefaultHost\n-\t\t\tif val := getLogTarget(); val != \"\" {\n-\t\t\t\topts.Logf(\"You have enabled a non-default log target. Doing without being told to by Tailscale staff or your network administrator will make getting support difficult.\")\n-\t\t\t\tconf.BaseURL = val\n-\t\t\t\tu, _ := url.Parse(val)\n-\t\t\t\tlogHost = u.Host\n-\t\t\t}\n \t\t\tconf.HTTPC = &http.Client{Transport: TransportOptions{\n \t\t\t\tHost:   logHost,\n \t\t\t\tNetMon: opts.NetMon,\n@@ -680,13 +682,20 @@ func (opts Options) New() *Policy {\n \t\topts.Logf(\"%s\", earlyErrBuf.Bytes())\n \t}\n \n-\treturn &Policy{\n+\treturn &conf, &Policy{\n \t\tLogtail:  lw,\n \t\tPublicID: newc.PublicID,\n \t\tLogf:     opts.Logf,\n \t}\n }\n \n+// New returns a new log policy (a logger and its instance ID).\n+func (opts Options) New() *Policy {\n+\tdisableLogging := envknob.NoLogsNoSupport() || testenv.InTest() || runtime.GOOS == \"plan9\"\n+\t_, policy := opts.init(disableLogging)\n+\treturn policy\n+}\n+\n // attachFilchBuffer creates an on-disk ring buffer using filch and attaches\n // it to the logtail config. Note that this is optional; if no buffer is set,\n // logtail will use an in-memory buffer.\n---\nlogpolicy/logpolicy_test.go\n@@ -4,19 +4,22 @@\n package logpolicy\n \n import (\n+\t\"net/http\"\n \t\"os\"\n \t\"reflect\"\n \t\"testing\"\n \n \t\"tailscale.com/logtail\"\n )\n \n-func TestLogHost(t *testing.T) {\n+func resetLogTarget() {\n+\tos.Unsetenv(\"TS_LOG_TARGET\")\n \tv := reflect.ValueOf(&getLogTargetOnce).Elem()\n-\treset := func() {\n-\t\tv.Set(reflect.Zero(v.Type()))\n-\t}\n-\tdefer reset()\n+\tv.Set(reflect.Zero(v.Type()))\n+}\n+\n+func TestLogHost(t *testing.T) {\n+\tdefer resetLogTarget()\n \n \ttests := []struct {\n \t\tenv  string\n@@ -29,10 +32,55 @@ func TestLogHost(t *testing.T) {\n \t\t{\"https://foo.com:123/\", \"foo.com\"},\n \t}\n \tfor _, tt := range tests {\n-\t\treset()\n+\t\tresetLogTarget()\n \t\tos.Setenv(\"TS_LOG_TARGET\", tt.env)\n \t\tif got := LogHost(); got != tt.want {\n \t\t\tt.Errorf(\"for env %q, got %q, want %q\", tt.env, got, tt.want)\n \t\t}\n \t}\n }\n+func TestOptions(t *testing.T) {\n+\tdefer resetLogTarget()\n+\n+\ttests := []struct {\n+\t\tname        string\n+\t\topts        func() Options\n+\t\twantBaseURL string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"default\",\n+\t\t\topts:        func() Options { return Options{} },\n+\t\t\twantBaseURL: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom_baseurl\",\n+\t\t\topts: func() Options {\n+\t\t\t\tos.Setenv(\"TS_LOG_TARGET\", \"http://localhost:1234\")\n+\t\t\t\treturn Options{}\n+\t\t\t},\n+\t\t\twantBaseURL: \"http://localhost:1234\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom_httpc_and_baseurl\",\n+\t\t\topts: func() Options {\n+\t\t\t\tos.Setenv(\"TS_LOG_TARGET\", \"http://localhost:12345\")\n+\t\t\t\treturn Options{HTTPC: &http.Client{Transport: noopPretendSuccessTransport{}}}\n+\t\t\t},\n+\t\t\twantBaseURL: \"http://localhost:12345\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresetLogTarget()\n+\t\t\tconfig, policy := tt.opts().init(false)\n+\t\t\tif policy == nil {\n+\t\t\t\tt.Fatal(\"unexpected nil policy\")\n+\t\t\t}\n+\t\t\tif config.BaseURL != tt.wantBaseURL {\n+\t\t\t\tt.Errorf(\"got %q, want %q\", config.BaseURL, tt.wantBaseURL)\n+\t\t\t}\n+\t\t\tpolicy.Close()\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\nnet/netmon/netmon.go\n@@ -441,14 +441,14 @@ func (m *Monitor) handlePotentialChange(newState *State, forceCallbacks bool) {\n \tdelta.Major = m.IsMajorChangeFrom(oldState, newState)\n \tif delta.Major {\n \t\tm.gwValid = false\n-\t\tm.ifState = newState\n \n \t\tif s1, s2 := oldState.String(), delta.New.String(); s1 == s2 {\n \t\t\tm.logf(\"[unexpected] network state changed, but stringification didn't: %v\", s1)\n \t\t\tm.logf(\"[unexpected] old: %s\", jsonSummary(oldState))\n \t\t\tm.logf(\"[unexpected] new: %s\", jsonSummary(newState))\n \t\t}\n \t}\n+\tm.ifState = newState\n \t// See if we have a queued or new time jump signal.\n \tif timeJumped {\n \t\tm.resetTimeJumpedLocked()\n---\n\n\n---\n\nChoice D:\ntsnet/depaware.txt\n@@ -132,7 +132,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n    L \ud83d\udca3 github.com/mdlayher/netlink                                  from github.com/google/nftables+\n    L \ud83d\udca3 github.com/mdlayher/netlink/nlenc                            from github.com/jsimonetti/rtnetlink+\n    L    github.com/mdlayher/netlink/nltest                           from github.com/google/nftables\n-  LA    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n+   L    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n   LA \ud83d\udca3 github.com/mdlayher/socket                                   from github.com/mdlayher/netlink+\n         github.com/miekg/dns                                         from tailscale.com/net/dns/recursive\n  LDWA \ud83d\udca3 github.com/mitchellh/go-ps                                   from tailscale.com/safesocket\n---\nutil/systemd/systemd_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package systemd\n \n---\nutil/systemd/systemd_nonlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux || android\n \n package systemd\n \n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nInstaller tests only run when changes are made to pkgserve. This PR schedules the tests to be run daily (10 AM EST) and report any failures to Slack.\r\n\r\nFixes [tailscale/corp#19103](https://github.com/tailscale/corp/issues/19103)\n\n---\n\nChoice A:\ntailcfg/tailcfg.go\n@@ -2446,6 +2446,14 @@ const (\n \t// native tailnet. This is currently only sent to Hello, in its\n \t// peer node list.\n \tNodeAttrNativeIPV4 NodeCapability = \"native-ipv4\"\n+\n+\t// NodeAttrRelayServer permits the node to act as an underlay UDP relay\n+\t// server. There are no expected values for this key in NodeCapMap.\n+\tNodeAttrRelayServer NodeCapability = \"relay:server\"\n+\n+\t// NodeAttrRelayClient permits the node to act as an underlay UDP relay\n+\t// client. There are no expected values for this key in NodeCapMap.\n+\tNodeAttrRelayClient NodeCapability = \"relay:client\"\n )\n \n // SetDNSRequest is a request to add a DNS record.\n---\n\n\n---\n\nChoice B:\nprober/derp.go\n@@ -596,11 +596,23 @@ func (d *derpProber) updateMap(ctx context.Context) error {\n }\n \n func (d *derpProber) ProbeUDP(ipaddr string, port int) ProbeClass {\n+\tinitLabels := make(Labels)\n+\tip := net.ParseIP(ipaddr)\n+\n+\tif ip.To4() != nil {\n+\t\tinitLabels[\"address_family\"] = \"ipv4\"\n+\t} else if ip.To16() != nil { // Will return an IPv4 as 16 byte, so ensure the check for IPv4 precedes this\n+\t\tinitLabels[\"address_family\"] = \"ipv6\"\n+\t} else {\n+\t\tinitLabels[\"address_family\"] = \"unknown\"\n+\t}\n+\n \treturn ProbeClass{\n \t\tProbe: func(ctx context.Context) error {\n \t\t\treturn derpProbeUDP(ctx, ipaddr, port)\n \t\t},\n-\t\tClass: \"derp_udp\",\n+\t\tClass:  \"derp_udp\",\n+\t\tLabels: initLabels,\n \t}\n }\n \n---\nprober/prober.go\n@@ -404,10 +404,14 @@ func (p *Probe) recordEndLocked(err error) {\n \t\tp.mSeconds.WithLabelValues(\"ok\").Add(latency.Seconds())\n \t\tp.latencyHist.Value = latency\n \t\tp.latencyHist = p.latencyHist.Next()\n+\t\tp.mAttempts.WithLabelValues(\"fail\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"fail\").Add(0)\n \t} else {\n \t\tp.latency = 0\n \t\tp.mAttempts.WithLabelValues(\"fail\").Inc()\n \t\tp.mSeconds.WithLabelValues(\"fail\").Add(latency.Seconds())\n+\t\tp.mAttempts.WithLabelValues(\"ok\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"ok\").Add(0)\n \t}\n \tp.successHist.Value = p.succeeded\n \tp.successHist = p.successHist.Next()\n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/init@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/autobuild@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/analyze@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n---\n\n\n---\n\nChoice D:\n.github/workflows/installer.yml\n@@ -1,6 +1,8 @@\n name: test installer.sh\n \n on:\n+  schedule:\n+    - cron: '0 15 * * *' # 10am EST (UTC-4/5)\n   push:\n     branches:\n       - \"main\"\n@@ -72,10 +74,10 @@ jobs:\n       # tar and gzip are needed by the actions/checkout below.\n       run: yum install -y --allowerasing tar gzip ${{ matrix.deps }}\n       if: |\n-        contains(matrix.image, 'centos')\n-        || contains(matrix.image, 'oraclelinux')\n-        || contains(matrix.image, 'fedora')\n-        || contains(matrix.image, 'amazonlinux')\n+        contains(matrix.image, 'centos') ||\n+        contains(matrix.image, 'oraclelinux') ||\n+        contains(matrix.image, 'fedora') ||\n+        contains(matrix.image, 'amazonlinux')\n     - name: install dependencies (zypper)\n       # tar and gzip are needed by the actions/checkout below.\n       run: zypper --non-interactive install tar gzip ${{ matrix.deps }}\n@@ -85,11 +87,11 @@ jobs:\n         apt-get update\n         apt-get install -y ${{ matrix.deps }}\n       if: |\n-        contains(matrix.image, 'debian')\n-        || contains(matrix.image, 'ubuntu')\n-        || contains(matrix.image, 'elementary')\n-        || contains(matrix.image, 'parrotsec')\n-        || contains(matrix.image, 'kalilinux')\n+        contains(matrix.image, 'debian') ||\n+        contains(matrix.image, 'ubuntu') ||\n+        contains(matrix.image, 'elementary') ||\n+        contains(matrix.image, 'parrotsec') ||\n+        contains(matrix.image, 'kalilinux')\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: run installer\n@@ -100,3 +102,30 @@ jobs:\n       continue-on-error: true\n     - name: check tailscale version\n       run: tailscale --version\n+  notify-slack:\n+    needs: test\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Notify Slack of failure on scheduled runs\n+        if: failure() && github.event_name == 'schedule'\n+        uses: slackapi/slack-github-action@485a9d42d3a73031f12ec201c457e2162c45d02d # v2.0.0\n+        with:\n+          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}\n+          webhook-type: incoming-webhook\n+          payload: |\n+            {\n+              \"attachments\": [{\n+                \"title\": \"Tailscale installer test failed\",\n+                \"title_link\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\n+                \"text\": \"One or more OSes in the test matrix failed. See the run for details.\",\n+                \"fields\": [\n+                  {\n+                    \"title\": \"Ref\",\n+                    \"value\": \"${{ github.ref_name }}\",\n+                    \"short\": true\n+                  }\n+                ],\n+                \"footer\": \"${{ github.workflow }} on schedule\",\n+                \"color\": \"danger\"\n+              }]\n+            }\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nPer suggestion from @sfllaw at https://github.com/tailscale/tailscale/pull/15576#issuecomment-2787386082\n\nUpdates #engdocs\n\n\n---\n\nChoice A:\ncmd/k8s-operator/ingress-for-pg.go\n@@ -1105,13 +1105,11 @@ func isErrorFeatureFlagNotEnabled(err error) bool {\n \t// Tailscale control plane when a Tailscale Service API call is made for a\n \t// tailnet that does not have the Tailscale Services feature flag enabled.\n \tconst messageFFNotEnabled = \"feature unavailable for tailnet\"\n-\tvar errResp *tailscale.ErrResponse\n-\tok := errors.As(err, &errResp)\n-\treturn ok && strings.Contains(errResp.Message, messageFFNotEnabled)\n+\treturn err != nil && strings.Contains(err.Error(), messageFFNotEnabled)\n }\n \n func isErrorTailscaleServiceNotFound(err error) bool {\n-\tvar errResp *tailscale.ErrResponse\n+\tvar errResp tailscale.ErrResponse\n \tok := errors.As(err, &errResp)\n \treturn ok && errResp.Status == http.StatusNotFound\n }\n---\ncmd/k8s-operator/svc-for-pg_test.go\n@@ -8,10 +8,8 @@ package main\n import (\n \t\"context\"\n \t\"encoding/json\"\n-\t\"errors\"\n \t\"fmt\"\n \t\"math/rand/v2\"\n-\t\"net/http\"\n \t\"net/netip\"\n \t\"testing\"\n \n@@ -23,7 +21,6 @@ import (\n \t\"k8s.io/client-go/tools/record\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n-\t\"tailscale.com/internal/client/tailscale\"\n \t\"tailscale.com/ipn/ipnstate\"\n \ttsoperator \"tailscale.com/k8s-operator\"\n \ttsapi \"tailscale.com/k8s-operator/apis/v1alpha1\"\n@@ -108,8 +105,7 @@ func TestServicePGReconciler_UpdateHostname(t *testing.T) {\n \tif err == nil {\n \t\tt.Fatalf(\"svc:default-%s not cleaned up\", svc.Name)\n \t}\n-\tvar errResp *tailscale.ErrResponse\n-\tif !errors.As(err, &errResp) || errResp.Status != http.StatusNotFound {\n+\tif !isErrorTailscaleServiceNotFound(err) {\n \t\tt.Fatalf(\"unexpected error: %v\", err)\n \t}\n }\n---\ncmd/k8s-operator/testutils_test.go\n@@ -901,11 +901,11 @@ func (c *fakeTSClient) GetVIPService(ctx context.Context, name tailcfg.ServiceNa\n \tc.Lock()\n \tdefer c.Unlock()\n \tif c.vipServices == nil {\n-\t\treturn nil, &tailscale.ErrResponse{Status: http.StatusNotFound}\n+\t\treturn nil, tailscale.ErrResponse{Status: http.StatusNotFound}\n \t}\n \tsvc, ok := c.vipServices[name]\n \tif !ok {\n-\t\treturn nil, &tailscale.ErrResponse{Status: http.StatusNotFound}\n+\t\treturn nil, tailscale.ErrResponse{Status: http.StatusNotFound}\n \t}\n \treturn svc, nil\n }\n---\n\n\n---\n\nChoice B:\n.github/workflows/installer.yml\n@@ -1,6 +1,8 @@\n name: test installer.sh\n \n on:\n+  schedule:\n+    - cron: '0 15 * * *' # 10am EST (UTC-4/5)\n   push:\n     branches:\n       - \"main\"\n@@ -72,10 +74,10 @@ jobs:\n       # tar and gzip are needed by the actions/checkout below.\n       run: yum install -y --allowerasing tar gzip ${{ matrix.deps }}\n       if: |\n-        contains(matrix.image, 'centos')\n-        || contains(matrix.image, 'oraclelinux')\n-        || contains(matrix.image, 'fedora')\n-        || contains(matrix.image, 'amazonlinux')\n+        contains(matrix.image, 'centos') ||\n+        contains(matrix.image, 'oraclelinux') ||\n+        contains(matrix.image, 'fedora') ||\n+        contains(matrix.image, 'amazonlinux')\n     - name: install dependencies (zypper)\n       # tar and gzip are needed by the actions/checkout below.\n       run: zypper --non-interactive install tar gzip ${{ matrix.deps }}\n@@ -85,11 +87,11 @@ jobs:\n         apt-get update\n         apt-get install -y ${{ matrix.deps }}\n       if: |\n-        contains(matrix.image, 'debian')\n-        || contains(matrix.image, 'ubuntu')\n-        || contains(matrix.image, 'elementary')\n-        || contains(matrix.image, 'parrotsec')\n-        || contains(matrix.image, 'kalilinux')\n+        contains(matrix.image, 'debian') ||\n+        contains(matrix.image, 'ubuntu') ||\n+        contains(matrix.image, 'elementary') ||\n+        contains(matrix.image, 'parrotsec') ||\n+        contains(matrix.image, 'kalilinux')\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: run installer\n@@ -100,3 +102,30 @@ jobs:\n       continue-on-error: true\n     - name: check tailscale version\n       run: tailscale --version\n+  notify-slack:\n+    needs: test\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Notify Slack of failure on scheduled runs\n+        if: failure() && github.event_name == 'schedule'\n+        uses: slackapi/slack-github-action@485a9d42d3a73031f12ec201c457e2162c45d02d # v2.0.0\n+        with:\n+          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}\n+          webhook-type: incoming-webhook\n+          payload: |\n+            {\n+              \"attachments\": [{\n+                \"title\": \"Tailscale installer test failed\",\n+                \"title_link\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\n+                \"text\": \"One or more OSes in the test matrix failed. See the run for details.\",\n+                \"fields\": [\n+                  {\n+                    \"title\": \"Ref\",\n+                    \"value\": \"${{ github.ref_name }}\",\n+                    \"short\": true\n+                  }\n+                ],\n+                \"footer\": \"${{ github.workflow }} on schedule\",\n+                \"color\": \"danger\"\n+              }]\n+            }\n---\n\n\n---\n\nChoice C:\n.github/CONTRIBUTING.md\n@@ -0,0 +1,17 @@\n+PRs welcome! But please file bugs first and explain the problem or\n+motivation. For new or changed functionality, strike up a discussion\n+and get agreement on the design/solution before spending too much time writing\n+code.\n+\n+Commit messages should [reference\n+bugs](https://docs.github.com/en/github/writing-on-github/autolinked-references-and-urls).\n+\n+We require [Developer Certificate of\n+Origin](https://en.wikipedia.org/wiki/Developer_Certificate_of_Origin) (DCO)\n+`Signed-off-by` lines in commits. (`git commit -s`)\n+\n+Please squash your code review edits & force push. Multiple commits in\n+a PR are fine, but only if they're each logically separate and all tests pass\n+at each stage. No fixup commits.\n+\n+See [commit-messages.md](docs/commit-messages.md) (or skim `git log`) for our commit message style.\n---\n\n\n---\n\nChoice D:\nclient/systray/logo.go\n@@ -11,10 +11,12 @@ import (\n \t\"image\"\n \t\"image/color\"\n \t\"image/png\"\n+\t\"runtime\"\n \t\"sync\"\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/fogleman/gg\"\n )\n \n@@ -251,7 +253,13 @@ func (logo tsLogo) renderWithBorder(borderUnits int) *bytes.Buffer {\n \t}\n \n \tb := bytes.NewBuffer(nil)\n-\tpng.Encode(b, dc.Image())\n+\n+\t// Encode as ICO format on Windows, PNG on all other platforms.\n+\tif runtime.GOOS == \"windows\" {\n+\t\t_ = ico.Encode(b, dc.Image())\n+\t} else {\n+\t\t_ = png.Encode(b, dc.Image())\n+\t}\n \treturn b\n }\n \n---\nclient/systray/systray.go\n@@ -7,9 +7,11 @@\n package systray\n \n import (\n+\t\"bytes\"\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"image\"\n \t\"io\"\n \t\"log\"\n \t\"net/http\"\n@@ -23,6 +25,7 @@ import (\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/atotto/clipboard\"\n \tdbus \"github.com/godbus/dbus/v5\"\n \t\"github.com/toqueteos/webbrowser\"\n@@ -330,6 +333,20 @@ func setRemoteIcon(menu *systray.MenuItem, urlStr string) {\n \t\tresp, err := http.Get(urlStr)\n \t\tif err == nil && resp.StatusCode == http.StatusOK {\n \t\t\tb, _ = io.ReadAll(resp.Body)\n+\n+\t\t\t// Convert image to ICO format on Windows\n+\t\t\tif runtime.GOOS == \"windows\" {\n+\t\t\t\tim, _, err := image.Decode(bytes.NewReader(b))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tbuf := bytes.NewBuffer(nil)\n+\t\t\t\tif err := ico.Encode(buf, im); err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tb = buf.Bytes()\n+\t\t\t}\n+\n \t\t\thttpCache[urlStr] = b\n \t\t\tresp.Body.Close()\n \t\t}\n---\ngo.mod\n@@ -4,7 +4,8 @@ go 1.24.0\n \n require (\n \tfilippo.io/mkcert v1.4.4\n-\tfyne.io/systray v1.11.0\n+\tfyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a\n+\tgithub.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9\n \tgithub.com/akutz/memconn v0.1.0\n \tgithub.com/alexbrainman/sspi v0.0.0-20231016080023-1a75b4708caa\n \tgithub.com/andybalholm/brotli v1.1.0\n@@ -100,7 +101,7 @@ require (\n \tgolang.org/x/net v0.36.0\n \tgolang.org/x/oauth2 v0.26.0\n \tgolang.org/x/sync v0.11.0\n-\tgolang.org/x/sys v0.30.0\n+\tgolang.org/x/sys v0.31.0\n \tgolang.org/x/term v0.29.0\n \tgolang.org/x/time v0.10.0\n \tgolang.org/x/tools v0.30.0\n---\ngo.sum\n@@ -41,8 +41,8 @@ filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\n filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\n filippo.io/mkcert v1.4.4 h1:8eVbbwfVlaqUM7OwuftKc2nuYOoTDQWqsoXmzoXZdbc=\n filippo.io/mkcert v1.4.4/go.mod h1:VyvOchVuAye3BoUsPUOOofKygVwLV2KQMVFJNRq+1dA=\n-fyne.io/systray v1.11.0 h1:D9HISlxSkx+jHSniMBR6fCFOUjk1x/OOOJLa9lJYAKg=\n-fyne.io/systray v1.11.0/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a h1:I8mEKo5sawHu8CqYf3FSjIl9b3puXasFVn2D/hrCneY=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n github.com/4meepo/tagalign v1.3.3 h1:ZsOxcwGD/jP4U/aw7qeWu58i7dwYemfy5Y+IF1ACoNw=\n github.com/4meepo/tagalign v1.3.3/go.mod h1:Q9c1rYMZJc9dPRkbQPpcBNCLEmY2njbAsXhQOZFE2dE=\n github.com/Abirdcfly/dupword v0.0.14 h1:3U4ulkc8EUo+CaT105/GJ1BQwtgyj6+VaBVbAX11Ba8=\n@@ -67,6 +67,8 @@ github.com/Djarvur/go-err113 v0.1.0 h1:uCRZZOdMQ0TZPHYTdYpoC0bLYJKPEHPUJ8MeAa51l\n github.com/Djarvur/go-err113 v0.1.0/go.mod h1:4UJr5HIiMZrwgkSPdsjy2uOQExX/WEILpIrO9UPGuXs=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0 h1:sATXp1x6/axKxz2Gjxv8MALP0bXaNRfQinEwyfMcx8c=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0/go.mod h1:Nl76DrGNJTA1KJ0LePKBw/vznBX1EHbAZX8mwjR82nI=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9 h1:1ltqoej5GtaWF8jaiA49HwsZD459jqm9YFz9ZtMFpQA=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9/go.mod h1:7uhhqiBaR4CpN0k9rMjOtjpcfGd6DG2m04zQxKnWQ0I=\n github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\n github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\n github.com/Masterminds/semver v1.5.0 h1:H65muMkzWKEuNDnfl9d70GUjFniHKHRbFPGBuZ3QEww=\n@@ -1218,8 +1220,8 @@ golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n-golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=\n-golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=\n+golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #8632\n\n\n---\n\nChoice A:\nipn/prefs.go\n@@ -607,9 +607,9 @@ func (p *Prefs) Equals(p2 *Prefs) bool {\n \t\tp.OperatorUser == p2.OperatorUser &&\n \t\tp.Hostname == p2.Hostname &&\n \t\tp.ForceDaemon == p2.ForceDaemon &&\n-\t\tcompareIPNets(p.AdvertiseRoutes, p2.AdvertiseRoutes) &&\n-\t\tcompareStrings(p.AdvertiseTags, p2.AdvertiseTags) &&\n-\t\tcompareStrings(p.AdvertiseServices, p2.AdvertiseServices) &&\n+\t\tslices.Equal(p.AdvertiseRoutes, p2.AdvertiseRoutes) &&\n+\t\tslices.Equal(p.AdvertiseTags, p2.AdvertiseTags) &&\n+\t\tslices.Equal(p.AdvertiseServices, p2.AdvertiseServices) &&\n \t\tp.Persist.Equals(p2.Persist) &&\n \t\tp.ProfileName == p2.ProfileName &&\n \t\tp.AutoUpdate.Equals(p2.AutoUpdate) &&\n@@ -636,30 +636,6 @@ func (ap AppConnectorPrefs) Pretty() string {\n \treturn \"\"\n }\n \n-func compareIPNets(a, b []netip.Prefix) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n-\tfor i := range a {\n-\t\tif a[i] != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-func compareStrings(a, b []string) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n-\tfor i := range a {\n-\t\tif a[i] != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n // NewPrefs returns the default preferences to use.\n func NewPrefs() *Prefs {\n \t// Provide default values for options which might be missing\n---\n\n\n---\n\nChoice B:\ncmd/tailscale/cli/netcheck.go\n@@ -55,7 +55,10 @@ func runNetcheck(ctx context.Context, args []string) error {\n \n \t// Ensure that we close the portmapper after running a netcheck; this\n \t// will release any port mappings created.\n-\tpm := portmapper.NewClient(logf, netMon, nil, nil, nil)\n+\tpm := portmapper.NewClient(portmapper.Config{\n+\t\tLogf:   logf,\n+\t\tNetMon: netMon,\n+\t})\n \tdefer pm.Close()\n \n \tc := &netcheck.Client{\n---\nipn/localapi/localapi.go\n@@ -818,19 +818,25 @@ func (h *Handler) serveDebugPortmap(w http.ResponseWriter, r *http.Request) {\n \tdone := make(chan bool, 1)\n \n \tvar c *portmapper.Client\n-\tc = portmapper.NewClient(logger.WithPrefix(logf, \"portmapper: \"), h.b.NetMon(), debugKnobs, h.b.ControlKnobs(), func() {\n-\t\tlogf(\"portmapping changed.\")\n-\t\tlogf(\"have mapping: %v\", c.HaveMapping())\n-\n-\t\tif ext, ok := c.GetCachedMappingOrStartCreatingOne(); ok {\n-\t\t\tlogf(\"cb: mapping: %v\", ext)\n-\t\t\tselect {\n-\t\t\tcase done <- true:\n-\t\t\tdefault:\n+\tc = portmapper.NewClient(portmapper.Config{\n+\t\tLogf:         logger.WithPrefix(logf, \"portmapper: \"),\n+\t\tNetMon:       h.b.NetMon(),\n+\t\tDebugKnobs:   debugKnobs,\n+\t\tControlKnobs: h.b.ControlKnobs(),\n+\t\tOnChange: func() {\n+\t\t\tlogf(\"portmapping changed.\")\n+\t\t\tlogf(\"have mapping: %v\", c.HaveMapping())\n+\n+\t\t\tif ext, ok := c.GetCachedMappingOrStartCreatingOne(); ok {\n+\t\t\t\tlogf(\"cb: mapping: %v\", ext)\n+\t\t\t\tselect {\n+\t\t\t\tcase done <- true:\n+\t\t\t\tdefault:\n+\t\t\t\t}\n+\t\t\t\treturn\n \t\t\t}\n-\t\t\treturn\n-\t\t}\n-\t\tlogf(\"cb: no mapping\")\n+\t\t\tlogf(\"cb: no mapping\")\n+\t\t},\n \t})\n \tdefer c.Close()\n \n---\nnet/portmapper/igd_test.go\n@@ -260,9 +260,14 @@ func (d *TestIGD) handlePCPQuery(pkt []byte, src netip.AddrPort) {\n \n func newTestClient(t *testing.T, igd *TestIGD) *Client {\n \tvar c *Client\n-\tc = NewClient(t.Logf, netmon.NewStatic(), nil, new(controlknobs.Knobs), func() {\n-\t\tt.Logf(\"port map changed\")\n-\t\tt.Logf(\"have mapping: %v\", c.HaveMapping())\n+\tc = NewClient(Config{\n+\t\tLogf:         t.Logf,\n+\t\tNetMon:       netmon.NewStatic(),\n+\t\tControlKnobs: new(controlknobs.Knobs),\n+\t\tOnChange: func() {\n+\t\t\tt.Logf(\"port map changed\")\n+\t\t\tt.Logf(\"have mapping: %v\", c.HaveMapping())\n+\t\t},\n \t})\n \tc.testPxPPort = igd.TestPxPPort()\n \tc.testUPnPPort = igd.TestUPnPPort()\n---\nnet/portmapper/portmapper.go\n@@ -201,32 +201,45 @@ func (m *pmpMapping) Release(ctx context.Context) {\n \tuc.WriteToUDPAddrPort(pkt, m.gw)\n }\n \n-// NewClient returns a new portmapping client.\n-//\n-// The netMon parameter is required.\n-//\n-// The debug argument allows configuring the behaviour of the portmapper for\n-// debugging; if nil, a sensible set of defaults will be used.\n-//\n-// The controlKnobs, if non-nil, specifies the control knobs from the control\n-// plane that might disable portmapping.\n-//\n-// The optional onChange argument specifies a func to run in a new goroutine\n-// whenever the port mapping status has changed. If nil, it doesn't make a\n-// callback.\n-func NewClient(logf logger.Logf, netMon *netmon.Monitor, debug *DebugKnobs, controlKnobs *controlknobs.Knobs, onChange func()) *Client {\n-\tif netMon == nil {\n+// Config carries the settings for a [Client].\n+type Config struct {\n+\t// Logf is called to generate text logs for the client. If nil, logger.Discard is used.\n+\tLogf logger.Logf\n+\n+\t// NetMon is the network monitor used by the client. It must be non-nil.\n+\tNetMon *netmon.Monitor\n+\n+\t// DebugKnobs, if non-nil, configure the behaviour of the portmapper for\n+\t// debugging.  If nil, a sensible set of defaults will be used.\n+\tDebugKnobs *DebugKnobs\n+\n+\t// ControlKnobs, if non-nil, specifies knobs from the control plane that\n+\t// might disable port mapping.\n+\tControlKnobs *controlknobs.Knobs\n+\n+\t// OnChange is called to run in a new goroutine whenever the port mapping\n+\t// status has changed. If nil, no callback is issued.\n+\tOnChange func()\n+}\n+\n+// NewClient constructs a new portmapping [Client] from c. It will panic if any\n+// required parameters are omitted.\n+func NewClient(c Config) *Client {\n+\tif c.NetMon == nil {\n \t\tpanic(\"nil netMon\")\n \t}\n \tret := &Client{\n-\t\tlogf:         logf,\n-\t\tnetMon:       netMon,\n+\t\tlogf:         c.Logf,\n+\t\tnetMon:       c.NetMon,\n \t\tipAndGateway: netmon.LikelyHomeRouterIP, // TODO(bradfitz): move this to method on netMon\n-\t\tonChange:     onChange,\n-\t\tcontrolKnobs: controlKnobs,\n+\t\tonChange:     c.OnChange,\n+\t\tcontrolKnobs: c.ControlKnobs,\n+\t}\n+\tif ret.logf == nil {\n+\t\tret.logf = logger.Discard\n \t}\n-\tif debug != nil {\n-\t\tret.debug = *debug\n+\tif c.DebugKnobs != nil {\n+\t\tret.debug = *c.DebugKnobs\n \t}\n \treturn ret\n }\n---\nnet/portmapper/portmapper_test.go\n@@ -18,7 +18,7 @@ func TestCreateOrGetMapping(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tc.SetLocalPort(1234)\n \tfor i := range 2 {\n@@ -34,7 +34,7 @@ func TestClientProbe(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tfor i := range 3 {\n \t\tif i > 0 {\n@@ -49,7 +49,7 @@ func TestClientProbeThenMap(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tc.debug.VerboseLogs = true\n \tc.SetLocalPort(1234)\n---\nwgengine/magicsock/magicsock.go\n@@ -544,7 +544,13 @@ func NewConn(opts Options) (*Conn, error) {\n \tportMapOpts := &portmapper.DebugKnobs{\n \t\tDisableAll: func() bool { return opts.DisablePortMapper || c.onlyTCP443.Load() },\n \t}\n-\tc.portMapper = portmapper.NewClient(portmapperLogf, opts.NetMon, portMapOpts, opts.ControlKnobs, c.onPortMapChanged)\n+\tc.portMapper = portmapper.NewClient(portmapper.Config{\n+\t\tLogf:         portmapperLogf,\n+\t\tNetMon:       opts.NetMon,\n+\t\tDebugKnobs:   portMapOpts,\n+\t\tControlKnobs: opts.ControlKnobs,\n+\t\tOnChange:     c.onPortMapChanged,\n+\t})\n \tc.portMapper.SetGatewayLookupFunc(opts.NetMon.GatewayAndSelfIP)\n \tc.netMon = opts.NetMon\n \tc.health = opts.HealthTracker\n---\n\n\n---\n\nChoice C:\ncmd/k8s-operator/deploy/crds/tailscale.com_connectors.yaml\n@@ -32,6 +32,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_dnsconfigs.yaml\n@@ -20,6 +20,9 @@ spec:\n           jsonPath: .status.nameserver.ip\n           name: NameserverIP\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -18,6 +18,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxygroups.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .spec.type\n           name: Type\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_recorders.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .status.devices[?(@.url != \"\")].url\n           name: URL\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -61,6 +61,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -312,6 +315,9 @@ spec:\n               jsonPath: .status.nameserver.ip\n               name: NameserverIP\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -492,6 +498,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -2803,6 +2812,9 @@ spec:\n               jsonPath: .spec.type\n               name: Type\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -3013,6 +3025,9 @@ spec:\n               jsonPath: .status.devices[?(@.url != \"\")].url\n               name: URL\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n---\nk8s-operator/apis/v1alpha1/types_connector.go\n@@ -24,6 +24,7 @@ var ConnectorKind = \"Connector\"\n // +kubebuilder:printcolumn:name=\"IsExitNode\",type=\"string\",JSONPath=`.status.isExitNode`,description=\"Whether this Connector instance defines an exit node.\"\n // +kubebuilder:printcolumn:name=\"IsAppConnector\",type=\"string\",JSONPath=`.status.isAppConnector`,description=\"Whether this Connector instance is an app connector.\"\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ConnectorReady\")].reason`,description=\"Status of the deployed Connector resources.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Connector defines a Tailscale node that will be deployed in the cluster. The\n // node can be configured to act as a Tailscale subnet router and/or a Tailscale\n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -16,6 +16,7 @@ var ProxyClassKind = \"ProxyClass\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyClassReady\")].reason`,description=\"Status of the ProxyClass.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyClass describes a set of configuration parameters that can be applied to\n // proxy resources created by the Tailscale Kubernetes operator.\n---\nk8s-operator/apis/v1alpha1/types_proxygroup.go\n@@ -14,6 +14,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=pg\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyGroupReady\")].reason`,description=\"Status of the deployed ProxyGroup resources.\"\n // +kubebuilder:printcolumn:name=\"Type\",type=\"string\",JSONPath=`.spec.type`,description=\"ProxyGroup type.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyGroup defines a set of Tailscale devices that will act as proxies.\n // Currently only egress ProxyGroups are supported.\n---\nk8s-operator/apis/v1alpha1/types_recorder.go\n@@ -15,6 +15,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=rec\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"RecorderReady\")].reason`,description=\"Status of the deployed Recorder resources.\"\n // +kubebuilder:printcolumn:name=\"URL\",type=\"string\",JSONPath=`.status.devices[?(@.url != \"\")].url`,description=\"URL on which the UI is exposed if enabled.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Recorder defines a tsrecorder device for recording SSH sessions. By default,\n // it will store recordings in a local ephemeral volume. If you want to persist\n---\nk8s-operator/apis/v1alpha1/types_tsdnsconfig.go\n@@ -18,6 +18,7 @@ var DNSConfigKind = \"DNSConfig\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster,shortName=dc\n // +kubebuilder:printcolumn:name=\"NameserverIP\",type=\"string\",JSONPath=`.status.nameserver.ip`,description=\"Service IP address of the nameserver\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // DNSConfig can be deployed to cluster to make a subset of Tailscale MagicDNS\n // names resolvable by cluster workloads. Use this if: A) you need to refer to\n---\n\n\n---\n\nChoice D:\ncontrol/controlhttp/client.go\n@@ -96,6 +96,9 @@ func (a *Dialer) httpsFallbackDelay() time.Duration {\n var _ = envknob.RegisterBool(\"TS_USE_CONTROL_DIAL_PLAN\") // to record at init time whether it's in use\n \n func (a *Dialer) dial(ctx context.Context) (*ClientConn, error) {\n+\n+\ta.logPort80Failure.Store(true)\n+\n \t// If we don't have a dial plan, just fall back to dialing the single\n \t// host we know about.\n \tuseDialPlan := envknob.BoolDefaultTrue(\"TS_USE_CONTROL_DIAL_PLAN\")\n@@ -278,7 +281,9 @@ func (d *Dialer) forceNoise443() bool {\n \t\t// This heuristic works around networks where port 80 is MITMed and\n \t\t// appears to work for a bit post-Upgrade but then gets closed,\n \t\t// such as seen in https://github.com/tailscale/tailscale/issues/13597.\n-\t\td.logf(\"controlhttp: forcing port 443 dial due to recent noise dial\")\n+\t\tif d.logPort80Failure.CompareAndSwap(true, false) {\n+\t\t\td.logf(\"controlhttp: forcing port 443 dial due to recent noise dial\")\n+\t\t}\n \t\treturn true\n \t}\n \n---\ncontrol/controlhttp/constants.go\n@@ -6,6 +6,7 @@ package controlhttp\n import (\n \t\"net/http\"\n \t\"net/url\"\n+\t\"sync/atomic\"\n \t\"time\"\n \n \t\"tailscale.com/health\"\n@@ -90,6 +91,11 @@ type Dialer struct {\n \n \tproxyFunc func(*http.Request) (*url.URL, error) // or nil\n \n+\t// logPort80Failure is whether we should log about port 80 interceptions\n+\t// and forcing a port 443 dial. We do this only once per \"dial\" method\n+\t// which can result in many concurrent racing dialHost calls.\n+\tlogPort80Failure atomic.Bool\n+\n \t// For tests only\n \tdrainFinished        chan struct{}\n \tomitCertErrorLogging bool\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nWhen we have an old cert that is being rotated, include it in the order. If we're in the ARI-recommended rotation window, LE should exclude us from rate limits. If we're not within that window, the order still succeeds, so there's no risk in including the old cert.\r\n\r\nFixes #15542\n\n---\n\nChoice A:\nipn/ipnext/ipnext.go\n@@ -114,7 +114,7 @@ func RegisterExtension(name string, newExt NewExtensionFn) {\n \t\tpanic(fmt.Sprintf(\"ipnext: newExt is nil: %q\", name))\n \t}\n \tif extensions.Contains(name) {\n-\t\tpanic(fmt.Sprintf(\"ipnext: duplicate extensions: %q\", name))\n+\t\tpanic(fmt.Sprintf(\"ipnext: duplicate extension name %q\", name))\n \t}\n \textensions.Set(name, &Definition{name, newExt})\n }\n---\nipn/ipnlocal/extension_host.go\n@@ -22,6 +22,7 @@ import (\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/execqueue\"\n+\t\"tailscale.com/util/mak\"\n \t\"tailscale.com/util/testenv\"\n )\n \n@@ -97,7 +98,8 @@ type ExtensionHost struct {\n \tinitialized atomic.Bool\n \t// activeExtensions is a subset of allExtensions that have been initialized and are ready to use.\n \tactiveExtensions []ipnext.Extension\n-\t// extensionsByName are the activeExtensions indexed by their names.\n+\t// extensionsByName are the extensions indexed by their names.\n+\t// They are not necessarily initialized (in activeExtensions) yet.\n \textensionsByName map[string]ipnext.Extension\n \t// postInitWorkQueue is a queue of functions to be executed\n \t// by the workQueue after all extensions have been initialized.\n@@ -184,6 +186,24 @@ func newExtensionHost(logf logger.Logf, b Backend, overrideExts ...*ipnext.Defin\n \t\t\treturn nil, fmt.Errorf(\"failed to create %q extension: %v\", d.Name(), err)\n \t\t}\n \t\thost.allExtensions = append(host.allExtensions, ext)\n+\n+\t\tif d.Name() != ext.Name() {\n+\t\t\treturn nil, fmt.Errorf(\"extension name %q does not match the registered name %q\", ext.Name(), d.Name())\n+\t\t}\n+\n+\t\tif _, ok := host.extensionsByName[ext.Name()]; ok {\n+\t\t\treturn nil, fmt.Errorf(\"duplicate extension name %q\", ext.Name())\n+\t\t} else {\n+\t\t\tmak.Set(&host.extensionsByName, ext.Name(), ext)\n+\t\t}\n+\n+\t\ttyp := reflect.TypeOf(ext)\n+\t\tif _, ok := host.extByType.Load(typ); ok {\n+\t\t\tif _, ok := ext.(interface{ PermitDoubleRegister() }); !ok {\n+\t\t\t\treturn nil, fmt.Errorf(\"duplicate extension type %T\", ext)\n+\t\t\t}\n+\t\t}\n+\t\thost.extByType.Store(typ, ext)\n \t}\n \treturn host, nil\n }\n@@ -215,10 +235,6 @@ func (h *ExtensionHost) init() {\n \tdefer h.initDone.Store(true)\n \n \t// Initialize the extensions in the order they were registered.\n-\th.mu.Lock()\n-\th.activeExtensions = make([]ipnext.Extension, 0, len(h.allExtensions))\n-\th.extensionsByName = make(map[string]ipnext.Extension, len(h.allExtensions))\n-\th.mu.Unlock()\n \tfor _, ext := range h.allExtensions {\n \t\t// Do not hold the lock while calling [ipnext.Extension.Init].\n \t\t// Extensions call back into the host to register their callbacks,\n@@ -240,8 +256,6 @@ func (h *ExtensionHost) init() {\n \t\t// We'd like to make them visible to other extensions that are initialized later.\n \t\th.mu.Lock()\n \t\th.activeExtensions = append(h.activeExtensions, ext)\n-\t\th.extensionsByName[ext.Name()] = ext\n-\t\th.extByType.Store(reflect.TypeOf(ext), ext)\n \t\th.mu.Unlock()\n \t}\n \n---\nipn/ipnlocal/extension_host_test.go\n@@ -30,6 +30,7 @@ import (\n \t\"tailscale.com/tstime\"\n \t\"tailscale.com/types/key\"\n \t\"tailscale.com/types/lazy\"\n+\t\"tailscale.com/types/logger\"\n \t\"tailscale.com/types/persist\"\n \t\"tailscale.com/util/must\"\n )\n@@ -1042,6 +1043,38 @@ func TestNilExtensionHostMethodCall(t *testing.T) {\n \t}\n }\n \n+// extBeforeStartExtension is a test extension used by TestGetExtBeforeStart.\n+// It is registered with the [ipnext.RegisterExtension].\n+type extBeforeStartExtension struct{}\n+\n+func init() {\n+\tipnext.RegisterExtension(\"ext-before-start\", mkExtBeforeStartExtension)\n+}\n+\n+func mkExtBeforeStartExtension(logger.Logf, ipnext.SafeBackend) (ipnext.Extension, error) {\n+\treturn extBeforeStartExtension{}, nil\n+}\n+\n+func (extBeforeStartExtension) Name() string { return \"ext-before-start\" }\n+func (extBeforeStartExtension) Init(ipnext.Host) error {\n+\treturn nil\n+}\n+func (extBeforeStartExtension) Shutdown() error {\n+\treturn nil\n+}\n+\n+// TestGetExtBeforeStart verifies that an extension registered via\n+// RegisterExtension can be retrieved with GetExt before the host is started\n+// (via LocalBackend.Start)\n+func TestGetExtBeforeStart(t *testing.T) {\n+\tlb := newTestBackend(t)\n+\t// Now call GetExt without calling Start on the LocalBackend.\n+\t_, ok := GetExt[extBeforeStartExtension](lb)\n+\tif !ok {\n+\t\tt.Fatal(\"didn't find extension\")\n+\t}\n+}\n+\n // checkMethodCallWithZeroArgs calls the method m on the receiver r\n // with zero values for all its arguments, except the receiver itself.\n // It returns the result of the method call, or fails the test if the call panics.\n@@ -1151,6 +1184,10 @@ type testExtension struct {\n \n var _ ipnext.Extension = (*testExtension)(nil)\n \n+// PermitDoubleRegister is a sentinel method whose existence tells the\n+// ExtensionHost to permit it to be registered multiple times.\n+func (*testExtension) PermitDoubleRegister() {}\n+\n func (e *testExtension) setT(t *testing.T) {\n \te.t = t\n }\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/cert.go\n@@ -484,14 +484,15 @@ var getCertPEM = func(ctx context.Context, b *LocalBackend, cs certStore, logf l\n \t// In case this method was triggered multiple times in parallel (when\n \t// serving incoming requests), check whether one of the other goroutines\n \t// already renewed the cert before us.\n-\tif p, err := getCertPEMCached(cs, domain, now); err == nil {\n+\tprevious, err := getCertPEMCached(cs, domain, now)\n+\tif err == nil {\n \t\t// shouldStartDomainRenewal caches its result so it's OK to call this\n \t\t// frequently.\n-\t\tshouldRenew, err := b.shouldStartDomainRenewal(cs, domain, now, p, minValidity)\n+\t\tshouldRenew, err := b.shouldStartDomainRenewal(cs, domain, now, previous, minValidity)\n \t\tif err != nil {\n \t\t\tlogf(\"error checking for certificate renewal: %v\", err)\n \t\t} else if !shouldRenew {\n-\t\t\treturn p, nil\n+\t\t\treturn previous, nil\n \t\t}\n \t} else if !errors.Is(err, ipn.ErrStateNotExist) && !errors.Is(err, errCertExpired) {\n \t\treturn nil, err\n@@ -536,7 +537,17 @@ var getCertPEM = func(ctx context.Context, b *LocalBackend, cs certStore, logf l\n \t\treturn nil, err\n \t}\n \n-\torder, err := ac.AuthorizeOrder(ctx, []acme.AuthzID{{Type: \"dns\", Value: domain}})\n+\t// If we have a previous cert, include it in the order. Assuming we're\n+\t// within the ARI renewal window this should exclude us from LE rate\n+\t// limits.\n+\tvar opts []acme.OrderOption\n+\tif previous != nil {\n+\t\tprevCrt, err := previous.parseCertificate()\n+\t\tif err == nil {\n+\t\t\topts = append(opts, acme.WithOrderReplacesCert(prevCrt))\n+\t\t}\n+\t}\n+\torder, err := ac.AuthorizeOrder(ctx, []acme.AuthzID{{Type: \"dns\", Value: domain}}, opts...)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n---\n\n\n---\n\nChoice C:\nsafesocket/safesocket.go\n@@ -61,7 +61,11 @@ func ConnectContext(ctx context.Context, path string) (net.Conn, error) {\n \t\t\tif ctx.Err() != nil {\n \t\t\t\treturn nil, ctx.Err()\n \t\t\t}\n-\t\t\ttime.Sleep(250 * time.Millisecond)\n+\t\t\tselect {\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\treturn nil, ctx.Err()\n+\t\t\tcase <-time.After(250 * time.Millisecond):\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\treturn c, err\n---\n\n\n---\n\nChoice D:\ncmd/tsidp/Dockerfile\n@@ -31,11 +31,11 @@ WORKDIR /app\n \n # Environment variables\n ENV TAILSCALE_USE_WIP_CODE=1 \\\n-    TS_HOSTNAME=tsidp \\\n+    TS_HOSTNAME=idp \\\n     TS_STATE_DIR=/var/lib/tsidp\n \n # Expose the default port\n EXPOSE 443\n \n # Run the application\n-ENTRYPOINT [\"/app/tsidp\"]\n\\ No newline at end of file\n+ENTRYPOINT [\"/bin/sh\", \"-c\", \"/app/tsidp --hostname=${TS_HOSTNAME} --dir=${TS_STATE_DIR}\"]\n---\ncmd/tsidp/README.md\n@@ -38,7 +38,7 @@\n      --name `tsidp` \\\n      -p 443:443 \\\n      -e TS_AUTHKEY=YOUR_TAILSCALE_AUTHKEY \\\n-     -e TS_HOSTNAME=tsidp \\\n+     -e TS_HOSTNAME=idp \\\n      -v tsidp-data:/var/lib/tsidp \\\n      tsidp:latest\n    ```\n@@ -48,7 +48,7 @@\n    docker logs tsidp\n    ```\n \n-   Visit `https://tsidp.tailnet.ts.net` to confirm the service is running.\n+   Visit `https://idp.tailnet.ts.net` to confirm the service is running.\n \n ## Usage Example: Proxmox Integration\n \n@@ -82,13 +82,14 @@ The `tsidp` server supports several command-line flags:\n - `--port`: Port to listen on (default: 443)\n - `--local-port`: Allow requests from localhost\n - `--use-local-tailscaled`: Use local tailscaled instead of tsnet\n+- `--hostname`: tsnet hostname\n - `--dir`: tsnet state directory\n \n ## Environment Variables\n \n - `TS_AUTHKEY`: Your Tailscale authentication key (required)\n-- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\")\n-- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\")\n+- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\", Docker only)\n+- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\", Docker only)\n - `TAILSCALE_USE_WIP_CODE`: Enable work-in-progress code (default: \"1\")\n \n ## Support\n@@ -97,4 +98,4 @@ This is an [experimental](https://tailscale.com/kb/1167/release-stages#experimen\n \n ## License\n \n-BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n\\ No newline at end of file\n+BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n---\ncmd/tsidp/tsidp.go\n@@ -65,6 +65,7 @@ var (\n \tflagLocalPort          = flag.Int(\"local-port\", -1, \"allow requests from localhost\")\n \tflagUseLocalTailscaled = flag.Bool(\"use-local-tailscaled\", false, \"use local tailscaled instead of tsnet\")\n \tflagFunnel             = flag.Bool(\"funnel\", false, \"use Tailscale Funnel to make tsidp available on the public internet\")\n+\tflagHostname           = flag.String(\"hostname\", \"idp\", \"tsnet hostname to use instead of idp\")\n \tflagDir                = flag.String(\"dir\", \"\", \"tsnet state directory; a default one will be created if not provided\")\n )\n \n@@ -121,7 +122,7 @@ func main() {\n \t\tdefer cleanup()\n \t} else {\n \t\tts := &tsnet.Server{\n-\t\t\tHostname: \"idp\",\n+\t\t\tHostname: *flagHostname,\n \t\t\tDir:      *flagDir,\n \t\t}\n \t\tif *flagVerbose {\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n\u2026fs field\r\n\r\nThis flag is currently no-op and hidden. The flag does round trip through the related pref. Subsequent commits will tie them to net/udprelay.Server. There is no corresponding \"tailscale up\" flag, enabling/disabling of the relay server will only be supported via \"tailscale set\".\r\n\r\nThis is a string flag in order to support disablement via empty string as a port value of 0 means \"enable the server and listen on a random unused port\". Disablement via empty string also follows existing flag convention, e.g. advertise-routes.\r\n\r\nEarly internal discussions settled on \"tailscale set --relay=\"<port>\", but the author felt this was too ambiguous around client vs server, and may cause confusion in the future if we add related flags.\r\n\r\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\ntool/gocross/gocross.go\n@@ -15,9 +15,9 @@ import (\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"runtime/debug\"\n \n \t\"tailscale.com/atomicfile\"\n-\t\"tailscale.com/version\"\n )\n \n func main() {\n@@ -28,8 +28,19 @@ func main() {\n \t\t// any time.\n \t\tswitch os.Args[1] {\n \t\tcase \"gocross-version\":\n-\t\t\tfmt.Println(version.GetMeta().GitCommit)\n-\t\t\tos.Exit(0)\n+\t\t\tbi, ok := debug.ReadBuildInfo()\n+\t\t\tif !ok {\n+\t\t\t\tfmt.Fprintln(os.Stderr, \"failed getting build info\")\n+\t\t\t\tos.Exit(1)\n+\t\t\t}\n+\t\t\tfor _, s := range bi.Settings {\n+\t\t\t\tif s.Key == \"vcs.revision\" {\n+\t\t\t\t\tfmt.Println(s.Value)\n+\t\t\t\t\tos.Exit(0)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfmt.Fprintln(os.Stderr, \"did not find vcs.revision in build info\")\n+\t\t\tos.Exit(1)\n \t\tcase \"is-gocross\":\n \t\t\t// This subcommand exits with an error code when called on a\n \t\t\t// regular go binary, so it can be used to detect when `go` is\n@@ -85,9 +96,9 @@ func main() {\n \t\tpath := filepath.Join(toolchain, \"bin\") + string(os.PathListSeparator) + os.Getenv(\"PATH\")\n \t\tenv.Set(\"PATH\", path)\n \n-\t\tdebug(\"Input: %s\\n\", formatArgv(os.Args))\n-\t\tdebug(\"Command: %s\\n\", formatArgv(newArgv))\n-\t\tdebug(\"Set the following flags/envvars:\\n%s\\n\", env.Diff())\n+\t\tdebugf(\"Input: %s\\n\", formatArgv(os.Args))\n+\t\tdebugf(\"Command: %s\\n\", formatArgv(newArgv))\n+\t\tdebugf(\"Set the following flags/envvars:\\n%s\\n\", env.Diff())\n \n \t\targs = newArgv\n \t\tif err := env.Apply(); err != nil {\n@@ -103,7 +114,7 @@ func main() {\n //go:embed gocross-wrapper.sh\n var wrapperScript []byte\n \n-func debug(format string, args ...any) {\n+func debugf(format string, args ...any) {\n \tdebug := os.Getenv(\"GOCROSS_DEBUG\")\n \tvar (\n \t\tout *os.File\n---\ntool/gocross/gocross_test.go\n@@ -0,0 +1,19 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package main\n+\n+import (\n+\t\"testing\"\n+\n+\t\"tailscale.com/tstest/deptest\"\n+)\n+\n+func TestDeps(t *testing.T) {\n+\tdeptest.DepChecker{\n+\t\tBadDeps: map[string]string{\n+\t\t\t\"tailscale.com/tailcfg\": \"circular dependency via go generate\",\n+\t\t\t\"tailscale.com/version\": \"circular dependency via go generate\",\n+\t\t},\n+\t}.Check(t)\n+}\n---\n\n\n---\n\nChoice B:\nipn/store/store_aws.go\n@@ -12,10 +12,6 @@ import (\n )\n \n func init() {\n-\tregisterAvailableExternalStores = append(registerAvailableExternalStores, registerAWSStore)\n-}\n-\n-func registerAWSStore() {\n \tRegister(\"arn:\", func(logf logger.Logf, arg string) (ipn.StateStore, error) {\n \t\tssmARN, opts, err := awsstore.ParseARNAndOpts(arg)\n \t\tif err != nil {\n---\nipn/store/store_kube.go\n@@ -14,10 +14,6 @@ import (\n )\n \n func init() {\n-\tregisterAvailableExternalStores = append(registerAvailableExternalStores, registerKubeStore)\n-}\n-\n-func registerKubeStore() {\n \tRegister(\"kube:\", func(logf logger.Logf, path string) (ipn.StateStore, error) {\n \t\tsecretName := strings.TrimPrefix(path, \"kube:\")\n \t\treturn kubestore.New(logf, secretName)\n---\nipn/store/stores.go\n@@ -26,16 +26,8 @@ import (\n // The arg is of the form \"prefix:rest\", where prefix was previously registered with Register.\n type Provider func(logf logger.Logf, arg string) (ipn.StateStore, error)\n \n-var regOnce sync.Once\n-\n-var registerAvailableExternalStores []func()\n-\n-func registerDefaultStores() {\n+func init() {\n \tRegister(\"mem:\", mem.New)\n-\n-\tfor _, f := range registerAvailableExternalStores {\n-\t\tf()\n-\t}\n }\n \n var knownStores map[string]Provider\n@@ -55,7 +47,6 @@ var knownStores map[string]Provider\n //     the suffix is a Kubernetes secret name\n //   - In all other cases, the path is treated as a filepath.\n func New(logf logger.Logf, path string) (ipn.StateStore, error) {\n-\tregOnce.Do(registerDefaultStores)\n \tfor prefix, sf := range knownStores {\n \t\tif strings.HasPrefix(path, prefix) {\n \t\t\t// We can't strip the prefix here as some NewStoreFunc (like arn:)\n---\nipn/store/stores_test.go\n@@ -4,6 +4,7 @@\n package store\n \n import (\n+\t\"maps\"\n \t\"path/filepath\"\n \t\"testing\"\n \n@@ -14,10 +15,9 @@ import (\n )\n \n func TestNewStore(t *testing.T) {\n-\tregOnce.Do(registerDefaultStores)\n+\toldKnownStores := maps.Clone(knownStores)\n \tt.Cleanup(func() {\n-\t\tknownStores = map[string]Provider{}\n-\t\tregisterDefaultStores()\n+\t\tknownStores = oldKnownStores\n \t})\n \tknownStores = map[string]Provider{}\n \n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/cert.go\n@@ -484,14 +484,15 @@ var getCertPEM = func(ctx context.Context, b *LocalBackend, cs certStore, logf l\n \t// In case this method was triggered multiple times in parallel (when\n \t// serving incoming requests), check whether one of the other goroutines\n \t// already renewed the cert before us.\n-\tif p, err := getCertPEMCached(cs, domain, now); err == nil {\n+\tprevious, err := getCertPEMCached(cs, domain, now)\n+\tif err == nil {\n \t\t// shouldStartDomainRenewal caches its result so it's OK to call this\n \t\t// frequently.\n-\t\tshouldRenew, err := b.shouldStartDomainRenewal(cs, domain, now, p, minValidity)\n+\t\tshouldRenew, err := b.shouldStartDomainRenewal(cs, domain, now, previous, minValidity)\n \t\tif err != nil {\n \t\t\tlogf(\"error checking for certificate renewal: %v\", err)\n \t\t} else if !shouldRenew {\n-\t\t\treturn p, nil\n+\t\t\treturn previous, nil\n \t\t}\n \t} else if !errors.Is(err, ipn.ErrStateNotExist) && !errors.Is(err, errCertExpired) {\n \t\treturn nil, err\n@@ -536,7 +537,17 @@ var getCertPEM = func(ctx context.Context, b *LocalBackend, cs certStore, logf l\n \t\treturn nil, err\n \t}\n \n-\torder, err := ac.AuthorizeOrder(ctx, []acme.AuthzID{{Type: \"dns\", Value: domain}})\n+\t// If we have a previous cert, include it in the order. Assuming we're\n+\t// within the ARI renewal window this should exclude us from LE rate\n+\t// limits.\n+\tvar opts []acme.OrderOption\n+\tif previous != nil {\n+\t\tprevCrt, err := previous.parseCertificate()\n+\t\tif err == nil {\n+\t\t\topts = append(opts, acme.WithOrderReplacesCert(prevCrt))\n+\t\t}\n+\t}\n+\torder, err := ac.AuthorizeOrder(ctx, []acme.AuthzID{{Type: \"dns\", Value: domain}}, opts...)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/set.go\n@@ -11,6 +11,7 @@ import (\n \t\"net/netip\"\n \t\"os/exec\"\n \t\"runtime\"\n+\t\"strconv\"\n \t\"strings\"\n \n \t\"github.com/peterbourgon/ff/v3/ffcli\"\n@@ -22,6 +23,7 @@ import (\n \t\"tailscale.com/net/tsaddr\"\n \t\"tailscale.com/safesocket\"\n \t\"tailscale.com/types/opt\"\n+\t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/version\"\n )\n@@ -62,6 +64,7 @@ type setArgsT struct {\n \tsnat                   bool\n \tstatefulFiltering      bool\n \tnetfilterMode          string\n+\trelayServerPort        string\n }\n \n func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n@@ -82,6 +85,7 @@ func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n \tsetf.BoolVar(&setArgs.updateApply, \"auto-update\", false, \"automatically update to the latest available version\")\n \tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, hidden+\"allow management plane to gather device posture information\")\n \tsetf.BoolVar(&setArgs.runWebClient, \"webclient\", false, \"expose the web interface for managing this node over Tailscale at port 5252\")\n+\tsetf.StringVar(&setArgs.relayServerPort, \"relay-server-port\", \"\", hidden+\"UDP port number (0 will pick a random unused port) for the relay server to bind to, on all interfaces, or empty string to disable relay server functionality\")\n \n \tffcomplete.Flag(setf, \"exit-node\", func(args []string) ([]string, ffcomplete.ShellCompDirective, error) {\n \t\tst, err := localClient.Status(context.Background())\n@@ -233,6 +237,15 @@ func runSet(ctx context.Context, args []string) (retErr error) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tif setArgs.relayServerPort != \"\" {\n+\t\tuport, err := strconv.ParseUint(setArgs.relayServerPort, 10, 16)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"failed to set relay server port: %v\", err)\n+\t\t}\n+\t\tmaskedPrefs.Prefs.RelayServerPort = ptr.To(int(uport))\n+\t}\n+\n \tcheckPrefs := curPrefs.Clone()\n \tcheckPrefs.ApplyEdits(maskedPrefs)\n \tif err := localClient.CheckPrefs(ctx, checkPrefs); err != nil {\n---\ncmd/tailscale/cli/up.go\n@@ -773,6 +773,7 @@ func init() {\n \taddPrefFlagMapping(\"auto-update\", \"AutoUpdate.Apply\")\n \taddPrefFlagMapping(\"advertise-connector\", \"AppConnector\")\n \taddPrefFlagMapping(\"posture-checking\", \"PostureChecking\")\n+\taddPrefFlagMapping(\"relay-server-port\", \"RelayServerPort\")\n }\n \n func addPrefFlagMapping(flagName string, prefNames ...string) {\n---\nipn/ipn_clone.go\n@@ -61,6 +61,9 @@ func (src *Prefs) Clone() *Prefs {\n \t\t\t}\n \t\t}\n \t}\n+\tif dst.RelayServerPort != nil {\n+\t\tdst.RelayServerPort = ptr.To(*src.RelayServerPort)\n+\t}\n \tdst.Persist = src.Persist.Clone()\n \treturn dst\n }\n@@ -96,6 +99,7 @@ var _PrefsCloneNeedsRegeneration = Prefs(struct {\n \tPostureChecking        bool\n \tNetfilterKind          string\n \tDriveShares            []*drive.Share\n+\tRelayServerPort        *int\n \tAllowSingleHosts       marshalAsTrueInJSON\n \tPersist                *persist.Persist\n }{})\n---\nipn/ipn_view.go\n@@ -166,6 +166,10 @@ func (v PrefsView) NetfilterKind() string                 { return v.\u0436.Netfilte\n func (v PrefsView) DriveShares() views.SliceView[*drive.Share, drive.ShareView] {\n \treturn views.SliceOfViews[*drive.Share, drive.ShareView](v.\u0436.DriveShares)\n }\n+func (v PrefsView) RelayServerPort() views.ValuePointer[int] {\n+\treturn views.ValuePointerOf(v.\u0436.RelayServerPort)\n+}\n+\n func (v PrefsView) AllowSingleHosts() marshalAsTrueInJSON { return v.\u0436.AllowSingleHosts }\n func (v PrefsView) Persist() persist.PersistView          { return v.\u0436.Persist.View() }\n \n@@ -200,6 +204,7 @@ var _PrefsViewNeedsRegeneration = Prefs(struct {\n \tPostureChecking        bool\n \tNetfilterKind          string\n \tDriveShares            []*drive.Share\n+\tRelayServerPort        *int\n \tAllowSingleHosts       marshalAsTrueInJSON\n \tPersist                *persist.Persist\n }{})\n---\nipn/prefs.go\n@@ -246,6 +246,14 @@ type Prefs struct {\n \t// by name.\n \tDriveShares []*drive.Share\n \n+\t// RelayServerPort is the UDP port number for the relay server to bind to,\n+\t// on all interfaces. A non-nil zero value signifies a random unused port\n+\t// should be used. A nil value signifies relay server functionality\n+\t// should be disabled. This field is currently experimental, and therefore\n+\t// no guarantees are made about its current naming and functionality when\n+\t// non-nil/enabled.\n+\tRelayServerPort *int `json:\",omitempty\"`\n+\n \t// AllowSingleHosts was a legacy field that was always true\n \t// for the past 4.5 years. It controlled whether Tailscale\n \t// peers got /32 or /127 routes for each other.\n@@ -337,6 +345,7 @@ type MaskedPrefs struct {\n \tPostureCheckingSet        bool                `json:\",omitempty\"`\n \tNetfilterKindSet          bool                `json:\",omitempty\"`\n \tDriveSharesSet            bool                `json:\",omitempty\"`\n+\tRelayServerPortSet        bool                `json:\",omitempty\"`\n }\n \n // SetsInternal reports whether mp has any of the Internal*Set field bools set\n@@ -555,6 +564,9 @@ func (p *Prefs) pretty(goos string) string {\n \t}\n \tsb.WriteString(p.AutoUpdate.Pretty())\n \tsb.WriteString(p.AppConnector.Pretty())\n+\tif p.RelayServerPort != nil {\n+\t\tfmt.Fprintf(&sb, \"relayServerPort=%d \", *p.RelayServerPort)\n+\t}\n \tif p.Persist != nil {\n \t\tsb.WriteString(p.Persist.Pretty())\n \t} else {\n@@ -616,7 +628,8 @@ func (p *Prefs) Equals(p2 *Prefs) bool {\n \t\tp.AppConnector == p2.AppConnector &&\n \t\tp.PostureChecking == p2.PostureChecking &&\n \t\tslices.EqualFunc(p.DriveShares, p2.DriveShares, drive.SharesEqual) &&\n-\t\tp.NetfilterKind == p2.NetfilterKind\n+\t\tp.NetfilterKind == p2.NetfilterKind &&\n+\t\tcompareIntPtrs(p.RelayServerPort, p2.RelayServerPort)\n }\n \n func (au AutoUpdatePrefs) Pretty() string {\n@@ -636,6 +649,16 @@ func (ap AppConnectorPrefs) Pretty() string {\n \treturn \"\"\n }\n \n+func compareIntPtrs(a, b *int) bool {\n+\tif (a == nil) != (b == nil) {\n+\t\treturn false\n+\t}\n+\tif a == nil {\n+\t\treturn true\n+\t}\n+\treturn *a == *b\n+}\n+\n // NewPrefs returns the default preferences to use.\n func NewPrefs() *Prefs {\n \t// Provide default values for options which might be missing\n---\nipn/prefs_test.go\n@@ -65,6 +65,7 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\"PostureChecking\",\n \t\t\"NetfilterKind\",\n \t\t\"DriveShares\",\n+\t\t\"RelayServerPort\",\n \t\t\"AllowSingleHosts\",\n \t\t\"Persist\",\n \t}\n@@ -73,6 +74,9 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\thave, prefsHandles)\n \t}\n \n+\trelayServerPort := func(port int) *int {\n+\t\treturn &port\n+\t}\n \tnets := func(strs ...string) (ns []netip.Prefix) {\n \t\tfor _, s := range strs {\n \t\t\tn, err := netip.ParsePrefix(s)\n@@ -341,6 +345,16 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\t&Prefs{AdvertiseServices: []string{\"svc:tux\", \"svc:amelie\"}},\n \t\t\tfalse,\n \t\t},\n+\t\t{\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(0)},\n+\t\t\t&Prefs{RelayServerPort: nil},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(0)},\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(1)},\n+\t\t\tfalse,\n+\t\t},\n \t}\n \tfor i, tt := range tests {\n \t\tgot := tt.a.Equals(tt.b)\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAdds a new diagram for ProxyGroups running in Ingress mode. Documentation is currently not publicly available, but a link needs adding once it is.\r\n\r\nUpdates tailscale/corp#24795\r\n\r\nChange-Id: I0d5dd6bf6f0e1b8b0becae848dc97d8b4bfb9ccb\n\n---\n\nChoice A:\ndocs/k8s/operator-architecture.md\n@@ -131,11 +131,11 @@ flowchart TD\n \n [Documentation][kb-operator-l7-ingress]\n \n-L7 ingress is relatively similar to L3 ingress. It is configured via an\n-`Ingress` object instead of a `Service`, and uses `tailscale serve` to accept\n-traffic instead of configuring `iptables` or `nftables` rules. Note that we use\n-tailscaled's local API (`SetServeConfig`) to set serve config, not the\n-`tailscale serve` command.\n+The L7 ingress architecture diagram is relatively similar to L3 ingress. It is\n+configured via an `Ingress` object instead of a `Service`, and uses\n+`tailscale serve` to accept traffic instead of configuring `iptables` or\n+`nftables` rules. Note that we use tailscaled's local API (`SetServeConfig`) to\n+set serve config, not the `tailscale serve` command.\n \n ```mermaid\n %%{ init: { 'theme':'neutral' } }%%\n@@ -159,6 +159,10 @@ flowchart TD\n             state-secret[\"state Secret\"]\n         end\n \n+        subgraph cluster-scope[Cluster scoped resources]\n+            ingress-class[Tailscale IngressClass]\n+        end\n+\n         subgraph defaultns[namespace=default]\n             ingress[tailscale Ingress]\n             svc[\"Service\"]\n@@ -260,6 +264,8 @@ flowchart TD\n \n ## `ProxyGroup`\n \n+### Egress\n+\n [Documentation][kb-operator-l3-egress-proxygroup]\n \n The `ProxyGroup` custom resource manages a collection of proxy Pods that\n@@ -278,8 +284,6 @@ ports via the ClusterIP Service and its EndpointSlice. The operator then\n generates the egress ConfigMap that tells the `ProxyGroup` Pods which incoming\n ports map to which egress targets.\n \n-`ProxyGroups` currently only support egress.\n-\n ```mermaid\n %%{ init: { 'theme':'neutral' } }%%\n \n@@ -364,6 +368,86 @@ flowchart LR\n \n ```\n \n+### Ingress\n+\n+A ProxyGroup can also serve as a highly available set of proxies for an\n+Ingress resource. The `-0` Pod is always the replica that will issue a certificate\n+from Let's Encrypt.\n+\n+If the same Ingress config is applied in multiple clusters, ProxyGroup proxies\n+from each cluster will be valid targets for the ts.net DNS name, and the proxy\n+each client is routed to will depend on the same rules as for [high availability][kb-ha]\n+subnet routers, and is encoded in the client's netmap.\n+\n+```mermaid\n+%%{ init: { 'theme':'neutral' } }%%\n+flowchart LR\n+    classDef tsnode color:#fff,fill:#000;\n+    classDef pod fill:#fff;\n+\n+    subgraph Key\n+        ts[Tailscale device]:::tsnode\n+        pod((Pod)):::pod\n+        blank[\" \"]-->|WireGuard traffic| blank2[\" \"]\n+        blank3[\" \"]-->|Other network traffic| blank4[\" \"]\n+    end\n+\n+    subgraph k8s[Kubernetes cluster]\n+        subgraph tailscale-ns[namespace=tailscale]\n+            operator((operator)):::tsnode\n+            ingress-sts[\"StatefulSet\"]\n+            serve-cm[serve config ConfigMap]\n+            ingress-0((\"pg-0 (dst)\")):::tsnode\n+            ingress-1((\"pg-1 (dst)\")):::tsnode\n+            tls-secret[myapp.tails.ts.net Secret]\n+        end\n+\n+        subgraph defaultns[namespace=default]\n+            ingress[myapp.tails.ts.net Ingress]\n+            svc[\"myapp Service\"]\n+            svc --> pod1((pod1))\n+            svc --> pod2((pod2))\n+        end\n+\n+        subgraph cluster[Cluster scoped resources]\n+            ingress-class[Tailscale IngressClass]\n+            pg[ProxyGroup 'pg']\n+        end\n+    end\n+\n+    control[\"Tailscale control plane\"]\n+    ts-svc[\"myapp Tailscale Service\"]\n+\n+    client[\"client (src)\"]:::tsnode -->|dials https\\://myapp.tails.ts.net/api| ingress-1\n+    ingress-0 -->|forwards traffic| svc\n+    ingress-1 -->|forwards traffic| svc\n+    control -.->|creates| ts-svc\n+    operator -.->|creates myapp Tailscale Service| control\n+    control -.->|netmap points myapp Tailscale Service to pg-1| client\n+    operator -.->|creates| ingress-sts\n+    ingress-sts -.->|manages| ingress-0\n+    ingress-sts -.->|manages| ingress-1\n+    ingress-0 -.->|issues myapp.tails.ts.net cert| le[Let's Encrypt]\n+    ingress-0 -.->|stores cert| tls-secret\n+    ingress-1 -.->|reads cert| tls-secret\n+    operator -.->|watches| ingress\n+    operator -.->|watches| pg\n+    operator -.->|creates| serve-cm\n+    serve-cm -.->|mounted| ingress-0\n+    serve-cm -.->|mounted| ingress-1\n+    ingress -.->|/api prefix| svc\n+\n+    linkStyle 0 stroke:red;\n+    linkStyle 4 stroke:red;\n+\n+    linkStyle 1 stroke:blue;\n+    linkStyle 2 stroke:blue;\n+    linkStyle 3 stroke:blue;\n+    linkStyle 5 stroke:blue;\n+    linkStyle 6 stroke:blue;\n+\n+```\n+\n ## Connector\n \n [Subnet router and exit node documentation][kb-operator-connector]\n@@ -514,4 +598,5 @@ flowchart TD\n [kb-operator-connector]: https://tailscale.com/kb/1441/kubernetes-operator-connector\n [kb-operator-app-connector]: https://tailscale.com/kb/1517/kubernetes-operator-app-connector\n [kb-operator-recorder]: https://tailscale.com/kb/1484/kubernetes-operator-deploying-tsrecorder\n+[kb-ha]: https://tailscale.com/kb/1115/high-availability\n [k8s-impersonation]: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation\n---\n\n\n---\n\nChoice B:\ncmd/natc/natc.go\n@@ -94,18 +94,24 @@ func main() {\n \t\t}\n \t\tignoreDstTable.Insert(pfx, true)\n \t}\n-\tvar v4Prefixes []netip.Prefix\n+\tvar (\n+\t\tv4Prefixes    []netip.Prefix\n+\t\tnumV4DNSAddrs int\n+\t)\n \tfor _, s := range strings.Split(*v4PfxStr, \",\") {\n \t\tp := netip.MustParsePrefix(strings.TrimSpace(s))\n \t\tif p.Masked() != p {\n \t\t\tlog.Fatalf(\"v4 prefix %v is not a masked prefix\", p)\n \t\t}\n \t\tv4Prefixes = append(v4Prefixes, p)\n+\t\tnumIPs := 1 << (32 - p.Bits())\n+\t\tnumV4DNSAddrs += numIPs\n \t}\n \tif len(v4Prefixes) == 0 {\n \t\tlog.Fatalf(\"no v4 prefixes specified\")\n \t}\n \tdnsAddr := v4Prefixes[0].Addr()\n+\tnumV4DNSAddrs -= 1 // Subtract the dnsAddr allocated above.\n \tts := &tsnet.Server{\n \t\tHostname: *hostname,\n \t}\n@@ -153,12 +159,13 @@ func main() {\n \t}\n \n \tc := &connector{\n-\t\tts:         ts,\n-\t\tlc:         lc,\n-\t\tdnsAddr:    dnsAddr,\n-\t\tv4Ranges:   v4Prefixes,\n-\t\tv6ULA:      ula(uint16(*siteID)),\n-\t\tignoreDsts: ignoreDstTable,\n+\t\tts:            ts,\n+\t\tlc:            lc,\n+\t\tdnsAddr:       dnsAddr,\n+\t\tv4Ranges:      v4Prefixes,\n+\t\tnumV4DNSAddrs: numV4DNSAddrs,\n+\t\tv6ULA:         ula(uint16(*siteID)),\n+\t\tignoreDsts:    ignoreDstTable,\n \t}\n \tc.run(ctx)\n }\n@@ -177,6 +184,11 @@ type connector struct {\n \t// v4Ranges is the list of IPv4 ranges to advertise and assign addresses from.\n \t// These are masked prefixes.\n \tv4Ranges []netip.Prefix\n+\n+\t// numV4DNSAddrs is the total size of the IPv4 ranges in addresses, minus the\n+\t// dnsAddr allocation.\n+\tnumV4DNSAddrs int\n+\n \t// v6ULA is the ULA prefix used by the app connector to assign IPv6 addresses.\n \tv6ULA netip.Prefix\n \n@@ -502,6 +514,7 @@ type perPeerState struct {\n \tmu           sync.Mutex\n \tdomainToAddr map[string][]netip.Addr\n \taddrToDomain *bart.Table[string]\n+\tnumV4Allocs  int\n }\n \n // domainForIP returns the domain name assigned to the given IP address and\n@@ -547,17 +560,25 @@ func (ps *perPeerState) isIPUsedLocked(ip netip.Addr) bool {\n \n // unusedIPv4Locked returns an unused IPv4 address from the available ranges.\n func (ps *perPeerState) unusedIPv4Locked() netip.Addr {\n+\t// All addresses have been allocated.\n+\tif ps.numV4Allocs >= ps.c.numV4DNSAddrs {\n+\t\treturn netip.Addr{}\n+\t}\n+\n \t// TODO: skip ranges that have been exhausted\n-\tfor _, r := range ps.c.v4Ranges {\n-\t\tip := randV4(r)\n-\t\tfor r.Contains(ip) {\n+\t// TODO: implement a much more efficient algorithm for finding unused IPs,\n+\t// this is fairly crazy.\n+\tfor {\n+\t\tfor _, r := range ps.c.v4Ranges {\n+\t\t\tip := randV4(r)\n+\t\t\tif !r.Contains(ip) {\n+\t\t\t\tpanic(\"error: randV4 returned invalid address\")\n+\t\t\t}\n \t\t\tif !ps.isIPUsedLocked(ip) && ip != ps.c.dnsAddr {\n \t\t\t\treturn ip\n \t\t\t}\n-\t\t\tip = ip.Next()\n \t\t}\n \t}\n-\treturn netip.Addr{}\n }\n \n // randV4 returns a random IPv4 address within the given prefix.\n@@ -583,6 +604,7 @@ func (ps *perPeerState) assignAddrsLocked(domain string) []netip.Addr {\n \tif !v4.IsValid() {\n \t\treturn nil\n \t}\n+\tps.numV4Allocs++\n \tas16 := ps.c.v6ULA.Addr().As16()\n \tas4 := v4.As4()\n \tcopy(as16[12:], as4[:])\n---\ncmd/natc/natc_test.go\n@@ -4,6 +4,8 @@\n package main\n \n import (\n+\t\"errors\"\n+\t\"fmt\"\n \t\"net/netip\"\n \t\"slices\"\n \t\"testing\"\n@@ -225,9 +227,10 @@ func TestDNSResponse(t *testing.T) {\n \n func TestPerPeerState(t *testing.T) {\n \tc := &connector{\n-\t\tv4Ranges: []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n-\t\tv6ULA:    netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n-\t\tdnsAddr:  netip.MustParseAddr(\"100.64.1.1\"),\n+\t\tv4Ranges:      []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n+\t\tv6ULA:         netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n+\t\tdnsAddr:       netip.MustParseAddr(\"100.64.1.0\"),\n+\t\tnumV4DNSAddrs: (1<<(32-24) - 1),\n \t}\n \n \tps := &perPeerState{c: c}\n@@ -328,9 +331,10 @@ func TestIgnoreDestination(t *testing.T) {\n \n func TestConnectorGenerateDNSResponse(t *testing.T) {\n \tc := &connector{\n-\t\tv4Ranges: []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n-\t\tv6ULA:    netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n-\t\tdnsAddr:  netip.MustParseAddr(\"100.64.1.1\"),\n+\t\tv4Ranges:      []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n+\t\tv6ULA:         netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n+\t\tdnsAddr:       netip.MustParseAddr(\"100.64.1.0\"),\n+\t\tnumV4DNSAddrs: (1<<(32-24) - 1),\n \t}\n \n \treq := &dnsmessage.Message{\n@@ -363,3 +367,63 @@ func TestConnectorGenerateDNSResponse(t *testing.T) {\n \t\tt.Errorf(\"generateDNSResponse() responses differ between calls\")\n \t}\n }\n+\n+func TestIPPoolExhaustion(t *testing.T) {\n+\tsmallPrefix := netip.MustParsePrefix(\"100.64.1.0/30\") // Only 4 IPs: .0, .1, .2, .3\n+\tc := &connector{\n+\t\tv6ULA:         netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n+\t\tv4Ranges:      []netip.Prefix{smallPrefix},\n+\t\tdnsAddr:       netip.MustParseAddr(\"100.64.1.0\"),\n+\t\tnumV4DNSAddrs: 3,\n+\t}\n+\n+\tps := &perPeerState{c: c}\n+\n+\tassignedIPs := make(map[netip.Addr]string)\n+\n+\tdomains := []string{\"a.example.com\", \"b.example.com\", \"c.example.com\", \"d.example.com\"}\n+\n+\tvar errs []error\n+\n+\tfor i := 0; i < 5; i++ {\n+\t\tfor _, domain := range domains {\n+\t\t\taddrs, err := ps.ipForDomain(domain)\n+\t\t\tif err != nil {\n+\t\t\t\terrs = append(errs, fmt.Errorf(\"failed to get IP for domain %q: %w\", domain, err))\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tfor _, addr := range addrs {\n+\t\t\t\tif d, ok := assignedIPs[addr]; ok {\n+\t\t\t\t\tif d != domain {\n+\t\t\t\t\t\tt.Errorf(\"IP %s reused for domain %q, previously assigned to %q\", addr, domain, d)\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tassignedIPs[addr] = domain\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor addr, domain := range assignedIPs {\n+\t\tif addr.Is4() && !smallPrefix.Contains(addr) {\n+\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, smallPrefix)\n+\t\t}\n+\t\tif addr.Is6() && !c.v6ULA.Contains(addr) {\n+\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, c.v6ULA)\n+\t\t}\n+\t\tif addr == c.dnsAddr {\n+\t\t\tt.Errorf(\"IP %s for domain %q is the reserved DNS address\", addr, domain)\n+\t\t}\n+\t}\n+\n+\t// expect one error for each iteration with the 4th domain\n+\tif len(errs) != 5 {\n+\t\tt.Errorf(\"Expected 5 errors, got %d: %v\", len(errs), errs)\n+\t}\n+\tfor _, err := range errs {\n+\t\tif !errors.Is(err, ErrNoIPsAvailable) {\n+\t\t\tt.Errorf(\"generateDNSResponse() error = %v, want ErrNoIPsAvailable\", err)\n+\t\t}\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\ncmd/tsidp/Dockerfile\n@@ -31,11 +31,11 @@ WORKDIR /app\n \n # Environment variables\n ENV TAILSCALE_USE_WIP_CODE=1 \\\n-    TS_HOSTNAME=tsidp \\\n+    TS_HOSTNAME=idp \\\n     TS_STATE_DIR=/var/lib/tsidp\n \n # Expose the default port\n EXPOSE 443\n \n # Run the application\n-ENTRYPOINT [\"/app/tsidp\"]\n\\ No newline at end of file\n+ENTRYPOINT [\"/bin/sh\", \"-c\", \"/app/tsidp --hostname=${TS_HOSTNAME} --dir=${TS_STATE_DIR}\"]\n---\ncmd/tsidp/README.md\n@@ -38,7 +38,7 @@\n      --name `tsidp` \\\n      -p 443:443 \\\n      -e TS_AUTHKEY=YOUR_TAILSCALE_AUTHKEY \\\n-     -e TS_HOSTNAME=tsidp \\\n+     -e TS_HOSTNAME=idp \\\n      -v tsidp-data:/var/lib/tsidp \\\n      tsidp:latest\n    ```\n@@ -48,7 +48,7 @@\n    docker logs tsidp\n    ```\n \n-   Visit `https://tsidp.tailnet.ts.net` to confirm the service is running.\n+   Visit `https://idp.tailnet.ts.net` to confirm the service is running.\n \n ## Usage Example: Proxmox Integration\n \n@@ -82,13 +82,14 @@ The `tsidp` server supports several command-line flags:\n - `--port`: Port to listen on (default: 443)\n - `--local-port`: Allow requests from localhost\n - `--use-local-tailscaled`: Use local tailscaled instead of tsnet\n+- `--hostname`: tsnet hostname\n - `--dir`: tsnet state directory\n \n ## Environment Variables\n \n - `TS_AUTHKEY`: Your Tailscale authentication key (required)\n-- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\")\n-- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\")\n+- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\", Docker only)\n+- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\", Docker only)\n - `TAILSCALE_USE_WIP_CODE`: Enable work-in-progress code (default: \"1\")\n \n ## Support\n@@ -97,4 +98,4 @@ This is an [experimental](https://tailscale.com/kb/1167/release-stages#experimen\n \n ## License\n \n-BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n\\ No newline at end of file\n+BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n---\ncmd/tsidp/tsidp.go\n@@ -65,6 +65,7 @@ var (\n \tflagLocalPort          = flag.Int(\"local-port\", -1, \"allow requests from localhost\")\n \tflagUseLocalTailscaled = flag.Bool(\"use-local-tailscaled\", false, \"use local tailscaled instead of tsnet\")\n \tflagFunnel             = flag.Bool(\"funnel\", false, \"use Tailscale Funnel to make tsidp available on the public internet\")\n+\tflagHostname           = flag.String(\"hostname\", \"idp\", \"tsnet hostname to use instead of idp\")\n \tflagDir                = flag.String(\"dir\", \"\", \"tsnet state directory; a default one will be created if not provided\")\n )\n \n@@ -121,7 +122,7 @@ func main() {\n \t\tdefer cleanup()\n \t} else {\n \t\tts := &tsnet.Server{\n-\t\t\tHostname: \"idp\",\n+\t\t\tHostname: *flagHostname,\n \t\t\tDir:      *flagDir,\n \t\t}\n \t\tif *flagVerbose {\n---\n\n\n---\n\nChoice D:\nrelease/dist/cli/cli.go\n@@ -65,6 +65,7 @@ func CLI(getTargets func() ([]dist.Target, error)) *ffcli.Command {\n \t\t\t\t\tfs.StringVar(&buildArgs.manifest, \"manifest\", \"\", \"manifest file to write\")\n \t\t\t\t\tfs.BoolVar(&buildArgs.verbose, \"verbose\", false, \"verbose logging\")\n \t\t\t\t\tfs.StringVar(&buildArgs.webClientRoot, \"web-client-root\", \"\", \"path to root of web client source to build\")\n+\t\t\t\t\tfs.StringVar(&buildArgs.outPath, \"out\", \"\", \"path to write output artifacts (defaults to '$PWD/dist' if not set)\")\n \t\t\t\t\treturn fs\n \t\t\t\t})(),\n \t\t\t\tLongHelp: strings.TrimSpace(`\n@@ -156,6 +157,7 @@ var buildArgs struct {\n \tmanifest      string\n \tverbose       bool\n \twebClientRoot string\n+\toutPath       string\n }\n \n func runBuild(ctx context.Context, filters []string, targets []dist.Target) error {\n@@ -172,7 +174,11 @@ func runBuild(ctx context.Context, filters []string, targets []dist.Target) erro\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting working directory: %w\", err)\n \t}\n-\tb, err := dist.NewBuild(wd, filepath.Join(wd, \"dist\"))\n+\toutPath := filepath.Join(wd, \"dist\")\n+\tif buildArgs.outPath != \"\" {\n+\t\toutPath = buildArgs.outPath\n+\t}\n+\tb, err := dist.NewBuild(wd, outPath)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"creating build context: %w\", err)\n \t}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis test exercises singleUseStringFlag behavior to ensure an error is returned when flags are set multiple times.\r\n\r\nUpdates #15534\n\n---\n\nChoice A:\nsafeweb/http.go\n@@ -376,6 +376,7 @@ func (s *Server) serveBrowser(w http.ResponseWriter, r *http.Request) {\n \tw.Header().Set(\"Content-Security-Policy\", s.csp)\n \tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n \tw.Header().Set(\"Referer-Policy\", \"same-origin\")\n+\tw.Header().Set(\"Cross-Origin-Opener-Policy\", \"same-origin\")\n \tif s.SecureContext {\n \t\tw.Header().Set(\"Strict-Transport-Security\", cmp.Or(s.StrictTransportSecurityOptions, DefaultStrictTransportSecurityOptions))\n \t}\n---\n\n\n---\n\nChoice B:\ncmd/tailscale/cli/cli_test.go\n@@ -1659,3 +1659,51 @@ func TestSingleUseStringFlag(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestSingleUseStringFlagsSetTwice(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tflagName string\n+\t\tvals     []string\n+\t\tsetup    func(*upArgsT) flag.Value\n+\t}{\n+\t\t{\n+\t\t\tname:     \"advertise-tags\",\n+\t\t\tflagName: \"advertise-tags\",\n+\t\t\tvals:     []string{\"tag:foo\", \"tag:bar\"},\n+\t\t\tsetup: func(u *upArgsT) flag.Value {\n+\t\t\t\treturn &u.advertiseTags\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"advertise-routes\",\n+\t\t\tflagName: \"advertise-routes\",\n+\t\t\tvals:     []string{\"10.0.0.0/8\", \"192.168.0.0/16\"},\n+\t\t\tsetup: func(u *upArgsT) flag.Value {\n+\t\t\t\treturn &u.advertiseRoutes\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tvar upArgs upArgsT\n+\t\t\tfs := flag.NewFlagSet(\"test\", flag.ContinueOnError)\n+\t\t\tfs.SetOutput(io.Discard)\n+\n+\t\t\tfs.Var(tt.setup(&upArgs), tt.flagName, \"\")\n+\t\t\targs := []string{\n+\t\t\t\tfmt.Sprintf(\"--%s=%s\", tt.flagName, tt.vals[0]),\n+\t\t\t\tfmt.Sprintf(\"--%s=%s\", tt.flagName, tt.vals[1]),\n+\t\t\t}\n+\n+\t\t\terr := fs.Parse(args)\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatal(\"expected error when setting flag twice, got nil\")\n+\t\t\t}\n+\t\t\tif !strings.Contains(err.Error(), \"flag can only be specified once\") {\n+\t\t\t\tt.Errorf(\"unexpected error message: %v\", err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\ncmd/tailscale/cli/debug.go\n@@ -136,6 +136,17 @@ func debugCmd() *ffcli.Command {\n \t\t\t\tExec:       runLocalCreds,\n \t\t\t\tShortHelp:  \"Print how to access Tailscale LocalAPI\",\n \t\t\t},\n+\t\t\t{\n+\t\t\t\tName:       \"localapi\",\n+\t\t\t\tShortUsage: \"tailscale debug localapi [<method>] <path> [<body| \\\"-\\\">]\",\n+\t\t\t\tExec:       runLocalAPI,\n+\t\t\t\tShortHelp:  \"Call a LocalAPI method directly\",\n+\t\t\t\tFlagSet: (func() *flag.FlagSet {\n+\t\t\t\t\tfs := newFlagSet(\"localapi\")\n+\t\t\t\t\tfs.BoolVar(&localAPIFlags.verbose, \"v\", false, \"verbose; dump HTTP headers\")\n+\t\t\t\t\treturn fs\n+\t\t\t\t})(),\n+\t\t\t},\n \t\t\t{\n \t\t\t\tName:       \"restun\",\n \t\t\t\tShortUsage: \"tailscale debug restun\",\n@@ -451,6 +462,81 @@ func runLocalCreds(ctx context.Context, args []string) error {\n \treturn nil\n }\n \n+func looksLikeHTTPMethod(s string) bool {\n+\tif len(s) > len(\"OPTIONS\") {\n+\t\treturn false\n+\t}\n+\tfor _, r := range s {\n+\t\tif r < 'A' || r > 'Z' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+var localAPIFlags struct {\n+\tverbose bool\n+}\n+\n+func runLocalAPI(ctx context.Context, args []string) error {\n+\tif len(args) == 0 {\n+\t\treturn errors.New(\"expected at least one argument\")\n+\t}\n+\tmethod := \"GET\"\n+\tif looksLikeHTTPMethod(args[0]) {\n+\t\tmethod = args[0]\n+\t\targs = args[1:]\n+\t\tif len(args) == 0 {\n+\t\t\treturn errors.New(\"expected at least one argument after method\")\n+\t\t}\n+\t}\n+\tpath := args[0]\n+\tif !strings.HasPrefix(path, \"/localapi/\") {\n+\t\tif !strings.Contains(path, \"/\") {\n+\t\t\tpath = \"/localapi/v0/\" + path\n+\t\t} else {\n+\t\t\tpath = \"/localapi/\" + path\n+\t\t}\n+\t}\n+\n+\tvar body io.Reader\n+\tif len(args) > 1 {\n+\t\tif args[1] == \"-\" {\n+\t\t\tfmt.Fprintf(Stderr, \"# reading request body from stdin...\\n\")\n+\t\t\tall, err := io.ReadAll(os.Stdin)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"reading Stdin: %q\", err)\n+\t\t\t}\n+\t\t\tbody = bytes.NewReader(all)\n+\t\t} else {\n+\t\t\tbody = strings.NewReader(args[1])\n+\t\t}\n+\t}\n+\treq, err := http.NewRequest(method, \"http://local-tailscaled.sock\"+path, body)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tfmt.Fprintf(Stderr, \"# doing request %s %s\\n\", method, path)\n+\n+\tres, err := localClient.DoLocalRequest(req)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tis2xx := res.StatusCode >= 200 && res.StatusCode <= 299\n+\tif localAPIFlags.verbose {\n+\t\tres.Write(Stdout)\n+\t} else {\n+\t\tif !is2xx {\n+\t\t\tfmt.Fprintf(Stderr, \"# Response status %s\\n\", res.Status)\n+\t\t}\n+\t\tio.Copy(Stdout, res.Body)\n+\t}\n+\tif is2xx {\n+\t\treturn nil\n+\t}\n+\treturn errors.New(res.Status)\n+}\n+\n type localClientRoundTripper struct{}\n \n func (localClientRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n---\n\n\n---\n\nChoice D:\nnet/dns/config.go\n@@ -10,6 +10,8 @@ import (\n \t\"net/netip\"\n \t\"sort\"\n \n+\t\"tailscale.com/control/controlknobs\"\n+\t\"tailscale.com/envknob\"\n \t\"tailscale.com/net/dns/publicdns\"\n \t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/tsaddr\"\n@@ -47,11 +49,28 @@ type Config struct {\n \tOnlyIPv6 bool\n }\n \n-func (c *Config) serviceIP() netip.Addr {\n+var magicDNSDualStack = envknob.RegisterBool(\"TS_DEBUG_MAGIC_DNS_DUAL_STACK\")\n+\n+// serviceIPs returns the list of service IPs where MagicDNS is reachable.\n+//\n+// The provided knobs may be nil.\n+func (c *Config) serviceIPs(knobs *controlknobs.Knobs) []netip.Addr {\n \tif c.OnlyIPv6 {\n-\t\treturn tsaddr.TailscaleServiceIPv6()\n+\t\treturn []netip.Addr{tsaddr.TailscaleServiceIPv6()}\n \t}\n-\treturn tsaddr.TailscaleServiceIP()\n+\n+\t// TODO(bradfitz,mikeodr,raggi): include IPv6 here too; tailscale/tailscale#15404\n+\t// And add a controlknobs knob to disable dual stack.\n+\t//\n+\t// For now, opt-in for testing.\n+\tif magicDNSDualStack() {\n+\t\treturn []netip.Addr{\n+\t\t\ttsaddr.TailscaleServiceIP(),\n+\t\t\ttsaddr.TailscaleServiceIPv6(),\n+\t\t}\n+\t}\n+\n+\treturn []netip.Addr{tsaddr.TailscaleServiceIP()}\n }\n \n // WriteToBufioWriter write a debug version of c for logs to w, omitting\n---\nnet/dns/manager.go\n@@ -307,7 +307,7 @@ func (m *Manager) compileConfig(cfg Config) (rcfg resolver.Config, ocfg OSConfig\n \t\t// through quad-100.\n \t\trcfg.Routes = routes\n \t\trcfg.Routes[\".\"] = cfg.DefaultResolvers\n-\t\tocfg.Nameservers = []netip.Addr{cfg.serviceIP()}\n+\t\tocfg.Nameservers = cfg.serviceIPs(m.knobs)\n \t\treturn rcfg, ocfg, nil\n \t}\n \n@@ -345,7 +345,7 @@ func (m *Manager) compileConfig(cfg Config) (rcfg resolver.Config, ocfg OSConfig\n \t// or routes + MagicDNS, or just MagicDNS, or on an OS that cannot\n \t// split-DNS. Install a split config pointing at quad-100.\n \trcfg.Routes = routes\n-\tocfg.Nameservers = []netip.Addr{cfg.serviceIP()}\n+\tocfg.Nameservers = cfg.serviceIPs(m.knobs)\n \n \tvar baseCfg *OSConfig // base config; non-nil if/when known\n \n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nDefault tags to `$TAGS` if set, so that people can choose arbitrary subsets of features.\r\n\r\nUpdates #12614\n\n---\n\nChoice A:\ncmd/tailscale/cli/set.go\n@@ -83,7 +83,7 @@ func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n \tsetf.BoolVar(&setArgs.advertiseConnector, \"advertise-connector\", false, \"offer to be an app connector for domain specific internet traffic for the tailnet\")\n \tsetf.BoolVar(&setArgs.updateCheck, \"update-check\", true, \"notify about available Tailscale updates\")\n \tsetf.BoolVar(&setArgs.updateApply, \"auto-update\", false, \"automatically update to the latest available version\")\n-\tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, hidden+\"allow management plane to gather device posture information\")\n+\tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, \"allow management plane to gather device posture information\")\n \tsetf.BoolVar(&setArgs.runWebClient, \"webclient\", false, \"expose the web interface for managing this node over Tailscale at port 5252\")\n \tsetf.StringVar(&setArgs.relayServerPort, \"relay-server-port\", \"\", hidden+\"UDP port number (0 will pick a random unused port) for the relay server to bind to, on all interfaces, or empty string to disable relay server functionality\")\n \n---\n\n\n---\n\nChoice B:\nhealth/health.go\n@@ -1054,13 +1054,18 @@ func (t *Tracker) stringsLocked() []string {\n \n \twarnLen := len(result)\n \tfor _, c := range t.controlMessages {\n+\t\tvar msg string\n \t\tif c.Title != \"\" && c.Text != \"\" {\n-\t\t\tresult = append(result, c.Title+\": \"+c.Text)\n+\t\t\tmsg = c.Title + \": \" + c.Text\n \t\t} else if c.Title != \"\" {\n-\t\t\tresult = append(result, c.Title)\n+\t\t\tmsg = c.Title + \".\"\n \t\t} else if c.Text != \"\" {\n-\t\t\tresult = append(result, c.Text)\n+\t\t\tmsg = c.Text\n \t\t}\n+\t\tif c.PrimaryAction != nil {\n+\t\t\tmsg = msg + \" \" + c.PrimaryAction.Label + \": \" + c.PrimaryAction.URL\n+\t\t}\n+\t\tresult = append(result, msg)\n \t}\n \tsort.Strings(result[warnLen:])\n \n---\nhealth/health_test.go\n@@ -467,29 +467,48 @@ func TestControlHealth(t *testing.T) {\n \tbaseWarns := ht.CurrentState().Warnings\n \tbaseStrs := ht.Strings()\n \n-\tht.SetControlHealth(map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n+\tmsgs := map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n \t\t\"control-health-test\": {\n \t\t\tTitle: \"Control health message\",\n-\t\t\tText:  \"Extra help\",\n+\t\t\tText:  \"Extra help.\",\n \t\t},\n \t\t\"control-health-title\": {\n \t\t\tTitle: \"Control health title only\",\n \t\t},\n-\t})\n+\t\t\"control-health-with-action\": {\n+\t\t\tTitle: \"Control health message\",\n+\t\t\tText:  \"Extra help.\",\n+\t\t\tPrimaryAction: &tailcfg.DisplayMessageAction{\n+\t\t\t\tURL:   \"http://www.example.com\",\n+\t\t\t\tLabel: \"Learn more\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\tht.SetControlHealth(msgs)\n \n \tt.Run(\"Warnings\", func(t *testing.T) {\n \t\twantWarns := map[WarnableCode]UnhealthyState{\n \t\t\t\"control-health-test\": {\n \t\t\t\tWarnableCode: \"control-health-test\",\n \t\t\t\tSeverity:     SeverityMedium,\n \t\t\t\tTitle:        \"Control health message\",\n-\t\t\t\tText:         \"Extra help\",\n+\t\t\t\tText:         \"Extra help.\",\n \t\t\t},\n \t\t\t\"control-health-title\": {\n \t\t\t\tWarnableCode: \"control-health-title\",\n \t\t\t\tSeverity:     SeverityMedium,\n \t\t\t\tTitle:        \"Control health title only\",\n \t\t\t},\n+\t\t\t\"control-health-with-action\": {\n+\t\t\t\tWarnableCode: \"control-health-with-action\",\n+\t\t\t\tSeverity:     SeverityMedium,\n+\t\t\t\tTitle:        \"Control health message\",\n+\t\t\t\tText:         \"Extra help.\",\n+\t\t\t\tPrimaryAction: &UnhealthyStateAction{\n+\t\t\t\t\tURL:   \"http://www.example.com\",\n+\t\t\t\t\tLabel: \"Learn more\",\n+\t\t\t\t},\n+\t\t\t},\n \t\t}\n \t\tstate := ht.CurrentState()\n \t\tgotWarns := maps.Clone(state.Warnings)\n@@ -505,8 +524,9 @@ func TestControlHealth(t *testing.T) {\n \n \tt.Run(\"Strings()\", func(t *testing.T) {\n \t\twantStrs := []string{\n-\t\t\t\"Control health message: Extra help\",\n-\t\t\t\"Control health title only\",\n+\t\t\t\"Control health message: Extra help.\",\n+\t\t\t\"Control health message: Extra help. Learn more: http://www.example.com\",\n+\t\t\t\"Control health title only.\",\n \t\t}\n \t\tvar gotStrs []string\n \t\tfor _, s := range ht.Strings() {\n@@ -527,8 +547,7 @@ func TestControlHealth(t *testing.T) {\n \t\t\tType: MetricLabelWarning,\n \t\t}).String()\n \t\twant := strconv.Itoa(\n-\t\t\t2 + // from SetControlHealth\n-\t\t\t\tlen(baseStrs),\n+\t\t\tlen(msgs) + len(baseStrs),\n \t\t)\n \t\tif got != want {\n \t\t\tt.Errorf(\"metricsHealthMessage.Get(warning) = %q, want %q\", got, want)\n---\n\n\n---\n\nChoice C:\nbuild_dist.sh\n@@ -28,18 +28,26 @@ EOF\n \texit 0\n fi\n \n-tags=\"\"\n+tags=\"${TAGS:-}\"\n ldflags=\"-X tailscale.com/version.longStamp=${VERSION_LONG} -X tailscale.com/version.shortStamp=${VERSION_SHORT}\"\n \n # build_dist.sh arguments must precede go build arguments.\n while [ \"$#\" -gt 1 ]; do\n \tcase \"$1\" in\n \t--extra-small)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --extra-small or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\tldflags=\"$ldflags -w -s\"\n \t\ttags=\"${tags:+$tags,}ts_omit_aws,ts_omit_bird,ts_omit_tap,ts_omit_kube,ts_omit_completion,ts_omit_ssh,ts_omit_wakeonlan,ts_omit_capture\"\n \t\t;;\n \t--box)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --box or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\ttags=\"${tags:+$tags,}ts_include_cli\"\n \t\t;;\n---\n\n\n---\n\nChoice D:\ncontrol/controlclient/map_test.go\n@@ -17,6 +17,7 @@ import (\n \t\"github.com/google/go-cmp/cmp\"\n \t\"go4.org/mem\"\n \t\"tailscale.com/control/controlknobs\"\n+\t\"tailscale.com/health\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/tstime\"\n@@ -1136,3 +1137,34 @@ func BenchmarkMapSessionDelta(b *testing.B) {\n \t\t})\n \t}\n }\n+\n+// TestNetmapHealthIntegration checks that we get the expected health warnings\n+// from processing a map response and passing the NetworkMap to a health tracker\n+func TestNetmapHealthIntegration(t *testing.T) {\n+\tms := newTestMapSession(t, nil)\n+\tht := health.Tracker{}\n+\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tnm := ms.netmapForResponse(&tailcfg.MapResponse{\n+\t\tHealth: []string{\"Test message\"},\n+\t})\n+\tht.SetControlHealth(nm.ControlHealth)\n+\n+\tstate := ht.CurrentState()\n+\twarning, ok := state.Warnings[\"control-health\"]\n+\n+\tif !ok {\n+\t\tt.Fatal(\"no warning found in current state with code 'control-health'\")\n+\t}\n+\tif got, want := warning.Title, \"Coordination server reports an issue\"; got != want {\n+\t\tt.Errorf(\"warning.Title = %q, want %q\", got, want)\n+\t}\n+\tif got, want := warning.Severity, health.SeverityMedium; got != want {\n+\t\tt.Errorf(\"warning.Severity = %s, want %s\", got, want)\n+\t}\n+\tif got, want := warning.Text, \"The coordination server is reporting an health issue: Test message\"; got != want {\n+\t\tt.Errorf(\"warning.Text = %q, want %q\", got, want)\n+\t}\n+}\n---\nhealth/health.go\n@@ -402,7 +402,7 @@ func (t *Tracker) setUnhealthyLocked(w *Warnable, args Args) {\n \t\t\t// executed immediately. Otherwise, the callback should be enqueued to run once the Warnable\n \t\t\t// becomes visible.\n \t\t\tif w.IsVisible(ws, t.now) {\n-\t\t\t\tgo cb(w, w.unhealthyState(ws))\n+\t\t\t\tcb(w, w.unhealthyState(ws))\n \t\t\t\tcontinue\n \t\t\t}\n \n@@ -415,7 +415,7 @@ func (t *Tracker) setUnhealthyLocked(w *Warnable, args Args) {\n \t\t\t\t// Check if the Warnable is still unhealthy, as it could have become healthy between the time\n \t\t\t\t// the timer was set for and the time it was executed.\n \t\t\t\tif t.warnableVal[w] != nil {\n-\t\t\t\t\tgo cb(w, w.unhealthyState(ws))\n+\t\t\t\t\tcb(w, w.unhealthyState(ws))\n \t\t\t\t\tdelete(t.pendingVisibleTimers, w)\n \t\t\t\t}\n \t\t\t})\n@@ -449,7 +449,7 @@ func (t *Tracker) setHealthyLocked(w *Warnable) {\n \t}\n \n \tfor _, cb := range t.watchers {\n-\t\tgo cb(w, nil)\n+\t\tcb(w, nil)\n \t}\n }\n \n@@ -483,6 +483,16 @@ func (t *Tracker) AppendWarnableDebugFlags(base []string) []string {\n // The provided callback function will be executed in its own goroutine. The returned function can be used\n // to unregister the callback.\n func (t *Tracker) RegisterWatcher(cb func(w *Warnable, r *UnhealthyState)) (unregister func()) {\n+\treturn t.registerSyncWatcher(func(w *Warnable, r *UnhealthyState) {\n+\t\tgo cb(w, r)\n+\t})\n+}\n+\n+// registerSyncWatcher adds a function that will be called whenever the health\n+// state of any Warnable changes. The provided callback function will be\n+// executed synchronously. Call RegisterWatcher to register any callbacks that\n+// won't return from execution immediately.\n+func (t *Tracker) registerSyncWatcher(cb func(w *Warnable, r *UnhealthyState)) (unregister func()) {\n \tif t.nil() {\n \t\treturn func() {}\n \t}\n---\nhealth/health_test.go\n@@ -451,3 +451,88 @@ func TestNoDERPHomeWarnableManual(t *testing.T) {\n \t\tt.Fatalf(\"got unexpected noDERPHomeWarnable warnable: %v\", ws)\n \t}\n }\n+\n+func TestControlHealth(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\tstate := ht.CurrentState()\n+\twarning, ok := state.Warnings[\"control-health\"]\n+\n+\tif !ok {\n+\t\tt.Fatal(\"no warning found in current state with code 'control-health'\")\n+\t}\n+\tif got, want := warning.Title, \"Coordination server reports an issue\"; got != want {\n+\t\tt.Errorf(\"warning.Title = %q, want %q\", got, want)\n+\t}\n+\tif got, want := warning.Severity, SeverityMedium; got != want {\n+\t\tt.Errorf(\"warning.Severity = %s, want %s\", got, want)\n+\t}\n+\tif got, want := warning.Text, \"The coordination server is reporting an health issue: Test message\"; got != want {\n+\t\tt.Errorf(\"warning.Text = %q, want %q\", got, want)\n+\t}\n+}\n+\n+func TestControlHealthNotifiesOnChange(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tif !gotNotified {\n+\t\tt.Errorf(\"watcher did not get called, want it to be called\")\n+\t}\n+}\n+\n+func TestControlHealthNoNotifyOnUnchanged(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\t// Set up an existing control health issue\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\t// Now register our watcher\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\t// Send the same control health message again - should not notify\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tif gotNotified {\n+\t\tt.Errorf(\"watcher got called, want it to not be called\")\n+\t}\n+}\n+\n+func TestControlHealthIgnoredOutsideMapPoll(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tstate := ht.CurrentState()\n+\t_, ok := state.Warnings[\"control-health\"]\n+\n+\tif ok {\n+\t\tt.Error(\"got a warning with code 'control-health', want none\")\n+\t}\n+\n+\tif gotNotified {\n+\t\tt.Error(\"watcher got called, want it to not be called\")\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #words\n\n\n---\n\nChoice A:\nipn/ipnlocal/drive.go\n@@ -4,6 +4,7 @@\n package ipnlocal\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"slices\"\n@@ -338,7 +339,7 @@ func (b *LocalBackend) driveRemotesFromPeers(nm *netmap.NetworkMap) []*drive.Rem\n \t\t\t\t// Check that the peer is allowed to share with us.\n \t\t\t\taddresses := peer.Addresses()\n \t\t\t\tfor _, p := range addresses.All() {\n-\t\t\t\t\tif cn.PeerHasCap(p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n+\t\t\t\t\tif cn.PeerHasCap(context.Background(), p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n---\nipn/ipnlocal/local.go\n@@ -96,6 +96,7 @@ import (\n \t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/util/clientmetric\"\n+\t\"tailscale.com/util/ctxkey\"\n \t\"tailscale.com/util/deephash\"\n \t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/goroutines\"\n@@ -1463,15 +1464,19 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+var nodeCtxLockedKey = ctxkey.New(\"localNodeContext-locked\", false)\n+\n+var ctxNodeContextLocked = nodeCtxLockedKey.WithValue(context.Background(), true)\n+\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(context.Context, tailcfg.NodeView) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tif pred(ctxNodeContextLocked, peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n@@ -6652,9 +6657,11 @@ func (b *LocalBackend) TestOnlyPublicKeys() (machineKey key.MachinePublic, nodeK\n \n // PeerHasCap reports whether the peer with the given Tailscale IP addresses\n // contains the given capability string, with any value(s).\n-func (b *localNodeContext) PeerHasCap(addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n-\tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n+func (b *localNodeContext) PeerHasCap(ctx context.Context, addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n+\tif !nodeCtxLockedKey.Value(ctx) {\n+\t\tb.mu.Lock()\n+\t\tdefer b.mu.Unlock()\n+\t}\n \treturn b.peerHasCapLocked(addr, wantCap)\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n+\tpeers := cn.AppendMatchingPeers(nil, func(ctx context.Context, p tailcfg.NodeView) bool {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n \t\tif self != p.User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(ctx, p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n@@ -241,7 +241,7 @@ func (b *LocalBackend) taildropTargetStatus(p tailcfg.NodeView) ipnstate.Taildro\n \t}\n \tif nm.User() != p.User() {\n \t\t// Different user must have the explicit file sharing target capability\n-\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(context.Background(), p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn ipnstate.TaildropTargetOwnedByOtherUser\n \t\t}\n---\n\n\n---\n\nChoice B:\nwords/scales.txt\n@@ -440,3 +440,5 @@ sidemirror\n wage\n salary\n fujita\n+caiman\n+cichlid\n---\nwords/tails.txt\n@@ -720,3 +720,5 @@ mining\n coat\n follow\n stalk\n+caudal\n+chronicle\n---\n\n\n---\n\nChoice C:\nnet/packet/packet.go\n@@ -51,10 +51,11 @@ type Parsed struct {\n \tIPVersion uint8\n \t// IPProto is the IP subprotocol (UDP, TCP, etc.). Valid iff IPVersion != 0.\n \tIPProto ipproto.Proto\n-\t// SrcIP4 is the source address. Family matches IPVersion. Port is\n-\t// valid iff IPProto == TCP || IPProto == UDP.\n+\t// Src is the source address. Family matches IPVersion. Port is\n+\t// valid iff IPProto == TCP || IPProto == UDP || IPProto == SCTP.\n \tSrc netip.AddrPort\n-\t// DstIP4 is the destination address. Family matches IPVersion.\n+\t// Dst is the destination address. Family matches IPVersion. Port is\n+\t// valid iff IPProto == TCP || IPProto == UDP || IPProto == SCTP.\n \tDst netip.AddrPort\n \t// TCPFlags is the packet's TCP flag bits. Valid iff IPProto == TCP.\n \tTCPFlags TCPFlag\n---\n\n\n---\n\nChoice D:\nutil/set/smallset.go\n@@ -0,0 +1,134 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package set\n+\n+import (\n+\t\"iter\"\n+\t\"maps\"\n+\n+\t\"tailscale.com/types/structs\"\n+)\n+\n+// SmallSet is a set that is optimized for reducing memory overhead when the\n+// expected size of the set is 0 or 1 elements.\n+//\n+// The zero value of SmallSet is a usable empty set.\n+//\n+// When storing a SmallSet in a map as a value type, it is important to re-assign\n+// the map entry after calling Add or Delete, as the SmallSet's representation\n+// may change.\n+//\n+// Copying a SmallSet by value may alias the previous value. Use the Clone method\n+// to create a new SmallSet with the same contents.\n+type SmallSet[T comparable] struct {\n+\t_   structs.Incomparable // to prevent == mistakes\n+\tone T                    // if non-zero, then single item in set\n+\tm   Set[T]               // if non-nil, the set of items, which might be size 1 if it's the zero value of T\n+}\n+\n+// Values returns an iterator over the elements of the set.\n+// The iterator will yield the elements in no particular order.\n+func (s SmallSet[T]) Values() iter.Seq[T] {\n+\tif s.m != nil {\n+\t\treturn maps.Keys(s.m)\n+\t}\n+\tvar zero T\n+\treturn func(yield func(T) bool) {\n+\t\tif s.one != zero {\n+\t\t\tyield(s.one)\n+\t\t}\n+\t}\n+}\n+\n+// Contains reports whether e is in the set.\n+func (s SmallSet[T]) Contains(e T) bool {\n+\tif s.m != nil {\n+\t\treturn s.m.Contains(e)\n+\t}\n+\tvar zero T\n+\treturn e != zero && s.one == e\n+}\n+\n+// Add adds e to the set.\n+//\n+// When storing a SmallSet in a map as a value type, it is important to\n+// re-assign the map entry after calling Add or Delete, as the SmallSet's\n+// representation may change.\n+func (s *SmallSet[T]) Add(e T) {\n+\tvar zero T\n+\tif s.m != nil {\n+\t\ts.m.Add(e)\n+\t\treturn\n+\t}\n+\t// Size zero to one non-zero element.\n+\tif s.one == zero && e != zero {\n+\t\ts.one = e\n+\t\treturn\n+\t}\n+\t// Need to make a multi map, either\n+\t// because we now have two items, or\n+\t// because e is the zero value.\n+\ts.m = Set[T]{}\n+\tif s.one != zero {\n+\t\ts.m.Add(s.one) // move single item to multi\n+\t}\n+\ts.m.Add(e) // add new item\n+\ts.one = zero\n+}\n+\n+// Len reports the number of elements in the set.\n+func (s SmallSet[T]) Len() int {\n+\tvar zero T\n+\tif s.m != nil {\n+\t\treturn s.m.Len()\n+\t}\n+\tif s.one != zero {\n+\t\treturn 1\n+\t}\n+\treturn 0\n+}\n+\n+// Delete removes e from the set.\n+//\n+// When storing a SmallSet in a map as a value type, it is important to\n+// re-assign the map entry after calling Add or Delete, as the SmallSet's\n+// representation may change.\n+func (s *SmallSet[T]) Delete(e T) {\n+\tvar zero T\n+\tif s.m == nil {\n+\t\tif s.one == e {\n+\t\t\ts.one = zero\n+\t\t}\n+\t\treturn\n+\t}\n+\ts.m.Delete(e)\n+\n+\t// If the map size drops to zero, that means\n+\t// it only contained the zero value of T.\n+\tif s.m.Len() == 0 {\n+\t\ts.m = nil\n+\t\treturn\n+\t}\n+\n+\t// If the map size drops to one element and doesn't\n+\t// contain the zero value, we can switch back to the\n+\t// single-item representation.\n+\tif s.m.Len() == 1 {\n+\t\tfor v := range s.m {\n+\t\t\tif v != zero {\n+\t\t\t\ts.one = v\n+\t\t\t\ts.m = nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// Clone returns a copy of s that doesn't alias the original.\n+func (s SmallSet[T]) Clone() SmallSet[T] {\n+\treturn SmallSet[T]{\n+\t\tone: s.one,\n+\t\tm:   maps.Clone(s.m), // preserves nilness\n+\t}\n+}\n---\nutil/set/smallset_test.go\n@@ -0,0 +1,91 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package set\n+\n+import (\n+\t\"fmt\"\n+\t\"iter\"\n+\t\"maps\"\n+\t\"reflect\"\n+\t\"slices\"\n+\t\"testing\"\n+)\n+\n+func TestSmallSet(t *testing.T) {\n+\tt.Parallel()\n+\n+\twantSize := reflect.TypeFor[int64]().Size() + reflect.TypeFor[map[int]struct{}]().Size()\n+\tif wantSize > 16 {\n+\t\tt.Errorf(\"wantSize should be no more than 16\") // it might be smaller on 32-bit systems\n+\t}\n+\tif size := reflect.TypeFor[SmallSet[int64]]().Size(); size != wantSize {\n+\t\tt.Errorf(\"SmallSet[int64] size is %d, want %v\", size, wantSize)\n+\t}\n+\n+\ttype op struct {\n+\t\tadd bool\n+\t\tv   int\n+\t}\n+\tops := iter.Seq[op](func(yield func(op) bool) {\n+\t\tfor _, add := range []bool{false, true} {\n+\t\t\tfor v := range 4 {\n+\t\t\t\tif !yield(op{add: add, v: v}) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t})\n+\ttype setLike interface {\n+\t\tAdd(int)\n+\t\tDelete(int)\n+\t}\n+\tapply := func(s setLike, o op) {\n+\t\tif o.add {\n+\t\t\ts.Add(o.v)\n+\t\t} else {\n+\t\t\ts.Delete(o.v)\n+\t\t}\n+\t}\n+\n+\t// For all combinations of 4 operations,\n+\t// apply them to both a regular map and SmallSet\n+\t// and make sure all the invariants hold.\n+\n+\tfor op1 := range ops {\n+\t\tfor op2 := range ops {\n+\t\t\tfor op3 := range ops {\n+\t\t\t\tfor op4 := range ops {\n+\n+\t\t\t\t\tnormal := Set[int]{}\n+\t\t\t\t\tsmall := &SmallSet[int]{}\n+\t\t\t\t\tfor _, op := range []op{op1, op2, op3, op4} {\n+\t\t\t\t\t\tapply(normal, op)\n+\t\t\t\t\t\tapply(small, op)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tname := func() string {\n+\t\t\t\t\t\treturn fmt.Sprintf(\"op1=%v, op2=%v, op3=%v, op4=%v\", op1, op2, op3, op4)\n+\t\t\t\t\t}\n+\t\t\t\t\tif normal.Len() != small.Len() {\n+\t\t\t\t\t\tt.Errorf(\"len mismatch after ops %s: normal=%d, small=%d\", name(), normal.Len(), small.Len())\n+\t\t\t\t\t}\n+\t\t\t\t\tif got := small.Clone().Len(); normal.Len() != got {\n+\t\t\t\t\t\tt.Errorf(\"len mismatch after ops %s: normal=%d, clone=%d\", name(), normal.Len(), got)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tnormalEle := slices.Sorted(maps.Keys(normal))\n+\t\t\t\t\tsmallEle := slices.Sorted(small.Values())\n+\t\t\t\t\tif !slices.Equal(normalEle, smallEle) {\n+\t\t\t\t\t\tt.Errorf(\"elements mismatch after ops %s: normal=%v, small=%v\", name(), normalEle, smallEle)\n+\t\t\t\t\t}\n+\t\t\t\t\tfor e := range 5 {\n+\t\t\t\t\t\tif normal.Contains(e) != small.Contains(e) {\n+\t\t\t\t\t\t\tt.Errorf(\"contains(%v) mismatch after ops %s: normal=%v, small=%v\", e, name(), normal.Contains(e), small.Contains(e))\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nMay fix #15579.\r\n\r\nThe issue, root cause and proposed solution are better described in the issue itself.\n\n---\n\nChoice A:\ncmd/tsidp/tsidp.go\n@@ -795,7 +795,7 @@ type oidcTokenResponse struct {\n \tIDToken      string `json:\"id_token\"`\n \tTokenType    string `json:\"token_type\"`\n \tAccessToken  string `json:\"access_token\"`\n-\tRefreshToken string `json:\"refresh_token\"`\n+\tRefreshToken string `json:\"refresh_token,omitempty\"`\n \tExpiresIn    int    `json:\"expires_in\"`\n }\n \n---\n\n\n---\n\nChoice B:\ndisco/disco.go\n@@ -25,6 +25,7 @@ import (\n \t\"fmt\"\n \t\"net\"\n \t\"net/netip\"\n+\t\"time\"\n \n \t\"go4.org/mem\"\n \t\"tailscale.com/types/key\"\n@@ -47,6 +48,7 @@ const (\n \tTypeBindUDPRelayEndpoint          = MessageType(0x04)\n \tTypeBindUDPRelayEndpointChallenge = MessageType(0x05)\n \tTypeBindUDPRelayEndpointAnswer    = MessageType(0x06)\n+\tTypeCallMeMaybeVia                = MessageType(0x07)\n )\n \n const v0 = byte(0)\n@@ -93,6 +95,8 @@ func Parse(p []byte) (Message, error) {\n \t\treturn parseBindUDPRelayEndpointChallenge(ver, p)\n \tcase TypeBindUDPRelayEndpointAnswer:\n \t\treturn parseBindUDPRelayEndpointAnswer(ver, p)\n+\tcase TypeCallMeMaybeVia:\n+\t\treturn parseCallMeMaybeVia(ver, p)\n \tdefault:\n \t\treturn nil, fmt.Errorf(\"unknown message type 0x%02x\", byte(t))\n \t}\n@@ -392,3 +396,94 @@ func parseBindUDPRelayEndpointAnswer(ver uint8, p []byte) (m *BindUDPRelayEndpoi\n \tcopy(m.Answer[:], p[:])\n \treturn m, nil\n }\n+\n+// CallMeMaybeVia is a message sent only over DERP to request that the recipient\n+// try to open up a magicsock path back to the sender. The 'Via' in\n+// CallMeMaybeVia highlights that candidate paths are served through an\n+// intermediate relay, likely a [tailscale.com/net/udprelay.Server].\n+//\n+// Usage of the candidate paths in magicsock requires a 3-way handshake\n+// involving [BindUDPRelayEndpoint], [BindUDPRelayEndpointChallenge], and\n+// [BindUDPRelayEndpointAnswer].\n+//\n+// CallMeMaybeVia mirrors [tailscale.com/net/udprelay.ServerEndpoint], which\n+// contains field documentation.\n+//\n+// The recipient may choose to not open a path back if it's already happy with\n+// its path. Direct connections, e.g. [CallMeMaybe]-signaled, take priority over\n+// CallMeMaybeVia paths.\n+//\n+// This message type is currently considered experimental and is not yet tied to\n+// a [tailscale.com/tailcfg.CapabilityVersion].\n+type CallMeMaybeVia struct {\n+\t// ServerDisco is [tailscale.com/net/udprelay.ServerEndpoint.ServerDisco]\n+\tServerDisco key.DiscoPublic\n+\t// LamportID is [tailscale.com/net/udprelay.ServerEndpoint.LamportID]\n+\tLamportID uint64\n+\t// VNI is [tailscale.com/net/udprelay.ServerEndpoint.VNI]\n+\tVNI uint32\n+\t// BindLifetime is [tailscale.com/net/udprelay.ServerEndpoint.BindLifetime]\n+\tBindLifetime time.Duration\n+\t// SteadyStateLifetime is [tailscale.com/net/udprelay.ServerEndpoint.SteadyStateLifetime]\n+\tSteadyStateLifetime time.Duration\n+\t// AddrPorts is [tailscale.com/net/udprelay.ServerEndpoint.AddrPorts]\n+\tAddrPorts []netip.AddrPort\n+}\n+\n+const cmmvDataLenMinusEndpoints = key.DiscoPublicRawLen + // ServerDisco\n+\t8 + // LamportID\n+\t4 + // VNI\n+\t8 + // BindLifetime\n+\t8 // SteadyStateLifetime\n+\n+func (m *CallMeMaybeVia) AppendMarshal(b []byte) []byte {\n+\tendpointsLen := epLength * len(m.AddrPorts)\n+\tret, p := appendMsgHeader(b, TypeCallMeMaybeVia, v0, cmmvDataLenMinusEndpoints+endpointsLen)\n+\tdisco := m.ServerDisco.AppendTo(nil)\n+\tcopy(p, disco)\n+\tp = p[key.DiscoPublicRawLen:]\n+\tbinary.BigEndian.PutUint64(p[:8], m.LamportID)\n+\tp = p[8:]\n+\tbinary.BigEndian.PutUint32(p[:4], m.VNI)\n+\tp = p[4:]\n+\tbinary.BigEndian.PutUint64(p[:8], uint64(m.BindLifetime))\n+\tp = p[8:]\n+\tbinary.BigEndian.PutUint64(p[:8], uint64(m.SteadyStateLifetime))\n+\tp = p[8:]\n+\tfor _, ipp := range m.AddrPorts {\n+\t\ta := ipp.Addr().As16()\n+\t\tcopy(p, a[:])\n+\t\tbinary.BigEndian.PutUint16(p[16:18], ipp.Port())\n+\t\tp = p[epLength:]\n+\t}\n+\treturn ret\n+}\n+\n+func parseCallMeMaybeVia(ver uint8, p []byte) (m *CallMeMaybeVia, err error) {\n+\tm = new(CallMeMaybeVia)\n+\tif len(p) < cmmvDataLenMinusEndpoints+epLength ||\n+\t\t(len(p)-cmmvDataLenMinusEndpoints)%epLength != 0 ||\n+\t\tver != 0 {\n+\t\treturn m, nil\n+\t}\n+\tm.ServerDisco = key.DiscoPublicFromRaw32(mem.B(p[:key.DiscoPublicRawLen]))\n+\tp = p[key.DiscoPublicRawLen:]\n+\tm.LamportID = binary.BigEndian.Uint64(p[:8])\n+\tp = p[8:]\n+\tm.VNI = binary.BigEndian.Uint32(p[:4])\n+\tp = p[4:]\n+\tm.BindLifetime = time.Duration(binary.BigEndian.Uint64(p[:8]))\n+\tp = p[8:]\n+\tm.SteadyStateLifetime = time.Duration(binary.BigEndian.Uint64(p[:8]))\n+\tp = p[8:]\n+\tm.AddrPorts = make([]netip.AddrPort, 0, len(p)-cmmvDataLenMinusEndpoints/epLength)\n+\tfor len(p) > 0 {\n+\t\tvar a [16]byte\n+\t\tcopy(a[:], p)\n+\t\tm.AddrPorts = append(m.AddrPorts, netip.AddrPortFrom(\n+\t\t\tnetip.AddrFrom16(a).Unmap(),\n+\t\t\tbinary.BigEndian.Uint16(p[16:18])))\n+\t\tp = p[epLength:]\n+\t}\n+\treturn m, nil\n+}\n---\ndisco/disco_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \n \t\"go4.org/mem\"\n \t\"tailscale.com/types/key\"\n@@ -106,6 +107,21 @@ func TestMarshalAndParse(t *testing.T) {\n \t\t\t},\n \t\t\twant: \"06 00 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f\",\n \t\t},\n+\t\t{\n+\t\t\tname: \"call_me_maybe_via\",\n+\t\t\tm: &CallMeMaybeVia{\n+\t\t\t\tServerDisco:         key.DiscoPublicFromRaw32(mem.B([]byte{1: 1, 2: 2, 30: 30, 31: 31})),\n+\t\t\t\tLamportID:           123,\n+\t\t\t\tVNI:                 456,\n+\t\t\t\tBindLifetime:        time.Second,\n+\t\t\t\tSteadyStateLifetime: time.Minute,\n+\t\t\t\tAddrPorts: []netip.AddrPort{\n+\t\t\t\t\tnetip.MustParseAddrPort(\"1.2.3.4:567\"),\n+\t\t\t\t\tnetip.MustParseAddrPort(\"[2001::3456]:789\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twant: \"07 00 00 01 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 1e 1f 00 00 00 00 00 00 00 7b 00 00 01 c8 00 00 00 00 3b 9a ca 00 00 00 00 0d f8 47 58 00 00 00 00 00 00 00 00 00 00 00 ff ff 01 02 03 04 02 37 20 01 00 00 00 00 00 00 00 00 00 00 00 00 34 56 03 15\",\n+\t\t},\n \t}\n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n---\n\n\n---\n\nChoice C:\nclient/systray/logo.go\n@@ -11,10 +11,12 @@ import (\n \t\"image\"\n \t\"image/color\"\n \t\"image/png\"\n+\t\"runtime\"\n \t\"sync\"\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/fogleman/gg\"\n )\n \n@@ -251,7 +253,13 @@ func (logo tsLogo) renderWithBorder(borderUnits int) *bytes.Buffer {\n \t}\n \n \tb := bytes.NewBuffer(nil)\n-\tpng.Encode(b, dc.Image())\n+\n+\t// Encode as ICO format on Windows, PNG on all other platforms.\n+\tif runtime.GOOS == \"windows\" {\n+\t\t_ = ico.Encode(b, dc.Image())\n+\t} else {\n+\t\t_ = png.Encode(b, dc.Image())\n+\t}\n \treturn b\n }\n \n---\nclient/systray/systray.go\n@@ -7,9 +7,11 @@\n package systray\n \n import (\n+\t\"bytes\"\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"image\"\n \t\"io\"\n \t\"log\"\n \t\"net/http\"\n@@ -23,6 +25,7 @@ import (\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/atotto/clipboard\"\n \tdbus \"github.com/godbus/dbus/v5\"\n \t\"github.com/toqueteos/webbrowser\"\n@@ -330,6 +333,20 @@ func setRemoteIcon(menu *systray.MenuItem, urlStr string) {\n \t\tresp, err := http.Get(urlStr)\n \t\tif err == nil && resp.StatusCode == http.StatusOK {\n \t\t\tb, _ = io.ReadAll(resp.Body)\n+\n+\t\t\t// Convert image to ICO format on Windows\n+\t\t\tif runtime.GOOS == \"windows\" {\n+\t\t\t\tim, _, err := image.Decode(bytes.NewReader(b))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tbuf := bytes.NewBuffer(nil)\n+\t\t\t\tif err := ico.Encode(buf, im); err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tb = buf.Bytes()\n+\t\t\t}\n+\n \t\t\thttpCache[urlStr] = b\n \t\t\tresp.Body.Close()\n \t\t}\n---\ngo.mod\n@@ -4,7 +4,8 @@ go 1.24.0\n \n require (\n \tfilippo.io/mkcert v1.4.4\n-\tfyne.io/systray v1.11.0\n+\tfyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a\n+\tgithub.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9\n \tgithub.com/akutz/memconn v0.1.0\n \tgithub.com/alexbrainman/sspi v0.0.0-20231016080023-1a75b4708caa\n \tgithub.com/andybalholm/brotli v1.1.0\n@@ -100,7 +101,7 @@ require (\n \tgolang.org/x/net v0.36.0\n \tgolang.org/x/oauth2 v0.26.0\n \tgolang.org/x/sync v0.11.0\n-\tgolang.org/x/sys v0.30.0\n+\tgolang.org/x/sys v0.31.0\n \tgolang.org/x/term v0.29.0\n \tgolang.org/x/time v0.10.0\n \tgolang.org/x/tools v0.30.0\n---\ngo.sum\n@@ -41,8 +41,8 @@ filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\n filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\n filippo.io/mkcert v1.4.4 h1:8eVbbwfVlaqUM7OwuftKc2nuYOoTDQWqsoXmzoXZdbc=\n filippo.io/mkcert v1.4.4/go.mod h1:VyvOchVuAye3BoUsPUOOofKygVwLV2KQMVFJNRq+1dA=\n-fyne.io/systray v1.11.0 h1:D9HISlxSkx+jHSniMBR6fCFOUjk1x/OOOJLa9lJYAKg=\n-fyne.io/systray v1.11.0/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a h1:I8mEKo5sawHu8CqYf3FSjIl9b3puXasFVn2D/hrCneY=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n github.com/4meepo/tagalign v1.3.3 h1:ZsOxcwGD/jP4U/aw7qeWu58i7dwYemfy5Y+IF1ACoNw=\n github.com/4meepo/tagalign v1.3.3/go.mod h1:Q9c1rYMZJc9dPRkbQPpcBNCLEmY2njbAsXhQOZFE2dE=\n github.com/Abirdcfly/dupword v0.0.14 h1:3U4ulkc8EUo+CaT105/GJ1BQwtgyj6+VaBVbAX11Ba8=\n@@ -67,6 +67,8 @@ github.com/Djarvur/go-err113 v0.1.0 h1:uCRZZOdMQ0TZPHYTdYpoC0bLYJKPEHPUJ8MeAa51l\n github.com/Djarvur/go-err113 v0.1.0/go.mod h1:4UJr5HIiMZrwgkSPdsjy2uOQExX/WEILpIrO9UPGuXs=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0 h1:sATXp1x6/axKxz2Gjxv8MALP0bXaNRfQinEwyfMcx8c=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0/go.mod h1:Nl76DrGNJTA1KJ0LePKBw/vznBX1EHbAZX8mwjR82nI=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9 h1:1ltqoej5GtaWF8jaiA49HwsZD459jqm9YFz9ZtMFpQA=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9/go.mod h1:7uhhqiBaR4CpN0k9rMjOtjpcfGd6DG2m04zQxKnWQ0I=\n github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\n github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\n github.com/Masterminds/semver v1.5.0 h1:H65muMkzWKEuNDnfl9d70GUjFniHKHRbFPGBuZ3QEww=\n@@ -1218,8 +1220,8 @@ golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n-golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=\n-golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=\n+golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n---\n\n\n---\n\nChoice D:\nipn/localapi/debugderp.go\n@@ -13,13 +13,15 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"strconv\"\n+\t\"strings\"\n \t\"time\"\n \n \t\"tailscale.com/derp/derphttp\"\n \t\"tailscale.com/ipn/ipnstate\"\n \t\"tailscale.com/net/netaddr\"\n \t\"tailscale.com/net/netns\"\n \t\"tailscale.com/net/stun\"\n+\t\"tailscale.com/net/tlsdial\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/types/key\"\n \t\"tailscale.com/types/nettype\"\n@@ -97,10 +99,22 @@ func (h *Handler) serveDebugDERPRegion(w http.ResponseWriter, r *http.Request) {\n \t\t} else {\n \t\t\tdefer conn.Close()\n \n+\t\t\ttlsConfig := tls.Config{\n+\t\t\t\tServerName: derpNode.HostName,\n+\t\t\t}\n+\t\t\tif derpNode.CertName != \"\" {\n+\t\t\t\t// If the CertName starts with \"sha256-raw:\", then the rest of the string is a hex-encoded SHA256 of the\n+\t\t\t\t// cert to expect. This is used for self-signed certs.\n+\t\t\t\t// See also: tailcfg/derpmap.go\n+\t\t\t\tif suf, ok := strings.CutPrefix(derpNode.CertName, \"sha256-raw:\"); ok {\n+\t\t\t\t\ttlsdial.SetConfigExpectedCertHash(&tlsConfig, suf)\n+\t\t\t\t} else {\n+\t\t\t\t\t// CertName is not a raw cert hash - and is not empty, it should be used.\n+\t\t\t\t\ttlsConfig.ServerName = derpNode.CertName\n+\t\t\t\t}\n+\t\t\t}\n \t\t\t// Upgrade to TLS and verify that works properly.\n-\t\t\ttlsConn := tls.Client(conn, &tls.Config{\n-\t\t\t\tServerName: cmp.Or(derpNode.CertName, derpNode.HostName),\n-\t\t\t})\n+\t\t\ttlsConn := tls.Client(conn, &tlsConfig)\n \t\t\tif err := tlsConn.HandshakeContext(ctx); err != nil {\n \t\t\t\tst.Errors = append(st.Errors, fmt.Sprintf(\"Error upgrading connection to node %q @ %q to TLS over IPv4: %v\", derpNode.HostName, addr, err))\n \t\t\t} else {\n@@ -116,13 +130,22 @@ func (h *Handler) serveDebugDERPRegion(w http.ResponseWriter, r *http.Request) {\n \t\t} else {\n \t\t\tdefer conn.Close()\n \n+\t\t\ttlsConfig := tls.Config{\n+\t\t\t\tServerName: derpNode.HostName,\n+\t\t\t}\n+\t\t\tif derpNode.CertName != \"\" {\n+\t\t\t\tif suf, ok := strings.CutPrefix(derpNode.CertName, \"sha256-raw:\"); ok {\n+\t\t\t\t\ttlsdial.SetConfigExpectedCertHash(&tlsConfig, suf)\n+\t\t\t\t} else {\n+\t\t\t\t\ttlsConfig.ServerName = derpNode.CertName\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// TODO(andrew-d): we should print more\n+\t\t\t// detailed failure information on if/why TLS\n+\t\t\t// verification fails\n+\n \t\t\t// Upgrade to TLS and verify that works properly.\n-\t\t\ttlsConn := tls.Client(conn, &tls.Config{\n-\t\t\t\tServerName: cmp.Or(derpNode.CertName, derpNode.HostName),\n-\t\t\t\t// TODO(andrew-d): we should print more\n-\t\t\t\t// detailed failure information on if/why TLS\n-\t\t\t\t// verification fails\n-\t\t\t})\n+\t\t\ttlsConn := tls.Client(conn, &tlsConfig)\n \t\t\tif err := tlsConn.HandshakeContext(ctx); err != nil {\n \t\t\t\tst.Errors = append(st.Errors, fmt.Sprintf(\"Error upgrading connection to node %q @ %q to TLS over IPv6: %v\", derpNode.HostName, addr, err))\n \t\t\t} else {\n---\nnet/tlsdial/tlsdial.go\n@@ -248,7 +248,7 @@ func SetConfigExpectedCert(c *tls.Config, certDNSName string) {\n }\n \n // SetConfigExpectedCertHash configures c's VerifyPeerCertificate function\n-// to require that exactly 1 cert is presented, and that the hex of its SHA256 hash\n+// to require that no more than 2 certs are presented, and that the hex of the first cert(the server's cert)'s SHA256 hash\n // is equal to wantFullCertSHA256Hex and that it's a valid cert for c.ServerName.\n func SetConfigExpectedCertHash(c *tls.Config, wantFullCertSHA256Hex string) {\n \tif c.VerifyPeerCertificate != nil {\n@@ -263,7 +263,10 @@ func SetConfigExpectedCertHash(c *tls.Config, wantFullCertSHA256Hex string) {\n \t\tif len(rawCerts) == 0 {\n \t\t\treturn errors.New(\"no certs presented\")\n \t\t}\n-\t\tif len(rawCerts) > 1 {\n+\t\t// There may be up to 2 certs: the server's cert (mandatory) and the Metacert (used in TLS1.3 and later, to save a rtt).\n+\t\t// Unfortunately the TLS connection is not established yet, so we can't check the TLS version here.\n+\t\t// Learn more about metacerts at `derp/derp_server.go/initMetacert`.\n+\t\tif len(rawCerts) > 2 {\n \t\t\treturn errors.New(\"unexpected multiple certs presented\")\n \t\t}\n \t\tif fmt.Sprintf(\"%02x\", sha256.Sum256(rawCerts[0])) != wantFullCertSHA256Hex {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #15015\r\n\r\nThis fixes building with `nix build` on latest code.\n\n---\n\nChoice A:\ncmd/containerboot/healthz.go\n@@ -47,10 +47,10 @@ func (h *healthz) update(healthy bool) {\n \th.hasAddrs = healthy\n }\n \n-// healthHandlers registers a simple health handler at /healthz.\n+// registerHealthHandlers registers a simple health handler at /healthz.\n // A containerized tailscale instance is considered healthy if\n // it has at least one tailnet IP address.\n-func healthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n+func registerHealthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n \th := &healthz{podIPv4: podIPv4}\n \tmux.Handle(\"GET /healthz\", h)\n \treturn h\n---\ncmd/containerboot/main.go\n@@ -195,18 +195,21 @@ func run() error {\n \t\treturn fmt.Errorf(\"failed to bring up tailscale: %w\", err)\n \t}\n \tkillTailscaled := func() {\n+\t\t// The default termination grace period for a Pod is 30s. We wait 25s at\n+\t\t// most so that we still reserve some of that budget for tailscaled\n+\t\t// to receive and react to a SIGTERM before the SIGKILL that k8s\n+\t\t// will send at the end of the grace period.\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)\n+\t\tdefer cancel()\n+\n+\t\tif err := ensureServicesNotAdvertised(ctx, client); err != nil {\n+\t\t\tlog.Printf(\"Error ensuring services are not advertised: %v\", err)\n+\t\t}\n+\n \t\tif hasKubeStateStore(cfg) {\n \t\t\t// Check we're not shutting tailscaled down while it's still writing\n \t\t\t// state. If we authenticate and fail to write all the state, we'll\n \t\t\t// never recover automatically.\n-\t\t\t//\n-\t\t\t// The default termination grace period for a Pod is 30s. We wait 25s at\n-\t\t\t// most so that we still reserve some of that budget for tailscaled\n-\t\t\t// to receive and react to a SIGTERM before the SIGKILL that k8s\n-\t\t\t// will send at the end of the grace period.\n-\t\t\tctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)\n-\t\t\tdefer cancel()\n-\n \t\t\tlog.Printf(\"Checking for consistent state\")\n \t\t\terr := kc.waitForConsistentState(ctx)\n \t\t\tif err != nil {\n@@ -226,7 +229,7 @@ func run() error {\n \t\tmux := http.NewServeMux()\n \n \t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.HealthCheckAddrPort)\n-\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \n \t\tclose := runHTTPServer(mux, cfg.HealthCheckAddrPort)\n \t\tdefer close()\n@@ -237,15 +240,16 @@ func run() error {\n \n \t\tif cfg.localMetricsEnabled() {\n \t\t\tlog.Printf(\"Running metrics endpoint at %s/metrics\", cfg.LocalAddrPort)\n-\t\t\tmetricsHandlers(mux, client, cfg.DebugAddrPort)\n+\t\t\tregisterMetricsHandlers(mux, client, cfg.DebugAddrPort)\n \t\t}\n \n \t\tif cfg.localHealthEnabled() {\n \t\t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.LocalAddrPort)\n-\t\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \t\t}\n-\t\tif cfg.EgressProxiesCfgPath != \"\" {\n-\t\t\tlog.Printf(\"Running preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n+\n+\t\tif cfg.egressSvcsTerminateEPEnabled() {\n+\t\t\tlog.Printf(\"Running egress preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n \t\t\tep.registerHandlers(mux)\n \t\t}\n \n---\ncmd/containerboot/metrics.go\n@@ -62,13 +62,13 @@ func (m *metrics) handleDebug(w http.ResponseWriter, r *http.Request) {\n \tproxy(w, r, debugURL, http.DefaultClient.Do)\n }\n \n-// metricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n+// registerMetricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n // requests to tailscaled's /localapi/v0/usermetrics API.\n //\n // In 1.78.x and 1.80.x, it also proxies debug paths to tailscaled's debug\n // endpoint if configured to ease migration for a breaking change serving user\n // metrics instead of debug metrics on the \"metrics\" port.\n-func metricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n+func registerMetricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n \tm := &metrics{\n \t\tlc:            lc,\n \t\tdebugEndpoint: debugAddrPort,\n---\ncmd/containerboot/serve.go\n@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"log\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -169,3 +170,46 @@ func readServeConfig(path, certDomain string) (*ipn.ServeConfig, error) {\n \t}\n \treturn &sc, nil\n }\n+\n+func ensureServicesNotAdvertised(ctx context.Context, lc *local.Client) error {\n+\tprefs, err := lc.GetPrefs(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"error getting prefs: %w\", err)\n+\t}\n+\tif len(prefs.AdvertiseServices) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tlog.Printf(\"serve proxy: unadvertising services: %v\", prefs.AdvertiseServices)\n+\tif _, err := lc.EditPrefs(ctx, &ipn.MaskedPrefs{\n+\t\tAdvertiseServicesSet: true,\n+\t\tPrefs: ipn.Prefs{\n+\t\t\tAdvertiseServices: nil,\n+\t\t},\n+\t}); err != nil {\n+\t\t// EditPrefs only returns an error if it fails _set_ its local prefs.\n+\t\t// If it fails to _persist_ the prefs in state, we don't get an error\n+\t\t// and we continue waiting below, as control will failover as usual.\n+\t\treturn fmt.Errorf(\"error setting prefs AdvertiseServices: %w\", err)\n+\t}\n+\n+\t// Services use the same (failover XOR regional routing) mechanism that\n+\t// HA subnet routers use. Unfortunately we don't yet get a reliable signal\n+\t// from control that it's responded to our unadvertisement, so the best we\n+\t// can do is wait for 20 seconds, where 15s is the approximate maximum time\n+\t// it should take for control to choose a new primary, and 5s is for buffer.\n+\t//\n+\t// Note: There is no guarantee that clients have been _informed_ of the new\n+\t// primary no matter how long we wait. We would need a mechanism to await\n+\t// netmap updates for peers to know for sure.\n+\t//\n+\t// See https://tailscale.com/kb/1115/high-availability for more details.\n+\t// TODO(tomhjp): Wait for a netmap update instead of sleeping when control\n+\t// supports that.\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\treturn nil\n+\tcase <-time.After(20 * time.Second):\n+\t\treturn nil\n+\t}\n+}\n---\ncmd/k8s-operator/proxygroup_specs.go\n@@ -197,6 +197,16 @@ func pgStatefulSet(pg *tsapi.ProxyGroup, namespace, image, tsFirewallMode string\n \t// This mechanism currently (2025-01-26) rely on the local health check being accessible on the Pod's\n \t// IP, so they are not supported for ProxyGroups where users have configured TS_LOCAL_ADDR_PORT to a custom\n \t// value.\n+\t//\n+\t// NB: For _Ingress_ ProxyGroups, we run shutdown logic within containerboot\n+\t// in reaction to a SIGTERM signal instead of using a pre-stop hook. This is\n+\t// because Ingress pods need to unadvertise services, and it's preferable to\n+\t// avoid triggering those side-effects from a GET request that would be\n+\t// accessible to the whole cluster network (in the absence of NetworkPolicy\n+\t// rules).\n+\t//\n+\t// TODO(tomhjp): add a readiness probe or gate to Ingress Pods. There is a\n+\t// small window where the Pod is marked ready but routing can still fail.\n \tif pg.Spec.Type == tsapi.ProxyGroupTypeEgress && !hasLocalAddrPortSet(proxyClass) {\n \t\tc.Lifecycle = &corev1.Lifecycle{\n \t\t\tPreStop: &corev1.LifecycleHandler{\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -2404,11 +2404,9 @@ func (b *LocalBackend) Start(opts ipn.Options) error {\n \t}\n \n \tvar auditLogShutdown func()\n-\t// Audit logging is only available if the client has set up a proper persistent\n-\t// store for the logs in sys.\n \tstore, ok := b.sys.AuditLogStore.GetOK()\n \tif !ok {\n-\t\tb.logf(\"auditlog: [unexpected] no persistent audit log storage configured.  using memory store.\")\n+\t\t// Use memory store by default if no explicit store is provided.\n \t\tstore = auditlog.NewLogStore(&memstore.Store{})\n \t}\n \n---\n\n\n---\n\nChoice C:\nutil/mak/mak.go\n@@ -5,11 +5,6 @@\n // things, notably to maps, but also slices.\n package mak\n \n-import (\n-\t\"fmt\"\n-\t\"reflect\"\n-)\n-\n // Set populates an entry in a map, making the map if necessary.\n //\n // That is, it assigns (*m)[k] = v, making *m if it was nil.\n@@ -20,35 +15,6 @@ func Set[K comparable, V any, T ~map[K]V](m *T, k K, v V) {\n \t(*m)[k] = v\n }\n \n-// NonNil takes a pointer to a Go data structure\n-// (currently only a slice or a map) and makes sure it's non-nil for\n-// JSON serialization. (In particular, JavaScript clients usually want\n-// the field to be defined after they decode the JSON.)\n-//\n-// Deprecated: use NonNilSliceForJSON or NonNilMapForJSON instead.\n-func NonNil(ptr any) {\n-\tif ptr == nil {\n-\t\tpanic(\"nil interface\")\n-\t}\n-\trv := reflect.ValueOf(ptr)\n-\tif rv.Kind() != reflect.Ptr {\n-\t\tpanic(fmt.Sprintf(\"kind %v, not Ptr\", rv.Kind()))\n-\t}\n-\tif rv.Pointer() == 0 {\n-\t\tpanic(\"nil pointer\")\n-\t}\n-\trv = rv.Elem()\n-\tif rv.Pointer() != 0 {\n-\t\treturn\n-\t}\n-\tswitch rv.Type().Kind() {\n-\tcase reflect.Slice:\n-\t\trv.Set(reflect.MakeSlice(rv.Type(), 0, 0))\n-\tcase reflect.Map:\n-\t\trv.Set(reflect.MakeMap(rv.Type()))\n-\t}\n-}\n-\n // NonNilSliceForJSON makes sure that *slicePtr is non-nil so it will\n // won't be omitted from JSON serialization and possibly confuse JavaScript\n // clients expecting it to be present.\n---\nutil/mak/mak_test.go\n@@ -40,35 +40,6 @@ func TestSet(t *testing.T) {\n \t})\n }\n \n-func TestNonNil(t *testing.T) {\n-\tvar s []string\n-\tNonNil(&s)\n-\tif len(s) != 0 {\n-\t\tt.Errorf(\"slice len = %d; want 0\", len(s))\n-\t}\n-\tif s == nil {\n-\t\tt.Error(\"slice still nil\")\n-\t}\n-\n-\ts = append(s, \"foo\")\n-\tNonNil(&s)\n-\tif len(s) != 1 {\n-\t\tt.Errorf(\"len = %d; want 1\", len(s))\n-\t}\n-\tif s[0] != \"foo\" {\n-\t\tt.Errorf(\"value = %q; want foo\", s)\n-\t}\n-\n-\tvar m map[string]string\n-\tNonNil(&m)\n-\tif len(m) != 0 {\n-\t\tt.Errorf(\"map len = %d; want 0\", len(s))\n-\t}\n-\tif m == nil {\n-\t\tt.Error(\"map still nil\")\n-\t}\n-}\n-\n func TestNonNilMapForJSON(t *testing.T) {\n \ttype M map[string]int\n \tvar m M\n---\n\n\n---\n\nChoice D:\nflake.lock\n@@ -36,11 +36,11 @@\n     },\n     \"nixpkgs\": {\n       \"locked\": {\n-        \"lastModified\": 1724748588,\n-        \"narHash\": \"sha256-NlpGA4+AIf1dKNq76ps90rxowlFXUsV9x7vK/mN37JM=\",\n+        \"lastModified\": 1743938762,\n+        \"narHash\": \"sha256-UgFYn8sGv9B8PoFpUfCa43CjMZBl1x/ShQhRDHBFQdI=\",\n         \"owner\": \"NixOS\",\n         \"repo\": \"nixpkgs\",\n-        \"rev\": \"a6292e34000dc93d43bccf78338770c1c5ec8a99\",\n+        \"rev\": \"74a40410369a1c35ee09b8a1abee6f4acbedc059\",\n         \"type\": \"github\"\n       },\n       \"original\": {\n---\nflake.nix\n@@ -68,14 +68,14 @@\n     # you're an end user you should be prepared for this flake to not\n     # build periodically.\n     tailscale = pkgs:\n-      pkgs.buildGo123Module rec {\n+      pkgs.buildGo124Module rec {\n         name = \"tailscale\";\n \n         src = ./.;\n         vendorHash = pkgs.lib.fileContents ./go.mod.sri;\n         nativeBuildInputs = pkgs.lib.optionals pkgs.stdenv.isLinux [pkgs.makeWrapper];\n         ldflags = [\"-X tailscale.com/version.gitCommitStamp=${tailscaleRev}\"];\n-        CGO_ENABLED = 0;\n+        env.CGO_ENABLED = 0;\n         subPackages = [\"cmd/tailscale\" \"cmd/tailscaled\"];\n         doCheck = false;\n \n@@ -118,7 +118,7 @@\n           gotools\n           graphviz\n           perl\n-          go_1_23\n+          go_1_24\n           yarn\n \n           # qemu and e2fsprogs are needed for natlab\n@@ -130,4 +130,4 @@\n   in\n     flake-utils.lib.eachDefaultSystem (system: flakeForSystem nixpkgs system);\n }\n-# nix-direnv cache busting line: sha256-xO1DuLWi6/lpA9ubA2ZYVJM+CkVNA5IaVGZxX9my0j0=\n+# nix-direnv cache busting line: sha256-av4kr09rjNRmag94ziNjJuI/cg8b8lAD3Tk24t/ezH4=\n---\ngo.mod.sri\n@@ -1 +1 @@\n-sha256-xO1DuLWi6/lpA9ubA2ZYVJM+CkVNA5IaVGZxX9my0j0=\n+sha256-av4kr09rjNRmag94ziNjJuI/cg8b8lAD3Tk24t/ezH4=\n\\ No newline at end of file\n---\nshell.nix\n@@ -16,4 +16,4 @@\n ) {\n   src =  ./.;\n }).shellNix\n-# nix-direnv cache busting line: sha256-xO1DuLWi6/lpA9ubA2ZYVJM+CkVNA5IaVGZxX9my0j0=\n+# nix-direnv cache busting line: sha256-av4kr09rjNRmag94ziNjJuI/cg8b8lAD3Tk24t/ezH4=\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n`tailscale set` was created to set preferences, which used to be overloaded into `tailscale up`. To move people over to the new command, `tailscale up` was supposed to be frozen, so no new preference flags would be added. But people forgot it was frozen, there was no test, and so new flags were added anyway.\r\n\r\nTestUpFlagSetIsFrozen complains when new flags are added to `tailscale up`. This doesn\u2019t try all combinations of GOOS, but the CI builds run in every OS, so this should be caught in the PR.\r\n\r\nThis problem is described, in detail, in #15460.\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -958,7 +958,9 @@ func (b *LocalBackend) linkChange(delta *netmon.ChangeDelta) {\n \n \tif peerAPIListenAsync && b.netMap != nil && b.state == ipn.Running {\n \t\twant := b.netMap.GetAddresses().Len()\n-\t\tif len(b.peerAPIListeners) < want {\n+\t\thave := len(b.peerAPIListeners)\n+\t\tb.logf(\"[v1] linkChange: have %d peerAPIListeners, want %d\", have, want)\n+\t\tif have < want {\n \t\t\tb.logf(\"linkChange: peerAPIListeners too low; trying again\")\n \t\t\tb.goTracker.Go(b.initPeerAPIListener)\n \t\t}\n@@ -5369,6 +5371,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n+\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -5918,19 +5918,22 @@ func (b *LocalBackend) requestEngineStatusAndWait() {\n \tb.logf(\"requestEngineStatusAndWait: got status update.\")\n }\n \n+// [controlclient.Auto] implements [auditlog.Transport].\n+var _ auditlog.Transport = (*controlclient.Auto)(nil)\n+\n // setControlClientLocked sets the control client to cc,\n // which may be nil.\n //\n // b.mu must be held.\n func (b *LocalBackend) setControlClientLocked(cc controlclient.Client) {\n \tb.cc = cc\n \tb.ccAuto, _ = cc.(*controlclient.Auto)\n-\tif b.auditLogger != nil {\n+\tif t, ok := b.cc.(auditlog.Transport); ok && b.auditLogger != nil {\n \t\tif err := b.auditLogger.SetProfileID(b.pm.CurrentProfile().ID()); err != nil {\n \t\t\tb.logf(\"audit logger set profile ID failure: %v\", err)\n \t\t}\n \n-\t\tif err := b.auditLogger.Start(b.ccAuto); err != nil {\n+\t\tif err := b.auditLogger.Start(t); err != nil {\n \t\t\tb.logf(\"audit logger start failure: %v\", err)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local.go\n@@ -4968,7 +4968,7 @@ func (b *LocalBackend) authReconfig() {\n \t\treturn\n \t}\n \n-\toneCGNATRoute := shouldUseOneCGNATRoute(b.logf, b.sys.ControlKnobs(), version.OS())\n+\toneCGNATRoute := shouldUseOneCGNATRoute(b.logf, b.sys.NetMon.Get(), b.sys.ControlKnobs(), version.OS())\n \trcfg := b.routerConfig(cfg, prefs, oneCGNATRoute)\n \n \terr = b.e.Reconfig(cfg, rcfg, dcfg)\n@@ -4992,7 +4992,7 @@ func (b *LocalBackend) authReconfig() {\n //\n // The versionOS is a Tailscale-style version (\"iOS\", \"macOS\") and not\n // a runtime.GOOS.\n-func shouldUseOneCGNATRoute(logf logger.Logf, controlKnobs *controlknobs.Knobs, versionOS string) bool {\n+func shouldUseOneCGNATRoute(logf logger.Logf, mon *netmon.Monitor, controlKnobs *controlknobs.Knobs, versionOS string) bool {\n \tif controlKnobs != nil {\n \t\t// Explicit enabling or disabling always take precedence.\n \t\tif v, ok := controlKnobs.OneCGNAT.Load().Get(); ok {\n@@ -5007,7 +5007,7 @@ func shouldUseOneCGNATRoute(logf logger.Logf, controlKnobs *controlknobs.Knobs,\n \t// use fine-grained routes if another interfaces is also using the CGNAT\n \t// IP range.\n \tif versionOS == \"macOS\" {\n-\t\thasCGNATInterface, err := netmon.HasCGNATInterface()\n+\t\thasCGNATInterface, err := mon.HasCGNATInterface()\n \t\tif err != nil {\n \t\t\tlogf(\"shouldUseOneCGNATRoute: Could not determine if any interfaces use CGNAT: %v\", err)\n \t\t\treturn false\n---\nipn/ipnlocal/peerapi.go\n@@ -481,7 +481,7 @@ func (h *peerAPIHandler) handleServeInterfaces(w http.ResponseWriter, r *http.Re\n \t\tfmt.Fprintf(w, \"<h3>Could not get the default route: %s</h3>\\n\", html.EscapeString(err.Error()))\n \t}\n \n-\tif hasCGNATInterface, err := netmon.HasCGNATInterface(); hasCGNATInterface {\n+\tif hasCGNATInterface, err := h.ps.b.sys.NetMon.Get().HasCGNATInterface(); hasCGNATInterface {\n \t\tfmt.Fprintln(w, \"<p>There is another interface using the CGNAT range.</p>\")\n \t} else if err != nil {\n \t\tfmt.Fprintf(w, \"<p>Could not check for CGNAT interfaces: %s</p>\\n\", html.EscapeString(err.Error()))\n---\nnet/netmon/interfaces_test.go\n@@ -13,7 +13,7 @@ import (\n )\n \n func TestGetState(t *testing.T) {\n-\tst, err := getState()\n+\tst, err := getState(\"\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/netmon/netmon.go\n@@ -161,7 +161,7 @@ func (m *Monitor) InterfaceState() *State {\n }\n \n func (m *Monitor) interfaceStateUncached() (*State, error) {\n-\treturn getState()\n+\treturn getState(m.tsIfName)\n }\n \n // SetTailscaleInterfaceName sets the name of the Tailscale interface. For\n---\nnet/netmon/state.go\n@@ -461,21 +461,22 @@ func isTailscaleInterface(name string, ips []netip.Prefix) bool {\n // getPAC, if non-nil, returns the current PAC file URL.\n var getPAC func() string\n \n-// GetState returns the state of all the current machine's network interfaces.\n+// getState returns the state of all the current machine's network interfaces.\n //\n // It does not set the returned State.IsExpensive. The caller can populate that.\n //\n-// Deprecated: use netmon.Monitor.InterfaceState instead.\n-func getState() (*State, error) {\n+// optTSInterfaceName is the name of the Tailscale interface, if known.\n+func getState(optTSInterfaceName string) (*State, error) {\n \ts := &State{\n \t\tInterfaceIPs: make(map[string][]netip.Prefix),\n \t\tInterface:    make(map[string]Interface),\n \t}\n \tif err := ForeachInterface(func(ni Interface, pfxs []netip.Prefix) {\n+\t\tisTSInterfaceName := optTSInterfaceName != \"\" && ni.Name == optTSInterfaceName\n \t\tifUp := ni.IsUp()\n \t\ts.Interface[ni.Name] = ni\n \t\ts.InterfaceIPs[ni.Name] = append(s.InterfaceIPs[ni.Name], pfxs...)\n-\t\tif !ifUp || isTailscaleInterface(ni.Name, pfxs) {\n+\t\tif !ifUp || isTSInterfaceName || isTailscaleInterface(ni.Name, pfxs) {\n \t\t\treturn\n \t\t}\n \t\tfor _, pfx := range pfxs {\n@@ -755,11 +756,12 @@ func DefaultRoute() (DefaultRouteDetails, error) {\n \n // HasCGNATInterface reports whether there are any non-Tailscale interfaces that\n // use a CGNAT IP range.\n-func HasCGNATInterface() (bool, error) {\n+func (m *Monitor) HasCGNATInterface() (bool, error) {\n \thasCGNATInterface := false\n \tcgnatRange := tsaddr.CGNATRange()\n \terr := ForeachInterface(func(i Interface, pfxs []netip.Prefix) {\n-\t\tif hasCGNATInterface || !i.IsUp() || isTailscaleInterface(i.Name, pfxs) {\n+\t\tisTSInterfaceName := m.tsIfName != \"\" && i.Name == m.tsIfName\n+\t\tif hasCGNATInterface || !i.IsUp() || isTSInterfaceName || isTailscaleInterface(i.Name, pfxs) {\n \t\t\treturn\n \t\t}\n \t\tfor _, pfx := range pfxs {\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/up_test.go\n@@ -0,0 +1,55 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package cli\n+\n+import (\n+\t\"flag\"\n+\t\"testing\"\n+\n+\t\"tailscale.com/util/set\"\n+)\n+\n+// validUpFlags are the only flags that are valid for tailscale up. The up\n+// command is frozen: no new preferences can be added. Instead, add them to\n+// tailscale set.\n+// See tailscale/tailscale#15460.\n+var validUpFlags = set.Of(\n+\t\"accept-dns\",\n+\t\"accept-risk\",\n+\t\"accept-routes\",\n+\t\"advertise-connector\",\n+\t\"advertise-exit-node\",\n+\t\"advertise-routes\",\n+\t\"advertise-tags\",\n+\t\"auth-key\",\n+\t\"exit-node\",\n+\t\"exit-node-allow-lan-access\",\n+\t\"force-reauth\",\n+\t\"host-routes\",\n+\t\"hostname\",\n+\t\"json\",\n+\t\"login-server\",\n+\t\"netfilter-mode\",\n+\t\"nickname\",\n+\t\"operator\",\n+\t\"posture-checking\",\n+\t\"qr\",\n+\t\"reset\",\n+\t\"shields-up\",\n+\t\"snat-subnet-routes\",\n+\t\"ssh\",\n+\t\"stateful-filtering\",\n+\t\"timeout\",\n+\t\"unattended\",\n+)\n+\n+// TestUpFlagSetIsFrozen complains when new flags are added to tailscale up.\n+func TestUpFlagSetIsFrozen(t *testing.T) {\n+\tupFlagSet.VisitAll(func(f *flag.Flag) {\n+\t\tname := f.Name\n+\t\tif !validUpFlags.Contains(name) {\n+\t\t\tt.Errorf(\"--%s flag added to tailscale up, new prefs go in tailscale set: see tailscale/tailscale#15460\", name)\n+\t\t}\n+\t})\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAs IPv4 and IPv6 end up with different MSS and different congestion control strategies, proxying between them can really amplify TCP meltdown style conditions in many real world network conditions, such as with higher latency, some loss, etc.\r\n\r\nAttempt to match up the protocols, otherwise pick a destination address arbitrarily. Also shuffle the target address to spread load across upstream load balancers.\r\n\r\nUpdates #15367\n\n---\n\nChoice A:\ncmd/natc/ippool/ippool.go\n@@ -24,7 +24,6 @@ var ErrNoIPsAvailable = errors.New(\"no IPs available\")\n type IPPool struct {\n \tperPeerMap syncs.Map[tailcfg.NodeID, *perPeerState]\n \tIPSet      *netipx.IPSet\n-\tV6ULA      netip.Prefix\n }\n \n func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bool) {\n@@ -44,15 +43,13 @@ func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bo\n func (ipp *IPPool) IPForDomain(from tailcfg.NodeID, domain string) (netip.Addr, error) {\n \tnpps := &perPeerState{\n \t\tipset: ipp.IPSet,\n-\t\tv6ULA: ipp.V6ULA,\n \t}\n \tps, _ := ipp.perPeerMap.LoadOrStore(from, npps)\n \treturn ps.ipForDomain(domain)\n }\n \n // perPeerState holds the state for a single peer.\n type perPeerState struct {\n-\tv6ULA netip.Prefix\n \tipset *netipx.IPSet\n \n \tmu           sync.Mutex\n---\ncmd/natc/ippool/ippool_test.go\n@@ -19,8 +19,7 @@ func TestIPPoolExhaustion(t *testing.T) {\n \tvar ipsb netipx.IPSetBuilder\n \tipsb.AddPrefix(smallPrefix)\n \taddrPool := must.Get(ipsb.IPSet())\n-\tv6ULA := netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\")\n-\tpool := IPPool{V6ULA: v6ULA, IPSet: addrPool}\n+\tpool := IPPool{IPSet: addrPool}\n \n \tassignedIPs := make(map[netip.Addr]string)\n \n@@ -52,9 +51,6 @@ func TestIPPoolExhaustion(t *testing.T) {\n \t\tif addr.Is4() && !smallPrefix.Contains(addr) {\n \t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, smallPrefix)\n \t\t}\n-\t\tif addr.Is6() && !v6ULA.Contains(addr) {\n-\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, v6ULA)\n-\t\t}\n \t}\n \n \t// expect one error for each iteration with the 5th domain\n@@ -73,7 +69,6 @@ func TestIPPool(t *testing.T) {\n \tipsb.AddPrefix(netip.MustParsePrefix(\"100.64.1.0/24\"))\n \taddrPool := must.Get(ipsb.IPSet())\n \tpool := IPPool{\n-\t\tV6ULA: netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n \t\tIPSet: addrPool,\n \t}\n \tfrom := tailcfg.NodeID(12345)\n---\ncmd/natc/natc.go\n@@ -153,7 +153,7 @@ func main() {\n \t\twhois:      lc,\n \t\tv6ULA:      v6ULA,\n \t\tignoreDsts: ignoreDstTable,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\troutes:     routes,\n \t\tdnsAddr:    dnsAddr,\n \t\tresolver:   net.DefaultResolver,\n---\ncmd/natc/natc_test.go\n@@ -270,7 +270,7 @@ func TestDNSResponse(t *testing.T) {\n \t\tignoreDsts: &bart.Table[bool]{},\n \t\troutes:     routes,\n \t\tv6ULA:      v6ULA,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\tdnsAddr:    dnsAddr,\n \t}\n \tc.ignoreDsts.Insert(netip.MustParsePrefix(\"8.8.4.4/32\"), true)\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -2404,11 +2404,9 @@ func (b *LocalBackend) Start(opts ipn.Options) error {\n \t}\n \n \tvar auditLogShutdown func()\n-\t// Audit logging is only available if the client has set up a proper persistent\n-\t// store for the logs in sys.\n \tstore, ok := b.sys.AuditLogStore.GetOK()\n \tif !ok {\n-\t\tb.logf(\"auditlog: [unexpected] no persistent audit log storage configured.  using memory store.\")\n+\t\t// Use memory store by default if no explicit store is provided.\n \t\tstore = auditlog.NewLogStore(&memstore.Store{})\n \t}\n \n---\n\n\n---\n\nChoice C:\ncmd/natc/natc.go\n@@ -13,6 +13,7 @@ import (\n \t\"flag\"\n \t\"fmt\"\n \t\"log\"\n+\t\"math/rand/v2\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/netip\"\n@@ -438,7 +439,7 @@ func (c *connector) handleTCPFlow(src, dst netip.AddrPort) (handler func(net.Con\n \t\treturn nil, false\n \t}\n \treturn func(conn net.Conn) {\n-\t\tproxyTCPConn(conn, domain)\n+\t\tproxyTCPConn(conn, domain, c)\n \t}, true\n }\n \n@@ -456,16 +457,34 @@ func (c *connector) ignoreDestination(dstAddrs []netip.Addr) bool {\n \treturn false\n }\n \n-func proxyTCPConn(c net.Conn, dest string) {\n+func proxyTCPConn(c net.Conn, dest string, ctor *connector) {\n \tif c.RemoteAddr() == nil {\n \t\tlog.Printf(\"proxyTCPConn: nil RemoteAddr\")\n \t\tc.Close()\n \t\treturn\n \t}\n-\taddrPortStr := c.LocalAddr().String()\n-\t_, port, err := net.SplitHostPort(addrPortStr)\n+\tladdr, err := netip.ParseAddrPort(c.LocalAddr().String())\n \tif err != nil {\n-\t\tlog.Printf(\"tcpRoundRobinHandler.Handle: bogus addrPort %q\", addrPortStr)\n+\t\tlog.Printf(\"proxyTCPConn: ParseAddrPort failed: %v\", err)\n+\t\tc.Close()\n+\t\treturn\n+\t}\n+\n+\tdaddrs, err := ctor.resolver.LookupNetIP(context.TODO(), \"ip\", dest)\n+\tif err != nil {\n+\t\tlog.Printf(\"proxyTCPConn: LookupNetIP failed: %v\", err)\n+\t\tc.Close()\n+\t\treturn\n+\t}\n+\n+\tif len(daddrs) == 0 {\n+\t\tlog.Printf(\"proxyTCPConn: no IP addresses found for %s\", dest)\n+\t\tc.Close()\n+\t\treturn\n+\t}\n+\n+\tif ctor.ignoreDestination(daddrs) {\n+\t\tlog.Printf(\"proxyTCPConn: closing connection to ignored destination %s (%v)\", dest, daddrs)\n \t\tc.Close()\n \t\treturn\n \t}\n@@ -475,10 +494,37 @@ func proxyTCPConn(c net.Conn, dest string) {\n \t\t\treturn netutil.NewOneConnListener(c, nil), nil\n \t\t},\n \t}\n-\t// XXX(raggi): if the connection here resolves to an ignored destination,\n-\t// the connection should be closed/failed.\n-\tp.AddRoute(addrPortStr, &tcpproxy.DialProxy{\n-\t\tAddr: fmt.Sprintf(\"%s:%s\", dest, port),\n+\n+\t// TODO(raggi): more code could avoid this shuffle, but avoiding allocations\n+\t// for now most of the time daddrs will be short.\n+\trand.Shuffle(len(daddrs), func(i, j int) {\n+\t\tdaddrs[i], daddrs[j] = daddrs[j], daddrs[i]\n \t})\n+\tdaddr := daddrs[0]\n+\n+\t// Try to match the upstream and downstream protocols (v4/v6)\n+\tif laddr.Addr().Is6() {\n+\t\tfor _, addr := range daddrs {\n+\t\t\tif addr.Is6() {\n+\t\t\t\tdaddr = addr\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tfor _, addr := range daddrs {\n+\t\t\tif addr.Is4() {\n+\t\t\t\tdaddr = addr\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// TODO(raggi): drop this library, it ends up being allocation and\n+\t// indirection heavy and really doesn't help us here.\n+\tdsockaddrs := netip.AddrPortFrom(daddr, laddr.Port()).String()\n+\tp.AddRoute(dsockaddrs, &tcpproxy.DialProxy{\n+\t\tAddr: dsockaddrs,\n+\t})\n+\n \tp.Start()\n }\n---\n\n\n---\n\nChoice D:\nssh/tailssh/tailssh_test.go\n@@ -16,7 +16,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"log\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n@@ -48,7 +47,6 @@ import (\n \t\"tailscale.com/tsd\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/types/key\"\n-\t\"tailscale.com/types/logger\"\n \t\"tailscale.com/types/logid\"\n \t\"tailscale.com/types/netmap\"\n \t\"tailscale.com/types/ptr\"\n@@ -230,7 +228,7 @@ func TestMatchRule(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tc := &conn{\n \t\t\t\tinfo: tt.ci,\n-\t\t\t\tsrv:  &server{logf: t.Logf},\n+\t\t\t\tsrv:  &server{logf: tstest.WhileTestRunningLogger(t)},\n \t\t\t}\n \t\t\tgot, gotUser, gotAcceptEnv, err := c.matchRule(tt.rule)\n \t\t\tif err != tt.wantErr {\n@@ -349,7 +347,7 @@ func TestEvalSSHPolicy(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tc := &conn{\n \t\t\t\tinfo: tt.ci,\n-\t\t\t\tsrv:  &server{logf: t.Logf},\n+\t\t\t\tsrv:  &server{logf: tstest.WhileTestRunningLogger(t)},\n \t\t\t}\n \t\t\tgot, gotUser, gotAcceptEnv, match := c.evalSSHPolicy(tt.policy)\n \t\t\tif match != tt.wantMatch {\n@@ -491,7 +489,7 @@ func TestSSHRecordingCancelsSessionsOnUploadFailure(t *testing.T) {\n \t})\n \n \ts := &server{\n-\t\tlogf: t.Logf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t\tlb: &localState{\n \t\t\tsshEnabled: true,\n \t\t\tmatchingRule: newSSHRule(\n@@ -553,7 +551,7 @@ func TestSSHRecordingCancelsSessionsOnUploadFailure(t *testing.T) {\n \n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n-\t\t\ts.logf = t.Logf\n+\t\t\ts.logf = tstest.WhileTestRunningLogger(t)\n \t\t\ttstest.Replace(t, &handler, tt.handler)\n \t\t\tsc, dc := memnet.NewTCPConn(src, dst, 1024)\n \t\t\tvar wg sync.WaitGroup\n@@ -621,7 +619,7 @@ func TestMultipleRecorders(t *testing.T) {\n \t})\n \n \ts := &server{\n-\t\tlogf: t.Logf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t\tlb: &localState{\n \t\t\tsshEnabled: true,\n \t\t\tmatchingRule: newSSHRule(\n@@ -714,7 +712,7 @@ func TestSSHRecordingNonInteractive(t *testing.T) {\n \t})\n \n \ts := &server{\n-\t\tlogf: t.Logf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t\tlb: &localState{\n \t\t\tsshEnabled: true,\n \t\t\tmatchingRule: newSSHRule(\n@@ -887,13 +885,15 @@ func TestSSHAuthFlow(t *testing.T) {\n \t\t},\n \t}\n \ts := &server{\n-\t\tlogf: log.Printf,\n+\t\tlogf: tstest.WhileTestRunningLogger(t),\n \t}\n \tdefer s.Shutdown()\n \tsrc, dst := must.Get(netip.ParseAddrPort(\"100.100.100.101:2231\")), must.Get(netip.ParseAddrPort(\"100.100.100.102:22\"))\n \tfor _, tc := range tests {\n \t\tfor _, authMethods := range [][]string{nil, {\"publickey\", \"password\"}, {\"password\", \"publickey\"}} {\n \t\t\tt.Run(fmt.Sprintf(\"%s-skip-none-auth-%v\", tc.name, strings.Join(authMethods, \"-then-\")), func(t *testing.T) {\n+\t\t\t\ts.logf = tstest.WhileTestRunningLogger(t)\n+\n \t\t\t\tsc, dc := memnet.NewTCPConn(src, dst, 1024)\n \t\t\t\ts.lb = tc.state\n \t\t\t\tsshUser := \"alice\"\n@@ -1036,7 +1036,7 @@ func TestSSHAuthFlow(t *testing.T) {\n }\n \n func TestSSH(t *testing.T) {\n-\tvar logf logger.Logf = t.Logf\n+\tlogf := tstest.WhileTestRunningLogger(t)\n \tsys := tsd.NewSystem()\n \teng, err := wgengine.NewFakeUserspaceEngine(logf, sys.Set, sys.HealthTracker(), sys.UserMetricsRegistry(), sys.Bus.Get())\n \tif err != nil {\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [actions/cache](https://github.com/actions/cache) from 4.2.2 to 4.2.3.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/actions/cache/releases\">actions/cache's releases</a>.</em></p>\n<blockquote>\n<h2>v4.2.3</h2>\n<h2>What's Changed</h2>\n<ul>\n<li>Update to use <code>@\u200bactions/cache</code> 4.0.3 package &amp; prepare for new release by <a href=\"https://github.com/salmanmkc\"><code>@\u200bsalmanmkc</code></a> in <a href=\"https://redirect.github.com/actions/cache/pull/1577\">actions/cache#1577</a> (SAS tokens for cache entries are now masked in debug logs)</li>\n</ul>\n<h2>New Contributors</h2>\n<ul>\n<li><a href=\"https://github.com/salmanmkc\"><code>@\u200bsalmanmkc</code></a> made their first contribution in <a href=\"https://redirect.github.com/actions/cache/pull/1577\">actions/cache#1577</a></li>\n</ul>\n<p><strong>Full Changelog</strong>: <a href=\"https://github.com/actions/cache/compare/v4.2.2...v4.2.3\">https://github.com/actions/cache/compare/v4.2.2...v4.2.3</a></p>\n</blockquote>\n</details>\n<details>\n<summary>Changelog</summary>\n<p><em>Sourced from <a href=\"https://github.com/actions/cache/blob/main/RELEASES.md\">actions/cache's changelog</a>.</em></p>\n<blockquote>\n<h1>Releases</h1>\n<h3>4.2.3</h3>\n<ul>\n<li>Bump <code>@actions/cache</code> to v4.0.3 (obfuscates SAS token in debug logs for cache entries)</li>\n</ul>\n<h3>4.2.2</h3>\n<ul>\n<li>Bump <code>@actions/cache</code> to v4.0.2</li>\n</ul>\n<h3>4.2.1</h3>\n<ul>\n<li>Bump <code>@actions/cache</code> to v4.0.1</li>\n</ul>\n<h3>4.2.0</h3>\n<p>TLDR; The cache backend service has been rewritten from the ground up for improved performance and reliability. <a href=\"https://github.com/actions/cache\">actions/cache</a> now integrates with the new cache service (v2) APIs.</p>\n<p>The new service will gradually roll out as of <strong>February 1st, 2025</strong>. The legacy service will also be sunset on the same date. Changes in these release are <strong>fully backward compatible</strong>.</p>\n<p><strong>We are deprecating some versions of this action</strong>. We recommend upgrading to version <code>v4</code> or <code>v3</code> as soon as possible before <strong>February 1st, 2025.</strong> (Upgrade instructions below).</p>\n<p>If you are using pinned SHAs, please use the SHAs of versions <code>v4.2.0</code> or <code>v3.4.0</code></p>\n<p>If you do not upgrade, all workflow runs using any of the deprecated <a href=\"https://github.com/actions/cache\">actions/cache</a> will fail.</p>\n<p>Upgrading to the recommended versions will not break your workflows.</p>\n<h3>4.1.2</h3>\n<ul>\n<li>Add GitHub Enterprise Cloud instances hostname filters to inform API endpoint choices - <a href=\"https://redirect.github.com/actions/cache/pull/1474\">#1474</a></li>\n<li>Security fix: Bump braces from 3.0.2 to 3.0.3 - <a href=\"https://redirect.github.com/actions/cache/pull/1475\">#1475</a></li>\n</ul>\n<h3>4.1.1</h3>\n<ul>\n<li>Restore original behavior of <code>cache-hit</code> output - <a href=\"https://redirect.github.com/actions/cache/pull/1467\">#1467</a></li>\n</ul>\n<h3>4.1.0</h3>\n<ul>\n<li>Ensure <code>cache-hit</code> output is set when a cache is missed - <a href=\"https://redirect.github.com/actions/cache/pull/1404\">#1404</a></li>\n<li>Deprecate <code>save-always</code> input - <a href=\"https://redirect.github.com/actions/cache/pull/1452\">#1452</a></li>\n</ul>\n<h3>4.0.2</h3>\n<ul>\n<li>Fixed restore <code>fail-on-cache-miss</code> not working.</li>\n</ul>\n<h3>4.0.1</h3>\n<ul>\n<li>Updated <code>isGhes</code> check</li>\n</ul>\n<!-- raw HTML omitted -->\n</blockquote>\n<p>... (truncated)</p>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/actions/cache/commit/5a3ec84eff668545956fd18022155c47e93e2684\"><code>5a3ec84</code></a> Merge pull request <a href=\"https://redirect.github.com/actions/cache/issues/1577\">#1577</a> from salmanmkc/salmanmkc/4-test</li>\n<li><a href=\"https://github.com/actions/cache/commit/7de21022a7b6824c106a9847befcbd8154b45b6a\"><code>7de2102</code></a> Update releases.md</li>\n<li><a href=\"https://github.com/actions/cache/commit/76d40dd347779762a1c829bbeeda5da4d81ca8c1\"><code>76d40dd</code></a> Update to use the latest version of the cache package to obfuscate the SAS</li>\n<li><a href=\"https://github.com/actions/cache/commit/76dd5eb692f606c28d4b7a4ea7cfdffc926ba06a\"><code>76dd5eb</code></a> update cache with main</li>\n<li><a href=\"https://github.com/actions/cache/commit/8c80c27c5e4498d5675b05fb1eff96a56c593b06\"><code>8c80c27</code></a> new package</li>\n<li><a href=\"https://github.com/actions/cache/commit/45cfd0e7fffd1869ea4d5bfb54a464d825c1f742\"><code>45cfd0e</code></a> updates</li>\n<li><a href=\"https://github.com/actions/cache/commit/edd449b9cf39c2a20dc7c3d505ff6dc193c48a02\"><code>edd449b</code></a> updated cache with latest changes</li>\n<li><a href=\"https://github.com/actions/cache/commit/0576707e373f92196b81695442ed3f80c347f9c7\"><code>0576707</code></a> latest test before pr</li>\n<li><a href=\"https://github.com/actions/cache/commit/3105dc9754dd9cd935ffcf45c091ed2cadbf42b9\"><code>3105dc9</code></a> update</li>\n<li><a href=\"https://github.com/actions/cache/commit/9450d42d15022999ad2fa60a8b91f01fc92a0563\"><code>9450d42</code></a> mask</li>\n<li>Additional commits viewable in <a href=\"https://github.com/actions/cache/compare/d4323d4df104b026a6aa633fdb11d772146be0bf...5a3ec84eff668545956fd18022155c47e93e2684\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=actions/cache&package-manager=github_actions&previous-version=4.2.2&new-version=4.2.3)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\nipn/ipnlocal/local_test.go\n@@ -15,7 +15,6 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n-\t\"runtime\"\n \t\"slices\"\n \t\"strings\"\n \t\"sync\"\n@@ -2597,9 +2596,6 @@ func TestPreferencePolicyInfo(t *testing.T) {\n }\n \n func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n-\tif runtime.GOOS == \"darwin\" {\n-\t\tt.Skip(\"test known broken on macOS; see https://github.com/tailscale/tailscale/issues/15691\")\n-\t}\n \ttests := []struct {\n \t\tbefore, after  opt.Bool\n \t\tcontainer      opt.Bool\n@@ -2669,7 +2665,7 @@ func TestOnTailnetDefaultAutoUpdate(t *testing.T) {\n \t\t\t// On platforms that don't support auto-update we can never\n \t\t\t// transition to auto-updates being enabled. The value should\n \t\t\t// remain unchanged after onTailnetDefaultAutoUpdate.\n-\t\t\tif !clientupdate.CanAutoUpdate() && want.EqualBool(true) {\n+\t\t\tif !clientupdate.CanAutoUpdate() {\n \t\t\t\twant = tt.before\n \t\t\t}\n \t\t\tif got := b.pm.CurrentPrefs().AutoUpdate().Apply; got != want {\n---\n\n\n---\n\nChoice B:\ndocs/k8s/operator-architecture.md\n@@ -131,11 +131,11 @@ flowchart TD\n \n [Documentation][kb-operator-l7-ingress]\n \n-L7 ingress is relatively similar to L3 ingress. It is configured via an\n-`Ingress` object instead of a `Service`, and uses `tailscale serve` to accept\n-traffic instead of configuring `iptables` or `nftables` rules. Note that we use\n-tailscaled's local API (`SetServeConfig`) to set serve config, not the\n-`tailscale serve` command.\n+The L7 ingress architecture diagram is relatively similar to L3 ingress. It is\n+configured via an `Ingress` object instead of a `Service`, and uses\n+`tailscale serve` to accept traffic instead of configuring `iptables` or\n+`nftables` rules. Note that we use tailscaled's local API (`SetServeConfig`) to\n+set serve config, not the `tailscale serve` command.\n \n ```mermaid\n %%{ init: { 'theme':'neutral' } }%%\n@@ -159,6 +159,10 @@ flowchart TD\n             state-secret[\"state Secret\"]\n         end\n \n+        subgraph cluster-scope[Cluster scoped resources]\n+            ingress-class[Tailscale IngressClass]\n+        end\n+\n         subgraph defaultns[namespace=default]\n             ingress[tailscale Ingress]\n             svc[\"Service\"]\n@@ -260,6 +264,8 @@ flowchart TD\n \n ## `ProxyGroup`\n \n+### Egress\n+\n [Documentation][kb-operator-l3-egress-proxygroup]\n \n The `ProxyGroup` custom resource manages a collection of proxy Pods that\n@@ -278,8 +284,6 @@ ports via the ClusterIP Service and its EndpointSlice. The operator then\n generates the egress ConfigMap that tells the `ProxyGroup` Pods which incoming\n ports map to which egress targets.\n \n-`ProxyGroups` currently only support egress.\n-\n ```mermaid\n %%{ init: { 'theme':'neutral' } }%%\n \n@@ -364,6 +368,86 @@ flowchart LR\n \n ```\n \n+### Ingress\n+\n+A ProxyGroup can also serve as a highly available set of proxies for an\n+Ingress resource. The `-0` Pod is always the replica that will issue a certificate\n+from Let's Encrypt.\n+\n+If the same Ingress config is applied in multiple clusters, ProxyGroup proxies\n+from each cluster will be valid targets for the ts.net DNS name, and the proxy\n+each client is routed to will depend on the same rules as for [high availability][kb-ha]\n+subnet routers, and is encoded in the client's netmap.\n+\n+```mermaid\n+%%{ init: { 'theme':'neutral' } }%%\n+flowchart LR\n+    classDef tsnode color:#fff,fill:#000;\n+    classDef pod fill:#fff;\n+\n+    subgraph Key\n+        ts[Tailscale device]:::tsnode\n+        pod((Pod)):::pod\n+        blank[\" \"]-->|WireGuard traffic| blank2[\" \"]\n+        blank3[\" \"]-->|Other network traffic| blank4[\" \"]\n+    end\n+\n+    subgraph k8s[Kubernetes cluster]\n+        subgraph tailscale-ns[namespace=tailscale]\n+            operator((operator)):::tsnode\n+            ingress-sts[\"StatefulSet\"]\n+            serve-cm[serve config ConfigMap]\n+            ingress-0((\"pg-0 (dst)\")):::tsnode\n+            ingress-1((\"pg-1 (dst)\")):::tsnode\n+            tls-secret[myapp.tails.ts.net Secret]\n+        end\n+\n+        subgraph defaultns[namespace=default]\n+            ingress[myapp.tails.ts.net Ingress]\n+            svc[\"myapp Service\"]\n+            svc --> pod1((pod1))\n+            svc --> pod2((pod2))\n+        end\n+\n+        subgraph cluster[Cluster scoped resources]\n+            ingress-class[Tailscale IngressClass]\n+            pg[ProxyGroup 'pg']\n+        end\n+    end\n+\n+    control[\"Tailscale control plane\"]\n+    ts-svc[\"myapp Tailscale Service\"]\n+\n+    client[\"client (src)\"]:::tsnode -->|dials https\\://myapp.tails.ts.net/api| ingress-1\n+    ingress-0 -->|forwards traffic| svc\n+    ingress-1 -->|forwards traffic| svc\n+    control -.->|creates| ts-svc\n+    operator -.->|creates myapp Tailscale Service| control\n+    control -.->|netmap points myapp Tailscale Service to pg-1| client\n+    operator -.->|creates| ingress-sts\n+    ingress-sts -.->|manages| ingress-0\n+    ingress-sts -.->|manages| ingress-1\n+    ingress-0 -.->|issues myapp.tails.ts.net cert| le[Let's Encrypt]\n+    ingress-0 -.->|stores cert| tls-secret\n+    ingress-1 -.->|reads cert| tls-secret\n+    operator -.->|watches| ingress\n+    operator -.->|watches| pg\n+    operator -.->|creates| serve-cm\n+    serve-cm -.->|mounted| ingress-0\n+    serve-cm -.->|mounted| ingress-1\n+    ingress -.->|/api prefix| svc\n+\n+    linkStyle 0 stroke:red;\n+    linkStyle 4 stroke:red;\n+\n+    linkStyle 1 stroke:blue;\n+    linkStyle 2 stroke:blue;\n+    linkStyle 3 stroke:blue;\n+    linkStyle 5 stroke:blue;\n+    linkStyle 6 stroke:blue;\n+\n+```\n+\n ## Connector\n \n [Subnet router and exit node documentation][kb-operator-connector]\n@@ -514,4 +598,5 @@ flowchart TD\n [kb-operator-connector]: https://tailscale.com/kb/1441/kubernetes-operator-connector\n [kb-operator-app-connector]: https://tailscale.com/kb/1517/kubernetes-operator-app-connector\n [kb-operator-recorder]: https://tailscale.com/kb/1484/kubernetes-operator-deploying-tsrecorder\n+[kb-ha]: https://tailscale.com/kb/1115/high-availability\n [k8s-impersonation]: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation\n---\n\n\n---\n\nChoice C:\n.github/workflows/test.yml\n@@ -79,7 +79,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -157,7 +157,7 @@ jobs:\n         cache: false\n \n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -263,7 +263,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -333,7 +333,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -386,7 +386,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -5918,19 +5918,22 @@ func (b *LocalBackend) requestEngineStatusAndWait() {\n \tb.logf(\"requestEngineStatusAndWait: got status update.\")\n }\n \n+// [controlclient.Auto] implements [auditlog.Transport].\n+var _ auditlog.Transport = (*controlclient.Auto)(nil)\n+\n // setControlClientLocked sets the control client to cc,\n // which may be nil.\n //\n // b.mu must be held.\n func (b *LocalBackend) setControlClientLocked(cc controlclient.Client) {\n \tb.cc = cc\n \tb.ccAuto, _ = cc.(*controlclient.Auto)\n-\tif b.auditLogger != nil {\n+\tif t, ok := b.cc.(auditlog.Transport); ok && b.auditLogger != nil {\n \t\tif err := b.auditLogger.SetProfileID(b.pm.CurrentProfile().ID()); err != nil {\n \t\t\tb.logf(\"audit logger set profile ID failure: %v\", err)\n \t\t}\n \n-\t\tif err := b.auditLogger.Start(b.ccAuto); err != nil {\n+\t\tif err := b.auditLogger.Start(t); err != nil {\n \t\t\tb.logf(\"audit logger start failure: %v\", err)\n \t\t}\n \t}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [github/codeql-action](https://github.com/github/codeql-action) from 3.28.13 to 3.28.14.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/releases\">github/codeql-action's releases</a>.</em></p>\n<blockquote>\n<h2>v3.28.14</h2>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>3.28.14 - 07 Apr 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.0. <a href=\"https://redirect.github.com/github/codeql-action/pull/2838\">#2838</a></li>\n</ul>\n<p>See the full <a href=\"https://github.com/github/codeql-action/blob/v3.28.14/CHANGELOG.md\">CHANGELOG.md</a> for more information.</p>\n</blockquote>\n</details>\n<details>\n<summary>Changelog</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/blob/main/CHANGELOG.md\">github/codeql-action's changelog</a>.</em></p>\n<blockquote>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>[UNRELEASED]</h2>\n<p>No user facing changes.</p>\n<h2>3.28.14 - 07 Apr 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.21.0. <a href=\"https://redirect.github.com/github/codeql-action/pull/2838\">#2838</a></li>\n</ul>\n<h2>3.28.13 - 24 Mar 2025</h2>\n<p>No user facing changes.</p>\n<h2>3.28.12 - 19 Mar 2025</h2>\n<ul>\n<li>Dependency caching should now cache more dependencies for Java <code>build-mode: none</code> extractions. This should speed up workflows and avoid inconsistent alerts in some cases.</li>\n<li>Update default CodeQL bundle version to 2.20.7. <a href=\"https://redirect.github.com/github/codeql-action/pull/2810\">#2810</a></li>\n</ul>\n<h2>3.28.11 - 07 Mar 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.6. <a href=\"https://redirect.github.com/github/codeql-action/pull/2793\">#2793</a></li>\n</ul>\n<h2>3.28.10 - 21 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.5. <a href=\"https://redirect.github.com/github/codeql-action/pull/2772\">#2772</a></li>\n<li>Address an issue where the CodeQL Bundle would occasionally fail to decompress on macOS. <a href=\"https://redirect.github.com/github/codeql-action/pull/2768\">#2768</a></li>\n</ul>\n<h2>3.28.9 - 07 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.4. <a href=\"https://redirect.github.com/github/codeql-action/pull/2753\">#2753</a></li>\n</ul>\n<h2>3.28.8 - 29 Jan 2025</h2>\n<ul>\n<li>Enable support for Kotlin 2.1.10 when running with CodeQL CLI v2.20.3. <a href=\"https://redirect.github.com/github/codeql-action/pull/2744\">#2744</a></li>\n</ul>\n<h2>3.28.7 - 29 Jan 2025</h2>\n<p>No user facing changes.</p>\n<h2>3.28.6 - 27 Jan 2025</h2>\n<ul>\n<li>Re-enable debug artifact upload for CLI versions 2.20.3 or greater. <a href=\"https://redirect.github.com/github/codeql-action/pull/2726\">#2726</a></li>\n</ul>\n<h2>3.28.5 - 24 Jan 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.3. <a href=\"https://redirect.github.com/github/codeql-action/pull/2717\">#2717</a></li>\n</ul>\n<!-- raw HTML omitted -->\n</blockquote>\n<p>... (truncated)</p>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/github/codeql-action/commit/fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2\"><code>fc7e4a0</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2844\">#2844</a> from github/update-v3.28.14-362ef4ce2</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/be0175c800fe14dd962aaa2c97f55371f6f95b35\"><code>be0175c</code></a> Update changelog for v3.28.14</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/362ef4ce205154842cd1d34794abd82bb8f12cd5\"><code>362ef4c</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2838\">#2838</a> from github/update-bundle/codeql-bundle-v2.21.0</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/2b85c00718b8a4d8e9928961ea3cf0437450e643\"><code>2b85c00</code></a> Merge branch 'main' into update-bundle/codeql-bundle-v2.21.0</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/41aa4376380d34f89f93b8f2f92bb9d3b5723154\"><code>41aa437</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2841\">#2841</a> from github/angelapwen/log-init-post-telemetry</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/92864f48b0dea860caaa9bba99727700e0b4fd3d\"><code>92864f4</code></a> Add logs around status report telemetry in <code>init-post</code> step</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/e13fe0dd2d51f2b63b05fee9b9cda14b2050f678\"><code>e13fe0d</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2833\">#2833</a> from github/NlightNFotis/reclassify_upload_sarif_issues</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/06703ce3e5d16d2ba1159d8ef76d0bc95d3bed97\"><code>06703ce</code></a> Merge branch 'main' into NlightNFotis/reclassify_upload_sarif_issues</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/676a422916fb4b124d13126326cd03f440e112d6\"><code>676a422</code></a> review-comments: nest validateSariFileSchema into try-catch block to better d...</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/498c7f37e85d2d0fe6bac32a3c71708870a27bee\"><code>498c7f3</code></a> review-comments: unwrap error in upload-sarif-action and re-classify as Confi...</li>\n<li>Additional commits viewable in <a href=\"https://github.com/github/codeql-action/compare/1b549b9259bda1cb5ddde3b41741a82a2d15a841...fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=github/codeql-action&package-manager=github_actions&previous-version=3.28.13&new-version=3.28.14)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n+      uses: github/codeql-action/init@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n+      uses: github/codeql-action/autobuild@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n+      uses: github/codeql-action/analyze@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -4837,9 +4837,34 @@ func (b *LocalBackend) doSetHostinfoFilterServices() {\n \tc := len(hi.Services)\n \thi.Services = append(hi.Services[:c:c], peerAPIServices...)\n \thi.PushDeviceToken = b.pushDeviceToken.Load()\n+\n+\t// Compare the expected ports from peerAPIServices to the actual ports in hi.Services.\n+\texpectedPorts := extractPeerAPIPorts(peerAPIServices)\n+\tactualPorts := extractPeerAPIPorts(hi.Services)\n+\tif expectedPorts != actualPorts {\n+\t\tb.logf(\"Hostinfo peerAPI ports changed: expected %v, got %v\", expectedPorts, actualPorts)\n+\t}\n+\n \tcc.SetHostinfo(&hi)\n }\n \n+type portPair struct {\n+\tv4, v6 uint16\n+}\n+\n+func extractPeerAPIPorts(services []tailcfg.Service) portPair {\n+\tvar p portPair\n+\tfor _, s := range services {\n+\t\tswitch s.Proto {\n+\t\tcase \"peerapi4\":\n+\t\t\tp.v4 = s.Port\n+\t\tcase \"peerapi6\":\n+\t\t\tp.v6 = s.Port\n+\t\t}\n+\t}\n+\treturn p\n+}\n+\n // NetMap returns the latest cached network map received from\n // controlclient, or nil if no network map was received yet.\n func (b *LocalBackend) NetMap() *netmap.NetworkMap {\n---\n\n\n---\n\nChoice C:\ncmd/derpprobe/derpprobe.go\n@@ -9,6 +9,7 @@ import (\n \t\"fmt\"\n \t\"log\"\n \t\"net/http\"\n+\t\"os\"\n \t\"sort\"\n \t\"time\"\n \n@@ -75,6 +76,9 @@ func main() {\n \t\tfor _, s := range st.bad {\n \t\t\tlog.Printf(\"bad: %s\", s)\n \t\t}\n+\t\tif len(st.bad) > 0 {\n+\t\t\tos.Exit(1)\n+\t\t}\n \t\treturn\n \t}\n \n---\n\n\n---\n\nChoice D:\n.github/workflows/test.yml\n@@ -39,7 +39,7 @@ concurrency:\n \n jobs:\n   race-root-integration:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     strategy:\n       fail-fast: false # don't abort the entire matrix if one element fails\n       matrix:\n@@ -74,7 +74,7 @@ jobs:\n             buildflags: \"-race\"\n             shard: '3/3'\n           - goarch: \"386\" # thanks yaml\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -187,7 +187,7 @@ jobs:\n         find $(go env GOMODCACHE)/cache -type f -mmin +90 -delete\n \n   privileged:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     container:\n       image: golang:latest\n       options: --privileged\n@@ -214,7 +214,7 @@ jobs:\n         XDG_CACHE_HOME: \"/var/lib/ghrunner/cache\"\n \n   race-build:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -258,7 +258,7 @@ jobs:\n           - goos: openbsd\n             goarch: amd64\n \n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -300,7 +300,7 @@ jobs:\n \n   ios: # similar to cross above, but iOS can't build most of the repo. So, just\n        #make it build a few smoke packages.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -328,7 +328,7 @@ jobs:\n           - goos: illumos\n             goarch: amd64\n \n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -366,7 +366,7 @@ jobs:\n     # similar to cross above, but android fails to build a few pieces of the\n     # repo. We should fix those pieces, they're small, but as a stepping stone,\n     # only test the subset of android that our past smoke test checked.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -381,7 +381,7 @@ jobs:\n         GOARCH: arm64\n \n   wasm: # builds tsconnect, which is the only wasm build we support\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -420,7 +420,7 @@ jobs:\n         find $(go env GOMODCACHE)/cache -type f -mmin +90 -delete\n \n   tailscale_go: # Subset of tests that depend on our custom Go toolchain.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -440,7 +440,7 @@ jobs:\n     # explicit 'if' condition, because the default condition for steps is\n     # 'success()', meaning \"only run this if no previous steps failed\".\n     if: github.event_name == 'pull_request'\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: build fuzzers\n       id: build\n@@ -492,7 +492,7 @@ jobs:\n         path: ${{ env.artifacts_path }}/out/artifacts\n \n   depaware:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -502,7 +502,7 @@ jobs:\n         find . -name 'depaware.txt' | xargs -n1 dirname | xargs ./tool/go run github.com/tailscale/depaware --check --internal\n \n   go_generate:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -515,7 +515,7 @@ jobs:\n         git diff --name-only --exit-code || (echo \"The files above need updating. Please run 'go generate'.\"; exit 1)\n \n   go_mod_tidy:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -527,15 +527,15 @@ jobs:\n         git diff --name-only --exit-code || (echo \"Please run 'go mod tidy'.\"; exit 1)\n \n   licenses:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: check licenses\n       run: ./scripts/check_license_headers.sh .\n \n   staticcheck:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     strategy:\n       fail-fast: false # don't abort the entire matrix if one element fails\n       matrix:\n@@ -576,7 +576,7 @@ jobs:\n       - go_mod_tidy\n       - licenses\n       - staticcheck\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: notify  \n       # Only notify slack for merged commits, not PR failures.\n@@ -605,7 +605,7 @@ jobs:\n \n   check_mergeability:\n     if: always()\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     needs:\n       - android\n       - test\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFor future in-memory network changes (#15558) to be able to be\nstricter and do automatic leak detection when it's safe to do so, in\nnon-parallel tests.\n\nUpdates tailscale/corp#27636\n\n\n---\n\nChoice A:\nwgengine/userspace.go\n@@ -1580,6 +1580,12 @@ type fwdDNSLinkSelector struct {\n }\n \n func (ls fwdDNSLinkSelector) PickLink(ip netip.Addr) (linkName string) {\n+\t// sandboxed macOS does not automatically bind to the loopback interface so\n+\t// we must be explicit about it.\n+\tif runtime.GOOS == \"darwin\" && ip.IsLoopback() {\n+\t\treturn \"lo0\"\n+\t}\n+\n \tif ls.ue.isDNSIPOverTailscale.Load()(ip) {\n \t\treturn ls.tunName\n \t}\n---\n\n\n---\n\nChoice B:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/init@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/autobuild@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/analyze@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n---\n\n\n---\n\nChoice C:\nfeature/taildrop/ext.go\n@@ -100,6 +100,10 @@ func (e *Extension) Init(h ipnext.Host) error {\n \th.Hooks().SetPeerStatus.Add(e.setPeerStatus)\n \th.Hooks().BackendStateChange.Add(e.onBackendStateChange)\n \n+\t// TODO(nickkhyl): remove this after the profileManager refactoring.\n+\t// See tailscale/tailscale#15974.\n+\tprofile, prefs := h.Profiles().CurrentProfileState()\n+\te.onChangeProfile(profile, prefs, false)\n \treturn nil\n }\n \n---\nfeature/taildrop/integration_test.go\n@@ -26,7 +26,6 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n-\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n \ttestTaildropIntegration(t, false)\n }\n \n---\nipn/ipnext/ipnext.go\n@@ -37,7 +37,10 @@ type Extension interface {\n \t// It must be the same as the name used to register the extension.\n \tName() string\n \n-\t// Init is called to initialize the extension when LocalBackend is initialized.\n+\t// Init is called to initialize the extension when LocalBackend's\n+\t// Start method is called. Extensions are created but not initialized\n+\t// unless LocalBackend is started.\n+\t//\n \t// If the extension cannot be initialized, it must return an error,\n \t// and its Shutdown method will not be called on the host's shutdown.\n \t// Returned errors are not fatal; they are used for logging.\n@@ -333,6 +336,7 @@ type Hooks struct {\n \t// BackendStateChange is called when the backend state changes.\n \tBackendStateChange feature.Hooks[func(ipn.State)]\n \n+\t// ProfileStateChange contains callbacks that are invoked when the current login profile\n \t// or its [ipn.Prefs] change, after those changes have been made. The current login profile\n \t// may be changed either because of a profile switch, or because the profile information\n \t// was updated by [LocalBackend.SetControlClientStatus], including when the profile\n---\nipn/ipnlocal/local.go\n@@ -237,6 +237,8 @@ type LocalBackend struct {\n \t// for testing and graceful shutdown purposes.\n \tgoTracker goroutines.Tracker\n \n+\tstartOnce sync.Once // protects the one\u2011time initialization in [LocalBackend.Start]\n+\n \t// extHost is the bridge between [LocalBackend] and the registered [ipnext.Extension]s.\n \t// It may be nil in tests that use direct composite literal initialization of [LocalBackend]\n \t// instead of calling [NewLocalBackend]. A nil pointer is a valid, no-op host.\n@@ -568,8 +570,6 @@ func NewLocalBackend(logf logger.Logf, logID logid.PublicID, sys *tsd.System, lo\n \t\t\t}\n \t\t}\n \t}\n-\n-\tb.extHost.Init()\n \treturn b, nil\n }\n \n@@ -2162,6 +2162,11 @@ func (b *LocalBackend) getNewControlClientFuncLocked() clientGen {\n \treturn b.ccGen\n }\n \n+// initOnce is called on the first call to [LocalBackend.Start].\n+func (b *LocalBackend) initOnce() {\n+\tb.extHost.Init()\n+}\n+\n // Start applies the configuration specified in opts, and starts the\n // state machine.\n //\n@@ -2175,6 +2180,8 @@ func (b *LocalBackend) getNewControlClientFuncLocked() clientGen {\n func (b *LocalBackend) Start(opts ipn.Options) error {\n \tb.logf(\"Start\")\n \n+\tb.startOnce.Do(b.initOnce)\n+\n \tvar clientToShutdown controlclient.Client\n \tdefer func() {\n \t\tif clientToShutdown != nil {\n---\n\n\n---\n\nChoice D:\nutil/testenv/testenv.go\n@@ -6,6 +6,7 @@\n package testenv\n \n import (\n+\t\"context\"\n \t\"flag\"\n \n \t\"tailscale.com/types/lazy\"\n@@ -19,3 +20,41 @@ func InTest() bool {\n \t\treturn flag.Lookup(\"test.v\") != nil\n \t})\n }\n+\n+// TB is testing.TB, to avoid importing \"testing\" in non-test code.\n+type TB interface {\n+\tCleanup(func())\n+\tError(args ...any)\n+\tErrorf(format string, args ...any)\n+\tFail()\n+\tFailNow()\n+\tFailed() bool\n+\tFatal(args ...any)\n+\tFatalf(format string, args ...any)\n+\tHelper()\n+\tLog(args ...any)\n+\tLogf(format string, args ...any)\n+\tName() string\n+\tSetenv(key, value string)\n+\tChdir(dir string)\n+\tSkip(args ...any)\n+\tSkipNow()\n+\tSkipf(format string, args ...any)\n+\tSkipped() bool\n+\tTempDir() string\n+\tContext() context.Context\n+}\n+\n+// InParallelTest reports whether t is running as a parallel test.\n+//\n+// Use of this function taints t such that its Parallel method (assuming t is an\n+// actual *testing.T) will panic if called after this function.\n+func InParallelTest(t TB) (isParallel bool) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tisParallel = true\n+\t\t}\n+\t}()\n+\tt.Chdir(\".\") // panics in a t.Parallel test\n+\treturn false\n+}\n---\nutil/testenv/testenv_test.go\n@@ -16,3 +16,16 @@ func TestDeps(t *testing.T) {\n \t\t},\n \t}.Check(t)\n }\n+\n+func TestInParallelTestTrue(t *testing.T) {\n+\tt.Parallel()\n+\tif !InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return true once t.Parallel has been called\")\n+\t}\n+}\n+\n+func TestInParallelTestFalse(t *testing.T) {\n+\tif InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return false before t.Parallel has been called\")\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nPull in https://github.com/tailscale/golang-x-crypto/pull/16\r\n\r\nUpdates #15542\n\n---\n\nChoice A:\n.github/CONTRIBUTING.md\n@@ -0,0 +1,17 @@\n+PRs welcome! But please file bugs first and explain the problem or\n+motivation. For new or changed functionality, strike up a discussion\n+and get agreement on the design/solution before spending too much time writing\n+code.\n+\n+Commit messages should [reference\n+bugs](https://docs.github.com/en/github/writing-on-github/autolinked-references-and-urls).\n+\n+We require [Developer Certificate of\n+Origin](https://en.wikipedia.org/wiki/Developer_Certificate_of_Origin) (DCO)\n+`Signed-off-by` lines in commits. (`git commit -s`)\n+\n+Please squash your code review edits & force push. Multiple commits in\n+a PR are fine, but only if they're each logically separate and all tests pass\n+at each stage. No fixup commits.\n+\n+See [commit-messages.md](docs/commit-messages.md) (or skim `git log`) for our commit message style.\n---\n\n\n---\n\nChoice B:\ncmd/tailscale/cli/cli_test.go\n@@ -1659,3 +1659,51 @@ func TestSingleUseStringFlag(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestSingleUseStringFlagsSetTwice(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tflagName string\n+\t\tvals     []string\n+\t\tsetup    func(*upArgsT) flag.Value\n+\t}{\n+\t\t{\n+\t\t\tname:     \"advertise-tags\",\n+\t\t\tflagName: \"advertise-tags\",\n+\t\t\tvals:     []string{\"tag:foo\", \"tag:bar\"},\n+\t\t\tsetup: func(u *upArgsT) flag.Value {\n+\t\t\t\treturn &u.advertiseTags\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"advertise-routes\",\n+\t\t\tflagName: \"advertise-routes\",\n+\t\t\tvals:     []string{\"10.0.0.0/8\", \"192.168.0.0/16\"},\n+\t\t\tsetup: func(u *upArgsT) flag.Value {\n+\t\t\t\treturn &u.advertiseRoutes\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tvar upArgs upArgsT\n+\t\t\tfs := flag.NewFlagSet(\"test\", flag.ContinueOnError)\n+\t\t\tfs.SetOutput(io.Discard)\n+\n+\t\t\tfs.Var(tt.setup(&upArgs), tt.flagName, \"\")\n+\t\t\targs := []string{\n+\t\t\t\tfmt.Sprintf(\"--%s=%s\", tt.flagName, tt.vals[0]),\n+\t\t\t\tfmt.Sprintf(\"--%s=%s\", tt.flagName, tt.vals[1]),\n+\t\t\t}\n+\n+\t\t\terr := fs.Parse(args)\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatal(\"expected error when setting flag twice, got nil\")\n+\t\t\t}\n+\t\t\tif !strings.Contains(err.Error(), \"flag can only be specified once\") {\n+\t\t\t\tt.Errorf(\"unexpected error message: %v\", err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\n.github/workflows/installer.yml\n@@ -1,6 +1,8 @@\n name: test installer.sh\n \n on:\n+  schedule:\n+    - cron: '0 15 * * *' # 10am EST (UTC-4/5)\n   push:\n     branches:\n       - \"main\"\n@@ -72,10 +74,10 @@ jobs:\n       # tar and gzip are needed by the actions/checkout below.\n       run: yum install -y --allowerasing tar gzip ${{ matrix.deps }}\n       if: |\n-        contains(matrix.image, 'centos')\n-        || contains(matrix.image, 'oraclelinux')\n-        || contains(matrix.image, 'fedora')\n-        || contains(matrix.image, 'amazonlinux')\n+        contains(matrix.image, 'centos') ||\n+        contains(matrix.image, 'oraclelinux') ||\n+        contains(matrix.image, 'fedora') ||\n+        contains(matrix.image, 'amazonlinux')\n     - name: install dependencies (zypper)\n       # tar and gzip are needed by the actions/checkout below.\n       run: zypper --non-interactive install tar gzip ${{ matrix.deps }}\n@@ -85,11 +87,11 @@ jobs:\n         apt-get update\n         apt-get install -y ${{ matrix.deps }}\n       if: |\n-        contains(matrix.image, 'debian')\n-        || contains(matrix.image, 'ubuntu')\n-        || contains(matrix.image, 'elementary')\n-        || contains(matrix.image, 'parrotsec')\n-        || contains(matrix.image, 'kalilinux')\n+        contains(matrix.image, 'debian') ||\n+        contains(matrix.image, 'ubuntu') ||\n+        contains(matrix.image, 'elementary') ||\n+        contains(matrix.image, 'parrotsec') ||\n+        contains(matrix.image, 'kalilinux')\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: run installer\n@@ -100,3 +102,30 @@ jobs:\n       continue-on-error: true\n     - name: check tailscale version\n       run: tailscale --version\n+  notify-slack:\n+    needs: test\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Notify Slack of failure on scheduled runs\n+        if: failure() && github.event_name == 'schedule'\n+        uses: slackapi/slack-github-action@485a9d42d3a73031f12ec201c457e2162c45d02d # v2.0.0\n+        with:\n+          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}\n+          webhook-type: incoming-webhook\n+          payload: |\n+            {\n+              \"attachments\": [{\n+                \"title\": \"Tailscale installer test failed\",\n+                \"title_link\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\n+                \"text\": \"One or more OSes in the test matrix failed. See the run for details.\",\n+                \"fields\": [\n+                  {\n+                    \"title\": \"Ref\",\n+                    \"value\": \"${{ github.ref_name }}\",\n+                    \"short\": true\n+                  }\n+                ],\n+                \"footer\": \"${{ github.workflow }} on schedule\",\n+                \"color\": \"danger\"\n+              }]\n+            }\n---\n\n\n---\n\nChoice D:\ngo.mod\n@@ -77,7 +77,7 @@ require (\n \tgithub.com/tailscale/certstore v0.1.1-0.20231202035212-d3fa0460f47e\n \tgithub.com/tailscale/depaware v0.0.0-20250112153213-b748de04d81b\n \tgithub.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41\n-\tgithub.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca\n+\tgithub.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869\n \tgithub.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05\n \tgithub.com/tailscale/hujson v0.0.0-20221223112325-20486734a56a\n \tgithub.com/tailscale/mkctr v0.0.0-20250228050937-c75ea1476830\n---\ngo.sum\n@@ -910,8 +910,8 @@ github.com/tailscale/go-winio v0.0.0-20231025203758-c4f33415bf55 h1:Gzfnfk2TWrk8\n github.com/tailscale/go-winio v0.0.0-20231025203758-c4f33415bf55/go.mod h1:4k4QO+dQ3R5FofL+SanAUZe+/QfeK0+OIuwDIRu2vSg=\n github.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41 h1:/V2rCMMWcsjYaYO2MeovLw+ClP63OtXgCF2Y1eb8+Ns=\n github.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41/go.mod h1:/roCdA6gg6lQyw/Oz6gIIGu3ggJKYhF+WC/AQReE5XQ=\n-github.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca h1:ecjHwH73Yvqf/oIdQ2vxAX+zc6caQsYdPzsxNW1J3G8=\n-github.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca/go.mod h1:ikbF+YT089eInTp9f2vmvy4+ZVnW5hzX1q2WknxSprQ=\n+github.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869 h1:SRL6irQkKGQKKLzvQP/ke/2ZuB7Py5+XuqtOgSj+iMM=\n+github.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869/go.mod h1:ikbF+YT089eInTp9f2vmvy4+ZVnW5hzX1q2WknxSprQ=\n github.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05 h1:4chzWmimtJPxRs2O36yuGRW3f9SYV+bMTTvMBI0EKio=\n github.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05/go.mod h1:PdCqy9JzfWMJf1H5UJW2ip33/d4YkoKN0r67yKH1mG8=\n github.com/tailscale/hujson v0.0.0-20221223112325-20486734a56a h1:SJy1Pu0eH1C29XwJucQo73FrleVK6t4kYz4NVhp34Yw=\n---\ntempfork/acme/acme.go\n@@ -270,10 +270,7 @@ func (c *Client) FetchRenewalInfo(ctx context.Context, leaf []byte) (*RenewalInf\n \t\treturn nil, fmt.Errorf(\"parsing leaf certificate: %w\", err)\n \t}\n \n-\trenewalURL, err := c.getRenewalURL(parsedLeaf)\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"generating renewal info URL: %w\", err)\n-\t}\n+\trenewalURL := c.getRenewalURL(parsedLeaf)\n \n \tres, err := c.get(ctx, renewalURL, wantStatus(http.StatusOK))\n \tif err != nil {\n@@ -288,16 +285,20 @@ func (c *Client) FetchRenewalInfo(ctx context.Context, leaf []byte) (*RenewalInf\n \treturn &info, nil\n }\n \n-func (c *Client) getRenewalURL(cert *x509.Certificate) (string, error) {\n+func (c *Client) getRenewalURL(cert *x509.Certificate) string {\n \t// See https://www.ietf.org/archive/id/draft-ietf-acme-ari-04.html#name-the-renewalinfo-resource\n \t// for how the request URL is built.\n \turl := c.dir.RenewalInfoURL\n \tif !strings.HasSuffix(url, \"/\") {\n \t\turl += \"/\"\n \t}\n+\treturn url + certRenewalIdentifier(cert)\n+}\n+\n+func certRenewalIdentifier(cert *x509.Certificate) string {\n \taki := base64.RawURLEncoding.EncodeToString(cert.AuthorityKeyId)\n \tserial := base64.RawURLEncoding.EncodeToString(cert.SerialNumber.Bytes())\n-\treturn fmt.Sprintf(\"%s%s.%s\", url, aki, serial), nil\n+\treturn aki + \".\" + serial\n }\n \n // AcceptTOS always returns true to indicate the acceptance of a CA's Terms of Service\n---\ntempfork/acme/acme_test.go\n@@ -549,10 +549,7 @@ func TestGetRenewalURL(t *testing.T) {\n \t}\n \n \tclient := newTestClientWithMockDirectory()\n-\turlString, err := client.getRenewalURL(parsedLeaf)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\turlString := client.getRenewalURL(parsedLeaf)\n \n \tparsedURL, err := url.Parse(urlString)\n \tif err != nil {\n---\ntempfork/acme/rfc8555.go\n@@ -7,6 +7,7 @@ package acme\n import (\n \t\"context\"\n \t\"crypto\"\n+\t\"crypto/x509\"\n \t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"encoding/pem\"\n@@ -205,6 +206,7 @@ func (c *Client) AuthorizeOrder(ctx context.Context, id []AuthzID, opt ...OrderO\n \t\tIdentifiers []wireAuthzID `json:\"identifiers\"`\n \t\tNotBefore   string        `json:\"notBefore,omitempty\"`\n \t\tNotAfter    string        `json:\"notAfter,omitempty\"`\n+\t\tReplaces    string        `json:\"replaces,omitempty\"`\n \t}{}\n \tfor _, v := range id {\n \t\treq.Identifiers = append(req.Identifiers, wireAuthzID{\n@@ -218,6 +220,14 @@ func (c *Client) AuthorizeOrder(ctx context.Context, id []AuthzID, opt ...OrderO\n \t\t\treq.NotBefore = time.Time(o).Format(time.RFC3339)\n \t\tcase orderNotAfterOpt:\n \t\t\treq.NotAfter = time.Time(o).Format(time.RFC3339)\n+\t\tcase orderReplacesCert:\n+\t\t\treq.Replaces = certRenewalIdentifier(o.cert)\n+\t\tcase orderReplacesCertDER:\n+\t\t\tcert, err := x509.ParseCertificate(o)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"failed to parse certificate being replaced: %w\", err)\n+\t\t\t}\n+\t\t\treq.Replaces = certRenewalIdentifier(cert)\n \t\tdefault:\n \t\t\t// Package's fault if we let this happen.\n \t\t\tpanic(fmt.Sprintf(\"unsupported order option type %T\", o))\n---\ntempfork/acme/rfc8555_test.go\n@@ -766,10 +766,17 @@ func TestRFC_AuthorizeOrder(t *testing.T) {\n \ts.start()\n \tdefer s.close()\n \n+\tprevCertDER, _ := pem.Decode([]byte(leafPEM))\n+\tprevCert, err := x509.ParseCertificate(prevCertDER.Bytes)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n \tcl := &Client{Key: testKeyEC, DirectoryURL: s.url(\"/\")}\n \to, err := cl.AuthorizeOrder(context.Background(), DomainIDs(\"example.org\"),\n \t\tWithOrderNotBefore(time.Date(2019, 8, 31, 0, 0, 0, 0, time.UTC)),\n \t\tWithOrderNotAfter(time.Date(2019, 9, 2, 0, 0, 0, 0, time.UTC)),\n+\t\tWithOrderReplacesCert(prevCert),\n \t)\n \tif err != nil {\n \t\tt.Fatal(err)\n---\ntempfork/acme/types.go\n@@ -391,6 +391,30 @@ type orderNotAfterOpt time.Time\n \n func (orderNotAfterOpt) privateOrderOpt() {}\n \n+// WithOrderReplacesCert indicates that this Order is for a replacement of an\n+// existing certificate.\n+// See https://datatracker.ietf.org/doc/html/draft-ietf-acme-ari-03#section-5\n+func WithOrderReplacesCert(cert *x509.Certificate) OrderOption {\n+\treturn orderReplacesCert{cert}\n+}\n+\n+type orderReplacesCert struct {\n+\tcert *x509.Certificate\n+}\n+\n+func (orderReplacesCert) privateOrderOpt() {}\n+\n+// WithOrderReplacesCertDER indicates that this Order is for a replacement of\n+// an existing DER-encoded certificate.\n+// See https://datatracker.ietf.org/doc/html/draft-ietf-acme-ari-03#section-5\n+func WithOrderReplacesCertDER(der []byte) OrderOption {\n+\treturn orderReplacesCertDER(der)\n+}\n+\n+type orderReplacesCertDER []byte\n+\n+func (orderReplacesCertDER) privateOrderOpt() {}\n+\n // Authorization encodes an authorization response.\n type Authorization struct {\n \t// URI uniquely identifies a authorization.\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis shouldn't be necessary, but while we're continuing to figure out the root cause, this is better than having to restart the app or switch profiles on the command line.\r\n\r\nUpdates #15528\r\n\r\nChange-Id: Ia101a4a3005adb9118051b3416f5a64a4a45987d\n\n---\n\nChoice A:\nfeature/taildrop/integration_test.go\n@@ -26,6 +26,21 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n+\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n+\ttestTaildropIntegration(t, false)\n+}\n+\n+func TestTaildropIntegration_Fresh(t *testing.T) {\n+\ttestTaildropIntegration(t, true)\n+}\n+\n+// freshProfiles is whether to start the test right away\n+// with a fresh profile. If false, tailscaled is started, stopped,\n+// and restarted again to simulate a real-world scenario where\n+// the first profile already existed.\n+//\n+// This exercises an ipnext hook ordering issue we hit earlier.\n+func testTaildropIntegration(t *testing.T, freshProfiles bool) {\n \ttstest.Parallel(t)\n \tcontrolOpt := integration.ConfigureControl(func(s *testcontrol.Server) {\n \t\ts.AllNodesSameUser = true // required for Taildrop\n@@ -39,18 +54,30 @@ func TestTaildropIntegration(t *testing.T) {\n \tn2 := integration.NewTestNode(t, env)\n \td2 := n2.StartDaemon()\n \n-\tn1.AwaitListening()\n-\tt.Logf(\"n1 is listening\")\n-\tn2.AwaitListening()\n-\tt.Logf(\"n2 is listening\")\n-\tn1.MustUp()\n-\tt.Logf(\"n1 is up\")\n-\tn2.MustUp()\n-\tt.Logf(\"n2 is up\")\n-\tn1.AwaitRunning()\n-\tt.Logf(\"n1 is running\")\n-\tn2.AwaitRunning()\n-\tt.Logf(\"n2 is running\")\n+\tawaitUp := func() {\n+\t\tt.Helper()\n+\t\tn1.AwaitListening()\n+\t\tt.Logf(\"n1 is listening\")\n+\t\tn2.AwaitListening()\n+\t\tt.Logf(\"n2 is listening\")\n+\t\tn1.MustUp()\n+\t\tt.Logf(\"n1 is up\")\n+\t\tn2.MustUp()\n+\t\tt.Logf(\"n2 is up\")\n+\t\tn1.AwaitRunning()\n+\t\tt.Logf(\"n1 is running\")\n+\t\tn2.AwaitRunning()\n+\t\tt.Logf(\"n2 is running\")\n+\t}\n+\tawaitUp()\n+\n+\tif !freshProfiles {\n+\t\td1.MustCleanShutdown(t)\n+\t\td2.MustCleanShutdown(t)\n+\t\td1 = n1.StartDaemon()\n+\t\td2 = n2.StartDaemon()\n+\t\tawaitUp()\n+\t}\n \n \tvar peerStableID tailcfg.StableNodeID\n \n---\n\n\n---\n\nChoice B:\ntstest/integration/integration.go\n@@ -684,7 +684,6 @@ func (n *TestNode) StartDaemonAsIPNGOOS(ipnGOOS string) *Daemon {\n \t\tcmd.Args = append(cmd.Args, \"--config=\"+n.configFile)\n \t}\n \tcmd.Env = append(os.Environ(),\n-\t\t\"TS_CONTROL_IS_PLAINTEXT_HTTP=1\",\n \t\t\"TS_DEBUG_PERMIT_HTTP_C2N=1\",\n \t\t\"TS_LOG_TARGET=\"+n.env.LogCatcherServer.URL,\n \t\t\"HTTP_PROXY=\"+n.env.TrafficTrapServer.URL,\n---\n\n\n---\n\nChoice C:\nipn/prefs.go\n@@ -607,9 +607,9 @@ func (p *Prefs) Equals(p2 *Prefs) bool {\n \t\tp.OperatorUser == p2.OperatorUser &&\n \t\tp.Hostname == p2.Hostname &&\n \t\tp.ForceDaemon == p2.ForceDaemon &&\n-\t\tcompareIPNets(p.AdvertiseRoutes, p2.AdvertiseRoutes) &&\n-\t\tcompareStrings(p.AdvertiseTags, p2.AdvertiseTags) &&\n-\t\tcompareStrings(p.AdvertiseServices, p2.AdvertiseServices) &&\n+\t\tslices.Equal(p.AdvertiseRoutes, p2.AdvertiseRoutes) &&\n+\t\tslices.Equal(p.AdvertiseTags, p2.AdvertiseTags) &&\n+\t\tslices.Equal(p.AdvertiseServices, p2.AdvertiseServices) &&\n \t\tp.Persist.Equals(p2.Persist) &&\n \t\tp.ProfileName == p2.ProfileName &&\n \t\tp.AutoUpdate.Equals(p2.AutoUpdate) &&\n@@ -636,30 +636,6 @@ func (ap AppConnectorPrefs) Pretty() string {\n \treturn \"\"\n }\n \n-func compareIPNets(a, b []netip.Prefix) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n-\tfor i := range a {\n-\t\tif a[i] != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-func compareStrings(a, b []string) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n-\tfor i := range a {\n-\t\tif a[i] != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n // NewPrefs returns the default preferences to use.\n func NewPrefs() *Prefs {\n \t// Provide default values for options which might be missing\n---\n\n\n---\n\nChoice D:\nclient/systray/systray.go\n@@ -84,12 +84,13 @@ type Menu struct {\n \tbgCancel context.CancelFunc\n \n \t// Top-level menu items\n-\tconnect    *systray.MenuItem\n-\tdisconnect *systray.MenuItem\n-\tself       *systray.MenuItem\n-\texitNodes  *systray.MenuItem\n-\tmore       *systray.MenuItem\n-\tquit       *systray.MenuItem\n+\tconnect     *systray.MenuItem\n+\tdisconnect  *systray.MenuItem\n+\tself        *systray.MenuItem\n+\texitNodes   *systray.MenuItem\n+\tmore        *systray.MenuItem\n+\trebuildMenu *systray.MenuItem\n+\tquit        *systray.MenuItem\n \n \trebuildCh  chan struct{} // triggers a menu rebuild\n \taccountsCh chan ipn.ProfileID\n@@ -295,6 +296,17 @@ func (menu *Menu) rebuild() {\n \t\t})\n \t}\n \n+\t// TODO(#15528): this menu item shouldn't be necessary at all,\n+\t// but is at least more discoverable than having users switch profiles or exit nodes.\n+\tmenu.rebuildMenu = systray.AddMenuItem(\"Rebuild menu\", \"Fix missing menu items\")\n+\tonClick(ctx, menu.rebuildMenu, func(ctx context.Context) {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\tcase menu.rebuildCh <- struct{}{}:\n+\t\t}\n+\t})\n+\tmenu.rebuildMenu.Enable()\n+\n \tmenu.quit = systray.AddMenuItem(\"Quit\", \"Quit the app\")\n \tmenu.quit.Enable()\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFix some minor typos in comments\n\n---\n\nChoice A:\nfeature/capture/dissector/ts-dissector.lua\n@@ -1,5 +1,5 @@\n function hasbit(x, p)\n-  return x % (p + p) >= p       \n+  return bit.band(x, p) ~= 0\n end\n \n tsdebug_ll = Proto(\"tsdebug\", \"Tailscale debug\")\n@@ -128,6 +128,10 @@ function tsdisco_frame.dissector(buffer, pinfo, tree)\n     if     message_type == 1 then subtree:add(DISCO_TYPE, \"Ping\")\n     elseif message_type == 2 then subtree:add(DISCO_TYPE, \"Pong\")\n     elseif message_type == 3 then subtree:add(DISCO_TYPE, \"Call me maybe\")\n+    elseif message_type == 4 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint\")\n+    elseif message_type == 5 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint Challenge\")\n+    elseif message_type == 6 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint Answer\")\n+    elseif message_type == 7 then subtree:add(DISCO_TYPE, \"Call me maybe via\")\n     end\n \n     -- Message version\n---\n\n\n---\n\nChoice B:\nposture/serialnumber_stub.go\n@@ -1,13 +1,12 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-// android: not implemented\n // js: not implemented\n // plan9: not implemented\n // solaris: currently unsupported by go-smbios:\n // https://github.com/digitalocean/go-smbios/pull/21\n \n-//go:build android || solaris || plan9 || js || wasm || tamago || aix || (darwin && !cgo && !ios)\n+//go:build solaris || plan9 || js || wasm || tamago || aix || (darwin && !cgo && !ios)\n \n package posture\n \n---\nposture/serialnumber_syspolicy.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build android || ios\n+\n package posture\n \n import (\n@@ -10,9 +12,9 @@ import (\n \t\"tailscale.com/util/syspolicy\"\n )\n \n-// GetSerialNumbers returns the serial number of the iOS/tvOS device as reported by an\n+// GetSerialNumbers returns the serial number of the device as reported by an\n // MDM solution. It requires configuration via the DeviceSerialNumber system policy.\n-// This is the only way to gather serial numbers on iOS and tvOS.\n+// This is the only way to gather serial numbers on iOS, tvOS and Android.\n func GetSerialNumbers(_ logger.Logf) ([]string, error) {\n \ts, err := syspolicy.GetString(syspolicy.DeviceSerialNumber, \"\")\n \tif err != nil {\n---\nutil/syspolicy/policy_keys.go\n@@ -126,8 +126,8 @@ const (\n \t// The default is \"user-decides\" unless otherwise stated.\n \tPostureChecking Key = \"PostureChecking\"\n \t// DeviceSerialNumber is the serial number of the device that is running Tailscale.\n-\t// This is used on iOS/tvOS to allow IT administrators to manually give us a serial number via MDM.\n-\t// We are unable to programmatically get the serial number from IOKit due to sandboxing restrictions.\n+\t// This is used on Android, iOS and tvOS to allow IT administrators to manually give us a serial number via MDM.\n+\t// We are unable to programmatically get the serial number on mobile due to sandboxing restrictions.\n \tDeviceSerialNumber Key = \"DeviceSerialNumber\"\n \n \t// ManagedByOrganizationName indicates the name of the organization managing the Tailscale\n---\n\n\n---\n\nChoice C:\ndrive/driveimpl/dirfs/dirfs.go\n@@ -44,7 +44,7 @@ func (c *Child) isAvailable() bool {\n // Any attempts to perform operations on paths inside of children will result\n // in a panic, as these are not expected to be performed on this FS.\n //\n-// An FS an optionally have a StaticRoot, which will insert a folder with that\n+// An FS can optionally have a StaticRoot, which will insert a folder with that\n // StaticRoot into the tree, like this:\n //\n // -- <StaticRoot>\n---\ndrive/driveimpl/fileserver.go\n@@ -61,7 +61,7 @@ func NewFileServer() (*FileServer, error) {\n \t}, nil\n }\n \n-// generateSecretToken generates a hex-encoded 256 bit secet.\n+// generateSecretToken generates a hex-encoded 256 bit secret.\n func generateSecretToken() (string, error) {\n \ttokenBytes := make([]byte, 32)\n \t_, err := rand.Read(tokenBytes)\n---\ndrive/remote_permissions.go\n@@ -32,7 +32,7 @@ type grant struct {\n \tAccess string\n }\n \n-// ParsePermissions builds a Permissions map from a lis of raw grants.\n+// ParsePermissions builds a Permissions map from a list of raw grants.\n func ParsePermissions(rawGrants [][]byte) (Permissions, error) {\n \tpermissions := make(Permissions)\n \tfor _, rawGrant := range rawGrants {\n---\n\n\n---\n\nChoice D:\ncontrol/controlclient/map_test.go\n@@ -17,6 +17,7 @@ import (\n \t\"github.com/google/go-cmp/cmp\"\n \t\"go4.org/mem\"\n \t\"tailscale.com/control/controlknobs\"\n+\t\"tailscale.com/health\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/tstime\"\n@@ -1136,3 +1137,34 @@ func BenchmarkMapSessionDelta(b *testing.B) {\n \t\t})\n \t}\n }\n+\n+// TestNetmapHealthIntegration checks that we get the expected health warnings\n+// from processing a map response and passing the NetworkMap to a health tracker\n+func TestNetmapHealthIntegration(t *testing.T) {\n+\tms := newTestMapSession(t, nil)\n+\tht := health.Tracker{}\n+\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tnm := ms.netmapForResponse(&tailcfg.MapResponse{\n+\t\tHealth: []string{\"Test message\"},\n+\t})\n+\tht.SetControlHealth(nm.ControlHealth)\n+\n+\tstate := ht.CurrentState()\n+\twarning, ok := state.Warnings[\"control-health\"]\n+\n+\tif !ok {\n+\t\tt.Fatal(\"no warning found in current state with code 'control-health'\")\n+\t}\n+\tif got, want := warning.Title, \"Coordination server reports an issue\"; got != want {\n+\t\tt.Errorf(\"warning.Title = %q, want %q\", got, want)\n+\t}\n+\tif got, want := warning.Severity, health.SeverityMedium; got != want {\n+\t\tt.Errorf(\"warning.Severity = %s, want %s\", got, want)\n+\t}\n+\tif got, want := warning.Text, \"The coordination server is reporting an health issue: Test message\"; got != want {\n+\t\tt.Errorf(\"warning.Text = %q, want %q\", got, want)\n+\t}\n+}\n---\nhealth/health.go\n@@ -402,7 +402,7 @@ func (t *Tracker) setUnhealthyLocked(w *Warnable, args Args) {\n \t\t\t// executed immediately. Otherwise, the callback should be enqueued to run once the Warnable\n \t\t\t// becomes visible.\n \t\t\tif w.IsVisible(ws, t.now) {\n-\t\t\t\tgo cb(w, w.unhealthyState(ws))\n+\t\t\t\tcb(w, w.unhealthyState(ws))\n \t\t\t\tcontinue\n \t\t\t}\n \n@@ -415,7 +415,7 @@ func (t *Tracker) setUnhealthyLocked(w *Warnable, args Args) {\n \t\t\t\t// Check if the Warnable is still unhealthy, as it could have become healthy between the time\n \t\t\t\t// the timer was set for and the time it was executed.\n \t\t\t\tif t.warnableVal[w] != nil {\n-\t\t\t\t\tgo cb(w, w.unhealthyState(ws))\n+\t\t\t\t\tcb(w, w.unhealthyState(ws))\n \t\t\t\t\tdelete(t.pendingVisibleTimers, w)\n \t\t\t\t}\n \t\t\t})\n@@ -449,7 +449,7 @@ func (t *Tracker) setHealthyLocked(w *Warnable) {\n \t}\n \n \tfor _, cb := range t.watchers {\n-\t\tgo cb(w, nil)\n+\t\tcb(w, nil)\n \t}\n }\n \n@@ -483,6 +483,16 @@ func (t *Tracker) AppendWarnableDebugFlags(base []string) []string {\n // The provided callback function will be executed in its own goroutine. The returned function can be used\n // to unregister the callback.\n func (t *Tracker) RegisterWatcher(cb func(w *Warnable, r *UnhealthyState)) (unregister func()) {\n+\treturn t.registerSyncWatcher(func(w *Warnable, r *UnhealthyState) {\n+\t\tgo cb(w, r)\n+\t})\n+}\n+\n+// registerSyncWatcher adds a function that will be called whenever the health\n+// state of any Warnable changes. The provided callback function will be\n+// executed synchronously. Call RegisterWatcher to register any callbacks that\n+// won't return from execution immediately.\n+func (t *Tracker) registerSyncWatcher(cb func(w *Warnable, r *UnhealthyState)) (unregister func()) {\n \tif t.nil() {\n \t\treturn func() {}\n \t}\n---\nhealth/health_test.go\n@@ -451,3 +451,88 @@ func TestNoDERPHomeWarnableManual(t *testing.T) {\n \t\tt.Fatalf(\"got unexpected noDERPHomeWarnable warnable: %v\", ws)\n \t}\n }\n+\n+func TestControlHealth(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\tstate := ht.CurrentState()\n+\twarning, ok := state.Warnings[\"control-health\"]\n+\n+\tif !ok {\n+\t\tt.Fatal(\"no warning found in current state with code 'control-health'\")\n+\t}\n+\tif got, want := warning.Title, \"Coordination server reports an issue\"; got != want {\n+\t\tt.Errorf(\"warning.Title = %q, want %q\", got, want)\n+\t}\n+\tif got, want := warning.Severity, SeverityMedium; got != want {\n+\t\tt.Errorf(\"warning.Severity = %s, want %s\", got, want)\n+\t}\n+\tif got, want := warning.Text, \"The coordination server is reporting an health issue: Test message\"; got != want {\n+\t\tt.Errorf(\"warning.Text = %q, want %q\", got, want)\n+\t}\n+}\n+\n+func TestControlHealthNotifiesOnChange(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tif !gotNotified {\n+\t\tt.Errorf(\"watcher did not get called, want it to be called\")\n+\t}\n+}\n+\n+func TestControlHealthNoNotifyOnUnchanged(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\t// Set up an existing control health issue\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\t// Now register our watcher\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\t// Send the same control health message again - should not notify\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tif gotNotified {\n+\t\tt.Errorf(\"watcher got called, want it to not be called\")\n+\t}\n+}\n+\n+func TestControlHealthIgnoredOutsideMapPoll(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tstate := ht.CurrentState()\n+\t_, ok := state.Warnings[\"control-health\"]\n+\n+\tif ok {\n+\t\tt.Error(\"got a warning with code 'control-health', want none\")\n+\t}\n+\n+\tif gotNotified {\n+\t\tt.Error(\"watcher got called, want it to not be called\")\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAndroid >=14 forbids the use of netlink sockets by apps, which results in either initialization failures or getting killed by the sandbox.\r\n\r\nThis should not affect the Tailscale android app in https://github.com/tailscale/tailscale-android, since it uses its own libtailscale shim to construct a data plane with a router that plugs into Android's native networking APIs. This only affects builds of tsnet programs targeting android, since without the additional logic from tailscale-android, Go considers `android` to be a subset of the `linux` GOOS, and thus selects implementations that try to use netlink.\r\n\r\nFixes #9836\r\n\r\n---\r\n\r\nI don't love sprinkling more build tags to deal with this, better HAL APIs would be preferable... But tactically, this unblocks other work until we get to refactors.\n\n---\n\nChoice A:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/init@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/autobuild@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/analyze@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n---\n\n\n---\n\nChoice B:\nwgengine/magicsock/magicsock_linux.go\n@@ -66,10 +66,10 @@ var (\n \t\t// fragmented, and we don't want to handle reassembly.\n \t\tbpf.LoadAbsolute{Off: 6, Size: 2},\n \t\t// More Fragments bit set means this is part of a fragmented packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 7, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 8, SkipFalse: 0},\n \t\t// Non-zero fragment offset with MF=0 means this is the last\n \t\t// fragment of packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 6, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 7, SkipFalse: 0},\n \n \t\t// Load IP header length into X register.\n \t\tbpf.LoadMemShift{Off: 0},\n---\nwgengine/magicsock/magicsock_linux_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"net/netip\"\n \t\"testing\"\n \n+\t\"golang.org/x/net/bpf\"\n \t\"golang.org/x/sys/cpu\"\n \t\"golang.org/x/sys/unix\"\n \t\"tailscale.com/disco\"\n@@ -146,3 +147,78 @@ func TestEthernetProto(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestBpfDiscardV4(t *testing.T) {\n+\t// Good packet as a reference for what should not be rejected\n+\tudp4Packet := []byte{\n+\t\t// IPv4 header\n+\t\t0x45, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x40, 0x11, 0x00, 0x00,\n+\t\t0x7f, 0x00, 0x00, 0x01, // source ip\n+\t\t0x7f, 0x00, 0x00, 0x02, // dest ip\n+\n+\t\t// UDP header\n+\t\t0x30, 0x39, // src port\n+\t\t0xd4, 0x31, // dest port\n+\t\t0x00, 0x12, // length; 8 bytes header + 10 bytes payload = 18 bytes\n+\t\t0x00, 0x00, // checksum; unused\n+\n+\t\t// Payload: disco magic plus 32 bytes for key and 24 bytes for nonce\n+\t\t0x54, 0x53, 0xf0, 0x9f, 0x92, 0xac, 0x00, 0x01, 0x02, 0x03,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n+\t}\n+\n+\tvm, err := bpf.NewVM(magicsockFilterV4)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed creating BPF VM: %v\", err)\n+\t}\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\treplace map[int]byte\n+\t\taccept  bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"base accepted datagram\",\n+\t\t\treplace: map[int]byte{},\n+\t\t\taccept:  true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"more fragments\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t6: 0x20,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some fragment\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t7: 0x01,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t}\n+\n+\tudp4PacketChanged := make([]byte, len(udp4Packet))\n+\tcopy(udp4PacketChanged, udp4Packet)\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfor k, v := range tt.replace {\n+\t\t\t\tudp4PacketChanged[k] = v\n+\t\t\t}\n+\t\t\tret, err := vm.Run(udp4PacketChanged)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"BPF VM error: %v\", err)\n+\t\t\t}\n+\n+\t\t\tif (ret != 0) != tt.accept {\n+\t\t\t\tt.Errorf(\"expected accept=%v, got ret=%v\", tt.accept, ret)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\nnet/routetable/routetable_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package routetable\n \n---\nnet/routetable/routetable_other.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux && !darwin && !freebsd\n+//go:build android || (!linux && !darwin && !freebsd)\n \n package routetable\n \n---\nnet/tstun/linkattrs_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android\n+\n package tstun\n \n import (\n---\nnet/tstun/linkattrs_notlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux || android\n \n package tstun\n \n---\nwgengine/router/router_android.go\n@@ -0,0 +1,29 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build android\n+\n+package router\n+\n+import (\n+\t\"github.com/tailscale/wireguard-go/tun\"\n+\t\"tailscale.com/health\"\n+\t\"tailscale.com/net/netmon\"\n+\t\"tailscale.com/types/logger\"\n+)\n+\n+func newUserspaceRouter(logf logger.Logf, tunDev tun.Device, netMon *netmon.Monitor, health *health.Tracker) (Router, error) {\n+\t// Note, this codepath is _not_ used when building the android app\n+\t// from github.com/tailscale/tailscale-android. The android app\n+\t// constructs its own wgengine with a custom router implementation\n+\t// that plugs into Android networking APIs.\n+\t//\n+\t// In practice, the only place this fake router gets used is when\n+\t// you build a tsnet app for android, in which case we don't want\n+\t// to touch the OS network stack and a no-op router is correct.\n+\treturn NewFake(logf), nil\n+}\n+\n+func cleanUp(logf logger.Logf, interfaceName string) {\n+\t// Nothing to do here.\n+}\n---\nwgengine/router/router_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android\n+\n package router\n \n import (\n---\n\n\n---\n\nChoice D:\nwgengine/magicsock/endpoint.go\n@@ -820,7 +820,7 @@ func (de *endpoint) heartbeat() {\n \n \tudpAddr, _, _ := de.addrForSendLocked(now)\n \tif udpAddr.IsValid() {\n-\t\t// We have a preferred path. Ping that every 2 seconds.\n+\t\t// We have a preferred path. Ping that every 'heartbeatInterval'.\n \t\tde.startDiscoPingLocked(udpAddr, now, pingHeartbeat, 0, nil)\n \t}\n \n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFix the index out of bound panic when a request is made to the local fileserver mux with a valid secret-token, but missing share name.\r\n\r\nExample error:\r\nhttp: panic serving 127.0.0.1:40974: runtime error: slice bounds out of range [2:1]\r\n\r\nAdditionally, we documentation the edge case behavior of utilities that this fileserver mux depends on.\n\n---\n\nChoice A:\ncmd/natc/ippool/ippool.go\n@@ -24,7 +24,6 @@ var ErrNoIPsAvailable = errors.New(\"no IPs available\")\n type IPPool struct {\n \tperPeerMap syncs.Map[tailcfg.NodeID, *perPeerState]\n \tIPSet      *netipx.IPSet\n-\tV6ULA      netip.Prefix\n }\n \n func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bool) {\n@@ -44,15 +43,13 @@ func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bo\n func (ipp *IPPool) IPForDomain(from tailcfg.NodeID, domain string) (netip.Addr, error) {\n \tnpps := &perPeerState{\n \t\tipset: ipp.IPSet,\n-\t\tv6ULA: ipp.V6ULA,\n \t}\n \tps, _ := ipp.perPeerMap.LoadOrStore(from, npps)\n \treturn ps.ipForDomain(domain)\n }\n \n // perPeerState holds the state for a single peer.\n type perPeerState struct {\n-\tv6ULA netip.Prefix\n \tipset *netipx.IPSet\n \n \tmu           sync.Mutex\n---\ncmd/natc/ippool/ippool_test.go\n@@ -19,8 +19,7 @@ func TestIPPoolExhaustion(t *testing.T) {\n \tvar ipsb netipx.IPSetBuilder\n \tipsb.AddPrefix(smallPrefix)\n \taddrPool := must.Get(ipsb.IPSet())\n-\tv6ULA := netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\")\n-\tpool := IPPool{V6ULA: v6ULA, IPSet: addrPool}\n+\tpool := IPPool{IPSet: addrPool}\n \n \tassignedIPs := make(map[netip.Addr]string)\n \n@@ -52,9 +51,6 @@ func TestIPPoolExhaustion(t *testing.T) {\n \t\tif addr.Is4() && !smallPrefix.Contains(addr) {\n \t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, smallPrefix)\n \t\t}\n-\t\tif addr.Is6() && !v6ULA.Contains(addr) {\n-\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, v6ULA)\n-\t\t}\n \t}\n \n \t// expect one error for each iteration with the 5th domain\n@@ -73,7 +69,6 @@ func TestIPPool(t *testing.T) {\n \tipsb.AddPrefix(netip.MustParsePrefix(\"100.64.1.0/24\"))\n \taddrPool := must.Get(ipsb.IPSet())\n \tpool := IPPool{\n-\t\tV6ULA: netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n \t\tIPSet: addrPool,\n \t}\n \tfrom := tailcfg.NodeID(12345)\n---\ncmd/natc/natc.go\n@@ -153,7 +153,7 @@ func main() {\n \t\twhois:      lc,\n \t\tv6ULA:      v6ULA,\n \t\tignoreDsts: ignoreDstTable,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\troutes:     routes,\n \t\tdnsAddr:    dnsAddr,\n \t\tresolver:   net.DefaultResolver,\n---\ncmd/natc/natc_test.go\n@@ -270,7 +270,7 @@ func TestDNSResponse(t *testing.T) {\n \t\tignoreDsts: &bart.Table[bool]{},\n \t\troutes:     routes,\n \t\tv6ULA:      v6ULA,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\tdnsAddr:    dnsAddr,\n \t}\n \tc.ignoreDsts.Insert(netip.MustParsePrefix(\"8.8.4.4/32\"), true)\n---\n\n\n---\n\nChoice B:\ndrive/driveimpl/drive_test.go\n@@ -133,6 +133,71 @@ func TestPermissions(t *testing.T) {\n \t}\n }\n \n+// TestMissingPaths verifies that the fileserver running at localhost\n+// correctly handles paths with missing required components.\n+//\n+// Expected path format:\n+// http://localhost:[PORT]/<secretToken>/<share>[/<subSharePath...>]\n+func TestMissingPaths(t *testing.T) {\n+\ts := newSystem(t)\n+\n+\tfileserverAddr := s.addRemote(remote1)\n+\ts.addShare(remote1, share11, drive.PermissionReadWrite)\n+\n+\tclient := &http.Client{\n+\t\tTransport: &http.Transport{DisableKeepAlives: true},\n+\t}\n+\taddr := strings.Split(fileserverAddr, \"|\")[1]\n+\tsecretToken := strings.Split(fileserverAddr, \"|\")[0]\n+\n+\ttestCases := []struct {\n+\t\tname       string\n+\t\tpath       string\n+\t\twantStatus int\n+\t}{\n+\t\t{\n+\t\t\tname:       \"empty path\",\n+\t\t\tpath:       \"\",\n+\t\t\twantStatus: http.StatusForbidden,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"single slash\",\n+\t\t\tpath:       \"/\",\n+\t\t\twantStatus: http.StatusForbidden,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"only token\",\n+\t\t\tpath:       \"/\" + secretToken,\n+\t\t\twantStatus: http.StatusBadRequest,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"token with trailing slash\",\n+\t\t\tpath:       \"/\" + secretToken + \"/\",\n+\t\t\twantStatus: http.StatusBadRequest,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"token and invalid share\",\n+\t\t\tpath:       \"/\" + secretToken + \"/nonexistentshare\",\n+\t\t\twantStatus: http.StatusNotFound,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tu := fmt.Sprintf(\"http://%s%s\", addr, tc.path)\n+\t\t\tresp, err := client.Get(u)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"unexpected error making request: %v\", err)\n+\t\t\t}\n+\t\t\tdefer resp.Body.Close()\n+\n+\t\t\tif resp.StatusCode != tc.wantStatus {\n+\t\t\t\tt.Errorf(\"got status code %d, want %d\", resp.StatusCode, tc.wantStatus)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n // TestSecretTokenAuth verifies that the fileserver running at localhost cannot\n // be accessed directly without the correct secret token. This matters because\n // if a victim can be induced to visit the localhost URL and access a malicious\n@@ -704,8 +769,8 @@ func (a *noopAuthenticator) Close() error {\n \treturn nil\n }\n \n-const lockBody = `<?xml version=\"1.0\" encoding=\"utf-8\" ?> \n-<D:lockinfo xmlns:D='DAV:'> \n-  <D:lockscope><D:exclusive/></D:lockscope> \n-  <D:locktype><D:write/></D:locktype> \n+const lockBody = `<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n+<D:lockinfo xmlns:D='DAV:'>\n+  <D:lockscope><D:exclusive/></D:lockscope>\n+  <D:locktype><D:write/></D:locktype>\n </D:lockinfo>`\n---\ndrive/driveimpl/fileserver.go\n@@ -142,6 +142,10 @@ func (s *FileServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n \t\treturn\n \t}\n \n+\tif len(parts) < 2 {\n+\t\tw.WriteHeader(http.StatusBadRequest)\n+\t\treturn\n+\t}\n \tr.URL.Path = shared.Join(parts[2:]...)\n \tshare := parts[1]\n \ts.sharesMu.RLock()\n---\ndrive/driveimpl/shared/pathutil.go\n@@ -22,6 +22,9 @@ const (\n // CleanAndSplit cleans the provided path p and splits it into its constituent\n // parts. This is different from path.Split which just splits a path into prefix\n // and suffix.\n+//\n+// If p is empty or contains only path separators, CleanAndSplit returns a slice\n+// of length 1 whose only element is \"\".\n func CleanAndSplit(p string) []string {\n \treturn strings.Split(strings.Trim(path.Clean(p), sepStringAndDot), sepString)\n }\n@@ -38,6 +41,8 @@ func Parent(p string) string {\n }\n \n // Join behaves like path.Join() but also includes a leading slash.\n+//\n+// When parts are missing, the result is \"/\".\n func Join(parts ...string) string {\n \tfullParts := make([]string, 0, len(parts))\n \tfullParts = append(fullParts, sepString)\n---\ndrive/driveimpl/shared/pathutil_test.go\n@@ -40,6 +40,7 @@ func TestJoin(t *testing.T) {\n \t\tparts []string\n \t\twant  string\n \t}{\n+\t\t{[]string{}, \"/\"},\n \t\t{[]string{\"\"}, \"/\"},\n \t\t{[]string{\"a\"}, \"/a\"},\n \t\t{[]string{\"/a\"}, \"/a\"},\n---\n\n\n---\n\nChoice C:\n.github/workflows/installer.yml\n@@ -1,6 +1,8 @@\n name: test installer.sh\n \n on:\n+  schedule:\n+    - cron: '0 15 * * *' # 10am EST (UTC-4/5)\n   push:\n     branches:\n       - \"main\"\n@@ -72,10 +74,10 @@ jobs:\n       # tar and gzip are needed by the actions/checkout below.\n       run: yum install -y --allowerasing tar gzip ${{ matrix.deps }}\n       if: |\n-        contains(matrix.image, 'centos')\n-        || contains(matrix.image, 'oraclelinux')\n-        || contains(matrix.image, 'fedora')\n-        || contains(matrix.image, 'amazonlinux')\n+        contains(matrix.image, 'centos') ||\n+        contains(matrix.image, 'oraclelinux') ||\n+        contains(matrix.image, 'fedora') ||\n+        contains(matrix.image, 'amazonlinux')\n     - name: install dependencies (zypper)\n       # tar and gzip are needed by the actions/checkout below.\n       run: zypper --non-interactive install tar gzip ${{ matrix.deps }}\n@@ -85,11 +87,11 @@ jobs:\n         apt-get update\n         apt-get install -y ${{ matrix.deps }}\n       if: |\n-        contains(matrix.image, 'debian')\n-        || contains(matrix.image, 'ubuntu')\n-        || contains(matrix.image, 'elementary')\n-        || contains(matrix.image, 'parrotsec')\n-        || contains(matrix.image, 'kalilinux')\n+        contains(matrix.image, 'debian') ||\n+        contains(matrix.image, 'ubuntu') ||\n+        contains(matrix.image, 'elementary') ||\n+        contains(matrix.image, 'parrotsec') ||\n+        contains(matrix.image, 'kalilinux')\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: run installer\n@@ -100,3 +102,30 @@ jobs:\n       continue-on-error: true\n     - name: check tailscale version\n       run: tailscale --version\n+  notify-slack:\n+    needs: test\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Notify Slack of failure on scheduled runs\n+        if: failure() && github.event_name == 'schedule'\n+        uses: slackapi/slack-github-action@485a9d42d3a73031f12ec201c457e2162c45d02d # v2.0.0\n+        with:\n+          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}\n+          webhook-type: incoming-webhook\n+          payload: |\n+            {\n+              \"attachments\": [{\n+                \"title\": \"Tailscale installer test failed\",\n+                \"title_link\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\n+                \"text\": \"One or more OSes in the test matrix failed. See the run for details.\",\n+                \"fields\": [\n+                  {\n+                    \"title\": \"Ref\",\n+                    \"value\": \"${{ github.ref_name }}\",\n+                    \"short\": true\n+                  }\n+                ],\n+                \"footer\": \"${{ github.workflow }} on schedule\",\n+                \"color\": \"danger\"\n+              }]\n+            }\n---\n\n\n---\n\nChoice D:\ntstest/integration/testcontrol/testcontrol.go\n@@ -839,15 +839,17 @@ func (s *Server) serveMap(w http.ResponseWriter, r *http.Request, mkey key.Machi\n \n \tw.WriteHeader(200)\n \tfor {\n-\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n-\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n-\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif streaming {\n+\t\t// Only send raw map responses to the streaming poll, to avoid a\n+\t\t// non-streaming map request beating the streaming poll in a race and\n+\t\t// potentially dropping the map response.\n+\t\tif streaming {\n+\t\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n+\t\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n+\t\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treturn\n \t\t}\n \n \t\tif s.canGenerateAutomaticMapResponseFor(req.NodeKey) {\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\nutil/testenv/testenv.go\n@@ -6,6 +6,7 @@\n package testenv\n \n import (\n+\t\"context\"\n \t\"flag\"\n \n \t\"tailscale.com/types/lazy\"\n@@ -19,3 +20,41 @@ func InTest() bool {\n \t\treturn flag.Lookup(\"test.v\") != nil\n \t})\n }\n+\n+// TB is testing.TB, to avoid importing \"testing\" in non-test code.\n+type TB interface {\n+\tCleanup(func())\n+\tError(args ...any)\n+\tErrorf(format string, args ...any)\n+\tFail()\n+\tFailNow()\n+\tFailed() bool\n+\tFatal(args ...any)\n+\tFatalf(format string, args ...any)\n+\tHelper()\n+\tLog(args ...any)\n+\tLogf(format string, args ...any)\n+\tName() string\n+\tSetenv(key, value string)\n+\tChdir(dir string)\n+\tSkip(args ...any)\n+\tSkipNow()\n+\tSkipf(format string, args ...any)\n+\tSkipped() bool\n+\tTempDir() string\n+\tContext() context.Context\n+}\n+\n+// InParallelTest reports whether t is running as a parallel test.\n+//\n+// Use of this function taints t such that its Parallel method (assuming t is an\n+// actual *testing.T) will panic if called after this function.\n+func InParallelTest(t TB) (isParallel bool) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tisParallel = true\n+\t\t}\n+\t}()\n+\tt.Chdir(\".\") // panics in a t.Parallel test\n+\treturn false\n+}\n---\nutil/testenv/testenv_test.go\n@@ -16,3 +16,16 @@ func TestDeps(t *testing.T) {\n \t\t},\n \t}.Check(t)\n }\n+\n+func TestInParallelTestTrue(t *testing.T) {\n+\tt.Parallel()\n+\tif !InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return true once t.Parallel has been called\")\n+\t}\n+}\n+\n+func TestInParallelTestFalse(t *testing.T) {\n+\tif InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return false before t.Parallel has been called\")\n+\t}\n+}\n---\n\n\n---\n\nChoice B:\ntailcfg/tailcfg.go\n@@ -1462,6 +1462,13 @@ const (\n \t// user groups as Kubernetes user groups. This capability is read by\n \t// peers that are Tailscale Kubernetes operator instances.\n \tPeerCapabilityKubernetes PeerCapability = \"tailscale.com/cap/kubernetes\"\n+\n+\t// PeerCapabilityRelay grants the ability for a peer to allocate relay\n+\t// endpoints.\n+\tPeerCapabilityRelay PeerCapability = \"tailscale.com/cap/relay\"\n+\t// PeerCapabilityRelayTarget grants the current node the ability to allocate\n+\t// relay endpoints to the peer which has this capability.\n+\tPeerCapabilityRelayTarget PeerCapability = \"tailscale.com/cap/relay-target\"\n )\n \n // NodeCapMap is a map of capabilities to their optional values. It is valid for\n---\n\n\n---\n\nChoice C:\nclient/systray/systray.go\n@@ -84,12 +84,13 @@ type Menu struct {\n \tbgCancel context.CancelFunc\n \n \t// Top-level menu items\n-\tconnect    *systray.MenuItem\n-\tdisconnect *systray.MenuItem\n-\tself       *systray.MenuItem\n-\texitNodes  *systray.MenuItem\n-\tmore       *systray.MenuItem\n-\tquit       *systray.MenuItem\n+\tconnect     *systray.MenuItem\n+\tdisconnect  *systray.MenuItem\n+\tself        *systray.MenuItem\n+\texitNodes   *systray.MenuItem\n+\tmore        *systray.MenuItem\n+\trebuildMenu *systray.MenuItem\n+\tquit        *systray.MenuItem\n \n \trebuildCh  chan struct{} // triggers a menu rebuild\n \taccountsCh chan ipn.ProfileID\n@@ -295,6 +296,17 @@ func (menu *Menu) rebuild() {\n \t\t})\n \t}\n \n+\t// TODO(#15528): this menu item shouldn't be necessary at all,\n+\t// but is at least more discoverable than having users switch profiles or exit nodes.\n+\tmenu.rebuildMenu = systray.AddMenuItem(\"Rebuild menu\", \"Fix missing menu items\")\n+\tonClick(ctx, menu.rebuildMenu, func(ctx context.Context) {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\tcase menu.rebuildCh <- struct{}{}:\n+\t\t}\n+\t})\n+\tmenu.rebuildMenu.Enable()\n+\n \tmenu.quit = systray.AddMenuItem(\"Quit\", \"Quit the app\")\n \tmenu.quit.Enable()\n \n---\n\n\n---\n\nChoice D:\nscripts/installer.sh\n@@ -208,8 +208,11 @@ main() {\n \t\t\t\t\tPACKAGETYPE=\"yum\"\n \t\t\t\tfi\n \t\t\t\t;;\n-\t\t\trhel)\n+\t\t\trhel|miraclelinux)\n \t\t\t\tOS=\"$ID\"\n+\t\t\t\tif [ \"$ID\" = \"miraclelinux\" ]; then\n+\t\t\t\t\tOS=\"rhel\"\n+\t\t\t\tfi\n \t\t\t\tVERSION=\"$(echo \"$VERSION_ID\" | cut -f1 -d.)\"\n \t\t\t\tPACKAGETYPE=\"dnf\"\n \t\t\t\tif [ \"$VERSION\" = \"7\" ]; then\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #cleanup\n\n---\n\nChoice A:\nipn/prefs.go\n@@ -721,9 +721,10 @@ func (p *Prefs) ControlURLOrDefault() string {\n // of the platform it's running on.\n func (p *Prefs) DefaultRouteAll(goos string) bool {\n \tswitch goos {\n-\tcase \"windows\":\n+\tcase \"windows\", \"android\", \"ios\":\n \t\treturn true\n \tcase \"darwin\":\n+\t\t// Only true for macAppStore and macsys, false for darwin tailscaled.\n \t\treturn version.IsSandboxedMacOS()\n \tdefault:\n \t\treturn false\n---\n\n\n---\n\nChoice B:\nipn/ipnstate/ipnstate.go\n@@ -53,9 +53,6 @@ type Status struct {\n \t// If nil, an exit node is not in use.\n \tExitNodeStatus *ExitNodeStatus `json:\"ExitNodeStatus,omitempty\"`\n \n-\t// DERPHomeRegionID is the current home DERP region ID.\n-\tDERPHomeRegionID int\n-\n \t// Health contains health check problems.\n \t// Empty means everything is good. (or at least that no known\n \t// problems are detected)\n---\nwgengine/magicsock/magicsock.go\n@@ -2892,15 +2892,11 @@ func (c *Conn) UpdateStatus(sb *ipnstate.StatusBuilder) {\n \t\t})\n \t}\n \n-\tsb.MutateStatus(func(s *ipnstate.Status) {\n-\t\ts.DERPHomeRegionID = c.myDerp\n-\t\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n-\t\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n-\t\t\t// to include all the DERP connections we have open\n-\t\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n-\t\t})\n+\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n+\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n+\t\t// to include all the DERP connections we have open\n+\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n \t})\n-\n }\n \n // SetStatistics specifies a per-connection statistics aggregator.\n---\n\n\n---\n\nChoice C:\nnet/udprelay/server.go\n@@ -21,6 +21,7 @@ import (\n \t\"go4.org/mem\"\n \t\"tailscale.com/disco\"\n \t\"tailscale.com/net/packet\"\n+\t\"tailscale.com/tstime\"\n \t\"tailscale.com/types/key\"\n )\n \n@@ -114,12 +115,12 @@ type ServerEndpoint struct {\n \t// BindLifetime is amount of time post-allocation the Server will consider\n \t// the endpoint active while it has yet to be bound via 3-way bind handshake\n \t// from both client parties.\n-\tBindLifetime time.Duration\n+\tBindLifetime tstime.GoDuration\n \n \t// SteadyStateLifetime is the amount of time post 3-way bind handshake from\n \t// both client parties the Server will consider the endpoint active lacking\n \t// bidirectional data flow.\n-\tSteadyStateLifetime time.Duration\n+\tSteadyStateLifetime tstime.GoDuration\n }\n \n // serverEndpoint contains Server-internal ServerEndpoint state. serverEndpoint\n@@ -489,8 +490,8 @@ func (s *Server) AllocateEndpoint(discoA, discoB key.DiscoPublic) (ServerEndpoin\n \t\t\t\tAddrPorts:           s.addrPorts,\n \t\t\t\tVNI:                 e.vni,\n \t\t\t\tLamportID:           e.lamportID,\n-\t\t\t\tBindLifetime:        s.bindLifetime,\n-\t\t\t\tSteadyStateLifetime: s.steadyStateLifetime,\n+\t\t\t\tBindLifetime:        tstime.GoDuration{Duration: s.bindLifetime},\n+\t\t\t\tSteadyStateLifetime: tstime.GoDuration{Duration: s.steadyStateLifetime},\n \t\t\t}, nil\n \t\t}\n \t\t// If an endpoint exists for the pair of key.DiscoPublic's, and is\n@@ -526,7 +527,7 @@ func (s *Server) AllocateEndpoint(discoA, discoB key.DiscoPublic) (ServerEndpoin\n \t\tAddrPorts:           s.addrPorts,\n \t\tVNI:                 e.vni,\n \t\tLamportID:           e.lamportID,\n-\t\tBindLifetime:        s.bindLifetime,\n-\t\tSteadyStateLifetime: s.steadyStateLifetime,\n+\t\tBindLifetime:        tstime.GoDuration{Duration: s.bindLifetime},\n+\t\tSteadyStateLifetime: tstime.GoDuration{Duration: s.steadyStateLifetime},\n \t}, nil\n }\n---\nnet/udprelay/server_test.go\n@@ -5,6 +5,8 @@ package udprelay\n \n import (\n \t\"bytes\"\n+\t\"encoding/json\"\n+\t\"math\"\n \t\"net\"\n \t\"net/netip\"\n \t\"testing\"\n@@ -15,6 +17,7 @@ import (\n \t\"go4.org/mem\"\n \t\"tailscale.com/disco\"\n \t\"tailscale.com/net/packet\"\n+\t\"tailscale.com/tstime\"\n \t\"tailscale.com/types/key\"\n )\n \n@@ -202,3 +205,96 @@ func TestServer(t *testing.T) {\n \t\tt.Fatal(\"unexpected msg B->A\")\n \t}\n }\n+\n+func TestServerEndpointJSONUnmarshal(t *testing.T) {\n+\ttests := []struct {\n+\t\tname    string\n+\t\tjson    []byte\n+\t\twantErr bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"valid\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid ServerDisco\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"1\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid LamportID\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":1.1,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid AddrPorts\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid VNI\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":18446744073709551615,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid BindLifetime\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"5\",\"SteadyStateLifetime\":\"5m0s\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid SteadyStateLifetime\",\n+\t\t\tjson:    []byte(`{\"ServerDisco\":\"discokey:003cd7453e04a653eb0e7a18f206fc353180efadb2facfd05ebd6982a1392c7f\",\"LamportID\":18446744073709551615,\"AddrPorts\":[\"127.0.0.1:1\",\"127.0.0.2:2\"],\"VNI\":16777215,\"BindLifetime\":\"30s\",\"SteadyStateLifetime\":\"5\"}`),\n+\t\t\twantErr: true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tvar out ServerEndpoint\n+\t\t\terr := json.Unmarshal(tt.json, &out)\n+\t\t\tif tt.wantErr != (err != nil) {\n+\t\t\t\tt.Fatalf(\"wantErr: %v (err == nil): %v\", tt.wantErr, err == nil)\n+\t\t\t}\n+\t\t\tif tt.wantErr {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestServerEndpointJSONMarshal(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\tserverEndpoint ServerEndpoint\n+\t}{\n+\t\t{\n+\t\t\tname: \"valid roundtrip\",\n+\t\t\tserverEndpoint: ServerEndpoint{\n+\t\t\t\tServerDisco:         key.NewDisco().Public(),\n+\t\t\t\tLamportID:           uint64(math.MaxUint64),\n+\t\t\t\tAddrPorts:           []netip.AddrPort{netip.MustParseAddrPort(\"127.0.0.1:1\"), netip.MustParseAddrPort(\"127.0.0.2:2\")},\n+\t\t\t\tVNI:                 1<<24 - 1,\n+\t\t\t\tBindLifetime:        tstime.GoDuration{Duration: defaultBindLifetime},\n+\t\t\t\tSteadyStateLifetime: tstime.GoDuration{Duration: defaultSteadyStateLifetime},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tb, err := json.Marshal(&tt.serverEndpoint)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tvar got ServerEndpoint\n+\t\t\terr = json.Unmarshal(b, &got)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif diff := cmp.Diff(got, tt.serverEndpoint, cmpopts.EquateComparable(netip.AddrPort{}, key.DiscoPublic{})); diff != \"\" {\n+\t\t\t\tt.Fatalf(\"ServerEndpoint unequal (-got +want)\\n%s\", diff)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/peerapi.go\n@@ -1135,7 +1135,7 @@ func (h *peerAPIHandler) handleServeDrive(w http.ResponseWriter, r *http.Request\n \n \tp, err := drive.ParsePermissions(rawPerms)\n \tif err != nil {\n-\t\th.logf(\"taildrive: error parsing permissions: %w\", err.Error())\n+\t\th.logf(\"taildrive: error parsing permissions: %v\", err)\n \t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n \t\treturn\n \t}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/corp#27502\n\n---\n\nChoice A:\nipn/prefs.go\n@@ -607,9 +607,9 @@ func (p *Prefs) Equals(p2 *Prefs) bool {\n \t\tp.OperatorUser == p2.OperatorUser &&\n \t\tp.Hostname == p2.Hostname &&\n \t\tp.ForceDaemon == p2.ForceDaemon &&\n-\t\tcompareIPNets(p.AdvertiseRoutes, p2.AdvertiseRoutes) &&\n-\t\tcompareStrings(p.AdvertiseTags, p2.AdvertiseTags) &&\n-\t\tcompareStrings(p.AdvertiseServices, p2.AdvertiseServices) &&\n+\t\tslices.Equal(p.AdvertiseRoutes, p2.AdvertiseRoutes) &&\n+\t\tslices.Equal(p.AdvertiseTags, p2.AdvertiseTags) &&\n+\t\tslices.Equal(p.AdvertiseServices, p2.AdvertiseServices) &&\n \t\tp.Persist.Equals(p2.Persist) &&\n \t\tp.ProfileName == p2.ProfileName &&\n \t\tp.AutoUpdate.Equals(p2.AutoUpdate) &&\n@@ -636,30 +636,6 @@ func (ap AppConnectorPrefs) Pretty() string {\n \treturn \"\"\n }\n \n-func compareIPNets(a, b []netip.Prefix) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n-\tfor i := range a {\n-\t\tif a[i] != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-func compareStrings(a, b []string) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n-\tfor i := range a {\n-\t\tif a[i] != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n // NewPrefs returns the default preferences to use.\n func NewPrefs() *Prefs {\n \t// Provide default values for options which might be missing\n---\n\n\n---\n\nChoice B:\nscripts/installer.sh\n@@ -208,8 +208,11 @@ main() {\n \t\t\t\t\tPACKAGETYPE=\"yum\"\n \t\t\t\tfi\n \t\t\t\t;;\n-\t\t\trhel)\n+\t\t\trhel|miraclelinux)\n \t\t\t\tOS=\"$ID\"\n+\t\t\t\tif [ \"$ID\" = \"miraclelinux\" ]; then\n+\t\t\t\t\tOS=\"rhel\"\n+\t\t\t\tfi\n \t\t\t\tVERSION=\"$(echo \"$VERSION_ID\" | cut -f1 -d.)\"\n \t\t\t\tPACKAGETYPE=\"dnf\"\n \t\t\t\tif [ \"$VERSION\" = \"7\" ]; then\n---\n\n\n---\n\nChoice C:\ntailcfg/tailcfg.go\n@@ -2446,6 +2446,14 @@ const (\n \t// native tailnet. This is currently only sent to Hello, in its\n \t// peer node list.\n \tNodeAttrNativeIPV4 NodeCapability = \"native-ipv4\"\n+\n+\t// NodeAttrRelayServer permits the node to act as an underlay UDP relay\n+\t// server. There are no expected values for this key in NodeCapMap.\n+\tNodeAttrRelayServer NodeCapability = \"relay:server\"\n+\n+\t// NodeAttrRelayClient permits the node to act as an underlay UDP relay\n+\t// client. There are no expected values for this key in NodeCapMap.\n+\tNodeAttrRelayClient NodeCapability = \"relay:client\"\n )\n \n // SetDNSRequest is a request to add a DNS record.\n---\n\n\n---\n\nChoice D:\ntsnet/depaware.txt\n@@ -80,10 +80,10 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n    L    github.com/aws/smithy-go/transport/http                      from github.com/aws/aws-sdk-go-v2/aws/middleware+\n    L    github.com/aws/smithy-go/transport/http/internal/io          from github.com/aws/smithy-go/transport/http\n    L    github.com/aws/smithy-go/waiter                              from github.com/aws/aws-sdk-go-v2/service/ssm\n- LDWA    github.com/coder/websocket                                   from tailscale.com/util/eventbus\n- LDWA    github.com/coder/websocket/internal/errd                     from github.com/coder/websocket\n- LDWA    github.com/coder/websocket/internal/util                     from github.com/coder/websocket\n- LDWA    github.com/coder/websocket/internal/xsync                    from github.com/coder/websocket\n+ LDW    github.com/coder/websocket                                   from tailscale.com/util/eventbus\n+ LDW    github.com/coder/websocket/internal/errd                     from github.com/coder/websocket\n+ LDW    github.com/coder/websocket/internal/util                     from github.com/coder/websocket\n+ LDW    github.com/coder/websocket/internal/xsync                    from github.com/coder/websocket\n    L    github.com/coreos/go-iptables/iptables                       from tailscale.com/util/linuxfw\n    W \ud83d\udca3 github.com/dblohm7/wingoes                                   from github.com/dblohm7/wingoes/com+\n    W \ud83d\udca3 github.com/dblohm7/wingoes/com                               from tailscale.com/util/osdiag+\n@@ -552,7 +552,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         hash/crc32                                                   from compress/gzip+\n         hash/maphash                                                 from go4.org/mem\n         html                                                         from html/template+\n- LDWA    html/template                                                from github.com/gorilla/csrf+\n+ LDW    html/template                                                from github.com/gorilla/csrf+\n         internal/abi                                                 from crypto/x509/internal/macos+\n         internal/asan                                                from internal/runtime/maps+\n         internal/bisect                                              from internal/godebug\n@@ -639,8 +639,8 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         sync/atomic                                                  from context+\n         syscall                                                      from archive/tar+\n         text/tabwriter                                               from runtime/pprof\n- LDWA    text/template                                                from html/template\n- LDWA    text/template/parse                                          from html/template+\n+ LDW    text/template                                                from html/template\n+ LDW    text/template/parse                                          from html/template+\n         time                                                         from archive/tar+\n         unicode                                                      from bytes+\n         unicode/utf16                                                from crypto/x509+\n---\nutil/eventbus/debughttp.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !ios\n+//go:build !ios && !android\n \n package eventbus\n \n---\nutil/eventbus/debughttp_off.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build ios\n+//go:build ios || android\n \n package eventbus\n \n@@ -12,6 +12,8 @@ func registerHTTPDebugger(d *Debugger, td *tsweb.DebugHandler) {\n \t// reflection for method lookups. This forces the compiler to\n \t// retain a lot more code and information to make dynamic method\n \t// dispatch work, which is unacceptable bloat for the iOS build.\n+\t// We also disable it on Android while we're at it, as nobody\n+\t// is debugging Tailscale internals on Android.\n \t//\n \t// TODO: https://github.com/tailscale/tailscale/issues/15297 to\n \t// bring the debug UI back to iOS somehow.\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nMake the perPeerState objects able to function independently without a shared reference to the connector.\r\n\r\nWe don't currently change the values from connector that perPeerState uses at runtime. Explicitly copying them at perPeerState creation allows us to, for example, put the perPeerState into a consensus algorithm in the future.\r\n\r\nUpdates #14667\n\n---\n\nChoice A:\ntypes/logger/logger.go\n@@ -323,6 +323,7 @@ func (fn ArgWriter) Format(f fmt.State, _ rune) {\n \tbw.Reset(f)\n \tfn(bw)\n \tbw.Flush()\n+\tbw.Reset(io.Discard)\n \targBufioPool.Put(bw)\n }\n \n---\n\n\n---\n\nChoice B:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/init@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/autobuild@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/analyze@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/serve.go\n@@ -632,7 +632,7 @@ func (b *LocalBackend) getServeHandler(r *http.Request) (_ ipn.HTTPHandlerView,\n \n \thostname := r.Host\n \tif r.TLS == nil {\n-\t\ttcd := \".\" + b.Status().CurrentTailnet.MagicDNSSuffix\n+\t\ttcd := \".\" + b.CurrentProfile().NetworkProfile().MagicDNSName\n \t\tif host, _, err := net.SplitHostPort(hostname); err == nil {\n \t\t\thostname = host\n \t\t}\n---\n\n\n---\n\nChoice D:\ncmd/natc/natc.go\n@@ -359,7 +359,7 @@ var tsMBox = dnsmessage.MustNewName(\"support.tailscale.com.\")\n // generateDNSResponse generates a DNS response for the given request. The from\n // argument is the NodeID of the node that sent the request.\n func (c *connector) generateDNSResponse(req *dnsmessage.Message, from tailcfg.NodeID) ([]byte, error) {\n-\tpm, _ := c.perPeerMap.LoadOrStore(from, &perPeerState{c: c})\n+\tpm, _ := c.perPeerMap.LoadOrStore(from, newPerPeerState(c))\n \tvar addrs []netip.Addr\n \tif len(req.Questions) > 0 {\n \t\tswitch req.Questions[0].Type {\n@@ -509,14 +509,22 @@ func proxyTCPConn(c net.Conn, dest string) {\n \n // perPeerState holds the state for a single peer.\n type perPeerState struct {\n-\tc *connector\n+\tv6ULA netip.Prefix\n+\tipset *netipx.IPSet\n \n \tmu           sync.Mutex\n \taddrInUse    *big.Int\n \tdomainToAddr map[string][]netip.Addr\n \taddrToDomain *bart.Table[string]\n }\n \n+func newPerPeerState(c *connector) *perPeerState {\n+\treturn &perPeerState{\n+\t\tipset: c.ipset,\n+\t\tv6ULA: c.v6ULA,\n+\t}\n+}\n+\n // domainForIP returns the domain name assigned to the given IP address and\n // whether it was found.\n func (ps *perPeerState) domainForIP(ip netip.Addr) (_ string, ok bool) {\n@@ -555,7 +563,7 @@ func (ps *perPeerState) unusedIPv4Locked() netip.Addr {\n \tif ps.addrInUse == nil {\n \t\tps.addrInUse = big.NewInt(0)\n \t}\n-\treturn allocAddr(ps.c.ipset, ps.addrInUse)\n+\treturn allocAddr(ps.ipset, ps.addrInUse)\n }\n \n // assignAddrsLocked assigns a pair of unique IP addresses for the given domain\n@@ -570,7 +578,7 @@ func (ps *perPeerState) assignAddrsLocked(domain string) []netip.Addr {\n \tif !v4.IsValid() {\n \t\treturn nil\n \t}\n-\tas16 := ps.c.v6ULA.Addr().As16()\n+\tas16 := ps.v6ULA.Addr().As16()\n \tas4 := v4.As4()\n \tcopy(as16[12:], as4[:])\n \tv6 := netip.AddrFrom16(as16)\n---\ncmd/natc/natc_test.go\n@@ -220,7 +220,7 @@ func TestPerPeerState(t *testing.T) {\n \t}\n \tc.setPrefixes([]netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")})\n \n-\tps := &perPeerState{c: c}\n+\tps := newPerPeerState(c)\n \n \taddrs, err := ps.ipForDomain(\"example.com\")\n \tif err != nil {\n@@ -360,7 +360,7 @@ func TestIPPoolExhaustion(t *testing.T) {\n \t}\n \tc.setPrefixes([]netip.Prefix{smallPrefix})\n \n-\tps := &perPeerState{c: c}\n+\tps := newPerPeerState(c)\n \n \tassignedIPs := make(map[netip.Addr]string)\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n When enabled, both the operator itself and proxy instances can register as ephemeral nodes, which are automatically deleted from the tailnet when offline for an extended period. This helps automate node cleanup and prevents accumulation of stale nodes in tailnets, particularly valuable in dynamic Kubernetes environments where pods frequently scale up and down.\r\n   \r\nThe implementation adds an `ephemeral` configuration flag to the operator's deployment templates, chart values, and CRD specifications, along with corresponding code changes to generate the appropriate auth keys with ephemeral capabilities.\n\n---\n\nChoice A:\nclient/tailscale/acl.go\n@@ -50,6 +50,18 @@ type NodeAttrGrant struct {\n \tAttr []string `json:\"attr,omitempty\"`\n }\n \n+// ACLAttrConfig defines the configuration for a custom attribute.\n+type ACLAttrConfig struct {\n+\t// Type specifies the attribute type. Valid values: \"string\", \"number\", \"bool\".\n+\tType string `json:\"type,omitempty\"`\n+\n+\t// AllowSetByNode allows nodes to set this attribute themselves.\n+\tAllowSetByNode bool `json:\"allowSetByNode,omitempty\"`\n+\n+\t// BroadcastToPeers lists target nodes to receive this attribute value.\n+\tBroadcastToPeers []string `json:\"broadcastToPeers,omitempty\"`\n+}\n+\n // ACLDetails contains all the details for an ACL.\n type ACLDetails struct {\n \tTests     []ACLTest           `json:\"tests,omitempty\"`\n@@ -58,6 +70,9 @@ type ACLDetails struct {\n \tTagOwners map[string][]string `json:\"tagowners,omitempty\"`\n \tHosts     map[string]string   `json:\"hosts,omitempty\"`\n \tNodeAttrs []NodeAttrGrant     `json:\"nodeAttrs,omitempty\"`\n+\n+\t// AttrConfig maps attribute names to their configuration.\n+\tAttrConfig map[string]ACLAttrConfig `json:\"attrConfig,omitempty\"`\n }\n \n // ACL contains an ACLDetails and metadata.\n---\n\n\n---\n\nChoice B:\n.github/workflows/test.yml\n@@ -79,7 +79,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -157,7 +157,7 @@ jobs:\n         cache: false\n \n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -263,7 +263,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -333,7 +333,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n@@ -386,7 +386,7 @@ jobs:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: Restore Cache\n-      uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2\n+      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n       with:\n         # Note: unlike the other setups, this is only grabbing the mod download\n         # cache, rather than the whole mod directory, as the download cache\n---\n\n\n---\n\nChoice C:\ncontrol/controlclient/direct.go\n@@ -95,15 +95,16 @@ type Direct struct {\n \tsfGroup     singleflight.Group[struct{}, *NoiseClient] // protects noiseClient creation.\n \tnoiseClient *NoiseClient\n \n-\tpersist      persist.PersistView\n-\tauthKey      string\n-\ttryingNewKey key.NodePrivate\n-\texpiry       time.Time         // or zero value if none/unknown\n-\thostinfo     *tailcfg.Hostinfo // always non-nil\n-\tnetinfo      *tailcfg.NetInfo\n-\tendpoints    []tailcfg.Endpoint\n-\ttkaHead      string\n-\tlastPingURL  string // last PingRequest.URL received, for dup suppression\n+\tpersist                 persist.PersistView\n+\tauthKey                 string\n+\ttryingNewKey            key.NodePrivate\n+\texpiry                  time.Time         // or zero value if none/unknown\n+\thostinfo                *tailcfg.Hostinfo // always non-nil\n+\tnetinfo                 *tailcfg.NetInfo\n+\tendpoints               []tailcfg.Endpoint\n+\ttkaHead                 string\n+\tlastPingURL             string // last PingRequest.URL received, for dup suppression\n+\tconnectionHandleForTest string // sent in MapRequest.ConnectionHandleForTest\n }\n \n // Observer is implemented by users of the control client (such as LocalBackend)\n@@ -403,6 +404,14 @@ func (c *Direct) SetTKAHead(tkaHead string) bool {\n \treturn true\n }\n \n+// SetConnectionHandleForTest stores a new MapRequest.ConnectionHandleForTest\n+// value for the next update.\n+func (c *Direct) SetConnectionHandleForTest(handle string) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tc.connectionHandleForTest = handle\n+}\n+\n func (c *Direct) GetPersist() persist.PersistView {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n@@ -851,6 +860,7 @@ func (c *Direct) sendMapRequest(ctx context.Context, isStreaming bool, nu Netmap\n \tserverNoiseKey := c.serverNoiseKey\n \thi := c.hostInfoLocked()\n \tbackendLogID := hi.BackendLogID\n+\tconnectionHandleForTest := c.connectionHandleForTest\n \tvar epStrs []string\n \tvar eps []netip.AddrPort\n \tvar epTypes []tailcfg.EndpointType\n@@ -891,17 +901,18 @@ func (c *Direct) sendMapRequest(ctx context.Context, isStreaming bool, nu Netmap\n \n \tnodeKey := persist.PublicNodeKey()\n \trequest := &tailcfg.MapRequest{\n-\t\tVersion:       tailcfg.CurrentCapabilityVersion,\n-\t\tKeepAlive:     true,\n-\t\tNodeKey:       nodeKey,\n-\t\tDiscoKey:      c.discoPubKey,\n-\t\tEndpoints:     eps,\n-\t\tEndpointTypes: epTypes,\n-\t\tStream:        isStreaming,\n-\t\tHostinfo:      hi,\n-\t\tDebugFlags:    c.debugFlags,\n-\t\tOmitPeers:     nu == nil,\n-\t\tTKAHead:       c.tkaHead,\n+\t\tVersion:                 tailcfg.CurrentCapabilityVersion,\n+\t\tKeepAlive:               true,\n+\t\tNodeKey:                 nodeKey,\n+\t\tDiscoKey:                c.discoPubKey,\n+\t\tEndpoints:               eps,\n+\t\tEndpointTypes:           epTypes,\n+\t\tStream:                  isStreaming,\n+\t\tHostinfo:                hi,\n+\t\tDebugFlags:              c.debugFlags,\n+\t\tOmitPeers:               nu == nil,\n+\t\tTKAHead:                 c.tkaHead,\n+\t\tConnectionHandleForTest: connectionHandleForTest,\n \t}\n \tvar extraDebugFlags []string\n \tif hi != nil && c.netMon != nil && !c.skipIPForwardingCheck &&\n---\ntailcfg/tailcfg.go\n@@ -1385,6 +1385,12 @@ type MapRequest struct {\n \t//     * \"warn-router-unhealthy\": client's Router implementation is\n \t//       having problems.\n \tDebugFlags []string `json:\",omitempty\"`\n+\n+\t// ConnectionHandleForTest, if non-empty, is an opaque string sent by the client that\n+\t// identifies this specific connection to the server. The server may choose to\n+\t// use this handle to identify the connection for debugging or testing\n+\t// purposes. It has no semantic meaning.\n+\tConnectionHandleForTest string `json:\",omitempty\"`\n }\n \n // PortRange represents a range of UDP or TCP port numbers.\n---\n\n\n---\n\nChoice D:\ncmd/k8s-operator/deploy/chart/templates/deployment.yaml\n@@ -64,6 +64,8 @@ spec:\n               value: operator\n             - name: OPERATOR_LOGGING\n               value: {{ .Values.operatorConfig.logging }}\n+            - name: OPERATOR_EPHEMERAL\n+              value: \"{{ .Values.operatorConfig.ephemeral }}\"\n             - name: OPERATOR_NAMESPACE\n               valueFrom:\n                 fieldRef:\n---\ncmd/k8s-operator/deploy/chart/values.yaml\n@@ -36,6 +36,10 @@ operatorConfig:\n   # Multiple tags are defined as array items and passed to the operator as a comma-separated string\n   defaultTags:\n     - \"tag:k8s-operator\"\n+  \n+  # When true, the operator will use an ephemeral auth key\n+  # https://tailscale.com/kb/1111/ephemeral-nodes/\n+  ephemeral: false\n \n   image:\n     # Repository defaults to DockerHub, but images are also synced to ghcr.io/tailscale/k8s-operator.\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -2215,6 +2215,14 @@ spec:\n                         https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n                         Defaults to false.\n                       type: boolean\n+                    ephemeral:\n+                      description: |-\n+                        Ephemeral can be set to true to make the proxy instance register\n+                        as an ephemeral node. Ephemeral nodes are automatically deleted\n+                        from the tailnet when they are offline for a while.\n+                        https://tailscale.com/kb/1111/ephemeral-nodes/\n+                        Defaults to false.\n+                      type: boolean\n                 useLetsEncryptStagingEnvironment:\n                   description: |-\n                     Set UseLetsEncryptStagingEnvironment to true to issue TLS\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -2684,6 +2684,14 @@ spec:\n                                             https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n                                             Defaults to false.\n                                         type: boolean\n+                                    ephemeral:\n+                                        description: |-\n+                                            Ephemeral can be set to true to make the proxy instance register\n+                                            as an ephemeral node. Ephemeral nodes are automatically deleted\n+                                            from the tailnet when they are offline for a while.\n+                                            https://tailscale.com/kb/1111/ephemeral-nodes/\n+                                            Defaults to false.\n+                                        type: boolean\n                                 type: object\n                             useLetsEncryptStagingEnvironment:\n                                 description: |-\n@@ -5009,6 +5017,8 @@ spec:\n                       value: operator\n                     - name: OPERATOR_LOGGING\n                       value: info\n+                    - name: OPERATOR_EPHEMERAL\n+                      value: \"false\"\n                     - name: OPERATOR_NAMESPACE\n                       valueFrom:\n                         fieldRef:\n---\ncmd/k8s-operator/operator.go\n@@ -139,6 +139,7 @@ func initTSNet(zlog *zap.SugaredLogger) (*tsnet.Server, tsClient) {\n \t\thostname         = defaultEnv(\"OPERATOR_HOSTNAME\", \"tailscale-operator\")\n \t\tkubeSecret       = defaultEnv(\"OPERATOR_SECRET\", \"\")\n \t\toperatorTags     = defaultEnv(\"OPERATOR_INITIAL_TAGS\", \"tag:k8s-operator\")\n+\t\tephemeral        = defaultBool(\"OPERATOR_EPHEMERAL\", false)\n \t)\n \tstartlog := zlog.Named(\"startup\")\n \tif clientIDPath == \"\" || clientSecretPath == \"\" {\n@@ -196,6 +197,7 @@ waitOnline:\n \t\t\t\t\tCreate: tailscale.KeyDeviceCreateCapabilities{\n \t\t\t\t\t\tReusable:      false,\n \t\t\t\t\t\tPreauthorized: true,\n+\t\t\t\t\t\tEphemeral:     ephemeral,\n \t\t\t\t\t\tTags:          strings.Split(operatorTags, \",\"),\n \t\t\t\t\t},\n \t\t\t\t},\n---\ncmd/k8s-operator/proxygroup.go\n@@ -477,7 +477,11 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t\tif len(tags) == 0 {\n \t\t\t\ttags = r.defaultTags\n \t\t\t}\n-\t\t\tauthKey, err = newAuthKey(ctx, r.tsClient, tags)\n+\t\t\tephemeral := false\n+\t\t\tif proxyClass != nil && proxyClass.Spec.TailscaleConfig != nil {\n+\t\t\t\tephemeral = proxyClass.Spec.TailscaleConfig.Ephemeral\n+\t\t\t}\n+\t\t\tauthKey, err = newAuthKey(ctx, r.tsClient, tags, ephemeral)\n \t\t\tif err != nil {\n \t\t\t\treturn \"\", err\n \t\t\t}\n---\ncmd/k8s-operator/sts.go\n@@ -376,7 +376,7 @@ func (a *tailscaleSTSReconciler) createOrGetSecret(ctx context.Context, logger *\n \t\tif len(tags) == 0 {\n \t\t\ttags = a.defaultTags\n \t\t}\n-\t\tauthKey, err = newAuthKey(ctx, a.tsClient, tags)\n+\t\tauthKey, err = newAuthKey(ctx, a.tsClient, tags, shouldUseEphemeral(stsC.ProxyClass))\n \t\tif err != nil {\n \t\t\treturn \"\", \"\", nil, err\n \t\t}\n@@ -511,12 +511,13 @@ func deviceInfo(sec *corev1.Secret, podUID string, log *zap.SugaredLogger) (dev\n \treturn dev, nil\n }\n \n-func newAuthKey(ctx context.Context, tsClient tsClient, tags []string) (string, error) {\n+func newAuthKey(ctx context.Context, tsClient tsClient, tags []string, ephemeral bool) (string, error) {\n \tcaps := tailscale.KeyCapabilities{\n \t\tDevices: tailscale.KeyDeviceCapabilities{\n \t\t\tCreate: tailscale.KeyDeviceCreateCapabilities{\n \t\t\t\tReusable:      false,\n \t\t\t\tPreauthorized: true,\n+\t\t\t\tEphemeral:     ephemeral,\n \t\t\t\tTags:          tags,\n \t\t\t},\n \t\t},\n@@ -1022,6 +1023,10 @@ func shouldAcceptRoutes(pc *tsapi.ProxyClass) bool {\n \treturn pc != nil && pc.Spec.TailscaleConfig != nil && pc.Spec.TailscaleConfig.AcceptRoutes\n }\n \n+func shouldUseEphemeral(pc *tsapi.ProxyClass) bool {\n+\treturn pc != nil && pc.Spec.TailscaleConfig != nil && pc.Spec.TailscaleConfig.Ephemeral\n+}\n+\n // ptrObject is a type constraint for pointer types that implement\n // client.Object.\n type ptrObject[T any] interface {\n---\ncmd/k8s-operator/tsrecorder.go\n@@ -289,7 +289,7 @@ func (r *RecorderReconciler) ensureAuthSecretCreated(ctx context.Context, tsr *t\n \tif len(tags) == 0 {\n \t\ttags = tsapi.Tags{\"tag:k8s\"}\n \t}\n-\tauthKey, err := newAuthKey(ctx, r.tsClient, tags.Stringify())\n+\tauthKey, err := newAuthKey(ctx, r.tsClient, tags.Stringify(), false)\n \tif err != nil {\n \t\treturn err\n \t}\n---\nk8s-operator/api.md\n@@ -1013,5 +1013,6 @@ _Appears in:_\n | Field | Description | Default | Validation |\n | --- | --- | --- | --- |\n | `acceptRoutes` _boolean_ | AcceptRoutes can be set to true to make the proxy instance accept<br />routes advertized by other nodes on the tailnet, such as subnet<br />routes.<br />This is equivalent of passing --accept-routes flag to a tailscale Linux client.<br />https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices<br />Defaults to false. |  |  |\n+| `ephemeral` _boolean_ | Ephemeral can be set to true to make the proxy instance register<br />as an ephemeral node. Ephemeral nodes are automatically deleted<br />from the tailnet when they are offline for a while.<br />https://tailscale.com/kb/1111/ephemeral-nodes/<br />Defaults to false. |  |  |\n \n \n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -91,6 +91,13 @@ type TailscaleConfig struct {\n \t// https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n \t// Defaults to false.\n \tAcceptRoutes bool `json:\"acceptRoutes,omitempty\"`\n+\n+\t// Ephemeral can be set to true to make the proxy instance register\n+\t// as an ephemeral node. Ephemeral nodes are automatically deleted\n+\t// from the tailnet when they are offline for a while.\n+\t// https://tailscale.com/kb/1111/ephemeral-nodes/\n+\t// Defaults to false.\n+\tEphemeral bool `json:\"ephemeral,omitempty\"`\n }\n \n type StatefulSet struct {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nNot currently used in the OSS tree, a View for tailcfg.VIPService will make implementing some server side changes easier.\r\n\r\nUpdates tailscale/corp#26272\r\n\r\nChange-Id: If1ed0bea4eff8c4425d3845b433a1c562d99eb9e\n\n---\n\nChoice A:\nprober/prober.go\n@@ -559,8 +559,8 @@ func (p *Prober) RunHandler(w http.ResponseWriter, r *http.Request) error {\n \t\t\tPreviousSuccessRatio:  prevInfo.RecentSuccessRatio(),\n \t\t\tPreviousMedianLatency: prevInfo.RecentMedianLatency(),\n \t\t}\n-\t\tw.WriteHeader(respStatus)\n \t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tw.WriteHeader(respStatus)\n \t\tif err := json.NewEncoder(w).Encode(resp); err != nil {\n \t\t\treturn tsweb.Error(http.StatusInternalServerError, \"error encoding JSON response\", err)\n \t\t}\n---\nprober/prober_test.go\n@@ -598,6 +598,9 @@ func TestProberRunHandler(t *testing.T) {\n \t\t\t\t}\n \n \t\t\t\tif reqJSON {\n+\t\t\t\t\tif w.Header().Get(\"Content-Type\") != \"application/json\" {\n+\t\t\t\t\t\tt.Errorf(\"unexpected content type: got %q, want application/json\", w.Header().Get(\"Content-Type\"))\n+\t\t\t\t\t}\n \t\t\t\t\tvar gotJSON RunHandlerResponse\n \t\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), &gotJSON); err != nil {\n \t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, w.Body.String())\n---\n\n\n---\n\nChoice B:\ncmd/k8s-operator/deploy/crds/tailscale.com_connectors.yaml\n@@ -32,6 +32,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_dnsconfigs.yaml\n@@ -20,6 +20,9 @@ spec:\n           jsonPath: .status.nameserver.ip\n           name: NameserverIP\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -18,6 +18,9 @@ spec:\n           jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n           name: Status\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxygroups.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .spec.type\n           name: Type\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_recorders.yaml\n@@ -24,6 +24,9 @@ spec:\n           jsonPath: .status.devices[?(@.url != \"\")].url\n           name: URL\n           type: string\n+        - jsonPath: .metadata.creationTimestamp\n+          name: Age\n+          type: date\n       name: v1alpha1\n       schema:\n         openAPIV3Schema:\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -61,6 +61,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ConnectorReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -312,6 +315,9 @@ spec:\n               jsonPath: .status.nameserver.ip\n               name: NameserverIP\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -492,6 +498,9 @@ spec:\n               jsonPath: .status.conditions[?(@.type == \"ProxyClassReady\")].reason\n               name: Status\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -2803,6 +2812,9 @@ spec:\n               jsonPath: .spec.type\n               name: Type\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n@@ -3013,6 +3025,9 @@ spec:\n               jsonPath: .status.devices[?(@.url != \"\")].url\n               name: URL\n               type: string\n+            - jsonPath: .metadata.creationTimestamp\n+              name: Age\n+              type: date\n           name: v1alpha1\n           schema:\n             openAPIV3Schema:\n---\nk8s-operator/apis/v1alpha1/types_connector.go\n@@ -24,6 +24,7 @@ var ConnectorKind = \"Connector\"\n // +kubebuilder:printcolumn:name=\"IsExitNode\",type=\"string\",JSONPath=`.status.isExitNode`,description=\"Whether this Connector instance defines an exit node.\"\n // +kubebuilder:printcolumn:name=\"IsAppConnector\",type=\"string\",JSONPath=`.status.isAppConnector`,description=\"Whether this Connector instance is an app connector.\"\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ConnectorReady\")].reason`,description=\"Status of the deployed Connector resources.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Connector defines a Tailscale node that will be deployed in the cluster. The\n // node can be configured to act as a Tailscale subnet router and/or a Tailscale\n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -16,6 +16,7 @@ var ProxyClassKind = \"ProxyClass\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyClassReady\")].reason`,description=\"Status of the ProxyClass.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyClass describes a set of configuration parameters that can be applied to\n // proxy resources created by the Tailscale Kubernetes operator.\n---\nk8s-operator/apis/v1alpha1/types_proxygroup.go\n@@ -14,6 +14,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=pg\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"ProxyGroupReady\")].reason`,description=\"Status of the deployed ProxyGroup resources.\"\n // +kubebuilder:printcolumn:name=\"Type\",type=\"string\",JSONPath=`.spec.type`,description=\"ProxyGroup type.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // ProxyGroup defines a set of Tailscale devices that will act as proxies.\n // Currently only egress ProxyGroups are supported.\n---\nk8s-operator/apis/v1alpha1/types_recorder.go\n@@ -15,6 +15,7 @@ import (\n // +kubebuilder:resource:scope=Cluster,shortName=rec\n // +kubebuilder:printcolumn:name=\"Status\",type=\"string\",JSONPath=`.status.conditions[?(@.type == \"RecorderReady\")].reason`,description=\"Status of the deployed Recorder resources.\"\n // +kubebuilder:printcolumn:name=\"URL\",type=\"string\",JSONPath=`.status.devices[?(@.url != \"\")].url`,description=\"URL on which the UI is exposed if enabled.\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // Recorder defines a tsrecorder device for recording SSH sessions. By default,\n // it will store recordings in a local ephemeral volume. If you want to persist\n---\nk8s-operator/apis/v1alpha1/types_tsdnsconfig.go\n@@ -18,6 +18,7 @@ var DNSConfigKind = \"DNSConfig\"\n // +kubebuilder:subresource:status\n // +kubebuilder:resource:scope=Cluster,shortName=dc\n // +kubebuilder:printcolumn:name=\"NameserverIP\",type=\"string\",JSONPath=`.status.nameserver.ip`,description=\"Service IP address of the nameserver\"\n+// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n \n // DNSConfig can be deployed to cluster to make a subset of Tailscale MagicDNS\n // names resolvable by cluster workloads. Use this if: A) you need to refer to\n---\n\n\n---\n\nChoice C:\ncmd/tsidp/Dockerfile\n@@ -31,11 +31,11 @@ WORKDIR /app\n \n # Environment variables\n ENV TAILSCALE_USE_WIP_CODE=1 \\\n-    TS_HOSTNAME=tsidp \\\n+    TS_HOSTNAME=idp \\\n     TS_STATE_DIR=/var/lib/tsidp\n \n # Expose the default port\n EXPOSE 443\n \n # Run the application\n-ENTRYPOINT [\"/app/tsidp\"]\n\\ No newline at end of file\n+ENTRYPOINT [\"/bin/sh\", \"-c\", \"/app/tsidp --hostname=${TS_HOSTNAME} --dir=${TS_STATE_DIR}\"]\n---\ncmd/tsidp/README.md\n@@ -38,7 +38,7 @@\n      --name `tsidp` \\\n      -p 443:443 \\\n      -e TS_AUTHKEY=YOUR_TAILSCALE_AUTHKEY \\\n-     -e TS_HOSTNAME=tsidp \\\n+     -e TS_HOSTNAME=idp \\\n      -v tsidp-data:/var/lib/tsidp \\\n      tsidp:latest\n    ```\n@@ -48,7 +48,7 @@\n    docker logs tsidp\n    ```\n \n-   Visit `https://tsidp.tailnet.ts.net` to confirm the service is running.\n+   Visit `https://idp.tailnet.ts.net` to confirm the service is running.\n \n ## Usage Example: Proxmox Integration\n \n@@ -82,13 +82,14 @@ The `tsidp` server supports several command-line flags:\n - `--port`: Port to listen on (default: 443)\n - `--local-port`: Allow requests from localhost\n - `--use-local-tailscaled`: Use local tailscaled instead of tsnet\n+- `--hostname`: tsnet hostname\n - `--dir`: tsnet state directory\n \n ## Environment Variables\n \n - `TS_AUTHKEY`: Your Tailscale authentication key (required)\n-- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\")\n-- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\")\n+- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\", Docker only)\n+- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\", Docker only)\n - `TAILSCALE_USE_WIP_CODE`: Enable work-in-progress code (default: \"1\")\n \n ## Support\n@@ -97,4 +98,4 @@ This is an [experimental](https://tailscale.com/kb/1167/release-stages#experimen\n \n ## License\n \n-BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n\\ No newline at end of file\n+BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n---\ncmd/tsidp/tsidp.go\n@@ -65,6 +65,7 @@ var (\n \tflagLocalPort          = flag.Int(\"local-port\", -1, \"allow requests from localhost\")\n \tflagUseLocalTailscaled = flag.Bool(\"use-local-tailscaled\", false, \"use local tailscaled instead of tsnet\")\n \tflagFunnel             = flag.Bool(\"funnel\", false, \"use Tailscale Funnel to make tsidp available on the public internet\")\n+\tflagHostname           = flag.String(\"hostname\", \"idp\", \"tsnet hostname to use instead of idp\")\n \tflagDir                = flag.String(\"dir\", \"\", \"tsnet state directory; a default one will be created if not provided\")\n )\n \n@@ -121,7 +122,7 @@ func main() {\n \t\tdefer cleanup()\n \t} else {\n \t\tts := &tsnet.Server{\n-\t\t\tHostname: \"idp\",\n+\t\t\tHostname: *flagHostname,\n \t\t\tDir:      *flagDir,\n \t\t}\n \t\tif *flagVerbose {\n---\n\n\n---\n\nChoice D:\ntailcfg/tailcfg.go\n@@ -5,7 +5,7 @@\n // the node and the coordination server.\n package tailcfg\n \n-//go:generate go run tailscale.com/cmd/viewer --type=User,Node,Hostinfo,NetInfo,Login,DNSConfig,RegisterResponse,RegisterResponseAuth,RegisterRequest,DERPHomeParams,DERPRegion,DERPMap,DERPNode,SSHRule,SSHAction,SSHPrincipal,ControlDialPlan,Location,UserProfile --clonefunc\n+//go:generate go run tailscale.com/cmd/viewer --type=User,Node,Hostinfo,NetInfo,Login,DNSConfig,RegisterResponse,RegisterResponseAuth,RegisterRequest,DERPHomeParams,DERPRegion,DERPMap,DERPNode,SSHRule,SSHAction,SSHPrincipal,ControlDialPlan,Location,UserProfile,VIPService --clonefunc\n \n import (\n \t\"bytes\"\n---\ntailcfg/tailcfg_clone.go\n@@ -626,9 +626,28 @@ var _UserProfileCloneNeedsRegeneration = UserProfile(struct {\n \tProfilePicURL string\n }{})\n \n+// Clone makes a deep copy of VIPService.\n+// The result aliases no memory with the original.\n+func (src *VIPService) Clone() *VIPService {\n+\tif src == nil {\n+\t\treturn nil\n+\t}\n+\tdst := new(VIPService)\n+\t*dst = *src\n+\tdst.Ports = append(src.Ports[:0:0], src.Ports...)\n+\treturn dst\n+}\n+\n+// A compilation failure here means this code must be regenerated, with the command at the top of this file.\n+var _VIPServiceCloneNeedsRegeneration = VIPService(struct {\n+\tName   ServiceName\n+\tPorts  []ProtoPortRange\n+\tActive bool\n+}{})\n+\n // Clone duplicates src into dst and reports whether it succeeded.\n // To succeed, <src, dst> must be of types <*T, *T> or <*T, **T>,\n-// where T is one of User,Node,Hostinfo,NetInfo,Login,DNSConfig,RegisterResponse,RegisterResponseAuth,RegisterRequest,DERPHomeParams,DERPRegion,DERPMap,DERPNode,SSHRule,SSHAction,SSHPrincipal,ControlDialPlan,Location,UserProfile.\n+// where T is one of User,Node,Hostinfo,NetInfo,Login,DNSConfig,RegisterResponse,RegisterResponseAuth,RegisterRequest,DERPHomeParams,DERPRegion,DERPMap,DERPNode,SSHRule,SSHAction,SSHPrincipal,ControlDialPlan,Location,UserProfile,VIPService.\n func Clone(dst, src any) bool {\n \tswitch src := src.(type) {\n \tcase *User:\n@@ -802,6 +821,15 @@ func Clone(dst, src any) bool {\n \t\t\t*dst = src.Clone()\n \t\t\treturn true\n \t\t}\n+\tcase *VIPService:\n+\t\tswitch dst := dst.(type) {\n+\t\tcase *VIPService:\n+\t\t\t*dst = *src.Clone()\n+\t\t\treturn true\n+\t\tcase **VIPService:\n+\t\t\t*dst = src.Clone()\n+\t\t\treturn true\n+\t\t}\n \t}\n \treturn false\n }\n---\ntailcfg/tailcfg_view.go\n@@ -19,7 +19,7 @@ import (\n \t\"tailscale.com/types/views\"\n )\n \n-//go:generate go run tailscale.com/cmd/cloner  -clonefunc=true -type=User,Node,Hostinfo,NetInfo,Login,DNSConfig,RegisterResponse,RegisterResponseAuth,RegisterRequest,DERPHomeParams,DERPRegion,DERPMap,DERPNode,SSHRule,SSHAction,SSHPrincipal,ControlDialPlan,Location,UserProfile\n+//go:generate go run tailscale.com/cmd/cloner  -clonefunc=true -type=User,Node,Hostinfo,NetInfo,Login,DNSConfig,RegisterResponse,RegisterResponseAuth,RegisterRequest,DERPHomeParams,DERPRegion,DERPMap,DERPNode,SSHRule,SSHAction,SSHPrincipal,ControlDialPlan,Location,UserProfile,VIPService\n \n // View returns a read-only view of User.\n func (p *User) View() UserView {\n@@ -1414,3 +1414,59 @@ var _UserProfileViewNeedsRegeneration = UserProfile(struct {\n \tDisplayName   string\n \tProfilePicURL string\n }{})\n+\n+// View returns a read-only view of VIPService.\n+func (p *VIPService) View() VIPServiceView {\n+\treturn VIPServiceView{\u0436: p}\n+}\n+\n+// VIPServiceView provides a read-only view over VIPService.\n+//\n+// Its methods should only be called if `Valid()` returns true.\n+type VIPServiceView struct {\n+\t// \u0436 is the underlying mutable value, named with a hard-to-type\n+\t// character that looks pointy like a pointer.\n+\t// It is named distinctively to make you think of how dangerous it is to escape\n+\t// to callers. You must not let callers be able to mutate it.\n+\t\u0436 *VIPService\n+}\n+\n+// Valid reports whether v's underlying value is non-nil.\n+func (v VIPServiceView) Valid() bool { return v.\u0436 != nil }\n+\n+// AsStruct returns a clone of the underlying value which aliases no memory with\n+// the original.\n+func (v VIPServiceView) AsStruct() *VIPService {\n+\tif v.\u0436 == nil {\n+\t\treturn nil\n+\t}\n+\treturn v.\u0436.Clone()\n+}\n+\n+func (v VIPServiceView) MarshalJSON() ([]byte, error) { return json.Marshal(v.\u0436) }\n+\n+func (v *VIPServiceView) UnmarshalJSON(b []byte) error {\n+\tif v.\u0436 != nil {\n+\t\treturn errors.New(\"already initialized\")\n+\t}\n+\tif len(b) == 0 {\n+\t\treturn nil\n+\t}\n+\tvar x VIPService\n+\tif err := json.Unmarshal(b, &x); err != nil {\n+\t\treturn err\n+\t}\n+\tv.\u0436 = &x\n+\treturn nil\n+}\n+\n+func (v VIPServiceView) Name() ServiceName                  { return v.\u0436.Name }\n+func (v VIPServiceView) Ports() views.Slice[ProtoPortRange] { return views.SliceOf(v.\u0436.Ports) }\n+func (v VIPServiceView) Active() bool                       { return v.\u0436.Active }\n+\n+// A compilation failure here means this code must be regenerated, with the command at the top of this file.\n+var _VIPServiceViewNeedsRegeneration = VIPService(struct {\n+\tName   ServiceName\n+\tPorts  []ProtoPortRange\n+\tActive bool\n+}{})\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n Go 1.24.2 changes: https://github.com/golang/go/issues?q=milestone%3AGo1.24.2+label%3ACherryPickApproved\r\n\r\nDiff from previous Tailscale Go: https://github.com/tailscale/go/compare/4fdaeeb8fe43bcdb4e8cc736433b9cd9c0ddd221...16b6e4fd15c59336156cdbc977de1745ad094f2d\r\n\r\nUpdates #5794\r\n\n\n---\n\nChoice A:\ncmd/k8s-operator/depaware.txt\n@@ -840,7 +840,7 @@ tailscale.com/cmd/k8s-operator dependencies: (generated by github.com/tailscale/\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/cmd/k8s-operator+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\ncmd/tailscaled/depaware.txt\n@@ -318,7 +318,7 @@ tailscale.com/cmd/tailscaled dependencies: (generated by github.com/tailscale/de\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/cmd/tailscaled+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\nipn/ipnlocal/local.go\n@@ -64,6 +64,7 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4886,7 +4887,6 @@ func (b *LocalBackend) authReconfig() {\n \tnm := cn.NetMap()\n \thasPAC := b.prevIfState.HasPAC()\n \tdisableSubnetsIfPAC := cn.SelfHasCap(tailcfg.NodeAttrDisableSubnetsIfPAC)\n-\tuserDialUseRoutes := cn.SelfHasCap(tailcfg.NodeAttrUserDialUseRoutes)\n \tdohURL, dohURLOK := cn.exitNodeCanProxyDNS(prefs.ExitNodeID())\n \tdcfg := cn.dnsConfigForNetmap(prefs, b.keyExpired, b.logf, version.OS())\n \t// If the current node is an app connector, ensure the app connector machine is started\n@@ -4947,7 +4947,7 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif userDialUseRoutes {\n+\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n \t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n \t} else {\n \t\tb.dialer.SetRoutes(nil, nil)\n---\nnet/dns/resolver/forwarder.go\n@@ -17,6 +17,7 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"net/url\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n@@ -740,18 +741,35 @@ func (f *forwarder) sendUDP(ctx context.Context, fq *forwardQuery, rr resolverAn\n \treturn out, nil\n }\n \n+var optDNSForwardUseRoutes = envknob.RegisterOptBool(\"TS_DEBUG_DNS_FORWARD_USE_ROUTES\")\n+\n+// ShouldUseRoutes reports whether the DNS resolver should consider routes when dialing\n+// upstream nameservers via TCP.\n+//\n+// If true, routes should be considered ([tsdial.Dialer.UserDial]), otherwise defer\n+// to the system routes ([tsdial.Dialer.SystemDial]).\n+//\n+// TODO(nickkhyl): Update [tsdial.Dialer] to reuse the bart.Table we create in net/tstun.Wrapper\n+// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n+// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n+//\n+// See tailscale/tailscale#12027.\n+func ShouldUseRoutes(knobs *controlknobs.Knobs) bool {\n+\tswitch runtime.GOOS {\n+\tcase \"android\", \"ios\":\n+\t\t// On mobile platforms with lower memory limits (e.g., 50MB on iOS),\n+\t\t// this behavior is still gated by the \"user-dial-routes\" nodeAttr.\n+\t\treturn knobs != nil && knobs.UserDialUseRoutes.Load()\n+\tdefault:\n+\t\t// On all other platforms, it is the default behavior,\n+\t\t// but it can be overridden with the \"TS_DEBUG_DNS_FORWARD_USE_ROUTES\" env var.\n+\t\tdoNotUseRoutes := optDNSForwardUseRoutes().EqualBool(false)\n+\t\treturn !doNotUseRoutes\n+\t}\n+}\n+\n func (f *forwarder) getDialerType() netx.DialFunc {\n-\tif f.controlKnobs != nil && f.controlKnobs.UserDialUseRoutes.Load() {\n-\t\t// It is safe to use UserDial as it dials external servers without going through Tailscale\n-\t\t// and closes connections on interface change in the same way as SystemDial does,\n-\t\t// thus preventing DNS resolution issues when switching between WiFi and cellular,\n-\t\t// but can also dial an internal DNS server on the Tailnet or via a subnet router.\n-\t\t//\n-\t\t// TODO(nickkhyl): Update tsdial.Dialer to reuse the bart.Table we create in net/tstun.Wrapper\n-\t\t// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n-\t\t// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n-\t\t//\n-\t\t// See https://github.com/tailscale/tailscale/issues/12027.\n+\tif ShouldUseRoutes(f.controlKnobs) {\n \t\treturn f.dialer.UserDial\n \t}\n \treturn f.dialer.SystemDial\n---\nnet/tsdial/tsdial.go\n@@ -151,6 +151,7 @@ func (d *Dialer) SetRoutes(routes, localRoutes []netip.Prefix) {\n \t\tfor _, r := range localRoutes {\n \t\t\trt.Insert(r, false)\n \t\t}\n+\t\td.logf(\"tsdial: bart table size: %d\", rt.Size())\n \t}\n \n \td.routes.Store(rt)\n---\ntsnet/depaware.txt\n@@ -271,7 +271,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -1463,15 +1463,30 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n+// AppendMatchingPeers returns base with all peers that match pred appended.\n+//\n+// It acquires b.mu to read the netmap but releases it before calling pred.\n func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+\tvar peers []tailcfg.NodeView\n+\n \tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n-\tret := base\n-\tif b.netMap == nil {\n-\t\treturn ret\n+\tif b.netMap != nil {\n+\t\t// All fields on b.netMap are immutable, so this is\n+\t\t// safe to copy and use outside the lock.\n+\t\tpeers = b.netMap.Peers\n \t}\n-\tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\tb.mu.Unlock()\n+\n+\tret := base\n+\tfor _, peer := range peers {\n+\t\t// The peers in b.netMap don't contain updates made via\n+\t\t// UpdateNetmapDelta. So only use PeerView in b.netMap for its NodeID,\n+\t\t// and then look up the latest copy in b.peers which is updated in\n+\t\t// response to UpdateNetmapDelta edits.\n+\t\tb.mu.Lock()\n+\t\tpeer, ok := b.peers[peer.ID()]\n+\t\tb.mu.Unlock()\n+\t\tif ok && pred(peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice C:\ngo.toolchain.rev\n@@ -1 +1 @@\n-4fdaeeb8fe43bcdb4e8cc736433b9cd9c0ddd221\n+16b6e4fd15c59336156cdbc977de1745ad094f2d\n---\n\n\n---\n\nChoice D:\nipn/localapi/localapi.go\n@@ -397,6 +397,15 @@ func (h *Handler) serveBugReport(w http.ResponseWriter, r *http.Request) {\n \t// OS-specific details\n \th.logf.JSON(1, \"UserBugReportOS\", osdiag.SupportInfo(osdiag.LogSupportInfoReasonBugReport))\n \n+\t// Tailnet lock details\n+\tst := h.b.NetworkLockStatus()\n+\tif st.Enabled {\n+\t\th.logf.JSON(1, \"UserBugReportTailnetLockStatus\", st)\n+\t\tif st.NodeKeySignature != nil {\n+\t\t\th.logf(\"user bugreport tailnet lock signature: %s\", st.NodeKeySignature.String())\n+\t\t}\n+\t}\n+\n \tif defBool(r.URL.Query().Get(\"diagnose\"), false) {\n \t\th.b.Doctor(r.Context(), logger.WithPrefix(h.logf, \"diag: \"))\n \t}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nfixes tailscale/corp#27506\r\n\r\nThe source address link selection for forwarded DNS queries on sandboxed macOS doesn't deal with loopback addresses correctly resulting in \"network unreachable\" errors.   This adds an explicit check to ensure we return the loopback interface for loopback addresses instead of the default empty interface when the runtime.GOOS is darwin. \r\n\r\nTested on both macos, macsys and tailscaled with a simple DNS proxy.  Forwarded requests to 127/8 are now all routed correctly.\n\n---\n\nChoice A:\nipn/conf.go\n@@ -145,9 +145,15 @@ func (c *ConfigVAlpha) ToPrefs() (MaskedPrefs, error) {\n \t\tmp.AppConnector = *c.AppConnector\n \t\tmp.AppConnectorSet = true\n \t}\n+\t// Configfile should be the source of truth for whether this node\n+\t// advertises any services.  We need to ensure that each reload updates\n+\t// currently advertised services as else the transition from 'some\n+\t// services are advertised' to 'advertised services are empty/unset in\n+\t// conffile' would have no effect (especially given that an empty\n+\t// service slice would be omitted from the JSON config).\n+\tmp.AdvertiseServicesSet = true\n \tif c.AdvertiseServices != nil {\n \t\tmp.AdvertiseServices = c.AdvertiseServices\n-\t\tmp.AdvertiseServicesSet = true\n \t}\n \treturn mp, nil\n }\n---\nipn/ipnlocal/local_test.go\n@@ -4745,32 +4745,133 @@ func TestLoginNotifications(t *testing.T) {\n // TestConfigFileReload tests that the LocalBackend reloads its configuration\n // when the configuration file changes.\n func TestConfigFileReload(t *testing.T) {\n-\tcfg1 := `{\"Hostname\": \"foo\", \"Version\": \"alpha0\"}`\n-\tf := filepath.Join(t.TempDir(), \"cfg\")\n-\tmust.Do(os.WriteFile(f, []byte(cfg1), 0600))\n-\tsys := new(tsd.System)\n-\tsys.InitialConfig = must.Get(conffile.Load(f))\n-\tlb := newTestLocalBackendWithSys(t, sys)\n-\tmust.Do(lb.Start(ipn.Options{}))\n-\n-\tlb.mu.Lock()\n-\thn := lb.hostinfo.Hostname\n-\tlb.mu.Unlock()\n-\tif hn != \"foo\" {\n-\t\tt.Fatalf(\"got %q; want %q\", hn, \"foo\")\n+\ttype testCase struct {\n+\t\tname    string\n+\t\tinitial *conffile.Config\n+\t\tupdated *conffile.Config\n+\t\tcheckFn func(*testing.T, *LocalBackend)\n \t}\n \n-\tcfg2 := `{\"Hostname\": \"bar\", \"Version\": \"alpha0\"}`\n-\tmust.Do(os.WriteFile(f, []byte(cfg2), 0600))\n-\tif !must.Get(lb.ReloadConfig()) {\n-\t\tt.Fatal(\"reload failed\")\n+\ttests := []testCase{\n+\t\t{\n+\t\t\tname: \"hostname_change\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:  \"alpha0\",\n+\t\t\t\t\tHostname: ptr.To(\"initial-host\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:  \"alpha0\",\n+\t\t\t\t\tHostname: ptr.To(\"updated-host\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif got := b.Prefs().Hostname(); got != \"updated-host\" {\n+\t\t\t\t\tt.Errorf(\"hostname = %q; want updated-host\", got)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"start_advertising_services\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion: \"alpha0\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\", \"svc:def\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif got := b.Prefs().AdvertiseServices().AsSlice(); !reflect.DeepEqual(got, []string{\"svc:abc\", \"svc:def\"}) {\n+\t\t\t\t\tt.Errorf(\"AdvertiseServices = %v; want [svc:abc, svc:def]\", got)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"change_advertised_services\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\", \"svc:def\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\", \"svc:ghi\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif got := b.Prefs().AdvertiseServices().AsSlice(); !reflect.DeepEqual(got, []string{\"svc:abc\", \"svc:ghi\"}) {\n+\t\t\t\t\tt.Errorf(\"AdvertiseServices = %v; want [svc:abc, svc:ghi]\", got)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"unset_advertised_services\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion: \"alpha0\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif b.Prefs().AdvertiseServices().Len() != 0 {\n+\t\t\t\t\tt.Errorf(\"got %d AdvertiseServices wants none\", b.Prefs().AdvertiseServices().Len())\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n \t}\n \n-\tlb.mu.Lock()\n-\thn = lb.hostinfo.Hostname\n-\tlb.mu.Unlock()\n-\tif hn != \"bar\" {\n-\t\tt.Fatalf(\"got %q; want %q\", hn, \"bar\")\n+\tfor _, tc := range tests {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tdir := t.TempDir()\n+\t\t\tpath := filepath.Join(dir, \"tailscale.conf\")\n+\n+\t\t\t// Write initial config\n+\t\t\tinitialJSON, err := json.Marshal(tc.initial.Parsed)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif err := os.WriteFile(path, initialJSON, 0644); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\n+\t\t\t// Create backend with initial config\n+\t\t\ttc.initial.Path = path\n+\t\t\ttc.initial.Raw = initialJSON\n+\t\t\tsys := &tsd.System{\n+\t\t\t\tInitialConfig: tc.initial,\n+\t\t\t}\n+\t\t\tb := newTestLocalBackendWithSys(t, sys)\n+\n+\t\t\t// Update config file\n+\t\t\tupdatedJSON, err := json.Marshal(tc.updated.Parsed)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif err := os.WriteFile(path, updatedJSON, 0644); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\n+\t\t\t// Trigger reload\n+\t\t\tif ok, err := b.ReloadConfig(); !ok || err != nil {\n+\t\t\t\tt.Fatalf(\"ReloadConfig() = %v, %v; want true, nil\", ok, err)\n+\t\t\t}\n+\n+\t\t\t// Check outcome\n+\t\t\ttc.checkFn(t, b)\n+\t\t})\n \t}\n }\n \n---\n\n\n---\n\nChoice B:\ngo.mod\n@@ -272,7 +272,7 @@ require (\n \tgithub.com/gordonklaus/ineffassign v0.1.0 // indirect\n \tgithub.com/goreleaser/chglog v0.5.0 // indirect\n \tgithub.com/goreleaser/fileglob v1.3.0 // indirect\n-\tgithub.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30\n+\tgithub.com/gorilla/csrf v1.7.3\n \tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n \tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n \tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n---\ngo.sum\n@@ -524,8 +524,8 @@ github.com/goreleaser/fileglob v1.3.0 h1:/X6J7U8lbDpQtBvGcwwPS6OpzkNVlVEsFUVRx9+\n github.com/goreleaser/fileglob v1.3.0/go.mod h1:Jx6BoXv3mbYkEzwm9THo7xbr5egkAraxkGorbJb4RxU=\n github.com/goreleaser/nfpm/v2 v2.33.1 h1:EkdAzZyVhAI9JC1vjmjjbmnNzyH1J6Cu4JCsA7YcQuc=\n github.com/goreleaser/nfpm/v2 v2.33.1/go.mod h1:8wwWWvJWmn84xo/Sqiv0aMvEGTHlHZTXTEuVSgQpkIM=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30 h1:fiJdrgVBkjZ5B1HJ2WQwNOaXB+QyYcNXTA3t1XYLz0M=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n+github.com/gorilla/csrf v1.7.3 h1:BHWt6FTLZAb2HtWT5KDBf6qgpZzvtbp9QWDRKZMXJC0=\n+github.com/gorilla/csrf v1.7.3/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n github.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\n github.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\n github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=\n---\n\n\n---\n\nChoice C:\ncmd/proxy-to-grafana/proxy-to-grafana.go\n@@ -53,7 +53,7 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"tailscale.com/client/local\"\n+\t\"tailscale.com/client/tailscale/apitype\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/tsnet\"\n )\n@@ -195,13 +195,7 @@ func main() {\n \tlog.Fatal(http.Serve(ln, proxy))\n }\n \n-func modifyRequest(req *http.Request, localClient *local.Client) {\n-\t// with enable_login_token set to true, we get a cookie that handles\n-\t// auth for paths that are not /login\n-\tif req.URL.Path != \"/login\" {\n-\t\treturn\n-\t}\n-\n+func modifyRequest(req *http.Request, localClient whoisIdentitySource) {\n \t// Delete any existing X-Webauth-* headers to prevent possible spoofing\n \t// if getting Tailnet identity fails.\n \tfor h := range req.Header {\n@@ -210,6 +204,13 @@ func modifyRequest(req *http.Request, localClient *local.Client) {\n \t\t}\n \t}\n \n+\t// Set the X-Webauth-* headers only for the /login path\n+\t// With enable_login_token set to true, we get a cookie that handles\n+\t// auth for paths that are not /login\n+\tif req.URL.Path != \"/login\" {\n+\t\treturn\n+\t}\n+\n \tuser, role, err := getTailscaleIdentity(req.Context(), localClient, req.RemoteAddr)\n \tif err != nil {\n \t\tlog.Printf(\"error getting Tailscale user: %v\", err)\n@@ -221,7 +222,7 @@ func modifyRequest(req *http.Request, localClient *local.Client) {\n \treq.Header.Set(\"X-Webauth-Role\", role.String())\n }\n \n-func getTailscaleIdentity(ctx context.Context, localClient *local.Client, ipPort string) (*tailcfg.UserProfile, grafanaRole, error) {\n+func getTailscaleIdentity(ctx context.Context, localClient whoisIdentitySource, ipPort string) (*tailcfg.UserProfile, grafanaRole, error) {\n \twhois, err := localClient.WhoIs(ctx, ipPort)\n \tif err != nil {\n \t\treturn nil, ViewerRole, fmt.Errorf(\"failed to identify remote host: %w\", err)\n@@ -248,3 +249,7 @@ func getTailscaleIdentity(ctx context.Context, localClient *local.Client, ipPort\n \n \treturn whois.UserProfile, role, nil\n }\n+\n+type whoisIdentitySource interface {\n+\tWhoIs(ctx context.Context, ipPort string) (*apitype.WhoIsResponse, error)\n+}\n---\ncmd/proxy-to-grafana/proxy-to-grafana_test.go\n@@ -0,0 +1,77 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+package main\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+\n+\t\"tailscale.com/client/tailscale/apitype\"\n+\t\"tailscale.com/tailcfg\"\n+)\n+\n+type mockWhoisSource struct {\n+\tid *apitype.WhoIsResponse\n+}\n+\n+func (m *mockWhoisSource) WhoIs(ctx context.Context, remoteAddr string) (*apitype.WhoIsResponse, error) {\n+\tif m.id == nil {\n+\t\treturn nil, fmt.Errorf(\"missing mock identity\")\n+\t}\n+\treturn m.id, nil\n+}\n+\n+var whois = &apitype.WhoIsResponse{\n+\tUserProfile: &tailcfg.UserProfile{\n+\t\tLoginName:   \"foobar@example.com\",\n+\t\tDisplayName: \"Foobar\",\n+\t},\n+\tNode: &tailcfg.Node{\n+\t\tID: 1,\n+\t},\n+}\n+\n+func TestModifyRequest_Login(t *testing.T) {\n+\treq := httptest.NewRequest(\"GET\", \"/login\", nil)\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"foobar@example.com\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"foobar@example.com\")\n+\t}\n+\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"Viewer\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"Viewer\")\n+\t}\n+}\n+\n+func TestModifyRequest_RemoveHeaders_Login(t *testing.T) {\n+\treq := httptest.NewRequest(\"GET\", \"/login\", nil)\n+\treq.Header.Set(\"X-Webauth-User\", \"malicious@example.com\")\n+\treq.Header.Set(\"X-Webauth-Role\", \"Admin\")\n+\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"foobar@example.com\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"foobar@example.com\")\n+\t}\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"Viewer\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"Viewer\")\n+\t}\n+}\n+\n+func TestModifyRequest_RemoveHeaders_API(t *testing.T) {\n+\treq := httptest.NewRequest(\"DELETE\", \"/api/org/users/1\", nil)\n+\treq.Header.Set(\"X-Webauth-User\", \"malicious@example.com\")\n+\treq.Header.Set(\"X-Webauth-Role\", \"Admin\")\n+\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"\")\n+\t}\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"\")\n+\t}\n+}\n---\n\n\n---\n\nChoice D:\nwgengine/userspace.go\n@@ -1580,6 +1580,12 @@ type fwdDNSLinkSelector struct {\n }\n \n func (ls fwdDNSLinkSelector) PickLink(ip netip.Addr) (linkName string) {\n+\t// sandboxed macOS does not automatically bind to the loopback interface so\n+\t// we must be explicit about it.\n+\tif runtime.GOOS == \"darwin\" && ip.IsLoopback() {\n+\t\treturn \"lo0\"\n+\t}\n+\n \tif ls.ue.isDNSIPOverTailscale.Load()(ip) {\n \t\treturn ls.tunName\n \t}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAdd the golang-image-ico package, which is an incredibly small package to handle the ICO container format with PNG inside. Some profile photos look quite pixelated when displayed at this size, but it's better than nothing, and any Windows support is just a bonus anyway.\r\n\r\nUpdates #1708\r\n\r\nChange-Id: Ia101a4a3005adb9118051b3416f5a64a4a45987d\n\n---\n\nChoice A:\ngo.mod\n@@ -98,14 +98,14 @@ require (\n \tgo.uber.org/zap v1.27.0\n \tgo4.org/mem v0.0.0-20240501181205-ae6ca9944745\n \tgo4.org/netipx v0.0.0-20231129151722-fdeea329fbba\n-\tgolang.org/x/crypto v0.35.0\n+\tgolang.org/x/crypto v0.37.0\n \tgolang.org/x/exp v0.0.0-20250210185358-939b2ce775ac\n \tgolang.org/x/mod v0.23.0\n \tgolang.org/x/net v0.36.0\n \tgolang.org/x/oauth2 v0.26.0\n-\tgolang.org/x/sync v0.11.0\n-\tgolang.org/x/sys v0.31.0\n-\tgolang.org/x/term v0.29.0\n+\tgolang.org/x/sync v0.13.0\n+\tgolang.org/x/sys v0.32.0\n+\tgolang.org/x/term v0.31.0\n \tgolang.org/x/time v0.10.0\n \tgolang.org/x/tools v0.30.0\n \tgolang.zx2c4.com/wintun v0.0.0-20230126152724-0fa3db229ce2\n@@ -392,7 +392,7 @@ require (\n \tgo.uber.org/multierr v1.11.0 // indirect\n \tgolang.org/x/exp/typeparams v0.0.0-20240314144324-c7f7c6466f7f // indirect\n \tgolang.org/x/image v0.24.0 // indirect\n-\tgolang.org/x/text v0.22.0 // indirect\n+\tgolang.org/x/text v0.24.0 // indirect\n \tgomodules.xyz/jsonpatch/v2 v2.4.0 // indirect\n \tgoogle.golang.org/protobuf v1.35.1 // indirect\n \tgopkg.in/inf.v0 v0.9.1 // indirect\n---\ngo.sum\n@@ -1087,8 +1087,8 @@ golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5y\n golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=\n golang.org/x/crypto v0.1.0/go.mod h1:RecgLatLF4+eUMCP1PoPZQb+cVrJcOPbHkTkbkB9sbw=\n golang.org/x/crypto v0.3.0/go.mod h1:hebNnKkNXi2UzZN1eVRvBB7co0a+JxK6XbPiWVs/3J4=\n-golang.org/x/crypto v0.35.0 h1:b15kiHdrGCHrP6LvwaQ3c03kgNhhiMgvlhxHQhmg2Xs=\n-golang.org/x/crypto v0.35.0/go.mod h1:dy7dXNW32cAb/6/PRuTNsix8T+vJAqvuIy5Bli/x0YQ=\n+golang.org/x/crypto v0.37.0 h1:kJNSjF/Xp7kU0iB2Z+9viTPMW4EqqsrywMXLJOOsXSE=\n+golang.org/x/crypto v0.37.0/go.mod h1:vg+k43peMZ0pUMhYmVAWysMK35e6ioLh3wB8ZCAfbVc=\n golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\n golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\n golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\n@@ -1200,8 +1200,8 @@ golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJ\n golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n-golang.org/x/sync v0.11.0 h1:GGz8+XQP4FvTTrjZPzNKTMFtSXH80RAzG+5ghFPgK9w=\n-golang.org/x/sync v0.11.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\n+golang.org/x/sync v0.13.0 h1:AauUjRAJ9OSnvULf/ARrrVywoJDy0YS2AwQ98I37610=\n+golang.org/x/sync v0.13.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=\n golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n@@ -1264,16 +1264,16 @@ golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n-golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=\n-golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n+golang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=\n+golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.2.0/go.mod h1:TVmDHMZPmdnySmBfhjOoOdhjzdE1h4u1VwSiw2l1Nuc=\n golang.org/x/term v0.4.0/go.mod h1:9P2UbLfCdcvo3p/nzKvsmas4TnlujnuoV9hGgYzW1lQ=\n golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\n-golang.org/x/term v0.29.0 h1:L6pJp37ocefwRRtYPKSWOWzOtWSxVajvz2ldH/xi3iU=\n-golang.org/x/term v0.29.0/go.mod h1:6bl4lRlvVuDgSf3179VpIxBF0o10JUpXWOnI7nErv7s=\n+golang.org/x/term v0.31.0 h1:erwDkOK1Msy6offm1mOgvspSkslFnIGsFnxOKoufg3o=\n+golang.org/x/term v0.31.0/go.mod h1:R4BeIy7D95HzImkxGkTW1UQTtP54tio2RyHz7PwK0aw=\n golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n@@ -1284,8 +1284,8 @@ golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\n golang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n golang.org/x/text v0.6.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n-golang.org/x/text v0.22.0 h1:bofq7m3/HAFvbF51jz3Q9wLg3jkvSPuiZu/pD1XwgtM=\n-golang.org/x/text v0.22.0/go.mod h1:YRoo4H8PVmsu+E3Ou7cqLVH8oXWIHVoX0jqUWALQhfY=\n+golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=\n+golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=\n golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n---\n\n\n---\n\nChoice B:\nclient/tailscale/acl.go\n@@ -50,6 +50,18 @@ type NodeAttrGrant struct {\n \tAttr []string `json:\"attr,omitempty\"`\n }\n \n+// ACLAttrConfig defines the configuration for a custom attribute.\n+type ACLAttrConfig struct {\n+\t// Type specifies the attribute type. Valid values: \"string\", \"number\", \"bool\".\n+\tType string `json:\"type,omitempty\"`\n+\n+\t// AllowSetByNode allows nodes to set this attribute themselves.\n+\tAllowSetByNode bool `json:\"allowSetByNode,omitempty\"`\n+\n+\t// BroadcastToPeers lists target nodes to receive this attribute value.\n+\tBroadcastToPeers []string `json:\"broadcastToPeers,omitempty\"`\n+}\n+\n // ACLDetails contains all the details for an ACL.\n type ACLDetails struct {\n \tTests     []ACLTest           `json:\"tests,omitempty\"`\n@@ -58,6 +70,9 @@ type ACLDetails struct {\n \tTagOwners map[string][]string `json:\"tagowners,omitempty\"`\n \tHosts     map[string]string   `json:\"hosts,omitempty\"`\n \tNodeAttrs []NodeAttrGrant     `json:\"nodeAttrs,omitempty\"`\n+\n+\t// AttrConfig maps attribute names to their configuration.\n+\tAttrConfig map[string]ACLAttrConfig `json:\"attrConfig,omitempty\"`\n }\n \n // ACL contains an ACLDetails and metadata.\n---\n\n\n---\n\nChoice C:\nclient/systray/logo.go\n@@ -11,10 +11,12 @@ import (\n \t\"image\"\n \t\"image/color\"\n \t\"image/png\"\n+\t\"runtime\"\n \t\"sync\"\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/fogleman/gg\"\n )\n \n@@ -251,7 +253,13 @@ func (logo tsLogo) renderWithBorder(borderUnits int) *bytes.Buffer {\n \t}\n \n \tb := bytes.NewBuffer(nil)\n-\tpng.Encode(b, dc.Image())\n+\n+\t// Encode as ICO format on Windows, PNG on all other platforms.\n+\tif runtime.GOOS == \"windows\" {\n+\t\t_ = ico.Encode(b, dc.Image())\n+\t} else {\n+\t\t_ = png.Encode(b, dc.Image())\n+\t}\n \treturn b\n }\n \n---\nclient/systray/systray.go\n@@ -7,9 +7,11 @@\n package systray\n \n import (\n+\t\"bytes\"\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"image\"\n \t\"io\"\n \t\"log\"\n \t\"net/http\"\n@@ -23,6 +25,7 @@ import (\n \t\"time\"\n \n \t\"fyne.io/systray\"\n+\tico \"github.com/Kodeworks/golang-image-ico\"\n \t\"github.com/atotto/clipboard\"\n \tdbus \"github.com/godbus/dbus/v5\"\n \t\"github.com/toqueteos/webbrowser\"\n@@ -330,6 +333,20 @@ func setRemoteIcon(menu *systray.MenuItem, urlStr string) {\n \t\tresp, err := http.Get(urlStr)\n \t\tif err == nil && resp.StatusCode == http.StatusOK {\n \t\t\tb, _ = io.ReadAll(resp.Body)\n+\n+\t\t\t// Convert image to ICO format on Windows\n+\t\t\tif runtime.GOOS == \"windows\" {\n+\t\t\t\tim, _, err := image.Decode(bytes.NewReader(b))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tbuf := bytes.NewBuffer(nil)\n+\t\t\t\tif err := ico.Encode(buf, im); err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tb = buf.Bytes()\n+\t\t\t}\n+\n \t\t\thttpCache[urlStr] = b\n \t\t\tresp.Body.Close()\n \t\t}\n---\ngo.mod\n@@ -4,7 +4,8 @@ go 1.24.0\n \n require (\n \tfilippo.io/mkcert v1.4.4\n-\tfyne.io/systray v1.11.0\n+\tfyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a\n+\tgithub.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9\n \tgithub.com/akutz/memconn v0.1.0\n \tgithub.com/alexbrainman/sspi v0.0.0-20231016080023-1a75b4708caa\n \tgithub.com/andybalholm/brotli v1.1.0\n@@ -100,7 +101,7 @@ require (\n \tgolang.org/x/net v0.36.0\n \tgolang.org/x/oauth2 v0.26.0\n \tgolang.org/x/sync v0.11.0\n-\tgolang.org/x/sys v0.30.0\n+\tgolang.org/x/sys v0.31.0\n \tgolang.org/x/term v0.29.0\n \tgolang.org/x/time v0.10.0\n \tgolang.org/x/tools v0.30.0\n---\ngo.sum\n@@ -41,8 +41,8 @@ filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\n filippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\n filippo.io/mkcert v1.4.4 h1:8eVbbwfVlaqUM7OwuftKc2nuYOoTDQWqsoXmzoXZdbc=\n filippo.io/mkcert v1.4.4/go.mod h1:VyvOchVuAye3BoUsPUOOofKygVwLV2KQMVFJNRq+1dA=\n-fyne.io/systray v1.11.0 h1:D9HISlxSkx+jHSniMBR6fCFOUjk1x/OOOJLa9lJYAKg=\n-fyne.io/systray v1.11.0/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a h1:I8mEKo5sawHu8CqYf3FSjIl9b3puXasFVn2D/hrCneY=\n+fyne.io/systray v1.11.1-0.20250317195939-bcf6eed85e7a/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=\n github.com/4meepo/tagalign v1.3.3 h1:ZsOxcwGD/jP4U/aw7qeWu58i7dwYemfy5Y+IF1ACoNw=\n github.com/4meepo/tagalign v1.3.3/go.mod h1:Q9c1rYMZJc9dPRkbQPpcBNCLEmY2njbAsXhQOZFE2dE=\n github.com/Abirdcfly/dupword v0.0.14 h1:3U4ulkc8EUo+CaT105/GJ1BQwtgyj6+VaBVbAX11Ba8=\n@@ -67,6 +67,8 @@ github.com/Djarvur/go-err113 v0.1.0 h1:uCRZZOdMQ0TZPHYTdYpoC0bLYJKPEHPUJ8MeAa51l\n github.com/Djarvur/go-err113 v0.1.0/go.mod h1:4UJr5HIiMZrwgkSPdsjy2uOQExX/WEILpIrO9UPGuXs=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0 h1:sATXp1x6/axKxz2Gjxv8MALP0bXaNRfQinEwyfMcx8c=\n github.com/GaijinEntertainment/go-exhaustruct/v3 v3.2.0/go.mod h1:Nl76DrGNJTA1KJ0LePKBw/vznBX1EHbAZX8mwjR82nI=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9 h1:1ltqoej5GtaWF8jaiA49HwsZD459jqm9YFz9ZtMFpQA=\n+github.com/Kodeworks/golang-image-ico v0.0.0-20141118225523-73f0f4cfade9/go.mod h1:7uhhqiBaR4CpN0k9rMjOtjpcfGd6DG2m04zQxKnWQ0I=\n github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\n github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\n github.com/Masterminds/semver v1.5.0 h1:H65muMkzWKEuNDnfl9d70GUjFniHKHRbFPGBuZ3QEww=\n@@ -1218,8 +1220,8 @@ golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n-golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=\n-golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=\n+golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n---\n\n\n---\n\nChoice D:\nutil/set/smallset.go\n@@ -0,0 +1,134 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package set\n+\n+import (\n+\t\"iter\"\n+\t\"maps\"\n+\n+\t\"tailscale.com/types/structs\"\n+)\n+\n+// SmallSet is a set that is optimized for reducing memory overhead when the\n+// expected size of the set is 0 or 1 elements.\n+//\n+// The zero value of SmallSet is a usable empty set.\n+//\n+// When storing a SmallSet in a map as a value type, it is important to re-assign\n+// the map entry after calling Add or Delete, as the SmallSet's representation\n+// may change.\n+//\n+// Copying a SmallSet by value may alias the previous value. Use the Clone method\n+// to create a new SmallSet with the same contents.\n+type SmallSet[T comparable] struct {\n+\t_   structs.Incomparable // to prevent == mistakes\n+\tone T                    // if non-zero, then single item in set\n+\tm   Set[T]               // if non-nil, the set of items, which might be size 1 if it's the zero value of T\n+}\n+\n+// Values returns an iterator over the elements of the set.\n+// The iterator will yield the elements in no particular order.\n+func (s SmallSet[T]) Values() iter.Seq[T] {\n+\tif s.m != nil {\n+\t\treturn maps.Keys(s.m)\n+\t}\n+\tvar zero T\n+\treturn func(yield func(T) bool) {\n+\t\tif s.one != zero {\n+\t\t\tyield(s.one)\n+\t\t}\n+\t}\n+}\n+\n+// Contains reports whether e is in the set.\n+func (s SmallSet[T]) Contains(e T) bool {\n+\tif s.m != nil {\n+\t\treturn s.m.Contains(e)\n+\t}\n+\tvar zero T\n+\treturn e != zero && s.one == e\n+}\n+\n+// Add adds e to the set.\n+//\n+// When storing a SmallSet in a map as a value type, it is important to\n+// re-assign the map entry after calling Add or Delete, as the SmallSet's\n+// representation may change.\n+func (s *SmallSet[T]) Add(e T) {\n+\tvar zero T\n+\tif s.m != nil {\n+\t\ts.m.Add(e)\n+\t\treturn\n+\t}\n+\t// Size zero to one non-zero element.\n+\tif s.one == zero && e != zero {\n+\t\ts.one = e\n+\t\treturn\n+\t}\n+\t// Need to make a multi map, either\n+\t// because we now have two items, or\n+\t// because e is the zero value.\n+\ts.m = Set[T]{}\n+\tif s.one != zero {\n+\t\ts.m.Add(s.one) // move single item to multi\n+\t}\n+\ts.m.Add(e) // add new item\n+\ts.one = zero\n+}\n+\n+// Len reports the number of elements in the set.\n+func (s SmallSet[T]) Len() int {\n+\tvar zero T\n+\tif s.m != nil {\n+\t\treturn s.m.Len()\n+\t}\n+\tif s.one != zero {\n+\t\treturn 1\n+\t}\n+\treturn 0\n+}\n+\n+// Delete removes e from the set.\n+//\n+// When storing a SmallSet in a map as a value type, it is important to\n+// re-assign the map entry after calling Add or Delete, as the SmallSet's\n+// representation may change.\n+func (s *SmallSet[T]) Delete(e T) {\n+\tvar zero T\n+\tif s.m == nil {\n+\t\tif s.one == e {\n+\t\t\ts.one = zero\n+\t\t}\n+\t\treturn\n+\t}\n+\ts.m.Delete(e)\n+\n+\t// If the map size drops to zero, that means\n+\t// it only contained the zero value of T.\n+\tif s.m.Len() == 0 {\n+\t\ts.m = nil\n+\t\treturn\n+\t}\n+\n+\t// If the map size drops to one element and doesn't\n+\t// contain the zero value, we can switch back to the\n+\t// single-item representation.\n+\tif s.m.Len() == 1 {\n+\t\tfor v := range s.m {\n+\t\t\tif v != zero {\n+\t\t\t\ts.one = v\n+\t\t\t\ts.m = nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// Clone returns a copy of s that doesn't alias the original.\n+func (s SmallSet[T]) Clone() SmallSet[T] {\n+\treturn SmallSet[T]{\n+\t\tone: s.one,\n+\t\tm:   maps.Clone(s.m), // preserves nilness\n+\t}\n+}\n---\nutil/set/smallset_test.go\n@@ -0,0 +1,91 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package set\n+\n+import (\n+\t\"fmt\"\n+\t\"iter\"\n+\t\"maps\"\n+\t\"reflect\"\n+\t\"slices\"\n+\t\"testing\"\n+)\n+\n+func TestSmallSet(t *testing.T) {\n+\tt.Parallel()\n+\n+\twantSize := reflect.TypeFor[int64]().Size() + reflect.TypeFor[map[int]struct{}]().Size()\n+\tif wantSize > 16 {\n+\t\tt.Errorf(\"wantSize should be no more than 16\") // it might be smaller on 32-bit systems\n+\t}\n+\tif size := reflect.TypeFor[SmallSet[int64]]().Size(); size != wantSize {\n+\t\tt.Errorf(\"SmallSet[int64] size is %d, want %v\", size, wantSize)\n+\t}\n+\n+\ttype op struct {\n+\t\tadd bool\n+\t\tv   int\n+\t}\n+\tops := iter.Seq[op](func(yield func(op) bool) {\n+\t\tfor _, add := range []bool{false, true} {\n+\t\t\tfor v := range 4 {\n+\t\t\t\tif !yield(op{add: add, v: v}) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t})\n+\ttype setLike interface {\n+\t\tAdd(int)\n+\t\tDelete(int)\n+\t}\n+\tapply := func(s setLike, o op) {\n+\t\tif o.add {\n+\t\t\ts.Add(o.v)\n+\t\t} else {\n+\t\t\ts.Delete(o.v)\n+\t\t}\n+\t}\n+\n+\t// For all combinations of 4 operations,\n+\t// apply them to both a regular map and SmallSet\n+\t// and make sure all the invariants hold.\n+\n+\tfor op1 := range ops {\n+\t\tfor op2 := range ops {\n+\t\t\tfor op3 := range ops {\n+\t\t\t\tfor op4 := range ops {\n+\n+\t\t\t\t\tnormal := Set[int]{}\n+\t\t\t\t\tsmall := &SmallSet[int]{}\n+\t\t\t\t\tfor _, op := range []op{op1, op2, op3, op4} {\n+\t\t\t\t\t\tapply(normal, op)\n+\t\t\t\t\t\tapply(small, op)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tname := func() string {\n+\t\t\t\t\t\treturn fmt.Sprintf(\"op1=%v, op2=%v, op3=%v, op4=%v\", op1, op2, op3, op4)\n+\t\t\t\t\t}\n+\t\t\t\t\tif normal.Len() != small.Len() {\n+\t\t\t\t\t\tt.Errorf(\"len mismatch after ops %s: normal=%d, small=%d\", name(), normal.Len(), small.Len())\n+\t\t\t\t\t}\n+\t\t\t\t\tif got := small.Clone().Len(); normal.Len() != got {\n+\t\t\t\t\t\tt.Errorf(\"len mismatch after ops %s: normal=%d, clone=%d\", name(), normal.Len(), got)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tnormalEle := slices.Sorted(maps.Keys(normal))\n+\t\t\t\t\tsmallEle := slices.Sorted(small.Values())\n+\t\t\t\t\tif !slices.Equal(normalEle, smallEle) {\n+\t\t\t\t\t\tt.Errorf(\"elements mismatch after ops %s: normal=%v, small=%v\", name(), normalEle, smallEle)\n+\t\t\t\t\t}\n+\t\t\t\t\tfor e := range 5 {\n+\t\t\t\t\t\tif normal.Contains(e) != small.Contains(e) {\n+\t\t\t\t\t\t\tt.Errorf(\"contains(%v) mismatch after ops %s: normal=%v, small=%v\", e, name(), normal.Contains(e), small.Contains(e))\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nOtherwise you can get stuck finding minor ones nonstop.\n\nFixes #15484\n\n\n---\n\nChoice A:\nipn/ipnstate/ipnstate.go\n@@ -53,9 +53,6 @@ type Status struct {\n \t// If nil, an exit node is not in use.\n \tExitNodeStatus *ExitNodeStatus `json:\"ExitNodeStatus,omitempty\"`\n \n-\t// DERPHomeRegionID is the current home DERP region ID.\n-\tDERPHomeRegionID int\n-\n \t// Health contains health check problems.\n \t// Empty means everything is good. (or at least that no known\n \t// problems are detected)\n---\nwgengine/magicsock/magicsock.go\n@@ -2892,15 +2892,11 @@ func (c *Conn) UpdateStatus(sb *ipnstate.StatusBuilder) {\n \t\t})\n \t}\n \n-\tsb.MutateStatus(func(s *ipnstate.Status) {\n-\t\ts.DERPHomeRegionID = c.myDerp\n-\t\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n-\t\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n-\t\t\t// to include all the DERP connections we have open\n-\t\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n-\t\t})\n+\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n+\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n+\t\t// to include all the DERP connections we have open\n+\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n \t})\n-\n }\n \n // SetStatistics specifies a per-connection statistics aggregator.\n---\n\n\n---\n\nChoice B:\nnet/netmon/netmon.go\n@@ -441,14 +441,14 @@ func (m *Monitor) handlePotentialChange(newState *State, forceCallbacks bool) {\n \tdelta.Major = m.IsMajorChangeFrom(oldState, newState)\n \tif delta.Major {\n \t\tm.gwValid = false\n-\t\tm.ifState = newState\n \n \t\tif s1, s2 := oldState.String(), delta.New.String(); s1 == s2 {\n \t\t\tm.logf(\"[unexpected] network state changed, but stringification didn't: %v\", s1)\n \t\t\tm.logf(\"[unexpected] old: %s\", jsonSummary(oldState))\n \t\t\tm.logf(\"[unexpected] new: %s\", jsonSummary(newState))\n \t\t}\n \t}\n+\tm.ifState = newState\n \t// See if we have a queued or new time jump signal.\n \tif timeJumped {\n \t\tm.resetTimeJumpedLocked()\n---\n\n\n---\n\nChoice C:\ndocs/commit-messages.md\n@@ -72,7 +72,7 @@ For the body (the rest of the description):\n \n - blank line after the subject (first) line\n - the text should be wrapped to ~76 characters (to appease git viewing tools, mainly), unless you really need longer lines (e.g. for ASCII art, tables, or long links)\n-- there must be a `Fixes` or `Updates` line for all non-trivial commits linking to a tracking bug. This goes after the body with a blank newline separating the two. Trivial code clean-up commits can use `Updates #cleanup` instead of an issue.\n+- there must be a `Fixes` or `Updates` line for all non-cleanup commits linking to a tracking bug. This goes after the body with a blank newline separating the two. [Cleanup commits](#is-it-a-cleanup) can use `Updates #cleanup` instead of an issue.\n - `Change-Id` lines should ideally be included in commits in the `corp` repo and are more optional in `tailscale/tailscale`. You can configure Git to do this for you by running `./tool/go run misc/install-git-hooks.go` from the root of the corp repo. This was originally a Gerrit thing and we don't use Gerrit, but it lets us tooling track commits as they're cherry-picked between branches. Also, tools like [git-cleanup](https://github.com/bradfitz/gitutil) use it to clean up your old local branches once they're merged upstream.\n - we don't use Markdown in commit messages. (Accidental Markdown like bulleted lists or even headings is fine, but not links)\n - we require `Signed-off-by` lines in public repos (such as `tailscale/tailscale`). Add them using `git commit --signoff` or `git commit -s` for short. You can use them in private repos but do not have to.\n@@ -108,6 +108,54 @@ For changes in `tailscale/tailscale` that fix a significant bug or add a new fea\n add `RELNOTE: <summary of change>` toward the end of the commit message.\n This will aid the release engineer in writing the release notes for the next release.\n \n+## Is it a #cleanup?\n+\n+Our issuebot permits writing `Updates #cleanup` instead of an actual GitHub issue number.\n+\n+But only do that if it\u2019s actually a cleanup. Don\u2019t use that as an excuse to avoid filing an issue.\n+\n+Shortcuts[^1] to file issues:\n+- [go/bugc](http://go/bugc) (corp, safe choice)\n+- [go/bugo](http://go/bugo) (open source, if you want it public to the world).\n+\n+[^1]: These shortcuts point to our Tailscale\u2019s internal URL shortener service, which you too [can run in your own Tailnet](https://tailscale.com/blog/golink).\n+\n+The following guide can help you decide whether a tracking issue is warranted.\n+\n+|     |     |\n+| --- | --- |\n+| Was there a crash/panic? | Not a cleanup. Put the panic in a bug. Talk about when it was introduced, why, why a test didn\u2019t catch it, note what followup work might need to be done. |\n+| Did a customer report it? | Not a cleanup. Make a corp bug with links to the customer ticket. |\n+| Is it from an incident, get paged? | Not a cleanup. Let\u2019s track why we got paged. |\n+| Does it change behavior? | Not a cleanup. File a bug to track why. |\n+| Adding a test for a recently fixed bug? | Not a cleanup. Use the recently fixed bug\u2019s bug number. |\n+| Does it tweak a constant/parameter? | Not a cleanup. File a bug to track the debugging/tuning effort and record past results and goals for the future state. |\n+| Fixing a regression from an earlier change? | Not a cleanup. At minimum, reference the PR that caused the regression, but if users noticed, it might warrant its own bug. |\n+| Is it part of an overall effort that\u2019ll take a hundred small steps? | Not a cleanup. The overall effort should have a tracking bug to collect all the minor efforts. |\n+| Is it a security fix? Is it a security hardening? | Not a cleanup. There should be a bug about security incidents or security hardening efforts and backporting to previous releases, etc. |\n+| Is it a feature flag being removed? | Not a cleanup. File a task to coordinate with other teams and to track the work. |\n+\n+### Actual cleanup examples\n+\n+- Fixing typos in internal comments that users would\u2019ve never seen\n+- Simple, mechanical replacement of a deprecated API to its equivalently behaving replacement\n+  - [`errors.Wrapf`](https://pkg.go.dev/github.com/pkg/errors#Wrapf) \u2192 [`fmt.Errorf(\"%w\")`](https://pkg.go.dev/fmt#Errorf)\n+  - [math/rand](https://pkg.go.dev/math/rand) \u2192 [math/rand/v2](https://pkg.go.dev/math/rand/v2)\n+- Code movement\n+- Removing dead code that doesn\u2019t change behavior (API changes, feature flags, etc)\n+- Refactoring in prep for another change (but maybe mention the upcoming change\u2019s bug as motivation)\n+- Adding a test that you just noticed was missing, not as a result of any bug or report or new feature coming\n+- Formatting (gofmt / prettifier) that was missed earlier\n+\n+### What\u2019s the point of an issue?\n+\n+- Let us capture information that is inappropriate for a commit message\n+- Let us have conversations on a change after the fact\n+- Let us track metadata on issues and decide what to backport\n+- Let us associate related changes to each other, including after the fact\n+- Lets you write the backstory once on an overall bug/effort and re-use that issue number for N future commits, without having to repeat yourself on each commit message\n+- Provides archaeological breadcrumbs to future debuggers, providing context on why things were changed\n+\n # Reverts\n \n When you use `git revert` to revert a commit, the default commit message will identify the commit SHA and message that was reverted.  You must expand this message to explain **why** it is being reverted, including a link to the associated issue.\n---\n\n\n---\n\nChoice D:\nnet/packet/packet.go\n@@ -51,10 +51,11 @@ type Parsed struct {\n \tIPVersion uint8\n \t// IPProto is the IP subprotocol (UDP, TCP, etc.). Valid iff IPVersion != 0.\n \tIPProto ipproto.Proto\n-\t// SrcIP4 is the source address. Family matches IPVersion. Port is\n-\t// valid iff IPProto == TCP || IPProto == UDP.\n+\t// Src is the source address. Family matches IPVersion. Port is\n+\t// valid iff IPProto == TCP || IPProto == UDP || IPProto == SCTP.\n \tSrc netip.AddrPort\n-\t// DstIP4 is the destination address. Family matches IPVersion.\n+\t// Dst is the destination address. Family matches IPVersion. Port is\n+\t// valid iff IPProto == TCP || IPProto == UDP || IPProto == SCTP.\n \tDst netip.AddrPort\n \t// TCPFlags is the packet's TCP flag bits. Valid iff IPProto == TCP.\n \tTCPFlags TCPFlag\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIt only affected js/wasm and tamago.\n\nUpdates tailscale/corp#24697\n\n\n---\n\nChoice A:\nnet/netcheck/netcheck.go\n@@ -1045,7 +1045,7 @@ func (c *Client) finishAndStoreReport(rs *reportState, dm *tailcfg.DERPMap) *Rep\n }\n \n // runHTTPOnlyChecks is the netcheck done by environments that can\n-// only do HTTP requests, such as ws/wasm.\n+// only do HTTP requests, such as js/wasm.\n func (c *Client) runHTTPOnlyChecks(ctx context.Context, last *Report, rs *reportState, dm *tailcfg.DERPMap) error {\n \tvar regions []*tailcfg.DERPRegion\n \tif rs.incremental && last != nil {\n@@ -1057,6 +1057,9 @@ func (c *Client) runHTTPOnlyChecks(ctx context.Context, last *Report, rs *report\n \t}\n \tif len(regions) == 0 {\n \t\tfor _, dr := range dm.Regions {\n+\t\t\tif dr.NoMeasureNoHome {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tregions = append(regions, dr)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice B:\nipn/localapi/debugderp.go\n@@ -13,13 +13,15 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"strconv\"\n+\t\"strings\"\n \t\"time\"\n \n \t\"tailscale.com/derp/derphttp\"\n \t\"tailscale.com/ipn/ipnstate\"\n \t\"tailscale.com/net/netaddr\"\n \t\"tailscale.com/net/netns\"\n \t\"tailscale.com/net/stun\"\n+\t\"tailscale.com/net/tlsdial\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/types/key\"\n \t\"tailscale.com/types/nettype\"\n@@ -97,10 +99,22 @@ func (h *Handler) serveDebugDERPRegion(w http.ResponseWriter, r *http.Request) {\n \t\t} else {\n \t\t\tdefer conn.Close()\n \n+\t\t\ttlsConfig := tls.Config{\n+\t\t\t\tServerName: derpNode.HostName,\n+\t\t\t}\n+\t\t\tif derpNode.CertName != \"\" {\n+\t\t\t\t// If the CertName starts with \"sha256-raw:\", then the rest of the string is a hex-encoded SHA256 of the\n+\t\t\t\t// cert to expect. This is used for self-signed certs.\n+\t\t\t\t// See also: tailcfg/derpmap.go\n+\t\t\t\tif suf, ok := strings.CutPrefix(derpNode.CertName, \"sha256-raw:\"); ok {\n+\t\t\t\t\ttlsdial.SetConfigExpectedCertHash(&tlsConfig, suf)\n+\t\t\t\t} else {\n+\t\t\t\t\t// CertName is not a raw cert hash - and is not empty, it should be used.\n+\t\t\t\t\ttlsConfig.ServerName = derpNode.CertName\n+\t\t\t\t}\n+\t\t\t}\n \t\t\t// Upgrade to TLS and verify that works properly.\n-\t\t\ttlsConn := tls.Client(conn, &tls.Config{\n-\t\t\t\tServerName: cmp.Or(derpNode.CertName, derpNode.HostName),\n-\t\t\t})\n+\t\t\ttlsConn := tls.Client(conn, &tlsConfig)\n \t\t\tif err := tlsConn.HandshakeContext(ctx); err != nil {\n \t\t\t\tst.Errors = append(st.Errors, fmt.Sprintf(\"Error upgrading connection to node %q @ %q to TLS over IPv4: %v\", derpNode.HostName, addr, err))\n \t\t\t} else {\n@@ -116,13 +130,22 @@ func (h *Handler) serveDebugDERPRegion(w http.ResponseWriter, r *http.Request) {\n \t\t} else {\n \t\t\tdefer conn.Close()\n \n+\t\t\ttlsConfig := tls.Config{\n+\t\t\t\tServerName: derpNode.HostName,\n+\t\t\t}\n+\t\t\tif derpNode.CertName != \"\" {\n+\t\t\t\tif suf, ok := strings.CutPrefix(derpNode.CertName, \"sha256-raw:\"); ok {\n+\t\t\t\t\ttlsdial.SetConfigExpectedCertHash(&tlsConfig, suf)\n+\t\t\t\t} else {\n+\t\t\t\t\ttlsConfig.ServerName = derpNode.CertName\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// TODO(andrew-d): we should print more\n+\t\t\t// detailed failure information on if/why TLS\n+\t\t\t// verification fails\n+\n \t\t\t// Upgrade to TLS and verify that works properly.\n-\t\t\ttlsConn := tls.Client(conn, &tls.Config{\n-\t\t\t\tServerName: cmp.Or(derpNode.CertName, derpNode.HostName),\n-\t\t\t\t// TODO(andrew-d): we should print more\n-\t\t\t\t// detailed failure information on if/why TLS\n-\t\t\t\t// verification fails\n-\t\t\t})\n+\t\t\ttlsConn := tls.Client(conn, &tlsConfig)\n \t\t\tif err := tlsConn.HandshakeContext(ctx); err != nil {\n \t\t\t\tst.Errors = append(st.Errors, fmt.Sprintf(\"Error upgrading connection to node %q @ %q to TLS over IPv6: %v\", derpNode.HostName, addr, err))\n \t\t\t} else {\n---\nnet/tlsdial/tlsdial.go\n@@ -248,7 +248,7 @@ func SetConfigExpectedCert(c *tls.Config, certDNSName string) {\n }\n \n // SetConfigExpectedCertHash configures c's VerifyPeerCertificate function\n-// to require that exactly 1 cert is presented, and that the hex of its SHA256 hash\n+// to require that no more than 2 certs are presented, and that the hex of the first cert(the server's cert)'s SHA256 hash\n // is equal to wantFullCertSHA256Hex and that it's a valid cert for c.ServerName.\n func SetConfigExpectedCertHash(c *tls.Config, wantFullCertSHA256Hex string) {\n \tif c.VerifyPeerCertificate != nil {\n@@ -263,7 +263,10 @@ func SetConfigExpectedCertHash(c *tls.Config, wantFullCertSHA256Hex string) {\n \t\tif len(rawCerts) == 0 {\n \t\t\treturn errors.New(\"no certs presented\")\n \t\t}\n-\t\tif len(rawCerts) > 1 {\n+\t\t// There may be up to 2 certs: the server's cert (mandatory) and the Metacert (used in TLS1.3 and later, to save a rtt).\n+\t\t// Unfortunately the TLS connection is not established yet, so we can't check the TLS version here.\n+\t\t// Learn more about metacerts at `derp/derp_server.go/initMetacert`.\n+\t\tif len(rawCerts) > 2 {\n \t\t\treturn errors.New(\"unexpected multiple certs presented\")\n \t\t}\n \t\tif fmt.Sprintf(\"%02x\", sha256.Sum256(rawCerts[0])) != wantFullCertSHA256Hex {\n---\n\n\n---\n\nChoice C:\nbuild_dist.sh\n@@ -28,18 +28,26 @@ EOF\n \texit 0\n fi\n \n-tags=\"\"\n+tags=\"${TAGS:-}\"\n ldflags=\"-X tailscale.com/version.longStamp=${VERSION_LONG} -X tailscale.com/version.shortStamp=${VERSION_SHORT}\"\n \n # build_dist.sh arguments must precede go build arguments.\n while [ \"$#\" -gt 1 ]; do\n \tcase \"$1\" in\n \t--extra-small)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --extra-small or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\tldflags=\"$ldflags -w -s\"\n \t\ttags=\"${tags:+$tags,}ts_omit_aws,ts_omit_bird,ts_omit_tap,ts_omit_kube,ts_omit_completion,ts_omit_ssh,ts_omit_wakeonlan,ts_omit_capture\"\n \t\t;;\n \t--box)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --box or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\ttags=\"${tags:+$tags,}ts_include_cli\"\n \t\t;;\n---\n\n\n---\n\nChoice D:\nipn/ipnstate/ipnstate.go\n@@ -53,6 +53,9 @@ type Status struct {\n \t// If nil, an exit node is not in use.\n \tExitNodeStatus *ExitNodeStatus `json:\"ExitNodeStatus,omitempty\"`\n \n+\t// DERPHomeRegionID is the current home DERP region ID.\n+\tDERPHomeRegionID int\n+\n \t// Health contains health check problems.\n \t// Empty means everything is good. (or at least that no known\n \t// problems are detected)\n---\nwgengine/magicsock/magicsock.go\n@@ -2892,11 +2892,15 @@ func (c *Conn) UpdateStatus(sb *ipnstate.StatusBuilder) {\n \t\t})\n \t}\n \n-\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n-\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n-\t\t// to include all the DERP connections we have open\n-\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n+\tsb.MutateStatus(func(s *ipnstate.Status) {\n+\t\ts.DERPHomeRegionID = c.myDerp\n+\t\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n+\t\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n+\t\t\t// to include all the DERP connections we have open\n+\t\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n+\t\t})\n \t})\n+\n }\n \n // SetStatistics specifies a per-connection statistics aggregator.\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nHelps to fix: https://github.com/tailscale/tailscale/issues/12255 and needed for https://github.com/tailscale/tailscale/pull/15150\r\n\r\nThis fixes a bug in the local client where the DELETE request was not being sent correctly. The route was missing a slash before the url and this now matches the switch profile function.\r\n\r\nThis was included in https://github.com/tailscale/tailscale/pull/15150 but moved to its own PR by request of @bradfitz.\n\n---\n\nChoice A:\ncmd/natc/natc.go\n@@ -359,7 +359,7 @@ var tsMBox = dnsmessage.MustNewName(\"support.tailscale.com.\")\n // generateDNSResponse generates a DNS response for the given request. The from\n // argument is the NodeID of the node that sent the request.\n func (c *connector) generateDNSResponse(req *dnsmessage.Message, from tailcfg.NodeID) ([]byte, error) {\n-\tpm, _ := c.perPeerMap.LoadOrStore(from, &perPeerState{c: c})\n+\tpm, _ := c.perPeerMap.LoadOrStore(from, newPerPeerState(c))\n \tvar addrs []netip.Addr\n \tif len(req.Questions) > 0 {\n \t\tswitch req.Questions[0].Type {\n@@ -509,14 +509,22 @@ func proxyTCPConn(c net.Conn, dest string) {\n \n // perPeerState holds the state for a single peer.\n type perPeerState struct {\n-\tc *connector\n+\tv6ULA netip.Prefix\n+\tipset *netipx.IPSet\n \n \tmu           sync.Mutex\n \taddrInUse    *big.Int\n \tdomainToAddr map[string][]netip.Addr\n \taddrToDomain *bart.Table[string]\n }\n \n+func newPerPeerState(c *connector) *perPeerState {\n+\treturn &perPeerState{\n+\t\tipset: c.ipset,\n+\t\tv6ULA: c.v6ULA,\n+\t}\n+}\n+\n // domainForIP returns the domain name assigned to the given IP address and\n // whether it was found.\n func (ps *perPeerState) domainForIP(ip netip.Addr) (_ string, ok bool) {\n@@ -555,7 +563,7 @@ func (ps *perPeerState) unusedIPv4Locked() netip.Addr {\n \tif ps.addrInUse == nil {\n \t\tps.addrInUse = big.NewInt(0)\n \t}\n-\treturn allocAddr(ps.c.ipset, ps.addrInUse)\n+\treturn allocAddr(ps.ipset, ps.addrInUse)\n }\n \n // assignAddrsLocked assigns a pair of unique IP addresses for the given domain\n@@ -570,7 +578,7 @@ func (ps *perPeerState) assignAddrsLocked(domain string) []netip.Addr {\n \tif !v4.IsValid() {\n \t\treturn nil\n \t}\n-\tas16 := ps.c.v6ULA.Addr().As16()\n+\tas16 := ps.v6ULA.Addr().As16()\n \tas4 := v4.As4()\n \tcopy(as16[12:], as4[:])\n \tv6 := netip.AddrFrom16(as16)\n---\ncmd/natc/natc_test.go\n@@ -220,7 +220,7 @@ func TestPerPeerState(t *testing.T) {\n \t}\n \tc.setPrefixes([]netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")})\n \n-\tps := &perPeerState{c: c}\n+\tps := newPerPeerState(c)\n \n \taddrs, err := ps.ipForDomain(\"example.com\")\n \tif err != nil {\n@@ -360,7 +360,7 @@ func TestIPPoolExhaustion(t *testing.T) {\n \t}\n \tc.setPrefixes([]netip.Prefix{smallPrefix})\n \n-\tps := &perPeerState{c: c}\n+\tps := newPerPeerState(c)\n \n \tassignedIPs := make(map[netip.Addr]string)\n \n---\n\n\n---\n\nChoice B:\nclient/local/local.go\n@@ -1504,7 +1504,7 @@ func (lc *Client) SwitchProfile(ctx context.Context, profile ipn.ProfileID) erro\n // If the profile is the current profile, an empty profile\n // will be selected as if SwitchToEmptyProfile was called.\n func (lc *Client) DeleteProfile(ctx context.Context, profile ipn.ProfileID) error {\n-\t_, err := lc.send(ctx, \"DELETE\", \"/localapi/v0/profiles\"+url.PathEscape(string(profile)), http.StatusNoContent, nil)\n+\t_, err := lc.send(ctx, \"DELETE\", \"/localapi/v0/profiles/\"+url.PathEscape(string(profile)), http.StatusNoContent, nil)\n \treturn err\n }\n \n---\n\n\n---\n\nChoice C:\nutil/testenv/testenv.go\n@@ -6,6 +6,7 @@\n package testenv\n \n import (\n+\t\"context\"\n \t\"flag\"\n \n \t\"tailscale.com/types/lazy\"\n@@ -19,3 +20,41 @@ func InTest() bool {\n \t\treturn flag.Lookup(\"test.v\") != nil\n \t})\n }\n+\n+// TB is testing.TB, to avoid importing \"testing\" in non-test code.\n+type TB interface {\n+\tCleanup(func())\n+\tError(args ...any)\n+\tErrorf(format string, args ...any)\n+\tFail()\n+\tFailNow()\n+\tFailed() bool\n+\tFatal(args ...any)\n+\tFatalf(format string, args ...any)\n+\tHelper()\n+\tLog(args ...any)\n+\tLogf(format string, args ...any)\n+\tName() string\n+\tSetenv(key, value string)\n+\tChdir(dir string)\n+\tSkip(args ...any)\n+\tSkipNow()\n+\tSkipf(format string, args ...any)\n+\tSkipped() bool\n+\tTempDir() string\n+\tContext() context.Context\n+}\n+\n+// InParallelTest reports whether t is running as a parallel test.\n+//\n+// Use of this function taints t such that its Parallel method (assuming t is an\n+// actual *testing.T) will panic if called after this function.\n+func InParallelTest(t TB) (isParallel bool) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tisParallel = true\n+\t\t}\n+\t}()\n+\tt.Chdir(\".\") // panics in a t.Parallel test\n+\treturn false\n+}\n---\nutil/testenv/testenv_test.go\n@@ -16,3 +16,16 @@ func TestDeps(t *testing.T) {\n \t\t},\n \t}.Check(t)\n }\n+\n+func TestInParallelTestTrue(t *testing.T) {\n+\tt.Parallel()\n+\tif !InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return true once t.Parallel has been called\")\n+\t}\n+}\n+\n+func TestInParallelTestFalse(t *testing.T) {\n+\tif InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return false before t.Parallel has been called\")\n+\t}\n+}\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -64,7 +64,6 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n-\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4844,12 +4843,6 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n-\t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n-\t} else {\n-\t\tb.dialer.SetRoutes(nil, nil)\n-\t}\n-\n \tb.initPeerAPIListener()\n \tb.readvertiseAppConnectorRoutes()\n }\n---\nwgengine/userspace.go\n@@ -26,6 +26,7 @@ import (\n \t\"tailscale.com/health\"\n \t\"tailscale.com/ipn/ipnstate\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/flowtrack\"\n \t\"tailscale.com/net/ipset\"\n \t\"tailscale.com/net/netmon\"\n@@ -102,6 +103,7 @@ type userspaceEngine struct {\n \ttundev           *tstun.Wrapper\n \twgdev            *device.Device\n \trouter           router.Router\n+\tdialer           *tsdial.Dialer\n \tconfListenPort   uint16 // original conf.ListenPort\n \tdns              *dns.Manager\n \tmagicConn        *magicsock.Conn\n@@ -344,6 +346,7 @@ func NewUserspaceEngine(logf logger.Logf, conf Config) (_ Engine, reterr error)\n \t\twaitCh:         make(chan struct{}),\n \t\ttundev:         tsTUNDev,\n \t\trouter:         rtr,\n+\t\tdialer:         conf.Dialer,\n \t\tconfListenPort: conf.ListenPort,\n \t\tbirdClient:     conf.BIRDClient,\n \t\tcontrolKnobs:   conf.ControlKnobs,\n@@ -1028,6 +1031,14 @@ func (e *userspaceEngine) Reconfig(cfg *wgcfg.Config, routerCfg *router.Config,\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\n+\t\tif resolver.ShouldUseRoutes(e.controlKnobs) {\n+\t\t\te.logf(\"wgengine: Reconfig: user dialer\")\n+\t\t\te.dialer.SetRoutes(routerCfg.Routes, routerCfg.LocalRoutes)\n+\t\t} else {\n+\t\t\te.dialer.SetRoutes(nil, nil)\n+\t\t}\n+\n \t\t// Keep DNS configuration after router configuration, as some\n \t\t// DNS managers refuse to apply settings if the device has no\n \t\t// assigned address.\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [github/codeql-action](https://github.com/github/codeql-action) from 3.28.11 to 3.28.13.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/releases\">github/codeql-action's releases</a>.</em></p>\n<blockquote>\n<h2>v3.28.13</h2>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>3.28.13 - 24 Mar 2025</h2>\n<p>No user facing changes.</p>\n<p>See the full <a href=\"https://github.com/github/codeql-action/blob/v3.28.13/CHANGELOG.md\">CHANGELOG.md</a> for more information.</p>\n<h2>v3.28.12</h2>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>3.28.12 - 19 Mar 2025</h2>\n<ul>\n<li>Dependency caching should now cache more dependencies for Java <code>build-mode: none</code> extractions. This should speed up workflows and avoid inconsistent alerts in some cases.</li>\n<li>Update default CodeQL bundle version to 2.20.7. <a href=\"https://redirect.github.com/github/codeql-action/pull/2810\">#2810</a></li>\n</ul>\n<p>See the full <a href=\"https://github.com/github/codeql-action/blob/v3.28.12/CHANGELOG.md\">CHANGELOG.md</a> for more information.</p>\n</blockquote>\n</details>\n<details>\n<summary>Changelog</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/blob/main/CHANGELOG.md\">github/codeql-action's changelog</a>.</em></p>\n<blockquote>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>[UNRELEASED]</h2>\n<p>No user facing changes.</p>\n<h2>3.28.13 - 24 Mar 2025</h2>\n<p>No user facing changes.</p>\n<h2>3.28.12 - 19 Mar 2025</h2>\n<ul>\n<li>Dependency caching should now cache more dependencies for Java <code>build-mode: none</code> extractions. This should speed up workflows and avoid inconsistent alerts in some cases.</li>\n<li>Update default CodeQL bundle version to 2.20.7. <a href=\"https://redirect.github.com/github/codeql-action/pull/2810\">#2810</a></li>\n</ul>\n<h2>3.28.11 - 07 Mar 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.6. <a href=\"https://redirect.github.com/github/codeql-action/pull/2793\">#2793</a></li>\n</ul>\n<h2>3.28.10 - 21 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.5. <a href=\"https://redirect.github.com/github/codeql-action/pull/2772\">#2772</a></li>\n<li>Address an issue where the CodeQL Bundle would occasionally fail to decompress on macOS. <a href=\"https://redirect.github.com/github/codeql-action/pull/2768\">#2768</a></li>\n</ul>\n<h2>3.28.9 - 07 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.4. <a href=\"https://redirect.github.com/github/codeql-action/pull/2753\">#2753</a></li>\n</ul>\n<h2>3.28.8 - 29 Jan 2025</h2>\n<ul>\n<li>Enable support for Kotlin 2.1.10 when running with CodeQL CLI v2.20.3. <a href=\"https://redirect.github.com/github/codeql-action/pull/2744\">#2744</a></li>\n</ul>\n<h2>3.28.7 - 29 Jan 2025</h2>\n<p>No user facing changes.</p>\n<h2>3.28.6 - 27 Jan 2025</h2>\n<ul>\n<li>Re-enable debug artifact upload for CLI versions 2.20.3 or greater. <a href=\"https://redirect.github.com/github/codeql-action/pull/2726\">#2726</a></li>\n</ul>\n<h2>3.28.5 - 24 Jan 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.3. <a href=\"https://redirect.github.com/github/codeql-action/pull/2717\">#2717</a></li>\n</ul>\n<h2>3.28.4 - 23 Jan 2025</h2>\n<p>No user facing changes.</p>\n<!-- raw HTML omitted -->\n</blockquote>\n<p>... (truncated)</p>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/github/codeql-action/commit/1b549b9259bda1cb5ddde3b41741a82a2d15a841\"><code>1b549b9</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2819\">#2819</a> from github/update-v3.28.13-e0ea14102</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/82630c85f38b5b7c2c9cc279f06af77a080fba19\"><code>82630c8</code></a> Update changelog for v3.28.13</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/e0ea141027937784e3c10ed1679e503fcc2245bc\"><code>e0ea141</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2818\">#2818</a> from github/cklin/empty-pr-diff-range</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/b361a915088c90790a0c458a63a4b63108a9ab0a\"><code>b361a91</code></a> Diff-informed analysis: fix empty PR handling</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/bd1d9ab4eda903e1b5caa241368836575c6c476b\"><code>bd1d9ab</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2816\">#2816</a> from github/cklin/overlay-file-list</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/b98ae6ca52694a727f4a03c9bf7a52df66492f23\"><code>b98ae6c</code></a> Add overlay-database-utils tests</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/9825184a0aec625d59c8e5bcc122734a77e38e7b\"><code>9825184</code></a> Add getFileOidsUnderPath() tests</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/ac67cffe5c20e84b598930c8453336a7404b2786\"><code>ac67cff</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2817\">#2817</a> from github/cklin/default-setup-diff-informed</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/9c674ba4f548f8b6a6f1a7990756e80453894f56\"><code>9c674ba</code></a> build: refresh js files</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/d109dd5d333ab79c34032e0443e15643c347e966\"><code>d109dd5</code></a> Detect PR branches for Default Setup</li>\n<li>Additional commits viewable in <a href=\"https://github.com/github/codeql-action/compare/6bb031afdd8eb862ea3fc1848194185e076637e5...1b549b9259bda1cb5ddde3b41741a82a2d15a841\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=github/codeql-action&package-manager=github_actions&previous-version=3.28.11&new-version=3.28.13)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -958,7 +958,9 @@ func (b *LocalBackend) linkChange(delta *netmon.ChangeDelta) {\n \n \tif peerAPIListenAsync && b.netMap != nil && b.state == ipn.Running {\n \t\twant := b.netMap.GetAddresses().Len()\n-\t\tif len(b.peerAPIListeners) < want {\n+\t\thave := len(b.peerAPIListeners)\n+\t\tb.logf(\"[v1] linkChange: have %d peerAPIListeners, want %d\", have, want)\n+\t\tif have < want {\n \t\t\tb.logf(\"linkChange: peerAPIListeners too low; trying again\")\n \t\t\tb.goTracker.Go(b.initPeerAPIListener)\n \t\t}\n@@ -5369,6 +5371,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n+\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/drive.go\n@@ -4,6 +4,7 @@\n package ipnlocal\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"slices\"\n@@ -338,7 +339,7 @@ func (b *LocalBackend) driveRemotesFromPeers(nm *netmap.NetworkMap) []*drive.Rem\n \t\t\t\t// Check that the peer is allowed to share with us.\n \t\t\t\taddresses := peer.Addresses()\n \t\t\t\tfor _, p := range addresses.All() {\n-\t\t\t\t\tif cn.PeerHasCap(p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n+\t\t\t\t\tif cn.PeerHasCap(context.Background(), p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n---\nipn/ipnlocal/local.go\n@@ -96,6 +96,7 @@ import (\n \t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/util/clientmetric\"\n+\t\"tailscale.com/util/ctxkey\"\n \t\"tailscale.com/util/deephash\"\n \t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/goroutines\"\n@@ -1463,15 +1464,19 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+var nodeCtxLockedKey = ctxkey.New(\"localNodeContext-locked\", false)\n+\n+var ctxNodeContextLocked = nodeCtxLockedKey.WithValue(context.Background(), true)\n+\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(context.Context, tailcfg.NodeView) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tif pred(ctxNodeContextLocked, peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n@@ -6652,9 +6657,11 @@ func (b *LocalBackend) TestOnlyPublicKeys() (machineKey key.MachinePublic, nodeK\n \n // PeerHasCap reports whether the peer with the given Tailscale IP addresses\n // contains the given capability string, with any value(s).\n-func (b *localNodeContext) PeerHasCap(addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n-\tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n+func (b *localNodeContext) PeerHasCap(ctx context.Context, addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n+\tif !nodeCtxLockedKey.Value(ctx) {\n+\t\tb.mu.Lock()\n+\t\tdefer b.mu.Unlock()\n+\t}\n \treturn b.peerHasCapLocked(addr, wantCap)\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n+\tpeers := cn.AppendMatchingPeers(nil, func(ctx context.Context, p tailcfg.NodeView) bool {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n \t\tif self != p.User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(ctx, p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n@@ -241,7 +241,7 @@ func (b *LocalBackend) taildropTargetStatus(p tailcfg.NodeView) ipnstate.Taildro\n \t}\n \tif nm.User() != p.User() {\n \t\t// Different user must have the explicit file sharing target capability\n-\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(context.Background(), p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn ipnstate.TaildropTargetOwnedByOtherUser\n \t\t}\n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/init@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/autobuild@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/analyze@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/set.go\n@@ -11,6 +11,7 @@ import (\n \t\"net/netip\"\n \t\"os/exec\"\n \t\"runtime\"\n+\t\"strconv\"\n \t\"strings\"\n \n \t\"github.com/peterbourgon/ff/v3/ffcli\"\n@@ -22,6 +23,7 @@ import (\n \t\"tailscale.com/net/tsaddr\"\n \t\"tailscale.com/safesocket\"\n \t\"tailscale.com/types/opt\"\n+\t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/version\"\n )\n@@ -62,6 +64,7 @@ type setArgsT struct {\n \tsnat                   bool\n \tstatefulFiltering      bool\n \tnetfilterMode          string\n+\trelayServerPort        string\n }\n \n func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n@@ -82,6 +85,7 @@ func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n \tsetf.BoolVar(&setArgs.updateApply, \"auto-update\", false, \"automatically update to the latest available version\")\n \tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, hidden+\"allow management plane to gather device posture information\")\n \tsetf.BoolVar(&setArgs.runWebClient, \"webclient\", false, \"expose the web interface for managing this node over Tailscale at port 5252\")\n+\tsetf.StringVar(&setArgs.relayServerPort, \"relay-server-port\", \"\", hidden+\"UDP port number (0 will pick a random unused port) for the relay server to bind to, on all interfaces, or empty string to disable relay server functionality\")\n \n \tffcomplete.Flag(setf, \"exit-node\", func(args []string) ([]string, ffcomplete.ShellCompDirective, error) {\n \t\tst, err := localClient.Status(context.Background())\n@@ -233,6 +237,15 @@ func runSet(ctx context.Context, args []string) (retErr error) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tif setArgs.relayServerPort != \"\" {\n+\t\tuport, err := strconv.ParseUint(setArgs.relayServerPort, 10, 16)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"failed to set relay server port: %v\", err)\n+\t\t}\n+\t\tmaskedPrefs.Prefs.RelayServerPort = ptr.To(int(uport))\n+\t}\n+\n \tcheckPrefs := curPrefs.Clone()\n \tcheckPrefs.ApplyEdits(maskedPrefs)\n \tif err := localClient.CheckPrefs(ctx, checkPrefs); err != nil {\n---\ncmd/tailscale/cli/up.go\n@@ -773,6 +773,7 @@ func init() {\n \taddPrefFlagMapping(\"auto-update\", \"AutoUpdate.Apply\")\n \taddPrefFlagMapping(\"advertise-connector\", \"AppConnector\")\n \taddPrefFlagMapping(\"posture-checking\", \"PostureChecking\")\n+\taddPrefFlagMapping(\"relay-server-port\", \"RelayServerPort\")\n }\n \n func addPrefFlagMapping(flagName string, prefNames ...string) {\n---\nipn/ipn_clone.go\n@@ -61,6 +61,9 @@ func (src *Prefs) Clone() *Prefs {\n \t\t\t}\n \t\t}\n \t}\n+\tif dst.RelayServerPort != nil {\n+\t\tdst.RelayServerPort = ptr.To(*src.RelayServerPort)\n+\t}\n \tdst.Persist = src.Persist.Clone()\n \treturn dst\n }\n@@ -96,6 +99,7 @@ var _PrefsCloneNeedsRegeneration = Prefs(struct {\n \tPostureChecking        bool\n \tNetfilterKind          string\n \tDriveShares            []*drive.Share\n+\tRelayServerPort        *int\n \tAllowSingleHosts       marshalAsTrueInJSON\n \tPersist                *persist.Persist\n }{})\n---\nipn/ipn_view.go\n@@ -166,6 +166,10 @@ func (v PrefsView) NetfilterKind() string                 { return v.\u0436.Netfilte\n func (v PrefsView) DriveShares() views.SliceView[*drive.Share, drive.ShareView] {\n \treturn views.SliceOfViews[*drive.Share, drive.ShareView](v.\u0436.DriveShares)\n }\n+func (v PrefsView) RelayServerPort() views.ValuePointer[int] {\n+\treturn views.ValuePointerOf(v.\u0436.RelayServerPort)\n+}\n+\n func (v PrefsView) AllowSingleHosts() marshalAsTrueInJSON { return v.\u0436.AllowSingleHosts }\n func (v PrefsView) Persist() persist.PersistView          { return v.\u0436.Persist.View() }\n \n@@ -200,6 +204,7 @@ var _PrefsViewNeedsRegeneration = Prefs(struct {\n \tPostureChecking        bool\n \tNetfilterKind          string\n \tDriveShares            []*drive.Share\n+\tRelayServerPort        *int\n \tAllowSingleHosts       marshalAsTrueInJSON\n \tPersist                *persist.Persist\n }{})\n---\nipn/prefs.go\n@@ -246,6 +246,14 @@ type Prefs struct {\n \t// by name.\n \tDriveShares []*drive.Share\n \n+\t// RelayServerPort is the UDP port number for the relay server to bind to,\n+\t// on all interfaces. A non-nil zero value signifies a random unused port\n+\t// should be used. A nil value signifies relay server functionality\n+\t// should be disabled. This field is currently experimental, and therefore\n+\t// no guarantees are made about its current naming and functionality when\n+\t// non-nil/enabled.\n+\tRelayServerPort *int `json:\",omitempty\"`\n+\n \t// AllowSingleHosts was a legacy field that was always true\n \t// for the past 4.5 years. It controlled whether Tailscale\n \t// peers got /32 or /127 routes for each other.\n@@ -337,6 +345,7 @@ type MaskedPrefs struct {\n \tPostureCheckingSet        bool                `json:\",omitempty\"`\n \tNetfilterKindSet          bool                `json:\",omitempty\"`\n \tDriveSharesSet            bool                `json:\",omitempty\"`\n+\tRelayServerPortSet        bool                `json:\",omitempty\"`\n }\n \n // SetsInternal reports whether mp has any of the Internal*Set field bools set\n@@ -555,6 +564,9 @@ func (p *Prefs) pretty(goos string) string {\n \t}\n \tsb.WriteString(p.AutoUpdate.Pretty())\n \tsb.WriteString(p.AppConnector.Pretty())\n+\tif p.RelayServerPort != nil {\n+\t\tfmt.Fprintf(&sb, \"relayServerPort=%d \", *p.RelayServerPort)\n+\t}\n \tif p.Persist != nil {\n \t\tsb.WriteString(p.Persist.Pretty())\n \t} else {\n@@ -616,7 +628,8 @@ func (p *Prefs) Equals(p2 *Prefs) bool {\n \t\tp.AppConnector == p2.AppConnector &&\n \t\tp.PostureChecking == p2.PostureChecking &&\n \t\tslices.EqualFunc(p.DriveShares, p2.DriveShares, drive.SharesEqual) &&\n-\t\tp.NetfilterKind == p2.NetfilterKind\n+\t\tp.NetfilterKind == p2.NetfilterKind &&\n+\t\tcompareIntPtrs(p.RelayServerPort, p2.RelayServerPort)\n }\n \n func (au AutoUpdatePrefs) Pretty() string {\n@@ -636,6 +649,16 @@ func (ap AppConnectorPrefs) Pretty() string {\n \treturn \"\"\n }\n \n+func compareIntPtrs(a, b *int) bool {\n+\tif (a == nil) != (b == nil) {\n+\t\treturn false\n+\t}\n+\tif a == nil {\n+\t\treturn true\n+\t}\n+\treturn *a == *b\n+}\n+\n // NewPrefs returns the default preferences to use.\n func NewPrefs() *Prefs {\n \t// Provide default values for options which might be missing\n---\nipn/prefs_test.go\n@@ -65,6 +65,7 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\"PostureChecking\",\n \t\t\"NetfilterKind\",\n \t\t\"DriveShares\",\n+\t\t\"RelayServerPort\",\n \t\t\"AllowSingleHosts\",\n \t\t\"Persist\",\n \t}\n@@ -73,6 +74,9 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\thave, prefsHandles)\n \t}\n \n+\trelayServerPort := func(port int) *int {\n+\t\treturn &port\n+\t}\n \tnets := func(strs ...string) (ns []netip.Prefix) {\n \t\tfor _, s := range strs {\n \t\t\tn, err := netip.ParsePrefix(s)\n@@ -341,6 +345,16 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\t&Prefs{AdvertiseServices: []string{\"svc:tux\", \"svc:amelie\"}},\n \t\t\tfalse,\n \t\t},\n+\t\t{\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(0)},\n+\t\t\t&Prefs{RelayServerPort: nil},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(0)},\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(1)},\n+\t\t\tfalse,\n+\t\t},\n \t}\n \tfor i, tt := range tests {\n \t\tgot := tt.a.Equals(tt.b)\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [golangci/golangci-lint-action](https://github.com/golangci/golangci-lint-action) from 6.5.0 to 7.0.0.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/golangci/golangci-lint-action/releases\">golangci/golangci-lint-action's releases</a>.</em></p>\n<blockquote>\n<h2>v7.0.0</h2>\n<!-- raw HTML omitted -->\n<p>\u26a0\ufe0f <strong>The GitHub Action v7 supports golangci-lint v2 only.</strong> \u26a0\ufe0f</p>\n<h2>What's Changed</h2>\n<h3>Changes</h3>\n<ul>\n<li>feat: golangci-lint v2 support by <a href=\"https://github.com/ldez\"><code>@\u200bldez</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1198\">golangci/golangci-lint-action#1198</a></li>\n</ul>\n<h3>Documentation</h3>\n<ul>\n<li>docs: update annotation permissions by <a href=\"https://github.com/ldez\"><code>@\u200bldez</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1203\">golangci/golangci-lint-action#1203</a></li>\n<li>docs: fix checks permissions for annotations by <a href=\"https://github.com/kema-dev\"><code>@\u200bkema-dev</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1204\">golangci/golangci-lint-action#1204</a></li>\n</ul>\n<h3>Dependencies</h3>\n<ul>\n<li>build(deps-dev): bump the dev-dependencies group with 3 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1207\">golangci/golangci-lint-action#1207</a></li>\n</ul>\n<h2>New Contributors</h2>\n<ul>\n<li><a href=\"https://github.com/kema-dev\"><code>@\u200bkema-dev</code></a> made their first contribution in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1204\">golangci/golangci-lint-action#1204</a></li>\n</ul>\n<p><strong>Full Changelog</strong>: <a href=\"https://github.com/golangci/golangci-lint-action/compare/v6.5.2...v7.0.0\">https://github.com/golangci/golangci-lint-action/compare/v6.5.2...v7.0.0</a></p>\n<h2>v6.5.2</h2>\n<!-- raw HTML omitted -->\n<h2>What's Changed</h2>\n<h3>Changes</h3>\n<ul>\n<li>fix: update max version by <a href=\"https://github.com/ldez\"><code>@\u200bldez</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1201\">golangci/golangci-lint-action#1201</a></li>\n</ul>\n<h3>Dependencies</h3>\n<ul>\n<li>build(deps-dev): bump the dev-dependencies group with 2 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1199\">golangci/golangci-lint-action#1199</a></li>\n</ul>\n<p><strong>Full Changelog</strong>: <a href=\"https://github.com/golangci/golangci-lint-action/compare/v6.5.1...v6.5.2\">https://github.com/golangci/golangci-lint-action/compare/v6.5.1...v6.5.2</a></p>\n<h2>v6.5.1</h2>\n<!-- raw HTML omitted -->\n<h2>What's Changed</h2>\n<h3>Changes</h3>\n<ul>\n<li>fix: octokit retry by <a href=\"https://github.com/ldez\"><code>@\u200bldez</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1193\">golangci/golangci-lint-action#1193</a></li>\n<li>feat: restrict action v6 on golangci-lint v1 by <a href=\"https://github.com/ldez\"><code>@\u200bldez</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1194\">golangci/golangci-lint-action#1194</a></li>\n</ul>\n<h3>Documentation</h3>\n<ul>\n<li>docs: add notes for annotation config by <a href=\"https://github.com/dveeden\"><code>@\u200bdveeden</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1173\">golangci/golangci-lint-action#1173</a></li>\n<li>docs: improve verify option explanation by <a href=\"https://github.com/ldez\"><code>@\u200bldez</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1175\">golangci/golangci-lint-action#1175</a></li>\n</ul>\n<h3>Dependencies</h3>\n<ul>\n<li>build(deps-dev): bump the dev-dependencies group with 3 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1177\">golangci/golangci-lint-action#1177</a></li>\n<li>build(deps): bump the dependencies group with 2 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1178\">golangci/golangci-lint-action#1178</a></li>\n<li>build(deps): bump <code>@\u200boctokit/request</code> from 8.4.0 to 8.4.1 by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1181\">golangci/golangci-lint-action#1181</a></li>\n<li>build(deps-dev): bump the dev-dependencies group with 3 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1185\">golangci/golangci-lint-action#1185</a></li>\n<li>build(deps): bump <code>@\u200btypes/node</code> from 22.13.4 to 22.13.5 in the dependencies group by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1186\">golangci/golangci-lint-action#1186</a></li>\n<li>build(deps): bump <code>@\u200boctokit/plugin-paginate-rest</code> from 9.2.1 to 9.2.2 by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1187\">golangci/golangci-lint-action#1187</a></li>\n<li>build(deps): bump the dependencies group with 2 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1189\">golangci/golangci-lint-action#1189</a></li>\n<li>build(deps-dev): bump the dev-dependencies group across 1 directory with 5 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1190\">golangci/golangci-lint-action#1190</a></li>\n</ul>\n<!-- raw HTML omitted -->\n</blockquote>\n<p>... (truncated)</p>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/1481404843c368bc19ca9406f87d6e0fc97bdcfd\"><code>1481404</code></a> 7.0.0</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/dec74fa03096ff515422f71d18d41307cacde373\"><code>dec74fa</code></a> feat: golangci-lint v2 support (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1198\">#1198</a>)</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/1f07148fa0c704709f56ae92884ec7fc9d19a413\"><code>1f07148</code></a> build(deps-dev): bump the dev-dependencies group with 3 updates (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1207\">#1207</a>)</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/9938e103f8065deff3f289d9e975270d5541b866\"><code>9938e10</code></a> docs: fix checks permissions for annotations (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1204\">#1204</a>)</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/b91d580160cdcb5498a14265c2b329fdc9d62f0a\"><code>b91d580</code></a> docs: update annotation permissions (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1203\">#1203</a>)</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/55c2c1448f86e01eaae002a5a3a9624417608d84\"><code>55c2c14</code></a> 6.5.2</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/911ec56a221f2cb0322fe7e8a32026fafba0056f\"><code>911ec56</code></a> fix: update max version (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1201\">#1201</a>)</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/eb5c0cc4890366046baa605fa7592d303dea28e9\"><code>eb5c0cc</code></a> build(deps-dev): bump the dev-dependencies group with 2 updates (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1199\">#1199</a>)</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/4696ba8babb6127d732c3c6dde519db15edab9ea\"><code>4696ba8</code></a> 6.5.1</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/2ee514f1f31dd3d5f0ae6e6546082968a4b5e342\"><code>2ee514f</code></a> feat: restrict action v6 on golangci-lint v1 (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1194\">#1194</a>)</li>\n<li>Additional commits viewable in <a href=\"https://github.com/golangci/golangci-lint-action/compare/2226d7cb06a077cd73e56eedd38eecad18e5d837...1481404843c368bc19ca9406f87d6e0fc97bdcfd\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=golangci/golangci-lint-action&package-manager=github_actions&previous-version=6.5.0&new-version=7.0.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\nwgengine/magicsock/magicsock_linux.go\n@@ -66,10 +66,10 @@ var (\n \t\t// fragmented, and we don't want to handle reassembly.\n \t\tbpf.LoadAbsolute{Off: 6, Size: 2},\n \t\t// More Fragments bit set means this is part of a fragmented packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 7, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 8, SkipFalse: 0},\n \t\t// Non-zero fragment offset with MF=0 means this is the last\n \t\t// fragment of packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 6, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 7, SkipFalse: 0},\n \n \t\t// Load IP header length into X register.\n \t\tbpf.LoadMemShift{Off: 0},\n---\nwgengine/magicsock/magicsock_linux_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"net/netip\"\n \t\"testing\"\n \n+\t\"golang.org/x/net/bpf\"\n \t\"golang.org/x/sys/cpu\"\n \t\"golang.org/x/sys/unix\"\n \t\"tailscale.com/disco\"\n@@ -146,3 +147,78 @@ func TestEthernetProto(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestBpfDiscardV4(t *testing.T) {\n+\t// Good packet as a reference for what should not be rejected\n+\tudp4Packet := []byte{\n+\t\t// IPv4 header\n+\t\t0x45, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x40, 0x11, 0x00, 0x00,\n+\t\t0x7f, 0x00, 0x00, 0x01, // source ip\n+\t\t0x7f, 0x00, 0x00, 0x02, // dest ip\n+\n+\t\t// UDP header\n+\t\t0x30, 0x39, // src port\n+\t\t0xd4, 0x31, // dest port\n+\t\t0x00, 0x12, // length; 8 bytes header + 10 bytes payload = 18 bytes\n+\t\t0x00, 0x00, // checksum; unused\n+\n+\t\t// Payload: disco magic plus 32 bytes for key and 24 bytes for nonce\n+\t\t0x54, 0x53, 0xf0, 0x9f, 0x92, 0xac, 0x00, 0x01, 0x02, 0x03,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n+\t}\n+\n+\tvm, err := bpf.NewVM(magicsockFilterV4)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed creating BPF VM: %v\", err)\n+\t}\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\treplace map[int]byte\n+\t\taccept  bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"base accepted datagram\",\n+\t\t\treplace: map[int]byte{},\n+\t\t\taccept:  true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"more fragments\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t6: 0x20,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some fragment\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t7: 0x01,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t}\n+\n+\tudp4PacketChanged := make([]byte, len(udp4Packet))\n+\tcopy(udp4PacketChanged, udp4Packet)\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfor k, v := range tt.replace {\n+\t\t\t\tudp4PacketChanged[k] = v\n+\t\t\t}\n+\t\t\tret, err := vm.Run(udp4PacketChanged)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"BPF VM error: %v\", err)\n+\t\t\t}\n+\n+\t\t\tif (ret != 0) != tt.accept {\n+\t\t\t\tt.Errorf(\"expected accept=%v, got ret=%v\", tt.accept, ret)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/drive.go\n@@ -4,6 +4,7 @@\n package ipnlocal\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"slices\"\n@@ -338,7 +339,7 @@ func (b *LocalBackend) driveRemotesFromPeers(nm *netmap.NetworkMap) []*drive.Rem\n \t\t\t\t// Check that the peer is allowed to share with us.\n \t\t\t\taddresses := peer.Addresses()\n \t\t\t\tfor _, p := range addresses.All() {\n-\t\t\t\t\tif cn.PeerHasCap(p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n+\t\t\t\t\tif cn.PeerHasCap(context.Background(), p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n---\nipn/ipnlocal/local.go\n@@ -96,6 +96,7 @@ import (\n \t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/util/clientmetric\"\n+\t\"tailscale.com/util/ctxkey\"\n \t\"tailscale.com/util/deephash\"\n \t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/goroutines\"\n@@ -1463,15 +1464,19 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+var nodeCtxLockedKey = ctxkey.New(\"localNodeContext-locked\", false)\n+\n+var ctxNodeContextLocked = nodeCtxLockedKey.WithValue(context.Background(), true)\n+\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(context.Context, tailcfg.NodeView) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tif pred(ctxNodeContextLocked, peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n@@ -6652,9 +6657,11 @@ func (b *LocalBackend) TestOnlyPublicKeys() (machineKey key.MachinePublic, nodeK\n \n // PeerHasCap reports whether the peer with the given Tailscale IP addresses\n // contains the given capability string, with any value(s).\n-func (b *localNodeContext) PeerHasCap(addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n-\tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n+func (b *localNodeContext) PeerHasCap(ctx context.Context, addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n+\tif !nodeCtxLockedKey.Value(ctx) {\n+\t\tb.mu.Lock()\n+\t\tdefer b.mu.Unlock()\n+\t}\n \treturn b.peerHasCapLocked(addr, wantCap)\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n+\tpeers := cn.AppendMatchingPeers(nil, func(ctx context.Context, p tailcfg.NodeView) bool {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n \t\tif self != p.User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(ctx, p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n@@ -241,7 +241,7 @@ func (b *LocalBackend) taildropTargetStatus(p tailcfg.NodeView) ipnstate.Taildro\n \t}\n \tif nm.User() != p.User() {\n \t\t// Different user must have the explicit file sharing target capability\n-\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(context.Background(), p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn ipnstate.TaildropTargetOwnedByOtherUser\n \t\t}\n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/init@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/autobuild@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@45775bd8235c68ba998cffa5171334d58593da47 # v3.28.15\n+      uses: github/codeql-action/analyze@60168efe1c415ce0f5521ea06d5c2062adbeed1b # v3.28.17\n---\n\n\n---\n\nChoice D:\n.github/workflows/golangci-lint.yml\n@@ -31,9 +31,9 @@ jobs:\n           cache: false\n \n       - name: golangci-lint\n-        uses: golangci/golangci-lint-action@2226d7cb06a077cd73e56eedd38eecad18e5d837 # v6.5.0\n+        uses: golangci/golangci-lint-action@1481404843c368bc19ca9406f87d6e0fc97bdcfd # v7.0.0\n         with:\n-          version: v1.64\n+          version: v2.0.2\n \n           # Show only new issues if it's a pull request.\n           only-new-issues: true\n---\n.golangci.yml\n@@ -1,97 +1,110 @@\n+version: \"2\"\n+# Configuration for how we run golangci-lint\n+# Timeout of 5m was the default in v1.\n+run:\n+  timeout: 5m\n linters:\n   # Don't enable any linters by default; just the ones that we explicitly\n   # enable in the list below.\n-  disable-all: true\n+  default: none\n   enable:\n     - bidichk\n-    - gofmt\n-    - goimports\n     - govet\n     - misspell\n     - revive\n-\n-# Configuration for how we run golangci-lint\n-run:\n-  timeout: 5m\n-\n-issues:\n-  # Excluding configuration per-path, per-linter, per-text and per-source\n-  exclude-rules:\n-    # These are forks of an upstream package and thus are exempt from stylistic\n-    # changes that would make pulling in upstream changes harder.\n-    - path: tempfork/.*\\.go\n-      text: \"File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\"\n-    - path: util/singleflight/.*\\.go\n-      text: \"File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\"\n-\n-# Per-linter settings are contained in this top-level key\n-linters-settings:\n-  gofmt:\n-    rewrite-rules:\n-      - pattern: 'interface{}'\n-        replacement: 'any'\n-\n-  govet:\n+  settings:\n     # Matches what we use in corp as of 2023-12-07\n-    enable:\n-      - asmdecl\n-      - assign\n-      - atomic\n-      - bools\n-      - buildtag\n-      - cgocall\n-      - copylocks\n-      - deepequalerrors\n-      - errorsas\n-      - framepointer\n-      - httpresponse\n-      - ifaceassert\n-      - loopclosure\n-      - lostcancel\n-      - nilfunc\n-      - nilness\n-      - printf\n-      - reflectvaluecompare\n-      - shift\n-      - sigchanyzer\n-      - sortslice\n-      - stdmethods\n-      - stringintconv\n-      - structtag\n-      - testinggoroutine\n-      - tests\n-      - unmarshal\n-      - unreachable\n-      - unsafeptr\n-      - unusedresult\n-    settings:\n-      printf:\n-        # List of print function names to check (in addition to default)\n-        funcs:\n-          - github.com/tailscale/tailscale/types/logger.Discard\n-          # NOTE(andrew-d): this doesn't currently work because the printf\n-          # analyzer doesn't support type declarations\n-          #- github.com/tailscale/tailscale/types/logger.Logf\n-\n-  revive:\n-    enable-all-rules: false\n-    ignore-generated-header: true\n+    govet:\n+      enable:\n+        - asmdecl\n+        - assign\n+        - atomic\n+        - bools\n+        - buildtag\n+        - cgocall\n+        - copylocks\n+        - deepequalerrors\n+        - errorsas\n+        - framepointer\n+        - httpresponse\n+        - ifaceassert\n+        - loopclosure\n+        - lostcancel\n+        - nilfunc\n+        - nilness\n+        - printf\n+        - reflectvaluecompare\n+        - shift\n+        - sigchanyzer\n+        - sortslice\n+        - stdmethods\n+        - stringintconv\n+        - structtag\n+        - testinggoroutine\n+        - tests\n+        - unmarshal\n+        - unreachable\n+        - unsafeptr\n+        - unusedresult\n+      settings:\n+        printf:\n+          # List of print function names to check (in addition to default)\n+          funcs:\n+            - github.com/tailscale/tailscale/types/logger.Discard\n+            # NOTE(andrew-d): this doesn't currently work because the printf\n+            # analyzer doesn't support type declarations\n+            #- github.com/tailscale/tailscale/types/logger.Logf\n+    revive:\n+      enable-all-rules: false\n+      rules:\n+        - name: atomic\n+        - name: context-keys-type\n+        - name: defer\n+          arguments: [[\n+              # Calling 'recover' at the time a defer is registered (i.e. \"defer recover()\") has no effect.\n+              \"immediate-recover\",\n+              # Calling 'recover' outside of a deferred function has no effect\n+              \"recover\",\n+              # Returning values from a deferred function has no effect\n+              \"return\",\n+          ]]\n+        - name: duplicated-imports\n+        - name: errorf\n+        - name: string-of-int\n+        - name: time-equal\n+        - name: unconditional-recursion\n+        - name: useless-break\n+        - name: waitgroup-by-value\n+  exclusions:\n+    generated: lax\n+    presets:\n+      - comments\n+      - common-false-positives\n+      - legacy\n+      - std-error-handling\n     rules:\n-      - name: atomic\n-      - name: context-keys-type\n-      - name: defer\n-        arguments: [[\n-          # Calling 'recover' at the time a defer is registered (i.e. \"defer recover()\") has no effect.\n-          \"immediate-recover\",\n-          # Calling 'recover' outside of a deferred function has no effect\n-          \"recover\",\n-          # Returning values from a deferred function has no effect\n-          \"return\",\n-        ]]\n-      - name: duplicated-imports\n-      - name: errorf\n-      - name: string-of-int\n-      - name: time-equal\n-      - name: unconditional-recursion\n-      - name: useless-break\n-      - name: waitgroup-by-value\n+      # These are forks of an upstream package and thus are exempt from stylistic\n+      # changes that would make pulling in upstream changes harder.\n+      - path: tempfork/.*\\.go\n+        text: File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\n+      - path: util/singleflight/.*\\.go\n+        text: File is not `gofmt`-ed with `-s` `-r 'interface{} -> any'`\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n+formatters:\n+  enable:\n+    - gofmt\n+    - goimports\n+  settings:\n+    gofmt:\n+      rewrite-rules:\n+        - pattern: interface{}\n+          replacement: any\n+  exclusions:\n+    generated: lax\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes #14491\r\n\r\nTS_HOSTNAME and TS_STATE_DIR are now actually used as advertised in the README.\r\n(Since tsnet doesn't parse TS_HOSTNAME or TS_STATE_DIR by itself tmk).\r\n\r\nAlso changed Dockerfile to use `idp` to preserve the existing behavior.\n\n---\n\nChoice A:\nprober/derp.go\n@@ -596,11 +596,23 @@ func (d *derpProber) updateMap(ctx context.Context) error {\n }\n \n func (d *derpProber) ProbeUDP(ipaddr string, port int) ProbeClass {\n+\tinitLabels := make(Labels)\n+\tip := net.ParseIP(ipaddr)\n+\n+\tif ip.To4() != nil {\n+\t\tinitLabels[\"address_family\"] = \"ipv4\"\n+\t} else if ip.To16() != nil { // Will return an IPv4 as 16 byte, so ensure the check for IPv4 precedes this\n+\t\tinitLabels[\"address_family\"] = \"ipv6\"\n+\t} else {\n+\t\tinitLabels[\"address_family\"] = \"unknown\"\n+\t}\n+\n \treturn ProbeClass{\n \t\tProbe: func(ctx context.Context) error {\n \t\t\treturn derpProbeUDP(ctx, ipaddr, port)\n \t\t},\n-\t\tClass: \"derp_udp\",\n+\t\tClass:  \"derp_udp\",\n+\t\tLabels: initLabels,\n \t}\n }\n \n---\nprober/prober.go\n@@ -404,10 +404,14 @@ func (p *Probe) recordEndLocked(err error) {\n \t\tp.mSeconds.WithLabelValues(\"ok\").Add(latency.Seconds())\n \t\tp.latencyHist.Value = latency\n \t\tp.latencyHist = p.latencyHist.Next()\n+\t\tp.mAttempts.WithLabelValues(\"fail\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"fail\").Add(0)\n \t} else {\n \t\tp.latency = 0\n \t\tp.mAttempts.WithLabelValues(\"fail\").Inc()\n \t\tp.mSeconds.WithLabelValues(\"fail\").Add(latency.Seconds())\n+\t\tp.mAttempts.WithLabelValues(\"ok\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"ok\").Add(0)\n \t}\n \tp.successHist.Value = p.succeeded\n \tp.successHist = p.successHist.Next()\n---\n\n\n---\n\nChoice B:\ncmd/tsidp/Dockerfile\n@@ -31,11 +31,11 @@ WORKDIR /app\n \n # Environment variables\n ENV TAILSCALE_USE_WIP_CODE=1 \\\n-    TS_HOSTNAME=tsidp \\\n+    TS_HOSTNAME=idp \\\n     TS_STATE_DIR=/var/lib/tsidp\n \n # Expose the default port\n EXPOSE 443\n \n # Run the application\n-ENTRYPOINT [\"/app/tsidp\"]\n\\ No newline at end of file\n+ENTRYPOINT [\"/bin/sh\", \"-c\", \"/app/tsidp --hostname=${TS_HOSTNAME} --dir=${TS_STATE_DIR}\"]\n---\ncmd/tsidp/README.md\n@@ -38,7 +38,7 @@\n      --name `tsidp` \\\n      -p 443:443 \\\n      -e TS_AUTHKEY=YOUR_TAILSCALE_AUTHKEY \\\n-     -e TS_HOSTNAME=tsidp \\\n+     -e TS_HOSTNAME=idp \\\n      -v tsidp-data:/var/lib/tsidp \\\n      tsidp:latest\n    ```\n@@ -48,7 +48,7 @@\n    docker logs tsidp\n    ```\n \n-   Visit `https://tsidp.tailnet.ts.net` to confirm the service is running.\n+   Visit `https://idp.tailnet.ts.net` to confirm the service is running.\n \n ## Usage Example: Proxmox Integration\n \n@@ -82,13 +82,14 @@ The `tsidp` server supports several command-line flags:\n - `--port`: Port to listen on (default: 443)\n - `--local-port`: Allow requests from localhost\n - `--use-local-tailscaled`: Use local tailscaled instead of tsnet\n+- `--hostname`: tsnet hostname\n - `--dir`: tsnet state directory\n \n ## Environment Variables\n \n - `TS_AUTHKEY`: Your Tailscale authentication key (required)\n-- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\")\n-- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\")\n+- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\", Docker only)\n+- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\", Docker only)\n - `TAILSCALE_USE_WIP_CODE`: Enable work-in-progress code (default: \"1\")\n \n ## Support\n@@ -97,4 +98,4 @@ This is an [experimental](https://tailscale.com/kb/1167/release-stages#experimen\n \n ## License\n \n-BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n\\ No newline at end of file\n+BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n---\ncmd/tsidp/tsidp.go\n@@ -65,6 +65,7 @@ var (\n \tflagLocalPort          = flag.Int(\"local-port\", -1, \"allow requests from localhost\")\n \tflagUseLocalTailscaled = flag.Bool(\"use-local-tailscaled\", false, \"use local tailscaled instead of tsnet\")\n \tflagFunnel             = flag.Bool(\"funnel\", false, \"use Tailscale Funnel to make tsidp available on the public internet\")\n+\tflagHostname           = flag.String(\"hostname\", \"idp\", \"tsnet hostname to use instead of idp\")\n \tflagDir                = flag.String(\"dir\", \"\", \"tsnet state directory; a default one will be created if not provided\")\n )\n \n@@ -121,7 +122,7 @@ func main() {\n \t\tdefer cleanup()\n \t} else {\n \t\tts := &tsnet.Server{\n-\t\t\tHostname: \"idp\",\n+\t\t\tHostname: *flagHostname,\n \t\t\tDir:      *flagDir,\n \t\t}\n \t\tif *flagVerbose {\n---\n\n\n---\n\nChoice C:\ntstest/integration/testcontrol/testcontrol.go\n@@ -839,15 +839,17 @@ func (s *Server) serveMap(w http.ResponseWriter, r *http.Request, mkey key.Machi\n \n \tw.WriteHeader(200)\n \tfor {\n-\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n-\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n-\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif streaming {\n+\t\t// Only send raw map responses to the streaming poll, to avoid a\n+\t\t// non-streaming map request beating the streaming poll in a race and\n+\t\t// potentially dropping the map response.\n+\t\tif streaming {\n+\t\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n+\t\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n+\t\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treturn\n \t\t}\n \n \t\tif s.canGenerateAutomaticMapResponseFor(req.NodeKey) {\n---\n\n\n---\n\nChoice D:\nipn/ipnstate/ipnstate.go\n@@ -53,9 +53,6 @@ type Status struct {\n \t// If nil, an exit node is not in use.\n \tExitNodeStatus *ExitNodeStatus `json:\"ExitNodeStatus,omitempty\"`\n \n-\t// DERPHomeRegionID is the current home DERP region ID.\n-\tDERPHomeRegionID int\n-\n \t// Health contains health check problems.\n \t// Empty means everything is good. (or at least that no known\n \t// problems are detected)\n---\nwgengine/magicsock/magicsock.go\n@@ -2892,15 +2892,11 @@ func (c *Conn) UpdateStatus(sb *ipnstate.StatusBuilder) {\n \t\t})\n \t}\n \n-\tsb.MutateStatus(func(s *ipnstate.Status) {\n-\t\ts.DERPHomeRegionID = c.myDerp\n-\t\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n-\t\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n-\t\t\t// to include all the DERP connections we have open\n-\t\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n-\t\t})\n+\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n+\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n+\t\t// to include all the DERP connections we have open\n+\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n \t})\n-\n }\n \n // SetStatistics specifies a per-connection statistics aggregator.\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFor hooking up websocket VM clients to natlab.\n\nUpdates #13038\n\n\n---\n\nChoice A:\ncmd/natc/ippool/ippool.go\n@@ -24,7 +24,6 @@ var ErrNoIPsAvailable = errors.New(\"no IPs available\")\n type IPPool struct {\n \tperPeerMap syncs.Map[tailcfg.NodeID, *perPeerState]\n \tIPSet      *netipx.IPSet\n-\tV6ULA      netip.Prefix\n }\n \n func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bool) {\n@@ -44,15 +43,13 @@ func (ipp *IPPool) DomainForIP(from tailcfg.NodeID, addr netip.Addr) (string, bo\n func (ipp *IPPool) IPForDomain(from tailcfg.NodeID, domain string) (netip.Addr, error) {\n \tnpps := &perPeerState{\n \t\tipset: ipp.IPSet,\n-\t\tv6ULA: ipp.V6ULA,\n \t}\n \tps, _ := ipp.perPeerMap.LoadOrStore(from, npps)\n \treturn ps.ipForDomain(domain)\n }\n \n // perPeerState holds the state for a single peer.\n type perPeerState struct {\n-\tv6ULA netip.Prefix\n \tipset *netipx.IPSet\n \n \tmu           sync.Mutex\n---\ncmd/natc/ippool/ippool_test.go\n@@ -19,8 +19,7 @@ func TestIPPoolExhaustion(t *testing.T) {\n \tvar ipsb netipx.IPSetBuilder\n \tipsb.AddPrefix(smallPrefix)\n \taddrPool := must.Get(ipsb.IPSet())\n-\tv6ULA := netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\")\n-\tpool := IPPool{V6ULA: v6ULA, IPSet: addrPool}\n+\tpool := IPPool{IPSet: addrPool}\n \n \tassignedIPs := make(map[netip.Addr]string)\n \n@@ -52,9 +51,6 @@ func TestIPPoolExhaustion(t *testing.T) {\n \t\tif addr.Is4() && !smallPrefix.Contains(addr) {\n \t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, smallPrefix)\n \t\t}\n-\t\tif addr.Is6() && !v6ULA.Contains(addr) {\n-\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, v6ULA)\n-\t\t}\n \t}\n \n \t// expect one error for each iteration with the 5th domain\n@@ -73,7 +69,6 @@ func TestIPPool(t *testing.T) {\n \tipsb.AddPrefix(netip.MustParsePrefix(\"100.64.1.0/24\"))\n \taddrPool := must.Get(ipsb.IPSet())\n \tpool := IPPool{\n-\t\tV6ULA: netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n \t\tIPSet: addrPool,\n \t}\n \tfrom := tailcfg.NodeID(12345)\n---\ncmd/natc/natc.go\n@@ -153,7 +153,7 @@ func main() {\n \t\twhois:      lc,\n \t\tv6ULA:      v6ULA,\n \t\tignoreDsts: ignoreDstTable,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\troutes:     routes,\n \t\tdnsAddr:    dnsAddr,\n \t\tresolver:   net.DefaultResolver,\n---\ncmd/natc/natc_test.go\n@@ -270,7 +270,7 @@ func TestDNSResponse(t *testing.T) {\n \t\tignoreDsts: &bart.Table[bool]{},\n \t\troutes:     routes,\n \t\tv6ULA:      v6ULA,\n-\t\tipPool:     &ippool.IPPool{V6ULA: v6ULA, IPSet: addrPool},\n+\t\tipPool:     &ippool.IPPool{IPSet: addrPool},\n \t\tdnsAddr:    dnsAddr,\n \t}\n \tc.ignoreDsts.Insert(netip.MustParsePrefix(\"8.8.4.4/32\"), true)\n---\n\n\n---\n\nChoice B:\ncmd/vnet/vnet-main.go\n@@ -7,15 +7,21 @@ package main\n \n import (\n \t\"context\"\n+\t\"encoding/binary\"\n \t\"flag\"\n+\t\"fmt\"\n+\t\"io\"\n \t\"log\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/http/httputil\"\n \t\"net/url\"\n \t\"os\"\n+\t\"path/filepath\"\n+\t\"slices\"\n \t\"time\"\n \n+\t\"github.com/coder/websocket\"\n \t\"tailscale.com/tstest/natlab/vnet\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/must\"\n@@ -31,10 +37,18 @@ var (\n \tpcapFile = flag.String(\"pcap\", \"\", \"if non-empty, filename to write pcap\")\n \tv4       = flag.Bool(\"v4\", true, \"enable IPv4\")\n \tv6       = flag.Bool(\"v6\", true, \"enable IPv6\")\n+\n+\twsproxyListen = flag.String(\"wsproxy\", \"\", \"if non-empty, TCP address to run websocket server on. See https://github.com/copy/v86/blob/master/docs/networking.md#backend-url-schemes\")\n )\n \n func main() {\n \tflag.Parse()\n+\tif *wsproxyListen != \"\" {\n+\t\tif err := runWSProxy(); err != nil {\n+\t\t\tlog.Fatalf(\"runWSProxy: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n \n \tif _, err := os.Stat(*listen); err == nil {\n \t\tos.Remove(*listen)\n@@ -137,3 +151,168 @@ func main() {\n \t\tgo s.ServeUnixConn(c.(*net.UnixConn), vnet.ProtocolQEMU)\n \t}\n }\n+\n+func runWSProxy() error {\n+\tln, err := net.Listen(\"tcp\", *wsproxyListen)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer ln.Close()\n+\n+\tlog.Printf(\"Running wsproxy mode on %v ...\", *wsproxyListen)\n+\n+\tvar hs http.Server\n+\ths.Handler = http.HandlerFunc(handleWebSocket)\n+\n+\treturn hs.Serve(ln)\n+}\n+\n+func handleWebSocket(w http.ResponseWriter, r *http.Request) {\n+\tconn, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\tif err != nil {\n+\t\tlog.Printf(\"Upgrade error: %v\", err)\n+\t\treturn\n+\t}\n+\tdefer conn.Close(websocket.StatusInternalError, \"closing\")\n+\tlog.Printf(\"WebSocket client connected: %s\", r.RemoteAddr)\n+\n+\tctx, cancel := context.WithCancel(r.Context())\n+\tdefer cancel()\n+\n+\tmessageType, firstData, err := conn.Read(ctx)\n+\tif err != nil {\n+\t\tlog.Printf(\"ReadMessage first: %v\", err)\n+\t\treturn\n+\t}\n+\tif messageType != websocket.MessageBinary {\n+\t\tlog.Printf(\"Ignoring non-binary message\")\n+\t\treturn\n+\t}\n+\tif len(firstData) < 12 {\n+\t\tlog.Printf(\"Ignoring short message\")\n+\t\treturn\n+\t}\n+\tclientMAC := vnet.MAC(firstData[6:12])\n+\n+\t// Set up a qemu-protocol Unix socket pair. We'll fake the qemu protocol here\n+\t// to avoid changing the vnet package.\n+\ttd, err := os.MkdirTemp(\"\", \"vnet\")\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"MkdirTemp: %v\", err))\n+\t}\n+\tdefer os.RemoveAll(td)\n+\n+\tunixSrv := filepath.Join(td, \"vnet.sock\")\n+\n+\tsrv, err := net.Listen(\"unix\", unixSrv)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"Listen: %v\", err))\n+\t}\n+\tdefer srv.Close()\n+\n+\tvar c vnet.Config\n+\tc.SetBlendReality(true)\n+\n+\tvar net1opt = []any{vnet.NAT(\"easy\")}\n+\tnet1opt = append(net1opt, \"2.1.1.1\", \"192.168.1.1/24\")\n+\tnet1opt = append(net1opt, \"2000:52::1/64\")\n+\n+\tc.AddNode(c.AddNetwork(net1opt...), clientMAC)\n+\n+\tvs, err := vnet.New(&c)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"newServer: %v\", err))\n+\t}\n+\tif err := vs.PopulateDERPMapIPs(); err != nil {\n+\t\tlog.Printf(\"warning: ignoring failure to populate DERP map: %v\", err)\n+\t\treturn\n+\t}\n+\n+\terrc := make(chan error, 1)\n+\tfail := func(err error) {\n+\t\tselect {\n+\t\tcase errc <- err:\n+\t\t\tlog.Printf(\"failed: %v\", err)\n+\t\tcase <-ctx.Done():\n+\t\t}\n+\t}\n+\n+\tgo func() {\n+\t\tc, err := srv.Accept()\n+\t\tif err != nil {\n+\t\t\tfail(err)\n+\t\t\treturn\n+\t\t}\n+\t\tvs.ServeUnixConn(c.(*net.UnixConn), vnet.ProtocolQEMU)\n+\t}()\n+\n+\tuc, err := net.Dial(\"unix\", unixSrv)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"Dial: %v\", err))\n+\t}\n+\tdefer uc.Close()\n+\n+\tvar frameBuf []byte\n+\twriteDataToUnixConn := func(data []byte) error {\n+\t\tframeBuf = slices.Grow(frameBuf[:0], len(data)+4)[:len(data)+4]\n+\t\tbinary.BigEndian.PutUint32(frameBuf[:4], uint32(len(data)))\n+\t\tcopy(frameBuf[4:], data)\n+\n+\t\t_, err = uc.Write(frameBuf)\n+\t\treturn err\n+\t}\n+\tif err := writeDataToUnixConn(firstData); err != nil {\n+\t\tfail(err)\n+\t\treturn\n+\t}\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tmessageType, data, err := conn.Read(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\tfail(fmt.Errorf(\"ReadMessage: %v\", err))\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif messageType != websocket.MessageBinary {\n+\t\t\t\tlog.Printf(\"Ignoring non-binary message\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif err := writeDataToUnixConn(data); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tgo func() {\n+\t\tconst maxBuf = 4096\n+\t\tframeBuf := make([]byte, maxBuf)\n+\t\tfor {\n+\t\t\t_, err := io.ReadFull(uc, frameBuf[:4])\n+\t\t\tif err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tframeLen := binary.BigEndian.Uint32(frameBuf[:4])\n+\t\t\tif frameLen > maxBuf {\n+\t\t\t\tfail(fmt.Errorf(\"frame too large: %d\", frameLen))\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif _, err := io.ReadFull(uc, frameBuf[:frameLen]); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := conn.Write(ctx, websocket.MessageBinary, frameBuf[:frameLen]); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\t<-ctx.Done()\n+}\n---\ntstest/natlab/vnet/conf.go\n@@ -121,6 +121,8 @@ func (c *Config) AddNode(opts ...any) *Node {\n \t\t\t\t\tn.err = fmt.Errorf(\"unknown NodeOption %q\", o)\n \t\t\t\t}\n \t\t\t}\n+\t\tcase MAC:\n+\t\t\tn.mac = o\n \t\tdefault:\n \t\t\tif n.err == nil {\n \t\t\t\tn.err = fmt.Errorf(\"unknown AddNode option type %T\", o)\n---\ntstest/natlab/vnet/vnet.go\n@@ -88,6 +88,9 @@ func (s *Server) PopulateDERPMapIPs() error {\n \t\t\tif n.IPv4 != \"\" {\n \t\t\t\ts.derpIPs.Add(netip.MustParseAddr(n.IPv4))\n \t\t\t}\n+\t\t\tif n.IPv6 != \"\" {\n+\t\t\t\ts.derpIPs.Add(netip.MustParseAddr(n.IPv6))\n+\t\t\t}\n \t\t}\n \t}\n \treturn nil\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/drive.go\n@@ -4,6 +4,7 @@\n package ipnlocal\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"slices\"\n@@ -338,7 +339,7 @@ func (b *LocalBackend) driveRemotesFromPeers(nm *netmap.NetworkMap) []*drive.Rem\n \t\t\t\t// Check that the peer is allowed to share with us.\n \t\t\t\taddresses := peer.Addresses()\n \t\t\t\tfor _, p := range addresses.All() {\n-\t\t\t\t\tif cn.PeerHasCap(p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n+\t\t\t\t\tif cn.PeerHasCap(context.Background(), p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n---\nipn/ipnlocal/local.go\n@@ -96,6 +96,7 @@ import (\n \t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/util/clientmetric\"\n+\t\"tailscale.com/util/ctxkey\"\n \t\"tailscale.com/util/deephash\"\n \t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/goroutines\"\n@@ -1463,15 +1464,19 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+var nodeCtxLockedKey = ctxkey.New(\"localNodeContext-locked\", false)\n+\n+var ctxNodeContextLocked = nodeCtxLockedKey.WithValue(context.Background(), true)\n+\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(context.Context, tailcfg.NodeView) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tif pred(ctxNodeContextLocked, peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n@@ -6652,9 +6657,11 @@ func (b *LocalBackend) TestOnlyPublicKeys() (machineKey key.MachinePublic, nodeK\n \n // PeerHasCap reports whether the peer with the given Tailscale IP addresses\n // contains the given capability string, with any value(s).\n-func (b *localNodeContext) PeerHasCap(addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n-\tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n+func (b *localNodeContext) PeerHasCap(ctx context.Context, addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n+\tif !nodeCtxLockedKey.Value(ctx) {\n+\t\tb.mu.Lock()\n+\t\tdefer b.mu.Unlock()\n+\t}\n \treturn b.peerHasCapLocked(addr, wantCap)\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n+\tpeers := cn.AppendMatchingPeers(nil, func(ctx context.Context, p tailcfg.NodeView) bool {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n \t\tif self != p.User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(ctx, p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n@@ -241,7 +241,7 @@ func (b *LocalBackend) taildropTargetStatus(p tailcfg.NodeView) ipnstate.Taildro\n \t}\n \tif nm.User() != p.User() {\n \t\t// Different user must have the explicit file sharing target capability\n-\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(context.Background(), p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn ipnstate.TaildropTargetOwnedByOtherUser\n \t\t}\n---\n\n\n---\n\nChoice D:\ntsnet/tsnet.go\n@@ -1101,13 +1101,33 @@ type FunnelOption interface {\n \tfunnelOption()\n }\n \n-type funnelOnly int\n+type funnelOnly struct{}\n \n func (funnelOnly) funnelOption() {}\n \n // FunnelOnly configures the listener to only respond to connections from Tailscale Funnel.\n // The local tailnet will not be able to connect to the listener.\n-func FunnelOnly() FunnelOption { return funnelOnly(1) }\n+func FunnelOnly() FunnelOption { return funnelOnly{} }\n+\n+type funnelTLSConfig struct{ conf *tls.Config }\n+\n+func (f funnelTLSConfig) funnelOption() {}\n+\n+// FunnelTLSConfig configures the TLS configuration for [Server.ListenFunnel]\n+//\n+// This is rarely needed but can permit requiring client certificates, specific\n+// ciphers suites, etc.\n+//\n+// The provided conf should at least be able to get a certificate, setting\n+// GetCertificate, Certificates or GetConfigForClient appropriately.\n+// The most common configuration is to set GetCertificate to\n+// Server.LocalClient's GetCertificate method.\n+//\n+// Unless [FunnelOnly] is also used, the configuration is also used for\n+// in-tailnet connections that don't arrive over Funnel.\n+func FunnelTLSConfig(conf *tls.Config) FunnelOption {\n+\treturn funnelTLSConfig{conf: conf}\n+}\n \n // ListenFunnel announces on the public internet using Tailscale Funnel.\n //\n@@ -1140,6 +1160,26 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t\treturn nil, err\n \t}\n \n+\t// Process, validate opts.\n+\tlnOn := listenOnBoth\n+\tvar tlsConfig *tls.Config\n+\tfor _, opt := range opts {\n+\t\tswitch v := opt.(type) {\n+\t\tcase funnelTLSConfig:\n+\t\t\tif v.conf == nil {\n+\t\t\t\treturn nil, errors.New(\"invalid nil FunnelTLSConfig\")\n+\t\t\t}\n+\t\t\ttlsConfig = v.conf\n+\t\tcase funnelOnly:\n+\t\t\tlnOn = listenOnFunnel\n+\t\tdefault:\n+\t\t\treturn nil, fmt.Errorf(\"unknown opts FunnelOption type %T\", v)\n+\t\t}\n+\t}\n+\tif tlsConfig == nil {\n+\t\ttlsConfig = &tls.Config{GetCertificate: s.getCert}\n+\t}\n+\n \tctx := context.Background()\n \tst, err := s.Up(ctx)\n \tif err != nil {\n@@ -1177,19 +1217,11 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t}\n \n \t// Start a funnel listener.\n-\tlnOn := listenOnBoth\n-\tfor _, opt := range opts {\n-\t\tif _, ok := opt.(funnelOnly); ok {\n-\t\t\tlnOn = listenOnFunnel\n-\t\t}\n-\t}\n \tln, err := s.listen(network, addr, lnOn)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn tls.NewListener(ln, &tls.Config{\n-\t\tGetCertificate: s.getCert,\n-\t}), nil\n+\treturn tls.NewListener(ln, tlsConfig), nil\n }\n \n type listenOn string\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates tailscale/tailscale#14393\n\n---\n\nChoice A:\ncontrol/controlhttp/client.go\n@@ -96,6 +96,9 @@ func (a *Dialer) httpsFallbackDelay() time.Duration {\n var _ = envknob.RegisterBool(\"TS_USE_CONTROL_DIAL_PLAN\") // to record at init time whether it's in use\n \n func (a *Dialer) dial(ctx context.Context) (*ClientConn, error) {\n+\n+\ta.logPort80Failure.Store(true)\n+\n \t// If we don't have a dial plan, just fall back to dialing the single\n \t// host we know about.\n \tuseDialPlan := envknob.BoolDefaultTrue(\"TS_USE_CONTROL_DIAL_PLAN\")\n@@ -278,7 +281,9 @@ func (d *Dialer) forceNoise443() bool {\n \t\t// This heuristic works around networks where port 80 is MITMed and\n \t\t// appears to work for a bit post-Upgrade but then gets closed,\n \t\t// such as seen in https://github.com/tailscale/tailscale/issues/13597.\n-\t\td.logf(\"controlhttp: forcing port 443 dial due to recent noise dial\")\n+\t\tif d.logPort80Failure.CompareAndSwap(true, false) {\n+\t\t\td.logf(\"controlhttp: forcing port 443 dial due to recent noise dial\")\n+\t\t}\n \t\treturn true\n \t}\n \n---\ncontrol/controlhttp/constants.go\n@@ -6,6 +6,7 @@ package controlhttp\n import (\n \t\"net/http\"\n \t\"net/url\"\n+\t\"sync/atomic\"\n \t\"time\"\n \n \t\"tailscale.com/health\"\n@@ -90,6 +91,11 @@ type Dialer struct {\n \n \tproxyFunc func(*http.Request) (*url.URL, error) // or nil\n \n+\t// logPort80Failure is whether we should log about port 80 interceptions\n+\t// and forcing a port 443 dial. We do this only once per \"dial\" method\n+\t// which can result in many concurrent racing dialHost calls.\n+\tlogPort80Failure atomic.Bool\n+\n \t// For tests only\n \tdrainFinished        chan struct{}\n \tomitCertErrorLogging bool\n---\n\n\n---\n\nChoice B:\nnet/udprelay/server.go\n@@ -454,9 +454,10 @@ func (s *Server) packetReadLoop() {\n \n var ErrServerClosed = errors.New(\"server closed\")\n \n-// AllocateEndpoint allocates a ServerEndpoint for the provided pair of\n-// key.DiscoPublic's. It returns an error (ErrServerClosed) if the server has\n-// been closed.\n+// AllocateEndpoint allocates a [ServerEndpoint] for the provided pair of\n+// [key.DiscoPublic]'s. If an allocation already exists for discoA and discoB it\n+// is returned without modification/reallocation. AllocateEndpoint returns\n+// [ErrServerClosed] if the server has been closed.\n func (s *Server) AllocateEndpoint(discoA, discoB key.DiscoPublic) (ServerEndpoint, error) {\n \ts.mu.Lock()\n \tdefer s.mu.Unlock()\n@@ -471,36 +472,19 @@ func (s *Server) AllocateEndpoint(discoA, discoB key.DiscoPublic) (ServerEndpoin\n \tpair := newPairOfDiscoPubKeys(discoA, discoB)\n \te, ok := s.byDisco[pair]\n \tif ok {\n-\t\tif !e.isBound() {\n-\t\t\t// If the endpoint is not yet bound this is likely an allocation\n-\t\t\t// race between two clients on the same Server. Instead of\n-\t\t\t// re-allocating we return the existing allocation. We do not reset\n-\t\t\t// e.allocatedAt in case a client is \"stuck\" in an allocation\n-\t\t\t// loop and will not be able to complete a handshake, for whatever\n-\t\t\t// reason. Once the endpoint expires a new endpoint will be\n-\t\t\t// allocated. Clients can resolve duplicate ServerEndpoint details\n-\t\t\t// via ServerEndpoint.LamportID.\n-\t\t\t//\n-\t\t\t// TODO: consider ServerEndpoint.BindLifetime -= time.Now()-e.allocatedAt\n-\t\t\t// to give the client a more accurate picture of the bind window.\n-\t\t\t// Or, some threshold to trigger re-allocation if too much time has\n-\t\t\t// already passed since it was originally allocated.\n-\t\t\treturn ServerEndpoint{\n-\t\t\t\tServerDisco:         s.discoPublic,\n-\t\t\t\tAddrPorts:           s.addrPorts,\n-\t\t\t\tVNI:                 e.vni,\n-\t\t\t\tLamportID:           e.lamportID,\n-\t\t\t\tBindLifetime:        tstime.GoDuration{Duration: s.bindLifetime},\n-\t\t\t\tSteadyStateLifetime: tstime.GoDuration{Duration: s.steadyStateLifetime},\n-\t\t\t}, nil\n-\t\t}\n-\t\t// If an endpoint exists for the pair of key.DiscoPublic's, and is\n-\t\t// already bound, delete it. We will re-allocate a new endpoint. Chances\n-\t\t// are clients cannot make use of the existing, bound allocation if\n-\t\t// they are requesting a new one.\n-\t\tdelete(s.byDisco, pair)\n-\t\tdelete(s.byVNI, e.vni)\n-\t\ts.vniPool = append(s.vniPool, e.vni)\n+\t\t// Return the existing allocation. Clients can resolve duplicate\n+\t\t// [ServerEndpoint]'s via [ServerEndpoint.LamportID].\n+\t\t//\n+\t\t// TODO: consider ServerEndpoint.BindLifetime -= time.Now()-e.allocatedAt\n+\t\t// to give the client a more accurate picture of the bind window.\n+\t\treturn ServerEndpoint{\n+\t\t\tServerDisco:         s.discoPublic,\n+\t\t\tAddrPorts:           s.addrPorts,\n+\t\t\tVNI:                 e.vni,\n+\t\t\tLamportID:           e.lamportID,\n+\t\t\tBindLifetime:        tstime.GoDuration{Duration: s.bindLifetime},\n+\t\t\tSteadyStateLifetime: tstime.GoDuration{Duration: s.steadyStateLifetime},\n+\t\t}, nil\n \t}\n \n \tif len(s.vniPool) == 0 {\n---\nnet/udprelay/server_test.go\n@@ -174,8 +174,7 @@ func TestServer(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \n-\t// We expect the same endpoint details as the 3-way bind handshake has not\n-\t// yet been completed for both relay client parties.\n+\t// We expect the same endpoint details pre-handshake.\n \tif diff := cmp.Diff(dupEndpoint, endpoint, cmpopts.EquateComparable(netip.AddrPort{}, key.DiscoPublic{})); diff != \"\" {\n \t\tt.Fatalf(\"wrong dupEndpoint (-got +want)\\n%s\", diff)\n \t}\n@@ -191,6 +190,15 @@ func TestServer(t *testing.T) {\n \ttcA.handshake(t)\n \ttcB.handshake(t)\n \n+\tdupEndpoint, err = server.AllocateEndpoint(discoA.Public(), discoB.Public())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// We expect the same endpoint details post-handshake.\n+\tif diff := cmp.Diff(dupEndpoint, endpoint, cmpopts.EquateComparable(netip.AddrPort{}, key.DiscoPublic{})); diff != \"\" {\n+\t\tt.Fatalf(\"wrong dupEndpoint (-got +want)\\n%s\", diff)\n+\t}\n+\n \ttxToB := []byte{1, 2, 3}\n \ttcA.writeDataPkt(t, txToB)\n \trxFromA := tcB.readDataPkt(t)\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local.go\n@@ -4837,9 +4837,34 @@ func (b *LocalBackend) doSetHostinfoFilterServices() {\n \tc := len(hi.Services)\n \thi.Services = append(hi.Services[:c:c], peerAPIServices...)\n \thi.PushDeviceToken = b.pushDeviceToken.Load()\n+\n+\t// Compare the expected ports from peerAPIServices to the actual ports in hi.Services.\n+\texpectedPorts := extractPeerAPIPorts(peerAPIServices)\n+\tactualPorts := extractPeerAPIPorts(hi.Services)\n+\tif expectedPorts != actualPorts {\n+\t\tb.logf(\"Hostinfo peerAPI ports changed: expected %v, got %v\", expectedPorts, actualPorts)\n+\t}\n+\n \tcc.SetHostinfo(&hi)\n }\n \n+type portPair struct {\n+\tv4, v6 uint16\n+}\n+\n+func extractPeerAPIPorts(services []tailcfg.Service) portPair {\n+\tvar p portPair\n+\tfor _, s := range services {\n+\t\tswitch s.Proto {\n+\t\tcase \"peerapi4\":\n+\t\t\tp.v4 = s.Port\n+\t\tcase \"peerapi6\":\n+\t\t\tp.v6 = s.Port\n+\t\t}\n+\t}\n+\treturn p\n+}\n+\n // NetMap returns the latest cached network map received from\n // controlclient, or nil if no network map was received yet.\n func (b *LocalBackend) NetMap() *netmap.NetworkMap {\n---\n\n\n---\n\nChoice D:\ncmd/natc/ippool/consensusippool.go\n@@ -10,6 +10,8 @@ import (\n \t\"fmt\"\n \t\"log\"\n \t\"net/netip\"\n+\t\"os\"\n+\t\"path/filepath\"\n \t\"time\"\n \n \t\"github.com/hashicorp/raft\"\n@@ -150,9 +152,14 @@ func (ipp *ConsensusIPPool) domainLookup(from tailcfg.NodeID, addr netip.Addr) (\n }\n \n // StartConsensus is part of the IPPool interface. It starts the raft background routines that handle consensus.\n-func (ipp *ConsensusIPPool) StartConsensus(ctx context.Context, ts *tsnet.Server, clusterTag string) error {\n+func (ipp *ConsensusIPPool) StartConsensus(ctx context.Context, ts *tsnet.Server, clusterTag string, clusterStateDir string) error {\n \tcfg := tsconsensus.DefaultConfig()\n \tcfg.ServeDebugMonitor = true\n+\tvar err error\n+\tcfg.StateDirPath, err = getStatePath(clusterStateDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tcns, err := tsconsensus.Start(ctx, ts, ipp, clusterTag, cfg)\n \tif err != nil {\n \t\treturn err\n@@ -204,6 +211,30 @@ func (ps *consensusPerPeerState) unusedIPV4(ipset *netipx.IPSet, reuseDeadline t\n \treturn netip.Addr{}, false, \"\", errors.New(\"ip pool exhausted\")\n }\n \n+func getStatePath(pathFromFlag string) (string, error) {\n+\tvar dirPath string\n+\tif pathFromFlag != \"\" {\n+\t\tdirPath = pathFromFlag\n+\t} else {\n+\t\tconfDir, err := os.UserConfigDir()\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tdirPath = filepath.Join(confDir, \"nat-connector-cluster-state\")\n+\t}\n+\n+\tif err := os.MkdirAll(dirPath, 0700); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif fi, err := os.Stat(dirPath); err != nil {\n+\t\treturn \"\", err\n+\t} else if !fi.IsDir() {\n+\t\treturn \"\", fmt.Errorf(\"%v is not a directory\", dirPath)\n+\t}\n+\n+\treturn dirPath, nil\n+}\n+\n // isCloseToExpiry returns true if the lastUsed and now times are more than\n // half the lifetime apart\n func isCloseToExpiry(lastUsed, now time.Time, lifetime time.Duration) bool {\n---\ncmd/natc/natc.go\n@@ -59,6 +59,7 @@ func main() {\n \t\twgPort          = fs.Uint(\"wg-port\", 0, \"udp port for wireguard and peer to peer traffic\")\n \t\tclusterTag      = fs.String(\"cluster-tag\", \"\", \"optionally run in a consensus cluster with other nodes with this tag\")\n \t\tserver          = fs.String(\"login-server\", ipn.DefaultControlURL, \"the base URL of control server\")\n+\t\tclusterStateDir = fs.String(\"cluster-state-dir\", \"\", \"path to directory in which to store raft state\")\n \t)\n \tff.Parse(fs, os.Args[1:], ff.WithEnvVarPrefix(\"TS_NATC\"))\n \n@@ -155,7 +156,7 @@ func main() {\n \tvar ipp ippool.IPPool\n \tif *clusterTag != \"\" {\n \t\tcipp := ippool.NewConsensusIPPool(addrPool)\n-\t\terr = cipp.StartConsensus(ctx, ts, *clusterTag)\n+\t\terr = cipp.StartConsensus(ctx, ts, *clusterTag, *clusterStateDir)\n \t\tif err != nil {\n \t\t\tlog.Fatalf(\"StartConsensus: %v\", err)\n \t\t}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAs shown in [derper.go#L367](https://github.com/tailscale/tailscale/blob/main/cmd/derper/derper.go#L367), at least two certificates are present.\n\n---\n\nChoice A:\n.github/workflows/test.yml\n@@ -39,7 +39,7 @@ concurrency:\n \n jobs:\n   race-root-integration:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     strategy:\n       fail-fast: false # don't abort the entire matrix if one element fails\n       matrix:\n@@ -74,7 +74,7 @@ jobs:\n             buildflags: \"-race\"\n             shard: '3/3'\n           - goarch: \"386\" # thanks yaml\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -187,7 +187,7 @@ jobs:\n         find $(go env GOMODCACHE)/cache -type f -mmin +90 -delete\n \n   privileged:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     container:\n       image: golang:latest\n       options: --privileged\n@@ -214,7 +214,7 @@ jobs:\n         XDG_CACHE_HOME: \"/var/lib/ghrunner/cache\"\n \n   race-build:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -258,7 +258,7 @@ jobs:\n           - goos: openbsd\n             goarch: amd64\n \n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -300,7 +300,7 @@ jobs:\n \n   ios: # similar to cross above, but iOS can't build most of the repo. So, just\n        #make it build a few smoke packages.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -328,7 +328,7 @@ jobs:\n           - goos: illumos\n             goarch: amd64\n \n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -366,7 +366,7 @@ jobs:\n     # similar to cross above, but android fails to build a few pieces of the\n     # repo. We should fix those pieces, they're small, but as a stepping stone,\n     # only test the subset of android that our past smoke test checked.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -381,7 +381,7 @@ jobs:\n         GOARCH: arm64\n \n   wasm: # builds tsconnect, which is the only wasm build we support\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -420,7 +420,7 @@ jobs:\n         find $(go env GOMODCACHE)/cache -type f -mmin +90 -delete\n \n   tailscale_go: # Subset of tests that depend on our custom Go toolchain.\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -440,7 +440,7 @@ jobs:\n     # explicit 'if' condition, because the default condition for steps is\n     # 'success()', meaning \"only run this if no previous steps failed\".\n     if: github.event_name == 'pull_request'\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: build fuzzers\n       id: build\n@@ -492,7 +492,7 @@ jobs:\n         path: ${{ env.artifacts_path }}/out/artifacts\n \n   depaware:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -501,7 +501,7 @@ jobs:\n         make depaware\n \n   go_generate:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -514,7 +514,7 @@ jobs:\n         git diff --name-only --exit-code || (echo \"The files above need updating. Please run 'go generate'.\"; exit 1)\n \n   go_mod_tidy:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n@@ -526,15 +526,15 @@ jobs:\n         git diff --name-only --exit-code || (echo \"Please run 'go mod tidy'.\"; exit 1)\n \n   licenses:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: checkout\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n     - name: check licenses\n       run: ./scripts/check_license_headers.sh .\n \n   staticcheck:\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     strategy:\n       fail-fast: false # don't abort the entire matrix if one element fails\n       matrix:\n@@ -575,7 +575,7 @@ jobs:\n       - go_mod_tidy\n       - licenses\n       - staticcheck\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     steps:\n     - name: notify  \n       # Only notify slack for merged commits, not PR failures.\n@@ -604,7 +604,7 @@ jobs:\n \n   check_mergeability:\n     if: always()\n-    runs-on: ubuntu-22.04\n+    runs-on: ubuntu-24.04\n     needs:\n       - android\n       - test\n---\n\n\n---\n\nChoice B:\nhealth/health.go\n@@ -1054,13 +1054,18 @@ func (t *Tracker) stringsLocked() []string {\n \n \twarnLen := len(result)\n \tfor _, c := range t.controlMessages {\n+\t\tvar msg string\n \t\tif c.Title != \"\" && c.Text != \"\" {\n-\t\t\tresult = append(result, c.Title+\": \"+c.Text)\n+\t\t\tmsg = c.Title + \": \" + c.Text\n \t\t} else if c.Title != \"\" {\n-\t\t\tresult = append(result, c.Title)\n+\t\t\tmsg = c.Title + \".\"\n \t\t} else if c.Text != \"\" {\n-\t\t\tresult = append(result, c.Text)\n+\t\t\tmsg = c.Text\n \t\t}\n+\t\tif c.PrimaryAction != nil {\n+\t\t\tmsg = msg + \" \" + c.PrimaryAction.Label + \": \" + c.PrimaryAction.URL\n+\t\t}\n+\t\tresult = append(result, msg)\n \t}\n \tsort.Strings(result[warnLen:])\n \n---\nhealth/health_test.go\n@@ -467,29 +467,48 @@ func TestControlHealth(t *testing.T) {\n \tbaseWarns := ht.CurrentState().Warnings\n \tbaseStrs := ht.Strings()\n \n-\tht.SetControlHealth(map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n+\tmsgs := map[tailcfg.DisplayMessageID]tailcfg.DisplayMessage{\n \t\t\"control-health-test\": {\n \t\t\tTitle: \"Control health message\",\n-\t\t\tText:  \"Extra help\",\n+\t\t\tText:  \"Extra help.\",\n \t\t},\n \t\t\"control-health-title\": {\n \t\t\tTitle: \"Control health title only\",\n \t\t},\n-\t})\n+\t\t\"control-health-with-action\": {\n+\t\t\tTitle: \"Control health message\",\n+\t\t\tText:  \"Extra help.\",\n+\t\t\tPrimaryAction: &tailcfg.DisplayMessageAction{\n+\t\t\t\tURL:   \"http://www.example.com\",\n+\t\t\t\tLabel: \"Learn more\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\tht.SetControlHealth(msgs)\n \n \tt.Run(\"Warnings\", func(t *testing.T) {\n \t\twantWarns := map[WarnableCode]UnhealthyState{\n \t\t\t\"control-health-test\": {\n \t\t\t\tWarnableCode: \"control-health-test\",\n \t\t\t\tSeverity:     SeverityMedium,\n \t\t\t\tTitle:        \"Control health message\",\n-\t\t\t\tText:         \"Extra help\",\n+\t\t\t\tText:         \"Extra help.\",\n \t\t\t},\n \t\t\t\"control-health-title\": {\n \t\t\t\tWarnableCode: \"control-health-title\",\n \t\t\t\tSeverity:     SeverityMedium,\n \t\t\t\tTitle:        \"Control health title only\",\n \t\t\t},\n+\t\t\t\"control-health-with-action\": {\n+\t\t\t\tWarnableCode: \"control-health-with-action\",\n+\t\t\t\tSeverity:     SeverityMedium,\n+\t\t\t\tTitle:        \"Control health message\",\n+\t\t\t\tText:         \"Extra help.\",\n+\t\t\t\tPrimaryAction: &UnhealthyStateAction{\n+\t\t\t\t\tURL:   \"http://www.example.com\",\n+\t\t\t\t\tLabel: \"Learn more\",\n+\t\t\t\t},\n+\t\t\t},\n \t\t}\n \t\tstate := ht.CurrentState()\n \t\tgotWarns := maps.Clone(state.Warnings)\n@@ -505,8 +524,9 @@ func TestControlHealth(t *testing.T) {\n \n \tt.Run(\"Strings()\", func(t *testing.T) {\n \t\twantStrs := []string{\n-\t\t\t\"Control health message: Extra help\",\n-\t\t\t\"Control health title only\",\n+\t\t\t\"Control health message: Extra help.\",\n+\t\t\t\"Control health message: Extra help. Learn more: http://www.example.com\",\n+\t\t\t\"Control health title only.\",\n \t\t}\n \t\tvar gotStrs []string\n \t\tfor _, s := range ht.Strings() {\n@@ -527,8 +547,7 @@ func TestControlHealth(t *testing.T) {\n \t\t\tType: MetricLabelWarning,\n \t\t}).String()\n \t\twant := strconv.Itoa(\n-\t\t\t2 + // from SetControlHealth\n-\t\t\t\tlen(baseStrs),\n+\t\t\tlen(msgs) + len(baseStrs),\n \t\t)\n \t\tif got != want {\n \t\t\tt.Errorf(\"metricsHealthMessage.Get(warning) = %q, want %q\", got, want)\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/drive.go\n@@ -4,6 +4,7 @@\n package ipnlocal\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"os\"\n \t\"slices\"\n@@ -338,7 +339,7 @@ func (b *LocalBackend) driveRemotesFromPeers(nm *netmap.NetworkMap) []*drive.Rem\n \t\t\t\t// Check that the peer is allowed to share with us.\n \t\t\t\taddresses := peer.Addresses()\n \t\t\t\tfor _, p := range addresses.All() {\n-\t\t\t\t\tif cn.PeerHasCap(p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n+\t\t\t\t\tif cn.PeerHasCap(context.Background(), p.Addr(), tailcfg.PeerCapabilityTaildriveSharer) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n---\nipn/ipnlocal/local.go\n@@ -96,6 +96,7 @@ import (\n \t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/util/clientmetric\"\n+\t\"tailscale.com/util/ctxkey\"\n \t\"tailscale.com/util/deephash\"\n \t\"tailscale.com/util/dnsname\"\n \t\"tailscale.com/util/goroutines\"\n@@ -1463,15 +1464,19 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n-func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+var nodeCtxLockedKey = ctxkey.New(\"localNodeContext-locked\", false)\n+\n+var ctxNodeContextLocked = nodeCtxLockedKey.WithValue(context.Background(), true)\n+\n+func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(context.Context, tailcfg.NodeView) bool) []tailcfg.NodeView {\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tret := base\n \tif b.netMap == nil {\n \t\treturn ret\n \t}\n \tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\t\tif pred(ctxNodeContextLocked, peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n@@ -6652,9 +6657,11 @@ func (b *LocalBackend) TestOnlyPublicKeys() (machineKey key.MachinePublic, nodeK\n \n // PeerHasCap reports whether the peer with the given Tailscale IP addresses\n // contains the given capability string, with any value(s).\n-func (b *localNodeContext) PeerHasCap(addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n-\tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n+func (b *localNodeContext) PeerHasCap(ctx context.Context, addr netip.Addr, wantCap tailcfg.PeerCapability) bool {\n+\tif !nodeCtxLockedKey.Value(ctx) {\n+\t\tb.mu.Lock()\n+\t\tdefer b.mu.Unlock()\n+\t}\n \treturn b.peerHasCapLocked(addr, wantCap)\n }\n \n---\nipn/ipnlocal/taildrop.go\n@@ -190,14 +190,14 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \tif !b.capFileSharing {\n \t\treturn nil, errors.New(\"file sharing not enabled by Tailscale admin\")\n \t}\n-\tpeers := cn.AppendMatchingPeers(nil, func(p tailcfg.NodeView) bool {\n+\tpeers := cn.AppendMatchingPeers(nil, func(ctx context.Context, p tailcfg.NodeView) bool {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n \t\tif self != p.User() {\n \t\t\treturn false\n \t\t}\n-\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(ctx, p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn true\n \t\t}\n@@ -241,7 +241,7 @@ func (b *LocalBackend) taildropTargetStatus(p tailcfg.NodeView) ipnstate.Taildro\n \t}\n \tif nm.User() != p.User() {\n \t\t// Different user must have the explicit file sharing target capability\n-\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n+\t\tif p.Addresses().Len() == 0 || !cn.PeerHasCap(context.Background(), p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n \t\t\treturn ipnstate.TaildropTargetOwnedByOtherUser\n \t\t}\n---\n\n\n---\n\nChoice D:\ncmd/derper/cert_test.go\n@@ -140,6 +140,15 @@ func TestPinnedCertRawIP(t *testing.T) {\n \tvar hs http.Server\n \ths.Handler = mux\n \ths.TLSConfig = cp.TLSConfig()\n+\tgetCert := hs.TLSConfig.GetCertificate\n+\ths.TLSConfig.GetCertificate=func(hi *tls.ClientHelloInfo) (*tls.Certificate, error) {\n+\t\tcert, err := getCert(hi)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tcert.Certificate = append(cert.Certificate, ds.MetaCert())\n+\t\treturn cert, nil\n+\t}\n \tgo hs.ServeTLS(ln, \"\", \"\")\n \n \tlnPort := ln.Addr().(*net.TCPAddr).Port\n---\nnet/tlsdial/tlsdial.go\n@@ -263,7 +263,7 @@ func SetConfigExpectedCertHash(c *tls.Config, wantFullCertSHA256Hex string) {\n \t\tif len(rawCerts) == 0 {\n \t\t\treturn errors.New(\"no certs presented\")\n \t\t}\n-\t\tif len(rawCerts) > 1 {\n+\t\tif len(rawCerts) > 2 {\n \t\t\treturn errors.New(\"unexpected multiple certs presented\")\n \t\t}\n \t\tif fmt.Sprintf(\"%02x\", sha256.Sum256(rawCerts[0])) != wantFullCertSHA256Hex {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nNot all platforms have hardlinks, or not easily.\n\nThis lets a \"tailscale\" wrapper script set an environment variable\nbefore calling tailscaled.\n\nUpdates #2233\n\n\n---\n\nChoice A:\ncmd/tailscale/cli/cli.go\n@@ -164,7 +164,7 @@ func Run(args []string) (err error) {\n \n \terr = rootCmd.Run(context.Background())\n \tif tailscale.IsAccessDeniedError(err) && os.Getuid() != 0 && runtime.GOOS != \"windows\" {\n-\t\treturn fmt.Errorf(\"%v\\n\\nUse 'sudo tailscale %s' or 'tailscale up --operator=$USER' to not require root.\", err, strings.Join(args, \" \"))\n+\t\treturn fmt.Errorf(\"%v\\n\\nUse 'sudo tailscale %s'.\\nTo not require root, use 'sudo tailscale set --operator=$USER' once.\", err, strings.Join(args, \" \"))\n \t}\n \tif errors.Is(err, flag.ErrHelp) {\n \t\treturn nil\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/extension_host_test.go\n@@ -284,7 +284,7 @@ func TestNewExtensionHost(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tt.Parallel()\n \t\t\tlogf := tstest.WhileTestRunningLogger(t)\n-\t\t\th, err := NewExtensionHost(logf, &tsd.System{}, &testBackend{}, tt.defs...)\n+\t\t\th, err := NewExtensionHost(logf, tsd.NewSystem(), &testBackend{}, tt.defs...)\n \t\t\tif gotErr := err != nil; gotErr != tt.wantErr {\n \t\t\t\tt.Errorf(\"NewExtensionHost: gotErr %v(%v); wantErr %v\", gotErr, err, tt.wantErr)\n \t\t\t}\n@@ -1118,7 +1118,7 @@ func newExtensionHostForTest[T ipnext.Extension](t *testing.T, b Backend, initia\n \t\t}\n \t\tdefs[i] = ipnext.DefinitionForTest(ext)\n \t}\n-\th, err := NewExtensionHost(logf, &tsd.System{}, b, defs...)\n+\th, err := NewExtensionHost(logf, tsd.NewSystem(), b, defs...)\n \tif err != nil {\n \t\tt.Fatalf(\"NewExtensionHost: %v\", err)\n \t}\n---\nipn/ipnlocal/state_test.go\n@@ -1397,7 +1397,7 @@ func newLocalBackendWithMockEngineAndControl(t *testing.T, enableLogging bool) (\n \tdialer := &tsdial.Dialer{Logf: logf}\n \tdialer.SetNetMon(netmon.NewStatic())\n \n-\tsys := &tsd.System{}\n+\tsys := tsd.NewSystem()\n \tsys.Set(dialer)\n \tsys.Set(dialer.NetMon())\n \n---\n\n\n---\n\nChoice C:\ncmd/tailscaled/tailscaled.go\n@@ -151,10 +151,33 @@ var subCommands = map[string]*func([]string) error{\n \t\"serve-taildrive\":         &serveDriveFunc,\n }\n \n-var beCLI func() // non-nil if CLI is linked in\n+var beCLI func() // non-nil if CLI is linked in with the \"ts_include_cli\" build tag\n+\n+// shouldRunCLI reports whether we should run the Tailscale CLI (cmd/tailscale)\n+// instead of the daemon (cmd/tailscaled) in the case when the two are linked\n+// together into one binary for space savings reasons.\n+func shouldRunCLI() bool {\n+\tif beCLI == nil {\n+\t\t// Not linked in with the \"ts_include_cli\" build tag.\n+\t\treturn false\n+\t}\n+\tif len(os.Args) > 0 && filepath.Base(os.Args[0]) == \"tailscale\" {\n+\t\t// The binary was named (or hardlinked) as \"tailscale\".\n+\t\treturn true\n+\t}\n+\tif envknob.Bool(\"TS_BE_CLI\") {\n+\t\t// The environment variable was set to force it.\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n \n func main() {\n \tenvknob.PanicIfAnyEnvCheckedInInit()\n+\tif shouldRunCLI() {\n+\t\tbeCLI()\n+\t\treturn\n+\t}\n \tenvknob.ApplyDiskConfig()\n \tapplyIntegrationTestEnvKnob()\n \n@@ -175,11 +198,6 @@ func main() {\n \tflag.BoolVar(&args.disableLogs, \"no-logs-no-support\", false, \"disable log uploads; this also disables any technical support\")\n \tflag.StringVar(&args.confFile, \"config\", \"\", \"path to config file, or 'vm:user-data' to use the VM's user-data (EC2)\")\n \n-\tif len(os.Args) > 0 && filepath.Base(os.Args[0]) == \"tailscale\" && beCLI != nil {\n-\t\tbeCLI()\n-\t\treturn\n-\t}\n-\n \tif len(os.Args) > 1 {\n \t\tsub := os.Args[1]\n \t\tif fp, ok := subCommands[sub]; ok {\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -958,7 +958,9 @@ func (b *LocalBackend) linkChange(delta *netmon.ChangeDelta) {\n \n \tif peerAPIListenAsync && b.netMap != nil && b.state == ipn.Running {\n \t\twant := b.netMap.GetAddresses().Len()\n-\t\tif len(b.peerAPIListeners) < want {\n+\t\thave := len(b.peerAPIListeners)\n+\t\tb.logf(\"[v1] linkChange: have %d peerAPIListeners, want %d\", have, want)\n+\t\tif have < want {\n \t\t\tb.logf(\"linkChange: peerAPIListeners too low; trying again\")\n \t\t\tb.goTracker.Go(b.initPeerAPIListener)\n \t\t}\n@@ -5369,6 +5371,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n+\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes #15291\r\n\r\nNot supported on non-unix platforms since they don't support `syscall.Stat` (used to preserve existing ids when calling os.Chown)\n\n---\n\nChoice A:\ncmd/tailscale/cli/file.go\n@@ -15,8 +15,10 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"os\"\n+\t\"os/user\"\n \t\"path\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"sync/atomic\"\n \t\"time\"\n@@ -452,6 +454,7 @@ var fileGetCmd = &ffcli.Command{\n \toverwrite:  overwrite existing file\n \trename:     write to a new number-suffixed filename`)\n \t\tffcomplete.Flag(fs, \"conflict\", ffcomplete.Fixed(\"skip\", \"overwrite\", \"rename\"))\n+\t\tfs.StringVar(&getArgs.chown, \"chown\", \"\", \"sets owner:group for received files\")\n \t\treturn fs\n \t})(),\n }\n@@ -461,6 +464,7 @@ var getArgs = struct {\n \tloop     bool\n \tverbose  bool\n \tconflict onConflict\n+\tchown    string\n }{conflict: skipOnExist}\n \n func numberedFileName(dir, name string, i int) string {\n@@ -512,7 +516,7 @@ func openFileOrSubstitute(dir, base string, action onConflict) (*os.File, error)\n \t}\n }\n \n-func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targetFile string, size int64, err error) {\n+func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string, chown string) (targetFile string, size int64, err error) {\n \trc, size, err := localClient.GetWaitingFile(ctx, wf.Name)\n \tif err != nil {\n \t\treturn \"\", 0, fmt.Errorf(\"opening inbox file %q: %w\", wf.Name, err)\n@@ -531,10 +535,51 @@ func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targe\n \t\tf.Close()\n \t\treturn \"\", 0, fmt.Errorf(\"failed to write %v: %v\", f.Name(), err)\n \t}\n+\tif chown != \"\" {\n+\t\tusr, grp, _ := strings.Cut(chown, \":\")\n+\n+\t\t// Set default values to allow for partial changes (e.g. `user` or `:staff`)\n+\t\tuid, gid, err := fileStat(f)\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to stat file: %v\", err)\n+\t\t}\n+\n+\t\tif usr != \"\" {\n+\t\t\tif uid, err = strconv.Atoi(usr); err != nil {\n+\t\t\t\tuser, err := user.Lookup(usr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup user: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif uid, err = strconv.Atoi(user.Uid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert uid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif grp != \"\" {\n+\t\t\tif gid, err = strconv.Atoi(grp); err != nil {\n+\t\t\t\tgroup, err := user.LookupGroup(grp)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup group: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif gid, err = strconv.Atoi(group.Gid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert gid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif err := f.Chown(uid, gid); err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to chown file: %v\", err)\n+\t\t}\n+\t}\n \treturn f.Name(), size, f.Close()\n }\n \n-func runFileGetOneBatch(ctx context.Context, dir string) []error {\n+func runFileGetOneBatch(ctx context.Context, dir, chown string) []error {\n \tvar wfs []apitype.WaitingFile\n \tvar err error\n \tvar errs []error\n@@ -563,7 +608,7 @@ func runFileGetOneBatch(ctx context.Context, dir string) []error {\n \t\t\terrs = append(errs, fmt.Errorf(\"too many errors in runFileGetOneBatch(). %d files unexamined\", len(wfs)-i))\n \t\t\tbreak\n \t\t}\n-\t\twrittenFile, size, err := receiveFile(ctx, wf, dir)\n+\t\twrittenFile, size, err := receiveFile(ctx, wf, dir, chown)\n \t\tif err != nil {\n \t\t\terrs = append(errs, err)\n \t\t\tcontinue\n@@ -602,7 +647,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t}\n \tif getArgs.loop {\n \t\tfor {\n-\t\t\terrs := runFileGetOneBatch(ctx, dir)\n+\t\t\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \t\t\tfor _, err := range errs {\n \t\t\t\toutln(err)\n \t\t\t}\n@@ -621,7 +666,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t\t\t}\n \t\t}\n \t}\n-\terrs := runFileGetOneBatch(ctx, dir)\n+\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \tif len(errs) == 0 {\n \t\treturn nil\n \t}\n@@ -635,6 +680,9 @@ func wipeInbox(ctx context.Context) error {\n \tif getArgs.wait {\n \t\treturn errors.New(\"can't use --wait with /dev/null target\")\n \t}\n+\tif getArgs.chown != \"\" {\n+\t\treturn errors.New(\"can't use --chown with /dev/null target\")\n+\t}\n \twfs, err := localClient.WaitingFiles(ctx)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting WaitingFiles: %w\", err)\n---\ncmd/tailscale/cli/file_stub.go\n@@ -0,0 +1,16 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build windows || wasm || plan9 || tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(_f *os.File) (int, int, error) {\n+\treturn -1, -1, errors.New(\"Not implemented\")\n+}\n---\ncmd/tailscale/cli/file_unix.go\n@@ -0,0 +1,26 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build !windows && !wasm && !plan9 && !tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(f *os.File) (int, int, error) {\n+\tif f == nil {\n+\t\treturn -1, -1, errors.New(\"file cannot be nil\")\n+\t}\n+\n+\tvar stat syscall.Stat_t\n+\tif err := syscall.Stat(f.Name(), &stat); err != nil {\n+\t\treturn -1, -1, err\n+\t}\n+\n+\treturn int(stat.Uid), int(stat.Gid), nil\n+}\n---\n\n\n---\n\nChoice B:\nnet/portmapper/igd_test.go\n@@ -18,8 +18,10 @@ import (\n \t\"tailscale.com/net/netaddr\"\n \t\"tailscale.com/net/netmon\"\n \t\"tailscale.com/syncs\"\n+\t\"tailscale.com/tstest\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/eventbus\"\n+\t\"tailscale.com/util/testenv\"\n )\n \n // TestIGD is an IGD (Internet Gateway Device) for testing. It supports fake\n@@ -64,7 +66,8 @@ type igdCounters struct {\n \tinvalidPCPMapPkt int32\n }\n \n-func NewTestIGD(logf logger.Logf, t TestIGDOptions) (*TestIGD, error) {\n+func NewTestIGD(tb testenv.TB, t TestIGDOptions) (*TestIGD, error) {\n+\tlogf := tstest.WhileTestRunningLogger(tb)\n \td := &TestIGD{\n \t\tdoPMP:  t.PMP,\n \t\tdoPCP:  t.PCP,\n@@ -265,7 +268,7 @@ func (d *TestIGD) handlePCPQuery(pkt []byte, src netip.AddrPort) {\n func newTestClient(t *testing.T, igd *TestIGD, bus *eventbus.Bus) *Client {\n \tvar c *Client\n \tc = NewClient(Config{\n-\t\tLogf:         t.Logf,\n+\t\tLogf:         tstest.WhileTestRunningLogger(t),\n \t\tNetMon:       netmon.NewStatic(),\n \t\tControlKnobs: new(controlknobs.Knobs),\n \t\tEventBus:     bus,\n---\nnet/portmapper/portmapper_test.go\n@@ -61,7 +61,7 @@ func TestClientProbeThenMap(t *testing.T) {\n }\n \n func TestProbeIntegration(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PMP: true, PCP: true, UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PMP: true, PCP: true, UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -95,7 +95,7 @@ func TestProbeIntegration(t *testing.T) {\n }\n \n func TestPCPIntegration(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PMP: false, PCP: true, UPnP: false})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PMP: false, PCP: true, UPnP: false})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -137,7 +137,7 @@ func TestGetUPnPErrorsMetric(t *testing.T) {\n }\n \n func TestUpdateEvent(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{PCP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{PCP: true})\n \tif err != nil {\n \t\tt.Fatalf(\"Create test gateway: %v\", err)\n \t}\n---\nnet/portmapper/select_test.go\n@@ -28,7 +28,7 @@ func TestSelectBestService(t *testing.T) {\n \t}\n \n \t// Run a fake IGD server to respond to UPnP requests.\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/portmapper/upnp_test.go\n@@ -533,7 +533,7 @@ func TestGetUPnPClient(t *testing.T) {\n }\n \n func TestGetUPnPPortMapping(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -672,7 +672,7 @@ func TestGetUPnPPortMapping_LeaseDuration(t *testing.T) {\n \t\t\t\t\"DeletePortMapping\":    \"\", // Do nothing for test\n \t\t\t}\n \n-\t\t\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\t\t\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n@@ -722,7 +722,7 @@ func TestGetUPnPPortMapping_LeaseDuration(t *testing.T) {\n //\n // See https://github.com/tailscale/tailscale/issues/10911\n func TestGetUPnPPortMapping_NoValidServices(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -753,7 +753,7 @@ func TestGetUPnPPortMapping_NoValidServices(t *testing.T) {\n \n // Tests the legacy behaviour with the pre-UPnP standard portmapping service.\n func TestGetUPnPPortMapping_Legacy(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -796,7 +796,7 @@ func TestGetUPnPPortMapping_Legacy(t *testing.T) {\n }\n \n func TestGetUPnPPortMappingNoResponses(t *testing.T) {\n-\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -912,7 +912,7 @@ func TestGetUPnPPortMapping_Invalid(t *testing.T) {\n \t\t\"127.0.0.1\",\n \t} {\n \t\tt.Run(responseAddr, func(t *testing.T) {\n-\t\t\tigd, err := NewTestIGD(t.Logf, TestIGDOptions{UPnP: true})\n+\t\t\tigd, err := NewTestIGD(t, TestIGDOptions{UPnP: true})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n---\ntstest/log.go\n@@ -13,6 +13,7 @@ import (\n \n \t\"go4.org/mem\"\n \t\"tailscale.com/types/logger\"\n+\t\"tailscale.com/util/testenv\"\n )\n \n type testLogWriter struct {\n@@ -149,7 +150,7 @@ func (ml *MemLogger) String() string {\n \n // WhileTestRunningLogger returns a logger.Logf that logs to t.Logf until the\n // test finishes, at which point it no longer logs anything.\n-func WhileTestRunningLogger(t testing.TB) logger.Logf {\n+func WhileTestRunningLogger(t testenv.TB) logger.Logf {\n \tvar (\n \t\tmu   sync.RWMutex\n \t\tdone bool\n---\n\n\n---\n\nChoice C:\ncmd/proxy-to-grafana/proxy-to-grafana.go\n@@ -53,7 +53,7 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"tailscale.com/client/local\"\n+\t\"tailscale.com/client/tailscale/apitype\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/tsnet\"\n )\n@@ -195,13 +195,7 @@ func main() {\n \tlog.Fatal(http.Serve(ln, proxy))\n }\n \n-func modifyRequest(req *http.Request, localClient *local.Client) {\n-\t// with enable_login_token set to true, we get a cookie that handles\n-\t// auth for paths that are not /login\n-\tif req.URL.Path != \"/login\" {\n-\t\treturn\n-\t}\n-\n+func modifyRequest(req *http.Request, localClient whoisIdentitySource) {\n \t// Delete any existing X-Webauth-* headers to prevent possible spoofing\n \t// if getting Tailnet identity fails.\n \tfor h := range req.Header {\n@@ -210,6 +204,13 @@ func modifyRequest(req *http.Request, localClient *local.Client) {\n \t\t}\n \t}\n \n+\t// Set the X-Webauth-* headers only for the /login path\n+\t// With enable_login_token set to true, we get a cookie that handles\n+\t// auth for paths that are not /login\n+\tif req.URL.Path != \"/login\" {\n+\t\treturn\n+\t}\n+\n \tuser, role, err := getTailscaleIdentity(req.Context(), localClient, req.RemoteAddr)\n \tif err != nil {\n \t\tlog.Printf(\"error getting Tailscale user: %v\", err)\n@@ -221,7 +222,7 @@ func modifyRequest(req *http.Request, localClient *local.Client) {\n \treq.Header.Set(\"X-Webauth-Role\", role.String())\n }\n \n-func getTailscaleIdentity(ctx context.Context, localClient *local.Client, ipPort string) (*tailcfg.UserProfile, grafanaRole, error) {\n+func getTailscaleIdentity(ctx context.Context, localClient whoisIdentitySource, ipPort string) (*tailcfg.UserProfile, grafanaRole, error) {\n \twhois, err := localClient.WhoIs(ctx, ipPort)\n \tif err != nil {\n \t\treturn nil, ViewerRole, fmt.Errorf(\"failed to identify remote host: %w\", err)\n@@ -248,3 +249,7 @@ func getTailscaleIdentity(ctx context.Context, localClient *local.Client, ipPort\n \n \treturn whois.UserProfile, role, nil\n }\n+\n+type whoisIdentitySource interface {\n+\tWhoIs(ctx context.Context, ipPort string) (*apitype.WhoIsResponse, error)\n+}\n---\ncmd/proxy-to-grafana/proxy-to-grafana_test.go\n@@ -0,0 +1,77 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+package main\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+\n+\t\"tailscale.com/client/tailscale/apitype\"\n+\t\"tailscale.com/tailcfg\"\n+)\n+\n+type mockWhoisSource struct {\n+\tid *apitype.WhoIsResponse\n+}\n+\n+func (m *mockWhoisSource) WhoIs(ctx context.Context, remoteAddr string) (*apitype.WhoIsResponse, error) {\n+\tif m.id == nil {\n+\t\treturn nil, fmt.Errorf(\"missing mock identity\")\n+\t}\n+\treturn m.id, nil\n+}\n+\n+var whois = &apitype.WhoIsResponse{\n+\tUserProfile: &tailcfg.UserProfile{\n+\t\tLoginName:   \"foobar@example.com\",\n+\t\tDisplayName: \"Foobar\",\n+\t},\n+\tNode: &tailcfg.Node{\n+\t\tID: 1,\n+\t},\n+}\n+\n+func TestModifyRequest_Login(t *testing.T) {\n+\treq := httptest.NewRequest(\"GET\", \"/login\", nil)\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"foobar@example.com\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"foobar@example.com\")\n+\t}\n+\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"Viewer\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"Viewer\")\n+\t}\n+}\n+\n+func TestModifyRequest_RemoveHeaders_Login(t *testing.T) {\n+\treq := httptest.NewRequest(\"GET\", \"/login\", nil)\n+\treq.Header.Set(\"X-Webauth-User\", \"malicious@example.com\")\n+\treq.Header.Set(\"X-Webauth-Role\", \"Admin\")\n+\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"foobar@example.com\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"foobar@example.com\")\n+\t}\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"Viewer\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"Viewer\")\n+\t}\n+}\n+\n+func TestModifyRequest_RemoveHeaders_API(t *testing.T) {\n+\treq := httptest.NewRequest(\"DELETE\", \"/api/org/users/1\", nil)\n+\treq.Header.Set(\"X-Webauth-User\", \"malicious@example.com\")\n+\treq.Header.Set(\"X-Webauth-Role\", \"Admin\")\n+\n+\tmodifyRequest(req, &mockWhoisSource{id: whois})\n+\n+\tif got := req.Header.Get(\"X-Webauth-User\"); got != \"\" {\n+\t\tt.Errorf(\"X-Webauth-User = %q; want %q\", got, \"\")\n+\t}\n+\tif got := req.Header.Get(\"X-Webauth-Role\"); got != \"\" {\n+\t\tt.Errorf(\"X-Webauth-Role = %q; want %q\", got, \"\")\n+\t}\n+}\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -6146,17 +6146,17 @@ func (b *LocalBackend) setTCPPortsInterceptedFromNetmapAndPrefsLocked(prefs ipn.\n \t\t}\n \t}\n \n-\t// Update funnel info in hostinfo and kick off control update if needed.\n-\tb.updateIngressLocked()\n+\t// Update funnel and service hash info in hostinfo and kick off control update if needed.\n+\tb.updateIngressAndServiceHashLocked(prefs)\n \tb.setTCPPortsIntercepted(handlePorts)\n \tb.setVIPServicesTCPPortsInterceptedLocked(vipServicesPorts)\n }\n \n-// updateIngressLocked updates the hostinfo.WireIngress and hostinfo.IngressEnabled fields and kicks off a Hostinfo\n-// update if the values have changed.\n+// updateIngressAndServiceHashLocked updates the hostinfo.ServicesHash, hostinfo.WireIngress and\n+// hostinfo.IngressEnabled fields and kicks off a Hostinfo update if the values have changed.\n //\n // b.mu must be held.\n-func (b *LocalBackend) updateIngressLocked() {\n+func (b *LocalBackend) updateIngressAndServiceHashLocked(prefs ipn.PrefsView) {\n \tif b.hostinfo == nil {\n \t\treturn\n \t}\n@@ -6171,6 +6171,11 @@ func (b *LocalBackend) updateIngressLocked() {\n \t\tb.hostinfo.WireIngress = wire\n \t\thostInfoChanged = true\n \t}\n+\tlatestHash := b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\tif b.hostinfo.ServicesHash != latestHash {\n+\t\tb.hostinfo.ServicesHash = latestHash\n+\t\thostInfoChanged = true\n+\t}\n \t// Kick off a Hostinfo update to control if ingress status has changed.\n \tif hostInfoChanged {\n \t\tb.goTracker.Go(b.doSetHostinfoFilterServices)\n---\nipn/ipnlocal/local_test.go\n@@ -5134,10 +5134,17 @@ func TestUpdatePrefsOnSysPolicyChange(t *testing.T) {\n \t}\n }\n \n-func TestUpdateIngressLocked(t *testing.T) {\n+func TestUpdateIngressAndServiceHashLocked(t *testing.T) {\n+\tprefs := ipn.NewPrefs().View()\n+\tpreviousSC := &ipn.ServeConfig{\n+\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\"svc:abc\": {Tun: true},\n+\t\t},\n+\t}\n \ttests := []struct {\n \t\tname              string\n \t\thi                *tailcfg.Hostinfo\n+\t\thasPreviousSC     bool // whether to overwrite the ServeConfig hash in the Hostinfo using previousSC\n \t\tsc                *ipn.ServeConfig\n \t\twantIngress       bool\n \t\twantWireIngress   bool\n@@ -5163,6 +5170,16 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantWireIngress:   false, // implied by wantIngress\n \t\t\twantControlUpdate: true,\n \t\t},\n+\t\t{\n+\t\t\tname: \"empty_hostinfo_service_configured\",\n+\t\t\thi:   &tailcfg.Hostinfo{},\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t\t{\n \t\t\tname: \"empty_hostinfo_funnel_disabled\",\n \t\t\thi:   &tailcfg.Hostinfo{},\n@@ -5175,7 +5192,7 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantControlUpdate: true,\n \t\t},\n \t\t{\n-\t\t\tname: \"empty_hostinfo_no_funnel\",\n+\t\t\tname: \"empty_hostinfo_no_funnel_no_service\",\n \t\t\thi:   &tailcfg.Hostinfo{},\n \t\t\tsc: &ipn.ServeConfig{\n \t\t\t\tTCP: map[uint16]*ipn.TCPPortHandler{\n@@ -5196,6 +5213,16 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantIngress:     true,\n \t\t\twantWireIngress: false, // implied by wantIngress\n \t\t},\n+\t\t{\n+\t\t\tname:          \"service_hash_no_change\",\n+\t\t\thi:            &tailcfg.Hostinfo{},\n+\t\t\thasPreviousSC: true,\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n \t\t{\n \t\t\tname: \"funnel_disabled_no_change\",\n \t\t\thi: &tailcfg.Hostinfo{\n@@ -5208,6 +5235,13 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t},\n \t\t\twantWireIngress: true, // true if there is any AllowFunnel block\n \t\t},\n+\t\t{\n+\t\t\tname:              \"service_got_removed\",\n+\t\t\thi:                &tailcfg.Hostinfo{},\n+\t\t\thasPreviousSC:     true,\n+\t\t\tsc:                &ipn.ServeConfig{},\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t\t{\n \t\t\tname: \"funnel_changes_to_disabled\",\n \t\t\thi: &tailcfg.Hostinfo{\n@@ -5235,12 +5269,35 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantWireIngress:   false, // implied by wantIngress\n \t\t\twantControlUpdate: true,\n \t\t},\n+\t\t{\n+\t\t\tname: \"both_funnel_and_service_changes\",\n+\t\t\thi: &tailcfg.Hostinfo{\n+\t\t\t\tIngressEnabled: true,\n+\t\t\t},\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tAllowFunnel: map[ipn.HostPort]bool{\n+\t\t\t\t\t\"tailnet.xyz:443\": false,\n+\t\t\t\t},\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantWireIngress:   true, // true if there is any AllowFunnel block\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t}\n \n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tt.Parallel()\n \t\t\tb := newTestLocalBackend(t)\n \t\t\tb.hostinfo = tt.hi\n+\t\t\tif tt.hasPreviousSC {\n+\t\t\t\tb.mu.Lock()\n+\t\t\t\tb.serveConfig = previousSC.View()\n+\t\t\t\tb.hostinfo.ServicesHash = b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\t\t\t\tb.mu.Unlock()\n+\t\t\t}\n \t\t\tb.serveConfig = tt.sc.View()\n \t\t\tallDone := make(chan bool, 1)\n \t\t\tdefer b.goTracker.AddDoneCallback(func() {\n@@ -5256,7 +5313,7 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t})()\n \n \t\t\twas := b.goTracker.StartedGoroutines()\n-\t\t\tb.updateIngressLocked()\n+\t\t\tb.updateIngressAndServiceHashLocked(prefs)\n \n \t\t\tif tt.hi != nil {\n \t\t\t\tif tt.hi.IngressEnabled != tt.wantIngress {\n@@ -5265,6 +5322,12 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t\tif tt.hi.WireIngress != tt.wantWireIngress {\n \t\t\t\t\tt.Errorf(\"WireIngress = %v, want %v\", tt.hi.WireIngress, tt.wantWireIngress)\n \t\t\t\t}\n+\t\t\t\tb.mu.Lock()\n+\t\t\t\tsvcHash := b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\t\t\t\tb.mu.Unlock()\n+\t\t\t\tif tt.hi.ServicesHash != svcHash {\n+\t\t\t\t\tt.Errorf(\"ServicesHash = %v, want %v\", tt.hi.ServicesHash, svcHash)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tstartedGoroutine := b.goTracker.StartedGoroutines() != was\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nEnsure no services are advertised as part of shutting down tailscaled. Prefs are only edited if services are currently advertised, and if they're edited we wait for control's ~15s (+ buffer) delay to failover.\r\n\r\nNote that editing prefs will trigger a synchronous write to the state Secret, so it may fail to persist state if the ProxyGroup is getting scaled down and therefore has its RBAC deleted at the same time, but that failure doesn't stop prefs being updated within the local backend, doesn't  affect connectivity to control, and the state Secret is about to get deleted anyway, so the only negative side effect is a harmless error log during shutdown. Control still learns that the node is no longer advertising the service and triggers the failover.\r\n\r\nNote that the first version of this used a PreStop lifecycle hook, but that only supports GET methods and we need the shutdown to trigger side effects (updating prefs) so it didn't seem appropriate to expose that functionality on a GET endpoint that's accessible on the k8s network.\r\n\r\nUpdates tailscale/corp#24795\r\n\r\nChange-Id: I0a9a4fe7a5395ca76135ceead05cbc3ee32b3d3c\n\n---\n\nChoice A:\nfeature/relayserver/relayserver.go\n@@ -142,7 +142,7 @@ func handlePeerAPIRelayAllocateEndpoint(h ipnlocal.PeerAPIHandler, w http.Respon\n \n \thttpErrAndLog := func(message string, code int) {\n \t\thttp.Error(w, message, code)\n-\t\te.logf(\"peerapi: request from %v returned code %d: %s\", h.RemoteAddr(), code, message)\n+\t\th.Logf(\"relayserver: request from %v returned code %d: %s\", h.RemoteAddr(), code, message)\n \t}\n \n \tif !h.PeerCaps().HasCapability(tailcfg.PeerCapabilityRelay) {\n---\n\n\n---\n\nChoice B:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n+      uses: github/codeql-action/init@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n+      uses: github/codeql-action/autobuild@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@1b549b9259bda1cb5ddde3b41741a82a2d15a841 # v3.28.13\n+      uses: github/codeql-action/analyze@fc7e4a0fa01c3cca5fd6a1fddec5c0740c977aa2 # v3.28.14\n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/init@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/autobuild@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/analyze@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n---\n\n\n---\n\nChoice D:\ncmd/containerboot/healthz.go\n@@ -47,10 +47,10 @@ func (h *healthz) update(healthy bool) {\n \th.hasAddrs = healthy\n }\n \n-// healthHandlers registers a simple health handler at /healthz.\n+// registerHealthHandlers registers a simple health handler at /healthz.\n // A containerized tailscale instance is considered healthy if\n // it has at least one tailnet IP address.\n-func healthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n+func registerHealthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n \th := &healthz{podIPv4: podIPv4}\n \tmux.Handle(\"GET /healthz\", h)\n \treturn h\n---\ncmd/containerboot/main.go\n@@ -195,18 +195,21 @@ func run() error {\n \t\treturn fmt.Errorf(\"failed to bring up tailscale: %w\", err)\n \t}\n \tkillTailscaled := func() {\n+\t\t// The default termination grace period for a Pod is 30s. We wait 25s at\n+\t\t// most so that we still reserve some of that budget for tailscaled\n+\t\t// to receive and react to a SIGTERM before the SIGKILL that k8s\n+\t\t// will send at the end of the grace period.\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)\n+\t\tdefer cancel()\n+\n+\t\tif err := ensureServicesNotAdvertised(ctx, client); err != nil {\n+\t\t\tlog.Printf(\"Error ensuring services are not advertised: %v\", err)\n+\t\t}\n+\n \t\tif hasKubeStateStore(cfg) {\n \t\t\t// Check we're not shutting tailscaled down while it's still writing\n \t\t\t// state. If we authenticate and fail to write all the state, we'll\n \t\t\t// never recover automatically.\n-\t\t\t//\n-\t\t\t// The default termination grace period for a Pod is 30s. We wait 25s at\n-\t\t\t// most so that we still reserve some of that budget for tailscaled\n-\t\t\t// to receive and react to a SIGTERM before the SIGKILL that k8s\n-\t\t\t// will send at the end of the grace period.\n-\t\t\tctx, cancel := context.WithTimeout(context.Background(), 25*time.Second)\n-\t\t\tdefer cancel()\n-\n \t\t\tlog.Printf(\"Checking for consistent state\")\n \t\t\terr := kc.waitForConsistentState(ctx)\n \t\t\tif err != nil {\n@@ -226,7 +229,7 @@ func run() error {\n \t\tmux := http.NewServeMux()\n \n \t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.HealthCheckAddrPort)\n-\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \n \t\tclose := runHTTPServer(mux, cfg.HealthCheckAddrPort)\n \t\tdefer close()\n@@ -237,15 +240,16 @@ func run() error {\n \n \t\tif cfg.localMetricsEnabled() {\n \t\t\tlog.Printf(\"Running metrics endpoint at %s/metrics\", cfg.LocalAddrPort)\n-\t\t\tmetricsHandlers(mux, client, cfg.DebugAddrPort)\n+\t\t\tregisterMetricsHandlers(mux, client, cfg.DebugAddrPort)\n \t\t}\n \n \t\tif cfg.localHealthEnabled() {\n \t\t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.LocalAddrPort)\n-\t\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \t\t}\n-\t\tif cfg.EgressProxiesCfgPath != \"\" {\n-\t\t\tlog.Printf(\"Running preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n+\n+\t\tif cfg.egressSvcsTerminateEPEnabled() {\n+\t\t\tlog.Printf(\"Running egress preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n \t\t\tep.registerHandlers(mux)\n \t\t}\n \n---\ncmd/containerboot/metrics.go\n@@ -62,13 +62,13 @@ func (m *metrics) handleDebug(w http.ResponseWriter, r *http.Request) {\n \tproxy(w, r, debugURL, http.DefaultClient.Do)\n }\n \n-// metricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n+// registerMetricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n // requests to tailscaled's /localapi/v0/usermetrics API.\n //\n // In 1.78.x and 1.80.x, it also proxies debug paths to tailscaled's debug\n // endpoint if configured to ease migration for a breaking change serving user\n // metrics instead of debug metrics on the \"metrics\" port.\n-func metricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n+func registerMetricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n \tm := &metrics{\n \t\tlc:            lc,\n \t\tdebugEndpoint: debugAddrPort,\n---\ncmd/containerboot/serve.go\n@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"log\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -169,3 +170,46 @@ func readServeConfig(path, certDomain string) (*ipn.ServeConfig, error) {\n \t}\n \treturn &sc, nil\n }\n+\n+func ensureServicesNotAdvertised(ctx context.Context, lc *local.Client) error {\n+\tprefs, err := lc.GetPrefs(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"error getting prefs: %w\", err)\n+\t}\n+\tif len(prefs.AdvertiseServices) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tlog.Printf(\"serve proxy: unadvertising services: %v\", prefs.AdvertiseServices)\n+\tif _, err := lc.EditPrefs(ctx, &ipn.MaskedPrefs{\n+\t\tAdvertiseServicesSet: true,\n+\t\tPrefs: ipn.Prefs{\n+\t\t\tAdvertiseServices: nil,\n+\t\t},\n+\t}); err != nil {\n+\t\t// EditPrefs only returns an error if it fails _set_ its local prefs.\n+\t\t// If it fails to _persist_ the prefs in state, we don't get an error\n+\t\t// and we continue waiting below, as control will failover as usual.\n+\t\treturn fmt.Errorf(\"error setting prefs AdvertiseServices: %w\", err)\n+\t}\n+\n+\t// Services use the same (failover XOR regional routing) mechanism that\n+\t// HA subnet routers use. Unfortunately we don't yet get a reliable signal\n+\t// from control that it's responded to our unadvertisement, so the best we\n+\t// can do is wait for 20 seconds, where 15s is the approximate maximum time\n+\t// it should take for control to choose a new primary, and 5s is for buffer.\n+\t//\n+\t// Note: There is no guarantee that clients have been _informed_ of the new\n+\t// primary no matter how long we wait. We would need a mechanism to await\n+\t// netmap updates for peers to know for sure.\n+\t//\n+\t// See https://tailscale.com/kb/1115/high-availability for more details.\n+\t// TODO(tomhjp): Wait for a netmap update instead of sleeping when control\n+\t// supports that.\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\treturn nil\n+\tcase <-time.After(20 * time.Second):\n+\t\treturn nil\n+\t}\n+}\n---\ncmd/k8s-operator/proxygroup_specs.go\n@@ -197,6 +197,16 @@ func pgStatefulSet(pg *tsapi.ProxyGroup, namespace, image, tsFirewallMode string\n \t// This mechanism currently (2025-01-26) rely on the local health check being accessible on the Pod's\n \t// IP, so they are not supported for ProxyGroups where users have configured TS_LOCAL_ADDR_PORT to a custom\n \t// value.\n+\t//\n+\t// NB: For _Ingress_ ProxyGroups, we run shutdown logic within containerboot\n+\t// in reaction to a SIGTERM signal instead of using a pre-stop hook. This is\n+\t// because Ingress pods need to unadvertise services, and it's preferable to\n+\t// avoid triggering those side-effects from a GET request that would be\n+\t// accessible to the whole cluster network (in the absence of NetworkPolicy\n+\t// rules).\n+\t//\n+\t// TODO(tomhjp): add a readiness probe or gate to Ingress Pods. There is a\n+\t// small window where the Pod is marked ready but routing can still fail.\n \tif pg.Spec.Type == tsapi.ProxyGroupTypeEgress && !hasLocalAddrPortSet(proxyClass) {\n \t\tc.Lifecycle = &corev1.Lifecycle{\n \t\t\tPreStop: &corev1.LifecycleHandler{\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis adds the missing symlink support to the nardump tool.\r\nI tested it locally with a few folders, and can confirm the produced nar output is identical to nix's.\r\n\r\nIf tests are required, I would like some guidance on how to create proper tests (fuzz tests?) along with a few basic golden tests.\r\n\r\ncc @bradfitz\r\n\r\nEdit: added a basic test which tests the main() directly for the two main use cases `--sri` and outputting nar. Rather than testing writeNar, etc. i.e. unit tests.\r\n\r\nEdit2: simplified the test, directly testing writeNAR\n\n---\n\nChoice A:\ncmd/nardump/nardump.go\n@@ -100,14 +100,13 @@ func (nw *narWriter) writeDir(dirPath string) error {\n \t\tsub := path.Join(dirPath, ent.Name())\n \t\tvar err error\n \t\tswitch {\n-\t\tcase mode.IsRegular():\n-\t\t\terr = nw.writeRegular(sub)\n \t\tcase mode.IsDir():\n \t\t\terr = nw.writeDir(sub)\n+\t\tcase mode.IsRegular():\n+\t\t\terr = nw.writeRegular(sub)\n+\t\tcase mode&os.ModeSymlink != 0:\n+\t\t\terr = nw.writeSymlink(sub)\n \t\tdefault:\n-\t\t\t// TODO(bradfitz): symlink, but requires fighting io/fs a bit\n-\t\t\t// to get at Readlink or the osFS via fs. But for now\n-\t\t\t// we don't need symlinks because they're not in Go's archive.\n \t\t\treturn fmt.Errorf(\"unsupported file type %v at %q\", sub, mode)\n \t\t}\n \t\tif err != nil {\n@@ -143,6 +142,23 @@ func (nw *narWriter) writeRegular(path string) error {\n \treturn nil\n }\n \n+func (nw *narWriter) writeSymlink(path string) error {\n+\tnw.str(\"(\")\n+\tnw.str(\"type\")\n+\tnw.str(\"symlink\")\n+\tnw.str(\"target\")\n+\t// broken symlinks are valid in a nar\n+\t// given we do os.chdir(dir) and os.dirfs(\".\") above\n+\t// readlink now resolves relative links even if they are broken\n+\tlink, err := os.Readlink(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tnw.str(link)\n+\tnw.str(\")\")\n+\treturn nil\n+}\n+\n func (nw *narWriter) str(s string) {\n \tif err := writeString(nw.w, s); err != nil {\n \t\tpanic(writeNARError{err})\n---\ncmd/nardump/nardump_test.go\n@@ -0,0 +1,52 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package main\n+\n+import (\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+// setupTmpdir sets up a known golden layout, covering all allowed file/folder types in a nar\n+func setupTmpdir(t *testing.T) string {\n+\ttmpdir := t.TempDir()\n+\tpwd, _ := os.Getwd()\n+\tos.Chdir(tmpdir)\n+\tdefer os.Chdir(pwd)\n+\tos.MkdirAll(\"sub/dir\", 0755)\n+\tos.Symlink(\"brokenfile\", \"brokenlink\")\n+\tos.Symlink(\"sub/dir\", \"dirl\")\n+\tos.Symlink(\"/abs/nonexistentdir\", \"dirb\")\n+\tos.Create(\"sub/dir/file1\")\n+\tf, _ := os.Create(\"file2m\")\n+\t_ = f.Truncate(2 * 1024 * 1024)\n+\tf.Close()\n+\tos.Symlink(\"../file2m\", \"sub/goodlink\")\n+\treturn tmpdir\n+}\n+\n+func TestWriteNar(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// Skip test on Windows as the Nix package manager is not supported on this platform\n+\t\tt.Skip(\"nix package manager is not available on Windows\")\n+\t}\n+\tdir := setupTmpdir(t)\n+\tt.Run(\"nar\", func(t *testing.T) {\n+\t\t// obtained via `nix-store --dump /tmp/... | sha256sum` of the above test dir\n+\t\texpected := \"727613a36f41030e93a4abf2649c3ec64a2757ccff364e3f6f7d544eb976e442\"\n+\t\th := sha256.New()\n+\t\tos.Chdir(dir)\n+\t\terr := writeNAR(h, os.DirFS(\".\"))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\thash := fmt.Sprintf(\"%x\", h.Sum(nil))\n+\t\tif expected != hash {\n+\t\t\tt.Fatal(\"sha256sum of nar not matched\", hash, expected)\n+\t\t}\n+\t})\n+}\n---\n\n\n---\n\nChoice B:\ncmd/k8s-operator/svc-for-pg.go\n@@ -211,6 +211,11 @@ func (r *HAServiceReconciler) maybeProvision(ctx context.Context, hostname strin\n \t// already created and not owned by this Service.\n \tserviceName := tailcfg.ServiceName(\"svc:\" + hostname)\n \texistingVIPSvc, err := r.tsClient.GetVIPService(ctx, serviceName)\n+\tif isErrorFeatureFlagNotEnabled(err) {\n+\t\tlogger.Warn(msgFeatureFlagNotEnabled)\n+\t\tr.recorder.Event(svc, corev1.EventTypeWarning, warningTailscaleServiceFeatureFlagNotEnabled, msgFeatureFlagNotEnabled)\n+\t\treturn false, nil\n+\t}\n \tif err != nil && !isErrorTailscaleServiceNotFound(err) {\n \t\treturn false, fmt.Errorf(\"error getting Tailscale Service %q: %w\", hostname, err)\n \t}\n@@ -529,6 +534,11 @@ func (r *HAServiceReconciler) tailnetCertDomain(ctx context.Context) (string, er\n // It returns true if an existing VIPService was updated to remove owner reference, as well as any error that occurred.\n func (r *HAServiceReconciler) cleanupVIPService(ctx context.Context, name tailcfg.ServiceName, logger *zap.SugaredLogger) (updated bool, err error) {\n \tsvc, err := r.tsClient.GetVIPService(ctx, name)\n+\tif isErrorFeatureFlagNotEnabled(err) {\n+\t\tmsg := fmt.Sprintf(\"Unable to proceed with cleanup: %s.\", msgFeatureFlagNotEnabled)\n+\t\tlogger.Warn(msg)\n+\t\treturn false, nil\n+\t}\n \tif err != nil {\n \t\terrResp := &tailscale.ErrResponse{}\n \t\tok := errors.As(err, errResp)\n---\n\n\n---\n\nChoice C:\nwgengine/magicsock/magicsock.go\n@@ -1625,6 +1625,25 @@ func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey ke\n \t\tc.mu.Unlock()\n \t\treturn false, errConnClosed\n \t}\n+\tvar di *discoInfo\n+\tswitch {\n+\tcase c.peerMap.knownPeerDiscoKey(dstDisco):\n+\t\tdi = c.discoInfoForKnownPeerLocked(dstDisco)\n+\tcase isRelayHandshakeMsg:\n+\t\t// TODO(jwhited): consider caching relay server disco shared keys\n+\t\tdi = &discoInfo{\n+\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n+\t\t}\n+\tdefault:\n+\t\t// This is an attempt to send to an unknown peer that is not a relay\n+\t\t// server. This can happen when a call to the current function, which is\n+\t\t// often via a new goroutine, races with applying a change in the\n+\t\t// netmap, e.g. the associated peer(s) for dstDisco goes away.\n+\t\tc.mu.Unlock()\n+\t\treturn false, errors.New(\"unknown peer\")\n+\t}\n+\tc.mu.Unlock()\n+\n \tpkt := make([]byte, 0, 512) // TODO: size it correctly? pool? if it matters.\n \tif geneveVNI != nil {\n \t\tgh := packet.GeneveHeader{\n@@ -1641,23 +1660,6 @@ func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey ke\n \t}\n \tpkt = append(pkt, disco.Magic...)\n \tpkt = c.discoPublic.AppendTo(pkt)\n-\tvar di *discoInfo\n-\tif !isRelayHandshakeMsg {\n-\t\tdi = c.discoInfoLocked(dstDisco)\n-\t} else {\n-\t\t// c.discoInfoLocked() caches [*discoInfo] for dstDisco. It assumes that\n-\t\t// dstDisco is a known Tailscale peer, and will be cleaned around\n-\t\t// network map changes. In the case of a relay handshake message,\n-\t\t// dstDisco belongs to a relay server with a disco key that is\n-\t\t// discovered at endpoint allocation time or [disco.CallMeMaybeVia]\n-\t\t// reception time. There is no clear ending to its lifetime, so we\n-\t\t// can't cache with the same strategy. Instead, generate the shared\n-\t\t// key on the fly for now.\n-\t\tdi = &discoInfo{\n-\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n-\t\t}\n-\t}\n-\tc.mu.Unlock()\n \n \tif isDERP {\n \t\tmetricSendDiscoDERP.Add(1)\n@@ -1814,7 +1816,7 @@ func (c *Conn) handleDiscoMessage(msg []byte, src netip.AddrPort, derpNodeSrc ke\n \t//\n \t// From here on, peerNode and de are non-nil.\n \n-\tdi := c.discoInfoLocked(sender)\n+\tdi := c.discoInfoForKnownPeerLocked(sender)\n \n \tsealedBox := msg[discoHeaderLen:]\n \tpayload, ok := di.sharedKey.Open(sealedBox)\n@@ -2076,10 +2078,15 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \t}\n }\n \n-// discoInfoLocked returns the previous or new discoInfo for k.\n+// discoInfoForKnownPeerLocked returns the previous or new discoInfo for k.\n+//\n+// Callers must only pass key.DiscoPublic's that are present in and\n+// lifetime-managed via [Conn].peerMap. UDP relay server disco keys are discovered\n+// at relay endpoint allocation time or [disco.CallMeMaybeVia] reception time\n+// and therefore must never pass through this method.\n //\n // c.mu must be held.\n-func (c *Conn) discoInfoLocked(k key.DiscoPublic) *discoInfo {\n+func (c *Conn) discoInfoForKnownPeerLocked(k key.DiscoPublic) *discoInfo {\n \tdi, ok := c.discoInfo[k]\n \tif !ok {\n \t\tdi = &discoInfo{\n---\n\n\n---\n\nChoice D:\ncontrol/controlclient/map_test.go\n@@ -17,6 +17,7 @@ import (\n \t\"github.com/google/go-cmp/cmp\"\n \t\"go4.org/mem\"\n \t\"tailscale.com/control/controlknobs\"\n+\t\"tailscale.com/health\"\n \t\"tailscale.com/tailcfg\"\n \t\"tailscale.com/tstest\"\n \t\"tailscale.com/tstime\"\n@@ -1136,3 +1137,34 @@ func BenchmarkMapSessionDelta(b *testing.B) {\n \t\t})\n \t}\n }\n+\n+// TestNetmapHealthIntegration checks that we get the expected health warnings\n+// from processing a map response and passing the NetworkMap to a health tracker\n+func TestNetmapHealthIntegration(t *testing.T) {\n+\tms := newTestMapSession(t, nil)\n+\tht := health.Tracker{}\n+\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tnm := ms.netmapForResponse(&tailcfg.MapResponse{\n+\t\tHealth: []string{\"Test message\"},\n+\t})\n+\tht.SetControlHealth(nm.ControlHealth)\n+\n+\tstate := ht.CurrentState()\n+\twarning, ok := state.Warnings[\"control-health\"]\n+\n+\tif !ok {\n+\t\tt.Fatal(\"no warning found in current state with code 'control-health'\")\n+\t}\n+\tif got, want := warning.Title, \"Coordination server reports an issue\"; got != want {\n+\t\tt.Errorf(\"warning.Title = %q, want %q\", got, want)\n+\t}\n+\tif got, want := warning.Severity, health.SeverityMedium; got != want {\n+\t\tt.Errorf(\"warning.Severity = %s, want %s\", got, want)\n+\t}\n+\tif got, want := warning.Text, \"The coordination server is reporting an health issue: Test message\"; got != want {\n+\t\tt.Errorf(\"warning.Text = %q, want %q\", got, want)\n+\t}\n+}\n---\nhealth/health.go\n@@ -402,7 +402,7 @@ func (t *Tracker) setUnhealthyLocked(w *Warnable, args Args) {\n \t\t\t// executed immediately. Otherwise, the callback should be enqueued to run once the Warnable\n \t\t\t// becomes visible.\n \t\t\tif w.IsVisible(ws, t.now) {\n-\t\t\t\tgo cb(w, w.unhealthyState(ws))\n+\t\t\t\tcb(w, w.unhealthyState(ws))\n \t\t\t\tcontinue\n \t\t\t}\n \n@@ -415,7 +415,7 @@ func (t *Tracker) setUnhealthyLocked(w *Warnable, args Args) {\n \t\t\t\t// Check if the Warnable is still unhealthy, as it could have become healthy between the time\n \t\t\t\t// the timer was set for and the time it was executed.\n \t\t\t\tif t.warnableVal[w] != nil {\n-\t\t\t\t\tgo cb(w, w.unhealthyState(ws))\n+\t\t\t\t\tcb(w, w.unhealthyState(ws))\n \t\t\t\t\tdelete(t.pendingVisibleTimers, w)\n \t\t\t\t}\n \t\t\t})\n@@ -449,7 +449,7 @@ func (t *Tracker) setHealthyLocked(w *Warnable) {\n \t}\n \n \tfor _, cb := range t.watchers {\n-\t\tgo cb(w, nil)\n+\t\tcb(w, nil)\n \t}\n }\n \n@@ -483,6 +483,16 @@ func (t *Tracker) AppendWarnableDebugFlags(base []string) []string {\n // The provided callback function will be executed in its own goroutine. The returned function can be used\n // to unregister the callback.\n func (t *Tracker) RegisterWatcher(cb func(w *Warnable, r *UnhealthyState)) (unregister func()) {\n+\treturn t.registerSyncWatcher(func(w *Warnable, r *UnhealthyState) {\n+\t\tgo cb(w, r)\n+\t})\n+}\n+\n+// registerSyncWatcher adds a function that will be called whenever the health\n+// state of any Warnable changes. The provided callback function will be\n+// executed synchronously. Call RegisterWatcher to register any callbacks that\n+// won't return from execution immediately.\n+func (t *Tracker) registerSyncWatcher(cb func(w *Warnable, r *UnhealthyState)) (unregister func()) {\n \tif t.nil() {\n \t\treturn func() {}\n \t}\n---\nhealth/health_test.go\n@@ -451,3 +451,88 @@ func TestNoDERPHomeWarnableManual(t *testing.T) {\n \t\tt.Fatalf(\"got unexpected noDERPHomeWarnable warnable: %v\", ws)\n \t}\n }\n+\n+func TestControlHealth(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\tstate := ht.CurrentState()\n+\twarning, ok := state.Warnings[\"control-health\"]\n+\n+\tif !ok {\n+\t\tt.Fatal(\"no warning found in current state with code 'control-health'\")\n+\t}\n+\tif got, want := warning.Title, \"Coordination server reports an issue\"; got != want {\n+\t\tt.Errorf(\"warning.Title = %q, want %q\", got, want)\n+\t}\n+\tif got, want := warning.Severity, SeverityMedium; got != want {\n+\t\tt.Errorf(\"warning.Severity = %s, want %s\", got, want)\n+\t}\n+\tif got, want := warning.Text, \"The coordination server is reporting an health issue: Test message\"; got != want {\n+\t\tt.Errorf(\"warning.Text = %q, want %q\", got, want)\n+\t}\n+}\n+\n+func TestControlHealthNotifiesOnChange(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tif !gotNotified {\n+\t\tt.Errorf(\"watcher did not get called, want it to be called\")\n+\t}\n+}\n+\n+func TestControlHealthNoNotifyOnUnchanged(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\tht.GotStreamedMapResponse()\n+\n+\t// Set up an existing control health issue\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\t// Now register our watcher\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\t// Send the same control health message again - should not notify\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tif gotNotified {\n+\t\tt.Errorf(\"watcher got called, want it to not be called\")\n+\t}\n+}\n+\n+func TestControlHealthIgnoredOutsideMapPoll(t *testing.T) {\n+\tht := Tracker{}\n+\tht.SetIPNState(\"NeedsLogin\", true)\n+\n+\tgotNotified := false\n+\tht.registerSyncWatcher(func(_ *Warnable, _ *UnhealthyState) {\n+\t\tgotNotified = true\n+\t})\n+\n+\tht.SetControlHealth([]string{\"Test message\"})\n+\n+\tstate := ht.CurrentState()\n+\t_, ok := state.Warnings[\"control-health\"]\n+\n+\tif ok {\n+\t\tt.Error(\"got a warning with code 'control-health', want none\")\n+\t}\n+\n+\tif gotNotified {\n+\t\tt.Error(\"watcher got called, want it to not be called\")\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\ninitPeerAPIListener may be returning early unexpectedly. Add debug logging to see what causes it to return early when it does.\r\n\r\nUpdates #14393\n\n---\n\nChoice A:\ntsnet/tsnet.go\n@@ -505,6 +505,11 @@ func (s *Server) start() (reterr error) {\n \t\t\t// directory and hostname when they're not supplied. But we can fall\n \t\t\t// back to \"tsnet\" as well.\n \t\t\texe = \"tsnet\"\n+\t\tcase \"ios\":\n+\t\t\t// When compiled as a framework (via TailscaleKit in libtailscale),\n+\t\t\t// os.Executable() returns an error, so fall back to \"tsnet\" there\n+\t\t\t// too.\n+\t\t\texe = \"tsnet\"\n \t\tdefault:\n \t\t\treturn err\n \t\t}\n---\n\n\n---\n\nChoice B:\nwgengine/magicsock/endpoint.go\n@@ -1111,7 +1111,7 @@ func (de *endpoint) sendDiscoPing(ep netip.AddrPort, discoKey key.DiscoPublic, t\n \tsize = min(size, MaxDiscoPingSize)\n \tpadding := max(size-discoPingSize, 0)\n \n-\tsent, _ := de.c.sendDiscoMessage(ep, de.publicKey, discoKey, &disco.Ping{\n+\tsent, _ := de.c.sendDiscoMessage(ep, nil, de.publicKey, discoKey, &disco.Ping{\n \t\tTxID:    [12]byte(txid),\n \t\tNodeKey: de.c.publicKeyAtomic.Load(),\n \t\tPadding: padding,\n---\nwgengine/magicsock/magicsock.go\n@@ -1602,23 +1602,60 @@ var debugIPv4DiscoPingPenalty = envknob.RegisterDuration(\"TS_DISCO_PONG_IPV4_DEL\n //\n // If dst is a DERP IP:port, then dstKey must be non-zero.\n //\n+// If geneveVNI is non-nil, then the [disco.Message] will be preceded by a\n+// Geneve header with the supplied VNI set.\n+//\n // The dstKey should only be non-zero if the dstDisco key\n // unambiguously maps to exactly one peer.\n-func (c *Conn) sendDiscoMessage(dst netip.AddrPort, dstKey key.NodePublic, dstDisco key.DiscoPublic, m disco.Message, logLevel discoLogLevel) (sent bool, err error) {\n+func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey key.NodePublic, dstDisco key.DiscoPublic, m disco.Message, logLevel discoLogLevel) (sent bool, err error) {\n \tisDERP := dst.Addr() == tailcfg.DerpMagicIPAddr\n \tif _, isPong := m.(*disco.Pong); isPong && !isDERP && dst.Addr().Is4() {\n \t\ttime.Sleep(debugIPv4DiscoPingPenalty())\n \t}\n \n+\tisRelayHandshakeMsg := false\n+\tswitch m.(type) {\n+\tcase *disco.BindUDPRelayEndpoint, *disco.BindUDPRelayEndpointAnswer:\n+\t\tisRelayHandshakeMsg = true\n+\t}\n+\n \tc.mu.Lock()\n \tif c.closed {\n \t\tc.mu.Unlock()\n \t\treturn false, errConnClosed\n \t}\n \tpkt := make([]byte, 0, 512) // TODO: size it correctly? pool? if it matters.\n+\tif geneveVNI != nil {\n+\t\tgh := packet.GeneveHeader{\n+\t\t\tVersion:  0,\n+\t\t\tProtocol: packet.GeneveProtocolDisco,\n+\t\t\tVNI:      *geneveVNI,\n+\t\t\tControl:  isRelayHandshakeMsg,\n+\t\t}\n+\t\tpkt = append(pkt, make([]byte, packet.GeneveFixedHeaderLength)...)\n+\t\terr := gh.Encode(pkt)\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t}\n \tpkt = append(pkt, disco.Magic...)\n \tpkt = c.discoPublic.AppendTo(pkt)\n-\tdi := c.discoInfoLocked(dstDisco)\n+\tvar di *discoInfo\n+\tif !isRelayHandshakeMsg {\n+\t\tdi = c.discoInfoLocked(dstDisco)\n+\t} else {\n+\t\t// c.discoInfoLocked() caches [*discoInfo] for dstDisco. It assumes that\n+\t\t// dstDisco is a known Tailscale peer, and will be cleaned around\n+\t\t// network map changes. In the case of a relay handshake message,\n+\t\t// dstDisco belongs to a relay server with a disco key that is\n+\t\t// discovered at endpoint allocation time or [disco.CallMeMaybeVia]\n+\t\t// reception time. There is no clear ending to its lifetime, so we\n+\t\t// can't cache with the same strategy. Instead, generate the shared\n+\t\t// key on the fly for now.\n+\t\tdi = &discoInfo{\n+\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n+\t\t}\n+\t}\n \tc.mu.Unlock()\n \n \tif isDERP {\n@@ -1943,7 +1980,7 @@ func (c *Conn) handlePingLocked(dm *disco.Ping, src netip.AddrPort, di *discoInf\n \n \tipDst := src\n \tdiscoDest := di.discoKey\n-\tgo c.sendDiscoMessage(ipDst, dstKey, discoDest, &disco.Pong{\n+\tgo c.sendDiscoMessage(ipDst, nil, dstKey, discoDest, &disco.Pong{\n \t\tTxID: dm.TxID,\n \t\tSrc:  src,\n \t}, discoVerboseLog)\n@@ -1988,12 +2025,12 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \tfor _, ep := range c.lastEndpoints {\n \t\teps = append(eps, ep.Addr)\n \t}\n-\tgo de.c.sendDiscoMessage(derpAddr, de.publicKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n+\tgo de.c.sendDiscoMessage(derpAddr, nil, de.publicKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n \tif debugSendCallMeUnknownPeer() {\n \t\t// Send a callMeMaybe packet to a non-existent peer\n \t\tunknownKey := key.NewNode().Public()\n \t\tc.logf(\"magicsock: sending CallMeMaybe to unknown peer per TS_DEBUG_SEND_CALLME_UNKNOWN_PEER\")\n-\t\tgo de.c.sendDiscoMessage(derpAddr, unknownKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n+\t\tgo de.c.sendDiscoMessage(derpAddr, nil, unknownKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n \t}\n }\n \n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local.go\n@@ -5302,9 +5302,11 @@ func (b *LocalBackend) closePeerAPIListenersLocked() {\n const peerAPIListenAsync = runtime.GOOS == \"windows\" || runtime.GOOS == \"android\"\n \n func (b *LocalBackend) initPeerAPIListener() {\n+\tb.logf(\"[v1] initPeerAPIListener: entered\")\n \tb.mu.Lock()\n \tdefer b.mu.Unlock()\n \tif b.shutdownCalled {\n+\t\tb.logf(\"[v1] initPeerAPIListener: shutting down\")\n \t\treturn\n \t}\n \n@@ -5314,6 +5316,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t// ResetForClientDisconnect, or Start happens when its\n \t\t// mutex was released, the netMap could be\n \t\t// nil'ed out (Issue 1996). Bail out early here if so.\n+\t\tb.logf(\"[v1] initPeerAPIListener: no netmap\")\n \t\treturn\n \t}\n \n@@ -5328,6 +5331,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t}\n \t\tif allSame {\n \t\t\t// Nothing to do.\n+\t\t\tb.logf(\"[v1] initPeerAPIListener: %d netmap addresses match existing listeners\", addrs.Len())\n \t\t\treturn\n \t\t}\n \t}\n@@ -5336,6 +5340,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \n \tselfNode := b.netMap.SelfNode\n \tif !selfNode.Valid() || b.netMap.GetAddresses().Len() == 0 {\n+\t\tb.logf(\"[v1] initPeerAPIListener: no addresses in netmap\")\n \t\treturn\n \t}\n \n@@ -5369,7 +5374,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n-\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n+\t\t\t\t\tb.logf(\"[v1] possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\nChoice D:\ncmd/tailscale/cli/netcheck.go\n@@ -55,7 +55,10 @@ func runNetcheck(ctx context.Context, args []string) error {\n \n \t// Ensure that we close the portmapper after running a netcheck; this\n \t// will release any port mappings created.\n-\tpm := portmapper.NewClient(logf, netMon, nil, nil, nil)\n+\tpm := portmapper.NewClient(portmapper.Config{\n+\t\tLogf:   logf,\n+\t\tNetMon: netMon,\n+\t})\n \tdefer pm.Close()\n \n \tc := &netcheck.Client{\n---\nipn/localapi/localapi.go\n@@ -818,19 +818,25 @@ func (h *Handler) serveDebugPortmap(w http.ResponseWriter, r *http.Request) {\n \tdone := make(chan bool, 1)\n \n \tvar c *portmapper.Client\n-\tc = portmapper.NewClient(logger.WithPrefix(logf, \"portmapper: \"), h.b.NetMon(), debugKnobs, h.b.ControlKnobs(), func() {\n-\t\tlogf(\"portmapping changed.\")\n-\t\tlogf(\"have mapping: %v\", c.HaveMapping())\n-\n-\t\tif ext, ok := c.GetCachedMappingOrStartCreatingOne(); ok {\n-\t\t\tlogf(\"cb: mapping: %v\", ext)\n-\t\t\tselect {\n-\t\t\tcase done <- true:\n-\t\t\tdefault:\n+\tc = portmapper.NewClient(portmapper.Config{\n+\t\tLogf:         logger.WithPrefix(logf, \"portmapper: \"),\n+\t\tNetMon:       h.b.NetMon(),\n+\t\tDebugKnobs:   debugKnobs,\n+\t\tControlKnobs: h.b.ControlKnobs(),\n+\t\tOnChange: func() {\n+\t\t\tlogf(\"portmapping changed.\")\n+\t\t\tlogf(\"have mapping: %v\", c.HaveMapping())\n+\n+\t\t\tif ext, ok := c.GetCachedMappingOrStartCreatingOne(); ok {\n+\t\t\t\tlogf(\"cb: mapping: %v\", ext)\n+\t\t\t\tselect {\n+\t\t\t\tcase done <- true:\n+\t\t\t\tdefault:\n+\t\t\t\t}\n+\t\t\t\treturn\n \t\t\t}\n-\t\t\treturn\n-\t\t}\n-\t\tlogf(\"cb: no mapping\")\n+\t\t\tlogf(\"cb: no mapping\")\n+\t\t},\n \t})\n \tdefer c.Close()\n \n---\nnet/portmapper/igd_test.go\n@@ -260,9 +260,14 @@ func (d *TestIGD) handlePCPQuery(pkt []byte, src netip.AddrPort) {\n \n func newTestClient(t *testing.T, igd *TestIGD) *Client {\n \tvar c *Client\n-\tc = NewClient(t.Logf, netmon.NewStatic(), nil, new(controlknobs.Knobs), func() {\n-\t\tt.Logf(\"port map changed\")\n-\t\tt.Logf(\"have mapping: %v\", c.HaveMapping())\n+\tc = NewClient(Config{\n+\t\tLogf:         t.Logf,\n+\t\tNetMon:       netmon.NewStatic(),\n+\t\tControlKnobs: new(controlknobs.Knobs),\n+\t\tOnChange: func() {\n+\t\t\tt.Logf(\"port map changed\")\n+\t\t\tt.Logf(\"have mapping: %v\", c.HaveMapping())\n+\t\t},\n \t})\n \tc.testPxPPort = igd.TestPxPPort()\n \tc.testUPnPPort = igd.TestUPnPPort()\n---\nnet/portmapper/portmapper.go\n@@ -201,32 +201,45 @@ func (m *pmpMapping) Release(ctx context.Context) {\n \tuc.WriteToUDPAddrPort(pkt, m.gw)\n }\n \n-// NewClient returns a new portmapping client.\n-//\n-// The netMon parameter is required.\n-//\n-// The debug argument allows configuring the behaviour of the portmapper for\n-// debugging; if nil, a sensible set of defaults will be used.\n-//\n-// The controlKnobs, if non-nil, specifies the control knobs from the control\n-// plane that might disable portmapping.\n-//\n-// The optional onChange argument specifies a func to run in a new goroutine\n-// whenever the port mapping status has changed. If nil, it doesn't make a\n-// callback.\n-func NewClient(logf logger.Logf, netMon *netmon.Monitor, debug *DebugKnobs, controlKnobs *controlknobs.Knobs, onChange func()) *Client {\n-\tif netMon == nil {\n+// Config carries the settings for a [Client].\n+type Config struct {\n+\t// Logf is called to generate text logs for the client. If nil, logger.Discard is used.\n+\tLogf logger.Logf\n+\n+\t// NetMon is the network monitor used by the client. It must be non-nil.\n+\tNetMon *netmon.Monitor\n+\n+\t// DebugKnobs, if non-nil, configure the behaviour of the portmapper for\n+\t// debugging.  If nil, a sensible set of defaults will be used.\n+\tDebugKnobs *DebugKnobs\n+\n+\t// ControlKnobs, if non-nil, specifies knobs from the control plane that\n+\t// might disable port mapping.\n+\tControlKnobs *controlknobs.Knobs\n+\n+\t// OnChange is called to run in a new goroutine whenever the port mapping\n+\t// status has changed. If nil, no callback is issued.\n+\tOnChange func()\n+}\n+\n+// NewClient constructs a new portmapping [Client] from c. It will panic if any\n+// required parameters are omitted.\n+func NewClient(c Config) *Client {\n+\tif c.NetMon == nil {\n \t\tpanic(\"nil netMon\")\n \t}\n \tret := &Client{\n-\t\tlogf:         logf,\n-\t\tnetMon:       netMon,\n+\t\tlogf:         c.Logf,\n+\t\tnetMon:       c.NetMon,\n \t\tipAndGateway: netmon.LikelyHomeRouterIP, // TODO(bradfitz): move this to method on netMon\n-\t\tonChange:     onChange,\n-\t\tcontrolKnobs: controlKnobs,\n+\t\tonChange:     c.OnChange,\n+\t\tcontrolKnobs: c.ControlKnobs,\n+\t}\n+\tif ret.logf == nil {\n+\t\tret.logf = logger.Discard\n \t}\n-\tif debug != nil {\n-\t\tret.debug = *debug\n+\tif c.DebugKnobs != nil {\n+\t\tret.debug = *c.DebugKnobs\n \t}\n \treturn ret\n }\n---\nnet/portmapper/portmapper_test.go\n@@ -18,7 +18,7 @@ func TestCreateOrGetMapping(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tc.SetLocalPort(1234)\n \tfor i := range 2 {\n@@ -34,7 +34,7 @@ func TestClientProbe(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tfor i := range 3 {\n \t\tif i > 0 {\n@@ -49,7 +49,7 @@ func TestClientProbeThenMap(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tc.debug.VerboseLogs = true\n \tc.SetLocalPort(1234)\n---\nwgengine/magicsock/magicsock.go\n@@ -544,7 +544,13 @@ func NewConn(opts Options) (*Conn, error) {\n \tportMapOpts := &portmapper.DebugKnobs{\n \t\tDisableAll: func() bool { return opts.DisablePortMapper || c.onlyTCP443.Load() },\n \t}\n-\tc.portMapper = portmapper.NewClient(portmapperLogf, opts.NetMon, portMapOpts, opts.ControlKnobs, c.onPortMapChanged)\n+\tc.portMapper = portmapper.NewClient(portmapper.Config{\n+\t\tLogf:         portmapperLogf,\n+\t\tNetMon:       opts.NetMon,\n+\t\tDebugKnobs:   portMapOpts,\n+\t\tControlKnobs: opts.ControlKnobs,\n+\t\tOnChange:     c.onPortMapChanged,\n+\t})\n \tc.portMapper.SetGatewayLookupFunc(opts.NetMon.GatewayAndSelfIP)\n \tc.netMon = opts.NetMon\n \tc.health = opts.HealthTracker\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nWe now have a tailscale/alpine-base:3.19- use that as the default base image.\r\n\r\nNote that this change only applies to local dev builds.\r\nOur image build infra uses ALPINE.txt file and I already build images using the 3.19 base (`unstable-v1.81.209` tag)\r\n\r\nUpdates tailscale/tailscale#15328\n\n---\n\nChoice A:\ncmd/tailscale/cli/set.go\n@@ -11,6 +11,7 @@ import (\n \t\"net/netip\"\n \t\"os/exec\"\n \t\"runtime\"\n+\t\"strconv\"\n \t\"strings\"\n \n \t\"github.com/peterbourgon/ff/v3/ffcli\"\n@@ -22,6 +23,7 @@ import (\n \t\"tailscale.com/net/tsaddr\"\n \t\"tailscale.com/safesocket\"\n \t\"tailscale.com/types/opt\"\n+\t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/version\"\n )\n@@ -62,6 +64,7 @@ type setArgsT struct {\n \tsnat                   bool\n \tstatefulFiltering      bool\n \tnetfilterMode          string\n+\trelayServerPort        string\n }\n \n func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n@@ -82,6 +85,7 @@ func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n \tsetf.BoolVar(&setArgs.updateApply, \"auto-update\", false, \"automatically update to the latest available version\")\n \tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, hidden+\"allow management plane to gather device posture information\")\n \tsetf.BoolVar(&setArgs.runWebClient, \"webclient\", false, \"expose the web interface for managing this node over Tailscale at port 5252\")\n+\tsetf.StringVar(&setArgs.relayServerPort, \"relay-server-port\", \"\", hidden+\"UDP port number (0 will pick a random unused port) for the relay server to bind to, on all interfaces, or empty string to disable relay server functionality\")\n \n \tffcomplete.Flag(setf, \"exit-node\", func(args []string) ([]string, ffcomplete.ShellCompDirective, error) {\n \t\tst, err := localClient.Status(context.Background())\n@@ -233,6 +237,15 @@ func runSet(ctx context.Context, args []string) (retErr error) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tif setArgs.relayServerPort != \"\" {\n+\t\tuport, err := strconv.ParseUint(setArgs.relayServerPort, 10, 16)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"failed to set relay server port: %v\", err)\n+\t\t}\n+\t\tmaskedPrefs.Prefs.RelayServerPort = ptr.To(int(uport))\n+\t}\n+\n \tcheckPrefs := curPrefs.Clone()\n \tcheckPrefs.ApplyEdits(maskedPrefs)\n \tif err := localClient.CheckPrefs(ctx, checkPrefs); err != nil {\n---\ncmd/tailscale/cli/up.go\n@@ -773,6 +773,7 @@ func init() {\n \taddPrefFlagMapping(\"auto-update\", \"AutoUpdate.Apply\")\n \taddPrefFlagMapping(\"advertise-connector\", \"AppConnector\")\n \taddPrefFlagMapping(\"posture-checking\", \"PostureChecking\")\n+\taddPrefFlagMapping(\"relay-server-port\", \"RelayServerPort\")\n }\n \n func addPrefFlagMapping(flagName string, prefNames ...string) {\n---\nipn/ipn_clone.go\n@@ -61,6 +61,9 @@ func (src *Prefs) Clone() *Prefs {\n \t\t\t}\n \t\t}\n \t}\n+\tif dst.RelayServerPort != nil {\n+\t\tdst.RelayServerPort = ptr.To(*src.RelayServerPort)\n+\t}\n \tdst.Persist = src.Persist.Clone()\n \treturn dst\n }\n@@ -96,6 +99,7 @@ var _PrefsCloneNeedsRegeneration = Prefs(struct {\n \tPostureChecking        bool\n \tNetfilterKind          string\n \tDriveShares            []*drive.Share\n+\tRelayServerPort        *int\n \tAllowSingleHosts       marshalAsTrueInJSON\n \tPersist                *persist.Persist\n }{})\n---\nipn/ipn_view.go\n@@ -166,6 +166,10 @@ func (v PrefsView) NetfilterKind() string                 { return v.\u0436.Netfilte\n func (v PrefsView) DriveShares() views.SliceView[*drive.Share, drive.ShareView] {\n \treturn views.SliceOfViews[*drive.Share, drive.ShareView](v.\u0436.DriveShares)\n }\n+func (v PrefsView) RelayServerPort() views.ValuePointer[int] {\n+\treturn views.ValuePointerOf(v.\u0436.RelayServerPort)\n+}\n+\n func (v PrefsView) AllowSingleHosts() marshalAsTrueInJSON { return v.\u0436.AllowSingleHosts }\n func (v PrefsView) Persist() persist.PersistView          { return v.\u0436.Persist.View() }\n \n@@ -200,6 +204,7 @@ var _PrefsViewNeedsRegeneration = Prefs(struct {\n \tPostureChecking        bool\n \tNetfilterKind          string\n \tDriveShares            []*drive.Share\n+\tRelayServerPort        *int\n \tAllowSingleHosts       marshalAsTrueInJSON\n \tPersist                *persist.Persist\n }{})\n---\nipn/prefs.go\n@@ -246,6 +246,14 @@ type Prefs struct {\n \t// by name.\n \tDriveShares []*drive.Share\n \n+\t// RelayServerPort is the UDP port number for the relay server to bind to,\n+\t// on all interfaces. A non-nil zero value signifies a random unused port\n+\t// should be used. A nil value signifies relay server functionality\n+\t// should be disabled. This field is currently experimental, and therefore\n+\t// no guarantees are made about its current naming and functionality when\n+\t// non-nil/enabled.\n+\tRelayServerPort *int `json:\",omitempty\"`\n+\n \t// AllowSingleHosts was a legacy field that was always true\n \t// for the past 4.5 years. It controlled whether Tailscale\n \t// peers got /32 or /127 routes for each other.\n@@ -337,6 +345,7 @@ type MaskedPrefs struct {\n \tPostureCheckingSet        bool                `json:\",omitempty\"`\n \tNetfilterKindSet          bool                `json:\",omitempty\"`\n \tDriveSharesSet            bool                `json:\",omitempty\"`\n+\tRelayServerPortSet        bool                `json:\",omitempty\"`\n }\n \n // SetsInternal reports whether mp has any of the Internal*Set field bools set\n@@ -555,6 +564,9 @@ func (p *Prefs) pretty(goos string) string {\n \t}\n \tsb.WriteString(p.AutoUpdate.Pretty())\n \tsb.WriteString(p.AppConnector.Pretty())\n+\tif p.RelayServerPort != nil {\n+\t\tfmt.Fprintf(&sb, \"relayServerPort=%d \", *p.RelayServerPort)\n+\t}\n \tif p.Persist != nil {\n \t\tsb.WriteString(p.Persist.Pretty())\n \t} else {\n@@ -616,7 +628,8 @@ func (p *Prefs) Equals(p2 *Prefs) bool {\n \t\tp.AppConnector == p2.AppConnector &&\n \t\tp.PostureChecking == p2.PostureChecking &&\n \t\tslices.EqualFunc(p.DriveShares, p2.DriveShares, drive.SharesEqual) &&\n-\t\tp.NetfilterKind == p2.NetfilterKind\n+\t\tp.NetfilterKind == p2.NetfilterKind &&\n+\t\tcompareIntPtrs(p.RelayServerPort, p2.RelayServerPort)\n }\n \n func (au AutoUpdatePrefs) Pretty() string {\n@@ -636,6 +649,16 @@ func (ap AppConnectorPrefs) Pretty() string {\n \treturn \"\"\n }\n \n+func compareIntPtrs(a, b *int) bool {\n+\tif (a == nil) != (b == nil) {\n+\t\treturn false\n+\t}\n+\tif a == nil {\n+\t\treturn true\n+\t}\n+\treturn *a == *b\n+}\n+\n // NewPrefs returns the default preferences to use.\n func NewPrefs() *Prefs {\n \t// Provide default values for options which might be missing\n---\nipn/prefs_test.go\n@@ -65,6 +65,7 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\"PostureChecking\",\n \t\t\"NetfilterKind\",\n \t\t\"DriveShares\",\n+\t\t\"RelayServerPort\",\n \t\t\"AllowSingleHosts\",\n \t\t\"Persist\",\n \t}\n@@ -73,6 +74,9 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\thave, prefsHandles)\n \t}\n \n+\trelayServerPort := func(port int) *int {\n+\t\treturn &port\n+\t}\n \tnets := func(strs ...string) (ns []netip.Prefix) {\n \t\tfor _, s := range strs {\n \t\t\tn, err := netip.ParsePrefix(s)\n@@ -341,6 +345,16 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\t&Prefs{AdvertiseServices: []string{\"svc:tux\", \"svc:amelie\"}},\n \t\t\tfalse,\n \t\t},\n+\t\t{\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(0)},\n+\t\t\t&Prefs{RelayServerPort: nil},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(0)},\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(1)},\n+\t\t\tfalse,\n+\t\t},\n \t}\n \tfor i, tt := range tests {\n \t\tgot := tt.a.Equals(tt.b)\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -958,7 +958,9 @@ func (b *LocalBackend) linkChange(delta *netmon.ChangeDelta) {\n \n \tif peerAPIListenAsync && b.netMap != nil && b.state == ipn.Running {\n \t\twant := b.netMap.GetAddresses().Len()\n-\t\tif len(b.peerAPIListeners) < want {\n+\t\thave := len(b.peerAPIListeners)\n+\t\tb.logf(\"[v1] linkChange: have %d peerAPIListeners, want %d\", have, want)\n+\t\tif have < want {\n \t\t\tb.logf(\"linkChange: peerAPIListeners too low; trying again\")\n \t\t\tb.goTracker.Go(b.initPeerAPIListener)\n \t\t}\n@@ -5369,6 +5371,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n+\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\nChoice C:\nbuild_docker.sh\n@@ -16,7 +16,7 @@ eval \"$(./build_dist.sh shellvars)\"\n \n DEFAULT_TARGET=\"client\"\n DEFAULT_TAGS=\"v${VERSION_SHORT},v${VERSION_MINOR}\"\n-DEFAULT_BASE=\"tailscale/alpine-base:3.18\"\n+DEFAULT_BASE=\"tailscale/alpine-base:3.19\"\n # Set a few pre-defined OCI annotations. The source annotation is used by tools such as Renovate that scan the linked\n # Github repo to find release notes for any new image tags. Note that for official Tailscale images the default\n # annotations defined here will be overriden by release scripts that call this script.\n---\n\n\n---\n\nChoice D:\ncmd/k8s-operator/depaware.txt\n@@ -840,7 +840,7 @@ tailscale.com/cmd/k8s-operator dependencies: (generated by github.com/tailscale/\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/cmd/k8s-operator+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\ncmd/tailscaled/depaware.txt\n@@ -318,7 +318,7 @@ tailscale.com/cmd/tailscaled dependencies: (generated by github.com/tailscale/de\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/cmd/tailscaled+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\nipn/ipnlocal/local.go\n@@ -64,6 +64,7 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4886,7 +4887,6 @@ func (b *LocalBackend) authReconfig() {\n \tnm := cn.NetMap()\n \thasPAC := b.prevIfState.HasPAC()\n \tdisableSubnetsIfPAC := cn.SelfHasCap(tailcfg.NodeAttrDisableSubnetsIfPAC)\n-\tuserDialUseRoutes := cn.SelfHasCap(tailcfg.NodeAttrUserDialUseRoutes)\n \tdohURL, dohURLOK := cn.exitNodeCanProxyDNS(prefs.ExitNodeID())\n \tdcfg := cn.dnsConfigForNetmap(prefs, b.keyExpired, b.logf, version.OS())\n \t// If the current node is an app connector, ensure the app connector machine is started\n@@ -4947,7 +4947,7 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif userDialUseRoutes {\n+\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n \t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n \t} else {\n \t\tb.dialer.SetRoutes(nil, nil)\n---\nnet/dns/resolver/forwarder.go\n@@ -17,6 +17,7 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"net/url\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n@@ -740,18 +741,35 @@ func (f *forwarder) sendUDP(ctx context.Context, fq *forwardQuery, rr resolverAn\n \treturn out, nil\n }\n \n+var optDNSForwardUseRoutes = envknob.RegisterOptBool(\"TS_DEBUG_DNS_FORWARD_USE_ROUTES\")\n+\n+// ShouldUseRoutes reports whether the DNS resolver should consider routes when dialing\n+// upstream nameservers via TCP.\n+//\n+// If true, routes should be considered ([tsdial.Dialer.UserDial]), otherwise defer\n+// to the system routes ([tsdial.Dialer.SystemDial]).\n+//\n+// TODO(nickkhyl): Update [tsdial.Dialer] to reuse the bart.Table we create in net/tstun.Wrapper\n+// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n+// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n+//\n+// See tailscale/tailscale#12027.\n+func ShouldUseRoutes(knobs *controlknobs.Knobs) bool {\n+\tswitch runtime.GOOS {\n+\tcase \"android\", \"ios\":\n+\t\t// On mobile platforms with lower memory limits (e.g., 50MB on iOS),\n+\t\t// this behavior is still gated by the \"user-dial-routes\" nodeAttr.\n+\t\treturn knobs != nil && knobs.UserDialUseRoutes.Load()\n+\tdefault:\n+\t\t// On all other platforms, it is the default behavior,\n+\t\t// but it can be overridden with the \"TS_DEBUG_DNS_FORWARD_USE_ROUTES\" env var.\n+\t\tdoNotUseRoutes := optDNSForwardUseRoutes().EqualBool(false)\n+\t\treturn !doNotUseRoutes\n+\t}\n+}\n+\n func (f *forwarder) getDialerType() netx.DialFunc {\n-\tif f.controlKnobs != nil && f.controlKnobs.UserDialUseRoutes.Load() {\n-\t\t// It is safe to use UserDial as it dials external servers without going through Tailscale\n-\t\t// and closes connections on interface change in the same way as SystemDial does,\n-\t\t// thus preventing DNS resolution issues when switching between WiFi and cellular,\n-\t\t// but can also dial an internal DNS server on the Tailnet or via a subnet router.\n-\t\t//\n-\t\t// TODO(nickkhyl): Update tsdial.Dialer to reuse the bart.Table we create in net/tstun.Wrapper\n-\t\t// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n-\t\t// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n-\t\t//\n-\t\t// See https://github.com/tailscale/tailscale/issues/12027.\n+\tif ShouldUseRoutes(f.controlKnobs) {\n \t\treturn f.dialer.UserDial\n \t}\n \treturn f.dialer.SystemDial\n---\nnet/tsdial/tsdial.go\n@@ -151,6 +151,7 @@ func (d *Dialer) SetRoutes(routes, localRoutes []netip.Prefix) {\n \t\tfor _, r := range localRoutes {\n \t\t\trt.Insert(r, false)\n \t\t}\n+\t\td.logf(\"tsdial: bart table size: %d\", rt.Size())\n \t}\n \n \td.routes.Store(rt)\n---\ntsnet/depaware.txt\n@@ -271,7 +271,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAdd a PreStop lifecycle hook to the ProxyGroup ingress spec so that we can explicitly notify control that the service is being unadvertised and prompt it to update the netmap for clients faster. Without this, control just treats the device as temporarily offline and allows it a grace period before no longer considering it part of the service.\r\n\r\nChange-Id: I0a9a4fe7a5395ca76135ceead05cbc3ee32b3d3c\n\n---\n\nChoice A:\ntsnet/depaware.txt\n@@ -132,7 +132,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n    L \ud83d\udca3 github.com/mdlayher/netlink                                  from github.com/google/nftables+\n    L \ud83d\udca3 github.com/mdlayher/netlink/nlenc                            from github.com/jsimonetti/rtnetlink+\n    L    github.com/mdlayher/netlink/nltest                           from github.com/google/nftables\n-  LA    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n+   L    github.com/mdlayher/sdnotify                                 from tailscale.com/util/systemd\n   LA \ud83d\udca3 github.com/mdlayher/socket                                   from github.com/mdlayher/netlink+\n         github.com/miekg/dns                                         from tailscale.com/net/dns/recursive\n  LDWA \ud83d\udca3 github.com/mitchellh/go-ps                                   from tailscale.com/safesocket\n---\nutil/systemd/systemd_linux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package systemd\n \n---\nutil/systemd/systemd_nonlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux || android\n \n package systemd\n \n---\n\n\n---\n\nChoice B:\ncmd/containerboot/healthz.go\n@@ -47,10 +47,10 @@ func (h *healthz) update(healthy bool) {\n \th.hasAddrs = healthy\n }\n \n-// healthHandlers registers a simple health handler at /healthz.\n+// registerHealthHandlers registers a simple health handler at /healthz.\n // A containerized tailscale instance is considered healthy if\n // it has at least one tailnet IP address.\n-func healthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n+func registerHealthHandlers(mux *http.ServeMux, podIPv4 string) *healthz {\n \th := &healthz{podIPv4: podIPv4}\n \tmux.Handle(\"GET /healthz\", h)\n \treturn h\n---\ncmd/containerboot/main.go\n@@ -226,29 +226,38 @@ func run() error {\n \t\tmux := http.NewServeMux()\n \n \t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.HealthCheckAddrPort)\n-\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \n \t\tclose := runHTTPServer(mux, cfg.HealthCheckAddrPort)\n \t\tdefer close()\n \t}\n \n-\tif cfg.localMetricsEnabled() || cfg.localHealthEnabled() || cfg.egressSvcsTerminateEPEnabled() {\n+\tif cfg.localMetricsEnabled() ||\n+\t\tcfg.localHealthEnabled() ||\n+\t\tcfg.egressSvcsTerminateEPEnabled() ||\n+\t\tcfg.ServeConfigPath != \"\" {\n \t\tmux := http.NewServeMux()\n \n \t\tif cfg.localMetricsEnabled() {\n \t\t\tlog.Printf(\"Running metrics endpoint at %s/metrics\", cfg.LocalAddrPort)\n-\t\t\tmetricsHandlers(mux, client, cfg.DebugAddrPort)\n+\t\t\tregisterMetricsHandlers(mux, client, cfg.DebugAddrPort)\n \t\t}\n \n \t\tif cfg.localHealthEnabled() {\n \t\t\tlog.Printf(\"Running healthcheck endpoint at %s/healthz\", cfg.LocalAddrPort)\n-\t\t\thealthCheck = healthHandlers(mux, cfg.PodIPv4)\n+\t\t\thealthCheck = registerHealthHandlers(mux, cfg.PodIPv4)\n \t\t}\n-\t\tif cfg.EgressProxiesCfgPath != \"\" {\n-\t\t\tlog.Printf(\"Running preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n+\n+\t\tif cfg.egressSvcsTerminateEPEnabled() {\n+\t\t\tlog.Printf(\"Running egress preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.EgessServicesPreshutdownEP)\n \t\t\tep.registerHandlers(mux)\n \t\t}\n \n+\t\tif cfg.ServeConfigPath != \"\" {\n+\t\t\tlog.Printf(\"Running serve preshutdown hook at %s%s\", cfg.LocalAddrPort, kubetypes.ServePreshutdownEP)\n+\t\t\tregisterServeShutdownHandlers(mux, client)\n+\t\t}\n+\n \t\tclose := runHTTPServer(mux, cfg.LocalAddrPort)\n \t\tdefer close()\n \t}\n---\ncmd/containerboot/metrics.go\n@@ -62,13 +62,13 @@ func (m *metrics) handleDebug(w http.ResponseWriter, r *http.Request) {\n \tproxy(w, r, debugURL, http.DefaultClient.Do)\n }\n \n-// metricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n+// registerMetricsHandlers registers a simple HTTP metrics handler at /metrics, forwarding\n // requests to tailscaled's /localapi/v0/usermetrics API.\n //\n // In 1.78.x and 1.80.x, it also proxies debug paths to tailscaled's debug\n // endpoint if configured to ease migration for a breaking change serving user\n // metrics instead of debug metrics on the \"metrics\" port.\n-func metricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n+func registerMetricsHandlers(mux *http.ServeMux, lc *local.Client, debugAddrPort string) {\n \tm := &metrics{\n \t\tlc:            lc,\n \t\tdebugEndpoint: debugAddrPort,\n---\ncmd/containerboot/serve.go\n@@ -9,7 +9,9 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"log\"\n+\t\"net/http\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n@@ -169,3 +171,32 @@ func readServeConfig(path, certDomain string) (*ipn.ServeConfig, error) {\n \t}\n \treturn &sc, nil\n }\n+\n+func registerServeShutdownHandlers(mux *http.ServeMux, lc *local.Client) {\n+\t// Register the ingress shutdown handler.\n+\tmux.Handle(fmt.Sprintf(\"GET %s\", kubetypes.ServePreshutdownEP), serveShutdownHandler(lc))\n+}\n+\n+func serveShutdownHandler(lc *local.Client) http.HandlerFunc {\n+\treturn func(w http.ResponseWriter, r *http.Request) {\n+\t\tprefs, err := lc.GetPrefs(r.Context())\n+\t\tif err != nil {\n+\t\t\thttp.Error(w, fmt.Sprintf(\"error getting prefs: %v\", err), http.StatusInternalServerError)\n+\t\t\treturn\n+\t\t}\n+\t\tif len(prefs.AdvertiseServices) == 0 {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tlog.Printf(\"serve proxy: unadvertising services: %v\", prefs.AdvertiseServices)\n+\t\tif _, err := lc.EditPrefs(r.Context(), &ipn.MaskedPrefs{\n+\t\t\tAdvertiseServicesSet: true,\n+\t\t\tPrefs: ipn.Prefs{\n+\t\t\t\tAdvertiseServices: nil,\n+\t\t\t},\n+\t\t}); err != nil {\n+\t\t\thttp.Error(w, fmt.Sprintf(\"error setting prefs AdvertiseServices: %v\", err), http.StatusInternalServerError)\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n---\ncmd/k8s-operator/proxygroup_specs.go\n@@ -209,6 +209,15 @@ func pgStatefulSet(pg *tsapi.ProxyGroup, namespace, image, tsFirewallMode string\n \t\t// Set the deletion grace period to 6 minutes to ensure that the pre-stop hook has enough time to terminate\n \t\t// gracefully.\n \t\tss.Spec.Template.DeletionGracePeriodSeconds = ptr.To(deletionGracePeriodSeconds)\n+\t} else if pg.Spec.Type == tsapi.ProxyGroupTypeIngress {\n+\t\tc.Lifecycle = &corev1.Lifecycle{\n+\t\t\tPreStop: &corev1.LifecycleHandler{\n+\t\t\t\tHTTPGet: &corev1.HTTPGetAction{\n+\t\t\t\t\tPath: kubetypes.ServePreshutdownEP,\n+\t\t\t\t\tPort: intstr.FromInt(defaultLocalAddrPort),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n \t}\n \treturn ss, nil\n }\n---\ncmd/k8s-operator/proxygroup_test.go\n@@ -418,6 +418,18 @@ func TestProxyGroupTypes(t *testing.T) {\n \t\tverifyEnvVar(t, sts, \"TS_SERVE_CONFIG\", \"/etc/proxies/serve-config.json\")\n \t\tverifyEnvVar(t, sts, \"TS_EXPERIMENTAL_CERT_SHARE\", \"true\")\n \n+\t\texpectedLifecycle := corev1.Lifecycle{\n+\t\t\tPreStop: &corev1.LifecycleHandler{\n+\t\t\t\tHTTPGet: &corev1.HTTPGetAction{\n+\t\t\t\t\tPath: kubetypes.ServePreshutdownEP,\n+\t\t\t\t\tPort: intstr.FromInt(defaultLocalAddrPort),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tif diff := cmp.Diff(expectedLifecycle, *sts.Spec.Template.Spec.Containers[0].Lifecycle); diff != \"\" {\n+\t\t\tt.Errorf(\"unexpected lifecycle (-want +got):\\n%s\", diff)\n+\t\t}\n+\n \t\t// Verify ConfigMap volume mount\n \t\tcmName := fmt.Sprintf(\"%s-ingress-config\", pg.Name)\n \t\texpectedVolume := corev1.Volume{\n---\nkube/kubetypes/types.go\n@@ -48,6 +48,7 @@ const (\n \tPodIPv4Header string = \"Pod-IPv4\"\n \n \tEgessServicesPreshutdownEP = \"/internal-egress-services-preshutdown\"\n+\tServePreshutdownEP         = \"/internal-serve-preshutdown\"\n \n \tLabelManaged    = \"tailscale.com/managed\"\n \tLabelSecretType = \"tailscale.com/secret-type\" // \"config\", \"state\" \"certs\"\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/c2n.go\n@@ -240,13 +240,14 @@ func handleC2NAppConnectorDomainRoutesGet(b *LocalBackend, w http.ResponseWriter\n \tb.logf(\"c2n: GET /appconnector/routes received\")\n \n \tvar res tailcfg.C2NAppConnectorDomainRoutesResponse\n-\tif b.appConnector == nil {\n+\tappConnector := b.AppConnector()\n+\tif appConnector == nil {\n \t\tw.Header().Set(\"Content-Type\", \"application/json\")\n \t\tjson.NewEncoder(w).Encode(res)\n \t\treturn\n \t}\n \n-\tres.Domains = b.appConnector.DomainRoutes()\n+\tres.Domains = appConnector.DomainRoutes()\n \n \tw.Header().Set(\"Content-Type\", \"application/json\")\n \tjson.NewEncoder(w).Encode(res)\n---\nipn/ipnlocal/local.go\n@@ -4150,8 +4150,8 @@ func (b *LocalBackend) SetUseExitNodeEnabled(v bool) (ipn.PrefsView, error) {\n // AdvertiseRoutes has been set in the MaskedPrefs.\n func (b *LocalBackend) MaybeClearAppConnector(mp *ipn.MaskedPrefs) error {\n \tvar err error\n-\tif b.appConnector != nil && mp.AdvertiseRoutesSet {\n-\t\terr = b.appConnector.ClearRoutes()\n+\tif ac := b.AppConnector(); ac != nil && mp.AdvertiseRoutesSet {\n+\t\terr = ac.ClearRoutes()\n \t\tif err != nil {\n \t\t\tb.logf(\"appc: clear routes error: %v\", err)\n \t\t}\n@@ -4755,9 +4755,7 @@ func (b *LocalBackend) readvertiseAppConnectorRoutes() {\n \t//\n \t// Grab a copy of the field, since b.mu only guards access to the\n \t// b.appConnector field itself.\n-\tb.mu.Lock()\n-\tappConnector := b.appConnector\n-\tb.mu.Unlock()\n+\tappConnector := b.AppConnector()\n \n \tif appConnector == nil {\n \t\treturn\n@@ -6432,6 +6430,15 @@ func (b *LocalBackend) OfferingAppConnector() bool {\n \treturn b.appConnector != nil\n }\n \n+// AppConnector returns the current AppConnector, or nil if not configured.\n+//\n+// TODO(nickkhyl): move app connectors to [nodeBackend], or perhaps a feature package?\n+func (b *LocalBackend) AppConnector() *appc.AppConnector {\n+\tb.mu.Lock()\n+\tdefer b.mu.Unlock()\n+\treturn b.appConnector\n+}\n+\n // allowExitNodeDNSProxyToServeName reports whether the Exit Node DNS\n // proxy is allowed to serve responses for the provided DNS name.\n func (b *LocalBackend) allowExitNodeDNSProxyToServeName(name string) bool {\n---\n\n\n---\n\nChoice D:\nrelease/dist/cli/cli.go\n@@ -65,6 +65,7 @@ func CLI(getTargets func() ([]dist.Target, error)) *ffcli.Command {\n \t\t\t\t\tfs.StringVar(&buildArgs.manifest, \"manifest\", \"\", \"manifest file to write\")\n \t\t\t\t\tfs.BoolVar(&buildArgs.verbose, \"verbose\", false, \"verbose logging\")\n \t\t\t\t\tfs.StringVar(&buildArgs.webClientRoot, \"web-client-root\", \"\", \"path to root of web client source to build\")\n+\t\t\t\t\tfs.StringVar(&buildArgs.outPath, \"out\", \"\", \"path to write output artifacts (defaults to '$PWD/dist' if not set)\")\n \t\t\t\t\treturn fs\n \t\t\t\t})(),\n \t\t\t\tLongHelp: strings.TrimSpace(`\n@@ -156,6 +157,7 @@ var buildArgs struct {\n \tmanifest      string\n \tverbose       bool\n \twebClientRoot string\n+\toutPath       string\n }\n \n func runBuild(ctx context.Context, filters []string, targets []dist.Target) error {\n@@ -172,7 +174,11 @@ func runBuild(ctx context.Context, filters []string, targets []dist.Target) erro\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting working directory: %w\", err)\n \t}\n-\tb, err := dist.NewBuild(wd, filepath.Join(wd, \"dist\"))\n+\toutPath := filepath.Join(wd, \"dist\")\n+\tif buildArgs.outPath != \"\" {\n+\t\toutPath = buildArgs.outPath\n+\t}\n+\tb, err := dist.NewBuild(wd, outPath)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"creating build context: %w\", err)\n \t}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps Alpine 3.18 -> 3.19.\r\n\r\nAlpine 3.19 links iptables to nftables-based implementation that can break hosts that don't support nftables.\r\nThis PR links iptables back to the legacy implementation till we have some certainty that changing to\r\nnftables based implementation will not break existing setups.\r\n\r\nOnce this merges, I will build the new base and bump the version in the build script\r\nhttps://github.com/tailscale/tailscale/blob/4777cc2cda59b9ad5b987513c8d955c5a5977eb0/build_docker.sh#L19\r\n\r\nI'll follow up with some client metric that attempts to track the hosts that don't support nftables.\r\n\r\nI have tested this with both iptables and nftables based implementations.\r\n\r\n```\r\n$ docker run -it tailscale/alpine-base:3.18 iptables --version\r\niptables v1.8.9 (legacy)\r\n$ docker run -it tailscale/alpine-base:3.18 ip6tables --version\r\nip6tables v1.8.9 (legacy)\r\n$ docker run -it europe-west2-docker.pkg.dev/tailscale-sandbox/irbe-images/base:alpbump0.0.1 iptables --version\r\niptables v1.8.10 (legacy)\r\n$ docker run -it europe-west2-docker.pkg.dev/tailscale-sandbox/irbe-images/base:alpbump0.0.1 ip6tables --version\r\nip6tables v1.8.10 (legacy)\r\n```\r\n\r\nNote that the latest Alpine version is 3.21, but I don't want to make such a large bump now.\r\n\r\nOther changes in the 3.19 release notes look harmless https://www.alpinelinux.org/posts/Alpine-3.19.0-released.html\r\n\r\nUpdates tailscale/tailscale#15328\n\n---\n\nChoice A:\nnet/dns/debian_resolvconf.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || freebsd || openbsd\n+//go:build (linux && !android) || freebsd || openbsd\n \n package dns\n \n---\nnet/dns/direct.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build !android && !ios\n+\n package dns\n \n import (\n---\nnet/dns/direct_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build linux && !android\n+\n package dns\n \n import (\n---\nnet/dns/direct_notlinux.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux\n+//go:build !linux && !android && !ios\n \n package dns\n \n---\nnet/dns/manager_default.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build !linux && !freebsd && !openbsd && !windows && !darwin && !illumos && !solaris && !plan9\n+//go:build (!linux || android) && !freebsd && !openbsd && !windows && !darwin && !illumos && !solaris && !plan9\n \n package dns\n \n---\nnet/dns/manager_linux.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build linux && !android\n+\n package dns\n \n import (\n---\nnet/dns/nm.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package dns\n \n---\nnet/dns/openresolv.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux || freebsd || openbsd\n+//go:build (linux && !android) || freebsd || openbsd\n \n package dns\n \n---\nnet/dns/resolved.go\n@@ -1,7 +1,7 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-//go:build linux\n+//go:build linux && !android\n \n package dns\n \n---\ntsnet/depaware.txt\n@@ -103,7 +103,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         github.com/go-json-experiment/json/jsontext                  from github.com/go-json-experiment/json+\n    W \ud83d\udca3 github.com/go-ole/go-ole                                     from github.com/go-ole/go-ole/oleutil+\n    W \ud83d\udca3 github.com/go-ole/go-ole/oleutil                             from tailscale.com/wgengine/winnet\n-  LA \ud83d\udca3 github.com/godbus/dbus/v5                                    from tailscale.com/net/dns\n+   L \ud83d\udca3 github.com/godbus/dbus/v5                                    from tailscale.com/net/dns\n         github.com/golang/groupcache/lru                             from tailscale.com/net/dnscache\n         github.com/google/btree                                      from gvisor.dev/gvisor/pkg/tcpip/header+\n    L    github.com/google/nftables                                   from tailscale.com/util/linuxfw\n@@ -116,8 +116,8 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n  LDW    github.com/gorilla/csrf                                      from tailscale.com/client/web\n  LDW    github.com/gorilla/securecookie                              from github.com/gorilla/csrf\n         github.com/hdevalence/ed25519consensus                       from tailscale.com/clientupdate/distsign+\n-  LA \ud83d\udca3 github.com/illarion/gonotify/v3                              from tailscale.com/net/dns\n-  LA    github.com/illarion/gonotify/v3/syscallf                     from github.com/illarion/gonotify/v3\n+   L \ud83d\udca3 github.com/illarion/gonotify/v3                              from tailscale.com/net/dns\n+   L    github.com/illarion/gonotify/v3/syscallf                     from github.com/illarion/gonotify/v3\n    L    github.com/jmespath/go-jmespath                              from github.com/aws/aws-sdk-go-v2/service/ssm\n    L \ud83d\udca3 github.com/jsimonetti/rtnetlink                              from tailscale.com/net/netmon\n    L    github.com/jsimonetti/rtnetlink/internal/unix                from github.com/jsimonetti/rtnetlink\n---\n\n\n---\n\nChoice B:\nbuild_dist.sh\n@@ -28,18 +28,26 @@ EOF\n \texit 0\n fi\n \n-tags=\"\"\n+tags=\"${TAGS:-}\"\n ldflags=\"-X tailscale.com/version.longStamp=${VERSION_LONG} -X tailscale.com/version.shortStamp=${VERSION_SHORT}\"\n \n # build_dist.sh arguments must precede go build arguments.\n while [ \"$#\" -gt 1 ]; do\n \tcase \"$1\" in\n \t--extra-small)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --extra-small or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\tldflags=\"$ldflags -w -s\"\n \t\ttags=\"${tags:+$tags,}ts_omit_aws,ts_omit_bird,ts_omit_tap,ts_omit_kube,ts_omit_completion,ts_omit_ssh,ts_omit_wakeonlan,ts_omit_capture\"\n \t\t;;\n \t--box)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --box or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\ttags=\"${tags:+$tags,}ts_include_cli\"\n \t\t;;\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local.go\n@@ -1463,15 +1463,30 @@ func (b *LocalBackend) PeerCaps(src netip.Addr) tailcfg.PeerCapMap {\n \treturn b.currentNode().PeerCaps(src)\n }\n \n+// AppendMatchingPeers returns base with all peers that match pred appended.\n+//\n+// It acquires b.mu to read the netmap but releases it before calling pred.\n func (b *localNodeContext) AppendMatchingPeers(base []tailcfg.NodeView, pred func(tailcfg.NodeView) bool) []tailcfg.NodeView {\n+\tvar peers []tailcfg.NodeView\n+\n \tb.mu.Lock()\n-\tdefer b.mu.Unlock()\n-\tret := base\n-\tif b.netMap == nil {\n-\t\treturn ret\n+\tif b.netMap != nil {\n+\t\t// All fields on b.netMap are immutable, so this is\n+\t\t// safe to copy and use outside the lock.\n+\t\tpeers = b.netMap.Peers\n \t}\n-\tfor _, peer := range b.netMap.Peers {\n-\t\tif pred(peer) {\n+\tb.mu.Unlock()\n+\n+\tret := base\n+\tfor _, peer := range peers {\n+\t\t// The peers in b.netMap don't contain updates made via\n+\t\t// UpdateNetmapDelta. So only use PeerView in b.netMap for its NodeID,\n+\t\t// and then look up the latest copy in b.peers which is updated in\n+\t\t// response to UpdateNetmapDelta edits.\n+\t\tb.mu.Lock()\n+\t\tpeer, ok := b.peers[peer.ID()]\n+\t\tb.mu.Unlock()\n+\t\tif ok && pred(peer) {\n \t\t\tret = append(ret, peer)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice D:\nALPINE.txt\n@@ -1 +1 @@\n-3.18\n\\ No newline at end of file\n+3.19\n\\ No newline at end of file\n---\nDockerfile\n@@ -62,8 +62,10 @@ RUN GOARCH=$TARGETARCH go install -ldflags=\"\\\n       -X tailscale.com/version.gitCommitStamp=$VERSION_GIT_HASH\" \\\n       -v ./cmd/tailscale ./cmd/tailscaled ./cmd/containerboot\n \n-FROM alpine:3.18\n+FROM alpine:3.19\n RUN apk add --no-cache ca-certificates iptables iproute2 ip6tables\n+RUN rm /sbin/iptables && ln -s /sbin/iptables-legacy /sbin/iptables\n+RUN rm /sbin/ip6tables && ln -s /sbin/ip6tables-legacy /sbin/ip6tables\n \n COPY --from=build-env /go/bin/* /usr/local/bin/\n # For compat with the previous run.sh, although ideally you should be\n---\nDockerfile.base\n@@ -1,5 +1,12 @@\n # Copyright (c) Tailscale Inc & AUTHORS\n # SPDX-License-Identifier: BSD-3-Clause\n \n-FROM alpine:3.18\n-RUN apk add --no-cache ca-certificates iptables iproute2 ip6tables iputils\n+FROM alpine:3.19\n+RUN apk add --no-cache ca-certificates iptables iptables-legacy iproute2 ip6tables iputils\n+# Alpine 3.19 replaces legacy iptables with nftables based implementation.  We\n+# can't be certain that all hosts that run Tailscale containers currently\n+# suppport nftables, so link back to legacy for backwards compatibility reasons.\n+# TODO(irbekrm): add some way how to determine if we still run on nodes that\n+# don't support nftables, so that we can eventually remove these symlinks.\n+RUN rm /sbin/iptables && ln -s /sbin/iptables-legacy /sbin/iptables\n+RUN rm /sbin/ip6tables && ln -s /sbin/ip6tables-legacy /sbin/ip6tables\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nMinimal mitigation that doesn't do the full refactor that's probably\nwarranted.\n\nUpdates #15402\n\n\n---\n\nChoice A:\nutil/testenv/testenv.go\n@@ -6,6 +6,7 @@\n package testenv\n \n import (\n+\t\"context\"\n \t\"flag\"\n \n \t\"tailscale.com/types/lazy\"\n@@ -19,3 +20,41 @@ func InTest() bool {\n \t\treturn flag.Lookup(\"test.v\") != nil\n \t})\n }\n+\n+// TB is testing.TB, to avoid importing \"testing\" in non-test code.\n+type TB interface {\n+\tCleanup(func())\n+\tError(args ...any)\n+\tErrorf(format string, args ...any)\n+\tFail()\n+\tFailNow()\n+\tFailed() bool\n+\tFatal(args ...any)\n+\tFatalf(format string, args ...any)\n+\tHelper()\n+\tLog(args ...any)\n+\tLogf(format string, args ...any)\n+\tName() string\n+\tSetenv(key, value string)\n+\tChdir(dir string)\n+\tSkip(args ...any)\n+\tSkipNow()\n+\tSkipf(format string, args ...any)\n+\tSkipped() bool\n+\tTempDir() string\n+\tContext() context.Context\n+}\n+\n+// InParallelTest reports whether t is running as a parallel test.\n+//\n+// Use of this function taints t such that its Parallel method (assuming t is an\n+// actual *testing.T) will panic if called after this function.\n+func InParallelTest(t TB) (isParallel bool) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tisParallel = true\n+\t\t}\n+\t}()\n+\tt.Chdir(\".\") // panics in a t.Parallel test\n+\treturn false\n+}\n---\nutil/testenv/testenv_test.go\n@@ -16,3 +16,16 @@ func TestDeps(t *testing.T) {\n \t\t},\n \t}.Check(t)\n }\n+\n+func TestInParallelTestTrue(t *testing.T) {\n+\tt.Parallel()\n+\tif !InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return true once t.Parallel has been called\")\n+\t}\n+}\n+\n+func TestInParallelTestFalse(t *testing.T) {\n+\tif InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return false before t.Parallel has been called\")\n+\t}\n+}\n---\n\n\n---\n\nChoice B:\ntsnet/tsnet.go\n@@ -1101,13 +1101,33 @@ type FunnelOption interface {\n \tfunnelOption()\n }\n \n-type funnelOnly int\n+type funnelOnly struct{}\n \n func (funnelOnly) funnelOption() {}\n \n // FunnelOnly configures the listener to only respond to connections from Tailscale Funnel.\n // The local tailnet will not be able to connect to the listener.\n-func FunnelOnly() FunnelOption { return funnelOnly(1) }\n+func FunnelOnly() FunnelOption { return funnelOnly{} }\n+\n+type funnelTLSConfig struct{ conf *tls.Config }\n+\n+func (f funnelTLSConfig) funnelOption() {}\n+\n+// FunnelTLSConfig configures the TLS configuration for [Server.ListenFunnel]\n+//\n+// This is rarely needed but can permit requiring client certificates, specific\n+// ciphers suites, etc.\n+//\n+// The provided conf should at least be able to get a certificate, setting\n+// GetCertificate, Certificates or GetConfigForClient appropriately.\n+// The most common configuration is to set GetCertificate to\n+// Server.LocalClient's GetCertificate method.\n+//\n+// Unless [FunnelOnly] is also used, the configuration is also used for\n+// in-tailnet connections that don't arrive over Funnel.\n+func FunnelTLSConfig(conf *tls.Config) FunnelOption {\n+\treturn funnelTLSConfig{conf: conf}\n+}\n \n // ListenFunnel announces on the public internet using Tailscale Funnel.\n //\n@@ -1140,6 +1160,26 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t\treturn nil, err\n \t}\n \n+\t// Process, validate opts.\n+\tlnOn := listenOnBoth\n+\tvar tlsConfig *tls.Config\n+\tfor _, opt := range opts {\n+\t\tswitch v := opt.(type) {\n+\t\tcase funnelTLSConfig:\n+\t\t\tif v.conf == nil {\n+\t\t\t\treturn nil, errors.New(\"invalid nil FunnelTLSConfig\")\n+\t\t\t}\n+\t\t\ttlsConfig = v.conf\n+\t\tcase funnelOnly:\n+\t\t\tlnOn = listenOnFunnel\n+\t\tdefault:\n+\t\t\treturn nil, fmt.Errorf(\"unknown opts FunnelOption type %T\", v)\n+\t\t}\n+\t}\n+\tif tlsConfig == nil {\n+\t\ttlsConfig = &tls.Config{GetCertificate: s.getCert}\n+\t}\n+\n \tctx := context.Background()\n \tst, err := s.Up(ctx)\n \tif err != nil {\n@@ -1177,19 +1217,11 @@ func (s *Server) ListenFunnel(network, addr string, opts ...FunnelOption) (net.L\n \t}\n \n \t// Start a funnel listener.\n-\tlnOn := listenOnBoth\n-\tfor _, opt := range opts {\n-\t\tif _, ok := opt.(funnelOnly); ok {\n-\t\t\tlnOn = listenOnFunnel\n-\t\t}\n-\t}\n \tln, err := s.listen(network, addr, lnOn)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn tls.NewListener(ln, &tls.Config{\n-\t\tGetCertificate: s.getCert,\n-\t}), nil\n+\treturn tls.NewListener(ln, tlsConfig), nil\n }\n \n type listenOn string\n---\n\n\n---\n\nChoice C:\ncontrol/controlhttp/client.go\n@@ -96,6 +96,9 @@ func (a *Dialer) httpsFallbackDelay() time.Duration {\n var _ = envknob.RegisterBool(\"TS_USE_CONTROL_DIAL_PLAN\") // to record at init time whether it's in use\n \n func (a *Dialer) dial(ctx context.Context) (*ClientConn, error) {\n+\n+\ta.logPort80Failure.Store(true)\n+\n \t// If we don't have a dial plan, just fall back to dialing the single\n \t// host we know about.\n \tuseDialPlan := envknob.BoolDefaultTrue(\"TS_USE_CONTROL_DIAL_PLAN\")\n@@ -278,7 +281,9 @@ func (d *Dialer) forceNoise443() bool {\n \t\t// This heuristic works around networks where port 80 is MITMed and\n \t\t// appears to work for a bit post-Upgrade but then gets closed,\n \t\t// such as seen in https://github.com/tailscale/tailscale/issues/13597.\n-\t\td.logf(\"controlhttp: forcing port 443 dial due to recent noise dial\")\n+\t\tif d.logPort80Failure.CompareAndSwap(true, false) {\n+\t\t\td.logf(\"controlhttp: forcing port 443 dial due to recent noise dial\")\n+\t\t}\n \t\treturn true\n \t}\n \n---\ncontrol/controlhttp/constants.go\n@@ -6,6 +6,7 @@ package controlhttp\n import (\n \t\"net/http\"\n \t\"net/url\"\n+\t\"sync/atomic\"\n \t\"time\"\n \n \t\"tailscale.com/health\"\n@@ -90,6 +91,11 @@ type Dialer struct {\n \n \tproxyFunc func(*http.Request) (*url.URL, error) // or nil\n \n+\t// logPort80Failure is whether we should log about port 80 interceptions\n+\t// and forcing a port 443 dial. We do this only once per \"dial\" method\n+\t// which can result in many concurrent racing dialHost calls.\n+\tlogPort80Failure atomic.Bool\n+\n \t// For tests only\n \tdrainFinished        chan struct{}\n \tomitCertErrorLogging bool\n---\n\n\n---\n\nChoice D:\nlogpolicy/logpolicy.go\n@@ -518,8 +518,9 @@ type Options struct {\n \tMaxUploadSize int\n }\n \n-// New returns a new log policy (a logger and its instance ID).\n-func (opts Options) New() *Policy {\n+// init initializes the log policy and returns a logtail.Config and the\n+// Policy.\n+func (opts Options) init(disableLogging bool) (*logtail.Config, *Policy) {\n \tif hostinfo.IsNATLabGuestVM() {\n \t\t// In NATLab Gokrazy instances, tailscaled comes up concurently with\n \t\t// DHCP and the doesn't have DNS for a while. Wait for DHCP first.\n@@ -628,7 +629,7 @@ func (opts Options) New() *Policy {\n \t\tconf.IncludeProcSequence = true\n \t}\n \n-\tif envknob.NoLogsNoSupport() || testenv.InTest() || runtime.GOOS == \"plan9\" {\n+\tif disableLogging {\n \t\topts.Logf(\"You have disabled logging. Tailscale will not be able to provide support.\")\n \t\tconf.HTTPC = &http.Client{Transport: noopPretendSuccessTransport{}}\n \t} else {\n@@ -637,14 +638,15 @@ func (opts Options) New() *Policy {\n \t\tattachFilchBuffer(&conf, opts.Dir, opts.CmdName, opts.MaxBufferSize, opts.Logf)\n \t\tconf.HTTPC = opts.HTTPC\n \n+\t\tlogHost := logtail.DefaultHost\n+\t\tif val := getLogTarget(); val != \"\" {\n+\t\t\topts.Logf(\"You have enabled a non-default log target. Doing without being told to by Tailscale staff or your network administrator will make getting support difficult.\")\n+\t\t\tconf.BaseURL = val\n+\t\t\tu, _ := url.Parse(val)\n+\t\t\tlogHost = u.Host\n+\t\t}\n+\n \t\tif conf.HTTPC == nil {\n-\t\t\tlogHost := logtail.DefaultHost\n-\t\t\tif val := getLogTarget(); val != \"\" {\n-\t\t\t\topts.Logf(\"You have enabled a non-default log target. Doing without being told to by Tailscale staff or your network administrator will make getting support difficult.\")\n-\t\t\t\tconf.BaseURL = val\n-\t\t\t\tu, _ := url.Parse(val)\n-\t\t\t\tlogHost = u.Host\n-\t\t\t}\n \t\t\tconf.HTTPC = &http.Client{Transport: TransportOptions{\n \t\t\t\tHost:   logHost,\n \t\t\t\tNetMon: opts.NetMon,\n@@ -680,13 +682,20 @@ func (opts Options) New() *Policy {\n \t\topts.Logf(\"%s\", earlyErrBuf.Bytes())\n \t}\n \n-\treturn &Policy{\n+\treturn &conf, &Policy{\n \t\tLogtail:  lw,\n \t\tPublicID: newc.PublicID,\n \t\tLogf:     opts.Logf,\n \t}\n }\n \n+// New returns a new log policy (a logger and its instance ID).\n+func (opts Options) New() *Policy {\n+\tdisableLogging := envknob.NoLogsNoSupport() || testenv.InTest() || runtime.GOOS == \"plan9\"\n+\t_, policy := opts.init(disableLogging)\n+\treturn policy\n+}\n+\n // attachFilchBuffer creates an on-disk ring buffer using filch and attaches\n // it to the logtail config. Note that this is optional; if no buffer is set,\n // logtail will use an in-memory buffer.\n---\nlogpolicy/logpolicy_test.go\n@@ -4,19 +4,22 @@\n package logpolicy\n \n import (\n+\t\"net/http\"\n \t\"os\"\n \t\"reflect\"\n \t\"testing\"\n \n \t\"tailscale.com/logtail\"\n )\n \n-func TestLogHost(t *testing.T) {\n+func resetLogTarget() {\n+\tos.Unsetenv(\"TS_LOG_TARGET\")\n \tv := reflect.ValueOf(&getLogTargetOnce).Elem()\n-\treset := func() {\n-\t\tv.Set(reflect.Zero(v.Type()))\n-\t}\n-\tdefer reset()\n+\tv.Set(reflect.Zero(v.Type()))\n+}\n+\n+func TestLogHost(t *testing.T) {\n+\tdefer resetLogTarget()\n \n \ttests := []struct {\n \t\tenv  string\n@@ -29,10 +32,55 @@ func TestLogHost(t *testing.T) {\n \t\t{\"https://foo.com:123/\", \"foo.com\"},\n \t}\n \tfor _, tt := range tests {\n-\t\treset()\n+\t\tresetLogTarget()\n \t\tos.Setenv(\"TS_LOG_TARGET\", tt.env)\n \t\tif got := LogHost(); got != tt.want {\n \t\t\tt.Errorf(\"for env %q, got %q, want %q\", tt.env, got, tt.want)\n \t\t}\n \t}\n }\n+func TestOptions(t *testing.T) {\n+\tdefer resetLogTarget()\n+\n+\ttests := []struct {\n+\t\tname        string\n+\t\topts        func() Options\n+\t\twantBaseURL string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"default\",\n+\t\t\topts:        func() Options { return Options{} },\n+\t\t\twantBaseURL: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom_baseurl\",\n+\t\t\topts: func() Options {\n+\t\t\t\tos.Setenv(\"TS_LOG_TARGET\", \"http://localhost:1234\")\n+\t\t\t\treturn Options{}\n+\t\t\t},\n+\t\t\twantBaseURL: \"http://localhost:1234\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom_httpc_and_baseurl\",\n+\t\t\topts: func() Options {\n+\t\t\t\tos.Setenv(\"TS_LOG_TARGET\", \"http://localhost:12345\")\n+\t\t\t\treturn Options{HTTPC: &http.Client{Transport: noopPretendSuccessTransport{}}}\n+\t\t\t},\n+\t\t\twantBaseURL: \"http://localhost:12345\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresetLogTarget()\n+\t\t\tconfig, policy := tt.opts().init(false)\n+\t\t\tif policy == nil {\n+\t\t\t\tt.Fatal(\"unexpected nil policy\")\n+\t\t\t}\n+\t\t\tif config.BaseURL != tt.wantBaseURL {\n+\t\t\t\tt.Errorf(\"got %q, want %q\", config.BaseURL, tt.wantBaseURL)\n+\t\t\t}\n+\t\t\tpolicy.Close()\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nOn Windows and Android, peerAPIListeners may be initialized after a link change. This commit adds log statements to make it easier to trace this flow.\r\n\r\nUpdates #14393\n\n---\n\nChoice A:\nfeature/taildrop/integration_test.go\n@@ -26,6 +26,21 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n+\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n+\ttestTaildropIntegration(t, false)\n+}\n+\n+func TestTaildropIntegration_Fresh(t *testing.T) {\n+\ttestTaildropIntegration(t, true)\n+}\n+\n+// freshProfiles is whether to start the test right away\n+// with a fresh profile. If false, tailscaled is started, stopped,\n+// and restarted again to simulate a real-world scenario where\n+// the first profile already existed.\n+//\n+// This exercises an ipnext hook ordering issue we hit earlier.\n+func testTaildropIntegration(t *testing.T, freshProfiles bool) {\n \ttstest.Parallel(t)\n \tcontrolOpt := integration.ConfigureControl(func(s *testcontrol.Server) {\n \t\ts.AllNodesSameUser = true // required for Taildrop\n@@ -39,18 +54,30 @@ func TestTaildropIntegration(t *testing.T) {\n \tn2 := integration.NewTestNode(t, env)\n \td2 := n2.StartDaemon()\n \n-\tn1.AwaitListening()\n-\tt.Logf(\"n1 is listening\")\n-\tn2.AwaitListening()\n-\tt.Logf(\"n2 is listening\")\n-\tn1.MustUp()\n-\tt.Logf(\"n1 is up\")\n-\tn2.MustUp()\n-\tt.Logf(\"n2 is up\")\n-\tn1.AwaitRunning()\n-\tt.Logf(\"n1 is running\")\n-\tn2.AwaitRunning()\n-\tt.Logf(\"n2 is running\")\n+\tawaitUp := func() {\n+\t\tt.Helper()\n+\t\tn1.AwaitListening()\n+\t\tt.Logf(\"n1 is listening\")\n+\t\tn2.AwaitListening()\n+\t\tt.Logf(\"n2 is listening\")\n+\t\tn1.MustUp()\n+\t\tt.Logf(\"n1 is up\")\n+\t\tn2.MustUp()\n+\t\tt.Logf(\"n2 is up\")\n+\t\tn1.AwaitRunning()\n+\t\tt.Logf(\"n1 is running\")\n+\t\tn2.AwaitRunning()\n+\t\tt.Logf(\"n2 is running\")\n+\t}\n+\tawaitUp()\n+\n+\tif !freshProfiles {\n+\t\td1.MustCleanShutdown(t)\n+\t\td2.MustCleanShutdown(t)\n+\t\td1 = n1.StartDaemon()\n+\t\td2 = n2.StartDaemon()\n+\t\tawaitUp()\n+\t}\n \n \tvar peerStableID tailcfg.StableNodeID\n \n---\n\n\n---\n\nChoice B:\nwgengine/netstack/netstack.go\n@@ -327,10 +327,15 @@ func Create(logf logger.Logf, tundev *tstun.Wrapper, e wgengine.Engine, mc *magi\n \tif tcpipErr != nil {\n \t\treturn nil, fmt.Errorf(\"could not disable TCP RACK: %v\", tcpipErr)\n \t}\n-\tcubicOpt := tcpip.CongestionControlOption(\"cubic\")\n-\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &cubicOpt)\n+\t// gVisor defaults to reno at the time of writing. We explicitly set reno\n+\t// congestion control in order to prevent unexpected changes. Netstack\n+\t// has an int overflow in sender congestion window arithmetic that is more\n+\t// prone to trigger with cubic congestion control.\n+\t// See https://github.com/google/gvisor/issues/11632\n+\trenoOpt := tcpip.CongestionControlOption(\"reno\")\n+\ttcpipErr = ipstack.SetTransportProtocolOption(tcp.ProtocolNumber, &renoOpt)\n \tif tcpipErr != nil {\n-\t\treturn nil, fmt.Errorf(\"could not set cubic congestion control: %v\", tcpipErr)\n+\t\treturn nil, fmt.Errorf(\"could not set reno congestion control: %v\", tcpipErr)\n \t}\n \terr := setTCPBufSizes(ipstack)\n \tif err != nil {\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/local.go\n@@ -958,7 +958,9 @@ func (b *LocalBackend) linkChange(delta *netmon.ChangeDelta) {\n \n \tif peerAPIListenAsync && b.netMap != nil && b.state == ipn.Running {\n \t\twant := b.netMap.GetAddresses().Len()\n-\t\tif len(b.peerAPIListeners) < want {\n+\t\thave := len(b.peerAPIListeners)\n+\t\tb.logf(\"[v1] linkChange: have %d peerAPIListeners, want %d\", have, want)\n+\t\tif have < want {\n \t\t\tb.logf(\"linkChange: peerAPIListeners too low; trying again\")\n \t\t\tb.goTracker.Go(b.initPeerAPIListener)\n \t\t}\n@@ -5369,6 +5371,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n+\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\nChoice D:\ndocs/windows/policy/en-US/tailscale.adml\n@@ -16,6 +16,7 @@\n             <string id=\"SINCE_V1_62\">Tailscale version 1.62.0 and later</string>\n             <string id=\"SINCE_V1_74\">Tailscale version 1.74.0 and later</string>\n             <string id=\"SINCE_V1_78\">Tailscale version 1.78.0 and later</string>\n+            <string id=\"SINCE_V1_80\">Tailscale version 1.80.0 and later</string>\n             <string id=\"SINCE_V1_82\">Tailscale version 1.82.0 and later</string>\n             <string id=\"SINCE_V1_84\">Tailscale version 1.84.0 and later</string>\n             <string id=\"Tailscale_Category\">Tailscale</string>\n@@ -271,6 +272,12 @@ If you enable this policy, the menu item will be displayed indicating the organi\n If you disable this policy or do not configure it, the corresponding menu item will be hidden.\n \n See https://tailscale.com/kb/1315/mdm-keys#set-your-organization-name for more details.]]></string>\n+            <string id=\"OnboardingFlow\">Show the onboarding flow</string>\n+            <string id=\"OnboardingFlow_Help\"><![CDATA[This policy can be used to show or hide the onboarding flow displayed by the GUI.\n+\n+If you enable or don't configure this policy, the onboarding flow will be shown to new users who have not yet signed in to a Tailscale account.\n+\n+If you disable this policy, the onboarding flow will never be shown.]]></string>\n         </stringTable>\n         <presentationTable>\n             <presentation id=\"LoginURL\">\n---\ndocs/windows/policy/tailscale.admx\n@@ -54,6 +54,10 @@\n                   displayName=\"$(string.SINCE_V1_78)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n       </definition>\n+      <definition name=\"SINCE_V1_80\"\n+                  displayName=\"$(string.SINCE_V1_80)\">\n+        <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n+      </definition>\n       <definition name=\"SINCE_V1_82\"\n                   displayName=\"$(string.SINCE_V1_82)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n@@ -335,6 +339,16 @@\n         <string>hide</string>\n       </disabledValue>\n     </policy>\n+    <policy name=\"OnboardingFlow\" class=\"Both\" displayName=\"$(string.OnboardingFlow)\" explainText=\"$(string.OnboardingFlow_Help)\" key=\"Software\\Policies\\Tailscale\" valueName=\"OnboardingFlow\">\n+      <parentCategory ref=\"UI_Category\" />\n+      <supportedOn ref=\"SINCE_V1_80\" />\n+      <enabledValue>\n+        <string>show</string>\n+      </enabledValue>\n+      <disabledValue>\n+        <string>hide</string>\n+      </disabledValue>\n+    </policy>\n     <policy name=\"ManagedBy\" class=\"Both\" displayName=\"$(string.ManagedBy)\" explainText=\"$(string.ManagedBy_Help)\" presentation=\"$(presentation.ManagedBy)\" key=\"Software\\Policies\\Tailscale\">\n       <parentCategory ref=\"UI_Category\" />\n       <supportedOn ref=\"SINCE_V1_62\" />\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nfixes tailscale/tailscale#15394\r\n\r\nIn the current iteration, usage of the memstore for the audit logger is expected on some platforms.\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -2404,11 +2404,9 @@ func (b *LocalBackend) Start(opts ipn.Options) error {\n \t}\n \n \tvar auditLogShutdown func()\n-\t// Audit logging is only available if the client has set up a proper persistent\n-\t// store for the logs in sys.\n \tstore, ok := b.sys.AuditLogStore.GetOK()\n \tif !ok {\n-\t\tb.logf(\"auditlog: [unexpected] no persistent audit log storage configured.  using memory store.\")\n+\t\t// Use memory store by default if no explicit store is provided.\n \t\tstore = auditlog.NewLogStore(&memstore.Store{})\n \t}\n \n---\n\n\n---\n\nChoice B:\nwgengine/magicsock/magicsock_linux.go\n@@ -66,10 +66,10 @@ var (\n \t\t// fragmented, and we don't want to handle reassembly.\n \t\tbpf.LoadAbsolute{Off: 6, Size: 2},\n \t\t// More Fragments bit set means this is part of a fragmented packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 7, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 8, SkipFalse: 0},\n \t\t// Non-zero fragment offset with MF=0 means this is the last\n \t\t// fragment of packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 6, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 7, SkipFalse: 0},\n \n \t\t// Load IP header length into X register.\n \t\tbpf.LoadMemShift{Off: 0},\n---\nwgengine/magicsock/magicsock_linux_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"net/netip\"\n \t\"testing\"\n \n+\t\"golang.org/x/net/bpf\"\n \t\"golang.org/x/sys/cpu\"\n \t\"golang.org/x/sys/unix\"\n \t\"tailscale.com/disco\"\n@@ -146,3 +147,78 @@ func TestEthernetProto(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestBpfDiscardV4(t *testing.T) {\n+\t// Good packet as a reference for what should not be rejected\n+\tudp4Packet := []byte{\n+\t\t// IPv4 header\n+\t\t0x45, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x40, 0x11, 0x00, 0x00,\n+\t\t0x7f, 0x00, 0x00, 0x01, // source ip\n+\t\t0x7f, 0x00, 0x00, 0x02, // dest ip\n+\n+\t\t// UDP header\n+\t\t0x30, 0x39, // src port\n+\t\t0xd4, 0x31, // dest port\n+\t\t0x00, 0x12, // length; 8 bytes header + 10 bytes payload = 18 bytes\n+\t\t0x00, 0x00, // checksum; unused\n+\n+\t\t// Payload: disco magic plus 32 bytes for key and 24 bytes for nonce\n+\t\t0x54, 0x53, 0xf0, 0x9f, 0x92, 0xac, 0x00, 0x01, 0x02, 0x03,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n+\t}\n+\n+\tvm, err := bpf.NewVM(magicsockFilterV4)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed creating BPF VM: %v\", err)\n+\t}\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\treplace map[int]byte\n+\t\taccept  bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"base accepted datagram\",\n+\t\t\treplace: map[int]byte{},\n+\t\t\taccept:  true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"more fragments\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t6: 0x20,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some fragment\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t7: 0x01,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t}\n+\n+\tudp4PacketChanged := make([]byte, len(udp4Packet))\n+\tcopy(udp4PacketChanged, udp4Packet)\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfor k, v := range tt.replace {\n+\t\t\t\tudp4PacketChanged[k] = v\n+\t\t\t}\n+\t\t\tret, err := vm.Run(udp4PacketChanged)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"BPF VM error: %v\", err)\n+\t\t\t}\n+\n+\t\t\tif (ret != 0) != tt.accept {\n+\t\t\t\tt.Errorf(\"expected accept=%v, got ret=%v\", tt.accept, ret)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\ncmd/tailscale/cli/file.go\n@@ -15,8 +15,10 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"os\"\n+\t\"os/user\"\n \t\"path\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"sync/atomic\"\n \t\"time\"\n@@ -452,6 +454,7 @@ var fileGetCmd = &ffcli.Command{\n \toverwrite:  overwrite existing file\n \trename:     write to a new number-suffixed filename`)\n \t\tffcomplete.Flag(fs, \"conflict\", ffcomplete.Fixed(\"skip\", \"overwrite\", \"rename\"))\n+\t\tfs.StringVar(&getArgs.chown, \"chown\", \"\", \"sets owner:group for received files\")\n \t\treturn fs\n \t})(),\n }\n@@ -461,6 +464,7 @@ var getArgs = struct {\n \tloop     bool\n \tverbose  bool\n \tconflict onConflict\n+\tchown    string\n }{conflict: skipOnExist}\n \n func numberedFileName(dir, name string, i int) string {\n@@ -512,7 +516,7 @@ func openFileOrSubstitute(dir, base string, action onConflict) (*os.File, error)\n \t}\n }\n \n-func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targetFile string, size int64, err error) {\n+func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string, chown string) (targetFile string, size int64, err error) {\n \trc, size, err := localClient.GetWaitingFile(ctx, wf.Name)\n \tif err != nil {\n \t\treturn \"\", 0, fmt.Errorf(\"opening inbox file %q: %w\", wf.Name, err)\n@@ -531,10 +535,51 @@ func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targe\n \t\tf.Close()\n \t\treturn \"\", 0, fmt.Errorf(\"failed to write %v: %v\", f.Name(), err)\n \t}\n+\tif chown != \"\" {\n+\t\tusr, grp, _ := strings.Cut(chown, \":\")\n+\n+\t\t// Set default values to allow for partial changes (e.g. `user` or `:staff`)\n+\t\tuid, gid, err := fileStat(f)\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to stat file: %v\", err)\n+\t\t}\n+\n+\t\tif usr != \"\" {\n+\t\t\tif uid, err = strconv.Atoi(usr); err != nil {\n+\t\t\t\tuser, err := user.Lookup(usr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup user: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif uid, err = strconv.Atoi(user.Uid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert uid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif grp != \"\" {\n+\t\t\tif gid, err = strconv.Atoi(grp); err != nil {\n+\t\t\t\tgroup, err := user.LookupGroup(grp)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup group: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif gid, err = strconv.Atoi(group.Gid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert gid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif err := f.Chown(uid, gid); err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to chown file: %v\", err)\n+\t\t}\n+\t}\n \treturn f.Name(), size, f.Close()\n }\n \n-func runFileGetOneBatch(ctx context.Context, dir string) []error {\n+func runFileGetOneBatch(ctx context.Context, dir, chown string) []error {\n \tvar wfs []apitype.WaitingFile\n \tvar err error\n \tvar errs []error\n@@ -563,7 +608,7 @@ func runFileGetOneBatch(ctx context.Context, dir string) []error {\n \t\t\terrs = append(errs, fmt.Errorf(\"too many errors in runFileGetOneBatch(). %d files unexamined\", len(wfs)-i))\n \t\t\tbreak\n \t\t}\n-\t\twrittenFile, size, err := receiveFile(ctx, wf, dir)\n+\t\twrittenFile, size, err := receiveFile(ctx, wf, dir, chown)\n \t\tif err != nil {\n \t\t\terrs = append(errs, err)\n \t\t\tcontinue\n@@ -602,7 +647,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t}\n \tif getArgs.loop {\n \t\tfor {\n-\t\t\terrs := runFileGetOneBatch(ctx, dir)\n+\t\t\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \t\t\tfor _, err := range errs {\n \t\t\t\toutln(err)\n \t\t\t}\n@@ -621,7 +666,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t\t\t}\n \t\t}\n \t}\n-\terrs := runFileGetOneBatch(ctx, dir)\n+\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \tif len(errs) == 0 {\n \t\treturn nil\n \t}\n@@ -635,6 +680,9 @@ func wipeInbox(ctx context.Context) error {\n \tif getArgs.wait {\n \t\treturn errors.New(\"can't use --wait with /dev/null target\")\n \t}\n+\tif getArgs.chown != \"\" {\n+\t\treturn errors.New(\"can't use --chown with /dev/null target\")\n+\t}\n \twfs, err := localClient.WaitingFiles(ctx)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting WaitingFiles: %w\", err)\n---\ncmd/tailscale/cli/file_stub.go\n@@ -0,0 +1,16 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build windows || wasm || plan9 || tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(_f *os.File) (int, int, error) {\n+\treturn -1, -1, errors.New(\"Not implemented\")\n+}\n---\ncmd/tailscale/cli/file_unix.go\n@@ -0,0 +1,26 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build !windows && !wasm && !plan9 && !tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(f *os.File) (int, int, error) {\n+\tif f == nil {\n+\t\treturn -1, -1, errors.New(\"file cannot be nil\")\n+\t}\n+\n+\tvar stat syscall.Stat_t\n+\tif err := syscall.Stat(f.Name(), &stat); err != nil {\n+\t\treturn -1, -1, err\n+\t}\n+\n+\treturn int(stat.Uid), int(stat.Gid), nil\n+}\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -958,7 +958,9 @@ func (b *LocalBackend) linkChange(delta *netmon.ChangeDelta) {\n \n \tif peerAPIListenAsync && b.netMap != nil && b.state == ipn.Running {\n \t\twant := b.netMap.GetAddresses().Len()\n-\t\tif len(b.peerAPIListeners) < want {\n+\t\thave := len(b.peerAPIListeners)\n+\t\tb.logf(\"[v1] linkChange: have %d peerAPIListeners, want %d\", have, want)\n+\t\tif have < want {\n \t\t\tb.logf(\"linkChange: peerAPIListeners too low; trying again\")\n \t\t\tb.goTracker.Go(b.initPeerAPIListener)\n \t\t}\n@@ -5369,6 +5371,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n+\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis is to avoid issues where stale cache after Ingress recreation causes the certs not to be re-issued.\r\n\r\nWith this PR:\r\n- the kube nodes that don't run in cert-share mode (which is all nodes, except for the currently experimental HA Ingress backends) read from cache, write to the state Secret through cache (behaviour unchanged)\r\n- read replicas in cert-share mode attempt to read from cache, else look certs up in a Secret and refresh cache if found (unchanged)\r\n- write replicas in cert-share mode write to Secret only (changed behaviour).\r\n\r\nI have tested that with this change, the following workflow:\r\n1. An HA Ingress is created\r\n2. The Ingress gets deleted\r\n3. The Ingress is recreated again\r\n\r\nResults in TLS cert being issued at step 3 and stored in a Secret, so that when the replicas are next restarted there is no downtime due to missing certs.\r\n\r\nUpdates tailscale/corp#24795\n\n---\n\nChoice A:\nipn/desktop/mksyscall.go\n@@ -11,8 +11,6 @@ package desktop\n //sys registerClassEx(windowClass *_WNDCLASSEX) (atom uint16, err error) [atom==0] = user32.RegisterClassExW\n //sys createWindowEx(dwExStyle uint32, lpClassName *uint16, lpWindowName *uint16, dwStyle uint32, x int32, y int32, nWidth int32, nHeight int32, hWndParent windows.HWND, hMenu windows.Handle, hInstance windows.Handle, lpParam unsafe.Pointer) (hWnd windows.HWND, err error) [hWnd==0] = user32.CreateWindowExW\n //sys defWindowProc(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.DefWindowProcW\n-//sys setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) [res==0 && e1!=0] = user32.SetWindowLongPtrW\n-//sys getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) [res==0 && e1!=0] = user32.GetWindowLongPtrW\n //sys sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.SendMessageW\n //sys getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (ret int32) = user32.GetMessageW\n //sys translateMessage(lpMsg *_MSG) (res bool) = user32.TranslateMessage\n---\nipn/desktop/sessions_windows.go\n@@ -670,3 +670,38 @@ func (cs _WTS_CONNECTSTATE_CLASS) ToSessionStatus() SessionStatus {\n \t\treturn ClosedSession\n \t}\n }\n+\n+var (\n+\tprocGetWindowLongPtrW *windows.LazyProc\n+\tprocSetWindowLongPtrW *windows.LazyProc\n+)\n+\n+func init() {\n+\t// GetWindowLongPtrW and SetWindowLongPtrW are only available on 64-bit platforms.\n+\t// https://web.archive.org/web/20250414195520/https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw\n+\tif runtime.GOARCH == \"386\" || runtime.GOARCH == \"arm\" {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongW\")\n+\t} else {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongPtrW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongPtrW\")\n+\t}\n+}\n+\n+func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n---\nipn/desktop/zsyscall_windows.go\n@@ -48,11 +48,9 @@ var (\n \tprocDestroyWindow                      = moduser32.NewProc(\"DestroyWindow\")\n \tprocDispatchMessageW                   = moduser32.NewProc(\"DispatchMessageW\")\n \tprocGetMessageW                        = moduser32.NewProc(\"GetMessageW\")\n-\tprocGetWindowLongPtrW                  = moduser32.NewProc(\"GetWindowLongPtrW\")\n \tprocPostQuitMessage                    = moduser32.NewProc(\"PostQuitMessage\")\n \tprocRegisterClassExW                   = moduser32.NewProc(\"RegisterClassExW\")\n \tprocSendMessageW                       = moduser32.NewProc(\"SendMessageW\")\n-\tprocSetWindowLongPtrW                  = moduser32.NewProc(\"SetWindowLongPtrW\")\n \tprocTranslateMessage                   = moduser32.NewProc(\"TranslateMessage\")\n \tprocWTSRegisterSessionNotificationEx   = modwtsapi32.NewProc(\"WTSRegisterSessionNotificationEx\")\n \tprocWTSUnRegisterSessionNotificationEx = modwtsapi32.NewProc(\"WTSUnRegisterSessionNotificationEx\")\n@@ -98,15 +96,6 @@ func getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (r\n \treturn\n }\n \n-func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func postQuitMessage(exitCode int32) {\n \tsyscall.Syscall(procPostQuitMessage.Addr(), 1, uintptr(exitCode), 0, 0)\n \treturn\n@@ -127,15 +116,6 @@ func sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr)\n \treturn\n }\n \n-func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func translateMessage(lpMsg *_MSG) (res bool) {\n \tr0, _, _ := syscall.Syscall(procTranslateMessage.Addr(), 1, uintptr(unsafe.Pointer(lpMsg)), 0, 0)\n \tres = r0 != 0\n---\n\n\n---\n\nChoice B:\ndocs/windows/policy/en-US/tailscale.adml\n@@ -16,6 +16,7 @@\n             <string id=\"SINCE_V1_62\">Tailscale version 1.62.0 and later</string>\n             <string id=\"SINCE_V1_74\">Tailscale version 1.74.0 and later</string>\n             <string id=\"SINCE_V1_78\">Tailscale version 1.78.0 and later</string>\n+            <string id=\"SINCE_V1_80\">Tailscale version 1.80.0 and later</string>\n             <string id=\"SINCE_V1_82\">Tailscale version 1.82.0 and later</string>\n             <string id=\"SINCE_V1_84\">Tailscale version 1.84.0 and later</string>\n             <string id=\"Tailscale_Category\">Tailscale</string>\n@@ -271,6 +272,12 @@ If you enable this policy, the menu item will be displayed indicating the organi\n If you disable this policy or do not configure it, the corresponding menu item will be hidden.\n \n See https://tailscale.com/kb/1315/mdm-keys#set-your-organization-name for more details.]]></string>\n+            <string id=\"OnboardingFlow\">Show the onboarding flow</string>\n+            <string id=\"OnboardingFlow_Help\"><![CDATA[This policy can be used to show or hide the onboarding flow displayed by the GUI.\n+\n+If you enable or don't configure this policy, the onboarding flow will be shown to new users who have not yet signed in to a Tailscale account.\n+\n+If you disable this policy, the onboarding flow will never be shown.]]></string>\n         </stringTable>\n         <presentationTable>\n             <presentation id=\"LoginURL\">\n---\ndocs/windows/policy/tailscale.admx\n@@ -54,6 +54,10 @@\n                   displayName=\"$(string.SINCE_V1_78)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n       </definition>\n+      <definition name=\"SINCE_V1_80\"\n+                  displayName=\"$(string.SINCE_V1_80)\">\n+        <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n+      </definition>\n       <definition name=\"SINCE_V1_82\"\n                   displayName=\"$(string.SINCE_V1_82)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n@@ -335,6 +339,16 @@\n         <string>hide</string>\n       </disabledValue>\n     </policy>\n+    <policy name=\"OnboardingFlow\" class=\"Both\" displayName=\"$(string.OnboardingFlow)\" explainText=\"$(string.OnboardingFlow_Help)\" key=\"Software\\Policies\\Tailscale\" valueName=\"OnboardingFlow\">\n+      <parentCategory ref=\"UI_Category\" />\n+      <supportedOn ref=\"SINCE_V1_80\" />\n+      <enabledValue>\n+        <string>show</string>\n+      </enabledValue>\n+      <disabledValue>\n+        <string>hide</string>\n+      </disabledValue>\n+    </policy>\n     <policy name=\"ManagedBy\" class=\"Both\" displayName=\"$(string.ManagedBy)\" explainText=\"$(string.ManagedBy_Help)\" presentation=\"$(presentation.ManagedBy)\" key=\"Software\\Policies\\Tailscale\">\n       <parentCategory ref=\"UI_Category\" />\n       <supportedOn ref=\"SINCE_V1_62\" />\n---\n\n\n---\n\nChoice C:\nipn/store/kubestore/store_kube.go\n@@ -143,15 +143,6 @@ func (s *Store) WriteTLSCertAndKey(domain string, cert, key []byte) (err error)\n \tif err := dnsname.ValidHostname(domain); err != nil {\n \t\treturn fmt.Errorf(\"invalid domain name %q: %w\", domain, err)\n \t}\n-\tdefer func() {\n-\t\t// TODO(irbekrm): a read between these two separate writes would\n-\t\t// get a mismatched cert and key.  Allow writing both cert and\n-\t\t// key to the memory store in a single, lock-protected operation.\n-\t\tif err == nil {\n-\t\t\ts.memory.WriteState(ipn.StateKey(domain+\".crt\"), cert)\n-\t\t\ts.memory.WriteState(ipn.StateKey(domain+\".key\"), key)\n-\t\t}\n-\t}()\n \tsecretName := s.secretName\n \tdata := map[string][]byte{\n \t\tdomain + \".crt\": cert,\n@@ -166,36 +157,45 @@ func (s *Store) WriteTLSCertAndKey(domain string, cert, key []byte) (err error)\n \t\t\tkeyTLSKey:  key,\n \t\t}\n \t}\n-\treturn s.updateSecret(data, secretName)\n+\tif err := s.updateSecret(data, secretName); err != nil {\n+\t\treturn fmt.Errorf(\"error writing TLS cert and key to Secret: %w\", err)\n+\t}\n+\t// TODO(irbekrm): certs for write replicas are currently not\n+\t// written to memory to avoid out of sync memory state after\n+\t// Ingress resources have been recreated.  This means that TLS\n+\t// certs for write replicas are retrieved from the Secret on\n+\t// each HTTPS request.  This is a temporary solution till we\n+\t// implement a Secret watch.\n+\tif s.certShareMode != \"rw\" {\n+\t\ts.memory.WriteState(ipn.StateKey(domain+\".crt\"), cert)\n+\t\ts.memory.WriteState(ipn.StateKey(domain+\".key\"), key)\n+\t}\n+\treturn nil\n }\n \n // ReadTLSCertAndKey reads a TLS cert and key from memory or from a\n // domain-specific Secret. It first checks the in-memory store, if not found in\n // memory and running cert store in read-only mode, looks up a Secret.\n+// Note that write replicas of HA Ingress always retrieve TLS certs from Secrets.\n func (s *Store) ReadTLSCertAndKey(domain string) (cert, key []byte, err error) {\n \tif err := dnsname.ValidHostname(domain); err != nil {\n \t\treturn nil, nil, fmt.Errorf(\"invalid domain name %q: %w\", domain, err)\n \t}\n \tcertKey := domain + \".crt\"\n \tkeyKey := domain + \".key\"\n-\n \tcert, err = s.memory.ReadState(ipn.StateKey(certKey))\n \tif err == nil {\n \t\tkey, err = s.memory.ReadState(ipn.StateKey(keyKey))\n \t\tif err == nil {\n \t\t\treturn cert, key, nil\n \t\t}\n \t}\n-\tif s.certShareMode != \"ro\" {\n+\tif s.certShareMode == \"\" {\n \t\treturn nil, nil, ipn.ErrStateNotExist\n \t}\n-\t// If we are in cert share read only mode, it is possible that a write\n-\t// replica just issued the TLS cert for this DNS name and it has not\n-\t// been loaded to store yet, so check the Secret.\n \n \tctx, cancel := context.WithTimeout(context.Background(), timeout)\n \tdefer cancel()\n-\n \tsecret, err := s.client.GetSecret(ctx, domain)\n \tif err != nil {\n \t\tif kubeclient.IsNotFoundErr(err) {\n@@ -212,9 +212,18 @@ func (s *Store) ReadTLSCertAndKey(domain string) (cert, key []byte, err error) {\n \t}\n \t// TODO(irbekrm): a read between these two separate writes would\n \t// get a mismatched cert and key.  Allow writing both cert and\n-\t// key to the memory store in a single lock-protected operation.\n-\ts.memory.WriteState(ipn.StateKey(certKey), cert)\n-\ts.memory.WriteState(ipn.StateKey(keyKey), key)\n+\t// key to the memory store in a single, lock-protected operation.\n+\t//\n+\t// TODO(irbekrm): currently certs for write replicas of HA Ingress get\n+\t// retrieved from the cluster Secret on each HTTPS request to avoid a\n+\t// situation when after Ingress recreation stale certs are read from\n+\t// memory.\n+\t// Fix this by watching Secrets to ensure that memory store gets updated\n+\t// when Secrets are deleted.\n+\tif s.certShareMode == \"ro\" {\n+\t\ts.memory.WriteState(ipn.StateKey(certKey), cert)\n+\t\ts.memory.WriteState(ipn.StateKey(keyKey), key)\n+\t}\n \treturn cert, key, nil\n }\n \n---\nipn/store/kubestore/store_kube_test.go\n@@ -201,10 +201,6 @@ func TestWriteTLSCertAndKey(t *testing.T) {\n \t\t\t\t\"tls.crt\": []byte(testCert),\n \t\t\t\t\"tls.key\": []byte(testKey),\n \t\t\t},\n-\t\t\twantMemoryStore: map[ipn.StateKey][]byte{\n-\t\t\t\t\"my-app.tailnetxyz.ts.net.crt\": []byte(testCert),\n-\t\t\t\t\"my-app.tailnetxyz.ts.net.key\": []byte(testKey),\n-\t\t\t},\n \t\t},\n \t\t{\n \t\t\tname: \"cert_share_mode_write_update_existing\",\n@@ -219,10 +215,6 @@ func TestWriteTLSCertAndKey(t *testing.T) {\n \t\t\t\t\"tls.crt\": []byte(testCert),\n \t\t\t\t\"tls.key\": []byte(testKey),\n \t\t\t},\n-\t\t\twantMemoryStore: map[ipn.StateKey][]byte{\n-\t\t\t\t\"my-app.tailnetxyz.ts.net.crt\": []byte(testCert),\n-\t\t\t\t\"my-app.tailnetxyz.ts.net.key\": []byte(testKey),\n-\t\t\t},\n \t\t},\n \t\t{\n \t\t\tname: \"update_existing\",\n@@ -367,7 +359,7 @@ func TestReadTLSCertAndKey(t *testing.T) {\n \t\twantMemoryStore map[ipn.StateKey][]byte\n \t}{\n \t\t{\n-\t\t\tname: \"found\",\n+\t\t\tname: \"found_in_memory\",\n \t\t\tmemoryStore: map[ipn.StateKey][]byte{\n \t\t\t\t\"my-app.tailnetxyz.ts.net.crt\": []byte(testCert),\n \t\t\t\t\"my-app.tailnetxyz.ts.net.key\": []byte(testKey),\n@@ -381,7 +373,7 @@ func TestReadTLSCertAndKey(t *testing.T) {\n \t\t\t},\n \t\t},\n \t\t{\n-\t\t\tname:    \"not_found\",\n+\t\t\tname:    \"not_found_in_memory\",\n \t\t\tdomain:  testDomain,\n \t\t\twantErr: ipn.ErrStateNotExist,\n \t\t},\n@@ -400,6 +392,17 @@ func TestReadTLSCertAndKey(t *testing.T) {\n \t\t\t\t\"my-app.tailnetxyz.ts.net.key\": []byte(testKey),\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname:          \"cert_share_rw_mode_found_in_secret\",\n+\t\t\tcertShareMode: \"rw\",\n+\t\t\tdomain:        testDomain,\n+\t\t\tsecretData: map[string][]byte{\n+\t\t\t\t\"tls.crt\": []byte(testCert),\n+\t\t\t\t\"tls.key\": []byte(testKey),\n+\t\t\t},\n+\t\t\twantCert: []byte(testCert),\n+\t\t\twantKey:  []byte(testKey),\n+\t\t},\n \t\t{\n \t\t\tname:          \"cert_share_ro_mode_found_in_memory\",\n \t\t\tcertShareMode: \"ro\",\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/ssh_stub.go\n@@ -8,6 +8,7 @@ package ipnlocal\n import (\n \t\"errors\"\n \n+\t\"golang.org/x/crypto/ssh\"\n \t\"tailscale.com/tailcfg\"\n )\n \n@@ -18,3 +19,7 @@ func (b *LocalBackend) getSSHHostKeyPublicStrings() ([]string, error) {\n func (b *LocalBackend) getSSHUsernames(*tailcfg.C2NSSHUsernamesRequest) (*tailcfg.C2NSSHUsernamesResponse, error) {\n \treturn nil, errors.New(\"not implemented\")\n }\n+\n+func (b *LocalBackend) GetSSH_HostKeys() (keys []ssh.Signer, err error) {\n+\treturn nil, errors.New(\"not implemented\")\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nOn Windows and Android, peerAPIListeners may be initialized after a link change. This commit adds log statements to make it easier to trace this flow.\r\n\r\nUpdates #14393\n\n---\n\nChoice A:\nnet/netcheck/netcheck.go\n@@ -1045,7 +1045,7 @@ func (c *Client) finishAndStoreReport(rs *reportState, dm *tailcfg.DERPMap) *Rep\n }\n \n // runHTTPOnlyChecks is the netcheck done by environments that can\n-// only do HTTP requests, such as ws/wasm.\n+// only do HTTP requests, such as js/wasm.\n func (c *Client) runHTTPOnlyChecks(ctx context.Context, last *Report, rs *reportState, dm *tailcfg.DERPMap) error {\n \tvar regions []*tailcfg.DERPRegion\n \tif rs.incremental && last != nil {\n@@ -1057,6 +1057,9 @@ func (c *Client) runHTTPOnlyChecks(ctx context.Context, last *Report, rs *report\n \t}\n \tif len(regions) == 0 {\n \t\tfor _, dr := range dm.Regions {\n+\t\t\tif dr.NoMeasureNoHome {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tregions = append(regions, dr)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -958,7 +958,9 @@ func (b *LocalBackend) linkChange(delta *netmon.ChangeDelta) {\n \n \tif peerAPIListenAsync && b.netMap != nil && b.state == ipn.Running {\n \t\twant := b.netMap.GetAddresses().Len()\n-\t\tif len(b.peerAPIListeners) < want {\n+\t\thave := len(b.peerAPIListeners)\n+\t\tb.logf(\"[v1] linkChange: have %d peerAPIListeners, want %d\", have, want)\n+\t\tif have < want {\n \t\t\tb.logf(\"linkChange: peerAPIListeners too low; trying again\")\n \t\t\tb.goTracker.Go(b.initPeerAPIListener)\n \t\t}\n@@ -5369,6 +5371,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n+\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\nChoice C:\ngo.mod\n@@ -77,7 +77,7 @@ require (\n \tgithub.com/tailscale/certstore v0.1.1-0.20231202035212-d3fa0460f47e\n \tgithub.com/tailscale/depaware v0.0.0-20250112153213-b748de04d81b\n \tgithub.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41\n-\tgithub.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca\n+\tgithub.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869\n \tgithub.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05\n \tgithub.com/tailscale/hujson v0.0.0-20221223112325-20486734a56a\n \tgithub.com/tailscale/mkctr v0.0.0-20250228050937-c75ea1476830\n---\ngo.sum\n@@ -910,8 +910,8 @@ github.com/tailscale/go-winio v0.0.0-20231025203758-c4f33415bf55 h1:Gzfnfk2TWrk8\n github.com/tailscale/go-winio v0.0.0-20231025203758-c4f33415bf55/go.mod h1:4k4QO+dQ3R5FofL+SanAUZe+/QfeK0+OIuwDIRu2vSg=\n github.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41 h1:/V2rCMMWcsjYaYO2MeovLw+ClP63OtXgCF2Y1eb8+Ns=\n github.com/tailscale/goexpect v0.0.0-20210902213824-6e8c725cea41/go.mod h1:/roCdA6gg6lQyw/Oz6gIIGu3ggJKYhF+WC/AQReE5XQ=\n-github.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca h1:ecjHwH73Yvqf/oIdQ2vxAX+zc6caQsYdPzsxNW1J3G8=\n-github.com/tailscale/golang-x-crypto v0.0.0-20250218230618-9a281fd8faca/go.mod h1:ikbF+YT089eInTp9f2vmvy4+ZVnW5hzX1q2WknxSprQ=\n+github.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869 h1:SRL6irQkKGQKKLzvQP/ke/2ZuB7Py5+XuqtOgSj+iMM=\n+github.com/tailscale/golang-x-crypto v0.0.0-20250404221719-a5573b049869/go.mod h1:ikbF+YT089eInTp9f2vmvy4+ZVnW5hzX1q2WknxSprQ=\n github.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05 h1:4chzWmimtJPxRs2O36yuGRW3f9SYV+bMTTvMBI0EKio=\n github.com/tailscale/goupnp v1.0.1-0.20210804011211-c64d0f06ea05/go.mod h1:PdCqy9JzfWMJf1H5UJW2ip33/d4YkoKN0r67yKH1mG8=\n github.com/tailscale/hujson v0.0.0-20221223112325-20486734a56a h1:SJy1Pu0eH1C29XwJucQo73FrleVK6t4kYz4NVhp34Yw=\n---\ntempfork/acme/acme.go\n@@ -270,10 +270,7 @@ func (c *Client) FetchRenewalInfo(ctx context.Context, leaf []byte) (*RenewalInf\n \t\treturn nil, fmt.Errorf(\"parsing leaf certificate: %w\", err)\n \t}\n \n-\trenewalURL, err := c.getRenewalURL(parsedLeaf)\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"generating renewal info URL: %w\", err)\n-\t}\n+\trenewalURL := c.getRenewalURL(parsedLeaf)\n \n \tres, err := c.get(ctx, renewalURL, wantStatus(http.StatusOK))\n \tif err != nil {\n@@ -288,16 +285,20 @@ func (c *Client) FetchRenewalInfo(ctx context.Context, leaf []byte) (*RenewalInf\n \treturn &info, nil\n }\n \n-func (c *Client) getRenewalURL(cert *x509.Certificate) (string, error) {\n+func (c *Client) getRenewalURL(cert *x509.Certificate) string {\n \t// See https://www.ietf.org/archive/id/draft-ietf-acme-ari-04.html#name-the-renewalinfo-resource\n \t// for how the request URL is built.\n \turl := c.dir.RenewalInfoURL\n \tif !strings.HasSuffix(url, \"/\") {\n \t\turl += \"/\"\n \t}\n+\treturn url + certRenewalIdentifier(cert)\n+}\n+\n+func certRenewalIdentifier(cert *x509.Certificate) string {\n \taki := base64.RawURLEncoding.EncodeToString(cert.AuthorityKeyId)\n \tserial := base64.RawURLEncoding.EncodeToString(cert.SerialNumber.Bytes())\n-\treturn fmt.Sprintf(\"%s%s.%s\", url, aki, serial), nil\n+\treturn aki + \".\" + serial\n }\n \n // AcceptTOS always returns true to indicate the acceptance of a CA's Terms of Service\n---\ntempfork/acme/acme_test.go\n@@ -549,10 +549,7 @@ func TestGetRenewalURL(t *testing.T) {\n \t}\n \n \tclient := newTestClientWithMockDirectory()\n-\turlString, err := client.getRenewalURL(parsedLeaf)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\turlString := client.getRenewalURL(parsedLeaf)\n \n \tparsedURL, err := url.Parse(urlString)\n \tif err != nil {\n---\ntempfork/acme/rfc8555.go\n@@ -7,6 +7,7 @@ package acme\n import (\n \t\"context\"\n \t\"crypto\"\n+\t\"crypto/x509\"\n \t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"encoding/pem\"\n@@ -205,6 +206,7 @@ func (c *Client) AuthorizeOrder(ctx context.Context, id []AuthzID, opt ...OrderO\n \t\tIdentifiers []wireAuthzID `json:\"identifiers\"`\n \t\tNotBefore   string        `json:\"notBefore,omitempty\"`\n \t\tNotAfter    string        `json:\"notAfter,omitempty\"`\n+\t\tReplaces    string        `json:\"replaces,omitempty\"`\n \t}{}\n \tfor _, v := range id {\n \t\treq.Identifiers = append(req.Identifiers, wireAuthzID{\n@@ -218,6 +220,14 @@ func (c *Client) AuthorizeOrder(ctx context.Context, id []AuthzID, opt ...OrderO\n \t\t\treq.NotBefore = time.Time(o).Format(time.RFC3339)\n \t\tcase orderNotAfterOpt:\n \t\t\treq.NotAfter = time.Time(o).Format(time.RFC3339)\n+\t\tcase orderReplacesCert:\n+\t\t\treq.Replaces = certRenewalIdentifier(o.cert)\n+\t\tcase orderReplacesCertDER:\n+\t\t\tcert, err := x509.ParseCertificate(o)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"failed to parse certificate being replaced: %w\", err)\n+\t\t\t}\n+\t\t\treq.Replaces = certRenewalIdentifier(cert)\n \t\tdefault:\n \t\t\t// Package's fault if we let this happen.\n \t\t\tpanic(fmt.Sprintf(\"unsupported order option type %T\", o))\n---\ntempfork/acme/rfc8555_test.go\n@@ -766,10 +766,17 @@ func TestRFC_AuthorizeOrder(t *testing.T) {\n \ts.start()\n \tdefer s.close()\n \n+\tprevCertDER, _ := pem.Decode([]byte(leafPEM))\n+\tprevCert, err := x509.ParseCertificate(prevCertDER.Bytes)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n \tcl := &Client{Key: testKeyEC, DirectoryURL: s.url(\"/\")}\n \to, err := cl.AuthorizeOrder(context.Background(), DomainIDs(\"example.org\"),\n \t\tWithOrderNotBefore(time.Date(2019, 8, 31, 0, 0, 0, 0, time.UTC)),\n \t\tWithOrderNotAfter(time.Date(2019, 9, 2, 0, 0, 0, 0, time.UTC)),\n+\t\tWithOrderReplacesCert(prevCert),\n \t)\n \tif err != nil {\n \t\tt.Fatal(err)\n---\ntempfork/acme/types.go\n@@ -391,6 +391,30 @@ type orderNotAfterOpt time.Time\n \n func (orderNotAfterOpt) privateOrderOpt() {}\n \n+// WithOrderReplacesCert indicates that this Order is for a replacement of an\n+// existing certificate.\n+// See https://datatracker.ietf.org/doc/html/draft-ietf-acme-ari-03#section-5\n+func WithOrderReplacesCert(cert *x509.Certificate) OrderOption {\n+\treturn orderReplacesCert{cert}\n+}\n+\n+type orderReplacesCert struct {\n+\tcert *x509.Certificate\n+}\n+\n+func (orderReplacesCert) privateOrderOpt() {}\n+\n+// WithOrderReplacesCertDER indicates that this Order is for a replacement of\n+// an existing DER-encoded certificate.\n+// See https://datatracker.ietf.org/doc/html/draft-ietf-acme-ari-03#section-5\n+func WithOrderReplacesCertDER(der []byte) OrderOption {\n+\treturn orderReplacesCertDER(der)\n+}\n+\n+type orderReplacesCertDER []byte\n+\n+func (orderReplacesCertDER) privateOrderOpt() {}\n+\n // Authorization encodes an authorization response.\n type Authorization struct {\n \t// URI uniquely identifies a authorization.\n---\n\n\n---\n\nChoice D:\ncmd/vnet/vnet-main.go\n@@ -7,15 +7,21 @@ package main\n \n import (\n \t\"context\"\n+\t\"encoding/binary\"\n \t\"flag\"\n+\t\"fmt\"\n+\t\"io\"\n \t\"log\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/http/httputil\"\n \t\"net/url\"\n \t\"os\"\n+\t\"path/filepath\"\n+\t\"slices\"\n \t\"time\"\n \n+\t\"github.com/coder/websocket\"\n \t\"tailscale.com/tstest/natlab/vnet\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/must\"\n@@ -31,10 +37,18 @@ var (\n \tpcapFile = flag.String(\"pcap\", \"\", \"if non-empty, filename to write pcap\")\n \tv4       = flag.Bool(\"v4\", true, \"enable IPv4\")\n \tv6       = flag.Bool(\"v6\", true, \"enable IPv6\")\n+\n+\twsproxyListen = flag.String(\"wsproxy\", \"\", \"if non-empty, TCP address to run websocket server on. See https://github.com/copy/v86/blob/master/docs/networking.md#backend-url-schemes\")\n )\n \n func main() {\n \tflag.Parse()\n+\tif *wsproxyListen != \"\" {\n+\t\tif err := runWSProxy(); err != nil {\n+\t\t\tlog.Fatalf(\"runWSProxy: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n \n \tif _, err := os.Stat(*listen); err == nil {\n \t\tos.Remove(*listen)\n@@ -137,3 +151,168 @@ func main() {\n \t\tgo s.ServeUnixConn(c.(*net.UnixConn), vnet.ProtocolQEMU)\n \t}\n }\n+\n+func runWSProxy() error {\n+\tln, err := net.Listen(\"tcp\", *wsproxyListen)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer ln.Close()\n+\n+\tlog.Printf(\"Running wsproxy mode on %v ...\", *wsproxyListen)\n+\n+\tvar hs http.Server\n+\ths.Handler = http.HandlerFunc(handleWebSocket)\n+\n+\treturn hs.Serve(ln)\n+}\n+\n+func handleWebSocket(w http.ResponseWriter, r *http.Request) {\n+\tconn, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\tif err != nil {\n+\t\tlog.Printf(\"Upgrade error: %v\", err)\n+\t\treturn\n+\t}\n+\tdefer conn.Close(websocket.StatusInternalError, \"closing\")\n+\tlog.Printf(\"WebSocket client connected: %s\", r.RemoteAddr)\n+\n+\tctx, cancel := context.WithCancel(r.Context())\n+\tdefer cancel()\n+\n+\tmessageType, firstData, err := conn.Read(ctx)\n+\tif err != nil {\n+\t\tlog.Printf(\"ReadMessage first: %v\", err)\n+\t\treturn\n+\t}\n+\tif messageType != websocket.MessageBinary {\n+\t\tlog.Printf(\"Ignoring non-binary message\")\n+\t\treturn\n+\t}\n+\tif len(firstData) < 12 {\n+\t\tlog.Printf(\"Ignoring short message\")\n+\t\treturn\n+\t}\n+\tclientMAC := vnet.MAC(firstData[6:12])\n+\n+\t// Set up a qemu-protocol Unix socket pair. We'll fake the qemu protocol here\n+\t// to avoid changing the vnet package.\n+\ttd, err := os.MkdirTemp(\"\", \"vnet\")\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"MkdirTemp: %v\", err))\n+\t}\n+\tdefer os.RemoveAll(td)\n+\n+\tunixSrv := filepath.Join(td, \"vnet.sock\")\n+\n+\tsrv, err := net.Listen(\"unix\", unixSrv)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"Listen: %v\", err))\n+\t}\n+\tdefer srv.Close()\n+\n+\tvar c vnet.Config\n+\tc.SetBlendReality(true)\n+\n+\tvar net1opt = []any{vnet.NAT(\"easy\")}\n+\tnet1opt = append(net1opt, \"2.1.1.1\", \"192.168.1.1/24\")\n+\tnet1opt = append(net1opt, \"2000:52::1/64\")\n+\n+\tc.AddNode(c.AddNetwork(net1opt...), clientMAC)\n+\n+\tvs, err := vnet.New(&c)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"newServer: %v\", err))\n+\t}\n+\tif err := vs.PopulateDERPMapIPs(); err != nil {\n+\t\tlog.Printf(\"warning: ignoring failure to populate DERP map: %v\", err)\n+\t\treturn\n+\t}\n+\n+\terrc := make(chan error, 1)\n+\tfail := func(err error) {\n+\t\tselect {\n+\t\tcase errc <- err:\n+\t\t\tlog.Printf(\"failed: %v\", err)\n+\t\tcase <-ctx.Done():\n+\t\t}\n+\t}\n+\n+\tgo func() {\n+\t\tc, err := srv.Accept()\n+\t\tif err != nil {\n+\t\t\tfail(err)\n+\t\t\treturn\n+\t\t}\n+\t\tvs.ServeUnixConn(c.(*net.UnixConn), vnet.ProtocolQEMU)\n+\t}()\n+\n+\tuc, err := net.Dial(\"unix\", unixSrv)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"Dial: %v\", err))\n+\t}\n+\tdefer uc.Close()\n+\n+\tvar frameBuf []byte\n+\twriteDataToUnixConn := func(data []byte) error {\n+\t\tframeBuf = slices.Grow(frameBuf[:0], len(data)+4)[:len(data)+4]\n+\t\tbinary.BigEndian.PutUint32(frameBuf[:4], uint32(len(data)))\n+\t\tcopy(frameBuf[4:], data)\n+\n+\t\t_, err = uc.Write(frameBuf)\n+\t\treturn err\n+\t}\n+\tif err := writeDataToUnixConn(firstData); err != nil {\n+\t\tfail(err)\n+\t\treturn\n+\t}\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tmessageType, data, err := conn.Read(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\tfail(fmt.Errorf(\"ReadMessage: %v\", err))\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif messageType != websocket.MessageBinary {\n+\t\t\t\tlog.Printf(\"Ignoring non-binary message\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif err := writeDataToUnixConn(data); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tgo func() {\n+\t\tconst maxBuf = 4096\n+\t\tframeBuf := make([]byte, maxBuf)\n+\t\tfor {\n+\t\t\t_, err := io.ReadFull(uc, frameBuf[:4])\n+\t\t\tif err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tframeLen := binary.BigEndian.Uint32(frameBuf[:4])\n+\t\t\tif frameLen > maxBuf {\n+\t\t\t\tfail(fmt.Errorf(\"frame too large: %d\", frameLen))\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif _, err := io.ReadFull(uc, frameBuf[:frameLen]); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := conn.Write(ctx, websocket.MessageBinary, frameBuf[:frameLen]); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\t<-ctx.Done()\n+}\n---\ntstest/natlab/vnet/conf.go\n@@ -121,6 +121,8 @@ func (c *Config) AddNode(opts ...any) *Node {\n \t\t\t\t\tn.err = fmt.Errorf(\"unknown NodeOption %q\", o)\n \t\t\t\t}\n \t\t\t}\n+\t\tcase MAC:\n+\t\t\tn.mac = o\n \t\tdefault:\n \t\t\tif n.err == nil {\n \t\t\t\tn.err = fmt.Errorf(\"unknown AddNode option type %T\", o)\n---\ntstest/natlab/vnet/vnet.go\n@@ -88,6 +88,9 @@ func (s *Server) PopulateDERPMapIPs() error {\n \t\t\tif n.IPv4 != \"\" {\n \t\t\t\ts.derpIPs.Add(netip.MustParseAddr(n.IPv4))\n \t\t\t}\n+\t\t\tif n.IPv6 != \"\" {\n+\t\t\t\ts.derpIPs.Add(netip.MustParseAddr(n.IPv6))\n+\t\t\t}\n \t\t}\n \t}\n \treturn nil\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAdd a label which differentiates the address family for STUN checks.\r\n\r\nAlso initialize the derpprobe_attempts_total and\r\nderpprobe_seconds_total metrics by adding 0 for\r\nthe alternate fail/ok case.\r\n\r\nUpdates tailscale/corp#27249\n\n---\n\nChoice A:\ncmd/tsidp/Dockerfile\n@@ -31,11 +31,11 @@ WORKDIR /app\n \n # Environment variables\n ENV TAILSCALE_USE_WIP_CODE=1 \\\n-    TS_HOSTNAME=tsidp \\\n+    TS_HOSTNAME=idp \\\n     TS_STATE_DIR=/var/lib/tsidp\n \n # Expose the default port\n EXPOSE 443\n \n # Run the application\n-ENTRYPOINT [\"/app/tsidp\"]\n\\ No newline at end of file\n+ENTRYPOINT [\"/bin/sh\", \"-c\", \"/app/tsidp --hostname=${TS_HOSTNAME} --dir=${TS_STATE_DIR}\"]\n---\ncmd/tsidp/README.md\n@@ -38,7 +38,7 @@\n      --name `tsidp` \\\n      -p 443:443 \\\n      -e TS_AUTHKEY=YOUR_TAILSCALE_AUTHKEY \\\n-     -e TS_HOSTNAME=tsidp \\\n+     -e TS_HOSTNAME=idp \\\n      -v tsidp-data:/var/lib/tsidp \\\n      tsidp:latest\n    ```\n@@ -48,7 +48,7 @@\n    docker logs tsidp\n    ```\n \n-   Visit `https://tsidp.tailnet.ts.net` to confirm the service is running.\n+   Visit `https://idp.tailnet.ts.net` to confirm the service is running.\n \n ## Usage Example: Proxmox Integration\n \n@@ -82,13 +82,14 @@ The `tsidp` server supports several command-line flags:\n - `--port`: Port to listen on (default: 443)\n - `--local-port`: Allow requests from localhost\n - `--use-local-tailscaled`: Use local tailscaled instead of tsnet\n+- `--hostname`: tsnet hostname\n - `--dir`: tsnet state directory\n \n ## Environment Variables\n \n - `TS_AUTHKEY`: Your Tailscale authentication key (required)\n-- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\")\n-- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\")\n+- `TS_HOSTNAME`: Hostname for the `tsidp` server (default: \"idp\", Docker only)\n+- `TS_STATE_DIR`: State directory (default: \"/var/lib/tsidp\", Docker only)\n - `TAILSCALE_USE_WIP_CODE`: Enable work-in-progress code (default: \"1\")\n \n ## Support\n@@ -97,4 +98,4 @@ This is an [experimental](https://tailscale.com/kb/1167/release-stages#experimen\n \n ## License\n \n-BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n\\ No newline at end of file\n+BSD-3-Clause License. See [LICENSE](../../LICENSE) for details.\n---\ncmd/tsidp/tsidp.go\n@@ -65,6 +65,7 @@ var (\n \tflagLocalPort          = flag.Int(\"local-port\", -1, \"allow requests from localhost\")\n \tflagUseLocalTailscaled = flag.Bool(\"use-local-tailscaled\", false, \"use local tailscaled instead of tsnet\")\n \tflagFunnel             = flag.Bool(\"funnel\", false, \"use Tailscale Funnel to make tsidp available on the public internet\")\n+\tflagHostname           = flag.String(\"hostname\", \"idp\", \"tsnet hostname to use instead of idp\")\n \tflagDir                = flag.String(\"dir\", \"\", \"tsnet state directory; a default one will be created if not provided\")\n )\n \n@@ -121,7 +122,7 @@ func main() {\n \t\tdefer cleanup()\n \t} else {\n \t\tts := &tsnet.Server{\n-\t\t\tHostname: \"idp\",\n+\t\t\tHostname: *flagHostname,\n \t\t\tDir:      *flagDir,\n \t\t}\n \t\tif *flagVerbose {\n---\n\n\n---\n\nChoice B:\nprober/derp.go\n@@ -596,11 +596,23 @@ func (d *derpProber) updateMap(ctx context.Context) error {\n }\n \n func (d *derpProber) ProbeUDP(ipaddr string, port int) ProbeClass {\n+\tinitLabels := make(Labels)\n+\tip := net.ParseIP(ipaddr)\n+\n+\tif ip.To4() != nil {\n+\t\tinitLabels[\"address_family\"] = \"ipv4\"\n+\t} else if ip.To16() != nil { // Will return an IPv4 as 16 byte, so ensure the check for IPv4 precedes this\n+\t\tinitLabels[\"address_family\"] = \"ipv6\"\n+\t} else {\n+\t\tinitLabels[\"address_family\"] = \"unknown\"\n+\t}\n+\n \treturn ProbeClass{\n \t\tProbe: func(ctx context.Context) error {\n \t\t\treturn derpProbeUDP(ctx, ipaddr, port)\n \t\t},\n-\t\tClass: \"derp_udp\",\n+\t\tClass:  \"derp_udp\",\n+\t\tLabels: initLabels,\n \t}\n }\n \n---\nprober/prober.go\n@@ -404,10 +404,14 @@ func (p *Probe) recordEndLocked(err error) {\n \t\tp.mSeconds.WithLabelValues(\"ok\").Add(latency.Seconds())\n \t\tp.latencyHist.Value = latency\n \t\tp.latencyHist = p.latencyHist.Next()\n+\t\tp.mAttempts.WithLabelValues(\"fail\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"fail\").Add(0)\n \t} else {\n \t\tp.latency = 0\n \t\tp.mAttempts.WithLabelValues(\"fail\").Inc()\n \t\tp.mSeconds.WithLabelValues(\"fail\").Add(latency.Seconds())\n+\t\tp.mAttempts.WithLabelValues(\"ok\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"ok\").Add(0)\n \t}\n \tp.successHist.Value = p.succeeded\n \tp.successHist = p.successHist.Next()\n---\n\n\n---\n\nChoice C:\ncmd/tsidp/tsidp.go\n@@ -795,7 +795,7 @@ type oidcTokenResponse struct {\n \tIDToken      string `json:\"id_token\"`\n \tTokenType    string `json:\"token_type\"`\n \tAccessToken  string `json:\"access_token\"`\n-\tRefreshToken string `json:\"refresh_token\"`\n+\tRefreshToken string `json:\"refresh_token,omitempty\"`\n \tExpiresIn    int    `json:\"expires_in\"`\n }\n \n---\n\n\n---\n\nChoice D:\nclient/systray/systray.go\n@@ -84,12 +84,13 @@ type Menu struct {\n \tbgCancel context.CancelFunc\n \n \t// Top-level menu items\n-\tconnect    *systray.MenuItem\n-\tdisconnect *systray.MenuItem\n-\tself       *systray.MenuItem\n-\texitNodes  *systray.MenuItem\n-\tmore       *systray.MenuItem\n-\tquit       *systray.MenuItem\n+\tconnect     *systray.MenuItem\n+\tdisconnect  *systray.MenuItem\n+\tself        *systray.MenuItem\n+\texitNodes   *systray.MenuItem\n+\tmore        *systray.MenuItem\n+\trebuildMenu *systray.MenuItem\n+\tquit        *systray.MenuItem\n \n \trebuildCh  chan struct{} // triggers a menu rebuild\n \taccountsCh chan ipn.ProfileID\n@@ -295,6 +296,17 @@ func (menu *Menu) rebuild() {\n \t\t})\n \t}\n \n+\t// TODO(#15528): this menu item shouldn't be necessary at all,\n+\t// but is at least more discoverable than having users switch profiles or exit nodes.\n+\tmenu.rebuildMenu = systray.AddMenuItem(\"Rebuild menu\", \"Fix missing menu items\")\n+\tonClick(ctx, menu.rebuildMenu, func(ctx context.Context) {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\tcase menu.rebuildCh <- struct{}{}:\n+\t\t}\n+\t})\n+\tmenu.rebuildMenu.Enable()\n+\n \tmenu.quit = systray.AddMenuItem(\"Quit\", \"Quit the app\")\n \tmenu.quit.Enable()\n \n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nCurrently nobody calls SetTailscaleInterfaceName yet, so this is a\nno-op. I checked oss, android, and the macOS/iOS client. Nobody calls\nthis, or ever did.\n\nBut I want to in the future.\n\nUpdates #15408\nUpdates #9040\n\n\n---\n\nChoice A:\ntstest/integration/integration.go\n@@ -684,7 +684,6 @@ func (n *TestNode) StartDaemonAsIPNGOOS(ipnGOOS string) *Daemon {\n \t\tcmd.Args = append(cmd.Args, \"--config=\"+n.configFile)\n \t}\n \tcmd.Env = append(os.Environ(),\n-\t\t\"TS_CONTROL_IS_PLAINTEXT_HTTP=1\",\n \t\t\"TS_DEBUG_PERMIT_HTTP_C2N=1\",\n \t\t\"TS_LOG_TARGET=\"+n.env.LogCatcherServer.URL,\n \t\t\"HTTP_PROXY=\"+n.env.TrafficTrapServer.URL,\n---\n\n\n---\n\nChoice B:\nlogpolicy/logpolicy.go\n@@ -518,8 +518,9 @@ type Options struct {\n \tMaxUploadSize int\n }\n \n-// New returns a new log policy (a logger and its instance ID).\n-func (opts Options) New() *Policy {\n+// init initializes the log policy and returns a logtail.Config and the\n+// Policy.\n+func (opts Options) init(disableLogging bool) (*logtail.Config, *Policy) {\n \tif hostinfo.IsNATLabGuestVM() {\n \t\t// In NATLab Gokrazy instances, tailscaled comes up concurently with\n \t\t// DHCP and the doesn't have DNS for a while. Wait for DHCP first.\n@@ -628,7 +629,7 @@ func (opts Options) New() *Policy {\n \t\tconf.IncludeProcSequence = true\n \t}\n \n-\tif envknob.NoLogsNoSupport() || testenv.InTest() || runtime.GOOS == \"plan9\" {\n+\tif disableLogging {\n \t\topts.Logf(\"You have disabled logging. Tailscale will not be able to provide support.\")\n \t\tconf.HTTPC = &http.Client{Transport: noopPretendSuccessTransport{}}\n \t} else {\n@@ -637,14 +638,15 @@ func (opts Options) New() *Policy {\n \t\tattachFilchBuffer(&conf, opts.Dir, opts.CmdName, opts.MaxBufferSize, opts.Logf)\n \t\tconf.HTTPC = opts.HTTPC\n \n+\t\tlogHost := logtail.DefaultHost\n+\t\tif val := getLogTarget(); val != \"\" {\n+\t\t\topts.Logf(\"You have enabled a non-default log target. Doing without being told to by Tailscale staff or your network administrator will make getting support difficult.\")\n+\t\t\tconf.BaseURL = val\n+\t\t\tu, _ := url.Parse(val)\n+\t\t\tlogHost = u.Host\n+\t\t}\n+\n \t\tif conf.HTTPC == nil {\n-\t\t\tlogHost := logtail.DefaultHost\n-\t\t\tif val := getLogTarget(); val != \"\" {\n-\t\t\t\topts.Logf(\"You have enabled a non-default log target. Doing without being told to by Tailscale staff or your network administrator will make getting support difficult.\")\n-\t\t\t\tconf.BaseURL = val\n-\t\t\t\tu, _ := url.Parse(val)\n-\t\t\t\tlogHost = u.Host\n-\t\t\t}\n \t\t\tconf.HTTPC = &http.Client{Transport: TransportOptions{\n \t\t\t\tHost:   logHost,\n \t\t\t\tNetMon: opts.NetMon,\n@@ -680,13 +682,20 @@ func (opts Options) New() *Policy {\n \t\topts.Logf(\"%s\", earlyErrBuf.Bytes())\n \t}\n \n-\treturn &Policy{\n+\treturn &conf, &Policy{\n \t\tLogtail:  lw,\n \t\tPublicID: newc.PublicID,\n \t\tLogf:     opts.Logf,\n \t}\n }\n \n+// New returns a new log policy (a logger and its instance ID).\n+func (opts Options) New() *Policy {\n+\tdisableLogging := envknob.NoLogsNoSupport() || testenv.InTest() || runtime.GOOS == \"plan9\"\n+\t_, policy := opts.init(disableLogging)\n+\treturn policy\n+}\n+\n // attachFilchBuffer creates an on-disk ring buffer using filch and attaches\n // it to the logtail config. Note that this is optional; if no buffer is set,\n // logtail will use an in-memory buffer.\n---\nlogpolicy/logpolicy_test.go\n@@ -4,19 +4,22 @@\n package logpolicy\n \n import (\n+\t\"net/http\"\n \t\"os\"\n \t\"reflect\"\n \t\"testing\"\n \n \t\"tailscale.com/logtail\"\n )\n \n-func TestLogHost(t *testing.T) {\n+func resetLogTarget() {\n+\tos.Unsetenv(\"TS_LOG_TARGET\")\n \tv := reflect.ValueOf(&getLogTargetOnce).Elem()\n-\treset := func() {\n-\t\tv.Set(reflect.Zero(v.Type()))\n-\t}\n-\tdefer reset()\n+\tv.Set(reflect.Zero(v.Type()))\n+}\n+\n+func TestLogHost(t *testing.T) {\n+\tdefer resetLogTarget()\n \n \ttests := []struct {\n \t\tenv  string\n@@ -29,10 +32,55 @@ func TestLogHost(t *testing.T) {\n \t\t{\"https://foo.com:123/\", \"foo.com\"},\n \t}\n \tfor _, tt := range tests {\n-\t\treset()\n+\t\tresetLogTarget()\n \t\tos.Setenv(\"TS_LOG_TARGET\", tt.env)\n \t\tif got := LogHost(); got != tt.want {\n \t\t\tt.Errorf(\"for env %q, got %q, want %q\", tt.env, got, tt.want)\n \t\t}\n \t}\n }\n+func TestOptions(t *testing.T) {\n+\tdefer resetLogTarget()\n+\n+\ttests := []struct {\n+\t\tname        string\n+\t\topts        func() Options\n+\t\twantBaseURL string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"default\",\n+\t\t\topts:        func() Options { return Options{} },\n+\t\t\twantBaseURL: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom_baseurl\",\n+\t\t\topts: func() Options {\n+\t\t\t\tos.Setenv(\"TS_LOG_TARGET\", \"http://localhost:1234\")\n+\t\t\t\treturn Options{}\n+\t\t\t},\n+\t\t\twantBaseURL: \"http://localhost:1234\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom_httpc_and_baseurl\",\n+\t\t\topts: func() Options {\n+\t\t\t\tos.Setenv(\"TS_LOG_TARGET\", \"http://localhost:12345\")\n+\t\t\t\treturn Options{HTTPC: &http.Client{Transport: noopPretendSuccessTransport{}}}\n+\t\t\t},\n+\t\t\twantBaseURL: \"http://localhost:12345\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresetLogTarget()\n+\t\t\tconfig, policy := tt.opts().init(false)\n+\t\t\tif policy == nil {\n+\t\t\t\tt.Fatal(\"unexpected nil policy\")\n+\t\t\t}\n+\t\t\tif config.BaseURL != tt.wantBaseURL {\n+\t\t\t\tt.Errorf(\"got %q, want %q\", config.BaseURL, tt.wantBaseURL)\n+\t\t\t}\n+\t\t\tpolicy.Close()\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\ncmd/nardump/nardump.go\n@@ -100,14 +100,13 @@ func (nw *narWriter) writeDir(dirPath string) error {\n \t\tsub := path.Join(dirPath, ent.Name())\n \t\tvar err error\n \t\tswitch {\n-\t\tcase mode.IsRegular():\n-\t\t\terr = nw.writeRegular(sub)\n \t\tcase mode.IsDir():\n \t\t\terr = nw.writeDir(sub)\n+\t\tcase mode.IsRegular():\n+\t\t\terr = nw.writeRegular(sub)\n+\t\tcase mode&os.ModeSymlink != 0:\n+\t\t\terr = nw.writeSymlink(sub)\n \t\tdefault:\n-\t\t\t// TODO(bradfitz): symlink, but requires fighting io/fs a bit\n-\t\t\t// to get at Readlink or the osFS via fs. But for now\n-\t\t\t// we don't need symlinks because they're not in Go's archive.\n \t\t\treturn fmt.Errorf(\"unsupported file type %v at %q\", sub, mode)\n \t\t}\n \t\tif err != nil {\n@@ -143,6 +142,23 @@ func (nw *narWriter) writeRegular(path string) error {\n \treturn nil\n }\n \n+func (nw *narWriter) writeSymlink(path string) error {\n+\tnw.str(\"(\")\n+\tnw.str(\"type\")\n+\tnw.str(\"symlink\")\n+\tnw.str(\"target\")\n+\t// broken symlinks are valid in a nar\n+\t// given we do os.chdir(dir) and os.dirfs(\".\") above\n+\t// readlink now resolves relative links even if they are broken\n+\tlink, err := os.Readlink(path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tnw.str(link)\n+\tnw.str(\")\")\n+\treturn nil\n+}\n+\n func (nw *narWriter) str(s string) {\n \tif err := writeString(nw.w, s); err != nil {\n \t\tpanic(writeNARError{err})\n---\ncmd/nardump/nardump_test.go\n@@ -0,0 +1,52 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+package main\n+\n+import (\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+// setupTmpdir sets up a known golden layout, covering all allowed file/folder types in a nar\n+func setupTmpdir(t *testing.T) string {\n+\ttmpdir := t.TempDir()\n+\tpwd, _ := os.Getwd()\n+\tos.Chdir(tmpdir)\n+\tdefer os.Chdir(pwd)\n+\tos.MkdirAll(\"sub/dir\", 0755)\n+\tos.Symlink(\"brokenfile\", \"brokenlink\")\n+\tos.Symlink(\"sub/dir\", \"dirl\")\n+\tos.Symlink(\"/abs/nonexistentdir\", \"dirb\")\n+\tos.Create(\"sub/dir/file1\")\n+\tf, _ := os.Create(\"file2m\")\n+\t_ = f.Truncate(2 * 1024 * 1024)\n+\tf.Close()\n+\tos.Symlink(\"../file2m\", \"sub/goodlink\")\n+\treturn tmpdir\n+}\n+\n+func TestWriteNar(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// Skip test on Windows as the Nix package manager is not supported on this platform\n+\t\tt.Skip(\"nix package manager is not available on Windows\")\n+\t}\n+\tdir := setupTmpdir(t)\n+\tt.Run(\"nar\", func(t *testing.T) {\n+\t\t// obtained via `nix-store --dump /tmp/... | sha256sum` of the above test dir\n+\t\texpected := \"727613a36f41030e93a4abf2649c3ec64a2757ccff364e3f6f7d544eb976e442\"\n+\t\th := sha256.New()\n+\t\tos.Chdir(dir)\n+\t\terr := writeNAR(h, os.DirFS(\".\"))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\thash := fmt.Sprintf(\"%x\", h.Sum(nil))\n+\t\tif expected != hash {\n+\t\t\tt.Fatal(\"sha256sum of nar not matched\", hash, expected)\n+\t\t}\n+\t})\n+}\n---\n\n\n---\n\nChoice D:\nipn/ipnlocal/local.go\n@@ -4968,7 +4968,7 @@ func (b *LocalBackend) authReconfig() {\n \t\treturn\n \t}\n \n-\toneCGNATRoute := shouldUseOneCGNATRoute(b.logf, b.sys.ControlKnobs(), version.OS())\n+\toneCGNATRoute := shouldUseOneCGNATRoute(b.logf, b.sys.NetMon.Get(), b.sys.ControlKnobs(), version.OS())\n \trcfg := b.routerConfig(cfg, prefs, oneCGNATRoute)\n \n \terr = b.e.Reconfig(cfg, rcfg, dcfg)\n@@ -4992,7 +4992,7 @@ func (b *LocalBackend) authReconfig() {\n //\n // The versionOS is a Tailscale-style version (\"iOS\", \"macOS\") and not\n // a runtime.GOOS.\n-func shouldUseOneCGNATRoute(logf logger.Logf, controlKnobs *controlknobs.Knobs, versionOS string) bool {\n+func shouldUseOneCGNATRoute(logf logger.Logf, mon *netmon.Monitor, controlKnobs *controlknobs.Knobs, versionOS string) bool {\n \tif controlKnobs != nil {\n \t\t// Explicit enabling or disabling always take precedence.\n \t\tif v, ok := controlKnobs.OneCGNAT.Load().Get(); ok {\n@@ -5007,7 +5007,7 @@ func shouldUseOneCGNATRoute(logf logger.Logf, controlKnobs *controlknobs.Knobs,\n \t// use fine-grained routes if another interfaces is also using the CGNAT\n \t// IP range.\n \tif versionOS == \"macOS\" {\n-\t\thasCGNATInterface, err := netmon.HasCGNATInterface()\n+\t\thasCGNATInterface, err := mon.HasCGNATInterface()\n \t\tif err != nil {\n \t\t\tlogf(\"shouldUseOneCGNATRoute: Could not determine if any interfaces use CGNAT: %v\", err)\n \t\t\treturn false\n---\nipn/ipnlocal/peerapi.go\n@@ -481,7 +481,7 @@ func (h *peerAPIHandler) handleServeInterfaces(w http.ResponseWriter, r *http.Re\n \t\tfmt.Fprintf(w, \"<h3>Could not get the default route: %s</h3>\\n\", html.EscapeString(err.Error()))\n \t}\n \n-\tif hasCGNATInterface, err := netmon.HasCGNATInterface(); hasCGNATInterface {\n+\tif hasCGNATInterface, err := h.ps.b.sys.NetMon.Get().HasCGNATInterface(); hasCGNATInterface {\n \t\tfmt.Fprintln(w, \"<p>There is another interface using the CGNAT range.</p>\")\n \t} else if err != nil {\n \t\tfmt.Fprintf(w, \"<p>Could not check for CGNAT interfaces: %s</p>\\n\", html.EscapeString(err.Error()))\n---\nnet/netmon/interfaces_test.go\n@@ -13,7 +13,7 @@ import (\n )\n \n func TestGetState(t *testing.T) {\n-\tst, err := getState()\n+\tst, err := getState(\"\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/netmon/netmon.go\n@@ -161,7 +161,7 @@ func (m *Monitor) InterfaceState() *State {\n }\n \n func (m *Monitor) interfaceStateUncached() (*State, error) {\n-\treturn getState()\n+\treturn getState(m.tsIfName)\n }\n \n // SetTailscaleInterfaceName sets the name of the Tailscale interface. For\n---\nnet/netmon/state.go\n@@ -461,21 +461,22 @@ func isTailscaleInterface(name string, ips []netip.Prefix) bool {\n // getPAC, if non-nil, returns the current PAC file URL.\n var getPAC func() string\n \n-// GetState returns the state of all the current machine's network interfaces.\n+// getState returns the state of all the current machine's network interfaces.\n //\n // It does not set the returned State.IsExpensive. The caller can populate that.\n //\n-// Deprecated: use netmon.Monitor.InterfaceState instead.\n-func getState() (*State, error) {\n+// optTSInterfaceName is the name of the Tailscale interface, if known.\n+func getState(optTSInterfaceName string) (*State, error) {\n \ts := &State{\n \t\tInterfaceIPs: make(map[string][]netip.Prefix),\n \t\tInterface:    make(map[string]Interface),\n \t}\n \tif err := ForeachInterface(func(ni Interface, pfxs []netip.Prefix) {\n+\t\tisTSInterfaceName := optTSInterfaceName != \"\" && ni.Name == optTSInterfaceName\n \t\tifUp := ni.IsUp()\n \t\ts.Interface[ni.Name] = ni\n \t\ts.InterfaceIPs[ni.Name] = append(s.InterfaceIPs[ni.Name], pfxs...)\n-\t\tif !ifUp || isTailscaleInterface(ni.Name, pfxs) {\n+\t\tif !ifUp || isTSInterfaceName || isTailscaleInterface(ni.Name, pfxs) {\n \t\t\treturn\n \t\t}\n \t\tfor _, pfx := range pfxs {\n@@ -755,11 +756,12 @@ func DefaultRoute() (DefaultRouteDetails, error) {\n \n // HasCGNATInterface reports whether there are any non-Tailscale interfaces that\n // use a CGNAT IP range.\n-func HasCGNATInterface() (bool, error) {\n+func (m *Monitor) HasCGNATInterface() (bool, error) {\n \thasCGNATInterface := false\n \tcgnatRange := tsaddr.CGNATRange()\n \terr := ForeachInterface(func(i Interface, pfxs []netip.Prefix) {\n-\t\tif hasCGNATInterface || !i.IsUp() || isTailscaleInterface(i.Name, pfxs) {\n+\t\tisTSInterfaceName := m.tsIfName != \"\" && i.Name == m.tsIfName\n+\t\tif hasCGNATInterface || !i.IsUp() || isTSInterfaceName || isTailscaleInterface(i.Name, pfxs) {\n \t\t\treturn\n \t\t}\n \t\tfor _, pfx := range pfxs {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBaby step towards #15408.\n\nUpdates #15408\n\n\n---\n\nChoice A:\nnet/netmon/interfaces_test.go\n@@ -13,7 +13,7 @@ import (\n )\n \n func TestGetState(t *testing.T) {\n-\tst, err := GetState()\n+\tst, err := getState()\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/netmon/netmon.go\n@@ -161,7 +161,7 @@ func (m *Monitor) InterfaceState() *State {\n }\n \n func (m *Monitor) interfaceStateUncached() (*State, error) {\n-\treturn GetState()\n+\treturn getState()\n }\n \n // SetTailscaleInterfaceName sets the name of the Tailscale interface. For\n---\nnet/netmon/state.go\n@@ -466,7 +466,7 @@ var getPAC func() string\n // It does not set the returned State.IsExpensive. The caller can populate that.\n //\n // Deprecated: use netmon.Monitor.InterfaceState instead.\n-func GetState() (*State, error) {\n+func getState() (*State, error) {\n \ts := &State{\n \t\tInterfaceIPs: make(map[string][]netip.Prefix),\n \t\tInterface:    make(map[string]Interface),\n---\n\n\n---\n\nChoice B:\ncmd/k8s-operator/deploy/chart/templates/deployment.yaml\n@@ -64,6 +64,8 @@ spec:\n               value: operator\n             - name: OPERATOR_LOGGING\n               value: {{ .Values.operatorConfig.logging }}\n+            - name: OPERATOR_EPHEMERAL\n+              value: \"{{ .Values.operatorConfig.ephemeral }}\"\n             - name: OPERATOR_NAMESPACE\n               valueFrom:\n                 fieldRef:\n---\ncmd/k8s-operator/deploy/chart/values.yaml\n@@ -36,6 +36,10 @@ operatorConfig:\n   # Multiple tags are defined as array items and passed to the operator as a comma-separated string\n   defaultTags:\n     - \"tag:k8s-operator\"\n+  \n+  # When true, the operator will use an ephemeral auth key\n+  # https://tailscale.com/kb/1111/ephemeral-nodes/\n+  ephemeral: false\n \n   image:\n     # Repository defaults to DockerHub, but images are also synced to ghcr.io/tailscale/k8s-operator.\n---\ncmd/k8s-operator/deploy/crds/tailscale.com_proxyclasses.yaml\n@@ -2215,6 +2215,14 @@ spec:\n                         https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n                         Defaults to false.\n                       type: boolean\n+                    ephemeral:\n+                      description: |-\n+                        Ephemeral can be set to true to make the proxy instance register\n+                        as an ephemeral node. Ephemeral nodes are automatically deleted\n+                        from the tailnet when they are offline for a while.\n+                        https://tailscale.com/kb/1111/ephemeral-nodes/\n+                        Defaults to false.\n+                      type: boolean\n                 useLetsEncryptStagingEnvironment:\n                   description: |-\n                     Set UseLetsEncryptStagingEnvironment to true to issue TLS\n---\ncmd/k8s-operator/deploy/manifests/operator.yaml\n@@ -2684,6 +2684,14 @@ spec:\n                                             https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n                                             Defaults to false.\n                                         type: boolean\n+                                    ephemeral:\n+                                        description: |-\n+                                            Ephemeral can be set to true to make the proxy instance register\n+                                            as an ephemeral node. Ephemeral nodes are automatically deleted\n+                                            from the tailnet when they are offline for a while.\n+                                            https://tailscale.com/kb/1111/ephemeral-nodes/\n+                                            Defaults to false.\n+                                        type: boolean\n                                 type: object\n                             useLetsEncryptStagingEnvironment:\n                                 description: |-\n@@ -5009,6 +5017,8 @@ spec:\n                       value: operator\n                     - name: OPERATOR_LOGGING\n                       value: info\n+                    - name: OPERATOR_EPHEMERAL\n+                      value: \"false\"\n                     - name: OPERATOR_NAMESPACE\n                       valueFrom:\n                         fieldRef:\n---\ncmd/k8s-operator/operator.go\n@@ -139,6 +139,7 @@ func initTSNet(zlog *zap.SugaredLogger) (*tsnet.Server, tsClient) {\n \t\thostname         = defaultEnv(\"OPERATOR_HOSTNAME\", \"tailscale-operator\")\n \t\tkubeSecret       = defaultEnv(\"OPERATOR_SECRET\", \"\")\n \t\toperatorTags     = defaultEnv(\"OPERATOR_INITIAL_TAGS\", \"tag:k8s-operator\")\n+\t\tephemeral        = defaultBool(\"OPERATOR_EPHEMERAL\", false)\n \t)\n \tstartlog := zlog.Named(\"startup\")\n \tif clientIDPath == \"\" || clientSecretPath == \"\" {\n@@ -196,6 +197,7 @@ waitOnline:\n \t\t\t\t\tCreate: tailscale.KeyDeviceCreateCapabilities{\n \t\t\t\t\t\tReusable:      false,\n \t\t\t\t\t\tPreauthorized: true,\n+\t\t\t\t\t\tEphemeral:     ephemeral,\n \t\t\t\t\t\tTags:          strings.Split(operatorTags, \",\"),\n \t\t\t\t\t},\n \t\t\t\t},\n---\ncmd/k8s-operator/proxygroup.go\n@@ -477,7 +477,11 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t\tif len(tags) == 0 {\n \t\t\t\ttags = r.defaultTags\n \t\t\t}\n-\t\t\tauthKey, err = newAuthKey(ctx, r.tsClient, tags)\n+\t\t\tephemeral := false\n+\t\t\tif proxyClass != nil && proxyClass.Spec.TailscaleConfig != nil {\n+\t\t\t\tephemeral = proxyClass.Spec.TailscaleConfig.Ephemeral\n+\t\t\t}\n+\t\t\tauthKey, err = newAuthKey(ctx, r.tsClient, tags, ephemeral)\n \t\t\tif err != nil {\n \t\t\t\treturn \"\", err\n \t\t\t}\n---\ncmd/k8s-operator/sts.go\n@@ -376,7 +376,7 @@ func (a *tailscaleSTSReconciler) createOrGetSecret(ctx context.Context, logger *\n \t\tif len(tags) == 0 {\n \t\t\ttags = a.defaultTags\n \t\t}\n-\t\tauthKey, err = newAuthKey(ctx, a.tsClient, tags)\n+\t\tauthKey, err = newAuthKey(ctx, a.tsClient, tags, shouldUseEphemeral(stsC.ProxyClass))\n \t\tif err != nil {\n \t\t\treturn \"\", \"\", nil, err\n \t\t}\n@@ -511,12 +511,13 @@ func deviceInfo(sec *corev1.Secret, podUID string, log *zap.SugaredLogger) (dev\n \treturn dev, nil\n }\n \n-func newAuthKey(ctx context.Context, tsClient tsClient, tags []string) (string, error) {\n+func newAuthKey(ctx context.Context, tsClient tsClient, tags []string, ephemeral bool) (string, error) {\n \tcaps := tailscale.KeyCapabilities{\n \t\tDevices: tailscale.KeyDeviceCapabilities{\n \t\t\tCreate: tailscale.KeyDeviceCreateCapabilities{\n \t\t\t\tReusable:      false,\n \t\t\t\tPreauthorized: true,\n+\t\t\t\tEphemeral:     ephemeral,\n \t\t\t\tTags:          tags,\n \t\t\t},\n \t\t},\n@@ -1022,6 +1023,10 @@ func shouldAcceptRoutes(pc *tsapi.ProxyClass) bool {\n \treturn pc != nil && pc.Spec.TailscaleConfig != nil && pc.Spec.TailscaleConfig.AcceptRoutes\n }\n \n+func shouldUseEphemeral(pc *tsapi.ProxyClass) bool {\n+\treturn pc != nil && pc.Spec.TailscaleConfig != nil && pc.Spec.TailscaleConfig.Ephemeral\n+}\n+\n // ptrObject is a type constraint for pointer types that implement\n // client.Object.\n type ptrObject[T any] interface {\n---\ncmd/k8s-operator/tsrecorder.go\n@@ -289,7 +289,7 @@ func (r *RecorderReconciler) ensureAuthSecretCreated(ctx context.Context, tsr *t\n \tif len(tags) == 0 {\n \t\ttags = tsapi.Tags{\"tag:k8s\"}\n \t}\n-\tauthKey, err := newAuthKey(ctx, r.tsClient, tags.Stringify())\n+\tauthKey, err := newAuthKey(ctx, r.tsClient, tags.Stringify(), false)\n \tif err != nil {\n \t\treturn err\n \t}\n---\nk8s-operator/api.md\n@@ -1013,5 +1013,6 @@ _Appears in:_\n | Field | Description | Default | Validation |\n | --- | --- | --- | --- |\n | `acceptRoutes` _boolean_ | AcceptRoutes can be set to true to make the proxy instance accept<br />routes advertized by other nodes on the tailnet, such as subnet<br />routes.<br />This is equivalent of passing --accept-routes flag to a tailscale Linux client.<br />https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices<br />Defaults to false. |  |  |\n+| `ephemeral` _boolean_ | Ephemeral can be set to true to make the proxy instance register<br />as an ephemeral node. Ephemeral nodes are automatically deleted<br />from the tailnet when they are offline for a while.<br />https://tailscale.com/kb/1111/ephemeral-nodes/<br />Defaults to false. |  |  |\n \n \n---\nk8s-operator/apis/v1alpha1/types_proxyclass.go\n@@ -91,6 +91,13 @@ type TailscaleConfig struct {\n \t// https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices\n \t// Defaults to false.\n \tAcceptRoutes bool `json:\"acceptRoutes,omitempty\"`\n+\n+\t// Ephemeral can be set to true to make the proxy instance register\n+\t// as an ephemeral node. Ephemeral nodes are automatically deleted\n+\t// from the tailnet when they are offline for a while.\n+\t// https://tailscale.com/kb/1111/ephemeral-nodes/\n+\t// Defaults to false.\n+\tEphemeral bool `json:\"ephemeral,omitempty\"`\n }\n \n type StatefulSet struct {\n---\n\n\n---\n\nChoice C:\ntstest/integration/testcontrol/testcontrol.go\n@@ -839,15 +839,17 @@ func (s *Server) serveMap(w http.ResponseWriter, r *http.Request, mkey key.Machi\n \n \tw.WriteHeader(200)\n \tfor {\n-\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n-\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n-\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif streaming {\n+\t\t// Only send raw map responses to the streaming poll, to avoid a\n+\t\t// non-streaming map request beating the streaming poll in a race and\n+\t\t// potentially dropping the map response.\n+\t\tif streaming {\n+\t\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n+\t\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n+\t\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treturn\n \t\t}\n \n \t\tif s.canGenerateAutomaticMapResponseFor(req.NodeKey) {\n---\n\n\n---\n\nChoice D:\ndocs/commit-messages.md\n@@ -1,16 +1,12 @@\n # Commit messages\n \n+There are different styles of commit messages followed by different projects.\n This is Tailscale's style guide for writing git commit messages.\n-\n As with all style guides, many things here are subjective and exist primarily to\n codify existing conventions and promote uniformity and thus ease of reading by\n others. Others have stronger reasons, such as interop with tooling or making\n future git archaeology easier.\n \n-# Commit Messages\n-\n-There are different styles of commit messages followed by different projects.\n-\n Our commit message style is largely based on the Go language's style, which\n shares much in common with the Linux kernel's git commit message style (for\n which git was invented):\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nWhen an event bus is plumbed in, use it to subscribe and react to port mapping\nupdates instead of using the client's callback mechanism. For now, the callback\nremains available as a fallback when an event bus is not provided.\n\nUpdates #15160\n\nChange-Id: I026adca44bf6187692ee87ae8ec02641c12f7774\nSigned-off-by: M. J. Fromberger <fromberger@tailscale.com>\n\n\n---\n\nChoice A:\nrelease/dist/cli/cli.go\n@@ -65,6 +65,7 @@ func CLI(getTargets func() ([]dist.Target, error)) *ffcli.Command {\n \t\t\t\t\tfs.StringVar(&buildArgs.manifest, \"manifest\", \"\", \"manifest file to write\")\n \t\t\t\t\tfs.BoolVar(&buildArgs.verbose, \"verbose\", false, \"verbose logging\")\n \t\t\t\t\tfs.StringVar(&buildArgs.webClientRoot, \"web-client-root\", \"\", \"path to root of web client source to build\")\n+\t\t\t\t\tfs.StringVar(&buildArgs.outPath, \"out\", \"\", \"path to write output artifacts (defaults to '$PWD/dist' if not set)\")\n \t\t\t\t\treturn fs\n \t\t\t\t})(),\n \t\t\t\tLongHelp: strings.TrimSpace(`\n@@ -156,6 +157,7 @@ var buildArgs struct {\n \tmanifest      string\n \tverbose       bool\n \twebClientRoot string\n+\toutPath       string\n }\n \n func runBuild(ctx context.Context, filters []string, targets []dist.Target) error {\n@@ -172,7 +174,11 @@ func runBuild(ctx context.Context, filters []string, targets []dist.Target) erro\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting working directory: %w\", err)\n \t}\n-\tb, err := dist.NewBuild(wd, filepath.Join(wd, \"dist\"))\n+\toutPath := filepath.Join(wd, \"dist\")\n+\tif buildArgs.outPath != \"\" {\n+\t\toutPath = buildArgs.outPath\n+\t}\n+\tb, err := dist.NewBuild(wd, outPath)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"creating build context: %w\", err)\n \t}\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -6146,17 +6146,17 @@ func (b *LocalBackend) setTCPPortsInterceptedFromNetmapAndPrefsLocked(prefs ipn.\n \t\t}\n \t}\n \n-\t// Update funnel info in hostinfo and kick off control update if needed.\n-\tb.updateIngressLocked()\n+\t// Update funnel and service hash info in hostinfo and kick off control update if needed.\n+\tb.updateIngressAndServiceHashLocked(prefs)\n \tb.setTCPPortsIntercepted(handlePorts)\n \tb.setVIPServicesTCPPortsInterceptedLocked(vipServicesPorts)\n }\n \n-// updateIngressLocked updates the hostinfo.WireIngress and hostinfo.IngressEnabled fields and kicks off a Hostinfo\n-// update if the values have changed.\n+// updateIngressAndServiceHashLocked updates the hostinfo.ServicesHash, hostinfo.WireIngress and\n+// hostinfo.IngressEnabled fields and kicks off a Hostinfo update if the values have changed.\n //\n // b.mu must be held.\n-func (b *LocalBackend) updateIngressLocked() {\n+func (b *LocalBackend) updateIngressAndServiceHashLocked(prefs ipn.PrefsView) {\n \tif b.hostinfo == nil {\n \t\treturn\n \t}\n@@ -6171,6 +6171,11 @@ func (b *LocalBackend) updateIngressLocked() {\n \t\tb.hostinfo.WireIngress = wire\n \t\thostInfoChanged = true\n \t}\n+\tlatestHash := b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\tif b.hostinfo.ServicesHash != latestHash {\n+\t\tb.hostinfo.ServicesHash = latestHash\n+\t\thostInfoChanged = true\n+\t}\n \t// Kick off a Hostinfo update to control if ingress status has changed.\n \tif hostInfoChanged {\n \t\tb.goTracker.Go(b.doSetHostinfoFilterServices)\n---\nipn/ipnlocal/local_test.go\n@@ -5134,10 +5134,17 @@ func TestUpdatePrefsOnSysPolicyChange(t *testing.T) {\n \t}\n }\n \n-func TestUpdateIngressLocked(t *testing.T) {\n+func TestUpdateIngressAndServiceHashLocked(t *testing.T) {\n+\tprefs := ipn.NewPrefs().View()\n+\tpreviousSC := &ipn.ServeConfig{\n+\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\"svc:abc\": {Tun: true},\n+\t\t},\n+\t}\n \ttests := []struct {\n \t\tname              string\n \t\thi                *tailcfg.Hostinfo\n+\t\thasPreviousSC     bool // whether to overwrite the ServeConfig hash in the Hostinfo using previousSC\n \t\tsc                *ipn.ServeConfig\n \t\twantIngress       bool\n \t\twantWireIngress   bool\n@@ -5163,6 +5170,16 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantWireIngress:   false, // implied by wantIngress\n \t\t\twantControlUpdate: true,\n \t\t},\n+\t\t{\n+\t\t\tname: \"empty_hostinfo_service_configured\",\n+\t\t\thi:   &tailcfg.Hostinfo{},\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t\t{\n \t\t\tname: \"empty_hostinfo_funnel_disabled\",\n \t\t\thi:   &tailcfg.Hostinfo{},\n@@ -5175,7 +5192,7 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantControlUpdate: true,\n \t\t},\n \t\t{\n-\t\t\tname: \"empty_hostinfo_no_funnel\",\n+\t\t\tname: \"empty_hostinfo_no_funnel_no_service\",\n \t\t\thi:   &tailcfg.Hostinfo{},\n \t\t\tsc: &ipn.ServeConfig{\n \t\t\t\tTCP: map[uint16]*ipn.TCPPortHandler{\n@@ -5196,6 +5213,16 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantIngress:     true,\n \t\t\twantWireIngress: false, // implied by wantIngress\n \t\t},\n+\t\t{\n+\t\t\tname:          \"service_hash_no_change\",\n+\t\t\thi:            &tailcfg.Hostinfo{},\n+\t\t\thasPreviousSC: true,\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n \t\t{\n \t\t\tname: \"funnel_disabled_no_change\",\n \t\t\thi: &tailcfg.Hostinfo{\n@@ -5208,6 +5235,13 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t},\n \t\t\twantWireIngress: true, // true if there is any AllowFunnel block\n \t\t},\n+\t\t{\n+\t\t\tname:              \"service_got_removed\",\n+\t\t\thi:                &tailcfg.Hostinfo{},\n+\t\t\thasPreviousSC:     true,\n+\t\t\tsc:                &ipn.ServeConfig{},\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t\t{\n \t\t\tname: \"funnel_changes_to_disabled\",\n \t\t\thi: &tailcfg.Hostinfo{\n@@ -5235,12 +5269,35 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\twantWireIngress:   false, // implied by wantIngress\n \t\t\twantControlUpdate: true,\n \t\t},\n+\t\t{\n+\t\t\tname: \"both_funnel_and_service_changes\",\n+\t\t\thi: &tailcfg.Hostinfo{\n+\t\t\t\tIngressEnabled: true,\n+\t\t\t},\n+\t\t\tsc: &ipn.ServeConfig{\n+\t\t\t\tAllowFunnel: map[ipn.HostPort]bool{\n+\t\t\t\t\t\"tailnet.xyz:443\": false,\n+\t\t\t\t},\n+\t\t\t\tServices: map[tailcfg.ServiceName]*ipn.ServiceConfig{\n+\t\t\t\t\t\"svc:abc\": {Tun: true},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantWireIngress:   true, // true if there is any AllowFunnel block\n+\t\t\twantControlUpdate: true,\n+\t\t},\n \t}\n \n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tt.Parallel()\n \t\t\tb := newTestLocalBackend(t)\n \t\t\tb.hostinfo = tt.hi\n+\t\t\tif tt.hasPreviousSC {\n+\t\t\t\tb.mu.Lock()\n+\t\t\t\tb.serveConfig = previousSC.View()\n+\t\t\t\tb.hostinfo.ServicesHash = b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\t\t\t\tb.mu.Unlock()\n+\t\t\t}\n \t\t\tb.serveConfig = tt.sc.View()\n \t\t\tallDone := make(chan bool, 1)\n \t\t\tdefer b.goTracker.AddDoneCallback(func() {\n@@ -5256,7 +5313,7 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t})()\n \n \t\t\twas := b.goTracker.StartedGoroutines()\n-\t\t\tb.updateIngressLocked()\n+\t\t\tb.updateIngressAndServiceHashLocked(prefs)\n \n \t\t\tif tt.hi != nil {\n \t\t\t\tif tt.hi.IngressEnabled != tt.wantIngress {\n@@ -5265,6 +5322,12 @@ func TestUpdateIngressLocked(t *testing.T) {\n \t\t\t\tif tt.hi.WireIngress != tt.wantWireIngress {\n \t\t\t\t\tt.Errorf(\"WireIngress = %v, want %v\", tt.hi.WireIngress, tt.wantWireIngress)\n \t\t\t\t}\n+\t\t\t\tb.mu.Lock()\n+\t\t\t\tsvcHash := b.vipServiceHash(b.vipServicesFromPrefsLocked(prefs))\n+\t\t\t\tb.mu.Unlock()\n+\t\t\t\tif tt.hi.ServicesHash != svcHash {\n+\t\t\t\t\tt.Errorf(\"ServicesHash = %v, want %v\", tt.hi.ServicesHash, svcHash)\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tstartedGoroutine := b.goTracker.StartedGoroutines() != was\n---\n\n\n---\n\nChoice C:\nwgengine/magicsock/magicsock.go\n@@ -138,6 +138,7 @@ type Conn struct {\n \t// struct. Initialized once at construction, then constant.\n \n \teventBus               *eventbus.Bus\n+\teventClient            *eventbus.Client\n \tlogf                   logger.Logf\n \tepFunc                 func([]tailcfg.Endpoint)\n \tderpActiveFunc         func()\n@@ -547,6 +548,31 @@ func NewConn(opts Options) (*Conn, error) {\n \tc.testOnlyPacketListener = opts.TestOnlyPacketListener\n \tc.noteRecvActivity = opts.NoteRecvActivity\n \n+\t// If an event bus is enabled, subscribe to portmapping changes; otherwise\n+\t// use the callback mechanism of portmapper.Client.\n+\t//\n+\t// TODO(creachadair): Remove the switch once the event bus is mandatory.\n+\tonPortMapChanged := c.onPortMapChanged\n+\tif c.eventBus != nil {\n+\t\tc.eventClient = c.eventBus.Client(\"magicsock.Conn\")\n+\n+\t\tpmSub := eventbus.Subscribe[portmapper.Mapping](c.eventClient)\n+\t\tgo func() {\n+\t\t\tdefer pmSub.Close()\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase <-pmSub.Events():\n+\t\t\t\t\tc.onPortMapChanged()\n+\t\t\t\tcase <-pmSub.Done():\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\n+\t\t// Disable the explicit callback from the portmapper, the subscriber handles it.\n+\t\tonPortMapChanged = nil\n+\t}\n+\n \t// Don't log the same log messages possibly every few seconds in our\n \t// portmapper.\n \tportmapperLogf := logger.WithPrefix(c.logf, \"portmapper: \")\n@@ -560,7 +586,7 @@ func NewConn(opts Options) (*Conn, error) {\n \t\tNetMon:       opts.NetMon,\n \t\tDebugKnobs:   portMapOpts,\n \t\tControlKnobs: opts.ControlKnobs,\n-\t\tOnChange:     c.onPortMapChanged,\n+\t\tOnChange:     onPortMapChanged,\n \t})\n \tc.portMapper.SetGatewayLookupFunc(opts.NetMon.GatewayAndSelfIP)\n \tc.netMon = opts.NetMon\n@@ -2478,6 +2504,9 @@ func (c *connBind) Close() error {\n \tif c.closeDisco6 != nil {\n \t\tc.closeDisco6.Close()\n \t}\n+\tif c.eventClient != nil {\n+\t\tc.eventClient.Close()\n+\t}\n \t// Send an empty read result to unblock receiveDERP,\n \t// which will then check connBind.Closed.\n \t// connBind.Closed takes c.mu, but c.derpRecvCh is buffered.\n---\n\n\n---\n\nChoice D:\nbuild_dist.sh\n@@ -28,18 +28,26 @@ EOF\n \texit 0\n fi\n \n-tags=\"\"\n+tags=\"${TAGS:-}\"\n ldflags=\"-X tailscale.com/version.longStamp=${VERSION_LONG} -X tailscale.com/version.shortStamp=${VERSION_SHORT}\"\n \n # build_dist.sh arguments must precede go build arguments.\n while [ \"$#\" -gt 1 ]; do\n \tcase \"$1\" in\n \t--extra-small)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --extra-small or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\tldflags=\"$ldflags -w -s\"\n \t\ttags=\"${tags:+$tags,}ts_omit_aws,ts_omit_bird,ts_omit_tap,ts_omit_kube,ts_omit_completion,ts_omit_ssh,ts_omit_wakeonlan,ts_omit_capture\"\n \t\t;;\n \t--box)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --box or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\ttags=\"${tags:+$tags,}ts_include_cli\"\n \t\t;;\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #15404\n\n\n---\n\nChoice A:\nfeature/taildrop/integration_test.go\n@@ -26,6 +26,21 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n+\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n+\ttestTaildropIntegration(t, false)\n+}\n+\n+func TestTaildropIntegration_Fresh(t *testing.T) {\n+\ttestTaildropIntegration(t, true)\n+}\n+\n+// freshProfiles is whether to start the test right away\n+// with a fresh profile. If false, tailscaled is started, stopped,\n+// and restarted again to simulate a real-world scenario where\n+// the first profile already existed.\n+//\n+// This exercises an ipnext hook ordering issue we hit earlier.\n+func testTaildropIntegration(t *testing.T, freshProfiles bool) {\n \ttstest.Parallel(t)\n \tcontrolOpt := integration.ConfigureControl(func(s *testcontrol.Server) {\n \t\ts.AllNodesSameUser = true // required for Taildrop\n@@ -39,18 +54,30 @@ func TestTaildropIntegration(t *testing.T) {\n \tn2 := integration.NewTestNode(t, env)\n \td2 := n2.StartDaemon()\n \n-\tn1.AwaitListening()\n-\tt.Logf(\"n1 is listening\")\n-\tn2.AwaitListening()\n-\tt.Logf(\"n2 is listening\")\n-\tn1.MustUp()\n-\tt.Logf(\"n1 is up\")\n-\tn2.MustUp()\n-\tt.Logf(\"n2 is up\")\n-\tn1.AwaitRunning()\n-\tt.Logf(\"n1 is running\")\n-\tn2.AwaitRunning()\n-\tt.Logf(\"n2 is running\")\n+\tawaitUp := func() {\n+\t\tt.Helper()\n+\t\tn1.AwaitListening()\n+\t\tt.Logf(\"n1 is listening\")\n+\t\tn2.AwaitListening()\n+\t\tt.Logf(\"n2 is listening\")\n+\t\tn1.MustUp()\n+\t\tt.Logf(\"n1 is up\")\n+\t\tn2.MustUp()\n+\t\tt.Logf(\"n2 is up\")\n+\t\tn1.AwaitRunning()\n+\t\tt.Logf(\"n1 is running\")\n+\t\tn2.AwaitRunning()\n+\t\tt.Logf(\"n2 is running\")\n+\t}\n+\tawaitUp()\n+\n+\tif !freshProfiles {\n+\t\td1.MustCleanShutdown(t)\n+\t\td2.MustCleanShutdown(t)\n+\t\td1 = n1.StartDaemon()\n+\t\td2 = n2.StartDaemon()\n+\t\tawaitUp()\n+\t}\n \n \tvar peerStableID tailcfg.StableNodeID\n \n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -2404,11 +2404,9 @@ func (b *LocalBackend) Start(opts ipn.Options) error {\n \t}\n \n \tvar auditLogShutdown func()\n-\t// Audit logging is only available if the client has set up a proper persistent\n-\t// store for the logs in sys.\n \tstore, ok := b.sys.AuditLogStore.GetOK()\n \tif !ok {\n-\t\tb.logf(\"auditlog: [unexpected] no persistent audit log storage configured.  using memory store.\")\n+\t\t// Use memory store by default if no explicit store is provided.\n \t\tstore = auditlog.NewLogStore(&memstore.Store{})\n \t}\n \n---\n\n\n---\n\nChoice C:\nnet/dns/config.go\n@@ -10,6 +10,8 @@ import (\n \t\"net/netip\"\n \t\"sort\"\n \n+\t\"tailscale.com/control/controlknobs\"\n+\t\"tailscale.com/envknob\"\n \t\"tailscale.com/net/dns/publicdns\"\n \t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/tsaddr\"\n@@ -47,11 +49,28 @@ type Config struct {\n \tOnlyIPv6 bool\n }\n \n-func (c *Config) serviceIP() netip.Addr {\n+var magicDNSDualStack = envknob.RegisterBool(\"TS_DEBUG_MAGIC_DNS_DUAL_STACK\")\n+\n+// serviceIPs returns the list of service IPs where MagicDNS is reachable.\n+//\n+// The provided knobs may be nil.\n+func (c *Config) serviceIPs(knobs *controlknobs.Knobs) []netip.Addr {\n \tif c.OnlyIPv6 {\n-\t\treturn tsaddr.TailscaleServiceIPv6()\n+\t\treturn []netip.Addr{tsaddr.TailscaleServiceIPv6()}\n \t}\n-\treturn tsaddr.TailscaleServiceIP()\n+\n+\t// TODO(bradfitz,mikeodr,raggi): include IPv6 here too; tailscale/tailscale#15404\n+\t// And add a controlknobs knob to disable dual stack.\n+\t//\n+\t// For now, opt-in for testing.\n+\tif magicDNSDualStack() {\n+\t\treturn []netip.Addr{\n+\t\t\ttsaddr.TailscaleServiceIP(),\n+\t\t\ttsaddr.TailscaleServiceIPv6(),\n+\t\t}\n+\t}\n+\n+\treturn []netip.Addr{tsaddr.TailscaleServiceIP()}\n }\n \n // WriteToBufioWriter write a debug version of c for logs to w, omitting\n---\nnet/dns/manager.go\n@@ -307,7 +307,7 @@ func (m *Manager) compileConfig(cfg Config) (rcfg resolver.Config, ocfg OSConfig\n \t\t// through quad-100.\n \t\trcfg.Routes = routes\n \t\trcfg.Routes[\".\"] = cfg.DefaultResolvers\n-\t\tocfg.Nameservers = []netip.Addr{cfg.serviceIP()}\n+\t\tocfg.Nameservers = cfg.serviceIPs(m.knobs)\n \t\treturn rcfg, ocfg, nil\n \t}\n \n@@ -345,7 +345,7 @@ func (m *Manager) compileConfig(cfg Config) (rcfg resolver.Config, ocfg OSConfig\n \t// or routes + MagicDNS, or just MagicDNS, or on an OS that cannot\n \t// split-DNS. Install a split config pointing at quad-100.\n \trcfg.Routes = routes\n-\tocfg.Nameservers = []netip.Addr{cfg.serviceIP()}\n+\tocfg.Nameservers = cfg.serviceIPs(m.knobs)\n \n \tvar baseCfg *OSConfig // base config; non-nil if/when known\n \n---\n\n\n---\n\nChoice D:\ndocs/commit-messages.md\n@@ -1,16 +1,12 @@\n # Commit messages\n \n+There are different styles of commit messages followed by different projects.\n This is Tailscale's style guide for writing git commit messages.\n-\n As with all style guides, many things here are subjective and exist primarily to\n codify existing conventions and promote uniformity and thus ease of reading by\n others. Others have stronger reasons, such as interop with tooling or making\n future git archaeology easier.\n \n-# Commit Messages\n-\n-There are different styles of commit messages followed by different projects.\n-\n Our commit message style is largely based on the Go language's style, which\n shares much in common with the Linux kernel's git commit message style (for\n which git was invented):\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [actions/upload-artifact](https://github.com/actions/upload-artifact) from 4.6.1 to 4.6.2.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/actions/upload-artifact/releases\">actions/upload-artifact's releases</a>.</em></p>\n<blockquote>\n<h2>v4.6.2</h2>\n<h2>What's Changed</h2>\n<ul>\n<li>Update to use artifact 2.3.2 package &amp; prepare for new upload-artifact release by <a href=\"https://github.com/salmanmkc\"><code>@\u200bsalmanmkc</code></a> in <a href=\"https://redirect.github.com/actions/upload-artifact/pull/685\">actions/upload-artifact#685</a></li>\n</ul>\n<h2>New Contributors</h2>\n<ul>\n<li><a href=\"https://github.com/salmanmkc\"><code>@\u200bsalmanmkc</code></a> made their first contribution in <a href=\"https://redirect.github.com/actions/upload-artifact/pull/685\">actions/upload-artifact#685</a></li>\n</ul>\n<p><strong>Full Changelog</strong>: <a href=\"https://github.com/actions/upload-artifact/compare/v4...v4.6.2\">https://github.com/actions/upload-artifact/compare/v4...v4.6.2</a></p>\n</blockquote>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/actions/upload-artifact/commit/ea165f8d65b6e75b540449e92b4886f43607fa02\"><code>ea165f8</code></a> Merge pull request <a href=\"https://redirect.github.com/actions/upload-artifact/issues/685\">#685</a> from salmanmkc/salmanmkc/3-new-upload-artifacts-release</li>\n<li><a href=\"https://github.com/actions/upload-artifact/commit/08396203c179e13c71b9754ce3472ed71842eec0\"><code>0839620</code></a> Prepare for new release of actions/upload-artifact with new toolkit cache ver...</li>\n<li>See full diff in <a href=\"https://github.com/actions/upload-artifact/compare/4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1...ea165f8d65b6e75b540449e92b4886f43607fa02\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=actions/upload-artifact&package-manager=github_actions&previous-version=4.6.1&new-version=4.6.2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\ngo.mod\n@@ -272,7 +272,7 @@ require (\n \tgithub.com/gordonklaus/ineffassign v0.1.0 // indirect\n \tgithub.com/goreleaser/chglog v0.5.0 // indirect\n \tgithub.com/goreleaser/fileglob v1.3.0 // indirect\n-\tgithub.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30\n+\tgithub.com/gorilla/csrf v1.7.3\n \tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n \tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n \tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n---\ngo.sum\n@@ -524,8 +524,8 @@ github.com/goreleaser/fileglob v1.3.0 h1:/X6J7U8lbDpQtBvGcwwPS6OpzkNVlVEsFUVRx9+\n github.com/goreleaser/fileglob v1.3.0/go.mod h1:Jx6BoXv3mbYkEzwm9THo7xbr5egkAraxkGorbJb4RxU=\n github.com/goreleaser/nfpm/v2 v2.33.1 h1:EkdAzZyVhAI9JC1vjmjjbmnNzyH1J6Cu4JCsA7YcQuc=\n github.com/goreleaser/nfpm/v2 v2.33.1/go.mod h1:8wwWWvJWmn84xo/Sqiv0aMvEGTHlHZTXTEuVSgQpkIM=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30 h1:fiJdrgVBkjZ5B1HJ2WQwNOaXB+QyYcNXTA3t1XYLz0M=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n+github.com/gorilla/csrf v1.7.3 h1:BHWt6FTLZAb2HtWT5KDBf6qgpZzvtbp9QWDRKZMXJC0=\n+github.com/gorilla/csrf v1.7.3/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n github.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\n github.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\n github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=\n---\n\n\n---\n\nChoice B:\ntsnet/tsnet_test.go\n@@ -120,6 +120,7 @@ func startControl(t *testing.T) (controlURL string, control *testcontrol.Server)\n \t\t\tProxied: true,\n \t\t},\n \t\tMagicDNSDomain: \"tail-scale.ts.net\",\n+\t\tLogf:           t.Logf,\n \t}\n \tcontrol.HTTPTestServer = httptest.NewUnstartedServer(control)\n \tcontrol.HTTPTestServer.Start()\n@@ -221,7 +222,7 @@ func startServer(t *testing.T, ctx context.Context, controlURL, hostname string)\n \t\tgetCertForTesting: testCertRoot.getCert,\n \t}\n \tif *verboseNodes {\n-\t\ts.Logf = log.Printf\n+\t\ts.Logf = t.Logf\n \t}\n \tt.Cleanup(func() { s.Close() })\n \n---\n\n\n---\n\nChoice C:\nipn/localapi/localapi.go\n@@ -397,6 +397,15 @@ func (h *Handler) serveBugReport(w http.ResponseWriter, r *http.Request) {\n \t// OS-specific details\n \th.logf.JSON(1, \"UserBugReportOS\", osdiag.SupportInfo(osdiag.LogSupportInfoReasonBugReport))\n \n+\t// Tailnet lock details\n+\tst := h.b.NetworkLockStatus()\n+\tif st.Enabled {\n+\t\th.logf.JSON(1, \"UserBugReportTailnetLockStatus\", st)\n+\t\tif st.NodeKeySignature != nil {\n+\t\t\th.logf(\"user bugreport tailnet lock signature: %s\", st.NodeKeySignature.String())\n+\t\t}\n+\t}\n+\n \tif defBool(r.URL.Query().Get(\"diagnose\"), false) {\n \t\th.b.Doctor(r.Context(), logger.WithPrefix(h.logf, \"diag: \"))\n \t}\n---\n\n\n---\n\nChoice D:\n.github/workflows/test.yml\n@@ -485,7 +485,7 @@ jobs:\n       run: |\n         echo \"artifacts_path=$(realpath .)\" >> $GITHUB_ENV\n     - name: upload crash\n-      uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1\n+      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2\n       if: steps.run.outcome != 'success' && steps.build.outcome == 'success'\n       with:\n         name: artifacts\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [golangci/golangci-lint-action](https://github.com/golangci/golangci-lint-action) from 6.5.0 to 6.5.2.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/golangci/golangci-lint-action/releases\">golangci/golangci-lint-action's releases</a>.</em></p>\n<blockquote>\n<h2>v6.5.1</h2>\n<!-- raw HTML omitted -->\n<h2>What's Changed</h2>\n<h3>Changes</h3>\n<ul>\n<li>fix: octokit retry by <a href=\"https://github.com/ldez\"><code>@\u200bldez</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1193\">golangci/golangci-lint-action#1193</a></li>\n<li>feat: restrict action v6 on golangci-lint v1 by <a href=\"https://github.com/ldez\"><code>@\u200bldez</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1194\">golangci/golangci-lint-action#1194</a></li>\n</ul>\n<h3>Documentation</h3>\n<ul>\n<li>docs: add notes for annotation config by <a href=\"https://github.com/dveeden\"><code>@\u200bdveeden</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1173\">golangci/golangci-lint-action#1173</a></li>\n<li>docs: improve verify option explanation by <a href=\"https://github.com/ldez\"><code>@\u200bldez</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1175\">golangci/golangci-lint-action#1175</a></li>\n</ul>\n<h3>Dependencies</h3>\n<ul>\n<li>build(deps-dev): bump the dev-dependencies group with 3 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1177\">golangci/golangci-lint-action#1177</a></li>\n<li>build(deps): bump the dependencies group with 2 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1178\">golangci/golangci-lint-action#1178</a></li>\n<li>build(deps): bump <code>@\u200boctokit/request</code> from 8.4.0 to 8.4.1 by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1181\">golangci/golangci-lint-action#1181</a></li>\n<li>build(deps-dev): bump the dev-dependencies group with 3 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1185\">golangci/golangci-lint-action#1185</a></li>\n<li>build(deps): bump <code>@\u200btypes/node</code> from 22.13.4 to 22.13.5 in the dependencies group by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1186\">golangci/golangci-lint-action#1186</a></li>\n<li>build(deps): bump <code>@\u200boctokit/plugin-paginate-rest</code> from 9.2.1 to 9.2.2 by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1187\">golangci/golangci-lint-action#1187</a></li>\n<li>build(deps): bump the dependencies group with 2 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1189\">golangci/golangci-lint-action#1189</a></li>\n<li>build(deps-dev): bump the dev-dependencies group across 1 directory with 5 updates by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1190\">golangci/golangci-lint-action#1190</a></li>\n<li>build(deps-dev): bump eslint-config-prettier from 10.0.2 to 10.1.1 in the dev-dependencies group by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1191\">golangci/golangci-lint-action#1191</a></li>\n<li>build(deps): bump <code>@\u200btypes/node</code> from 22.13.8 to 22.13.10 in the dependencies group by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1192\">golangci/golangci-lint-action#1192</a></li>\n</ul>\n<h2>New Contributors</h2>\n<ul>\n<li><a href=\"https://github.com/dveeden\"><code>@\u200bdveeden</code></a> made their first contribution in <a href=\"https://redirect.github.com/golangci/golangci-lint-action/pull/1173\">golangci/golangci-lint-action#1173</a></li>\n</ul>\n<p><strong>Full Changelog</strong>: <a href=\"https://github.com/golangci/golangci-lint-action/compare/v6.5.0...v6.5.1\">https://github.com/golangci/golangci-lint-action/compare/v6.5.0...v6.5.1</a></p>\n</blockquote>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/55c2c1448f86e01eaae002a5a3a9624417608d84\"><code>55c2c14</code></a> 6.5.2</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/911ec56a221f2cb0322fe7e8a32026fafba0056f\"><code>911ec56</code></a> fix: update max version (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1201\">#1201</a>)</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/eb5c0cc4890366046baa605fa7592d303dea28e9\"><code>eb5c0cc</code></a> build(deps-dev): bump the dev-dependencies group with 2 updates (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1199\">#1199</a>)</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/4696ba8babb6127d732c3c6dde519db15edab9ea\"><code>4696ba8</code></a> 6.5.1</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/2ee514f1f31dd3d5f0ae6e6546082968a4b5e342\"><code>2ee514f</code></a> feat: restrict action v6 on golangci-lint v1 (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1194\">#1194</a>)</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/7e7b516e44d2b59c5a0e7095011ca654ef6df130\"><code>7e7b516</code></a> fix: octokit retry (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1193\">#1193</a>)</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/b871b4f9de8b829c8d43b0e3bcdf9a8a3f141a3b\"><code>b871b4f</code></a> build(deps): bump <code>@\u200btypes/node</code> from 22.13.8 to 22.13.10 in the dependencies gr...</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/08ba820282e7b504068939935e85f62c8eb73249\"><code>08ba820</code></a> build(deps-dev): bump eslint-config-prettier from 10.0.2 to 10.1.1 in the dev...</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/d8648ac2edec95c7927c492e5cfb10276c5ea71d\"><code>d8648ac</code></a> build(deps-dev): bump the dev-dependencies group across 1 directory with 5 up...</li>\n<li><a href=\"https://github.com/golangci/golangci-lint-action/commit/37d62ae433213da45128fd8921b10b86781db6c5\"><code>37d62ae</code></a> build(deps): bump the dependencies group with 2 updates (<a href=\"https://redirect.github.com/golangci/golangci-lint-action/issues/1189\">#1189</a>)</li>\n<li>Additional commits viewable in <a href=\"https://github.com/golangci/golangci-lint-action/compare/2226d7cb06a077cd73e56eedd38eecad18e5d837...55c2c1448f86e01eaae002a5a3a9624417608d84\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=golangci/golangci-lint-action&package-manager=github_actions&previous-version=6.5.0&new-version=6.5.2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\nwgengine/magicsock/magicsock_linux.go\n@@ -66,10 +66,10 @@ var (\n \t\t// fragmented, and we don't want to handle reassembly.\n \t\tbpf.LoadAbsolute{Off: 6, Size: 2},\n \t\t// More Fragments bit set means this is part of a fragmented packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 7, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x2000, SkipTrue: 8, SkipFalse: 0},\n \t\t// Non-zero fragment offset with MF=0 means this is the last\n \t\t// fragment of packet.\n-\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 6, SkipFalse: 0},\n+\t\tbpf.JumpIf{Cond: bpf.JumpBitsSet, Val: 0x1fff, SkipTrue: 7, SkipFalse: 0},\n \n \t\t// Load IP header length into X register.\n \t\tbpf.LoadMemShift{Off: 0},\n---\nwgengine/magicsock/magicsock_linux_test.go\n@@ -9,6 +9,7 @@ import (\n \t\"net/netip\"\n \t\"testing\"\n \n+\t\"golang.org/x/net/bpf\"\n \t\"golang.org/x/sys/cpu\"\n \t\"golang.org/x/sys/unix\"\n \t\"tailscale.com/disco\"\n@@ -146,3 +147,78 @@ func TestEthernetProto(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestBpfDiscardV4(t *testing.T) {\n+\t// Good packet as a reference for what should not be rejected\n+\tudp4Packet := []byte{\n+\t\t// IPv4 header\n+\t\t0x45, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x40, 0x11, 0x00, 0x00,\n+\t\t0x7f, 0x00, 0x00, 0x01, // source ip\n+\t\t0x7f, 0x00, 0x00, 0x02, // dest ip\n+\n+\t\t// UDP header\n+\t\t0x30, 0x39, // src port\n+\t\t0xd4, 0x31, // dest port\n+\t\t0x00, 0x12, // length; 8 bytes header + 10 bytes payload = 18 bytes\n+\t\t0x00, 0x00, // checksum; unused\n+\n+\t\t// Payload: disco magic plus 32 bytes for key and 24 bytes for nonce\n+\t\t0x54, 0x53, 0xf0, 0x9f, 0x92, 0xac, 0x00, 0x01, 0x02, 0x03,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n+\t}\n+\n+\tvm, err := bpf.NewVM(magicsockFilterV4)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed creating BPF VM: %v\", err)\n+\t}\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\treplace map[int]byte\n+\t\taccept  bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"base accepted datagram\",\n+\t\t\treplace: map[int]byte{},\n+\t\t\taccept:  true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"more fragments\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t6: 0x20,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some fragment\",\n+\t\t\treplace: map[int]byte{\n+\t\t\t\t7: 0x01,\n+\t\t\t},\n+\t\t\taccept: false,\n+\t\t},\n+\t}\n+\n+\tudp4PacketChanged := make([]byte, len(udp4Packet))\n+\tcopy(udp4PacketChanged, udp4Packet)\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tfor k, v := range tt.replace {\n+\t\t\t\tudp4PacketChanged[k] = v\n+\t\t\t}\n+\t\t\tret, err := vm.Run(udp4PacketChanged)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"BPF VM error: %v\", err)\n+\t\t\t}\n+\n+\t\t\tif (ret != 0) != tt.accept {\n+\t\t\t\tt.Errorf(\"expected accept=%v, got ret=%v\", tt.accept, ret)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\nChoice B:\n.github/workflows/golangci-lint.yml\n@@ -31,7 +31,7 @@ jobs:\n           cache: false\n \n       - name: golangci-lint\n-        uses: golangci/golangci-lint-action@2226d7cb06a077cd73e56eedd38eecad18e5d837 # v6.5.0\n+        uses: golangci/golangci-lint-action@55c2c1448f86e01eaae002a5a3a9624417608d84 # v6.5.2\n         with:\n           version: v1.64\n \n---\n\n\n---\n\nChoice C:\nsafesocket/safesocket.go\n@@ -61,7 +61,11 @@ func ConnectContext(ctx context.Context, path string) (net.Conn, error) {\n \t\t\tif ctx.Err() != nil {\n \t\t\t\treturn nil, ctx.Err()\n \t\t\t}\n-\t\t\ttime.Sleep(250 * time.Millisecond)\n+\t\t\tselect {\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\treturn nil, ctx.Err()\n+\t\t\tcase <-time.After(250 * time.Millisecond):\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\treturn c, err\n---\n\n\n---\n\nChoice D:\nbuild_dist.sh\n@@ -28,18 +28,26 @@ EOF\n \texit 0\n fi\n \n-tags=\"\"\n+tags=\"${TAGS:-}\"\n ldflags=\"-X tailscale.com/version.longStamp=${VERSION_LONG} -X tailscale.com/version.shortStamp=${VERSION_SHORT}\"\n \n # build_dist.sh arguments must precede go build arguments.\n while [ \"$#\" -gt 1 ]; do\n \tcase \"$1\" in\n \t--extra-small)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --extra-small or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\tldflags=\"$ldflags -w -s\"\n \t\ttags=\"${tags:+$tags,}ts_omit_aws,ts_omit_bird,ts_omit_tap,ts_omit_kube,ts_omit_completion,ts_omit_ssh,ts_omit_wakeonlan,ts_omit_capture\"\n \t\t;;\n \t--box)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --box or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\ttags=\"${tags:+$tags,}ts_include_cli\"\n \t\t;;\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [github/codeql-action](https://github.com/github/codeql-action) from 3.28.11 to 3.28.12.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/releases\">github/codeql-action's releases</a>.</em></p>\n<blockquote>\n<h2>v3.28.12</h2>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>3.28.12 - 19 Mar 2025</h2>\n<ul>\n<li>Dependency caching should now cache more dependencies for Java <code>build-mode: none</code> extractions. This should speed up workflows and avoid inconsistent alerts in some cases.</li>\n<li>Update default CodeQL bundle version to 2.20.7. <a href=\"https://redirect.github.com/github/codeql-action/pull/2810\">#2810</a></li>\n</ul>\n<p>See the full <a href=\"https://github.com/github/codeql-action/blob/v3.28.12/CHANGELOG.md\">CHANGELOG.md</a> for more information.</p>\n</blockquote>\n</details>\n<details>\n<summary>Changelog</summary>\n<p><em>Sourced from <a href=\"https://github.com/github/codeql-action/blob/main/CHANGELOG.md\">github/codeql-action's changelog</a>.</em></p>\n<blockquote>\n<h1>CodeQL Action Changelog</h1>\n<p>See the <a href=\"https://github.com/github/codeql-action/releases\">releases page</a> for the relevant changes to the CodeQL CLI and language packs.</p>\n<h2>[UNRELEASED]</h2>\n<p>No user facing changes.</p>\n<h2>3.28.12 - 19 Mar 2025</h2>\n<ul>\n<li>Dependency caching should now cache more dependencies for Java <code>build-mode: none</code> extractions. This should speed up workflows and avoid inconsistent alerts in some cases.</li>\n<li>Update default CodeQL bundle version to 2.20.7. <a href=\"https://redirect.github.com/github/codeql-action/pull/2810\">#2810</a></li>\n</ul>\n<h2>3.28.11 - 07 Mar 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.6. <a href=\"https://redirect.github.com/github/codeql-action/pull/2793\">#2793</a></li>\n</ul>\n<h2>3.28.10 - 21 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.5. <a href=\"https://redirect.github.com/github/codeql-action/pull/2772\">#2772</a></li>\n<li>Address an issue where the CodeQL Bundle would occasionally fail to decompress on macOS. <a href=\"https://redirect.github.com/github/codeql-action/pull/2768\">#2768</a></li>\n</ul>\n<h2>3.28.9 - 07 Feb 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.4. <a href=\"https://redirect.github.com/github/codeql-action/pull/2753\">#2753</a></li>\n</ul>\n<h2>3.28.8 - 29 Jan 2025</h2>\n<ul>\n<li>Enable support for Kotlin 2.1.10 when running with CodeQL CLI v2.20.3. <a href=\"https://redirect.github.com/github/codeql-action/pull/2744\">#2744</a></li>\n</ul>\n<h2>3.28.7 - 29 Jan 2025</h2>\n<p>No user facing changes.</p>\n<h2>3.28.6 - 27 Jan 2025</h2>\n<ul>\n<li>Re-enable debug artifact upload for CLI versions 2.20.3 or greater. <a href=\"https://redirect.github.com/github/codeql-action/pull/2726\">#2726</a></li>\n</ul>\n<h2>3.28.5 - 24 Jan 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.3. <a href=\"https://redirect.github.com/github/codeql-action/pull/2717\">#2717</a></li>\n</ul>\n<h2>3.28.4 - 23 Jan 2025</h2>\n<p>No user facing changes.</p>\n<h2>3.28.3 - 22 Jan 2025</h2>\n<ul>\n<li>Update default CodeQL bundle version to 2.20.2. <a href=\"https://redirect.github.com/github/codeql-action/pull/2707\">#2707</a></li>\n<li>Fix an issue downloading the CodeQL Bundle from a GitHub Enterprise Server instance which occurred when the CodeQL Bundle had been synced to the instance using the <a href=\"https://github.com/github/codeql-action-sync-tool\">CodeQL Action sync tool</a> and the Actions runner did not have Zstandard installed. <a href=\"https://redirect.github.com/github/codeql-action/pull/2710\">#2710</a></li>\n</ul>\n<!-- raw HTML omitted -->\n</blockquote>\n<p>... (truncated)</p>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/github/codeql-action/commit/5f8171a638ada777af81d42b55959a643bb29017\"><code>5f8171a</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2814\">#2814</a> from github/update-v3.28.12-6349095d1</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/bb59f7707d836b040802dbdf2ad1a16482d319da\"><code>bb59f77</code></a> Update changelog for v3.28.12</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/6349095d19ec30397ffb02a63b7aa4f867deb563\"><code>6349095</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2810\">#2810</a> from github/update-bundle/codeql-bundle-v2.20.7</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/d7d03fda1241f6b0b3fae460c9f19c6e887158ad\"><code>d7d03fd</code></a> Add changelog note</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/4e3a5342c5e8e627915b9a29b363f49da8c4a32e\"><code>4e3a534</code></a> Update default bundle to codeql-bundle-v2.20.7</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/55f023701cfc1e7d11ef2ae0c5ec3193dae4fce4\"><code>55f0237</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2802\">#2802</a> from github/mbg/dependency-caching/java-buildless</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/6a151cd77488e58567da1dcf953e7aeeaca4950c\"><code>6a151cd</code></a> Merge pull request <a href=\"https://redirect.github.com/github/codeql-action/issues/2811\">#2811</a> from github/dependabot/github_actions/actions-c2c311...</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/7866bcdb1b15b5d5cba0021b87f36d9f6d977156\"><code>7866bcd</code></a> Manually bump workflow to match autogenerated file</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/611289e0b0ce1f6fc14820f1b72edaed2de4ba2c\"><code>611289e</code></a> build(deps): bump ruby/setup-ruby in the actions group</li>\n<li><a href=\"https://github.com/github/codeql-action/commit/4c409a5b664afa7d5b12cd8487e310f286487472\"><code>4c409a5</code></a> Remove temporary dependency directory in <code>analyze</code> post action</li>\n<li>Additional commits viewable in <a href=\"https://github.com/github/codeql-action/compare/6bb031afdd8eb862ea3fc1848194185e076637e5...5f8171a638ada777af81d42b55959a643bb29017\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=github/codeql-action&package-manager=github_actions&previous-version=3.28.11&new-version=3.28.12)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\nipn/ipnlocal/taildrop.go\n@@ -194,8 +194,8 @@ func (b *LocalBackend) FileTargets() ([]*apitype.FileTarget, error) {\n \t\tif !p.Valid() || p.Hostinfo().OS() == \"tvOS\" {\n \t\t\treturn false\n \t\t}\n-\t\tif self != p.User() {\n-\t\t\treturn false\n+\t\tif self == p.User() {\n+\t\t\treturn true\n \t\t}\n \t\tif p.Addresses().Len() != 0 && cn.PeerHasCap(p.Addresses().At(0).Addr(), tailcfg.PeerCapabilityFileSharingTarget) {\n \t\t\t// Explicitly noted in the netmap ACL caps as a target.\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/peerapi.go\n@@ -1135,7 +1135,7 @@ func (h *peerAPIHandler) handleServeDrive(w http.ResponseWriter, r *http.Request\n \n \tp, err := drive.ParsePermissions(rawPerms)\n \tif err != nil {\n-\t\th.logf(\"taildrive: error parsing permissions: %w\", err.Error())\n+\t\th.logf(\"taildrive: error parsing permissions: %v\", err)\n \t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n \t\treturn\n \t}\n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -55,7 +55,7 @@ jobs:\n \n     # Initializes the CodeQL tools for scanning.\n     - name: Initialize CodeQL\n-      uses: github/codeql-action/init@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/init@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n       with:\n         languages: ${{ matrix.language }}\n         # If you wish to specify custom queries, you can do so here or in a config file.\n@@ -66,7 +66,7 @@ jobs:\n     # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n     # If this step fails, then you should remove it and run the build manually (see below)\n     - name: Autobuild\n-      uses: github/codeql-action/autobuild@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/autobuild@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n \n     # \u2139\ufe0f Command-line programs to run using the OS shell.\n     # \ud83d\udcda https://git.io/JvXDl\n@@ -80,4 +80,4 @@ jobs:\n     #   make release\n \n     - name: Perform CodeQL Analysis\n-      uses: github/codeql-action/analyze@6bb031afdd8eb862ea3fc1848194185e076637e5 # v3.28.11\n+      uses: github/codeql-action/analyze@5f8171a638ada777af81d42b55959a643bb29017 # v3.28.12\n---\n\n\n---\n\nChoice D:\ntstest/integration/integration_test.go\n@@ -1942,6 +1942,8 @@ func (n *testNode) AwaitIP6() netip.Addr {\n \n // AwaitRunning waits for n to reach the IPN state \"Running\".\n func (n *testNode) AwaitRunning() {\n+\tt := n.env.t\n+\tt.Helper()\n \tn.AwaitBackendState(\"Running\")\n }\n \n@@ -2015,7 +2017,7 @@ func (n *testNode) Status() (*ipnstate.Status, error) {\n \t}\n \tst := new(ipnstate.Status)\n \tif err := json.Unmarshal(out, st); err != nil {\n-\t\treturn nil, fmt.Errorf(\"decoding tailscale status JSON: %w\", err)\n+\t\treturn nil, fmt.Errorf(\"decoding tailscale status JSON: %w\\njson:\\n%s\", err, out)\n \t}\n \treturn st, nil\n }\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nBumps [actions/setup-go](https://github.com/actions/setup-go) from 5.3.0 to 5.4.0.\n<details>\n<summary>Release notes</summary>\n<p><em>Sourced from <a href=\"https://github.com/actions/setup-go/releases\">actions/setup-go's releases</a>.</em></p>\n<blockquote>\n<h2>v5.4.0</h2>\n<h2>What's Changed</h2>\n<h3>Dependency updates :</h3>\n<ul>\n<li>Upgrade semver from 7.6.0 to 7.6.3 by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/actions/setup-go/pull/535\">actions/setup-go#535</a></li>\n<li>Upgrade eslint-config-prettier from 8.10.0 to 10.0.1 by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/actions/setup-go/pull/536\">actions/setup-go#536</a></li>\n<li>Upgrade <code>@\u200baction/cache</code> from 4.0.0 to 4.0.2 by <a href=\"https://github.com/aparnajyothi-y\"><code>@\u200baparnajyothi-y</code></a> in <a href=\"https://redirect.github.com/actions/setup-go/pull/568\">actions/setup-go#568</a></li>\n<li>Upgrade undici from 5.28.4 to 5.28.5 by <a href=\"https://github.com/dependabot\"><code>@\u200bdependabot</code></a> in <a href=\"https://redirect.github.com/actions/setup-go/pull/541\">actions/setup-go#541</a></li>\n</ul>\n<h2>New Contributors</h2>\n<ul>\n<li><a href=\"https://github.com/aparnajyothi-y\"><code>@\u200baparnajyothi-y</code></a> made their first contribution in <a href=\"https://redirect.github.com/actions/setup-go/pull/568\">actions/setup-go#568</a></li>\n</ul>\n<p><strong>Full Changelog</strong>: <a href=\"https://github.com/actions/setup-go/compare/v5...v5.4.0\">https://github.com/actions/setup-go/compare/v5...v5.4.0</a></p>\n</blockquote>\n</details>\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/actions/setup-go/commit/0aaccfd150d50ccaeb58ebd88d36e91967a5f35b\"><code>0aaccfd</code></a> Bump undici from 5.28.4 to 5.28.5 (<a href=\"https://redirect.github.com/actions/setup-go/issues/541\">#541</a>)</li>\n<li><a href=\"https://github.com/actions/setup-go/commit/c4c114188661c0fa735e5b938764519fc6e8efa9\"><code>c4c1141</code></a> upgrade actions/cache to 4.0.2 (<a href=\"https://redirect.github.com/actions/setup-go/issues/568\">#568</a>)</li>\n<li><a href=\"https://github.com/actions/setup-go/commit/5a083d0e9a84784eb32078397cf5459adecb4c40\"><code>5a083d0</code></a> Bump eslint-config-prettier from 8.10.0 to 10.0.1 (<a href=\"https://redirect.github.com/actions/setup-go/issues/536\">#536</a>)</li>\n<li><a href=\"https://github.com/actions/setup-go/commit/1d82324e5352acd1afdae34b93def4fabce6599f\"><code>1d82324</code></a> Bump semver from 7.6.0 to 7.6.3 (<a href=\"https://redirect.github.com/actions/setup-go/issues/535\">#535</a>)</li>\n<li>See full diff in <a href=\"https://github.com/actions/setup-go/compare/f111f3307d8850f501ac008e886eec1fd1932a34...0aaccfd150d50ccaeb58ebd88d36e91967a5f35b\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\n[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=actions/setup-go&package-manager=github_actions&previous-version=5.3.0&new-version=5.4.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -5056,6 +5056,8 @@ func dnsConfigForNetmap(nm *netmap.NetworkMap, peers map[tailcfg.NodeID]tailcfg.\n \t\t!nm.GetAddresses().ContainsFunc(tsaddr.PrefixIs4)\n \tdcfg.OnlyIPv6 = selfV6Only\n \n+\twantAAAA := nm.AllCaps.Contains(tailcfg.NodeAttrMagicDNSPeerAAAA)\n+\n \t// Populate MagicDNS records. We do this unconditionally so that\n \t// quad-100 can always respond to MagicDNS queries, even if the OS\n \t// isn't configured to make MagicDNS resolution truly\n@@ -5092,7 +5094,7 @@ func dnsConfigForNetmap(nm *netmap.NetworkMap, peers map[tailcfg.NodeID]tailcfg.\n \t\t\t// https://github.com/tailscale/tailscale/issues/1152\n \t\t\t// tracks adding the right capability reporting to\n \t\t\t// enable AAAA in MagicDNS.\n-\t\t\tif addr.Addr().Is6() && have4 {\n+\t\t\tif addr.Addr().Is6() && have4 && !wantAAAA {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tips = append(ips, addr.Addr())\n---\ntailcfg/tailcfg.go\n@@ -160,7 +160,8 @@ type CapabilityVersion int\n //   - 113: 2025-01-20: Client communicates to control whether funnel is enabled by sending Hostinfo.IngressEnabled (#14688)\n //   - 114: 2025-01-30: NodeAttrMaxKeyDuration CapMap defined, clients might use it (no tailscaled code change) (#14829)\n //   - 115: 2025-03-07: Client understands DERPRegion.NoMeasureNoHome.\n-const CurrentCapabilityVersion CapabilityVersion = 115\n+//   - 116: 2025-05-05: Client serves MagicDNS \"AAAA\" if NodeAttrMagicDNSPeerAAAA set on self node\n+const CurrentCapabilityVersion CapabilityVersion = 116\n \n // ID is an integer ID for a user, node, or login allocated by the\n // control plane.\n@@ -2493,6 +2494,10 @@ const (\n \t// NodeAttrRelayClient permits the node to act as an underlay UDP relay\n \t// client. There are no expected values for this key in NodeCapMap.\n \tNodeAttrRelayClient NodeCapability = \"relay:client\"\n+\n+\t// NodeAttrMagicDNSPeerAAAA is a capability that tells the node's MagicDNS\n+\t// server to answer AAAA queries about its peers. See tailscale/tailscale#1152.\n+\tNodeAttrMagicDNSPeerAAAA NodeCapability = \"magicdns-aaaa\"\n )\n \n // SetDNSRequest is a request to add a DNS record.\n---\n\n\n---\n\nChoice B:\ntsnet/tsnet.go\n@@ -536,10 +536,7 @@ func (s *Server) start() (reterr error) {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\ts.rootPath, err = getTSNetDir(s.logf, confDir, prog)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\t\ts.rootPath = filepath.Join(confDir, \"tsnet-\"+prog)\n \t}\n \tif err := os.MkdirAll(s.rootPath, 0700); err != nil {\n \t\treturn err\n@@ -897,49 +894,6 @@ func (s *Server) getUDPHandlerForFlow(src, dst netip.AddrPort) (handler func(net\n \treturn func(c nettype.ConnPacketConn) { ln.handle(c) }, true\n }\n \n-// getTSNetDir usually just returns filepath.Join(confDir, \"tsnet-\"+prog)\n-// with no error.\n-//\n-// One special case is that it renames old \"tslib-\" directories to\n-// \"tsnet-\", and that rename might return an error.\n-//\n-// TODO(bradfitz): remove this maybe 6 months after 2022-03-17,\n-// once people (notably Tailscale corp services) have updated.\n-func getTSNetDir(logf logger.Logf, confDir, prog string) (string, error) {\n-\toldPath := filepath.Join(confDir, \"tslib-\"+prog)\n-\tnewPath := filepath.Join(confDir, \"tsnet-\"+prog)\n-\n-\tfi, err := os.Lstat(oldPath)\n-\tif os.IsNotExist(err) {\n-\t\t// Common path.\n-\t\treturn newPath, nil\n-\t}\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tif !fi.IsDir() {\n-\t\treturn \"\", fmt.Errorf(\"expected old tslib path %q to be a directory; got %v\", oldPath, fi.Mode())\n-\t}\n-\n-\t// At this point, oldPath exists and is a directory. But does\n-\t// the new path exist?\n-\n-\tfi, err = os.Lstat(newPath)\n-\tif err == nil && fi.IsDir() {\n-\t\t// New path already exists somehow. Ignore the old one and\n-\t\t// don't try to migrate it.\n-\t\treturn newPath, nil\n-\t}\n-\tif err != nil && !os.IsNotExist(err) {\n-\t\treturn \"\", err\n-\t}\n-\tif err := os.Rename(oldPath, newPath); err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tlogf(\"renamed old tsnet state storage directory %q to %q\", oldPath, newPath)\n-\treturn newPath, nil\n-}\n-\n // APIClient returns a tailscale.Client that can be used to make authenticated\n // requests to the Tailscale control server.\n // It requires the user to set tailscale.I_Acknowledge_This_API_Is_Unstable.\n---\n\n\n---\n\nChoice C:\n.github/workflows/codeql-analysis.yml\n@@ -49,7 +49,7 @@ jobs:\n \n     # Install a more recent Go that understands modern go.mod content.\n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n \n---\n.github/workflows/golangci-lint.yml\n@@ -25,7 +25,7 @@ jobs:\n     steps:\n       - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n-      - uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      - uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n         with:\n           go-version-file: go.mod\n           cache: false\n---\n.github/workflows/test.yml\n@@ -151,7 +151,7 @@ jobs:\n       uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n \n     - name: Install Go\n-      uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+      uses: actions/setup-go@0aaccfd150d50ccaeb58ebd88d36e91967a5f35b # v5.4.0\n       with:\n         go-version-file: go.mod\n         cache: false\n---\n\n\n---\n\nChoice D:\nlogpolicy/logpolicy.go\n@@ -518,8 +518,9 @@ type Options struct {\n \tMaxUploadSize int\n }\n \n-// New returns a new log policy (a logger and its instance ID).\n-func (opts Options) New() *Policy {\n+// init initializes the log policy and returns a logtail.Config and the\n+// Policy.\n+func (opts Options) init(disableLogging bool) (*logtail.Config, *Policy) {\n \tif hostinfo.IsNATLabGuestVM() {\n \t\t// In NATLab Gokrazy instances, tailscaled comes up concurently with\n \t\t// DHCP and the doesn't have DNS for a while. Wait for DHCP first.\n@@ -628,7 +629,7 @@ func (opts Options) New() *Policy {\n \t\tconf.IncludeProcSequence = true\n \t}\n \n-\tif envknob.NoLogsNoSupport() || testenv.InTest() || runtime.GOOS == \"plan9\" {\n+\tif disableLogging {\n \t\topts.Logf(\"You have disabled logging. Tailscale will not be able to provide support.\")\n \t\tconf.HTTPC = &http.Client{Transport: noopPretendSuccessTransport{}}\n \t} else {\n@@ -637,14 +638,15 @@ func (opts Options) New() *Policy {\n \t\tattachFilchBuffer(&conf, opts.Dir, opts.CmdName, opts.MaxBufferSize, opts.Logf)\n \t\tconf.HTTPC = opts.HTTPC\n \n+\t\tlogHost := logtail.DefaultHost\n+\t\tif val := getLogTarget(); val != \"\" {\n+\t\t\topts.Logf(\"You have enabled a non-default log target. Doing without being told to by Tailscale staff or your network administrator will make getting support difficult.\")\n+\t\t\tconf.BaseURL = val\n+\t\t\tu, _ := url.Parse(val)\n+\t\t\tlogHost = u.Host\n+\t\t}\n+\n \t\tif conf.HTTPC == nil {\n-\t\t\tlogHost := logtail.DefaultHost\n-\t\t\tif val := getLogTarget(); val != \"\" {\n-\t\t\t\topts.Logf(\"You have enabled a non-default log target. Doing without being told to by Tailscale staff or your network administrator will make getting support difficult.\")\n-\t\t\t\tconf.BaseURL = val\n-\t\t\t\tu, _ := url.Parse(val)\n-\t\t\t\tlogHost = u.Host\n-\t\t\t}\n \t\t\tconf.HTTPC = &http.Client{Transport: TransportOptions{\n \t\t\t\tHost:   logHost,\n \t\t\t\tNetMon: opts.NetMon,\n@@ -680,13 +682,20 @@ func (opts Options) New() *Policy {\n \t\topts.Logf(\"%s\", earlyErrBuf.Bytes())\n \t}\n \n-\treturn &Policy{\n+\treturn &conf, &Policy{\n \t\tLogtail:  lw,\n \t\tPublicID: newc.PublicID,\n \t\tLogf:     opts.Logf,\n \t}\n }\n \n+// New returns a new log policy (a logger and its instance ID).\n+func (opts Options) New() *Policy {\n+\tdisableLogging := envknob.NoLogsNoSupport() || testenv.InTest() || runtime.GOOS == \"plan9\"\n+\t_, policy := opts.init(disableLogging)\n+\treturn policy\n+}\n+\n // attachFilchBuffer creates an on-disk ring buffer using filch and attaches\n // it to the logtail config. Note that this is optional; if no buffer is set,\n // logtail will use an in-memory buffer.\n---\nlogpolicy/logpolicy_test.go\n@@ -4,19 +4,22 @@\n package logpolicy\n \n import (\n+\t\"net/http\"\n \t\"os\"\n \t\"reflect\"\n \t\"testing\"\n \n \t\"tailscale.com/logtail\"\n )\n \n-func TestLogHost(t *testing.T) {\n+func resetLogTarget() {\n+\tos.Unsetenv(\"TS_LOG_TARGET\")\n \tv := reflect.ValueOf(&getLogTargetOnce).Elem()\n-\treset := func() {\n-\t\tv.Set(reflect.Zero(v.Type()))\n-\t}\n-\tdefer reset()\n+\tv.Set(reflect.Zero(v.Type()))\n+}\n+\n+func TestLogHost(t *testing.T) {\n+\tdefer resetLogTarget()\n \n \ttests := []struct {\n \t\tenv  string\n@@ -29,10 +32,55 @@ func TestLogHost(t *testing.T) {\n \t\t{\"https://foo.com:123/\", \"foo.com\"},\n \t}\n \tfor _, tt := range tests {\n-\t\treset()\n+\t\tresetLogTarget()\n \t\tos.Setenv(\"TS_LOG_TARGET\", tt.env)\n \t\tif got := LogHost(); got != tt.want {\n \t\t\tt.Errorf(\"for env %q, got %q, want %q\", tt.env, got, tt.want)\n \t\t}\n \t}\n }\n+func TestOptions(t *testing.T) {\n+\tdefer resetLogTarget()\n+\n+\ttests := []struct {\n+\t\tname        string\n+\t\topts        func() Options\n+\t\twantBaseURL string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"default\",\n+\t\t\topts:        func() Options { return Options{} },\n+\t\t\twantBaseURL: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom_baseurl\",\n+\t\t\topts: func() Options {\n+\t\t\t\tos.Setenv(\"TS_LOG_TARGET\", \"http://localhost:1234\")\n+\t\t\t\treturn Options{}\n+\t\t\t},\n+\t\t\twantBaseURL: \"http://localhost:1234\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom_httpc_and_baseurl\",\n+\t\t\topts: func() Options {\n+\t\t\t\tos.Setenv(\"TS_LOG_TARGET\", \"http://localhost:12345\")\n+\t\t\t\treturn Options{HTTPC: &http.Client{Transport: noopPretendSuccessTransport{}}}\n+\t\t\t},\n+\t\t\twantBaseURL: \"http://localhost:12345\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresetLogTarget()\n+\t\t\tconfig, policy := tt.opts().init(false)\n+\t\t\tif policy == nil {\n+\t\t\t\tt.Fatal(\"unexpected nil policy\")\n+\t\t\t}\n+\t\t\tif config.BaseURL != tt.wantBaseURL {\n+\t\t\t\tt.Errorf(\"got %q, want %q\", config.BaseURL, tt.wantBaseURL)\n+\t\t\t}\n+\t\t\tpolicy.Close()\n+\t\t})\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nI noticed logs on one of my machines where it can't auto-update with\nscary log spam about \"failed to apply tailnet-wide default for\nauto-updates\".\n\nThis avoids trying to do the EditPrefs if we know it's just going to\nfail anyway.\n\nUpdates #282\n\n\n---\n\nChoice A:\nfeature/taildrop/integration_test.go\n@@ -26,6 +26,21 @@ import (\n // TODO(bradfitz): add test between different users with the peercap to permit that?\n \n func TestTaildropIntegration(t *testing.T) {\n+\tt.Skip(\"known failing test; see https://github.com/tailscale/tailscale/issues/15970\")\n+\ttestTaildropIntegration(t, false)\n+}\n+\n+func TestTaildropIntegration_Fresh(t *testing.T) {\n+\ttestTaildropIntegration(t, true)\n+}\n+\n+// freshProfiles is whether to start the test right away\n+// with a fresh profile. If false, tailscaled is started, stopped,\n+// and restarted again to simulate a real-world scenario where\n+// the first profile already existed.\n+//\n+// This exercises an ipnext hook ordering issue we hit earlier.\n+func testTaildropIntegration(t *testing.T, freshProfiles bool) {\n \ttstest.Parallel(t)\n \tcontrolOpt := integration.ConfigureControl(func(s *testcontrol.Server) {\n \t\ts.AllNodesSameUser = true // required for Taildrop\n@@ -39,18 +54,30 @@ func TestTaildropIntegration(t *testing.T) {\n \tn2 := integration.NewTestNode(t, env)\n \td2 := n2.StartDaemon()\n \n-\tn1.AwaitListening()\n-\tt.Logf(\"n1 is listening\")\n-\tn2.AwaitListening()\n-\tt.Logf(\"n2 is listening\")\n-\tn1.MustUp()\n-\tt.Logf(\"n1 is up\")\n-\tn2.MustUp()\n-\tt.Logf(\"n2 is up\")\n-\tn1.AwaitRunning()\n-\tt.Logf(\"n1 is running\")\n-\tn2.AwaitRunning()\n-\tt.Logf(\"n2 is running\")\n+\tawaitUp := func() {\n+\t\tt.Helper()\n+\t\tn1.AwaitListening()\n+\t\tt.Logf(\"n1 is listening\")\n+\t\tn2.AwaitListening()\n+\t\tt.Logf(\"n2 is listening\")\n+\t\tn1.MustUp()\n+\t\tt.Logf(\"n1 is up\")\n+\t\tn2.MustUp()\n+\t\tt.Logf(\"n2 is up\")\n+\t\tn1.AwaitRunning()\n+\t\tt.Logf(\"n1 is running\")\n+\t\tn2.AwaitRunning()\n+\t\tt.Logf(\"n2 is running\")\n+\t}\n+\tawaitUp()\n+\n+\tif !freshProfiles {\n+\t\td1.MustCleanShutdown(t)\n+\t\td2.MustCleanShutdown(t)\n+\t\td1 = n1.StartDaemon()\n+\t\td2 = n2.StartDaemon()\n+\t\tawaitUp()\n+\t}\n \n \tvar peerStableID tailcfg.StableNodeID\n \n---\n\n\n---\n\nChoice B:\nutil/testenv/testenv.go\n@@ -6,6 +6,7 @@\n package testenv\n \n import (\n+\t\"context\"\n \t\"flag\"\n \n \t\"tailscale.com/types/lazy\"\n@@ -19,3 +20,41 @@ func InTest() bool {\n \t\treturn flag.Lookup(\"test.v\") != nil\n \t})\n }\n+\n+// TB is testing.TB, to avoid importing \"testing\" in non-test code.\n+type TB interface {\n+\tCleanup(func())\n+\tError(args ...any)\n+\tErrorf(format string, args ...any)\n+\tFail()\n+\tFailNow()\n+\tFailed() bool\n+\tFatal(args ...any)\n+\tFatalf(format string, args ...any)\n+\tHelper()\n+\tLog(args ...any)\n+\tLogf(format string, args ...any)\n+\tName() string\n+\tSetenv(key, value string)\n+\tChdir(dir string)\n+\tSkip(args ...any)\n+\tSkipNow()\n+\tSkipf(format string, args ...any)\n+\tSkipped() bool\n+\tTempDir() string\n+\tContext() context.Context\n+}\n+\n+// InParallelTest reports whether t is running as a parallel test.\n+//\n+// Use of this function taints t such that its Parallel method (assuming t is an\n+// actual *testing.T) will panic if called after this function.\n+func InParallelTest(t TB) (isParallel bool) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tisParallel = true\n+\t\t}\n+\t}()\n+\tt.Chdir(\".\") // panics in a t.Parallel test\n+\treturn false\n+}\n---\nutil/testenv/testenv_test.go\n@@ -16,3 +16,16 @@ func TestDeps(t *testing.T) {\n \t\t},\n \t}.Check(t)\n }\n+\n+func TestInParallelTestTrue(t *testing.T) {\n+\tt.Parallel()\n+\tif !InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return true once t.Parallel has been called\")\n+\t}\n+}\n+\n+func TestInParallelTestFalse(t *testing.T) {\n+\tif InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return false before t.Parallel has been called\")\n+\t}\n+}\n---\n\n\n---\n\nChoice C:\ngo.mod\n@@ -272,7 +272,7 @@ require (\n \tgithub.com/gordonklaus/ineffassign v0.1.0 // indirect\n \tgithub.com/goreleaser/chglog v0.5.0 // indirect\n \tgithub.com/goreleaser/fileglob v1.3.0 // indirect\n-\tgithub.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30\n+\tgithub.com/gorilla/csrf v1.7.3\n \tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n \tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n \tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n---\ngo.sum\n@@ -524,8 +524,8 @@ github.com/goreleaser/fileglob v1.3.0 h1:/X6J7U8lbDpQtBvGcwwPS6OpzkNVlVEsFUVRx9+\n github.com/goreleaser/fileglob v1.3.0/go.mod h1:Jx6BoXv3mbYkEzwm9THo7xbr5egkAraxkGorbJb4RxU=\n github.com/goreleaser/nfpm/v2 v2.33.1 h1:EkdAzZyVhAI9JC1vjmjjbmnNzyH1J6Cu4JCsA7YcQuc=\n github.com/goreleaser/nfpm/v2 v2.33.1/go.mod h1:8wwWWvJWmn84xo/Sqiv0aMvEGTHlHZTXTEuVSgQpkIM=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30 h1:fiJdrgVBkjZ5B1HJ2WQwNOaXB+QyYcNXTA3t1XYLz0M=\n-github.com/gorilla/csrf v1.7.3-0.20250123201450-9dd6af1f6d30/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n+github.com/gorilla/csrf v1.7.3 h1:BHWt6FTLZAb2HtWT5KDBf6qgpZzvtbp9QWDRKZMXJC0=\n+github.com/gorilla/csrf v1.7.3/go.mod h1:F1Fj3KG23WYHE6gozCmBAezKookxbIvUJT+121wTuLk=\n github.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\n github.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\n github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=\n---\n\n\n---\n\nChoice D:\nclientupdate/clientupdate.go\n@@ -28,6 +28,7 @@ import (\n \t\"strings\"\n \n \t\"tailscale.com/hostinfo\"\n+\t\"tailscale.com/types/lazy\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/cmpver\"\n \t\"tailscale.com/version\"\n@@ -249,9 +250,13 @@ func (up *Updater) getUpdateFunction() (fn updateFunction, canAutoUpdate bool) {\n \treturn nil, false\n }\n \n+var canAutoUpdateCache lazy.SyncValue[bool]\n+\n // CanAutoUpdate reports whether auto-updating via the clientupdate package\n // is supported for the current os/distro.\n-func CanAutoUpdate() bool {\n+func CanAutoUpdate() bool { return canAutoUpdateCache.Get(canAutoUpdateUncached) }\n+\n+func canAutoUpdateUncached() bool {\n \tif version.IsMacSysExt() {\n \t\t// Macsys uses Sparkle for auto-updates, which doesn't have an update\n \t\t// function in this package.\n---\nipn/ipnlocal/local.go\n@@ -3479,18 +3479,20 @@ func (b *LocalBackend) onTailnetDefaultAutoUpdate(au bool) {\n \t\t// can still manually enable auto-updates on this node.\n \t\treturn\n \t}\n-\tb.logf(\"using tailnet default auto-update setting: %v\", au)\n-\tprefsClone := prefs.AsStruct()\n-\tprefsClone.AutoUpdate.Apply = opt.NewBool(au)\n-\t_, err := b.editPrefsLockedOnEntry(&ipn.MaskedPrefs{\n-\t\tPrefs: *prefsClone,\n-\t\tAutoUpdateSet: ipn.AutoUpdatePrefsMask{\n-\t\t\tApplySet: true,\n-\t\t},\n-\t}, unlock)\n-\tif err != nil {\n-\t\tb.logf(\"failed to apply tailnet-wide default for auto-updates (%v): %v\", au, err)\n-\t\treturn\n+\tif clientupdate.CanAutoUpdate() {\n+\t\tb.logf(\"using tailnet default auto-update setting: %v\", au)\n+\t\tprefsClone := prefs.AsStruct()\n+\t\tprefsClone.AutoUpdate.Apply = opt.NewBool(au)\n+\t\t_, err := b.editPrefsLockedOnEntry(&ipn.MaskedPrefs{\n+\t\t\tPrefs: *prefsClone,\n+\t\t\tAutoUpdateSet: ipn.AutoUpdatePrefsMask{\n+\t\t\t\tApplySet: true,\n+\t\t\t},\n+\t\t}, unlock)\n+\t\tif err != nil {\n+\t\t\tb.logf(\"failed to apply tailnet-wide default for auto-updates (%v): %v\", au, err)\n+\t\t\treturn\n+\t\t}\n \t}\n }\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThe `.git/` directory is the Git repository and not part of the working tree.\r\n\r\nThis patch fixes spurious failures because something inside `.git/` has a `.go` suffix. For example, there\u2019s a branch named `c22wen/magicsock.go` which is definitely not a Go source file.\r\n\r\n``` console\r\nsfllaw@host:~/tailscale$ git fetch origin c22wen/magicsock.go\r\nFrom https://github.com/tailscale/tailscale\r\n * branch                c22wen/magicsock.go -> FETCH_HEAD\r\nsfllaw@host:~/tailscale$ go test . -run 'TestPackageDocs'\r\n=== RUN   TestPackageDocs\r\n    pkgdoc_test.go:46: failed to ParseFile \".git/logs/refs/remotes/origin/c22wen/magicsock.go\": .git/logs/refs/remotes/upstream/c22wen/magicsock.go:1:1: expected 'package', found 0000000000000000000000000000000000000000 (and 1 more errors)\r\n--- FAIL: TestPackageDocs (0.01s)\r\nFAIL\r\nFAIL\ttailscale.com\t0.015s\r\nFAIL\r\n```\r\n\r\nFixes: #15383\n\n---\n\nChoice A:\nutil/testenv/testenv.go\n@@ -6,6 +6,7 @@\n package testenv\n \n import (\n+\t\"context\"\n \t\"flag\"\n \n \t\"tailscale.com/types/lazy\"\n@@ -19,3 +20,41 @@ func InTest() bool {\n \t\treturn flag.Lookup(\"test.v\") != nil\n \t})\n }\n+\n+// TB is testing.TB, to avoid importing \"testing\" in non-test code.\n+type TB interface {\n+\tCleanup(func())\n+\tError(args ...any)\n+\tErrorf(format string, args ...any)\n+\tFail()\n+\tFailNow()\n+\tFailed() bool\n+\tFatal(args ...any)\n+\tFatalf(format string, args ...any)\n+\tHelper()\n+\tLog(args ...any)\n+\tLogf(format string, args ...any)\n+\tName() string\n+\tSetenv(key, value string)\n+\tChdir(dir string)\n+\tSkip(args ...any)\n+\tSkipNow()\n+\tSkipf(format string, args ...any)\n+\tSkipped() bool\n+\tTempDir() string\n+\tContext() context.Context\n+}\n+\n+// InParallelTest reports whether t is running as a parallel test.\n+//\n+// Use of this function taints t such that its Parallel method (assuming t is an\n+// actual *testing.T) will panic if called after this function.\n+func InParallelTest(t TB) (isParallel bool) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tisParallel = true\n+\t\t}\n+\t}()\n+\tt.Chdir(\".\") // panics in a t.Parallel test\n+\treturn false\n+}\n---\nutil/testenv/testenv_test.go\n@@ -16,3 +16,16 @@ func TestDeps(t *testing.T) {\n \t\t},\n \t}.Check(t)\n }\n+\n+func TestInParallelTestTrue(t *testing.T) {\n+\tt.Parallel()\n+\tif !InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return true once t.Parallel has been called\")\n+\t}\n+}\n+\n+func TestInParallelTestFalse(t *testing.T) {\n+\tif InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return false before t.Parallel has been called\")\n+\t}\n+}\n---\n\n\n---\n\nChoice B:\ncmd/vnet/vnet-main.go\n@@ -7,15 +7,21 @@ package main\n \n import (\n \t\"context\"\n+\t\"encoding/binary\"\n \t\"flag\"\n+\t\"fmt\"\n+\t\"io\"\n \t\"log\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/http/httputil\"\n \t\"net/url\"\n \t\"os\"\n+\t\"path/filepath\"\n+\t\"slices\"\n \t\"time\"\n \n+\t\"github.com/coder/websocket\"\n \t\"tailscale.com/tstest/natlab/vnet\"\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/must\"\n@@ -31,10 +37,18 @@ var (\n \tpcapFile = flag.String(\"pcap\", \"\", \"if non-empty, filename to write pcap\")\n \tv4       = flag.Bool(\"v4\", true, \"enable IPv4\")\n \tv6       = flag.Bool(\"v6\", true, \"enable IPv6\")\n+\n+\twsproxyListen = flag.String(\"wsproxy\", \"\", \"if non-empty, TCP address to run websocket server on. See https://github.com/copy/v86/blob/master/docs/networking.md#backend-url-schemes\")\n )\n \n func main() {\n \tflag.Parse()\n+\tif *wsproxyListen != \"\" {\n+\t\tif err := runWSProxy(); err != nil {\n+\t\t\tlog.Fatalf(\"runWSProxy: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n \n \tif _, err := os.Stat(*listen); err == nil {\n \t\tos.Remove(*listen)\n@@ -137,3 +151,168 @@ func main() {\n \t\tgo s.ServeUnixConn(c.(*net.UnixConn), vnet.ProtocolQEMU)\n \t}\n }\n+\n+func runWSProxy() error {\n+\tln, err := net.Listen(\"tcp\", *wsproxyListen)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer ln.Close()\n+\n+\tlog.Printf(\"Running wsproxy mode on %v ...\", *wsproxyListen)\n+\n+\tvar hs http.Server\n+\ths.Handler = http.HandlerFunc(handleWebSocket)\n+\n+\treturn hs.Serve(ln)\n+}\n+\n+func handleWebSocket(w http.ResponseWriter, r *http.Request) {\n+\tconn, err := websocket.Accept(w, r, &websocket.AcceptOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\tif err != nil {\n+\t\tlog.Printf(\"Upgrade error: %v\", err)\n+\t\treturn\n+\t}\n+\tdefer conn.Close(websocket.StatusInternalError, \"closing\")\n+\tlog.Printf(\"WebSocket client connected: %s\", r.RemoteAddr)\n+\n+\tctx, cancel := context.WithCancel(r.Context())\n+\tdefer cancel()\n+\n+\tmessageType, firstData, err := conn.Read(ctx)\n+\tif err != nil {\n+\t\tlog.Printf(\"ReadMessage first: %v\", err)\n+\t\treturn\n+\t}\n+\tif messageType != websocket.MessageBinary {\n+\t\tlog.Printf(\"Ignoring non-binary message\")\n+\t\treturn\n+\t}\n+\tif len(firstData) < 12 {\n+\t\tlog.Printf(\"Ignoring short message\")\n+\t\treturn\n+\t}\n+\tclientMAC := vnet.MAC(firstData[6:12])\n+\n+\t// Set up a qemu-protocol Unix socket pair. We'll fake the qemu protocol here\n+\t// to avoid changing the vnet package.\n+\ttd, err := os.MkdirTemp(\"\", \"vnet\")\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"MkdirTemp: %v\", err))\n+\t}\n+\tdefer os.RemoveAll(td)\n+\n+\tunixSrv := filepath.Join(td, \"vnet.sock\")\n+\n+\tsrv, err := net.Listen(\"unix\", unixSrv)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"Listen: %v\", err))\n+\t}\n+\tdefer srv.Close()\n+\n+\tvar c vnet.Config\n+\tc.SetBlendReality(true)\n+\n+\tvar net1opt = []any{vnet.NAT(\"easy\")}\n+\tnet1opt = append(net1opt, \"2.1.1.1\", \"192.168.1.1/24\")\n+\tnet1opt = append(net1opt, \"2000:52::1/64\")\n+\n+\tc.AddNode(c.AddNetwork(net1opt...), clientMAC)\n+\n+\tvs, err := vnet.New(&c)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"newServer: %v\", err))\n+\t}\n+\tif err := vs.PopulateDERPMapIPs(); err != nil {\n+\t\tlog.Printf(\"warning: ignoring failure to populate DERP map: %v\", err)\n+\t\treturn\n+\t}\n+\n+\terrc := make(chan error, 1)\n+\tfail := func(err error) {\n+\t\tselect {\n+\t\tcase errc <- err:\n+\t\t\tlog.Printf(\"failed: %v\", err)\n+\t\tcase <-ctx.Done():\n+\t\t}\n+\t}\n+\n+\tgo func() {\n+\t\tc, err := srv.Accept()\n+\t\tif err != nil {\n+\t\t\tfail(err)\n+\t\t\treturn\n+\t\t}\n+\t\tvs.ServeUnixConn(c.(*net.UnixConn), vnet.ProtocolQEMU)\n+\t}()\n+\n+\tuc, err := net.Dial(\"unix\", unixSrv)\n+\tif err != nil {\n+\t\tpanic(fmt.Errorf(\"Dial: %v\", err))\n+\t}\n+\tdefer uc.Close()\n+\n+\tvar frameBuf []byte\n+\twriteDataToUnixConn := func(data []byte) error {\n+\t\tframeBuf = slices.Grow(frameBuf[:0], len(data)+4)[:len(data)+4]\n+\t\tbinary.BigEndian.PutUint32(frameBuf[:4], uint32(len(data)))\n+\t\tcopy(frameBuf[4:], data)\n+\n+\t\t_, err = uc.Write(frameBuf)\n+\t\treturn err\n+\t}\n+\tif err := writeDataToUnixConn(firstData); err != nil {\n+\t\tfail(err)\n+\t\treturn\n+\t}\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tmessageType, data, err := conn.Read(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\tfail(fmt.Errorf(\"ReadMessage: %v\", err))\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif messageType != websocket.MessageBinary {\n+\t\t\t\tlog.Printf(\"Ignoring non-binary message\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif err := writeDataToUnixConn(data); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tgo func() {\n+\t\tconst maxBuf = 4096\n+\t\tframeBuf := make([]byte, maxBuf)\n+\t\tfor {\n+\t\t\t_, err := io.ReadFull(uc, frameBuf[:4])\n+\t\t\tif err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tframeLen := binary.BigEndian.Uint32(frameBuf[:4])\n+\t\t\tif frameLen > maxBuf {\n+\t\t\t\tfail(fmt.Errorf(\"frame too large: %d\", frameLen))\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif _, err := io.ReadFull(uc, frameBuf[:frameLen]); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := conn.Write(ctx, websocket.MessageBinary, frameBuf[:frameLen]); err != nil {\n+\t\t\t\tfail(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\t<-ctx.Done()\n+}\n---\ntstest/natlab/vnet/conf.go\n@@ -121,6 +121,8 @@ func (c *Config) AddNode(opts ...any) *Node {\n \t\t\t\t\tn.err = fmt.Errorf(\"unknown NodeOption %q\", o)\n \t\t\t\t}\n \t\t\t}\n+\t\tcase MAC:\n+\t\t\tn.mac = o\n \t\tdefault:\n \t\t\tif n.err == nil {\n \t\t\t\tn.err = fmt.Errorf(\"unknown AddNode option type %T\", o)\n---\ntstest/natlab/vnet/vnet.go\n@@ -88,6 +88,9 @@ func (s *Server) PopulateDERPMapIPs() error {\n \t\t\tif n.IPv4 != \"\" {\n \t\t\t\ts.derpIPs.Add(netip.MustParseAddr(n.IPv4))\n \t\t\t}\n+\t\t\tif n.IPv6 != \"\" {\n+\t\t\t\ts.derpIPs.Add(netip.MustParseAddr(n.IPv6))\n+\t\t\t}\n \t\t}\n \t}\n \treturn nil\n---\n\n\n---\n\nChoice C:\npkgdoc_test.go\n@@ -26,6 +26,9 @@ func TestPackageDocs(t *testing.T) {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tif fi.Mode().IsDir() && path == \".git\" {\n+\t\t\treturn filepath.SkipDir // No documentation lives in .git\n+\t\t}\n \t\tif fi.Mode().IsRegular() && strings.HasSuffix(path, \".go\") {\n \t\t\tif strings.HasSuffix(path, \"_test.go\") {\n \t\t\t\treturn nil\n---\n\n\n---\n\nChoice D:\nipn/ipnstate/ipnstate.go\n@@ -53,6 +53,9 @@ type Status struct {\n \t// If nil, an exit node is not in use.\n \tExitNodeStatus *ExitNodeStatus `json:\"ExitNodeStatus,omitempty\"`\n \n+\t// DERPHomeRegionID is the current home DERP region ID.\n+\tDERPHomeRegionID int\n+\n \t// Health contains health check problems.\n \t// Empty means everything is good. (or at least that no known\n \t// problems are detected)\n---\nwgengine/magicsock/magicsock.go\n@@ -2892,11 +2892,15 @@ func (c *Conn) UpdateStatus(sb *ipnstate.StatusBuilder) {\n \t\t})\n \t}\n \n-\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n-\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n-\t\t// to include all the DERP connections we have open\n-\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n+\tsb.MutateStatus(func(s *ipnstate.Status) {\n+\t\ts.DERPHomeRegionID = c.myDerp\n+\t\tc.foreachActiveDerpSortedLocked(func(node int, ad activeDerp) {\n+\t\t\t// TODO(bradfitz): add a method to ipnstate.StatusBuilder\n+\t\t\t// to include all the DERP connections we have open\n+\t\t\t// and add it here. See the other caller of foreachActiveDerpSortedLocked.\n+\t\t})\n \t})\n+\n }\n \n // SetStatistics specifies a per-connection statistics aggregator.\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nNoticed while working on a dev tool that uses local.Client.\n\nUpdates #cleanup\n\n\n---\n\nChoice A:\nsafesocket/safesocket.go\n@@ -61,7 +61,11 @@ func ConnectContext(ctx context.Context, path string) (net.Conn, error) {\n \t\t\tif ctx.Err() != nil {\n \t\t\t\treturn nil, ctx.Err()\n \t\t\t}\n-\t\t\ttime.Sleep(250 * time.Millisecond)\n+\t\t\tselect {\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\treturn nil, ctx.Err()\n+\t\t\tcase <-time.After(250 * time.Millisecond):\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\treturn c, err\n---\n\n\n---\n\nChoice B:\ncmd/tailscale/cli/cli.go\n@@ -164,7 +164,7 @@ func Run(args []string) (err error) {\n \n \terr = rootCmd.Run(context.Background())\n \tif tailscale.IsAccessDeniedError(err) && os.Getuid() != 0 && runtime.GOOS != \"windows\" {\n-\t\treturn fmt.Errorf(\"%v\\n\\nUse 'sudo tailscale %s' or 'tailscale up --operator=$USER' to not require root.\", err, strings.Join(args, \" \"))\n+\t\treturn fmt.Errorf(\"%v\\n\\nUse 'sudo tailscale %s'.\\nTo not require root, use 'sudo tailscale set --operator=$USER' once.\", err, strings.Join(args, \" \"))\n \t}\n \tif errors.Is(err, flag.ErrHelp) {\n \t\treturn nil\n---\n\n\n---\n\nChoice C:\ntstime/tstime.go\n@@ -6,6 +6,7 @@ package tstime\n \n import (\n \t\"context\"\n+\t\"encoding\"\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n@@ -183,3 +184,40 @@ func (StdClock) AfterFunc(d time.Duration, f func()) TimerController {\n func (StdClock) Since(t time.Time) time.Duration {\n \treturn time.Since(t)\n }\n+\n+// GoDuration is a [time.Duration] but JSON serializes with [time.Duration.String].\n+//\n+// Note that this format is specific to Go and non-standard,\n+// but excels in being most humanly readable compared to alternatives.\n+// The wider industry still lacks consensus for the representation\n+// of a time duration in humanly-readable text.\n+// See https://go.dev/issue/71631 for more discussion.\n+//\n+// Regardless of how the industry evolves into the future,\n+// this type explicitly uses the Go format.\n+type GoDuration struct{ time.Duration }\n+\n+var (\n+\t_ encoding.TextAppender    = (*GoDuration)(nil)\n+\t_ encoding.TextMarshaler   = (*GoDuration)(nil)\n+\t_ encoding.TextUnmarshaler = (*GoDuration)(nil)\n+)\n+\n+func (d GoDuration) AppendText(b []byte) ([]byte, error) {\n+\t// The String method is inlineable (see https://go.dev/cl/520602),\n+\t// so this may not allocate since the string does not escape.\n+\treturn append(b, d.String()...), nil\n+}\n+\n+func (d GoDuration) MarshalText() ([]byte, error) {\n+\treturn []byte(d.String()), nil\n+}\n+\n+func (d *GoDuration) UnmarshalText(b []byte) error {\n+\td2, err := time.ParseDuration(string(b))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\td.Duration = d2\n+\treturn nil\n+}\n---\ntstime/tstime_test.go\n@@ -4,8 +4,11 @@\n package tstime\n \n import (\n+\t\"encoding/json\"\n \t\"testing\"\n \t\"time\"\n+\n+\t\"tailscale.com/util/must\"\n )\n \n func TestParseDuration(t *testing.T) {\n@@ -34,3 +37,17 @@ func TestParseDuration(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestGoDuration(t *testing.T) {\n+\twantDur := GoDuration{time.Hour + time.Minute + time.Second + time.Millisecond + time.Microsecond + time.Nanosecond}\n+\tgotJSON := string(must.Get(json.Marshal(wantDur)))\n+\twantJSON := `\"1h1m1.001001001s\"`\n+\tif gotJSON != wantJSON {\n+\t\tt.Errorf(\"json.Marshal(%v) = %s, want %s\", wantDur, gotJSON, wantJSON)\n+\t}\n+\tvar gotDur GoDuration\n+\tmust.Do(json.Unmarshal([]byte(wantJSON), &gotDur))\n+\tif gotDur != wantDur {\n+\t\tt.Errorf(\"json.Unmarshal(%s) = %v, want %v\", wantJSON, gotDur, wantDur)\n+\t}\n+}\n---\n\n\n---\n\nChoice D:\nnet/netmon/interfaces_test.go\n@@ -13,7 +13,7 @@ import (\n )\n \n func TestGetState(t *testing.T) {\n-\tst, err := GetState()\n+\tst, err := getState()\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n---\nnet/netmon/netmon.go\n@@ -161,7 +161,7 @@ func (m *Monitor) InterfaceState() *State {\n }\n \n func (m *Monitor) interfaceStateUncached() (*State, error) {\n-\treturn GetState()\n+\treturn getState()\n }\n \n // SetTailscaleInterfaceName sets the name of the Tailscale interface. For\n---\nnet/netmon/state.go\n@@ -466,7 +466,7 @@ var getPAC func() string\n // It does not set the returned State.IsExpensive. The caller can populate that.\n //\n // Deprecated: use netmon.Monitor.InterfaceState instead.\n-func GetState() (*State, error) {\n+func getState() (*State, error) {\n \ts := &State{\n \t\tInterfaceIPs: make(map[string][]netip.Prefix),\n \t\tInterface:    make(map[string]Interface),\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nWhen compiled into TailscaleKit.framework (via the libtailscale repository), os.Executable() returns an error instead of the name of the executable.  which manifests in the following error from Swift when starting a `TailscaleNode`:\r\n\r\n```\r\nTailscaleNode Error: internalError(Optional(\"tenet: cannot find executable path\"))\r\n```\r\n\r\nThis commit adds another branch to the switch statement that enumerates platforms which behave in this manner, and defaults to \"tsnet\" in the same manner as those other platforms.\n\n---\n\nChoice A:\ndocs/commit-messages.md\n@@ -1,16 +1,12 @@\n # Commit messages\n \n+There are different styles of commit messages followed by different projects.\n This is Tailscale's style guide for writing git commit messages.\n-\n As with all style guides, many things here are subjective and exist primarily to\n codify existing conventions and promote uniformity and thus ease of reading by\n others. Others have stronger reasons, such as interop with tooling or making\n future git archaeology easier.\n \n-# Commit Messages\n-\n-There are different styles of commit messages followed by different projects.\n-\n Our commit message style is largely based on the Go language's style, which\n shares much in common with the Linux kernel's git commit message style (for\n which git was invented):\n---\n\n\n---\n\nChoice B:\nwgengine/magicsock/endpoint.go\n@@ -1111,7 +1111,7 @@ func (de *endpoint) sendDiscoPing(ep netip.AddrPort, discoKey key.DiscoPublic, t\n \tsize = min(size, MaxDiscoPingSize)\n \tpadding := max(size-discoPingSize, 0)\n \n-\tsent, _ := de.c.sendDiscoMessage(ep, de.publicKey, discoKey, &disco.Ping{\n+\tsent, _ := de.c.sendDiscoMessage(ep, nil, de.publicKey, discoKey, &disco.Ping{\n \t\tTxID:    [12]byte(txid),\n \t\tNodeKey: de.c.publicKeyAtomic.Load(),\n \t\tPadding: padding,\n---\nwgengine/magicsock/magicsock.go\n@@ -1602,23 +1602,60 @@ var debugIPv4DiscoPingPenalty = envknob.RegisterDuration(\"TS_DISCO_PONG_IPV4_DEL\n //\n // If dst is a DERP IP:port, then dstKey must be non-zero.\n //\n+// If geneveVNI is non-nil, then the [disco.Message] will be preceded by a\n+// Geneve header with the supplied VNI set.\n+//\n // The dstKey should only be non-zero if the dstDisco key\n // unambiguously maps to exactly one peer.\n-func (c *Conn) sendDiscoMessage(dst netip.AddrPort, dstKey key.NodePublic, dstDisco key.DiscoPublic, m disco.Message, logLevel discoLogLevel) (sent bool, err error) {\n+func (c *Conn) sendDiscoMessage(dst netip.AddrPort, geneveVNI *uint32, dstKey key.NodePublic, dstDisco key.DiscoPublic, m disco.Message, logLevel discoLogLevel) (sent bool, err error) {\n \tisDERP := dst.Addr() == tailcfg.DerpMagicIPAddr\n \tif _, isPong := m.(*disco.Pong); isPong && !isDERP && dst.Addr().Is4() {\n \t\ttime.Sleep(debugIPv4DiscoPingPenalty())\n \t}\n \n+\tisRelayHandshakeMsg := false\n+\tswitch m.(type) {\n+\tcase *disco.BindUDPRelayEndpoint, *disco.BindUDPRelayEndpointAnswer:\n+\t\tisRelayHandshakeMsg = true\n+\t}\n+\n \tc.mu.Lock()\n \tif c.closed {\n \t\tc.mu.Unlock()\n \t\treturn false, errConnClosed\n \t}\n \tpkt := make([]byte, 0, 512) // TODO: size it correctly? pool? if it matters.\n+\tif geneveVNI != nil {\n+\t\tgh := packet.GeneveHeader{\n+\t\t\tVersion:  0,\n+\t\t\tProtocol: packet.GeneveProtocolDisco,\n+\t\t\tVNI:      *geneveVNI,\n+\t\t\tControl:  isRelayHandshakeMsg,\n+\t\t}\n+\t\tpkt = append(pkt, make([]byte, packet.GeneveFixedHeaderLength)...)\n+\t\terr := gh.Encode(pkt)\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t}\n \tpkt = append(pkt, disco.Magic...)\n \tpkt = c.discoPublic.AppendTo(pkt)\n-\tdi := c.discoInfoLocked(dstDisco)\n+\tvar di *discoInfo\n+\tif !isRelayHandshakeMsg {\n+\t\tdi = c.discoInfoLocked(dstDisco)\n+\t} else {\n+\t\t// c.discoInfoLocked() caches [*discoInfo] for dstDisco. It assumes that\n+\t\t// dstDisco is a known Tailscale peer, and will be cleaned around\n+\t\t// network map changes. In the case of a relay handshake message,\n+\t\t// dstDisco belongs to a relay server with a disco key that is\n+\t\t// discovered at endpoint allocation time or [disco.CallMeMaybeVia]\n+\t\t// reception time. There is no clear ending to its lifetime, so we\n+\t\t// can't cache with the same strategy. Instead, generate the shared\n+\t\t// key on the fly for now.\n+\t\tdi = &discoInfo{\n+\t\t\tsharedKey: c.discoPrivate.Shared(dstDisco),\n+\t\t}\n+\t}\n \tc.mu.Unlock()\n \n \tif isDERP {\n@@ -1943,7 +1980,7 @@ func (c *Conn) handlePingLocked(dm *disco.Ping, src netip.AddrPort, di *discoInf\n \n \tipDst := src\n \tdiscoDest := di.discoKey\n-\tgo c.sendDiscoMessage(ipDst, dstKey, discoDest, &disco.Pong{\n+\tgo c.sendDiscoMessage(ipDst, nil, dstKey, discoDest, &disco.Pong{\n \t\tTxID: dm.TxID,\n \t\tSrc:  src,\n \t}, discoVerboseLog)\n@@ -1988,12 +2025,12 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {\n \tfor _, ep := range c.lastEndpoints {\n \t\teps = append(eps, ep.Addr)\n \t}\n-\tgo de.c.sendDiscoMessage(derpAddr, de.publicKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n+\tgo de.c.sendDiscoMessage(derpAddr, nil, de.publicKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n \tif debugSendCallMeUnknownPeer() {\n \t\t// Send a callMeMaybe packet to a non-existent peer\n \t\tunknownKey := key.NewNode().Public()\n \t\tc.logf(\"magicsock: sending CallMeMaybe to unknown peer per TS_DEBUG_SEND_CALLME_UNKNOWN_PEER\")\n-\t\tgo de.c.sendDiscoMessage(derpAddr, unknownKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n+\t\tgo de.c.sendDiscoMessage(derpAddr, nil, unknownKey, epDisco.key, &disco.CallMeMaybe{MyNumber: eps}, discoLog)\n \t}\n }\n \n---\n\n\n---\n\nChoice C:\nutil/testenv/testenv.go\n@@ -6,6 +6,7 @@\n package testenv\n \n import (\n+\t\"context\"\n \t\"flag\"\n \n \t\"tailscale.com/types/lazy\"\n@@ -19,3 +20,41 @@ func InTest() bool {\n \t\treturn flag.Lookup(\"test.v\") != nil\n \t})\n }\n+\n+// TB is testing.TB, to avoid importing \"testing\" in non-test code.\n+type TB interface {\n+\tCleanup(func())\n+\tError(args ...any)\n+\tErrorf(format string, args ...any)\n+\tFail()\n+\tFailNow()\n+\tFailed() bool\n+\tFatal(args ...any)\n+\tFatalf(format string, args ...any)\n+\tHelper()\n+\tLog(args ...any)\n+\tLogf(format string, args ...any)\n+\tName() string\n+\tSetenv(key, value string)\n+\tChdir(dir string)\n+\tSkip(args ...any)\n+\tSkipNow()\n+\tSkipf(format string, args ...any)\n+\tSkipped() bool\n+\tTempDir() string\n+\tContext() context.Context\n+}\n+\n+// InParallelTest reports whether t is running as a parallel test.\n+//\n+// Use of this function taints t such that its Parallel method (assuming t is an\n+// actual *testing.T) will panic if called after this function.\n+func InParallelTest(t TB) (isParallel bool) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tisParallel = true\n+\t\t}\n+\t}()\n+\tt.Chdir(\".\") // panics in a t.Parallel test\n+\treturn false\n+}\n---\nutil/testenv/testenv_test.go\n@@ -16,3 +16,16 @@ func TestDeps(t *testing.T) {\n \t\t},\n \t}.Check(t)\n }\n+\n+func TestInParallelTestTrue(t *testing.T) {\n+\tt.Parallel()\n+\tif !InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return true once t.Parallel has been called\")\n+\t}\n+}\n+\n+func TestInParallelTestFalse(t *testing.T) {\n+\tif InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return false before t.Parallel has been called\")\n+\t}\n+}\n---\n\n\n---\n\nChoice D:\ntsnet/tsnet.go\n@@ -505,6 +505,11 @@ func (s *Server) start() (reterr error) {\n \t\t\t// directory and hostname when they're not supplied. But we can fall\n \t\t\t// back to \"tsnet\" as well.\n \t\t\texe = \"tsnet\"\n+\t\tcase \"ios\":\n+\t\t\t// When compiled as a framework (via TailscaleKit in libtailscale),\n+\t\t\t// os.Executable() returns an error, so fall back to \"tsnet\" there\n+\t\t\t// too.\n+\t\t\texe = \"tsnet\"\n \t\tdefault:\n \t\t\treturn err\n \t\t}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAs an example, without this patch you might get:\r\n\r\n```\r\n    integration_test.go:1945: failure/timeout waiting for transition to Running status: decoding tailscale status JSON: invalid character 'a' in literal true (expecting 'r')\r\n```\r\n\r\n(and that line of code is the `AwaitRunning` function itself)\r\n\r\nWith the patch you'd get:\r\n\r\n```\r\n    integration_test.go:534: failure/timeout waiting for transition to Running status: decoding tailscale status JSON: invalid character 'a' in literal true (expecting 'r')\r\n        json:\r\n        tailscale.toolchain.rev = \"4fdaeeb8fe43bcdb4e8cc736433b9cd9c0ddd221\", want \"2b494987ff3c1a6a26e10570c490394ff0a77aa4\"; but ignoring due to TS_PERMIT_TOOLCHAIN_MISMATCH=1\r\n        {\r\n          \"Version\": \"1.81.118-t504c0203b\",\r\n          \"TUN\": false,\r\n          \"BackendState\": \"Running\",\r\n          \"HaveNodeKey\": true,\r\n...\r\n```\r\n\r\nWhich makes it much clearer what went wrong, and also the line number points you at the test `TestNodeAddressIPFields` rather than the `AwaitRunning` helper.\n\n---\n\nChoice A:\nprober/tls_test.go\n@@ -252,7 +252,7 @@ func TestCRL(t *testing.T) {\n \t\t\t\"NoCRL\",\n \t\t\tleafCertParsed,\n \t\t\tnil,\n-\t\t\t\"\",\n+\t\t\t\"no CRL server presented in leaf cert for\",\n \t\t},\n \t\t{\n \t\t\t\"NotBeforeCRLStaplingDate\",\n@@ -276,7 +276,7 @@ func TestCRL(t *testing.T) {\n \t\t\t\treturn\n \t\t\t}\n \n-\t\t\tif err == nil || !strings.Contains(err.Error(), tt.wantErr) {\n+\t\t\tif err == nil || tt.wantErr == \"\" || !strings.Contains(err.Error(), tt.wantErr) {\n \t\t\t\tt.Errorf(\"unexpected error %q; want %q\", err, tt.wantErr)\n \t\t\t}\n \t\t})\n---\n\n\n---\n\nChoice B:\ntstest/integration/integration_test.go\n@@ -1942,6 +1942,8 @@ func (n *testNode) AwaitIP6() netip.Addr {\n \n // AwaitRunning waits for n to reach the IPN state \"Running\".\n func (n *testNode) AwaitRunning() {\n+\tt := n.env.t\n+\tt.Helper()\n \tn.AwaitBackendState(\"Running\")\n }\n \n@@ -2015,7 +2017,7 @@ func (n *testNode) Status() (*ipnstate.Status, error) {\n \t}\n \tst := new(ipnstate.Status)\n \tif err := json.Unmarshal(out, st); err != nil {\n-\t\treturn nil, fmt.Errorf(\"decoding tailscale status JSON: %w\", err)\n+\t\treturn nil, fmt.Errorf(\"decoding tailscale status JSON: %w\\njson:\\n%s\", err, out)\n \t}\n \treturn st, nil\n }\n---\n\n\n---\n\nChoice C:\nbuild_dist.sh\n@@ -28,18 +28,26 @@ EOF\n \texit 0\n fi\n \n-tags=\"\"\n+tags=\"${TAGS:-}\"\n ldflags=\"-X tailscale.com/version.longStamp=${VERSION_LONG} -X tailscale.com/version.shortStamp=${VERSION_SHORT}\"\n \n # build_dist.sh arguments must precede go build arguments.\n while [ \"$#\" -gt 1 ]; do\n \tcase \"$1\" in\n \t--extra-small)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --extra-small or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\tldflags=\"$ldflags -w -s\"\n \t\ttags=\"${tags:+$tags,}ts_omit_aws,ts_omit_bird,ts_omit_tap,ts_omit_kube,ts_omit_completion,ts_omit_ssh,ts_omit_wakeonlan,ts_omit_capture\"\n \t\t;;\n \t--box)\n+\t\tif [ ! -z \"${TAGS:-}\" ]; then\n+\t\t\techo \"set either --box or \\$TAGS, but not both\"\n+\t\t\texit 1\n+\t\tfi\n \t\tshift\n \t\ttags=\"${tags:+$tags,}ts_include_cli\"\n \t\t;;\n---\n\n\n---\n\nChoice D:\nutil/testenv/testenv.go\n@@ -6,6 +6,7 @@\n package testenv\n \n import (\n+\t\"context\"\n \t\"flag\"\n \n \t\"tailscale.com/types/lazy\"\n@@ -19,3 +20,41 @@ func InTest() bool {\n \t\treturn flag.Lookup(\"test.v\") != nil\n \t})\n }\n+\n+// TB is testing.TB, to avoid importing \"testing\" in non-test code.\n+type TB interface {\n+\tCleanup(func())\n+\tError(args ...any)\n+\tErrorf(format string, args ...any)\n+\tFail()\n+\tFailNow()\n+\tFailed() bool\n+\tFatal(args ...any)\n+\tFatalf(format string, args ...any)\n+\tHelper()\n+\tLog(args ...any)\n+\tLogf(format string, args ...any)\n+\tName() string\n+\tSetenv(key, value string)\n+\tChdir(dir string)\n+\tSkip(args ...any)\n+\tSkipNow()\n+\tSkipf(format string, args ...any)\n+\tSkipped() bool\n+\tTempDir() string\n+\tContext() context.Context\n+}\n+\n+// InParallelTest reports whether t is running as a parallel test.\n+//\n+// Use of this function taints t such that its Parallel method (assuming t is an\n+// actual *testing.T) will panic if called after this function.\n+func InParallelTest(t TB) (isParallel bool) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tisParallel = true\n+\t\t}\n+\t}()\n+\tt.Chdir(\".\") // panics in a t.Parallel test\n+\treturn false\n+}\n---\nutil/testenv/testenv_test.go\n@@ -16,3 +16,16 @@ func TestDeps(t *testing.T) {\n \t\t},\n \t}.Check(t)\n }\n+\n+func TestInParallelTestTrue(t *testing.T) {\n+\tt.Parallel()\n+\tif !InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return true once t.Parallel has been called\")\n+\t}\n+}\n+\n+func TestInParallelTestFalse(t *testing.T) {\n+\tif InParallelTest(t) {\n+\t\tt.Fatal(\"InParallelTest should return false before t.Parallel has been called\")\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nUpdates #cleanup\n\n---\n\nChoice A:\ntsnet/tsnet_test.go\n@@ -120,6 +120,7 @@ func startControl(t *testing.T) (controlURL string, control *testcontrol.Server)\n \t\t\tProxied: true,\n \t\t},\n \t\tMagicDNSDomain: \"tail-scale.ts.net\",\n+\t\tLogf:           t.Logf,\n \t}\n \tcontrol.HTTPTestServer = httptest.NewUnstartedServer(control)\n \tcontrol.HTTPTestServer.Start()\n@@ -221,7 +222,7 @@ func startServer(t *testing.T, ctx context.Context, controlURL, hostname string)\n \t\tgetCertForTesting: testCertRoot.getCert,\n \t}\n \tif *verboseNodes {\n-\t\ts.Logf = log.Printf\n+\t\ts.Logf = t.Logf\n \t}\n \tt.Cleanup(func() { s.Close() })\n \n---\n\n\n---\n\nChoice B:\nfeature/relayserver/relayserver.go\n@@ -142,7 +142,7 @@ func handlePeerAPIRelayAllocateEndpoint(h ipnlocal.PeerAPIHandler, w http.Respon\n \n \thttpErrAndLog := func(message string, code int) {\n \t\thttp.Error(w, message, code)\n-\t\te.logf(\"peerapi: request from %v returned code %d: %s\", h.RemoteAddr(), code, message)\n+\t\th.Logf(\"relayserver: request from %v returned code %d: %s\", h.RemoteAddr(), code, message)\n \t}\n \n \tif !h.PeerCaps().HasCapability(tailcfg.PeerCapabilityRelay) {\n---\n\n\n---\n\nChoice C:\nipn/ipnlocal/extension_host.go\n@@ -25,6 +25,7 @@ import (\n \t\"tailscale.com/types/logger\"\n \t\"tailscale.com/util/execqueue\"\n \t\"tailscale.com/util/set\"\n+\t\"tailscale.com/util/slicesx\"\n \t\"tailscale.com/util/testenv\"\n )\n \n@@ -378,7 +379,7 @@ func (h *ExtensionHost) NotifyProfileChange(profile ipn.LoginProfileView, prefs\n \th.currentPrefs = prefs\n \th.currentProfile = profile\n \t// Get the callbacks to be invoked.\n-\tcbs := collectValues(h.profileStateChangeCbs)\n+\tcbs := slicesx.MapValues(h.profileStateChangeCbs)\n \th.mu.Unlock()\n \tfor _, cb := range cbs {\n \t\tcb(profile, prefs, sameNode)\n@@ -402,7 +403,7 @@ func (h *ExtensionHost) NotifyProfilePrefsChanged(profile ipn.LoginProfileView,\n \th.currentPrefs = newPrefs\n \th.currentProfile = profile\n \t// Get the callbacks to be invoked.\n-\tstateCbs := collectValues(h.profileStateChangeCbs)\n+\tstateCbs := slicesx.MapValues(h.profileStateChangeCbs)\n \th.mu.Unlock()\n \tfor _, cb := range stateCbs {\n \t\tcb(profile, newPrefs, true)\n@@ -443,7 +444,7 @@ func (h *ExtensionHost) DetermineBackgroundProfile(profiles ipnext.ProfileStore)\n \t// Attempt to resolve the background profile using the registered\n \t// background profile resolvers (e.g., [ipn/desktop.desktopSessionsExt] on Windows).\n \th.mu.Lock()\n-\tresolvers := collectValues(h.backgroundProfileResolvers)\n+\tresolvers := slicesx.MapValues(h.backgroundProfileResolvers)\n \th.mu.Unlock()\n \tfor _, resolver := range resolvers {\n \t\tif profile := resolver(profiles); profile.Valid() {\n@@ -481,7 +482,7 @@ func (h *ExtensionHost) NotifyNewControlClient(cc controlclient.Client, profile\n \t\treturn nil\n \t}\n \th.mu.Lock()\n-\tcbs := collectValues(h.newControlClientCbs)\n+\tcbs := slicesx.MapValues(h.newControlClientCbs)\n \th.mu.Unlock()\n \tif len(cbs) > 0 {\n \t\tccShutdownCbs = make([]func(), 0, len(cbs))\n@@ -527,7 +528,7 @@ func (h *ExtensionHost) AuditLogger() ipnauth.AuditLogFunc {\n \t}\n \n \th.mu.Lock()\n-\tproviders := collectValues(h.auditLoggers)\n+\tproviders := slicesx.MapValues(h.auditLoggers)\n \th.mu.Unlock()\n \n \tvar loggers []ipnauth.AuditLogFunc\n@@ -642,17 +643,3 @@ type execQueue interface {\n \tShutdown()\n \tWait(context.Context) error\n }\n-\n-// collectValues is like [slices.Collect] of [maps.Values],\n-// but pre-allocates the slice to avoid reallocations.\n-// It returns nil if the map is empty.\n-func collectValues[K comparable, V any](m map[K]V) []V {\n-\tif len(m) == 0 {\n-\t\treturn nil\n-\t}\n-\ts := make([]V, 0, len(m))\n-\tfor _, v := range m {\n-\t\ts = append(s, v)\n-\t}\n-\treturn s\n-}\n---\n\n\n---\n\nChoice D:\ncmd/k8s-operator/depaware.txt\n@@ -840,7 +840,7 @@ tailscale.com/cmd/k8s-operator dependencies: (generated by github.com/tailscale/\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/cmd/k8s-operator+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\ncmd/tailscaled/depaware.txt\n@@ -318,7 +318,7 @@ tailscale.com/cmd/tailscaled dependencies: (generated by github.com/tailscale/de\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/cmd/tailscaled+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\nipn/ipnlocal/local.go\n@@ -64,6 +64,7 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4886,7 +4887,6 @@ func (b *LocalBackend) authReconfig() {\n \tnm := cn.NetMap()\n \thasPAC := b.prevIfState.HasPAC()\n \tdisableSubnetsIfPAC := cn.SelfHasCap(tailcfg.NodeAttrDisableSubnetsIfPAC)\n-\tuserDialUseRoutes := cn.SelfHasCap(tailcfg.NodeAttrUserDialUseRoutes)\n \tdohURL, dohURLOK := cn.exitNodeCanProxyDNS(prefs.ExitNodeID())\n \tdcfg := cn.dnsConfigForNetmap(prefs, b.keyExpired, b.logf, version.OS())\n \t// If the current node is an app connector, ensure the app connector machine is started\n@@ -4947,7 +4947,7 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif userDialUseRoutes {\n+\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n \t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n \t} else {\n \t\tb.dialer.SetRoutes(nil, nil)\n---\nnet/dns/resolver/forwarder.go\n@@ -17,6 +17,7 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"net/url\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n@@ -740,18 +741,35 @@ func (f *forwarder) sendUDP(ctx context.Context, fq *forwardQuery, rr resolverAn\n \treturn out, nil\n }\n \n+var optDNSForwardUseRoutes = envknob.RegisterOptBool(\"TS_DEBUG_DNS_FORWARD_USE_ROUTES\")\n+\n+// ShouldUseRoutes reports whether the DNS resolver should consider routes when dialing\n+// upstream nameservers via TCP.\n+//\n+// If true, routes should be considered ([tsdial.Dialer.UserDial]), otherwise defer\n+// to the system routes ([tsdial.Dialer.SystemDial]).\n+//\n+// TODO(nickkhyl): Update [tsdial.Dialer] to reuse the bart.Table we create in net/tstun.Wrapper\n+// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n+// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n+//\n+// See tailscale/tailscale#12027.\n+func ShouldUseRoutes(knobs *controlknobs.Knobs) bool {\n+\tswitch runtime.GOOS {\n+\tcase \"android\", \"ios\":\n+\t\t// On mobile platforms with lower memory limits (e.g., 50MB on iOS),\n+\t\t// this behavior is still gated by the \"user-dial-routes\" nodeAttr.\n+\t\treturn knobs != nil && knobs.UserDialUseRoutes.Load()\n+\tdefault:\n+\t\t// On all other platforms, it is the default behavior,\n+\t\t// but it can be overridden with the \"TS_DEBUG_DNS_FORWARD_USE_ROUTES\" env var.\n+\t\tdoNotUseRoutes := optDNSForwardUseRoutes().EqualBool(false)\n+\t\treturn !doNotUseRoutes\n+\t}\n+}\n+\n func (f *forwarder) getDialerType() netx.DialFunc {\n-\tif f.controlKnobs != nil && f.controlKnobs.UserDialUseRoutes.Load() {\n-\t\t// It is safe to use UserDial as it dials external servers without going through Tailscale\n-\t\t// and closes connections on interface change in the same way as SystemDial does,\n-\t\t// thus preventing DNS resolution issues when switching between WiFi and cellular,\n-\t\t// but can also dial an internal DNS server on the Tailnet or via a subnet router.\n-\t\t//\n-\t\t// TODO(nickkhyl): Update tsdial.Dialer to reuse the bart.Table we create in net/tstun.Wrapper\n-\t\t// to avoid having two bart tables in memory, especially on iOS. Once that's done,\n-\t\t// we can get rid of the nodeAttr/control knob and always use UserDial for DNS.\n-\t\t//\n-\t\t// See https://github.com/tailscale/tailscale/issues/12027.\n+\tif ShouldUseRoutes(f.controlKnobs) {\n \t\treturn f.dialer.UserDial\n \t}\n \treturn f.dialer.SystemDial\n---\nnet/tsdial/tsdial.go\n@@ -151,6 +151,7 @@ func (d *Dialer) SetRoutes(routes, localRoutes []netip.Prefix) {\n \t\tfor _, r := range localRoutes {\n \t\t\trt.Insert(r, false)\n \t\t}\n+\t\td.logf(\"tsdial: bart table size: %d\", rt.Size())\n \t}\n \n \td.routes.Store(rt)\n---\ntsnet/depaware.txt\n@@ -271,7 +271,7 @@ tailscale.com/tsnet dependencies: (generated by github.com/tailscale/depaware)\n         tailscale.com/net/dns/publicdns                              from tailscale.com/net/dns+\n         tailscale.com/net/dns/recursive                              from tailscale.com/net/dnsfallback\n         tailscale.com/net/dns/resolvconffile                         from tailscale.com/net/dns+\n-        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns\n+        tailscale.com/net/dns/resolver                               from tailscale.com/net/dns+\n         tailscale.com/net/dnscache                                   from tailscale.com/control/controlclient+\n         tailscale.com/net/dnsfallback                                from tailscale.com/control/controlclient+\n         tailscale.com/net/flowtrack                                  from tailscale.com/net/packet+\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n`(*LocalBackend).setControlClientLocked()` is called to both set and reset `b.cc`. We shouldn't attempt to start the audit logger when `b.cc` is being reset (i.e., `cc` is `nil`).\r\n\r\nHowever, it's fine to start the audit logger if `b.cc` implements `auditlog.Transport`, even if it's not a `controlclient.Auto` but a mock control client.\r\n\r\nIn this PR, we fix both issues and add an assertion that `*controlclient.Auto` is an `auditlog.Transport`. This ensures a compile-time failure if `*controlclient.Auto` ever stops being a valid transport due to future interface or implementation changes.\r\n\r\nUpdates tailscale/corp#26435\n\n---\n\nChoice A:\nipn/ipnlocal/local.go\n@@ -5918,19 +5918,22 @@ func (b *LocalBackend) requestEngineStatusAndWait() {\n \tb.logf(\"requestEngineStatusAndWait: got status update.\")\n }\n \n+// [controlclient.Auto] implements [auditlog.Transport].\n+var _ auditlog.Transport = (*controlclient.Auto)(nil)\n+\n // setControlClientLocked sets the control client to cc,\n // which may be nil.\n //\n // b.mu must be held.\n func (b *LocalBackend) setControlClientLocked(cc controlclient.Client) {\n \tb.cc = cc\n \tb.ccAuto, _ = cc.(*controlclient.Auto)\n-\tif b.auditLogger != nil {\n+\tif t, ok := b.cc.(auditlog.Transport); ok && b.auditLogger != nil {\n \t\tif err := b.auditLogger.SetProfileID(b.pm.CurrentProfile().ID()); err != nil {\n \t\t\tb.logf(\"audit logger set profile ID failure: %v\", err)\n \t\t}\n \n-\t\tif err := b.auditLogger.Start(b.ccAuto); err != nil {\n+\t\tif err := b.auditLogger.Start(t); err != nil {\n \t\t\tb.logf(\"audit logger start failure: %v\", err)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice B:\ntstest/integration/integration_test.go\n@@ -1942,6 +1942,8 @@ func (n *testNode) AwaitIP6() netip.Addr {\n \n // AwaitRunning waits for n to reach the IPN state \"Running\".\n func (n *testNode) AwaitRunning() {\n+\tt := n.env.t\n+\tt.Helper()\n \tn.AwaitBackendState(\"Running\")\n }\n \n@@ -2015,7 +2017,7 @@ func (n *testNode) Status() (*ipnstate.Status, error) {\n \t}\n \tst := new(ipnstate.Status)\n \tif err := json.Unmarshal(out, st); err != nil {\n-\t\treturn nil, fmt.Errorf(\"decoding tailscale status JSON: %w\", err)\n+\t\treturn nil, fmt.Errorf(\"decoding tailscale status JSON: %w\\njson:\\n%s\", err, out)\n \t}\n \treturn st, nil\n }\n---\n\n\n---\n\nChoice C:\nposture/serialnumber_stub.go\n@@ -1,13 +1,12 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n-// android: not implemented\n // js: not implemented\n // plan9: not implemented\n // solaris: currently unsupported by go-smbios:\n // https://github.com/digitalocean/go-smbios/pull/21\n \n-//go:build android || solaris || plan9 || js || wasm || tamago || aix || (darwin && !cgo && !ios)\n+//go:build solaris || plan9 || js || wasm || tamago || aix || (darwin && !cgo && !ios)\n \n package posture\n \n---\nposture/serialnumber_syspolicy.go\n@@ -1,6 +1,8 @@\n // Copyright (c) Tailscale Inc & AUTHORS\n // SPDX-License-Identifier: BSD-3-Clause\n \n+//go:build android || ios\n+\n package posture\n \n import (\n@@ -10,9 +12,9 @@ import (\n \t\"tailscale.com/util/syspolicy\"\n )\n \n-// GetSerialNumbers returns the serial number of the iOS/tvOS device as reported by an\n+// GetSerialNumbers returns the serial number of the device as reported by an\n // MDM solution. It requires configuration via the DeviceSerialNumber system policy.\n-// This is the only way to gather serial numbers on iOS and tvOS.\n+// This is the only way to gather serial numbers on iOS, tvOS and Android.\n func GetSerialNumbers(_ logger.Logf) ([]string, error) {\n \ts, err := syspolicy.GetString(syspolicy.DeviceSerialNumber, \"\")\n \tif err != nil {\n---\nutil/syspolicy/policy_keys.go\n@@ -126,8 +126,8 @@ const (\n \t// The default is \"user-decides\" unless otherwise stated.\n \tPostureChecking Key = \"PostureChecking\"\n \t// DeviceSerialNumber is the serial number of the device that is running Tailscale.\n-\t// This is used on iOS/tvOS to allow IT administrators to manually give us a serial number via MDM.\n-\t// We are unable to programmatically get the serial number from IOKit due to sandboxing restrictions.\n+\t// This is used on Android, iOS and tvOS to allow IT administrators to manually give us a serial number via MDM.\n+\t// We are unable to programmatically get the serial number on mobile due to sandboxing restrictions.\n \tDeviceSerialNumber Key = \"DeviceSerialNumber\"\n \n \t// ManagedByOrganizationName indicates the name of the organization managing the Tailscale\n---\n\n\n---\n\nChoice D:\ntstime/tstime.go\n@@ -6,6 +6,7 @@ package tstime\n \n import (\n \t\"context\"\n+\t\"encoding\"\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n@@ -183,3 +184,40 @@ func (StdClock) AfterFunc(d time.Duration, f func()) TimerController {\n func (StdClock) Since(t time.Time) time.Duration {\n \treturn time.Since(t)\n }\n+\n+// GoDuration is a [time.Duration] but JSON serializes with [time.Duration.String].\n+//\n+// Note that this format is specific to Go and non-standard,\n+// but excels in being most humanly readable compared to alternatives.\n+// The wider industry still lacks consensus for the representation\n+// of a time duration in humanly-readable text.\n+// See https://go.dev/issue/71631 for more discussion.\n+//\n+// Regardless of how the industry evolves into the future,\n+// this type explicitly uses the Go format.\n+type GoDuration struct{ time.Duration }\n+\n+var (\n+\t_ encoding.TextAppender    = (*GoDuration)(nil)\n+\t_ encoding.TextMarshaler   = (*GoDuration)(nil)\n+\t_ encoding.TextUnmarshaler = (*GoDuration)(nil)\n+)\n+\n+func (d GoDuration) AppendText(b []byte) ([]byte, error) {\n+\t// The String method is inlineable (see https://go.dev/cl/520602),\n+\t// so this may not allocate since the string does not escape.\n+\treturn append(b, d.String()...), nil\n+}\n+\n+func (d GoDuration) MarshalText() ([]byte, error) {\n+\treturn []byte(d.String()), nil\n+}\n+\n+func (d *GoDuration) UnmarshalText(b []byte) error {\n+\td2, err := time.ParseDuration(string(b))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\td.Duration = d2\n+\treturn nil\n+}\n---\ntstime/tstime_test.go\n@@ -4,8 +4,11 @@\n package tstime\n \n import (\n+\t\"encoding/json\"\n \t\"testing\"\n \t\"time\"\n+\n+\t\"tailscale.com/util/must\"\n )\n \n func TestParseDuration(t *testing.T) {\n@@ -34,3 +37,17 @@ func TestParseDuration(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestGoDuration(t *testing.T) {\n+\twantDur := GoDuration{time.Hour + time.Minute + time.Second + time.Millisecond + time.Microsecond + time.Nanosecond}\n+\tgotJSON := string(must.Get(json.Marshal(wantDur)))\n+\twantJSON := `\"1h1m1.001001001s\"`\n+\tif gotJSON != wantJSON {\n+\t\tt.Errorf(\"json.Marshal(%v) = %s, want %s\", wantDur, gotJSON, wantJSON)\n+\t}\n+\tvar gotDur GoDuration\n+\tmust.Do(json.Unmarshal([]byte(wantJSON), &gotDur))\n+\tif gotDur != wantDur {\n+\t\tt.Errorf(\"json.Unmarshal(%s) = %v, want %v\", wantJSON, gotDur, wantDur)\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis is a very dumb fix as it has an unbounded worst case runtime. IP allocation needs to be done in a more sane way in a follow-up.\r\n\r\nUpdates #15367\n\n---\n\nChoice A:\nnet/netcheck/netcheck.go\n@@ -1045,7 +1045,7 @@ func (c *Client) finishAndStoreReport(rs *reportState, dm *tailcfg.DERPMap) *Rep\n }\n \n // runHTTPOnlyChecks is the netcheck done by environments that can\n-// only do HTTP requests, such as ws/wasm.\n+// only do HTTP requests, such as js/wasm.\n func (c *Client) runHTTPOnlyChecks(ctx context.Context, last *Report, rs *reportState, dm *tailcfg.DERPMap) error {\n \tvar regions []*tailcfg.DERPRegion\n \tif rs.incremental && last != nil {\n@@ -1057,6 +1057,9 @@ func (c *Client) runHTTPOnlyChecks(ctx context.Context, last *Report, rs *report\n \t}\n \tif len(regions) == 0 {\n \t\tfor _, dr := range dm.Regions {\n+\t\t\tif dr.NoMeasureNoHome {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tregions = append(regions, dr)\n \t\t}\n \t}\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -64,7 +64,6 @@ import (\n \t\"tailscale.com/logpolicy\"\n \t\"tailscale.com/net/captivedetection\"\n \t\"tailscale.com/net/dns\"\n-\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/dnscache\"\n \t\"tailscale.com/net/dnsfallback\"\n \t\"tailscale.com/net/ipset\"\n@@ -4844,12 +4843,6 @@ func (b *LocalBackend) authReconfig() {\n \t}\n \tb.logf(\"[v1] authReconfig: ra=%v dns=%v 0x%02x: %v\", prefs.RouteAll(), prefs.CorpDNS(), flags, err)\n \n-\tif resolver.ShouldUseRoutes(b.ControlKnobs()) {\n-\t\tb.dialer.SetRoutes(rcfg.Routes, rcfg.LocalRoutes)\n-\t} else {\n-\t\tb.dialer.SetRoutes(nil, nil)\n-\t}\n-\n \tb.initPeerAPIListener()\n \tb.readvertiseAppConnectorRoutes()\n }\n---\nwgengine/userspace.go\n@@ -26,6 +26,7 @@ import (\n \t\"tailscale.com/health\"\n \t\"tailscale.com/ipn/ipnstate\"\n \t\"tailscale.com/net/dns\"\n+\t\"tailscale.com/net/dns/resolver\"\n \t\"tailscale.com/net/flowtrack\"\n \t\"tailscale.com/net/ipset\"\n \t\"tailscale.com/net/netmon\"\n@@ -102,6 +103,7 @@ type userspaceEngine struct {\n \ttundev           *tstun.Wrapper\n \twgdev            *device.Device\n \trouter           router.Router\n+\tdialer           *tsdial.Dialer\n \tconfListenPort   uint16 // original conf.ListenPort\n \tdns              *dns.Manager\n \tmagicConn        *magicsock.Conn\n@@ -344,6 +346,7 @@ func NewUserspaceEngine(logf logger.Logf, conf Config) (_ Engine, reterr error)\n \t\twaitCh:         make(chan struct{}),\n \t\ttundev:         tsTUNDev,\n \t\trouter:         rtr,\n+\t\tdialer:         conf.Dialer,\n \t\tconfListenPort: conf.ListenPort,\n \t\tbirdClient:     conf.BIRDClient,\n \t\tcontrolKnobs:   conf.ControlKnobs,\n@@ -1028,6 +1031,14 @@ func (e *userspaceEngine) Reconfig(cfg *wgcfg.Config, routerCfg *router.Config,\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\n+\t\tif resolver.ShouldUseRoutes(e.controlKnobs) {\n+\t\t\te.logf(\"wgengine: Reconfig: user dialer\")\n+\t\t\te.dialer.SetRoutes(routerCfg.Routes, routerCfg.LocalRoutes)\n+\t\t} else {\n+\t\t\te.dialer.SetRoutes(nil, nil)\n+\t\t}\n+\n \t\t// Keep DNS configuration after router configuration, as some\n \t\t// DNS managers refuse to apply settings if the device has no\n \t\t// assigned address.\n---\n\n\n---\n\nChoice C:\nfeature/capture/dissector/ts-dissector.lua\n@@ -1,5 +1,5 @@\n function hasbit(x, p)\n-  return x % (p + p) >= p       \n+  return bit.band(x, p) ~= 0\n end\n \n tsdebug_ll = Proto(\"tsdebug\", \"Tailscale debug\")\n@@ -128,6 +128,10 @@ function tsdisco_frame.dissector(buffer, pinfo, tree)\n     if     message_type == 1 then subtree:add(DISCO_TYPE, \"Ping\")\n     elseif message_type == 2 then subtree:add(DISCO_TYPE, \"Pong\")\n     elseif message_type == 3 then subtree:add(DISCO_TYPE, \"Call me maybe\")\n+    elseif message_type == 4 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint\")\n+    elseif message_type == 5 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint Challenge\")\n+    elseif message_type == 6 then subtree:add(DISCO_TYPE, \"Bind UDP Relay Endpoint Answer\")\n+    elseif message_type == 7 then subtree:add(DISCO_TYPE, \"Call me maybe via\")\n     end\n \n     -- Message version\n---\n\n\n---\n\nChoice D:\ncmd/natc/natc.go\n@@ -94,18 +94,24 @@ func main() {\n \t\t}\n \t\tignoreDstTable.Insert(pfx, true)\n \t}\n-\tvar v4Prefixes []netip.Prefix\n+\tvar (\n+\t\tv4Prefixes    []netip.Prefix\n+\t\tnumV4DNSAddrs int\n+\t)\n \tfor _, s := range strings.Split(*v4PfxStr, \",\") {\n \t\tp := netip.MustParsePrefix(strings.TrimSpace(s))\n \t\tif p.Masked() != p {\n \t\t\tlog.Fatalf(\"v4 prefix %v is not a masked prefix\", p)\n \t\t}\n \t\tv4Prefixes = append(v4Prefixes, p)\n+\t\tnumIPs := 1 << (32 - p.Bits())\n+\t\tnumV4DNSAddrs += numIPs\n \t}\n \tif len(v4Prefixes) == 0 {\n \t\tlog.Fatalf(\"no v4 prefixes specified\")\n \t}\n \tdnsAddr := v4Prefixes[0].Addr()\n+\tnumV4DNSAddrs -= 1 // Subtract the dnsAddr allocated above.\n \tts := &tsnet.Server{\n \t\tHostname: *hostname,\n \t}\n@@ -153,12 +159,13 @@ func main() {\n \t}\n \n \tc := &connector{\n-\t\tts:         ts,\n-\t\tlc:         lc,\n-\t\tdnsAddr:    dnsAddr,\n-\t\tv4Ranges:   v4Prefixes,\n-\t\tv6ULA:      ula(uint16(*siteID)),\n-\t\tignoreDsts: ignoreDstTable,\n+\t\tts:            ts,\n+\t\tlc:            lc,\n+\t\tdnsAddr:       dnsAddr,\n+\t\tv4Ranges:      v4Prefixes,\n+\t\tnumV4DNSAddrs: numV4DNSAddrs,\n+\t\tv6ULA:         ula(uint16(*siteID)),\n+\t\tignoreDsts:    ignoreDstTable,\n \t}\n \tc.run(ctx)\n }\n@@ -177,6 +184,11 @@ type connector struct {\n \t// v4Ranges is the list of IPv4 ranges to advertise and assign addresses from.\n \t// These are masked prefixes.\n \tv4Ranges []netip.Prefix\n+\n+\t// numV4DNSAddrs is the total size of the IPv4 ranges in addresses, minus the\n+\t// dnsAddr allocation.\n+\tnumV4DNSAddrs int\n+\n \t// v6ULA is the ULA prefix used by the app connector to assign IPv6 addresses.\n \tv6ULA netip.Prefix\n \n@@ -502,6 +514,7 @@ type perPeerState struct {\n \tmu           sync.Mutex\n \tdomainToAddr map[string][]netip.Addr\n \taddrToDomain *bart.Table[string]\n+\tnumV4Allocs  int\n }\n \n // domainForIP returns the domain name assigned to the given IP address and\n@@ -547,17 +560,25 @@ func (ps *perPeerState) isIPUsedLocked(ip netip.Addr) bool {\n \n // unusedIPv4Locked returns an unused IPv4 address from the available ranges.\n func (ps *perPeerState) unusedIPv4Locked() netip.Addr {\n+\t// All addresses have been allocated.\n+\tif ps.numV4Allocs >= ps.c.numV4DNSAddrs {\n+\t\treturn netip.Addr{}\n+\t}\n+\n \t// TODO: skip ranges that have been exhausted\n-\tfor _, r := range ps.c.v4Ranges {\n-\t\tip := randV4(r)\n-\t\tfor r.Contains(ip) {\n+\t// TODO: implement a much more efficient algorithm for finding unused IPs,\n+\t// this is fairly crazy.\n+\tfor {\n+\t\tfor _, r := range ps.c.v4Ranges {\n+\t\t\tip := randV4(r)\n+\t\t\tif !r.Contains(ip) {\n+\t\t\t\tpanic(\"error: randV4 returned invalid address\")\n+\t\t\t}\n \t\t\tif !ps.isIPUsedLocked(ip) && ip != ps.c.dnsAddr {\n \t\t\t\treturn ip\n \t\t\t}\n-\t\t\tip = ip.Next()\n \t\t}\n \t}\n-\treturn netip.Addr{}\n }\n \n // randV4 returns a random IPv4 address within the given prefix.\n@@ -583,6 +604,7 @@ func (ps *perPeerState) assignAddrsLocked(domain string) []netip.Addr {\n \tif !v4.IsValid() {\n \t\treturn nil\n \t}\n+\tps.numV4Allocs++\n \tas16 := ps.c.v6ULA.Addr().As16()\n \tas4 := v4.As4()\n \tcopy(as16[12:], as4[:])\n---\ncmd/natc/natc_test.go\n@@ -4,6 +4,8 @@\n package main\n \n import (\n+\t\"errors\"\n+\t\"fmt\"\n \t\"net/netip\"\n \t\"slices\"\n \t\"testing\"\n@@ -225,9 +227,10 @@ func TestDNSResponse(t *testing.T) {\n \n func TestPerPeerState(t *testing.T) {\n \tc := &connector{\n-\t\tv4Ranges: []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n-\t\tv6ULA:    netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n-\t\tdnsAddr:  netip.MustParseAddr(\"100.64.1.1\"),\n+\t\tv4Ranges:      []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n+\t\tv6ULA:         netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n+\t\tdnsAddr:       netip.MustParseAddr(\"100.64.1.0\"),\n+\t\tnumV4DNSAddrs: (1<<(32-24) - 1),\n \t}\n \n \tps := &perPeerState{c: c}\n@@ -328,9 +331,10 @@ func TestIgnoreDestination(t *testing.T) {\n \n func TestConnectorGenerateDNSResponse(t *testing.T) {\n \tc := &connector{\n-\t\tv4Ranges: []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n-\t\tv6ULA:    netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n-\t\tdnsAddr:  netip.MustParseAddr(\"100.64.1.1\"),\n+\t\tv4Ranges:      []netip.Prefix{netip.MustParsePrefix(\"100.64.1.0/24\")},\n+\t\tv6ULA:         netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n+\t\tdnsAddr:       netip.MustParseAddr(\"100.64.1.0\"),\n+\t\tnumV4DNSAddrs: (1<<(32-24) - 1),\n \t}\n \n \treq := &dnsmessage.Message{\n@@ -363,3 +367,63 @@ func TestConnectorGenerateDNSResponse(t *testing.T) {\n \t\tt.Errorf(\"generateDNSResponse() responses differ between calls\")\n \t}\n }\n+\n+func TestIPPoolExhaustion(t *testing.T) {\n+\tsmallPrefix := netip.MustParsePrefix(\"100.64.1.0/30\") // Only 4 IPs: .0, .1, .2, .3\n+\tc := &connector{\n+\t\tv6ULA:         netip.MustParsePrefix(\"fd7a:115c:a1e0:a99c:0001::/80\"),\n+\t\tv4Ranges:      []netip.Prefix{smallPrefix},\n+\t\tdnsAddr:       netip.MustParseAddr(\"100.64.1.0\"),\n+\t\tnumV4DNSAddrs: 3,\n+\t}\n+\n+\tps := &perPeerState{c: c}\n+\n+\tassignedIPs := make(map[netip.Addr]string)\n+\n+\tdomains := []string{\"a.example.com\", \"b.example.com\", \"c.example.com\", \"d.example.com\"}\n+\n+\tvar errs []error\n+\n+\tfor i := 0; i < 5; i++ {\n+\t\tfor _, domain := range domains {\n+\t\t\taddrs, err := ps.ipForDomain(domain)\n+\t\t\tif err != nil {\n+\t\t\t\terrs = append(errs, fmt.Errorf(\"failed to get IP for domain %q: %w\", domain, err))\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tfor _, addr := range addrs {\n+\t\t\t\tif d, ok := assignedIPs[addr]; ok {\n+\t\t\t\t\tif d != domain {\n+\t\t\t\t\t\tt.Errorf(\"IP %s reused for domain %q, previously assigned to %q\", addr, domain, d)\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tassignedIPs[addr] = domain\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor addr, domain := range assignedIPs {\n+\t\tif addr.Is4() && !smallPrefix.Contains(addr) {\n+\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, smallPrefix)\n+\t\t}\n+\t\tif addr.Is6() && !c.v6ULA.Contains(addr) {\n+\t\t\tt.Errorf(\"IP %s for domain %q not in expected range %s\", addr, domain, c.v6ULA)\n+\t\t}\n+\t\tif addr == c.dnsAddr {\n+\t\t\tt.Errorf(\"IP %s for domain %q is the reserved DNS address\", addr, domain)\n+\t\t}\n+\t}\n+\n+\t// expect one error for each iteration with the 4th domain\n+\tif len(errs) != 5 {\n+\t\tt.Errorf(\"Expected 5 errors, got %d: %v\", len(errs), errs)\n+\t}\n+\tfor _, err := range errs {\n+\t\tif !errors.Is(err, ErrNoIPsAvailable) {\n+\t\t\tt.Errorf(\"generateDNSResponse() error = %v, want ErrNoIPsAvailable\", err)\n+\t\t}\n+\t}\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nOnly send a stored raw map message in reply to a streaming map response. Otherwise a non-streaming map response might pick it up first, and potentially drop it. This guarantees that a map response sent via AddRawMapResponse will be picked up by the main map response loop in the client.\r\n\r\nFixes #15362\n\n---\n\nChoice A:\ncontrol/controlclient/direct.go\n@@ -95,15 +95,16 @@ type Direct struct {\n \tsfGroup     singleflight.Group[struct{}, *NoiseClient] // protects noiseClient creation.\n \tnoiseClient *NoiseClient\n \n-\tpersist      persist.PersistView\n-\tauthKey      string\n-\ttryingNewKey key.NodePrivate\n-\texpiry       time.Time         // or zero value if none/unknown\n-\thostinfo     *tailcfg.Hostinfo // always non-nil\n-\tnetinfo      *tailcfg.NetInfo\n-\tendpoints    []tailcfg.Endpoint\n-\ttkaHead      string\n-\tlastPingURL  string // last PingRequest.URL received, for dup suppression\n+\tpersist                 persist.PersistView\n+\tauthKey                 string\n+\ttryingNewKey            key.NodePrivate\n+\texpiry                  time.Time         // or zero value if none/unknown\n+\thostinfo                *tailcfg.Hostinfo // always non-nil\n+\tnetinfo                 *tailcfg.NetInfo\n+\tendpoints               []tailcfg.Endpoint\n+\ttkaHead                 string\n+\tlastPingURL             string // last PingRequest.URL received, for dup suppression\n+\tconnectionHandleForTest string // sent in MapRequest.ConnectionHandleForTest\n }\n \n // Observer is implemented by users of the control client (such as LocalBackend)\n@@ -403,6 +404,14 @@ func (c *Direct) SetTKAHead(tkaHead string) bool {\n \treturn true\n }\n \n+// SetConnectionHandleForTest stores a new MapRequest.ConnectionHandleForTest\n+// value for the next update.\n+func (c *Direct) SetConnectionHandleForTest(handle string) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tc.connectionHandleForTest = handle\n+}\n+\n func (c *Direct) GetPersist() persist.PersistView {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n@@ -851,6 +860,7 @@ func (c *Direct) sendMapRequest(ctx context.Context, isStreaming bool, nu Netmap\n \tserverNoiseKey := c.serverNoiseKey\n \thi := c.hostInfoLocked()\n \tbackendLogID := hi.BackendLogID\n+\tconnectionHandleForTest := c.connectionHandleForTest\n \tvar epStrs []string\n \tvar eps []netip.AddrPort\n \tvar epTypes []tailcfg.EndpointType\n@@ -891,17 +901,18 @@ func (c *Direct) sendMapRequest(ctx context.Context, isStreaming bool, nu Netmap\n \n \tnodeKey := persist.PublicNodeKey()\n \trequest := &tailcfg.MapRequest{\n-\t\tVersion:       tailcfg.CurrentCapabilityVersion,\n-\t\tKeepAlive:     true,\n-\t\tNodeKey:       nodeKey,\n-\t\tDiscoKey:      c.discoPubKey,\n-\t\tEndpoints:     eps,\n-\t\tEndpointTypes: epTypes,\n-\t\tStream:        isStreaming,\n-\t\tHostinfo:      hi,\n-\t\tDebugFlags:    c.debugFlags,\n-\t\tOmitPeers:     nu == nil,\n-\t\tTKAHead:       c.tkaHead,\n+\t\tVersion:                 tailcfg.CurrentCapabilityVersion,\n+\t\tKeepAlive:               true,\n+\t\tNodeKey:                 nodeKey,\n+\t\tDiscoKey:                c.discoPubKey,\n+\t\tEndpoints:               eps,\n+\t\tEndpointTypes:           epTypes,\n+\t\tStream:                  isStreaming,\n+\t\tHostinfo:                hi,\n+\t\tDebugFlags:              c.debugFlags,\n+\t\tOmitPeers:               nu == nil,\n+\t\tTKAHead:                 c.tkaHead,\n+\t\tConnectionHandleForTest: connectionHandleForTest,\n \t}\n \tvar extraDebugFlags []string\n \tif hi != nil && c.netMon != nil && !c.skipIPForwardingCheck &&\n---\ntailcfg/tailcfg.go\n@@ -1385,6 +1385,12 @@ type MapRequest struct {\n \t//     * \"warn-router-unhealthy\": client's Router implementation is\n \t//       having problems.\n \tDebugFlags []string `json:\",omitempty\"`\n+\n+\t// ConnectionHandleForTest, if non-empty, is an opaque string sent by the client that\n+\t// identifies this specific connection to the server. The server may choose to\n+\t// use this handle to identify the connection for debugging or testing\n+\t// purposes. It has no semantic meaning.\n+\tConnectionHandleForTest string `json:\",omitempty\"`\n }\n \n // PortRange represents a range of UDP or TCP port numbers.\n---\n\n\n---\n\nChoice B:\ntstest/integration/testcontrol/testcontrol.go\n@@ -839,15 +839,17 @@ func (s *Server) serveMap(w http.ResponseWriter, r *http.Request, mkey key.Machi\n \n \tw.WriteHeader(200)\n \tfor {\n-\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n-\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n-\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif streaming {\n+\t\t// Only send raw map responses to the streaming poll, to avoid a\n+\t\t// non-streaming map request beating the streaming poll in a race and\n+\t\t// potentially dropping the map response.\n+\t\tif streaming {\n+\t\t\tif resBytes, ok := s.takeRawMapMessage(req.NodeKey); ok {\n+\t\t\t\tif err := s.sendMapMsg(w, compress, resBytes); err != nil {\n+\t\t\t\t\ts.logf(\"sendMapMsg of raw message: %v\", err)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treturn\n \t\t}\n \n \t\tif s.canGenerateAutomaticMapResponseFor(req.NodeKey) {\n---\n\n\n---\n\nChoice C:\nutil/set/smallset.go\n@@ -50,6 +50,15 @@ func (s SmallSet[T]) Contains(e T) bool {\n \treturn e != zero && s.one == e\n }\n \n+// SoleElement returns the single value in the set, if the set has exactly one\n+// element.\n+//\n+// If the set is empty or has more than one element, ok will be false and e will\n+// be the zero value of T.\n+func (s SmallSet[T]) SoleElement() (e T, ok bool) {\n+\treturn s.one, s.Len() == 1\n+}\n+\n // Add adds e to the set.\n //\n // When storing a SmallSet in a map as a value type, it is important to\n@@ -61,10 +70,15 @@ func (s *SmallSet[T]) Add(e T) {\n \t\ts.m.Add(e)\n \t\treturn\n \t}\n-\t// Size zero to one non-zero element.\n-\tif s.one == zero && e != zero {\n-\t\ts.one = e\n-\t\treturn\n+\t// Non-zero elements can go into s.one.\n+\tif e != zero {\n+\t\tif s.one == zero {\n+\t\t\ts.one = e // Len 0 to Len 1\n+\t\t\treturn\n+\t\t}\n+\t\tif s.one == e {\n+\t\t\treturn // dup\n+\t\t}\n \t}\n \t// Need to make a multi map, either\n \t// because we now have two items, or\n@@ -73,7 +87,7 @@ func (s *SmallSet[T]) Add(e T) {\n \tif s.one != zero {\n \t\ts.m.Add(s.one) // move single item to multi\n \t}\n-\ts.m.Add(e) // add new item\n+\ts.m.Add(e) // add new item, possibly zero\n \ts.one = zero\n }\n \n---\nutil/set/smallset_test.go\n@@ -84,8 +84,43 @@ func TestSmallSet(t *testing.T) {\n \t\t\t\t\t\t\tt.Errorf(\"contains(%v) mismatch after ops %s: normal=%v, small=%v\", e, name(), normal.Contains(e), small.Contains(e))\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\n+\t\t\t\t\tif err := small.checkInvariants(); err != nil {\n+\t\t\t\t\t\tt.Errorf(\"checkInvariants failed after ops %s: %v\", name(), err)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif !t.Failed() {\n+\t\t\t\t\t\tsole, ok := small.SoleElement()\n+\t\t\t\t\t\tif ok != (small.Len() == 1) {\n+\t\t\t\t\t\t\tt.Errorf(\"SoleElement ok mismatch after ops %s: SoleElement ok=%v, want=%v\", name(), ok, !ok)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif ok && sole != smallEle[0] {\n+\t\t\t\t\t\t\tt.Errorf(\"SoleElement value mismatch after ops %s: SoleElement=%v, want=%v\", name(), sole, smallEle[0])\n+\t\t\t\t\t\t\tt.Errorf(\"Internals: %+v\", small)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (s *SmallSet[T]) checkInvariants() error {\n+\tvar zero T\n+\tif s.m != nil && s.one != zero {\n+\t\treturn fmt.Errorf(\"both m and one are non-zero\")\n+\t}\n+\tif s.m != nil {\n+\t\tswitch len(s.m) {\n+\t\tcase 0:\n+\t\t\treturn fmt.Errorf(\"m is non-nil but empty\")\n+\t\tcase 1:\n+\t\t\tfor k := range s.m {\n+\t\t\t\tif k != zero {\n+\t\t\t\t\treturn fmt.Errorf(\"m contains exactly 1 non-zero element, %v\", k)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n+\treturn nil\n }\n---\n\n\n---\n\nChoice D:\ngo.toolchain.rev\n@@ -1 +1 @@\n-16b6e4fd15c59336156cdbc977de1745ad094f2d\n+982da8f24fa0504f2214f24b0d68b2febd5983f8\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis adds a portable way to do a raw LocalAPI request without worrying\nabout the Unix-vs-macOS-vs-Windows ways of hitting the LocalAPI server.\n(It was already possible but tedious with 'tailscale debug local-creds')\n\nUpdates tailscale/corp#24690\n\n\n---\n\nChoice A:\ntailcfg/tailcfg.go\n@@ -2446,6 +2446,14 @@ const (\n \t// native tailnet. This is currently only sent to Hello, in its\n \t// peer node list.\n \tNodeAttrNativeIPV4 NodeCapability = \"native-ipv4\"\n+\n+\t// NodeAttrRelayServer permits the node to act as an underlay UDP relay\n+\t// server. There are no expected values for this key in NodeCapMap.\n+\tNodeAttrRelayServer NodeCapability = \"relay:server\"\n+\n+\t// NodeAttrRelayClient permits the node to act as an underlay UDP relay\n+\t// client. There are no expected values for this key in NodeCapMap.\n+\tNodeAttrRelayClient NodeCapability = \"relay:client\"\n )\n \n // SetDNSRequest is a request to add a DNS record.\n---\n\n\n---\n\nChoice B:\nrelease/dist/cli/cli.go\n@@ -65,6 +65,7 @@ func CLI(getTargets func() ([]dist.Target, error)) *ffcli.Command {\n \t\t\t\t\tfs.StringVar(&buildArgs.manifest, \"manifest\", \"\", \"manifest file to write\")\n \t\t\t\t\tfs.BoolVar(&buildArgs.verbose, \"verbose\", false, \"verbose logging\")\n \t\t\t\t\tfs.StringVar(&buildArgs.webClientRoot, \"web-client-root\", \"\", \"path to root of web client source to build\")\n+\t\t\t\t\tfs.StringVar(&buildArgs.outPath, \"out\", \"\", \"path to write output artifacts (defaults to '$PWD/dist' if not set)\")\n \t\t\t\t\treturn fs\n \t\t\t\t})(),\n \t\t\t\tLongHelp: strings.TrimSpace(`\n@@ -156,6 +157,7 @@ var buildArgs struct {\n \tmanifest      string\n \tverbose       bool\n \twebClientRoot string\n+\toutPath       string\n }\n \n func runBuild(ctx context.Context, filters []string, targets []dist.Target) error {\n@@ -172,7 +174,11 @@ func runBuild(ctx context.Context, filters []string, targets []dist.Target) erro\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting working directory: %w\", err)\n \t}\n-\tb, err := dist.NewBuild(wd, filepath.Join(wd, \"dist\"))\n+\toutPath := filepath.Join(wd, \"dist\")\n+\tif buildArgs.outPath != \"\" {\n+\t\toutPath = buildArgs.outPath\n+\t}\n+\tb, err := dist.NewBuild(wd, outPath)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"creating build context: %w\", err)\n \t}\n---\n\n\n---\n\nChoice C:\ncmd/tailscale/cli/debug.go\n@@ -136,6 +136,17 @@ func debugCmd() *ffcli.Command {\n \t\t\t\tExec:       runLocalCreds,\n \t\t\t\tShortHelp:  \"Print how to access Tailscale LocalAPI\",\n \t\t\t},\n+\t\t\t{\n+\t\t\t\tName:       \"localapi\",\n+\t\t\t\tShortUsage: \"tailscale debug localapi [<method>] <path> [<body| \\\"-\\\">]\",\n+\t\t\t\tExec:       runLocalAPI,\n+\t\t\t\tShortHelp:  \"Call a LocalAPI method directly\",\n+\t\t\t\tFlagSet: (func() *flag.FlagSet {\n+\t\t\t\t\tfs := newFlagSet(\"localapi\")\n+\t\t\t\t\tfs.BoolVar(&localAPIFlags.verbose, \"v\", false, \"verbose; dump HTTP headers\")\n+\t\t\t\t\treturn fs\n+\t\t\t\t})(),\n+\t\t\t},\n \t\t\t{\n \t\t\t\tName:       \"restun\",\n \t\t\t\tShortUsage: \"tailscale debug restun\",\n@@ -451,6 +462,81 @@ func runLocalCreds(ctx context.Context, args []string) error {\n \treturn nil\n }\n \n+func looksLikeHTTPMethod(s string) bool {\n+\tif len(s) > len(\"OPTIONS\") {\n+\t\treturn false\n+\t}\n+\tfor _, r := range s {\n+\t\tif r < 'A' || r > 'Z' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+var localAPIFlags struct {\n+\tverbose bool\n+}\n+\n+func runLocalAPI(ctx context.Context, args []string) error {\n+\tif len(args) == 0 {\n+\t\treturn errors.New(\"expected at least one argument\")\n+\t}\n+\tmethod := \"GET\"\n+\tif looksLikeHTTPMethod(args[0]) {\n+\t\tmethod = args[0]\n+\t\targs = args[1:]\n+\t\tif len(args) == 0 {\n+\t\t\treturn errors.New(\"expected at least one argument after method\")\n+\t\t}\n+\t}\n+\tpath := args[0]\n+\tif !strings.HasPrefix(path, \"/localapi/\") {\n+\t\tif !strings.Contains(path, \"/\") {\n+\t\t\tpath = \"/localapi/v0/\" + path\n+\t\t} else {\n+\t\t\tpath = \"/localapi/\" + path\n+\t\t}\n+\t}\n+\n+\tvar body io.Reader\n+\tif len(args) > 1 {\n+\t\tif args[1] == \"-\" {\n+\t\t\tfmt.Fprintf(Stderr, \"# reading request body from stdin...\\n\")\n+\t\t\tall, err := io.ReadAll(os.Stdin)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"reading Stdin: %q\", err)\n+\t\t\t}\n+\t\t\tbody = bytes.NewReader(all)\n+\t\t} else {\n+\t\t\tbody = strings.NewReader(args[1])\n+\t\t}\n+\t}\n+\treq, err := http.NewRequest(method, \"http://local-tailscaled.sock\"+path, body)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tfmt.Fprintf(Stderr, \"# doing request %s %s\\n\", method, path)\n+\n+\tres, err := localClient.DoLocalRequest(req)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tis2xx := res.StatusCode >= 200 && res.StatusCode <= 299\n+\tif localAPIFlags.verbose {\n+\t\tres.Write(Stdout)\n+\t} else {\n+\t\tif !is2xx {\n+\t\t\tfmt.Fprintf(Stderr, \"# Response status %s\\n\", res.Status)\n+\t\t}\n+\t\tio.Copy(Stdout, res.Body)\n+\t}\n+\tif is2xx {\n+\t\treturn nil\n+\t}\n+\treturn errors.New(res.Status)\n+}\n+\n type localClientRoundTripper struct{}\n \n func (localClientRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n---\n\n\n---\n\nChoice D:\nipn/localapi/localapi.go\n@@ -397,6 +397,15 @@ func (h *Handler) serveBugReport(w http.ResponseWriter, r *http.Request) {\n \t// OS-specific details\n \th.logf.JSON(1, \"UserBugReportOS\", osdiag.SupportInfo(osdiag.LogSupportInfoReasonBugReport))\n \n+\t// Tailnet lock details\n+\tst := h.b.NetworkLockStatus()\n+\tif st.Enabled {\n+\t\th.logf.JSON(1, \"UserBugReportTailnetLockStatus\", st)\n+\t\tif st.NodeKeySignature != nil {\n+\t\t\th.logf(\"user bugreport tailnet lock signature: %s\", st.NodeKeySignature.String())\n+\t\t}\n+\t}\n+\n \tif defBool(r.URL.Query().Get(\"diagnose\"), false) {\n \t\th.b.Doctor(r.Context(), logger.WithPrefix(h.logf, \"diag: \"))\n \t}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIf conffile is used to configure tailscaled, always update currently advertised services from conffile, even if they are empty in the conffile, to ensure that it is possible to transition to a state where no services are advertised.\r\n\r\nUpdates tailscale/corp#24795\n\n---\n\nChoice A:\nprober/derp.go\n@@ -596,11 +596,23 @@ func (d *derpProber) updateMap(ctx context.Context) error {\n }\n \n func (d *derpProber) ProbeUDP(ipaddr string, port int) ProbeClass {\n+\tinitLabels := make(Labels)\n+\tip := net.ParseIP(ipaddr)\n+\n+\tif ip.To4() != nil {\n+\t\tinitLabels[\"address_family\"] = \"ipv4\"\n+\t} else if ip.To16() != nil { // Will return an IPv4 as 16 byte, so ensure the check for IPv4 precedes this\n+\t\tinitLabels[\"address_family\"] = \"ipv6\"\n+\t} else {\n+\t\tinitLabels[\"address_family\"] = \"unknown\"\n+\t}\n+\n \treturn ProbeClass{\n \t\tProbe: func(ctx context.Context) error {\n \t\t\treturn derpProbeUDP(ctx, ipaddr, port)\n \t\t},\n-\t\tClass: \"derp_udp\",\n+\t\tClass:  \"derp_udp\",\n+\t\tLabels: initLabels,\n \t}\n }\n \n---\nprober/prober.go\n@@ -404,10 +404,14 @@ func (p *Probe) recordEndLocked(err error) {\n \t\tp.mSeconds.WithLabelValues(\"ok\").Add(latency.Seconds())\n \t\tp.latencyHist.Value = latency\n \t\tp.latencyHist = p.latencyHist.Next()\n+\t\tp.mAttempts.WithLabelValues(\"fail\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"fail\").Add(0)\n \t} else {\n \t\tp.latency = 0\n \t\tp.mAttempts.WithLabelValues(\"fail\").Inc()\n \t\tp.mSeconds.WithLabelValues(\"fail\").Add(latency.Seconds())\n+\t\tp.mAttempts.WithLabelValues(\"ok\").Add(0)\n+\t\tp.mSeconds.WithLabelValues(\"ok\").Add(0)\n \t}\n \tp.successHist.Value = p.succeeded\n \tp.successHist = p.successHist.Next()\n---\n\n\n---\n\nChoice B:\nipn/ipnlocal/local.go\n@@ -958,7 +958,9 @@ func (b *LocalBackend) linkChange(delta *netmon.ChangeDelta) {\n \n \tif peerAPIListenAsync && b.netMap != nil && b.state == ipn.Running {\n \t\twant := b.netMap.GetAddresses().Len()\n-\t\tif len(b.peerAPIListeners) < want {\n+\t\thave := len(b.peerAPIListeners)\n+\t\tb.logf(\"[v1] linkChange: have %d peerAPIListeners, want %d\", have, want)\n+\t\tif have < want {\n \t\t\tb.logf(\"linkChange: peerAPIListeners too low; trying again\")\n \t\t\tb.goTracker.Go(b.initPeerAPIListener)\n \t\t}\n@@ -5369,6 +5371,7 @@ func (b *LocalBackend) initPeerAPIListener() {\n \t\t\tln, err = ps.listen(a.Addr(), b.prevIfState)\n \t\t\tif err != nil {\n \t\t\t\tif peerAPIListenAsync {\n+\t\t\t\t\tb.logf(\"possibly transient peerapi listen(%q) error, will try again on linkChange: %v\", a.Addr(), err)\n \t\t\t\t\t// Expected. But we fix it later in linkChange\n \t\t\t\t\t// (\"peerAPIListeners too low\").\n \t\t\t\t\tcontinue\n---\n\n\n---\n\nChoice C:\nipn/conf.go\n@@ -145,9 +145,15 @@ func (c *ConfigVAlpha) ToPrefs() (MaskedPrefs, error) {\n \t\tmp.AppConnector = *c.AppConnector\n \t\tmp.AppConnectorSet = true\n \t}\n+\t// Configfile should be the source of truth for whether this node\n+\t// advertises any services.  We need to ensure that each reload updates\n+\t// currently advertised services as else the transition from 'some\n+\t// services are advertised' to 'advertised services are empty/unset in\n+\t// conffile' would have no effect (especially given that an empty\n+\t// service slice would be omitted from the JSON config).\n+\tmp.AdvertiseServicesSet = true\n \tif c.AdvertiseServices != nil {\n \t\tmp.AdvertiseServices = c.AdvertiseServices\n-\t\tmp.AdvertiseServicesSet = true\n \t}\n \treturn mp, nil\n }\n---\nipn/ipnlocal/local_test.go\n@@ -4745,32 +4745,133 @@ func TestLoginNotifications(t *testing.T) {\n // TestConfigFileReload tests that the LocalBackend reloads its configuration\n // when the configuration file changes.\n func TestConfigFileReload(t *testing.T) {\n-\tcfg1 := `{\"Hostname\": \"foo\", \"Version\": \"alpha0\"}`\n-\tf := filepath.Join(t.TempDir(), \"cfg\")\n-\tmust.Do(os.WriteFile(f, []byte(cfg1), 0600))\n-\tsys := new(tsd.System)\n-\tsys.InitialConfig = must.Get(conffile.Load(f))\n-\tlb := newTestLocalBackendWithSys(t, sys)\n-\tmust.Do(lb.Start(ipn.Options{}))\n-\n-\tlb.mu.Lock()\n-\thn := lb.hostinfo.Hostname\n-\tlb.mu.Unlock()\n-\tif hn != \"foo\" {\n-\t\tt.Fatalf(\"got %q; want %q\", hn, \"foo\")\n+\ttype testCase struct {\n+\t\tname    string\n+\t\tinitial *conffile.Config\n+\t\tupdated *conffile.Config\n+\t\tcheckFn func(*testing.T, *LocalBackend)\n \t}\n \n-\tcfg2 := `{\"Hostname\": \"bar\", \"Version\": \"alpha0\"}`\n-\tmust.Do(os.WriteFile(f, []byte(cfg2), 0600))\n-\tif !must.Get(lb.ReloadConfig()) {\n-\t\tt.Fatal(\"reload failed\")\n+\ttests := []testCase{\n+\t\t{\n+\t\t\tname: \"hostname_change\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:  \"alpha0\",\n+\t\t\t\t\tHostname: ptr.To(\"initial-host\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:  \"alpha0\",\n+\t\t\t\t\tHostname: ptr.To(\"updated-host\"),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif got := b.Prefs().Hostname(); got != \"updated-host\" {\n+\t\t\t\t\tt.Errorf(\"hostname = %q; want updated-host\", got)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"start_advertising_services\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion: \"alpha0\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\", \"svc:def\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif got := b.Prefs().AdvertiseServices().AsSlice(); !reflect.DeepEqual(got, []string{\"svc:abc\", \"svc:def\"}) {\n+\t\t\t\t\tt.Errorf(\"AdvertiseServices = %v; want [svc:abc, svc:def]\", got)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"change_advertised_services\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\", \"svc:def\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\", \"svc:ghi\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif got := b.Prefs().AdvertiseServices().AsSlice(); !reflect.DeepEqual(got, []string{\"svc:abc\", \"svc:ghi\"}) {\n+\t\t\t\t\tt.Errorf(\"AdvertiseServices = %v; want [svc:abc, svc:ghi]\", got)\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"unset_advertised_services\",\n+\t\t\tinitial: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion:           \"alpha0\",\n+\t\t\t\t\tAdvertiseServices: []string{\"svc:abc\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tupdated: &conffile.Config{\n+\t\t\t\tParsed: ipn.ConfigVAlpha{\n+\t\t\t\t\tVersion: \"alpha0\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tcheckFn: func(t *testing.T, b *LocalBackend) {\n+\t\t\t\tif b.Prefs().AdvertiseServices().Len() != 0 {\n+\t\t\t\t\tt.Errorf(\"got %d AdvertiseServices wants none\", b.Prefs().AdvertiseServices().Len())\n+\t\t\t\t}\n+\t\t\t},\n+\t\t},\n \t}\n \n-\tlb.mu.Lock()\n-\thn = lb.hostinfo.Hostname\n-\tlb.mu.Unlock()\n-\tif hn != \"bar\" {\n-\t\tt.Fatalf(\"got %q; want %q\", hn, \"bar\")\n+\tfor _, tc := range tests {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tdir := t.TempDir()\n+\t\t\tpath := filepath.Join(dir, \"tailscale.conf\")\n+\n+\t\t\t// Write initial config\n+\t\t\tinitialJSON, err := json.Marshal(tc.initial.Parsed)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif err := os.WriteFile(path, initialJSON, 0644); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\n+\t\t\t// Create backend with initial config\n+\t\t\ttc.initial.Path = path\n+\t\t\ttc.initial.Raw = initialJSON\n+\t\t\tsys := &tsd.System{\n+\t\t\t\tInitialConfig: tc.initial,\n+\t\t\t}\n+\t\t\tb := newTestLocalBackendWithSys(t, sys)\n+\n+\t\t\t// Update config file\n+\t\t\tupdatedJSON, err := json.Marshal(tc.updated.Parsed)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif err := os.WriteFile(path, updatedJSON, 0644); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\n+\t\t\t// Trigger reload\n+\t\t\tif ok, err := b.ReloadConfig(); !ok || err != nil {\n+\t\t\t\tt.Fatalf(\"ReloadConfig() = %v, %v; want true, nil\", ok, err)\n+\t\t\t}\n+\n+\t\t\t// Check outcome\n+\t\t\ttc.checkFn(t, b)\n+\t\t})\n \t}\n }\n \n---\n\n\n---\n\nChoice D:\nipn/desktop/mksyscall.go\n@@ -11,8 +11,6 @@ package desktop\n //sys registerClassEx(windowClass *_WNDCLASSEX) (atom uint16, err error) [atom==0] = user32.RegisterClassExW\n //sys createWindowEx(dwExStyle uint32, lpClassName *uint16, lpWindowName *uint16, dwStyle uint32, x int32, y int32, nWidth int32, nHeight int32, hWndParent windows.HWND, hMenu windows.Handle, hInstance windows.Handle, lpParam unsafe.Pointer) (hWnd windows.HWND, err error) [hWnd==0] = user32.CreateWindowExW\n //sys defWindowProc(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.DefWindowProcW\n-//sys setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) [res==0 && e1!=0] = user32.SetWindowLongPtrW\n-//sys getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) [res==0 && e1!=0] = user32.GetWindowLongPtrW\n //sys sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr) (res uintptr) = user32.SendMessageW\n //sys getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (ret int32) = user32.GetMessageW\n //sys translateMessage(lpMsg *_MSG) (res bool) = user32.TranslateMessage\n---\nipn/desktop/sessions_windows.go\n@@ -670,3 +670,38 @@ func (cs _WTS_CONNECTSTATE_CLASS) ToSessionStatus() SessionStatus {\n \t\treturn ClosedSession\n \t}\n }\n+\n+var (\n+\tprocGetWindowLongPtrW *windows.LazyProc\n+\tprocSetWindowLongPtrW *windows.LazyProc\n+)\n+\n+func init() {\n+\t// GetWindowLongPtrW and SetWindowLongPtrW are only available on 64-bit platforms.\n+\t// https://web.archive.org/web/20250414195520/https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw\n+\tif runtime.GOARCH == \"386\" || runtime.GOARCH == \"arm\" {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongW\")\n+\t} else {\n+\t\tprocGetWindowLongPtrW = moduser32.NewProc(\"GetWindowLongPtrW\")\n+\t\tprocSetWindowLongPtrW = moduser32.NewProc(\"SetWindowLongPtrW\")\n+\t}\n+}\n+\n+func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n+func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n+\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n+\tres = uintptr(r0)\n+\tif res == 0 && e1 != 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n---\nipn/desktop/zsyscall_windows.go\n@@ -48,11 +48,9 @@ var (\n \tprocDestroyWindow                      = moduser32.NewProc(\"DestroyWindow\")\n \tprocDispatchMessageW                   = moduser32.NewProc(\"DispatchMessageW\")\n \tprocGetMessageW                        = moduser32.NewProc(\"GetMessageW\")\n-\tprocGetWindowLongPtrW                  = moduser32.NewProc(\"GetWindowLongPtrW\")\n \tprocPostQuitMessage                    = moduser32.NewProc(\"PostQuitMessage\")\n \tprocRegisterClassExW                   = moduser32.NewProc(\"RegisterClassExW\")\n \tprocSendMessageW                       = moduser32.NewProc(\"SendMessageW\")\n-\tprocSetWindowLongPtrW                  = moduser32.NewProc(\"SetWindowLongPtrW\")\n \tprocTranslateMessage                   = moduser32.NewProc(\"TranslateMessage\")\n \tprocWTSRegisterSessionNotificationEx   = modwtsapi32.NewProc(\"WTSRegisterSessionNotificationEx\")\n \tprocWTSUnRegisterSessionNotificationEx = modwtsapi32.NewProc(\"WTSUnRegisterSessionNotificationEx\")\n@@ -98,15 +96,6 @@ func getMessage(lpMsg *_MSG, hwnd windows.HWND, msgMin uint32, msgMax uint32) (r\n \treturn\n }\n \n-func getWindowLongPtr(hwnd windows.HWND, index int32) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procGetWindowLongPtrW.Addr(), 2, uintptr(hwnd), uintptr(index), 0)\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func postQuitMessage(exitCode int32) {\n \tsyscall.Syscall(procPostQuitMessage.Addr(), 1, uintptr(exitCode), 0, 0)\n \treturn\n@@ -127,15 +116,6 @@ func sendMessage(hwnd windows.HWND, msg uint32, wparam uintptr, lparam uintptr)\n \treturn\n }\n \n-func setWindowLongPtr(hwnd windows.HWND, index int32, newLong uintptr) (res uintptr, err error) {\n-\tr0, _, e1 := syscall.Syscall(procSetWindowLongPtrW.Addr(), 3, uintptr(hwnd), uintptr(index), uintptr(newLong))\n-\tres = uintptr(r0)\n-\tif res == 0 && e1 != 0 {\n-\t\terr = errnoErr(e1)\n-\t}\n-\treturn\n-}\n-\n func translateMessage(lpMsg *_MSG) (res bool) {\n \tr0, _, _ := syscall.Syscall(procTranslateMessage.Addr(), 1, uintptr(unsafe.Pointer(lpMsg)), 0, 0)\n \tres = r0 != 0\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIn preparation for adding more parameters (and later, moving some away), rework\nthe portmapper constructor to accept its arguments on a Config struct rather\nthan positionally.\n\nThis is a breaking change to the function signature, but one that is very easy\nto update, and a search of GitHub reveals only six instances of usage outside\nclones and forks of Tailscale itself, that are not direct copies of the code\nfixed up here.\n\nWhile we could stub in another constructor, I think it is safe to let those\nfolks do the update in-place, since their usage is already affected by other\nchanges we can't test for anyway.\n\nUpdates #15160\n\nChange-Id: I9f8a5e12b38885074c98894b7376039261b43f43\nSigned-off-by: M. J. Fromberger <fromberger@tailscale.com>\n\n\n---\n\nChoice A:\ncmd/tailscale/cli/netcheck.go\n@@ -55,7 +55,10 @@ func runNetcheck(ctx context.Context, args []string) error {\n \n \t// Ensure that we close the portmapper after running a netcheck; this\n \t// will release any port mappings created.\n-\tpm := portmapper.NewClient(logf, netMon, nil, nil, nil)\n+\tpm := portmapper.NewClient(portmapper.Config{\n+\t\tLogf:   logf,\n+\t\tNetMon: netMon,\n+\t})\n \tdefer pm.Close()\n \n \tc := &netcheck.Client{\n---\nipn/localapi/localapi.go\n@@ -818,19 +818,25 @@ func (h *Handler) serveDebugPortmap(w http.ResponseWriter, r *http.Request) {\n \tdone := make(chan bool, 1)\n \n \tvar c *portmapper.Client\n-\tc = portmapper.NewClient(logger.WithPrefix(logf, \"portmapper: \"), h.b.NetMon(), debugKnobs, h.b.ControlKnobs(), func() {\n-\t\tlogf(\"portmapping changed.\")\n-\t\tlogf(\"have mapping: %v\", c.HaveMapping())\n-\n-\t\tif ext, ok := c.GetCachedMappingOrStartCreatingOne(); ok {\n-\t\t\tlogf(\"cb: mapping: %v\", ext)\n-\t\t\tselect {\n-\t\t\tcase done <- true:\n-\t\t\tdefault:\n+\tc = portmapper.NewClient(portmapper.Config{\n+\t\tLogf:         logger.WithPrefix(logf, \"portmapper: \"),\n+\t\tNetMon:       h.b.NetMon(),\n+\t\tDebugKnobs:   debugKnobs,\n+\t\tControlKnobs: h.b.ControlKnobs(),\n+\t\tOnChange: func() {\n+\t\t\tlogf(\"portmapping changed.\")\n+\t\t\tlogf(\"have mapping: %v\", c.HaveMapping())\n+\n+\t\t\tif ext, ok := c.GetCachedMappingOrStartCreatingOne(); ok {\n+\t\t\t\tlogf(\"cb: mapping: %v\", ext)\n+\t\t\t\tselect {\n+\t\t\t\tcase done <- true:\n+\t\t\t\tdefault:\n+\t\t\t\t}\n+\t\t\t\treturn\n \t\t\t}\n-\t\t\treturn\n-\t\t}\n-\t\tlogf(\"cb: no mapping\")\n+\t\t\tlogf(\"cb: no mapping\")\n+\t\t},\n \t})\n \tdefer c.Close()\n \n---\nnet/portmapper/igd_test.go\n@@ -260,9 +260,14 @@ func (d *TestIGD) handlePCPQuery(pkt []byte, src netip.AddrPort) {\n \n func newTestClient(t *testing.T, igd *TestIGD) *Client {\n \tvar c *Client\n-\tc = NewClient(t.Logf, netmon.NewStatic(), nil, new(controlknobs.Knobs), func() {\n-\t\tt.Logf(\"port map changed\")\n-\t\tt.Logf(\"have mapping: %v\", c.HaveMapping())\n+\tc = NewClient(Config{\n+\t\tLogf:         t.Logf,\n+\t\tNetMon:       netmon.NewStatic(),\n+\t\tControlKnobs: new(controlknobs.Knobs),\n+\t\tOnChange: func() {\n+\t\t\tt.Logf(\"port map changed\")\n+\t\t\tt.Logf(\"have mapping: %v\", c.HaveMapping())\n+\t\t},\n \t})\n \tc.testPxPPort = igd.TestPxPPort()\n \tc.testUPnPPort = igd.TestUPnPPort()\n---\nnet/portmapper/portmapper.go\n@@ -201,32 +201,45 @@ func (m *pmpMapping) Release(ctx context.Context) {\n \tuc.WriteToUDPAddrPort(pkt, m.gw)\n }\n \n-// NewClient returns a new portmapping client.\n-//\n-// The netMon parameter is required.\n-//\n-// The debug argument allows configuring the behaviour of the portmapper for\n-// debugging; if nil, a sensible set of defaults will be used.\n-//\n-// The controlKnobs, if non-nil, specifies the control knobs from the control\n-// plane that might disable portmapping.\n-//\n-// The optional onChange argument specifies a func to run in a new goroutine\n-// whenever the port mapping status has changed. If nil, it doesn't make a\n-// callback.\n-func NewClient(logf logger.Logf, netMon *netmon.Monitor, debug *DebugKnobs, controlKnobs *controlknobs.Knobs, onChange func()) *Client {\n-\tif netMon == nil {\n+// Config carries the settings for a [Client].\n+type Config struct {\n+\t// Logf is called to generate text logs for the client. If nil, logger.Discard is used.\n+\tLogf logger.Logf\n+\n+\t// NetMon is the network monitor used by the client. It must be non-nil.\n+\tNetMon *netmon.Monitor\n+\n+\t// DebugKnobs, if non-nil, configure the behaviour of the portmapper for\n+\t// debugging.  If nil, a sensible set of defaults will be used.\n+\tDebugKnobs *DebugKnobs\n+\n+\t// ControlKnobs, if non-nil, specifies knobs from the control plane that\n+\t// might disable port mapping.\n+\tControlKnobs *controlknobs.Knobs\n+\n+\t// OnChange is called to run in a new goroutine whenever the port mapping\n+\t// status has changed. If nil, no callback is issued.\n+\tOnChange func()\n+}\n+\n+// NewClient constructs a new portmapping [Client] from c. It will panic if any\n+// required parameters are omitted.\n+func NewClient(c Config) *Client {\n+\tif c.NetMon == nil {\n \t\tpanic(\"nil netMon\")\n \t}\n \tret := &Client{\n-\t\tlogf:         logf,\n-\t\tnetMon:       netMon,\n+\t\tlogf:         c.Logf,\n+\t\tnetMon:       c.NetMon,\n \t\tipAndGateway: netmon.LikelyHomeRouterIP, // TODO(bradfitz): move this to method on netMon\n-\t\tonChange:     onChange,\n-\t\tcontrolKnobs: controlKnobs,\n+\t\tonChange:     c.OnChange,\n+\t\tcontrolKnobs: c.ControlKnobs,\n+\t}\n+\tif ret.logf == nil {\n+\t\tret.logf = logger.Discard\n \t}\n-\tif debug != nil {\n-\t\tret.debug = *debug\n+\tif c.DebugKnobs != nil {\n+\t\tret.debug = *c.DebugKnobs\n \t}\n \treturn ret\n }\n---\nnet/portmapper/portmapper_test.go\n@@ -18,7 +18,7 @@ func TestCreateOrGetMapping(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tc.SetLocalPort(1234)\n \tfor i := range 2 {\n@@ -34,7 +34,7 @@ func TestClientProbe(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tfor i := range 3 {\n \t\tif i > 0 {\n@@ -49,7 +49,7 @@ func TestClientProbeThenMap(t *testing.T) {\n \tif v, _ := strconv.ParseBool(os.Getenv(\"HIT_NETWORK\")); !v {\n \t\tt.Skip(\"skipping test without HIT_NETWORK=1\")\n \t}\n-\tc := NewClient(t.Logf, nil, nil, new(controlknobs.Knobs), nil)\n+\tc := NewClient(Config{Logf: t.Logf, ControlKnobs: new(controlknobs.Knobs)})\n \tdefer c.Close()\n \tc.debug.VerboseLogs = true\n \tc.SetLocalPort(1234)\n---\nwgengine/magicsock/magicsock.go\n@@ -544,7 +544,13 @@ func NewConn(opts Options) (*Conn, error) {\n \tportMapOpts := &portmapper.DebugKnobs{\n \t\tDisableAll: func() bool { return opts.DisablePortMapper || c.onlyTCP443.Load() },\n \t}\n-\tc.portMapper = portmapper.NewClient(portmapperLogf, opts.NetMon, portMapOpts, opts.ControlKnobs, c.onPortMapChanged)\n+\tc.portMapper = portmapper.NewClient(portmapper.Config{\n+\t\tLogf:         portmapperLogf,\n+\t\tNetMon:       opts.NetMon,\n+\t\tDebugKnobs:   portMapOpts,\n+\t\tControlKnobs: opts.ControlKnobs,\n+\t\tOnChange:     c.onPortMapChanged,\n+\t})\n \tc.portMapper.SetGatewayLookupFunc(opts.NetMon.GatewayAndSelfIP)\n \tc.netMon = opts.NetMon\n \tc.health = opts.HealthTracker\n---\n\n\n---\n\nChoice B:\ntsnet/tsnet.go\n@@ -536,10 +536,7 @@ func (s *Server) start() (reterr error) {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\ts.rootPath, err = getTSNetDir(s.logf, confDir, prog)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\t\ts.rootPath = filepath.Join(confDir, \"tsnet-\"+prog)\n \t}\n \tif err := os.MkdirAll(s.rootPath, 0700); err != nil {\n \t\treturn err\n@@ -897,49 +894,6 @@ func (s *Server) getUDPHandlerForFlow(src, dst netip.AddrPort) (handler func(net\n \treturn func(c nettype.ConnPacketConn) { ln.handle(c) }, true\n }\n \n-// getTSNetDir usually just returns filepath.Join(confDir, \"tsnet-\"+prog)\n-// with no error.\n-//\n-// One special case is that it renames old \"tslib-\" directories to\n-// \"tsnet-\", and that rename might return an error.\n-//\n-// TODO(bradfitz): remove this maybe 6 months after 2022-03-17,\n-// once people (notably Tailscale corp services) have updated.\n-func getTSNetDir(logf logger.Logf, confDir, prog string) (string, error) {\n-\toldPath := filepath.Join(confDir, \"tslib-\"+prog)\n-\tnewPath := filepath.Join(confDir, \"tsnet-\"+prog)\n-\n-\tfi, err := os.Lstat(oldPath)\n-\tif os.IsNotExist(err) {\n-\t\t// Common path.\n-\t\treturn newPath, nil\n-\t}\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tif !fi.IsDir() {\n-\t\treturn \"\", fmt.Errorf(\"expected old tslib path %q to be a directory; got %v\", oldPath, fi.Mode())\n-\t}\n-\n-\t// At this point, oldPath exists and is a directory. But does\n-\t// the new path exist?\n-\n-\tfi, err = os.Lstat(newPath)\n-\tif err == nil && fi.IsDir() {\n-\t\t// New path already exists somehow. Ignore the old one and\n-\t\t// don't try to migrate it.\n-\t\treturn newPath, nil\n-\t}\n-\tif err != nil && !os.IsNotExist(err) {\n-\t\treturn \"\", err\n-\t}\n-\tif err := os.Rename(oldPath, newPath); err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tlogf(\"renamed old tsnet state storage directory %q to %q\", oldPath, newPath)\n-\treturn newPath, nil\n-}\n-\n // APIClient returns a tailscale.Client that can be used to make authenticated\n // requests to the Tailscale control server.\n // It requires the user to set tailscale.I_Acknowledge_This_API_Is_Unstable.\n---\n\n\n---\n\nChoice C:\ncmd/tailscale/cli/set.go\n@@ -11,6 +11,7 @@ import (\n \t\"net/netip\"\n \t\"os/exec\"\n \t\"runtime\"\n+\t\"strconv\"\n \t\"strings\"\n \n \t\"github.com/peterbourgon/ff/v3/ffcli\"\n@@ -22,6 +23,7 @@ import (\n \t\"tailscale.com/net/tsaddr\"\n \t\"tailscale.com/safesocket\"\n \t\"tailscale.com/types/opt\"\n+\t\"tailscale.com/types/ptr\"\n \t\"tailscale.com/types/views\"\n \t\"tailscale.com/version\"\n )\n@@ -62,6 +64,7 @@ type setArgsT struct {\n \tsnat                   bool\n \tstatefulFiltering      bool\n \tnetfilterMode          string\n+\trelayServerPort        string\n }\n \n func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n@@ -82,6 +85,7 @@ func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {\n \tsetf.BoolVar(&setArgs.updateApply, \"auto-update\", false, \"automatically update to the latest available version\")\n \tsetf.BoolVar(&setArgs.postureChecking, \"posture-checking\", false, hidden+\"allow management plane to gather device posture information\")\n \tsetf.BoolVar(&setArgs.runWebClient, \"webclient\", false, \"expose the web interface for managing this node over Tailscale at port 5252\")\n+\tsetf.StringVar(&setArgs.relayServerPort, \"relay-server-port\", \"\", hidden+\"UDP port number (0 will pick a random unused port) for the relay server to bind to, on all interfaces, or empty string to disable relay server functionality\")\n \n \tffcomplete.Flag(setf, \"exit-node\", func(args []string) ([]string, ffcomplete.ShellCompDirective, error) {\n \t\tst, err := localClient.Status(context.Background())\n@@ -233,6 +237,15 @@ func runSet(ctx context.Context, args []string) (retErr error) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tif setArgs.relayServerPort != \"\" {\n+\t\tuport, err := strconv.ParseUint(setArgs.relayServerPort, 10, 16)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"failed to set relay server port: %v\", err)\n+\t\t}\n+\t\tmaskedPrefs.Prefs.RelayServerPort = ptr.To(int(uport))\n+\t}\n+\n \tcheckPrefs := curPrefs.Clone()\n \tcheckPrefs.ApplyEdits(maskedPrefs)\n \tif err := localClient.CheckPrefs(ctx, checkPrefs); err != nil {\n---\ncmd/tailscale/cli/up.go\n@@ -773,6 +773,7 @@ func init() {\n \taddPrefFlagMapping(\"auto-update\", \"AutoUpdate.Apply\")\n \taddPrefFlagMapping(\"advertise-connector\", \"AppConnector\")\n \taddPrefFlagMapping(\"posture-checking\", \"PostureChecking\")\n+\taddPrefFlagMapping(\"relay-server-port\", \"RelayServerPort\")\n }\n \n func addPrefFlagMapping(flagName string, prefNames ...string) {\n---\nipn/ipn_clone.go\n@@ -61,6 +61,9 @@ func (src *Prefs) Clone() *Prefs {\n \t\t\t}\n \t\t}\n \t}\n+\tif dst.RelayServerPort != nil {\n+\t\tdst.RelayServerPort = ptr.To(*src.RelayServerPort)\n+\t}\n \tdst.Persist = src.Persist.Clone()\n \treturn dst\n }\n@@ -96,6 +99,7 @@ var _PrefsCloneNeedsRegeneration = Prefs(struct {\n \tPostureChecking        bool\n \tNetfilterKind          string\n \tDriveShares            []*drive.Share\n+\tRelayServerPort        *int\n \tAllowSingleHosts       marshalAsTrueInJSON\n \tPersist                *persist.Persist\n }{})\n---\nipn/ipn_view.go\n@@ -166,6 +166,10 @@ func (v PrefsView) NetfilterKind() string                 { return v.\u0436.Netfilte\n func (v PrefsView) DriveShares() views.SliceView[*drive.Share, drive.ShareView] {\n \treturn views.SliceOfViews[*drive.Share, drive.ShareView](v.\u0436.DriveShares)\n }\n+func (v PrefsView) RelayServerPort() views.ValuePointer[int] {\n+\treturn views.ValuePointerOf(v.\u0436.RelayServerPort)\n+}\n+\n func (v PrefsView) AllowSingleHosts() marshalAsTrueInJSON { return v.\u0436.AllowSingleHosts }\n func (v PrefsView) Persist() persist.PersistView          { return v.\u0436.Persist.View() }\n \n@@ -200,6 +204,7 @@ var _PrefsViewNeedsRegeneration = Prefs(struct {\n \tPostureChecking        bool\n \tNetfilterKind          string\n \tDriveShares            []*drive.Share\n+\tRelayServerPort        *int\n \tAllowSingleHosts       marshalAsTrueInJSON\n \tPersist                *persist.Persist\n }{})\n---\nipn/prefs.go\n@@ -246,6 +246,14 @@ type Prefs struct {\n \t// by name.\n \tDriveShares []*drive.Share\n \n+\t// RelayServerPort is the UDP port number for the relay server to bind to,\n+\t// on all interfaces. A non-nil zero value signifies a random unused port\n+\t// should be used. A nil value signifies relay server functionality\n+\t// should be disabled. This field is currently experimental, and therefore\n+\t// no guarantees are made about its current naming and functionality when\n+\t// non-nil/enabled.\n+\tRelayServerPort *int `json:\",omitempty\"`\n+\n \t// AllowSingleHosts was a legacy field that was always true\n \t// for the past 4.5 years. It controlled whether Tailscale\n \t// peers got /32 or /127 routes for each other.\n@@ -337,6 +345,7 @@ type MaskedPrefs struct {\n \tPostureCheckingSet        bool                `json:\",omitempty\"`\n \tNetfilterKindSet          bool                `json:\",omitempty\"`\n \tDriveSharesSet            bool                `json:\",omitempty\"`\n+\tRelayServerPortSet        bool                `json:\",omitempty\"`\n }\n \n // SetsInternal reports whether mp has any of the Internal*Set field bools set\n@@ -555,6 +564,9 @@ func (p *Prefs) pretty(goos string) string {\n \t}\n \tsb.WriteString(p.AutoUpdate.Pretty())\n \tsb.WriteString(p.AppConnector.Pretty())\n+\tif p.RelayServerPort != nil {\n+\t\tfmt.Fprintf(&sb, \"relayServerPort=%d \", *p.RelayServerPort)\n+\t}\n \tif p.Persist != nil {\n \t\tsb.WriteString(p.Persist.Pretty())\n \t} else {\n@@ -616,7 +628,8 @@ func (p *Prefs) Equals(p2 *Prefs) bool {\n \t\tp.AppConnector == p2.AppConnector &&\n \t\tp.PostureChecking == p2.PostureChecking &&\n \t\tslices.EqualFunc(p.DriveShares, p2.DriveShares, drive.SharesEqual) &&\n-\t\tp.NetfilterKind == p2.NetfilterKind\n+\t\tp.NetfilterKind == p2.NetfilterKind &&\n+\t\tcompareIntPtrs(p.RelayServerPort, p2.RelayServerPort)\n }\n \n func (au AutoUpdatePrefs) Pretty() string {\n@@ -636,6 +649,16 @@ func (ap AppConnectorPrefs) Pretty() string {\n \treturn \"\"\n }\n \n+func compareIntPtrs(a, b *int) bool {\n+\tif (a == nil) != (b == nil) {\n+\t\treturn false\n+\t}\n+\tif a == nil {\n+\t\treturn true\n+\t}\n+\treturn *a == *b\n+}\n+\n // NewPrefs returns the default preferences to use.\n func NewPrefs() *Prefs {\n \t// Provide default values for options which might be missing\n---\nipn/prefs_test.go\n@@ -65,6 +65,7 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\"PostureChecking\",\n \t\t\"NetfilterKind\",\n \t\t\"DriveShares\",\n+\t\t\"RelayServerPort\",\n \t\t\"AllowSingleHosts\",\n \t\t\"Persist\",\n \t}\n@@ -73,6 +74,9 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\thave, prefsHandles)\n \t}\n \n+\trelayServerPort := func(port int) *int {\n+\t\treturn &port\n+\t}\n \tnets := func(strs ...string) (ns []netip.Prefix) {\n \t\tfor _, s := range strs {\n \t\t\tn, err := netip.ParsePrefix(s)\n@@ -341,6 +345,16 @@ func TestPrefsEqual(t *testing.T) {\n \t\t\t&Prefs{AdvertiseServices: []string{\"svc:tux\", \"svc:amelie\"}},\n \t\t\tfalse,\n \t\t},\n+\t\t{\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(0)},\n+\t\t\t&Prefs{RelayServerPort: nil},\n+\t\t\tfalse,\n+\t\t},\n+\t\t{\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(0)},\n+\t\t\t&Prefs{RelayServerPort: relayServerPort(1)},\n+\t\t\tfalse,\n+\t\t},\n \t}\n \tfor i, tt := range tests {\n \t\tgot := tt.a.Equals(tt.b)\n---\n\n\n---\n\nChoice D:\ntstest/integration/integration_test.go\n@@ -1942,6 +1942,8 @@ func (n *testNode) AwaitIP6() netip.Addr {\n \n // AwaitRunning waits for n to reach the IPN state \"Running\".\n func (n *testNode) AwaitRunning() {\n+\tt := n.env.t\n+\tt.Helper()\n \tn.AwaitBackendState(\"Running\")\n }\n \n@@ -2015,7 +2017,7 @@ func (n *testNode) Status() (*ipnstate.Status, error) {\n \t}\n \tst := new(ipnstate.Status)\n \tif err := json.Unmarshal(out, st); err != nil {\n-\t\treturn nil, fmt.Errorf(\"decoding tailscale status JSON: %w\", err)\n+\t\treturn nil, fmt.Errorf(\"decoding tailscale status JSON: %w\\njson:\\n%s\", err, out)\n \t}\n \treturn st, nil\n }\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThere was a flaky failure case where renaming a TLS hostname for an ingress might leave the old hostname dangling in tailscaled config. This happened when the proxygroup reconciler loop had an outdated resource version of the config Secret in its cache after the ingress-pg-reconciler loop had very recently written it to delete the old hostname. As the proxygroup reconciler then did a patch, there was no conflict and it reinstated the old hostname.\r\n\r\nThis commit updates the patch to an update operation so that if the resource version is out of date it will fail with an optimistic lock error. It also checks for equality to reduce the likelihood that we make the update API call in the first place, because most of the time the proxygroup reconciler is not even making an update to the Secret in the case that the hostname has changed.\r\n\r\nUpdates tailscale/corp#24795\r\n\r\nChange-Id: Ie23a97440063976c9a8475d24ab18253e1f89050\n\n---\n\nChoice A:\ncmd/k8s-operator/svc-for-pg.go\n@@ -211,6 +211,11 @@ func (r *HAServiceReconciler) maybeProvision(ctx context.Context, hostname strin\n \t// already created and not owned by this Service.\n \tserviceName := tailcfg.ServiceName(\"svc:\" + hostname)\n \texistingVIPSvc, err := r.tsClient.GetVIPService(ctx, serviceName)\n+\tif isErrorFeatureFlagNotEnabled(err) {\n+\t\tlogger.Warn(msgFeatureFlagNotEnabled)\n+\t\tr.recorder.Event(svc, corev1.EventTypeWarning, warningTailscaleServiceFeatureFlagNotEnabled, msgFeatureFlagNotEnabled)\n+\t\treturn false, nil\n+\t}\n \tif err != nil && !isErrorTailscaleServiceNotFound(err) {\n \t\treturn false, fmt.Errorf(\"error getting Tailscale Service %q: %w\", hostname, err)\n \t}\n@@ -529,6 +534,11 @@ func (r *HAServiceReconciler) tailnetCertDomain(ctx context.Context) (string, er\n // It returns true if an existing VIPService was updated to remove owner reference, as well as any error that occurred.\n func (r *HAServiceReconciler) cleanupVIPService(ctx context.Context, name tailcfg.ServiceName, logger *zap.SugaredLogger) (updated bool, err error) {\n \tsvc, err := r.tsClient.GetVIPService(ctx, name)\n+\tif isErrorFeatureFlagNotEnabled(err) {\n+\t\tmsg := fmt.Sprintf(\"Unable to proceed with cleanup: %s.\", msgFeatureFlagNotEnabled)\n+\t\tlogger.Warn(msg)\n+\t\treturn false, nil\n+\t}\n \tif err != nil {\n \t\terrResp := &tailscale.ErrResponse{}\n \t\tok := errors.As(err, errResp)\n---\n\n\n---\n\nChoice B:\nutil/mak/mak.go\n@@ -5,11 +5,6 @@\n // things, notably to maps, but also slices.\n package mak\n \n-import (\n-\t\"fmt\"\n-\t\"reflect\"\n-)\n-\n // Set populates an entry in a map, making the map if necessary.\n //\n // That is, it assigns (*m)[k] = v, making *m if it was nil.\n@@ -20,35 +15,6 @@ func Set[K comparable, V any, T ~map[K]V](m *T, k K, v V) {\n \t(*m)[k] = v\n }\n \n-// NonNil takes a pointer to a Go data structure\n-// (currently only a slice or a map) and makes sure it's non-nil for\n-// JSON serialization. (In particular, JavaScript clients usually want\n-// the field to be defined after they decode the JSON.)\n-//\n-// Deprecated: use NonNilSliceForJSON or NonNilMapForJSON instead.\n-func NonNil(ptr any) {\n-\tif ptr == nil {\n-\t\tpanic(\"nil interface\")\n-\t}\n-\trv := reflect.ValueOf(ptr)\n-\tif rv.Kind() != reflect.Ptr {\n-\t\tpanic(fmt.Sprintf(\"kind %v, not Ptr\", rv.Kind()))\n-\t}\n-\tif rv.Pointer() == 0 {\n-\t\tpanic(\"nil pointer\")\n-\t}\n-\trv = rv.Elem()\n-\tif rv.Pointer() != 0 {\n-\t\treturn\n-\t}\n-\tswitch rv.Type().Kind() {\n-\tcase reflect.Slice:\n-\t\trv.Set(reflect.MakeSlice(rv.Type(), 0, 0))\n-\tcase reflect.Map:\n-\t\trv.Set(reflect.MakeMap(rv.Type()))\n-\t}\n-}\n-\n // NonNilSliceForJSON makes sure that *slicePtr is non-nil so it will\n // won't be omitted from JSON serialization and possibly confuse JavaScript\n // clients expecting it to be present.\n---\nutil/mak/mak_test.go\n@@ -40,35 +40,6 @@ func TestSet(t *testing.T) {\n \t})\n }\n \n-func TestNonNil(t *testing.T) {\n-\tvar s []string\n-\tNonNil(&s)\n-\tif len(s) != 0 {\n-\t\tt.Errorf(\"slice len = %d; want 0\", len(s))\n-\t}\n-\tif s == nil {\n-\t\tt.Error(\"slice still nil\")\n-\t}\n-\n-\ts = append(s, \"foo\")\n-\tNonNil(&s)\n-\tif len(s) != 1 {\n-\t\tt.Errorf(\"len = %d; want 1\", len(s))\n-\t}\n-\tif s[0] != \"foo\" {\n-\t\tt.Errorf(\"value = %q; want foo\", s)\n-\t}\n-\n-\tvar m map[string]string\n-\tNonNil(&m)\n-\tif len(m) != 0 {\n-\t\tt.Errorf(\"map len = %d; want 0\", len(s))\n-\t}\n-\tif m == nil {\n-\t\tt.Error(\"map still nil\")\n-\t}\n-}\n-\n func TestNonNilMapForJSON(t *testing.T) {\n \ttype M map[string]int\n \tvar m M\n---\n\n\n---\n\nChoice C:\ntailcfg/tailcfg.go\n@@ -1462,6 +1462,13 @@ const (\n \t// user groups as Kubernetes user groups. This capability is read by\n \t// peers that are Tailscale Kubernetes operator instances.\n \tPeerCapabilityKubernetes PeerCapability = \"tailscale.com/cap/kubernetes\"\n+\n+\t// PeerCapabilityRelay grants the ability for a peer to allocate relay\n+\t// endpoints.\n+\tPeerCapabilityRelay PeerCapability = \"tailscale.com/cap/relay\"\n+\t// PeerCapabilityRelayTarget grants the current node the ability to allocate\n+\t// relay endpoints to the peer which has this capability.\n+\tPeerCapabilityRelayTarget PeerCapability = \"tailscale.com/cap/relay-target\"\n )\n \n // NodeCapMap is a map of capabilities to their optional values. It is valid for\n---\n\n\n---\n\nChoice D:\ncmd/k8s-operator/proxygroup.go\n@@ -461,15 +461,15 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \n \t\tvar existingCfgSecret *corev1.Secret // unmodified copy of secret\n \t\tif err := r.Get(ctx, client.ObjectKeyFromObject(cfgSecret), cfgSecret); err == nil {\n-\t\t\tlogger.Debugf(\"secret %s/%s already exists\", cfgSecret.GetNamespace(), cfgSecret.GetName())\n+\t\t\tlogger.Debugf(\"Secret %s/%s already exists\", cfgSecret.GetNamespace(), cfgSecret.GetName())\n \t\t\texistingCfgSecret = cfgSecret.DeepCopy()\n \t\t} else if !apierrors.IsNotFound(err) {\n \t\t\treturn \"\", err\n \t\t}\n \n \t\tvar authKey string\n \t\tif existingCfgSecret == nil {\n-\t\t\tlogger.Debugf(\"creating authkey for new ProxyGroup proxy\")\n+\t\t\tlogger.Debugf(\"Creating authkey for new ProxyGroup proxy\")\n \t\t\ttags := pg.Spec.Tags.Stringify()\n \t\t\tif len(tags) == 0 {\n \t\t\t\ttags = r.defaultTags\n@@ -490,7 +490,7 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t\tif err != nil {\n \t\t\t\treturn \"\", fmt.Errorf(\"error marshalling tailscaled config: %w\", err)\n \t\t\t}\n-\t\t\tmak.Set(&cfgSecret.StringData, tsoperator.TailscaledConfigFileName(cap), string(cfgJSON))\n+\t\t\tmak.Set(&cfgSecret.Data, tsoperator.TailscaledConfigFileName(cap), cfgJSON)\n \t\t}\n \n \t\t// The config sha256 sum is a value for a hash annotation used to trigger\n@@ -520,12 +520,14 @@ func (r *ProxyGroupReconciler) ensureConfigSecretsCreated(ctx context.Context, p\n \t\t}\n \n \t\tif existingCfgSecret != nil {\n-\t\t\tlogger.Debugf(\"patching the existing ProxyGroup config Secret %s\", cfgSecret.Name)\n-\t\t\tif err := r.Patch(ctx, cfgSecret, client.MergeFrom(existingCfgSecret)); err != nil {\n-\t\t\t\treturn \"\", err\n+\t\t\tif !apiequality.Semantic.DeepEqual(existingCfgSecret, cfgSecret) {\n+\t\t\t\tlogger.Debugf(\"Updating the existing ProxyGroup config Secret %s\", cfgSecret.Name)\n+\t\t\t\tif err := r.Update(ctx, cfgSecret); err != nil {\n+\t\t\t\t\treturn \"\", err\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n-\t\t\tlogger.Debugf(\"creating a new config Secret %s for the ProxyGroup\", cfgSecret.Name)\n+\t\t\tlogger.Debugf(\"Creating a new config Secret %s for the ProxyGroup\", cfgSecret.Name)\n \t\t\tif err := r.Create(ctx, cfgSecret); err != nil {\n \t\t\t\treturn \"\", err\n \t\t\t}\n---\ncmd/k8s-operator/proxygroup_test.go\n@@ -475,8 +475,6 @@ func TestIngressAdvertiseServicesConfigPreserved(t *testing.T) {\n \t\t\tName:      pgConfigSecretName(pgName, 0),\n \t\t\tNamespace: tsNamespace,\n \t\t},\n-\t\t// Write directly to Data because the fake client doesn't copy the write-only\n-\t\t// StringData field across to Data for us.\n \t\tData: map[string][]byte{\n \t\t\ttsoperator.TailscaledConfigFileName(106): existingConfigBytes,\n \t\t},\n@@ -514,10 +512,10 @@ func TestIngressAdvertiseServicesConfigPreserved(t *testing.T) {\n \t\t\tNamespace:       tsNamespace,\n \t\t\tResourceVersion: \"2\",\n \t\t},\n-\t\tStringData: map[string]string{\n-\t\t\ttsoperator.TailscaledConfigFileName(106): string(expectedConfigBytes),\n+\t\tData: map[string][]byte{\n+\t\t\ttsoperator.TailscaledConfigFileName(106): expectedConfigBytes,\n \t\t},\n-\t}, omitSecretData)\n+\t})\n }\n \n func verifyProxyGroupCounts(t *testing.T, r *ProxyGroupReconciler, wantIngress, wantEgress int) {\n@@ -620,11 +618,3 @@ func addNodeIDToStateSecrets(t *testing.T, fc client.WithWatch, pg *tsapi.ProxyG\n \t\t})\n \t}\n }\n-\n-// The operator mostly writes to StringData and reads from Data, but the fake\n-// client doesn't copy StringData across to Data on write. When comparing actual\n-// vs expected Secrets, use this function to only check what the operator writes\n-// to StringData.\n-func omitSecretData(secret *corev1.Secret) {\n-\tsecret.Data = nil\n-}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nCommit 4b525fdda defers changing the working directory until the incubator process drops its privileges.\r\n\r\nHowever, it didn't account for the case where there is no incubator process, because no tailscaled was found on the PATH. In that case, it only intended to run `tailscaled be-child` in the root directory but accidentally ran everything there.\r\n\r\nFixes: #15350\n\n---\n\nChoice A:\nutil/set/smallset.go\n@@ -50,6 +50,15 @@ func (s SmallSet[T]) Contains(e T) bool {\n \treturn e != zero && s.one == e\n }\n \n+// SoleElement returns the single value in the set, if the set has exactly one\n+// element.\n+//\n+// If the set is empty or has more than one element, ok will be false and e will\n+// be the zero value of T.\n+func (s SmallSet[T]) SoleElement() (e T, ok bool) {\n+\treturn s.one, s.Len() == 1\n+}\n+\n // Add adds e to the set.\n //\n // When storing a SmallSet in a map as a value type, it is important to\n@@ -61,10 +70,15 @@ func (s *SmallSet[T]) Add(e T) {\n \t\ts.m.Add(e)\n \t\treturn\n \t}\n-\t// Size zero to one non-zero element.\n-\tif s.one == zero && e != zero {\n-\t\ts.one = e\n-\t\treturn\n+\t// Non-zero elements can go into s.one.\n+\tif e != zero {\n+\t\tif s.one == zero {\n+\t\t\ts.one = e // Len 0 to Len 1\n+\t\t\treturn\n+\t\t}\n+\t\tif s.one == e {\n+\t\t\treturn // dup\n+\t\t}\n \t}\n \t// Need to make a multi map, either\n \t// because we now have two items, or\n@@ -73,7 +87,7 @@ func (s *SmallSet[T]) Add(e T) {\n \tif s.one != zero {\n \t\ts.m.Add(s.one) // move single item to multi\n \t}\n-\ts.m.Add(e) // add new item\n+\ts.m.Add(e) // add new item, possibly zero\n \ts.one = zero\n }\n \n---\nutil/set/smallset_test.go\n@@ -84,8 +84,43 @@ func TestSmallSet(t *testing.T) {\n \t\t\t\t\t\t\tt.Errorf(\"contains(%v) mismatch after ops %s: normal=%v, small=%v\", e, name(), normal.Contains(e), small.Contains(e))\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\n+\t\t\t\t\tif err := small.checkInvariants(); err != nil {\n+\t\t\t\t\t\tt.Errorf(\"checkInvariants failed after ops %s: %v\", name(), err)\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif !t.Failed() {\n+\t\t\t\t\t\tsole, ok := small.SoleElement()\n+\t\t\t\t\t\tif ok != (small.Len() == 1) {\n+\t\t\t\t\t\t\tt.Errorf(\"SoleElement ok mismatch after ops %s: SoleElement ok=%v, want=%v\", name(), ok, !ok)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif ok && sole != smallEle[0] {\n+\t\t\t\t\t\t\tt.Errorf(\"SoleElement value mismatch after ops %s: SoleElement=%v, want=%v\", name(), sole, smallEle[0])\n+\t\t\t\t\t\t\tt.Errorf(\"Internals: %+v\", small)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (s *SmallSet[T]) checkInvariants() error {\n+\tvar zero T\n+\tif s.m != nil && s.one != zero {\n+\t\treturn fmt.Errorf(\"both m and one are non-zero\")\n+\t}\n+\tif s.m != nil {\n+\t\tswitch len(s.m) {\n+\t\tcase 0:\n+\t\t\treturn fmt.Errorf(\"m is non-nil but empty\")\n+\t\tcase 1:\n+\t\t\tfor k := range s.m {\n+\t\t\t\tif k != zero {\n+\t\t\t\t\treturn fmt.Errorf(\"m contains exactly 1 non-zero element, %v\", k)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n+\treturn nil\n }\n---\n\n\n---\n\nChoice B:\ndocs/windows/policy/en-US/tailscale.adml\n@@ -16,6 +16,7 @@\n             <string id=\"SINCE_V1_62\">Tailscale version 1.62.0 and later</string>\n             <string id=\"SINCE_V1_74\">Tailscale version 1.74.0 and later</string>\n             <string id=\"SINCE_V1_78\">Tailscale version 1.78.0 and later</string>\n+            <string id=\"SINCE_V1_80\">Tailscale version 1.80.0 and later</string>\n             <string id=\"SINCE_V1_82\">Tailscale version 1.82.0 and later</string>\n             <string id=\"SINCE_V1_84\">Tailscale version 1.84.0 and later</string>\n             <string id=\"Tailscale_Category\">Tailscale</string>\n@@ -271,6 +272,12 @@ If you enable this policy, the menu item will be displayed indicating the organi\n If you disable this policy or do not configure it, the corresponding menu item will be hidden.\n \n See https://tailscale.com/kb/1315/mdm-keys#set-your-organization-name for more details.]]></string>\n+            <string id=\"OnboardingFlow\">Show the onboarding flow</string>\n+            <string id=\"OnboardingFlow_Help\"><![CDATA[This policy can be used to show or hide the onboarding flow displayed by the GUI.\n+\n+If you enable or don't configure this policy, the onboarding flow will be shown to new users who have not yet signed in to a Tailscale account.\n+\n+If you disable this policy, the onboarding flow will never be shown.]]></string>\n         </stringTable>\n         <presentationTable>\n             <presentation id=\"LoginURL\">\n---\ndocs/windows/policy/tailscale.admx\n@@ -54,6 +54,10 @@\n                   displayName=\"$(string.SINCE_V1_78)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n       </definition>\n+      <definition name=\"SINCE_V1_80\"\n+                  displayName=\"$(string.SINCE_V1_80)\">\n+        <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n+      </definition>\n       <definition name=\"SINCE_V1_82\"\n                   displayName=\"$(string.SINCE_V1_82)\">\n         <and><reference ref=\"TAILSCALE_PRODUCT\"/></and>\n@@ -335,6 +339,16 @@\n         <string>hide</string>\n       </disabledValue>\n     </policy>\n+    <policy name=\"OnboardingFlow\" class=\"Both\" displayName=\"$(string.OnboardingFlow)\" explainText=\"$(string.OnboardingFlow_Help)\" key=\"Software\\Policies\\Tailscale\" valueName=\"OnboardingFlow\">\n+      <parentCategory ref=\"UI_Category\" />\n+      <supportedOn ref=\"SINCE_V1_80\" />\n+      <enabledValue>\n+        <string>show</string>\n+      </enabledValue>\n+      <disabledValue>\n+        <string>hide</string>\n+      </disabledValue>\n+    </policy>\n     <policy name=\"ManagedBy\" class=\"Both\" displayName=\"$(string.ManagedBy)\" explainText=\"$(string.ManagedBy_Help)\" presentation=\"$(presentation.ManagedBy)\" key=\"Software\\Policies\\Tailscale\">\n       <parentCategory ref=\"UI_Category\" />\n       <supportedOn ref=\"SINCE_V1_62\" />\n---\n\n\n---\n\nChoice C:\ncmd/tailscale/cli/file.go\n@@ -15,8 +15,10 @@ import (\n \t\"net/http\"\n \t\"net/netip\"\n \t\"os\"\n+\t\"os/user\"\n \t\"path\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"sync/atomic\"\n \t\"time\"\n@@ -452,6 +454,7 @@ var fileGetCmd = &ffcli.Command{\n \toverwrite:  overwrite existing file\n \trename:     write to a new number-suffixed filename`)\n \t\tffcomplete.Flag(fs, \"conflict\", ffcomplete.Fixed(\"skip\", \"overwrite\", \"rename\"))\n+\t\tfs.StringVar(&getArgs.chown, \"chown\", \"\", \"sets owner:group for received files\")\n \t\treturn fs\n \t})(),\n }\n@@ -461,6 +464,7 @@ var getArgs = struct {\n \tloop     bool\n \tverbose  bool\n \tconflict onConflict\n+\tchown    string\n }{conflict: skipOnExist}\n \n func numberedFileName(dir, name string, i int) string {\n@@ -512,7 +516,7 @@ func openFileOrSubstitute(dir, base string, action onConflict) (*os.File, error)\n \t}\n }\n \n-func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targetFile string, size int64, err error) {\n+func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string, chown string) (targetFile string, size int64, err error) {\n \trc, size, err := localClient.GetWaitingFile(ctx, wf.Name)\n \tif err != nil {\n \t\treturn \"\", 0, fmt.Errorf(\"opening inbox file %q: %w\", wf.Name, err)\n@@ -531,10 +535,51 @@ func receiveFile(ctx context.Context, wf apitype.WaitingFile, dir string) (targe\n \t\tf.Close()\n \t\treturn \"\", 0, fmt.Errorf(\"failed to write %v: %v\", f.Name(), err)\n \t}\n+\tif chown != \"\" {\n+\t\tusr, grp, _ := strings.Cut(chown, \":\")\n+\n+\t\t// Set default values to allow for partial changes (e.g. `user` or `:staff`)\n+\t\tuid, gid, err := fileStat(f)\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to stat file: %v\", err)\n+\t\t}\n+\n+\t\tif usr != \"\" {\n+\t\t\tif uid, err = strconv.Atoi(usr); err != nil {\n+\t\t\t\tuser, err := user.Lookup(usr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup user: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif uid, err = strconv.Atoi(user.Uid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert uid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif grp != \"\" {\n+\t\t\tif gid, err = strconv.Atoi(grp); err != nil {\n+\t\t\t\tgroup, err := user.LookupGroup(grp)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to lookup group: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif gid, err = strconv.Atoi(group.Gid); err != nil {\n+\t\t\t\t\tf.Close()\n+\t\t\t\t\treturn \"\", 0, fmt.Errorf(\"failed to convert gid to int: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif err := f.Chown(uid, gid); err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn \"\", 0, fmt.Errorf(\"failed to chown file: %v\", err)\n+\t\t}\n+\t}\n \treturn f.Name(), size, f.Close()\n }\n \n-func runFileGetOneBatch(ctx context.Context, dir string) []error {\n+func runFileGetOneBatch(ctx context.Context, dir, chown string) []error {\n \tvar wfs []apitype.WaitingFile\n \tvar err error\n \tvar errs []error\n@@ -563,7 +608,7 @@ func runFileGetOneBatch(ctx context.Context, dir string) []error {\n \t\t\terrs = append(errs, fmt.Errorf(\"too many errors in runFileGetOneBatch(). %d files unexamined\", len(wfs)-i))\n \t\t\tbreak\n \t\t}\n-\t\twrittenFile, size, err := receiveFile(ctx, wf, dir)\n+\t\twrittenFile, size, err := receiveFile(ctx, wf, dir, chown)\n \t\tif err != nil {\n \t\t\terrs = append(errs, err)\n \t\t\tcontinue\n@@ -602,7 +647,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t}\n \tif getArgs.loop {\n \t\tfor {\n-\t\t\terrs := runFileGetOneBatch(ctx, dir)\n+\t\t\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \t\t\tfor _, err := range errs {\n \t\t\t\toutln(err)\n \t\t\t}\n@@ -621,7 +666,7 @@ func runFileGet(ctx context.Context, args []string) error {\n \t\t\t}\n \t\t}\n \t}\n-\terrs := runFileGetOneBatch(ctx, dir)\n+\terrs := runFileGetOneBatch(ctx, dir, getArgs.chown)\n \tif len(errs) == 0 {\n \t\treturn nil\n \t}\n@@ -635,6 +680,9 @@ func wipeInbox(ctx context.Context) error {\n \tif getArgs.wait {\n \t\treturn errors.New(\"can't use --wait with /dev/null target\")\n \t}\n+\tif getArgs.chown != \"\" {\n+\t\treturn errors.New(\"can't use --chown with /dev/null target\")\n+\t}\n \twfs, err := localClient.WaitingFiles(ctx)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"getting WaitingFiles: %w\", err)\n---\ncmd/tailscale/cli/file_stub.go\n@@ -0,0 +1,16 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build windows || wasm || plan9 || tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(_f *os.File) (int, int, error) {\n+\treturn -1, -1, errors.New(\"Not implemented\")\n+}\n---\ncmd/tailscale/cli/file_unix.go\n@@ -0,0 +1,26 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build !windows && !wasm && !plan9 && !tamago\n+\n+package cli\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// Stats a path and returns the owning uid and gid. Errors on non-unix platforms.\n+func fileStat(f *os.File) (int, int, error) {\n+\tif f == nil {\n+\t\treturn -1, -1, errors.New(\"file cannot be nil\")\n+\t}\n+\n+\tvar stat syscall.Stat_t\n+\tif err := syscall.Stat(f.Name(), &stat); err != nil {\n+\t\treturn -1, -1, err\n+\t}\n+\n+\treturn int(stat.Uid), int(stat.Gid), nil\n+}\n---\n\n\n---\n\nChoice D:\nssh/tailssh/incubator.go\n@@ -12,11 +12,13 @@\n package tailssh\n \n import (\n+\t\"context\"\n \t\"encoding/json\"\n \t\"errors\"\n \t\"flag\"\n \t\"fmt\"\n \t\"io\"\n+\t\"io/fs\"\n \t\"log\"\n \t\"log/syslog\"\n \t\"os\"\n@@ -29,6 +31,7 @@ import (\n \t\"strings\"\n \t\"sync/atomic\"\n \t\"syscall\"\n+\t\"time\"\n \n \t\"github.com/creack/pty\"\n \t\"github.com/pkg/sftp\"\n@@ -70,11 +73,36 @@ var maybeStartLoginSession = func(dlogf logger.Logf, ia incubatorArgs) (close fu\n \treturn nil\n }\n \n+// tryExecInDir tries to run a command in dir and returns nil if it succeeds.\n+// Otherwise, it returns a filesystem error or a timeout error if the command\n+// took too long.\n+func tryExecInDir(ctx context.Context, dir string) error {\n+\tctx, cancel := context.WithTimeout(ctx, 10*time.Second)\n+\tdefer cancel()\n+\n+\t// Assume that the following executables exist, are executable, and\n+\t// immediately return.\n+\tvar name string\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\twindir := os.Getenv(\"windir\")\n+\t\tname = filepath.Join(windir, \"system32\", \"doskey.exe\")\n+\tdefault:\n+\t\tname = \"/bin/true\"\n+\t}\n+\n+\tcmd := exec.CommandContext(ctx, name)\n+\tcmd.Dir = dir\n+\treturn cmd.Run()\n+}\n+\n // newIncubatorCommand returns a new exec.Cmd configured with\n // `tailscaled be-child ssh` as the entrypoint.\n //\n-// If ss.srv.tailscaledPath is empty, this method is equivalent to\n-// exec.CommandContext.\n+// If ss.srv.tailscaledPath is empty, this method is almost equivalent to\n+// exec.CommandContext. It will refuse to run in SFTP-mode. It will simulate the\n+// behavior of SSHD when by falling back to the root directory if it cannot run\n+// a command in the user\u2019s home directory.\n //\n // The returned Cmd.Env is guaranteed to be nil; the caller populates it.\n func (ss *sshSession) newIncubatorCommand(logf logger.Logf) (cmd *exec.Cmd, err error) {\n@@ -104,7 +132,35 @@ func (ss *sshSession) newIncubatorCommand(logf logger.Logf) (cmd *exec.Cmd, err\n \t\tloginShell := ss.conn.localUser.LoginShell()\n \t\targs := shellArgs(isShell, ss.RawCommand())\n \t\tlogf(\"directly running %s %q\", loginShell, args)\n-\t\treturn exec.CommandContext(ss.ctx, loginShell, args...), nil\n+\t\tcmd = exec.CommandContext(ss.ctx, loginShell, args...)\n+\n+\t\t// While running directly instead of using `tailscaled be-child`,\n+\t\t// do what sshd does by running inside the home directory,\n+\t\t// falling back to the root directory it doesn't have permissions.\n+\t\t// This can happen if the system has networked home directories,\n+\t\t// i.e. NFS or SMB, which enable root-squashing by default.\n+\t\tcmd.Dir = ss.conn.localUser.HomeDir\n+\t\terr := tryExecInDir(ss.ctx, cmd.Dir)\n+\t\tswitch {\n+\t\tcase errors.Is(err, exec.ErrNotFound):\n+\t\t\t// /bin/true might not be installed on a barebones system,\n+\t\t\t// so we assume that the home directory does not exist.\n+\t\t\tcmd.Dir = \"/\"\n+\t\tcase errors.Is(err, fs.ErrPermission) || errors.Is(err, fs.ErrNotExist):\n+\t\t\t// Ensure that cmd.Dir is the source of the error.\n+\t\t\tvar pathErr *fs.PathError\n+\t\t\tif errors.As(err, &pathErr) && pathErr.Path == cmd.Dir {\n+\t\t\t\t// If we cannot run loginShell in localUser.HomeDir,\n+\t\t\t\t// we will try to run this command in the root directory.\n+\t\t\t\tcmd.Dir = \"/\"\n+\t\t\t} else {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\tcase err != nil:\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\treturn cmd, nil\n \t}\n \n \tlu := ss.conn.localUser\n@@ -178,7 +234,10 @@ func (ss *sshSession) newIncubatorCommand(logf logger.Logf) (cmd *exec.Cmd, err\n \t\t}\n \t}\n \n-\treturn exec.CommandContext(ss.ctx, ss.conn.srv.tailscaledPath, incubatorArgs...), nil\n+\tcmd = exec.CommandContext(ss.ctx, ss.conn.srv.tailscaledPath, incubatorArgs...)\n+\t// The incubator will chdir into the home directory after it drops privileges.\n+\tcmd.Dir = \"/\"\n+\treturn cmd, nil\n }\n \n var debugIncubator bool\n@@ -777,7 +836,6 @@ func (ss *sshSession) launchProcess() error {\n \t}\n \n \tcmd := ss.cmd\n-\tcmd.Dir = \"/\"\n \tcmd.Env = envForUser(ss.conn.localUser)\n \tfor _, kv := range ss.Environ() {\n \t\tif acceptEnvPair(kv) {\n---\n\n\n---\n\n"}], "ideal": "D"}
