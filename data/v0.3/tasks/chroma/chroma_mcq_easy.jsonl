{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - ...\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\ndocs/docs.trychroma.com/markdoc/content/integrations/frameworks/llamaindex.md\n@@ -6,5 +6,5 @@ name: LlamaIndex\n # LlamaIndex\n \n - `LlamaIndex` [Vector Store page](https://docs.llamaindex.ai/en/stable/examples/vector_stores/ChromaIndexDemo.html)\n-- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n-- [Chroma Loader on Llamahub](https://llamahub.ai/l/chroma)\n+- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n+- [Chroma Loader on Llamahub](https://llamahub.ai/l/vector_stores/llama-index-vector-stores-chroma)\n---\n\n\n---\n\nChoice B:\ngo/cmd/logservice/main.go\n@@ -2,8 +2,8 @@ package main\n \n import (\n \t\"context\"\n-\t\"net\"\n \n+\t\"github.com/chroma-core/chroma/go/pkg/grpcutils\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/configuration\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/leader\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/metrics\"\n@@ -15,7 +15,6 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/utils\"\n \tlibs \"github.com/chroma-core/chroma/go/shared/libs\"\n \t\"github.com/chroma-core/chroma/go/shared/otel\"\n-\tsharedOtel \"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"github.com/pingcap/log\"\n \t\"github.com/rs/zerolog\"\n \t\"go.uber.org/automaxprocs/maxprocs\"\n@@ -50,22 +49,21 @@ func main() {\n \tsysDb := sysdb.NewSysDB(config.SYSDB_CONN)\n \tlr := repository.NewLogRepository(conn, sysDb)\n \tserver := server.NewLogServer(lr)\n-\tvar listener net.Listener\n-\tlistener, err = net.Listen(\"tcp\", \":\"+config.PORT)\n+\n+\t_, err = grpcutils.Default.StartGrpcServer(\"log-service\", &grpcutils.GrpcConfig{\n+\t\tBindAddress: \":\" + config.PORT,\n+\t}, func(registrar grpc.ServiceRegistrar) {\n+\t\thealthcheck := health.NewServer()\n+\t\thealthgrpc.RegisterHealthServer(registrar, healthcheck)\n+\t\tlogservicepb.RegisterLogServiceServer(registrar, server)\n+\t})\n \tif err != nil {\n-\t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n+\t\tlog.Fatal(\"failed to create grpc server\", zap.Error(err))\n \t}\n-\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n-\thealthcheck := health.NewServer()\n-\thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n-\tlogservicepb.RegisterLogServiceServer(s, server)\n-\tlog.Info(\"log service started\", zap.String(\"address\", listener.Addr().String()))\n+\tlog.Info(\"log service started\")\n \tgo leader.AcquireLeaderLock(ctx, func(ctx context.Context) {\n \t\tgo purging.PerformPurgingLoop(ctx, lr)\n \t\tgo metrics.PerformMetricsLoop(ctx, lr)\n \t})\n-\tif err := s.Serve(listener); err != nil {\n-\t\tlog.Fatal(\"failed to serve\", zap.Error(err))\n-\t}\n }\n---\ngo/pkg/grpcutils/service.go\n@@ -4,11 +4,12 @@ import (\n \t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n-\t\"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"io\"\n \t\"net\"\n \t\"os\"\n \n+\t\"github.com/chroma-core/chroma/go/shared/otel\"\n+\n \t\"github.com/pingcap/log\"\n \t\"go.uber.org/zap\"\n \t\"google.golang.org/grpc\"\n@@ -82,7 +83,7 @@ func newDefaultGrpcProvider(name string, grpcConfig *GrpcConfig, registerFunc fu\n \tOPTL_TRACING_ENDPOINT := os.Getenv(\"OPTL_TRACING_ENDPOINT\")\n \tif OPTL_TRACING_ENDPOINT != \"\" {\n \t\totel.InitTracing(context.Background(), &otel.TracingConfig{\n-\t\t\tService:  \"sysdb-service\",\n+\t\t\tService:  name,\n \t\t\tEndpoint: OPTL_TRACING_ENDPOINT,\n \t\t})\n \t}\n---\ngo/pkg/sysdb/grpc/server.go\n@@ -158,7 +158,7 @@ func NewWithGrpcProvider(config Config, provider grpcutils.GrpcProvider) (*Serve\n \t\ts.softDeleteCleaner.Start()\n \n \t\tlog.Info(\"Starting GRPC server\")\n-\t\ts.grpcServer, err = provider.StartGrpcServer(\"coordinator\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n+\t\ts.grpcServer, err = provider.StartGrpcServer(\"sysdb-service\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n \t\t\tcoordinatorpb.RegisterSysDBServer(registrar, s)\n \t\t\thealthgrpc.RegisterHealthServer(registrar, s.healthServer)\n \t\t})\n---\n\n\n---\n\nChoice C:\nrust/tracing/src/init_tracer.rs\n@@ -143,6 +143,10 @@ pub fn init_stdout_layer() -> Box<dyn Layer<Registry> + Send + Sync> {\n                     .module_path()\n                     .unwrap_or(\"\")\n                     .starts_with(\"opentelemetry_sdk\")\n+                || metadata\n+                    .module_path()\n+                    .unwrap_or(\"\")\n+                    .starts_with(\"hosted-frontend\")\n         }))\n         .with_filter(tracing_subscriber::filter::LevelFilter::INFO)\n         .boxed()\n---\n\n\n---\n\nChoice D:\nk8s/test/minio.yaml\n@@ -16,7 +16,9 @@ spec:\n     spec:\n       volumes:\n         - name: minio\n-          emptyDir: {}\n+          emptyDir:\n+            medium: Memory\n+            sizeLimit: 2Gi\n       containers:\n         - name: minio\n           image: minio/minio:latest\n@@ -46,7 +48,7 @@ metadata:\n spec:\n   ports:\n     - name: http\n-    # Put the lb on a different port so we can run minio locally since the port is already in use\n+      # Put the lb on a different port so we can run minio locally since the port is already in use\n       port: 9001\n       targetPort: 9000\n   selector:\n---\nrust/garbage_collector/src/operators/delete_unused_files.rs\n@@ -147,27 +147,30 @@ impl Operator<DeleteUnusedFilesInput, DeleteUnusedFilesOutput> for DeleteUnusedF\n             CleanupMode::Delete | CleanupMode::DeleteV2 => {\n                 // Hard delete - remove the file\n                 if !all_files.is_empty() {\n-                    let mut delete_stream = futures::stream::iter(all_files.clone())\n-                        .map(move |file_path| self.delete_with_path(file_path))\n-                        .buffer_unordered(100);\n-\n-                    // Process any errors that occurred\n-                    while let Some(result) = delete_stream.next().await {\n-                        if let Err(e) = result {\n-                            match e {\n-                                StorageError::NotFound { path, source } => {\n-                                    tracing::info!(\"Rename file {path} not found: {source}\")\n-                                }\n-                                err => tracing::error!(\"Failed to delete: {err}\"),\n-                            }\n-                        }\n-                    }\n+                    // let mut delete_stream = futures::stream::iter(all_files.clone())\n+                    //     .map(move |file_path| self.delete_with_path(file_path))\n+                    //     .buffer_unordered(100);\n+\n+                    // // Process any errors that occurred\n+                    // while let Some(result) = delete_stream.next().await {\n+                    //     if let Err(e) = result {\n+                    //         match e {\n+                    //             StorageError::NotFound { path, source } => {\n+                    //                 tracing::info!(\"Rename file {path} not found: {source}\")\n+                    //             }\n+                    //             err => tracing::error!(\"Failed to delete: {err}\"),\n+                    //         }\n+                    //     }\n+                    // }\n+\n+                    self.storage.delete_many(all_files).await.unwrap();\n                 }\n             }\n         }\n \n         Ok(DeleteUnusedFilesOutput {\n-            deleted_files: all_files.into_iter().collect(),\n+            // deleted_files: all_files.into_iter().collect(),\n+            deleted_files: HashSet::new(),\n         })\n     }\n }\n---\nrust/storage/src/lib.rs\n@@ -302,6 +302,15 @@ impl Storage {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        match self {\n+            Storage::ObjectStore(object_store) => object_store.delete_many(keys).await,\n+            Storage::S3(s3) => s3.delete_many(keys).await,\n+            Storage::Local(_) => unimplemented!(),\n+            Storage::AdmissionControlledS3(_) => unimplemented!(),\n+        }\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         match self {\n             Storage::ObjectStore(object_store) => object_store.rename(src_key, dst_key).await,\n---\nrust/storage/src/object_store.rs\n@@ -284,6 +284,30 @@ impl ObjectStore {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        let mut locations = Vec::new();\n+        for key in keys {\n+            locations.push(Ok(Path::from(key)));\n+        }\n+\n+        let mut stream = self\n+            .object_store\n+            .delete_stream(futures::stream::iter(locations).boxed());\n+\n+        while let Some(result) = stream.next().await {\n+            match result {\n+                Ok(_) => {\n+                    tracing::info!(\"Successfully deleted object\");\n+                }\n+                Err(e) => {\n+                    tracing::error!(error = %e, \"Failed to delete object\");\n+                    return Err(e.into());\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         tracing::info!(src = %src_key, dst = %dst_key, \"Renaming object\");\n \n---\nrust/storage/src/s3.rs\n@@ -647,6 +647,49 @@ impl S3Storage {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        tracing::debug!(keys = ?keys, \"Deleting multiple objects from S3\");\n+\n+        // batch by 1000 keys as per S3 limits\n+        let mut futures = Vec::new();\n+        for chunk in keys.chunks(1000) {\n+            let delete_req = self.client.delete_objects().bucket(&self.bucket).delete(\n+                aws_sdk_s3::types::Delete::builder()\n+                    .set_objects(Some(\n+                        chunk\n+                            .iter()\n+                            .map(|key| {\n+                                aws_sdk_s3::types::ObjectIdentifier::builder()\n+                                    .key(key)\n+                                    .build()\n+                                    .unwrap()\n+                            })\n+                            .collect::<Vec<_>>(),\n+                    ))\n+                    .build()\n+                    .unwrap(),\n+            );\n+\n+            futures.push(delete_req.send());\n+        }\n+        let results = futures::future::join_all(futures).await;\n+        for res in results {\n+            match res {\n+                Ok(_) => {\n+                    tracing::debug!(\"Successfully deleted objects from S3\");\n+                }\n+                Err(e) => {\n+                    tracing::error!(error = %e, \"Failed to delete objects from S3\");\n+                    return Err(StorageError::Generic {\n+                        source: Arc::new(e.into_service_error()),\n+                    });\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         tracing::info!(src = %src_key, dst = %dst_key, \"Renaming object in S3\");\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nShould mark [x, x+i) as dirty, but marks [x+i, x+2i), so the dirty log\nalways sticks around, causing compactors to try and compact nothing.\n\n## Test plan\n\nCI\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -374,7 +374,7 @@ func (tc *Catalog) createCollectionImpl(txCtx context.Context, createCollection\n \t\treturn nil, false, common.ErrConcurrentDeleteCollection\n \t}\n \tresult := convertCollectionToModel(collectionList)[0]\n-\treturn result, true, nil\n+\treturn result, created, nil\n }\n \n func (tc *Catalog) CreateCollection(ctx context.Context, createCollection *model.CreateCollection, ts types.Timestamp) (*model.Collection, bool, error) {\n@@ -1249,7 +1249,6 @@ func (tc *Catalog) CreateCollectionAndSegments(ctx context.Context, createCollec\n \t\t}\n \n \t\t// If collection already exists, then do not create segments.\n-\t\t// TODO: Should we check to see if segments does not exist? and create them?\n \t\tif !created {\n \t\t\treturn nil\n \t\t}\n---\n\n\n---\n\nChoice B:\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -140,21 +140,20 @@ impl GarbageCollector {\n             .as_ref()\n             .ok_or(GarbageCollectCollectionError::Uninitialized)?;\n \n-        let use_v1_orchestrator = match cleanup_mode {\n-            CleanupMode::DryRun | CleanupMode::Rename | CleanupMode::Delete => true,\n-            CleanupMode::DryRunV2 | CleanupMode::DeleteV2 => false,\n-        };\n-\n-        if use_v1_orchestrator {\n+        if cleanup_mode.is_v2() {\n             let orchestrator =\n-                crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+                crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n                     collection.id,\n                     collection.version_file_path,\n+                    collection.lineage_file_path,\n                     absolute_cutoff_time,\n                     self.sysdb_client.clone(),\n                     dispatcher.clone(),\n+                    system.clone(),\n                     self.storage.clone(),\n+                    self.root_manager.clone(),\n                     cleanup_mode,\n+                    2,\n                 );\n \n             let started_at = SystemTime::now();\n@@ -178,23 +177,19 @@ impl GarbageCollector {\n                     format!(\"{:?}\", cleanup_mode),\n                 )],\n             );\n+\n             return Ok(result);\n         }\n \n-        let orchestrator =\n-            crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n-                collection.id,\n-                collection.version_file_path,\n-                collection.lineage_file_path,\n-                absolute_cutoff_time,\n-                self.sysdb_client.clone(),\n-                dispatcher.clone(),\n-                system.clone(),\n-                self.storage.clone(),\n-                self.root_manager.clone(),\n-                cleanup_mode,\n-                2,\n-            );\n+        let orchestrator = crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+            collection.id,\n+            collection.version_file_path,\n+            absolute_cutoff_time,\n+            self.sysdb_client.clone(),\n+            dispatcher.clone(),\n+            self.storage.clone(),\n+            cleanup_mode,\n+        );\n \n         let started_at = SystemTime::now();\n         let result = orchestrator.run(system.clone()).await?;\n@@ -217,7 +212,6 @@ impl GarbageCollector {\n                 format!(\"{:?}\", cleanup_mode),\n             )],\n         );\n-\n         Ok(result)\n     }\n }\n@@ -360,9 +354,18 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 continue;\n             }\n \n-            if collection.lineage_file_path.is_some() {\n+            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n+                tenant_mode_overrides\n+                    .get(&collection.tenant)\n+                    .cloned()\n+                    .unwrap_or(self.default_cleanup_mode)\n+            } else {\n+                self.default_cleanup_mode\n+            };\n+\n+            if collection.lineage_file_path.is_some() && !cleanup_mode.is_v2() {\n                 tracing::debug!(\n-                    \"Skipping garbage collection for root of fork tree: {}\",\n+                    \"Skipping garbage collection for root of fork tree because GC v1 cannot handle fork trees: {}\",\n                     collection.id\n                 );\n                 num_skipped_jobs += 1;\n@@ -376,17 +379,6 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 collection.version_file_path\n             );\n \n-            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n-                tenant_mode_overrides\n-                    .get(&collection.tenant)\n-                    .cloned()\n-                    .unwrap_or(self.default_cleanup_mode)\n-            } else {\n-                self.default_cleanup_mode\n-            };\n-\n-            tracing::info!(\"Creating gc orchestrator for collection: {}\", collection.id);\n-\n             let instrumented_span = span!(parent: None, tracing::Level::INFO, \"Garbage collection job\", collection_id = ?collection.id, tenant_id = %collection.tenant, cleanup_mode = ?cleanup_mode);\n             instrumented_span.follows_from(Span::current());\n \n@@ -1011,6 +1003,26 @@ mod tests {\n         let (collection_in_delete_mode, database_name_in_delete_mode) =\n             collection_in_delete_mode_handle.await.unwrap();\n \n+        // Fork collection in delete mode to give it a lineage file (only GC v2 can handle fork trees)\n+        {\n+            let source_collection = sysdb\n+                .get_collections(Some(collection_in_delete_mode), None, None, None, None, 0)\n+                .await\n+                .unwrap();\n+            let source_collection = source_collection.first().unwrap();\n+\n+            sysdb\n+                .fork_collection(\n+                    collection_in_delete_mode,\n+                    source_collection.total_records_post_compaction,\n+                    source_collection.total_records_post_compaction,\n+                    CollectionUuid::new(),\n+                    \"test-fork\".to_string(),\n+                )\n+                .await\n+                .unwrap();\n+        }\n+\n         // Wait 1 second for cutoff time\n         tokio::time::sleep(Duration::from_secs(1)).await;\n \n---\nrust/garbage_collector/src/types.rs\n@@ -19,6 +19,12 @@ pub enum CleanupMode {\n     DeleteV2,\n }\n \n+impl CleanupMode {\n+    pub fn is_v2(&self) -> bool {\n+        matches!(self, CleanupMode::DryRunV2 | CleanupMode::DeleteV2)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub enum VersionStatus {\n     #[allow(dead_code)]\n---\n\n\n---\n\nChoice C:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.41\n+version: 0.1.42\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -35,4 +35,4 @@ compactionService:\n       value: 'value: \"/tilt_config.yaml\"'\n \n rustLogService:\n-  replicaCount: 2\n+  replicaCount: 1\n---\n\n\n---\n\nChoice D:\nrust/wal3/src/writer.rs\n@@ -518,9 +518,7 @@ impl OnceLogWriter {\n             log_position,\n             messages,\n         );\n-        let fut2 = self\n-            .mark_dirty\n-            .mark_dirty(log_position + messages_len, messages_len);\n+        let fut2 = self.mark_dirty.mark_dirty(log_position, messages_len);\n         let (res1, res2) = futures::future::join(fut1, fut2).await;\n         res2?;\n         let (path, setsum, num_bytes) = res1?;\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - This change waits for a valid memberlist to be ready for the log client before marking the pod as ready\r\n  - This should address the flakes that have started to occur after making tilt in CI come up faster when we decoupled docker builds from tilt up, which makes this path more likely\r\n  - This mirrors the same path as the query executor\r\n- New functionality\r\n  - None\r\n  \r\n## Test plan\r\nThey are not currently tests\r\n_How are these changes tested?_\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nNone\n\n---\n\nChoice A:\nrust/frontend/src/impls/in_memory_frontend.rs\n@@ -664,6 +664,7 @@ impl InMemoryFrontend {\n     pub fn healthcheck(&self) -> chroma_types::HealthCheckResponse {\n         chroma_types::HealthCheckResponse {\n             is_executor_ready: true,\n+            is_log_client_ready: true,\n         }\n     }\n }\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -1433,6 +1433,7 @@ impl ServiceBasedFrontend {\n     pub async fn healthcheck(&self) -> HealthCheckResponse {\n         HealthCheckResponse {\n             is_executor_ready: self.executor.is_ready().await,\n+            is_log_client_ready: self.log_client.is_ready(),\n         }\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -738,6 +738,18 @@ impl GrpcLog {\n             Err(GrpcMigrateLogError::NotSupported)\n         }\n     }\n+\n+    /// If the log client is configured to use a memberlist-based client assigner,\n+    /// this function checks if the client assigner is ready to serve requests.\n+    /// This is useful to ensure that the client assigner has enough information about the cluster\n+    /// before making requests to the log service.\n+    pub fn is_ready(&self) -> bool {\n+        if let Some(client_assigner) = &self.alt_client_assigner {\n+            !client_assigner.is_empty()\n+        } else {\n+            true // If no client assigner is configured, we assume it's ready.\n+        }\n+    }\n }\n \n #[cfg(test)]\n---\nrust/log/src/log.rs\n@@ -222,4 +222,12 @@ impl Log {\n             Log::InMemory(_) => unimplemented!(),\n         }\n     }\n+\n+    pub fn is_ready(&self) -> bool {\n+        match self {\n+            Log::Sqlite(_) => true,\n+            Log::Grpc(log) => log.is_ready(),\n+            Log::InMemory(_) => true,\n+        }\n+    }\n }\n---\nrust/types/src/api_types.rs\n@@ -1719,11 +1719,12 @@ impl ChromaError for QueryError {\n #[derive(Serialize, ToSchema)]\n pub struct HealthCheckResponse {\n     pub is_executor_ready: bool,\n+    pub is_log_client_ready: bool,\n }\n \n impl HealthCheckResponse {\n     pub fn get_status_code(&self) -> tonic::Code {\n-        if self.is_executor_ready {\n+        if self.is_executor_ready && self.is_log_client_ready {\n             tonic::Code::Ok\n         } else {\n             tonic::Code::Unavailable\n---\n\n\n---\n\nChoice B:\n.github/workflows/release-chromadb.yml\n@@ -61,6 +61,7 @@ jobs:\n   go-tests:\n     name: Go tests\n     uses: ./.github/workflows/_go-tests.yml\n+    secrets: inherit\n \n   release-docker:\n     name: Publish to DockerHub and GHCR\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -374,7 +374,7 @@ func (tc *Catalog) createCollectionImpl(txCtx context.Context, createCollection\n \t\treturn nil, false, common.ErrConcurrentDeleteCollection\n \t}\n \tresult := convertCollectionToModel(collectionList)[0]\n-\treturn result, true, nil\n+\treturn result, created, nil\n }\n \n func (tc *Catalog) CreateCollection(ctx context.Context, createCollection *model.CreateCollection, ts types.Timestamp) (*model.Collection, bool, error) {\n@@ -1249,7 +1249,6 @@ func (tc *Catalog) CreateCollectionAndSegments(ctx context.Context, createCollec\n \t\t}\n \n \t\t// If collection already exists, then do not create segments.\n-\t\t// TODO: Should we check to see if segments does not exist? and create them?\n \t\tif !created {\n \t\t\treturn nil\n \t\t}\n---\n\n\n---\n\nChoice D:\n.github/workflows/_python-tests.yml\n@@ -155,7 +155,7 @@ jobs:\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n       - uses: ./.github/actions/tilt\n       - name: Test\n-        run: bin/cluster-test.sh bash -c 'python -m pytest \"${{ matrix.test-globs }}\"' --durations 10\n+        run: bin/cluster-test.sh bash -c 'python -m pytest \"${{ matrix.test-globs }}\" --durations 10'\n         shell: bash\n         env:\n           PROPERTY_TESTING_PRESET: ${{ inputs.property_testing_preset }}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThis speeds up the filter benchmark by 2.3x (tested locally, 7m12s -> 3m9s).\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\n\n---\n\nChoice A:\nrust/log/src/test.rs\n@@ -124,7 +124,7 @@ pub trait LoadFromGenerator<L: LogGenerator> {\n impl<L: LogGenerator + Send + 'static> LoadFromGenerator<L> for TestDistributedSegment {\n     async fn populate_with_generator(&mut self, log_count: usize, generator: L) {\n         let ids: Vec<_> = (1..=log_count).collect();\n-        for chunk in ids.chunks(100) {\n+        for chunk in ids.chunks(10_000) {\n             self.compact_log(\n                 generator.generate_chunk(chunk.iter().copied()),\n                 chunk\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -917,6 +917,7 @@ impl LogServer {\n                 Limits {\n                     max_files: Some(10_000),\n                     max_bytes: Some(1_000_000_000),\n+                    max_records: Some(10_000),\n                 },\n             )\n             .await?;\n@@ -1151,6 +1152,7 @@ impl LogServer {\n             let limits = Limits {\n                 max_files: Some(pull_logs.batch_size as u64 + 1),\n                 max_bytes: None,\n+                max_records: Some(pull_logs.batch_size as u64),\n             };\n             let fragments = match log_reader\n                 .scan(\n@@ -1172,17 +1174,25 @@ impl LogServer {\n                 .map(|fragment| async {\n                     let cache_key = format!(\"{collection_id}::{}\", fragment.path);\n                     if let Some(cache) = self.cache.as_ref() {\n-                        if let Ok(Some(answer)) = cache.get(&cache_key).await {\n+                        let cache_span = tracing::info_span!(\"cache get\");\n+                        if let Ok(Some(answer)) = cache.get(&cache_key).instrument(cache_span).await\n+                        {\n                             return Ok(Arc::new(answer.bytes));\n                         }\n-                        let answer = log_reader.fetch(fragment).await?;\n+                        let fetch_span = tracing::info_span!(\"fragment fetch\");\n+                        let answer = log_reader.fetch(fragment).instrument(fetch_span).await?;\n                         let cache_value = CachedParquetFragment {\n                             bytes: Clone::clone(&*answer),\n                         };\n-                        cache.insert(cache_key, cache_value).await;\n+                        let insert_span = tracing::info_span!(\"cache insert\");\n+                        cache\n+                            .insert(cache_key, cache_value)\n+                            .instrument(insert_span)\n+                            .await;\n                         Ok(answer)\n                     } else {\n-                        log_reader.fetch(fragment).await\n+                        let fetch_span = tracing::info_span!(\"fragment fetch\");\n+                        log_reader.fetch(fragment).instrument(fetch_span).await\n                     }\n                 })\n                 .collect::<Vec<_>>();\n@@ -1411,6 +1421,7 @@ impl LogServer {\n                 Limits {\n                     max_files: Some(1_000_000),\n                     max_bytes: Some(1_000_000_000),\n+                    max_records: Some(1_000_000),\n                 },\n             )\n             .await\n---\nrust/wal3/src/reader.rs\n@@ -22,6 +22,7 @@ use crate::{\n pub struct Limits {\n     pub max_files: Option<u64>,\n     pub max_bytes: Option<u64>,\n+    pub max_records: Option<u64>,\n }\n \n /// LogReader is a reader for the log.\n@@ -90,16 +91,27 @@ impl LogReader {\n         else {\n             return Err(Error::UninitializedLog);\n         };\n+        let log_position_range = if let Some(max_records) = limits.max_records {\n+            (from, from + max_records)\n+        } else {\n+            (from, LogPosition::MAX)\n+        };\n+        fn ranges_overlap(\n+            lhs: (LogPosition, LogPosition),\n+            rhs: (LogPosition, LogPosition),\n+        ) -> bool {\n+            lhs.0 <= rhs.1 && rhs.0 <= lhs.1\n+        }\n         let mut snapshots = manifest\n             .snapshots\n             .iter()\n-            .filter(|s| s.limit.offset() > from.offset())\n+            .filter(|s| ranges_overlap(log_position_range, (s.start, s.limit)))\n             .cloned()\n             .collect::<Vec<_>>();\n         let mut fragments = manifest\n             .fragments\n             .iter()\n-            .filter(|f| f.limit.offset() > from.offset())\n+            .filter(|f| ranges_overlap(log_position_range, (f.start, f.limit)))\n             .cloned()\n             .collect::<Vec<_>>();\n         while !snapshots.is_empty() {\n@@ -137,6 +149,18 @@ impl LogReader {\n                 fragments.truncate(max_files as usize);\n             }\n         }\n+        while fragments.len() > 1\n+            // NOTE(rescrv):  We take the start of the last fragment, because if there are enough\n+            // records without it we can pop.\n+            && fragments[fragments.len() - 1].start - fragments[0].start\n+                > limits.max_records.unwrap_or(u64::MAX)\n+        {\n+            tracing::info!(\n+                \"truncating to {} files because records restrictions\",\n+                fragments.len() - 1\n+            );\n+            fragments.pop();\n+        }\n         while fragments.len() > 1\n             && fragments\n                 .iter()\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -1219,17 +1219,16 @@ impl LogService for LogServer {\n             let witness = cursors.load(cursor_name).await.map_err(|err| {\n                 Status::new(err.code().into(), format!(\"Failed to load cursor: {}\", err))\n             })?;\n-            // This is the existing compaction_offset, which is the last record that was compacted.\n+            // This is the existing compaction_offset, which is the next record to compact.\n             let offset = witness\n                 .map(|x| x.1.position)\n-                .unwrap_or(LogPosition::from_offset(0));\n+                .unwrap_or(LogPosition::from_offset(1));\n             tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n                 &log_reader,\n-                // + 1 to get to the first uncompacted record.\n-                offset + 1u64,\n+                offset,\n                 target_prefix.clone(),\n             )\n             .await\n@@ -1253,7 +1252,9 @@ impl LogService for LogServer {\n             }\n             tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n-                compaction_offset: offset.offset(),\n+                // NOTE: The upstream service expects the last compacted offset as compaction offset\n+                compaction_offset: (offset - 1u64).offset(),\n+                // NOTE: The upstream service expects the last uncompacted offset as enumeration offset\n                 enumeration_offset: (max_offset - 1u64).offset(),\n             }))\n         }\n---\n\n\n---\n\nChoice D:\nCargo.lock\n@@ -1813,8 +1813,10 @@ dependencies = [\n  \"bytes\",\n  \"chroma-config\",\n  \"chroma-error\",\n+ \"chroma-tracing\",\n  \"futures\",\n  \"object_store\",\n+ \"opentelemetry\",\n  \"parking_lot\",\n  \"rand 0.8.5\",\n  \"rand_xorshift\",\n---\nrust/storage/Cargo.toml\n@@ -23,9 +23,11 @@ thiserror.workspace = true\n tokio = { workspace = true }\n tokio-util = { workspace = true }\n tracing = { workspace = true }\n+opentelemetry = { workspace = true }\n \n chroma-config = { workspace = true }\n chroma-error = { workspace = true }\n+chroma-tracing = { workspace = true }\n \n [dev-dependencies]\n rand_xorshift = { workspace = true }\n---\nrust/storage/src/admissioncontrolleds3.rs\n@@ -10,6 +10,7 @@ use bytes::Bytes;\n use chroma_config::registry::Registry;\n use chroma_config::Configurable;\n use chroma_error::ChromaError;\n+use chroma_tracing::util::Stopwatch;\n use futures::future::BoxFuture;\n use futures::{future::Shared, stream, FutureExt, StreamExt};\n use std::{\n@@ -524,9 +525,30 @@ impl RateLimitPolicy {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct CountBasedPolicyMetrics {\n+    // The delay in milliseconds before a request is allowed to proceed.\n+    pub nac_delay_ms: opentelemetry::metrics::Histogram<u64>,\n+}\n+\n+impl Default for CountBasedPolicyMetrics {\n+    fn default() -> Self {\n+        Self {\n+            nac_delay_ms: opentelemetry::global::meter(\"chroma.storage.admission_control\")\n+                .u64_histogram(\"nac_delay_ms\")\n+                .with_description(\n+                    \"The delay in milliseconds before a request is allowed to proceed.\",\n+                )\n+                .with_unit(\"ms\")\n+                .build(),\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct CountBasedPolicy {\n     remaining_tokens: Vec<Semaphore>,\n+    metrics: CountBasedPolicyMetrics,\n }\n \n impl CountBasedPolicy {\n@@ -537,14 +559,18 @@ impl CountBasedPolicy {\n                 (max_allowed_outstanding as f32 * allocation).ceil() as usize,\n             ));\n         }\n-        Self { remaining_tokens }\n+        Self {\n+            remaining_tokens,\n+            metrics: CountBasedPolicyMetrics::default(),\n+        }\n     }\n \n     async fn acquire(\n         &self,\n         priority: Arc<AtomicUsize>,\n         mut channel_receiver: Option<tokio::sync::mpsc::Receiver<()>>,\n     ) -> SemaphorePermit<'_> {\n+        let _stopwatch = Stopwatch::new(&self.metrics.nac_delay_ms, &[]);\n         loop {\n             let current_priority = priority.load(Ordering::SeqCst);\n             let current_priority: StorageRequestPriority = current_priority.into();\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nTogether, these changes shave 2m from the main group of Rust tests and 3m from test-long--bringing both under our target 15m.\r\n\r\n## Test plan\r\n\r\nCI passes.\n\n---\n\nChoice A:\ngo/cmd/logservice/main.go\n@@ -25,6 +25,11 @@ import (\n \thealthgrpc \"google.golang.org/grpc/health/grpc_health_v1\"\n )\n \n+// hard-coding this here despite it also being in pkg/grpcutils/service.go because\n+// using the methods from grpcutils results in breaking our metrics collection for\n+// some reason. This service is being deprecated soon, so this is just a quick fix.\n+const maxGrpcFrameSize = 256 * 1024 * 1024\n+\n func main() {\n \tctx := context.Background()\n \n@@ -55,7 +60,10 @@ func main() {\n \tif err != nil {\n \t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n \t}\n-\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n+\ts := grpc.NewServer(\n+\t\tgrpc.MaxRecvMsgSize(maxGrpcFrameSize),\n+\t\tgrpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor),\n+\t)\n \thealthcheck := health.NewServer()\n \thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n---\n\n\n---\n\nChoice B:\n.github/workflows/_rust-tests.yml\n@@ -7,7 +7,7 @@ jobs:\n   test:\n     strategy:\n       matrix:\n-        platform: [blacksmith-4vcpu-ubuntu-2204]\n+        platform: [blacksmith-8vcpu-ubuntu-2204]\n     runs-on: ${{ matrix.platform }}\n     env:\n       CARGO_TERM_COLOR: always\n@@ -22,9 +22,9 @@ jobs:\n       - name: Build CLI\n         run: cargo build --bin chroma\n       - name: Test\n-        run: cargo nextest run --no-capture --profile ci\n+        run: cargo nextest run --profile ci\n   test-long:\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n+    runs-on: blacksmith-8vcpu-ubuntu-2204\n     env:\n       CARGO_TERM_COLOR: always\n       RUST_BACKTRACE: 1\n@@ -35,10 +35,8 @@ jobs:\n         uses: ./.github/actions/rust\n         with:\n           github-token: ${{ github.token }}\n-      - name: Build CLI\n-        run: cargo build --bin chroma\n       - name: Test\n-        run: cargo nextest run --no-capture --profile ci_long_running\n+        run: cargo nextest run --profile ci_long_running\n \n   test-integration:\n     strategy:\n---\n\n\n---\n\nChoice C:\nrust/segment/src/sqlite_metadata.rs\n@@ -644,12 +644,12 @@ impl SqliteMetadataReader {\n \n         if let Some(whr) = &where_clause {\n             filter_limit_query\n-                .left_join(\n+                .inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n                 )\n-                .left_join(\n+                .inner_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n@@ -683,7 +683,7 @@ impl SqliteMetadataReader {\n \n         if document || metadata {\n             projection_query\n-                .left_join(\n+                .inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((alias.clone(), Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n---\n\n\n---\n\nChoice D:\nclients/js/packages/chromadb/package.json\n@@ -50,6 +50,13 @@\n     \"tsup\": \"^7.2.0\",\n     \"typescript\": \"^5.0.4\"\n   },\n+  \"optionalDependencies\": {\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+  },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n   },\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.0.0\"\n+$release = \"cli-1.1.0\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.0.0\"\n+RELEASE=\"cli-1.1.0\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\nrust/cli/src/client/collection.rs\n@@ -130,13 +130,7 @@ impl Collection {\n             self.chroma_client.tenant_id, self.chroma_client.db, self.collection_id\n         );\n \n-        let payload = AddCollectionRecordsPayload {\n-            ids,\n-            embeddings,\n-            documents,\n-            uris,\n-            metadatas,\n-        };\n+        let payload = AddCollectionRecordsPayload::new(ids, embeddings, documents, uris, metadatas);\n \n         let _response = send_request::<AddCollectionRecordsPayload, AddCollectionRecordsResponse>(\n             &self.chroma_client.host,\n---\nrust/cli/src/commands/copy.rs\n@@ -277,7 +277,7 @@ pub fn copy(args: CopyArgs) -> Result<(), CliError> {\n         if !args.all && args.collections.is_empty() {\n             return Err(CopyError::NoCollections.into());\n         }\n-        \n+\n         let (_, profile) = get_current_profile()?;\n         let (source, target) = get_target_and_destination(&args)?;\n         let (source_client, target_client, _handle) =\n---\nrust/frontend/src/server.rs\n@@ -1252,11 +1252,29 @@ async fn fork_collection(\n \n #[derive(Serialize, Deserialize, ToSchema, Debug, Clone)]\n pub struct AddCollectionRecordsPayload {\n-    pub ids: Vec<String>,\n-    pub embeddings: Option<Vec<Vec<f32>>>,\n-    pub documents: Option<Vec<Option<String>>>,\n-    pub uris: Option<Vec<Option<String>>>,\n-    pub metadatas: Option<Vec<Option<Metadata>>>,\n+    ids: Vec<String>,\n+    embeddings: Option<Vec<Vec<f32>>>,\n+    documents: Option<Vec<Option<String>>>,\n+    uris: Option<Vec<Option<String>>>,\n+    metadatas: Option<Vec<Option<Metadata>>>,\n+}\n+\n+impl AddCollectionRecordsPayload {\n+    pub fn new(\n+        ids: Vec<String>,\n+        embeddings: Option<Vec<Vec<f32>>>,\n+        documents: Option<Vec<Option<String>>>,\n+        uris: Option<Vec<Option<String>>>,\n+        metadatas: Option<Vec<Option<Metadata>>>,\n+    ) -> Self {\n+        Self {\n+            ids,\n+            embeddings,\n+            documents,\n+            uris,\n+            metadatas,\n+        }\n+    }\n }\n \n /// Adds records to a collection.\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nhttps://github.com/chroma-core/chroma/pull/4402 caused `test_filtering.py` to start flaking because the test assertions around `_` handling were not updated.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\n\n---\n\nChoice A:\nrust/blockstore/src/arrow/blockfile.rs\n@@ -471,6 +471,15 @@ impl<'me, K: ArrowReadableKey<'me> + Into<KeyWrapper>, V: ArrowReadableValue<'me\n         self.load_blocks(&target_block_ids).await;\n     }\n \n+    pub(crate) async fn load_blocks_for_prefixes(&self, prefixes: impl IntoIterator<Item = &str>) {\n+        let prefix_vec = prefixes.into_iter().collect();\n+        let target_block_ids = self\n+            .root\n+            .sparse_index\n+            .get_block_ids_for_prefixes(prefix_vec);\n+        self.load_blocks(&target_block_ids).await;\n+    }\n+\n     pub(crate) async fn get(\n         &'me self,\n         prefix: &str,\n---\nrust/blockstore/src/arrow/sparse_index.rs\n@@ -362,7 +362,47 @@ impl SparseIndexReader {\n         result_uuids\n     }\n \n-    pub(super) fn get_block_ids_range<'prefix, 'referred_data, PrefixRange>(\n+    pub(super) fn get_block_ids_for_prefixes(&self, mut prefixes: Vec<&str>) -> Vec<Uuid> {\n+        prefixes.sort();\n+        let mut result_uuids = Vec::new();\n+        let block_start = self.data.forward.iter();\n+        let block_end = block_start\n+            .clone()\n+            .skip(1)\n+            .map(|(delim, _)| match delim {\n+                SparseIndexDelimiter::Start => {\n+                    unreachable!(\"The start delimiter should only appear in the first block\")\n+                }\n+                SparseIndexDelimiter::Key(composite_key) => Some(composite_key.prefix.as_str()),\n+            })\n+            .chain([None]);\n+        let mut prefix_iter = prefixes.into_iter().peekable();\n+        for ((start_delim, block), end_prefix) in block_start.zip(block_end) {\n+            if let SparseIndexDelimiter::Key(CompositeKey {\n+                prefix: start_prefix,\n+                key: _,\n+            }) = start_delim\n+            {\n+                while let Some(&prefix) = prefix_iter.peek() {\n+                    if start_prefix.as_str() <= prefix {\n+                        break;\n+                    }\n+                    prefix_iter.next();\n+                }\n+            }\n+            if let Some(&prefix) = prefix_iter.peek() {\n+                if end_prefix.is_none() || end_prefix.is_some_and(|end_prefix| prefix <= end_prefix)\n+                {\n+                    result_uuids.push(block.id);\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+        result_uuids\n+    }\n+\n+    pub(super) fn get_block_ids_range<'prefix, PrefixRange>(\n         &self,\n         prefix_range: PrefixRange,\n     ) -> Vec<Uuid>\n---\nrust/blockstore/src/types/reader.rs\n@@ -125,6 +125,18 @@ impl<\n         }\n     }\n \n+    pub async fn load_blocks_for_prefixes<'prefix>(\n+        &self,\n+        prefixes: impl IntoIterator<Item = &'prefix str>,\n+    ) {\n+        match self {\n+            BlockfileReader::MemoryBlockfileReader(_reader) => unimplemented!(),\n+            BlockfileReader::ArrowBlockfileReader(reader) => {\n+                reader.load_blocks_for_prefixes(prefixes).await\n+            }\n+        }\n+    }\n+\n     pub async fn rank(\n         &'referred_data self,\n         prefix: &'referred_data str,\n---\n\n\n---\n\nChoice B:\n.github/workflows/release-chromadb.yml\n@@ -220,7 +220,7 @@ jobs:\n                 // - This workflow finishes for A and deploys A to Chroma Cloud\n                 // Chroma Cloud is now running A, but the last commit was B.\n                 \"environment\": \"staging\",\n-                \"planes\": \"data,control\"\n+                \"planes\": \"control,data\"\n               }\n             })\n \n---\n.github/workflows/trigger-deploy.yaml\n@@ -5,8 +5,9 @@ on:\n   push:\n     branches:\n       # main is not included here because it is handled by the release-chromadb.yaml workflow\n+      # production deploys (release branches) are also not here because they are currently\n+      # meant to be handled manually.\n       - rc/**-**-**\n-      - release/**-**-**\n \n jobs:\n   deploy:\n@@ -25,7 +26,7 @@ jobs:\n               ref: 'main',\n               inputs: {\n                 'planes': 'control,data',\n-                 environment: '${{ contains(github.ref, 'release/') && 'production' || 'staging' }}',\n+                 environment: 'staging',\n                 'ignore-lock': true,\n                 'oss-ref': '${{ github.ref_name }}',\n                 'hosted-ref': '${{ github.ref_name }}'\n---\n\n\n---\n\nChoice C:\nchromadb/test/property/test_filtering.py\n@@ -20,7 +20,6 @@\n import chromadb.test.property.strategies as strategies\n import hypothesis.strategies as st\n import logging\n-import re\n from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n import numpy as np\n \n@@ -95,20 +94,10 @@ def _filter_where_doc_clause(clause: WhereDocument, doc: Document) -> bool:\n     if key == \"$contains\":\n         if not doc:\n             return False\n-        # SQLite FTS handles % and _ as word boundaries that are ignored so we need to\n-        # treat them as wildcards\n-        if \"%\" in expr or \"_\" in expr:\n-            expr = expr.replace(\"%\", \".\").replace(\"_\", \".\")\n-            return re.search(expr, doc) is not None\n         return expr in doc\n     elif key == \"$not_contains\":\n         if not doc:\n             return True\n-        # SQLite FTS handles % and _ as word boundaries that are ignored so we need to\n-        # treat them as wildcards\n-        if \"%\" in expr or \"_\" in expr:\n-            expr = expr.replace(\"%\", \".\").replace(\"_\", \".\")\n-            return re.search(expr, doc) is None\n         return expr not in doc\n     else:\n         raise ValueError(\"Unknown operator: {}\".format(key))\n---\n\n\n---\n\nChoice D:\n.github/workflows/_python-tests.yml\n@@ -291,7 +291,7 @@ jobs:\n         api_key: ${{ secrets.DD_API_KEY }}\n         site: ${{ vars.DD_SITE }}\n     - name: Integration Test\n-      run: bin/python-integration-test ${{ matrix.test-globs }}\n+      run: python -m pytest ${{ matrix.test-globs }}\n       shell: bash\n       env:\n         ENV_FILE: ${{ matrix.env-file }}\n---\nchromadb/test/test_cli.py\n@@ -1,6 +1,5 @@\n import multiprocessing\n import multiprocessing.context\n-import os\n import sys\n import time\n from multiprocessing.synchronize import Event\n@@ -10,7 +9,6 @@\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,6 +17,36 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+        host: str, port: int,\n+    max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            client = chromadb.HttpClient(host=host, port=port)\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            print(\"Heartbeat failed, trying again...\")\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n@@ -32,14 +60,10 @@ def test_app() -> None:\n     server_process.start()\n     time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    assert wait_for_server(host=\"localhost\", port=8001), \"Server failed to start within maximum retry attempts\"\n \n-    client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -124,7 +148,7 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\", \"--timeout\", \"10\"]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\nrust/cli/src/commands/vacuum.rs\n@@ -20,8 +20,10 @@ use sqlx::Row;\n use std::error::Error;\n use std::path::Path;\n use std::str::FromStr;\n+use std::time::Duration;\n use std::{fs, io};\n use thiserror::Error;\n+use tokio::time::timeout;\n \n #[derive(Debug, Error)]\n pub enum VacuumError {\n@@ -43,6 +45,8 @@ pub struct VacuumArgs {\n     path: Option<String>,\n     #[clap(long, default_value_t = false, help = \"Skip vacuum confirmation\")]\n     force: bool,\n+    #[clap(long, help = \"Maximum time (in seconds) to wait for vacuum\")]\n+    timeout: Option<u64>,\n }\n \n fn sizeof_fmt(num: u64, suffix: Option<&str>) -> String {\n@@ -195,10 +199,6 @@ pub async fn vacuum_chroma(config: FrontendConfig) -> Result<(), Box<dyn Error>>\n \n     println!(\"Vacuuming (this may take a while)...\\n\");\n \n-    sqlx::query(&format!(\"PRAGMA busy_timeout = {}\", 5000))\n-        .execute(sqlite.get_conn())\n-        .await?;\n-\n     sqlx::query(\"VACUUM\").execute(sqlite.get_conn()).await?;\n \n     sqlx::query(\n@@ -264,9 +264,19 @@ pub fn vacuum(args: VacuumArgs) -> Result<(), CliError> {\n     };\n \n     let runtime = tokio::runtime::Runtime::new().expect(\"Failed to start Chroma\");\n-    runtime\n-        .block_on(vacuum_chroma(config.frontend))\n-        .map_err(|_| VacuumError::VacuumFailed)?;\n+\n+    let res = if let Some(secs) = args.timeout {\n+        runtime.block_on(async {\n+            timeout(Duration::from_secs(secs), vacuum_chroma(config.frontend))\n+                .await\n+                .unwrap_or_else(|_elapsed| {\n+                    Err(Box::new(VacuumError::VacuumFailed) as Box<dyn std::error::Error>)\n+                })\n+        })\n+    } else {\n+        runtime.block_on(vacuum_chroma(config.frontend))\n+    };\n+    res.map_err(|_| VacuumError::VacuumFailed)?;\n \n     let post_vacuum_size =\n         get_dir_size(Path::new(&persistent_path)).map_err(|_| VacuumError::DirSizeFailed)?;\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nReverts chroma-core/chroma#4759.\r\n\r\nThe split build consistently fails and is blocking our release pipeline. Reverting until we have clarity from Blacksmith and a tested & working split build impl.\n\n---\n\nChoice A:\n.github/actions/docker/action.yaml\n@@ -17,6 +17,11 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n+    # https://github.com/docker/setup-qemu-action - for multiplatform builds\n+    - name: Set up QEMU\n+      uses: docker/setup-qemu-action@v2\n+    - name: Set up Docker Buildx\n+      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n.github/workflows/_build_release_container.yml\n@@ -33,106 +33,43 @@ permissions:\n env:\n   GHCR_IMAGE_NAME: \"ghcr.io/chroma-core/chroma\"\n   DOCKERHUB_IMAGE_NAME: \"chromadb/chroma\"\n+  PLATFORMS: linux/amd64,linux/arm64 #linux/riscv64, linux/arm/v7\n \n jobs:\n   build:\n-    name: Build image for ${{ matrix.platform }}\n+    name: Build and publish container image\n     runs-on: blacksmith-16vcpu-ubuntu-2204\n-    strategy:\n-      matrix:\n-        platform: [amd64, arm64]\n-        include:\n-          - platform: amd64\n-            runner: blacksmith-16vcpu-ubuntu-2204\n-            docker_platform: linux/amd64\n-          - platform: arm64\n-            runner: blacksmith-16vcpu-ubuntu-2204-arm\n-            docker_platform: linux/arm64\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n         with:\n           fetch-depth: 0\n-\n       - name: Set up Docker\n         uses: ./.github/actions/docker\n         with:\n           ghcr-username: ${{ github.actor }}\n           ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n           dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-\n-      - name: Compute arch-specific tags\n-        id: tags\n+      - name: Compute tags\n         shell: bash\n+        id: compute_tags\n         run: |\n-          arch_tag=\"${{ inputs.tag }}-${{ matrix.platform }}\"\n-          ghcr=\"${{ env.GHCR_IMAGE_NAME }}:${arch_tag}\"\n-          dhub=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${arch_tag}\"\n-          echo \"arch_tag=$arch_tag\"      >> $GITHUB_OUTPUT\n-\n-          # expose *matrix-unique* step outputs\n-          echo \"ghcr_tag_${{ matrix.platform }}=$ghcr\"         >> $GITHUB_OUTPUT\n-          echo \"dockerhub_tag_${{ matrix.platform }}=$dhub\"    >> $GITHUB_OUTPUT\n+          tags=\"${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }},${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\"\n+          if [ \"${{ inputs.tag_as_latest }}\" = \"true\" ]; then\n+            tags=\"${tags},${{ env.GHCR_IMAGE_NAME }}:latest,${{ env.DOCKERHUB_IMAGE_NAME }}:latest\"\n+          fi\n \n-          # these two tags are what the build-push action will publish for *this* arch\n-          echo \"tags=$ghcr,$dhub\" >> $GITHUB_OUTPUT\n+          echo \"tags=${tags}\" >> $GITHUB_OUTPUT\n \n       - name: Build and push image\n         uses: useblacksmith/build-push-action@v1.1\n         with:\n           context: .\n           file: rust/Dockerfile\n           target: cli\n-          platforms: ${{ matrix.docker_platform }}\n+          platforms: ${{ env.PLATFORMS }}\n           push: true\n           build-args: |\n             RELEASE_MODE=1\n-          tags: ${{ steps.tags.outputs.tags }}\n-    outputs:\n-      ghcr_tag_amd64:      ${{ steps.tags.outputs.ghcr_tag_amd64 }}\n-      ghcr_tag_arm64:      ${{ steps.tags.outputs.ghcr_tag_arm64 }}\n-      dockerhub_tag_amd64: ${{ steps.tags.outputs.dockerhub_tag_amd64 }}\n-      dockerhub_tag_arm64: ${{ steps.tags.outputs.dockerhub_tag_arm64 }}\n-\n-  merge:\n-    name: Merge platform manifests\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n-    needs:\n-      - build\n-    steps:\n-      - name: Set up Docker\n-        uses: ./.github/actions/docker\n-        with:\n-          ghcr-username: ${{ github.actor }}\n-          ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n-          dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n-          dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-\n-      - name: Create and push manifest\n-        shell: bash\n-        run: |\n-          set -euo pipefail\n-\n-          # Pull the per-arch tags from job-level outputs\n-          ghcr_amd64='${{ needs.build.outputs.ghcr_tag_amd64 }}'\n-          ghcr_arm64='${{ needs.build.outputs.ghcr_tag_arm64 }}'\n-          dhub_amd64='${{ needs.build.outputs.dockerhub_tag_amd64 }}'\n-          dhub_arm64='${{ needs.build.outputs.dockerhub_tag_arm64 }}'\n-\n-          base_tag='${{ inputs.tag }}'\n-          ghcr_base=\"${{ env.GHCR_IMAGE_NAME }}:${base_tag}\"\n-          dhub_base=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${base_tag}\"\n-\n-          docker buildx imagetools create --tag \"$ghcr_base\" $ghcr_amd64 $ghcr_arm64\n-          docker buildx imagetools create --tag \"$dhub_base\"  $dhub_amd64 $dhub_arm64\n-\n-          if [[ \"${{ inputs.tag_as_latest }}\" == \"true\" ]]; then\n-            docker buildx imagetools create --tag \"${{ env.GHCR_IMAGE_NAME }}:latest\"  $ghcr_amd64 $ghcr_arm64\n-            docker buildx imagetools create --tag \"${{ env.DOCKERHUB_IMAGE_NAME }}:latest\" $dhub_amd64 $dhub_arm64\n-          fi\n-\n-      - name: Inspect image\n-        run: |\n-          docker buildx imagetools inspect ${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }}\n-          docker buildx imagetools inspect ${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\n+          tags: ${{ steps.compute_tags.outputs.tags }}\n---\n\n\n---\n\nChoice B:\nk8s/test/minio.yaml\n@@ -16,7 +16,9 @@ spec:\n     spec:\n       volumes:\n         - name: minio\n-          emptyDir: {}\n+          emptyDir:\n+            medium: Memory\n+            sizeLimit: 2Gi\n       containers:\n         - name: minio\n           image: minio/minio:latest\n@@ -46,7 +48,7 @@ metadata:\n spec:\n   ports:\n     - name: http\n-    # Put the lb on a different port so we can run minio locally since the port is already in use\n+      # Put the lb on a different port so we can run minio locally since the port is already in use\n       port: 9001\n       targetPort: 9000\n   selector:\n---\nrust/garbage_collector/src/operators/delete_unused_files.rs\n@@ -147,27 +147,30 @@ impl Operator<DeleteUnusedFilesInput, DeleteUnusedFilesOutput> for DeleteUnusedF\n             CleanupMode::Delete | CleanupMode::DeleteV2 => {\n                 // Hard delete - remove the file\n                 if !all_files.is_empty() {\n-                    let mut delete_stream = futures::stream::iter(all_files.clone())\n-                        .map(move |file_path| self.delete_with_path(file_path))\n-                        .buffer_unordered(100);\n-\n-                    // Process any errors that occurred\n-                    while let Some(result) = delete_stream.next().await {\n-                        if let Err(e) = result {\n-                            match e {\n-                                StorageError::NotFound { path, source } => {\n-                                    tracing::info!(\"Rename file {path} not found: {source}\")\n-                                }\n-                                err => tracing::error!(\"Failed to delete: {err}\"),\n-                            }\n-                        }\n-                    }\n+                    // let mut delete_stream = futures::stream::iter(all_files.clone())\n+                    //     .map(move |file_path| self.delete_with_path(file_path))\n+                    //     .buffer_unordered(100);\n+\n+                    // // Process any errors that occurred\n+                    // while let Some(result) = delete_stream.next().await {\n+                    //     if let Err(e) = result {\n+                    //         match e {\n+                    //             StorageError::NotFound { path, source } => {\n+                    //                 tracing::info!(\"Rename file {path} not found: {source}\")\n+                    //             }\n+                    //             err => tracing::error!(\"Failed to delete: {err}\"),\n+                    //         }\n+                    //     }\n+                    // }\n+\n+                    self.storage.delete_many(all_files).await.unwrap();\n                 }\n             }\n         }\n \n         Ok(DeleteUnusedFilesOutput {\n-            deleted_files: all_files.into_iter().collect(),\n+            // deleted_files: all_files.into_iter().collect(),\n+            deleted_files: HashSet::new(),\n         })\n     }\n }\n---\nrust/storage/src/lib.rs\n@@ -302,6 +302,15 @@ impl Storage {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        match self {\n+            Storage::ObjectStore(object_store) => object_store.delete_many(keys).await,\n+            Storage::S3(s3) => s3.delete_many(keys).await,\n+            Storage::Local(_) => unimplemented!(),\n+            Storage::AdmissionControlledS3(_) => unimplemented!(),\n+        }\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         match self {\n             Storage::ObjectStore(object_store) => object_store.rename(src_key, dst_key).await,\n---\nrust/storage/src/object_store.rs\n@@ -284,6 +284,30 @@ impl ObjectStore {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        let mut locations = Vec::new();\n+        for key in keys {\n+            locations.push(Ok(Path::from(key)));\n+        }\n+\n+        let mut stream = self\n+            .object_store\n+            .delete_stream(futures::stream::iter(locations).boxed());\n+\n+        while let Some(result) = stream.next().await {\n+            match result {\n+                Ok(_) => {\n+                    tracing::info!(\"Successfully deleted object\");\n+                }\n+                Err(e) => {\n+                    tracing::error!(error = %e, \"Failed to delete object\");\n+                    return Err(e.into());\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         tracing::info!(src = %src_key, dst = %dst_key, \"Renaming object\");\n \n---\nrust/storage/src/s3.rs\n@@ -647,6 +647,49 @@ impl S3Storage {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        tracing::debug!(keys = ?keys, \"Deleting multiple objects from S3\");\n+\n+        // batch by 1000 keys as per S3 limits\n+        let mut futures = Vec::new();\n+        for chunk in keys.chunks(1000) {\n+            let delete_req = self.client.delete_objects().bucket(&self.bucket).delete(\n+                aws_sdk_s3::types::Delete::builder()\n+                    .set_objects(Some(\n+                        chunk\n+                            .iter()\n+                            .map(|key| {\n+                                aws_sdk_s3::types::ObjectIdentifier::builder()\n+                                    .key(key)\n+                                    .build()\n+                                    .unwrap()\n+                            })\n+                            .collect::<Vec<_>>(),\n+                    ))\n+                    .build()\n+                    .unwrap(),\n+            );\n+\n+            futures.push(delete_req.send());\n+        }\n+        let results = futures::future::join_all(futures).await;\n+        for res in results {\n+            match res {\n+                Ok(_) => {\n+                    tracing::debug!(\"Successfully deleted objects from S3\");\n+                }\n+                Err(e) => {\n+                    tracing::error!(error = %e, \"Failed to delete objects from S3\");\n+                    return Err(StorageError::Generic {\n+                        source: Arc::new(e.into_service_error()),\n+                    });\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         tracing::info!(src = %src_key, dst = %dst_key, \"Renaming object in S3\");\n \n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\n\n\n---\n\nChoice D:\nrust/log/src/grpc_log.rs\n@@ -554,6 +554,7 @@ impl GrpcLog {\n         min_compaction_size: u64,\n     ) -> Result<Vec<CollectionInfo>, GrpcGetCollectionsWithNewDataError> {\n         let mut combined_response = Vec::new();\n+        let mut error = None;\n \n         if use_alt_log {\n             // Iterate over all alt clients and gather collections\n@@ -567,14 +568,25 @@ impl GrpcLog {\n                 }\n                 for mut alt_client in all_alt_clients.drain(..) {\n                     // We error if any subrequest errors\n-                    let response = alt_client\n+                    match alt_client\n                         .get_all_collection_info_to_compact(\n                             chroma_proto::GetAllCollectionInfoToCompactRequest {\n                                 min_compaction_size,\n                             },\n                         )\n-                        .await?;\n-                    combined_response.push(response.into_inner());\n+                        .await\n+                    {\n+                        Ok(response) => {\n+                            combined_response.push(response.into_inner());\n+                        }\n+                        Err(err) => {\n+                            tracing::error!(\"could not get all collection info to compact: {err}\");\n+                            if error.is_none() {\n+                                error = Some(err);\n+                            }\n+                            continue;\n+                        }\n+                    };\n                 }\n             } else {\n                 tracing::warn!(\n@@ -583,17 +595,33 @@ impl GrpcLog {\n                 return Ok(vec![]);\n             }\n         } else {\n-            let response = self\n+            match self\n                 .client\n                 .get_all_collection_info_to_compact(\n                     chroma_proto::GetAllCollectionInfoToCompactRequest {\n                         min_compaction_size,\n                     },\n                 )\n-                .await?;\n-            combined_response.push(response.into_inner());\n+                .await\n+            {\n+                Ok(response) => {\n+                    combined_response.push(response.into_inner());\n+                }\n+                Err(err) => {\n+                    tracing::error!(\"could not get all collection info to compact: {err}\");\n+                    if error.is_none() {\n+                        error = Some(err);\n+                    }\n+                }\n+            };\n         };\n \n+        if let Some(status) = error {\n+            if combined_response.is_empty() {\n+                return Err(status.into());\n+            }\n+        }\n+\n         let mut all_collections = Vec::new();\n         for response in combined_response {\n             let collections = response.all_collection_info;\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nCloses https://github.com/chroma-core/chroma/issues/4263.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\n\n---\n\nChoice A:\nchromadb/test/utils/cross_version.py\n@@ -5,7 +5,11 @@\n from types import ModuleType\n from typing import Dict, List\n \n-base_install_dir = tempfile.gettempdir() + \"/persistence_test_chromadb_versions\"\n+base_install_dir = (\n+    tempfile.gettempdir()\n+    + f\"/worker-{os.environ.get('PYTEST_XDIST_WORKER', 'unknown')}\"\n+    + \"/persistence_test_chromadb_versions\"\n+)\n \n \n def get_path_to_version_install(version: str) -> str:\n@@ -48,6 +52,8 @@ def install_version(version: str, dep_overrides: Dict[str, str]) -> None:\n \n \n def install(pkg: str, path: str, dep_overrides: Dict[str, str]) -> int:\n+    os.makedirs(path, exist_ok=True)\n+\n     # -q -q to suppress pip output to ERROR level\n     # https://pip.pypa.io/en/stable/cli/pip/#quiet\n     command = [sys.executable, \"-m\", \"pip\", \"-q\", \"-q\", \"install\", pkg]\n---\n\n\n---\n\nChoice B:\nrust/index/src/fulltext/types.rs\n@@ -313,7 +313,7 @@ impl<'me> FullTextIndexReader<'me> {\n         }\n \n         // Retrieve posting lists for each token.\n-        let posting_lists = futures::stream::iter(tokens)\n+        let posting_lists = futures::stream::iter(&tokens)\n             .then(|token| async move {\n                 let positional_posting_list = self\n                     .posting_lists_blockfile_reader\n@@ -355,39 +355,37 @@ impl<'me> FullTextIndexReader<'me> {\n \n             if min_doc_id == max_doc_id {\n                 // All tokens appear in the same document, so check positional alignment.\n-                let mut positions_per_posting_list = Vec::with_capacity(num_tokens);\n-                for (i, posting_list) in posting_lists.iter().enumerate() {\n-                    let (_, _, positions) = posting_list[pointers[i]];\n-                    positions_per_posting_list.push(positions);\n-                }\n-\n-                // Adjust positions and check for sequential alignment.\n                 // Imagine you're searching for \"brown fox\" over the document \"the quick brown fox\".\n                 // The positions for \"brown\" are {2} and for \"fox\" are {3}. The adjusted positions after subtracting the token's position in the query are {2} for \"brown\" and 3 - 1 = {2} for \"fox\".\n                 // The intersection of these two sets is non-empty, so we know that the two tokens are adjacent.\n+                // In practice, we must adjust the positions by using the byte offset of the token rather than the token's position in the query, because Unicode characters can be variable-length and the posting lists are stored as byte offsets.\n+                // E.x. imagine we're using a 1-gram tokenizer and processing the string \"\u00e9m\". The token positions are {0, 1}, but the byte offsets are {0, 2} (because \u00e9 is two bytes long).\n \n                 // Seed with the positions of the first token.\n-                let mut adjusted_positions = positions_per_posting_list[0]\n+                let mut adjusted = posting_lists[0][pointers[0]]\n+                    .2\n                     .iter()\n                     .copied()\n                     .collect::<HashSet<_>>();\n \n-                for (offset, positions_set) in positions_per_posting_list.iter().enumerate().skip(1)\n-                {\n-                    let positions_set = positions_set\n+                for i in 1..num_tokens {\n+                    let byte_delta_from_first_token =\n+                        tokens[i].offset_from as u32 - tokens[0].offset_from as u32;\n+                    let positions = &posting_lists[i][pointers[i]].2;\n+\n+                    let shifted = positions\n                         .iter()\n-                        // (We can discard any positions that the token appears at before the current offset)\n-                        .filter_map(|&p| p.checked_sub(offset as u32))\n+                        .filter_map(|&p| p.checked_sub(byte_delta_from_first_token))\n                         .collect::<HashSet<_>>();\n-                    adjusted_positions = &adjusted_positions & &positions_set;\n \n-                    if adjusted_positions.is_empty() {\n+                    adjusted = &adjusted & &shifted;\n+                    if adjusted.is_empty() {\n                         break;\n                     }\n                 }\n \n                 // All tokens are sequential\n-                if !adjusted_positions.is_empty() {\n+                if !adjusted.is_empty() {\n                     results.insert(min_doc_id);\n                 }\n \n@@ -991,6 +989,47 @@ mod tests {\n         assert_eq!(res, RoaringBitmap::from([1]));\n     }\n \n+    #[tokio::test]\n+    async fn test_document_with_multibyte_characters() {\n+        let tmp_dir = tempdir().unwrap();\n+        let storage = Storage::Local(LocalStorage::new(tmp_dir.path().to_str().unwrap()));\n+        let block_cache = new_cache_for_test();\n+        let root_cache = new_cache_for_test();\n+        let provider = BlockfileProvider::new_arrow(storage, 1024 * 1024, block_cache, root_cache);\n+        let pl_blockfile_writer = provider\n+            .write::<u32, Vec<u32>>(BlockfileWriterOptions::default().ordered_mutations())\n+            .await\n+            .unwrap();\n+        let pl_blockfile_id = pl_blockfile_writer.id();\n+\n+        let tokenizer = NgramTokenizer::new(3, 3, false).unwrap();\n+        let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer.clone());\n+\n+        index_writer\n+            .handle_batch([DocumentMutation::Create {\n+                offset_id: 1,\n+                new_document: \"pret\u00e9rito\",\n+            }])\n+            .unwrap();\n+\n+        index_writer.write_to_blockfiles().await.unwrap();\n+        let flusher = index_writer.commit().await.unwrap();\n+        flusher.flush().await.unwrap();\n+\n+        let pl_blockfile_reader = provider\n+            .read::<u32, &[u32]>(&pl_blockfile_id)\n+            .await\n+            .unwrap();\n+        let tokenizer = NgramTokenizer::new(3, 3, false).unwrap();\n+        let index_reader = FullTextIndexReader::new(pl_blockfile_reader, tokenizer);\n+\n+        let res = index_reader.search(\"pret\u00e9rito\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([1]));\n+\n+        let res = index_reader.search(\"bret\u00e9rito\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([]));\n+    }\n+\n     #[tokio::test]\n     async fn test_update_document() {\n         let tmp_dir = tempdir().unwrap();\n---\n\n\n---\n\nChoice C:\ngo/pkg/log/server/server.go\n@@ -8,7 +8,9 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb\"\n \t\"github.com/chroma-core/chroma/go/pkg/proto/logservicepb\"\n \t\"github.com/chroma-core/chroma/go/pkg/types\"\n+\ttrace_log \"github.com/pingcap/log\"\n \t\"google.golang.org/protobuf/proto\"\n+\t\"go.uber.org/zap\"\n )\n \n type logServer struct {\n@@ -59,6 +61,7 @@ func (s *logServer) ScoutLogs(ctx context.Context, req *logservicepb.ScoutLogsRe\n \tres = &logservicepb.ScoutLogsResponse{\n \t\tFirstUninsertedRecordOffset: int64(limit + 1),\n \t}\n+\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n \treturn\n }\n \n---\n\n\n---\n\nChoice D:\nrust/load/src/lib.rs\n@@ -1271,13 +1271,11 @@ impl LoadService {\n             for declared in declared {\n                 if let Entry::Vacant(entry) = running.entry(declared.uuid) {\n                     tracing::info!(\"spawning workload {}\", declared.uuid);\n-                    let root = tracing::info_span!(parent: None, \"workload\");\n                     let this = Arc::clone(self);\n                     let done = Arc::new(AtomicBool::new(false));\n                     let done_p = Arc::clone(&done);\n                     let inhibit = Arc::clone(&self.inhibit);\n                     let task = tokio::task::spawn(async move {\n-                        let _enter = root.enter();\n                         this.run_one_workload(done, inhibit, declared).await\n                     });\n                     entry.insert((done_p, task));\n@@ -1295,36 +1293,6 @@ impl LoadService {\n         let client = Arc::new(client(spec.connection.clone()).await);\n         let mut guac = Guacamole::new(spec.expires.timestamp_millis() as u64);\n         let mut next_op = Instant::now();\n-        let (tx, mut rx) = tokio::sync::mpsc::channel(1000);\n-        let _ = tx\n-            .send(tokio::spawn(async move { Ok::<(), Error>(()) }))\n-            .await;\n-        let this = Arc::clone(&self);\n-        let data_set = Arc::clone(&spec.data_set);\n-        let reaper = tokio::spawn(async move {\n-            while let Some(task) = rx.recv().await {\n-                if let Err(err) = task.await.unwrap() {\n-                    if !format!(\"{err:?}\").contains(\"429\") {\n-                        this.metrics.failed.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                        tracing::error!(\"workload task failed: {err:?}\");\n-                    } else {\n-                        this.metrics.limited.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                    }\n-                }\n-            }\n-        });\n \n         // Initialize the data set.\n         let data_set = Arc::clone(&spec.data_set);\n@@ -1408,30 +1376,44 @@ impl LoadService {\n                         .await\n                         .map_err(|err| Error::FailWorkload(err.to_string()))\n                     {\n-                        Ok(()) => Ok(()),\n+                        Ok(()) => (),\n                         Err(err) => {\n-                            if err.to_string().contains(\"invalid request: No results\") {\n+                            if format!(\"{err:?}\").contains(\"invalid request: No results\") {\n                                 this.metrics.no_results.add(\n                                     1,\n                                     &[KeyValue::new(\n                                         Key::from_static_str(\"data_set\"),\n                                         Value::from(data_set.name()),\n                                     )],\n                                 );\n-                                Ok(())\n+                                tracing::warn!(\"workload step no results: {err:?}\");\n+                            } else if !format!(\"{err:?}\").contains(\"429\") {\n+                                this.metrics.failed.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::error!(\"workload step failed: {err:?}\");\n                             } else {\n-                                Err(err)\n+                                this.metrics.limited.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::warn!(\"workload step rate limited: {err:?}\");\n                             }\n                         }\n-                    }\n+                    };\n                 };\n-                tx.send(tokio::spawn(fut)).await.unwrap();\n+                let span = tracing::info_span!(parent: None, \"step\", workload_uuid = %spec.uuid);\n+                tokio::spawn(fut.instrument(span));\n             }\n         }\n-        // Not an error, just needs to show up in stdout.\n-        tracing::error!(\"workload done: {}/{}\", spec.name, spec.description());\n-        drop(tx);\n-        reaper.await.unwrap();\n+        tracing::info!(\"workload done: {}/{}\", spec.name, spec.description());\n     }\n \n     fn load_persistent(&self) -> Result<(), Error> {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThis test will add records in batches of 100 without stopping, going up\r\nto 2M records before it decides it cannot blow the 100k limit.  If a\r\nbackpressure message is not thrown it fails the test.\r\n\r\n## Test plan\r\n\r\nAdded a test that passes locally.\r\n\r\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\nN/A\r\n\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -22,6 +22,7 @@ use chroma_types::chroma_proto::{\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n use figment::providers::{Env, Format, Yaml};\n+use opentelemetry::metrics::Meter;\n use parquet::arrow::arrow_reader::ParquetRecordBatchReaderBuilder;\n use prost::Message;\n use serde::{Deserialize, Serialize};\n@@ -48,6 +49,22 @@ const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n static STABLE_PREFIX: CursorName = unsafe { CursorName::from_string_unchecked(\"stable_prefix\") };\n static COMPACTION: CursorName = unsafe { CursorName::from_string_unchecked(\"compaction\") };\n \n+////////////////////////////////////////////// Metrics /////////////////////////////////////////////\n+\n+pub struct Metrics {\n+    log_total_uncompacted_records_count: opentelemetry::metrics::Gauge<f64>,\n+}\n+\n+impl Metrics {\n+    pub fn new(meter: Meter) -> Self {\n+        Self {\n+            log_total_uncompacted_records_count: meter\n+                .f64_gauge(\"log_total_uncompacted_records_count\")\n+                .build(),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////// state maintenance ////////////////////////////////////////\n \n // NOTE(rescrv):  This code dynamically opens and closes logs.  An opened log will stay open until\n@@ -334,6 +351,7 @@ impl DirtyMarker {\n \n     /// Given a contiguous prefix of markers, process the log into a rollup.  That is, a set of\n     /// markers to reinsert, a set of collections to compact, and an advance_to log position.\n+    #[allow(clippy::too_many_arguments)]\n     pub async fn rollup<\n         F1: Future<Output = Result<Option<Manifest>, wal3::Error>>,\n         F2: Future<Output = Result<Option<Witness>, wal3::Error>>,\n@@ -345,6 +363,7 @@ impl DirtyMarker {\n         record_count_threshold: u64,\n         reinsert_threshold: u64,\n         timeout_us: u64,\n+        metrics: &Metrics,\n     ) -> Result<Option<Rollup>, wal3::Error> {\n         // NOTE(rescrv);  This is complicated code because it's a hard problem to do efficiently.\n         // To cut complexity, I've chosen to do it in a way that is not the most efficient but is\n@@ -434,6 +453,7 @@ impl DirtyMarker {\n             .into_iter()\n             .flat_map(Result::ok)\n             .collect::<HashMap<_, _>>();\n+        let mut uncompacted = 0u64;\n         let compactable = compactable\n             .into_iter()\n             .filter_map(|collection_id| {\n@@ -473,6 +493,7 @@ impl DirtyMarker {\n                             cursor.position,\n                             manifest.maximum_log_position(),\n                         );\n+                        uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_threshold {\n                             Some(CollectionInfo {\n                                 collection_id: collection_id.to_string(),\n@@ -514,6 +535,9 @@ impl DirtyMarker {\n                 }\n             }\n         }\n+        metrics\n+            .log_total_uncompacted_records_count\n+            .record(uncompacted as f64, &[]);\n         Ok(Some(Rollup {\n             advance_to,\n             reinsert,\n@@ -608,6 +632,7 @@ pub struct LogServer {\n     dirty_log: Arc<LogWriter>,\n     compacting: tokio::sync::Mutex<()>,\n     cache: Option<Box<dyn chroma_cache::PersistentCache<String, CachedParquetFragment>>>,\n+    metrics: Metrics,\n }\n \n #[async_trait::async_trait]\n@@ -977,6 +1002,7 @@ impl LogService for LogServer {\n             ),\n             self.config.reinsert_threshold,\n             self.config.timeout_us,\n+            &self.metrics,\n         )\n         .await\n         .map_err(|err| Status::unavailable(err.to_string()))?;\n@@ -1456,13 +1482,15 @@ impl Configurable<LogServerConfig> for LogServer {\n         .map_err(|err| -> Box<dyn ChromaError> { Box::new(err) as _ })?;\n         let dirty_log = Arc::new(dirty_log);\n         let compacting = tokio::sync::Mutex::new(());\n+        let metrics = Metrics::new(opentelemetry::global::meter(\"chroma\"));\n         Ok(Self {\n             config: config.clone(),\n             open_logs: Arc::new(StateHashTable::default()),\n             storage,\n             dirty_log,\n             compacting,\n             cache,\n+            metrics,\n         })\n     }\n }\n@@ -1565,6 +1593,7 @@ mod tests {\n             1,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1626,6 +1655,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1709,6 +1739,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1822,6 +1853,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n---\n\n\n---\n\nChoice B:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -374,7 +374,7 @@ func (tc *Catalog) createCollectionImpl(txCtx context.Context, createCollection\n \t\treturn nil, false, common.ErrConcurrentDeleteCollection\n \t}\n \tresult := convertCollectionToModel(collectionList)[0]\n-\treturn result, true, nil\n+\treturn result, created, nil\n }\n \n func (tc *Catalog) CreateCollection(ctx context.Context, createCollection *model.CreateCollection, ts types.Timestamp) (*model.Collection, bool, error) {\n@@ -1251,7 +1251,6 @@ func (tc *Catalog) CreateCollectionAndSegments(ctx context.Context, createCollec\n \t\t}\n \n \t\t// If collection already exists, then do not create segments.\n-\t\t// TODO: Should we check to see if segments does not exist? and create them?\n \t\tif !created {\n \t\t\treturn nil\n \t\t}\n---\n\n\n---\n\nChoice C:\n.github/workflows/_python-tests.yml\n@@ -138,6 +138,7 @@ jobs:\n                     \"chromadb/test/property/test_collections_with_database_tenant.py\",\n                     \"chromadb/test/property/test_collections_with_database_tenant_overwrite.py\",\n                     \"chromadb/test/distributed/test_sanity.py\",\n+                    \"chromadb/test/distributed/test_log_backpressure.py\",\n                     \"chromadb/test/distributed/test_log_failover.py\"]\n     runs-on: ${{ matrix.platform }}\n     # OIDC token auth for AWS\n---\nchromadb/test/distributed/test_log_backpressure.py\n@@ -0,0 +1,53 @@\n+# Add up to 200k records until the log-is-full message is seen.\n+\n+import grpc\n+import math\n+import random\n+import time\n+\n+import numpy as np\n+\n+from chromadb.api import ClientAPI\n+from chromadb.proto.logservice_pb2 import SealLogRequest, MigrateLogRequest\n+from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+from chromadb.test.conftest import (\n+    reset,\n+    skip_if_not_cluster,\n+)\n+from chromadb.test.property import invariants\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n+\n+RECORDS = 2000000\n+BATCH_SIZE = 100\n+\n+@skip_if_not_cluster()\n+def test_log_backpressure(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('backpressuring for', collection.id)\n+\n+    excepted = False\n+    try:\n+        # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+        for i in range(0, RECORDS, BATCH_SIZE):\n+            ids = []\n+            embeddings = []\n+            ids.extend([str(x) for x in range(i, i + BATCH_SIZE)])\n+            embeddings.extend([np.random.rand(1, 3)[0] for x in range(i, i + BATCH_SIZE)])\n+            collection.add(ids=ids, embeddings=embeddings)\n+    except Exception as x:\n+        print(f\"Caught exception:\\n{x}\")\n+        if 'log needs compaction' in str(x):\n+            excepted = True\n+    assert excepted, \"Expected an exception to be thrown.\"\n---\nrust/worker/tilt_config.yaml\n@@ -169,6 +169,7 @@ compaction_service:\n             policy: \"full_rebuild\"\n \n log_service:\n+    num_records_before_backpressure: 100000\n     opentelemetry:\n         service_name: \"rust-log-service\"\n         endpoint: \"http://otel-collector:4317\"\n---\n\n\n---\n\nChoice D:\ngo/pkg/log/server/server.go\n@@ -152,6 +152,12 @@ func (s *logServer) PurgeDirtyForCollection(ctx context.Context, req *logservice\n \treturn\n }\n \n+func (s *logServer) InspectDirtyLog(ctx context.Context, req *logservicepb.InspectDirtyLogRequest) (res *logservicepb.InspectDirtyLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n+\n+\n func NewLogServer(lr *repository.LogRepository) logservicepb.LogServiceServer {\n \treturn &logServer{\n \t\tlr: lr,\n---\nidl/chromadb/proto/logservice.proto\n@@ -87,6 +87,14 @@ message PurgeDirtyForCollectionResponse {\n   // Empty\n }\n \n+message InspectDirtyLogRequest {\n+  // Empty\n+}\n+\n+message InspectDirtyLogResponse {\n+  repeated string markers = 1;\n+}\n+\n service LogService {\n   rpc PushLogs(PushLogsRequest) returns (PushLogsResponse) {}\n   rpc ScoutLogs(ScoutLogsRequest) returns (ScoutLogsResponse) {}\n@@ -95,4 +103,5 @@ service LogService {\n   rpc GetAllCollectionInfoToCompact(GetAllCollectionInfoToCompactRequest) returns (GetAllCollectionInfoToCompactResponse) {}\n   rpc UpdateCollectionLogOffset(UpdateCollectionLogOffsetRequest) returns (UpdateCollectionLogOffsetResponse) {}\n   rpc PurgeDirtyForCollection(PurgeDirtyForCollectionRequest) returns (PurgeDirtyForCollectionResponse) {}\n+  rpc InspectDirtyLog(InspectDirtyLogRequest) returns (InspectDirtyLogResponse) {}\n }\n---\nrust/log-service/src/bin/chroma-inspect-dirty-log.rs\n@@ -0,0 +1,27 @@\n+use tonic::transport::Channel;\n+\n+use chroma_types::chroma_proto::log_service_client::LogServiceClient;\n+use chroma_types::chroma_proto::InspectDirtyLogRequest;\n+\n+#[tokio::main]\n+async fn main() {\n+    let args = std::env::args().skip(1).collect::<Vec<_>>();\n+    if args.len() != 1 {\n+        eprintln!(\"USAGE: chroma-inspect-dirty-log [HOST]\");\n+        std::process::exit(13);\n+    }\n+    let logservice = Channel::from_shared(args[0].clone())\n+        .expect(\"could not create channel\")\n+        .connect()\n+        .await\n+        .expect(\"could not connect to log service\");\n+    let mut client = LogServiceClient::new(logservice);\n+    let dirty = client\n+        .inspect_dirty_log(InspectDirtyLogRequest {})\n+        .await\n+        .expect(\"could not inspect dirty log\");\n+    let dirty = dirty.into_inner();\n+    for line in dirty.markers {\n+        println!(\"{line}\");\n+    }\n+}\n---\nrust/log-service/src/lib.rs\n@@ -13,10 +13,10 @@ use chroma_storage::config::StorageConfig;\n use chroma_storage::Storage;\n use chroma_types::chroma_proto::{\n     log_service_server::LogService, CollectionInfo, GetAllCollectionInfoToCompactRequest,\n-    GetAllCollectionInfoToCompactResponse, LogRecord, OperationRecord, PullLogsRequest,\n-    PullLogsResponse, PurgeDirtyForCollectionRequest, PurgeDirtyForCollectionResponse,\n-    PushLogsRequest, PushLogsResponse, ScoutLogsRequest, ScoutLogsResponse,\n-    UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n+    GetAllCollectionInfoToCompactResponse, InspectDirtyLogRequest, InspectDirtyLogResponse,\n+    LogRecord, OperationRecord, PullLogsRequest, PullLogsResponse, PurgeDirtyForCollectionRequest,\n+    PurgeDirtyForCollectionResponse, PushLogsRequest, PushLogsResponse, ScoutLogsRequest,\n+    ScoutLogsResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n };\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n@@ -1080,6 +1080,65 @@ impl LogService for LogServer {\n             .map_err(|err| Status::new(err.code().into(), err.to_string()))?;\n         Ok(Response::new(PurgeDirtyForCollectionResponse {}))\n     }\n+\n+    #[tracing::instrument(skip(self, _request))]\n+    async fn inspect_dirty_log(\n+        &self,\n+        _request: Request<InspectDirtyLogRequest>,\n+    ) -> Result<Response<InspectDirtyLogResponse>, Status> {\n+        let Some(reader) = self.dirty_log.reader(LogReaderOptions::default()) else {\n+            return Err(Status::unavailable(\"Failed to get dirty log reader\"));\n+        };\n+        let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n+            return Err(Status::unavailable(\"Failed to get dirty log cursors\"));\n+        };\n+        let witness = match cursors.load(&STABLE_PREFIX).await {\n+            Ok(witness) => witness,\n+            Err(err) => {\n+                return Err(Status::new(err.code().into(), err.to_string()));\n+            }\n+        };\n+        let default = Cursor::default();\n+        let cursor = witness.as_ref().map(|w| w.cursor()).unwrap_or(&default);\n+        tracing::info!(\"cursoring from {cursor:?}\");\n+        let dirty_fragments = reader\n+            .scan(\n+                cursor.position,\n+                Limits {\n+                    max_files: Some(1_000_000),\n+                    max_bytes: Some(1_000_000_000),\n+                },\n+            )\n+            .await\n+            .map_err(|err| Status::new(err.code().into(), err.to_string()))?;\n+        let dirty_futures = dirty_fragments\n+            .iter()\n+            .map(|fragment| reader.read_parquet(fragment))\n+            .collect::<Vec<_>>();\n+        let dirty_raw = futures::future::try_join_all(dirty_futures)\n+            .await\n+            .map_err(|err| {\n+                Status::new(\n+                    err.code().into(),\n+                    format!(\"Failed to fetch dirty parquet: {}\", err),\n+                )\n+            })?;\n+        let mut markers = vec![];\n+        for (_, records, _) in dirty_raw {\n+            let records = records\n+                .into_iter()\n+                .map(|x| String::from_utf8(x.1))\n+                .collect::<Result<Vec<_>, _>>()\n+                .map_err(|err| {\n+                    Status::new(\n+                        chroma_error::ErrorCodes::DataLoss.into(),\n+                        format!(\"Failed to extract records: {}\", err),\n+                    )\n+                })?;\n+            markers.extend(records);\n+        }\n+        Ok(Response::new(InspectDirtyLogResponse { markers }))\n+    }\n }\n \n fn parquet_to_records(parquet: Arc<Vec<u8>>) -> Result<Vec<(LogPosition, Vec<u8>)>, Status> {\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nIf the collection is sealed, and it gets forked, the new collection\nshould be sealed too; otherwise we leak wal3 tenants back to the\ngo-based log.\n\n## Test plan\n\nI'm sending it to ci.  test_fork.py fails locally, but it seems to be\nfailing by trying to fork a collection that doesn't exist, which makes\nno sense.  Sharing to debug.\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1555,6 +1555,10 @@ func (tc *Catalog) FlushCollectionCompactionForVersionedCollection(ctx context.C\n \t\t\t\treturn nil, err\n \t\t\t}\n \n+\t\t\t// There was previously a bug that resulted in the tenant ID missing from some version files (https://github.com/chroma-core/chroma/pull/4408).\n+\t\t\t// This line can be removed once all corrupted version files are fixed.\n+\t\t\texistingVersionFilePb.CollectionInfoImmutable.TenantId = collectionEntry.Tenant\n+\n \t\t\t// Do a simple validation of the version file.\n \t\t\terr = tc.validateVersionFile(existingVersionFilePb, collectionEntry.ID, existingVersion)\n \t\t\tif err != nil {\n---\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionEntry(collectionID *string, databaseName *string) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, databases.tenant_id, collections.version, collections.version_file_name, collections.root_collection_id\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\nChoice B:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -830,12 +836,15 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/quota/mod.rs\n@@ -7,6 +7,7 @@ use std::{\n use chroma_error::ChromaError;\n use chroma_types::{CollectionUuid, Metadata, UpdateMetadata, Where};\n use thiserror::Error;\n+use validator::Validate;\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash)]\n pub enum Action {\n@@ -334,12 +335,14 @@ lazy_static::lazy_static! {\n     };\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Validate)]\n pub struct QuotaExceededError {\n     pub usage_type: UsageType,\n     pub action: Action,\n     pub usage: usize,\n     pub limit: usize,\n+    #[validate(length(min = 1))]\n+    pub message: Option<String>,\n }\n \n impl fmt::Display for QuotaExceededError {\n@@ -348,7 +351,11 @@ impl fmt::Display for QuotaExceededError {\n             f,\n             \"'{}' exceeded quota limit for action '{}': current usage of {} exceeds limit of {}\",\n             self.usage_type, self.action, self.usage, self.limit\n-        )\n+        )?;\n+        if let Some(msg) = self.message.as_ref() {\n+            write!(f, \". {}\", msg)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -393,3 +400,63 @@ impl QuotaEnforcer for () {\n         Box::pin(ready(Ok(())))\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{Action, QuotaExceededError, UsageType};\n+    use validator::Validate;\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_none() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: None,\n+        };\n+        assert!(error.validate().is_ok());\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_empty() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: Some(\"\".to_string()),\n+        };\n+        assert!(error.validate().is_err());\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_valid() {\n+        let custom_message = \"This is a valid message.\";\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: Some(custom_message.to_string()),\n+        };\n+        assert!(error.validate().is_ok());\n+        let error_string = format!(\"{}\", error);\n+        let expected_error_string = \"'Number of records' exceeded quota limit for action 'Add': current usage of 100 exceeds limit of 50. This is a valid message.\";\n+        assert_eq!(error_string, expected_error_string);\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_display_no_message() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: None,\n+        };\n+        assert!(error.validate().is_ok());\n+        let error_string = format!(\"{}\", error);\n+        assert_eq!(error_string, \"'Number of records' exceeded quota limit for action 'Add': current usage of 100 exceeds limit of 50\");\n+    }\n+}\n---\n\n\n---\n\nChoice D:\ngo/pkg/log/repository/log.go\n@@ -168,6 +168,13 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\t}\n \t}()\n \n+\t// NOTE(rescrv):  Only sourceInfo.IsSealed should be used on this struct.\n+\tvar sourceInfo log.Collection\n+\tsourceInfo, err = queriesWithTx.GetCollection(ctx, sourceCollectionID)\n+\tif err != nil {\n+\t\tsourceInfo.IsSealed = false\n+\t}\n+\n \tvar sourceBounds log.GetBoundsForCollectionRow\n \tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n@@ -207,6 +214,7 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\tID:                              targetCollectionID,\n \t\tRecordCompactionOffsetPosition:  int64(compactionOffset),\n \t\tRecordEnumerationOffsetPosition: int64(enumerationOffset),\n+\t\tIsSealed:                        sourceInfo.IsSealed,\n \t})\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n---\ngo/pkg/log/repository/log_test.go\n@@ -116,17 +116,17 @@ func (suite *LogTestSuite) TestUniqueConstraintPushLogs() {\n func (suite *LogTestSuite) TestSealedLogWontPush() {\n \tctx := context.Background()\n \tcollectionId := types.NewUniqueID()\n-\tparams := log.InsertCollectionParams {\n-\t\tID: collectionId.String(),\n+\tparams := log.InsertCollectionParams{\n+\t\tID:                              collectionId.String(),\n \t\tRecordEnumerationOffsetPosition: 1,\n-\t\tRecordCompactionOffsetPosition: 0,\n+\t\tRecordCompactionOffsetPosition:  0,\n \t}\n \t_, err := suite.lr.queries.InsertCollection(ctx, params)\n \tassert.NoError(suite.t, err, \"Initializing log should not fail.\")\n \t_, err = suite.lr.queries.SealLog(ctx, collectionId.String())\n \tassert.NoError(suite.t, err, \"Sealing log should not fail.\")\n \tvar isSealed bool\n-\t_, isSealed, err = suite.lr.InsertRecords(ctx, collectionId.String(), [][]byte{{1,2,3}})\n+\t_, isSealed, err = suite.lr.InsertRecords(ctx, collectionId.String(), [][]byte{{1, 2, 3}})\n \tassert.NoError(suite.t, err, \"Failed to push logs\")\n \tassert.True(suite.t, isSealed, \"Did not report was sealed\")\n }\n---\ngo/pkg/log/store/db/queries.sql.go\n@@ -138,6 +138,24 @@ func (q *Queries) GetBoundsForCollection(ctx context.Context, id string) (GetBou\n \treturn i, err\n }\n \n+const getCollection = `-- name: GetCollection :one\n+SELECT id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+FROM collection\n+WHERE id = $1\n+`\n+\n+func (q *Queries) GetCollection(ctx context.Context, id string) (Collection, error) {\n+\trow := q.db.QueryRow(ctx, getCollection, id)\n+\tvar i Collection\n+\terr := row.Scan(\n+\t\t&i.ID,\n+\t\t&i.RecordCompactionOffsetPosition,\n+\t\t&i.RecordEnumerationOffsetPosition,\n+\t\t&i.IsSealed,\n+\t)\n+\treturn i, err\n+}\n+\n const getCollectionForUpdate = `-- name: GetCollectionForUpdate :one\n SELECT id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n FROM collection\n@@ -239,17 +257,23 @@ func (q *Queries) GetTotalUncompactedRecordsCount(ctx context.Context) (int64, e\n }\n \n const insertCollection = `-- name: InsertCollection :one\n-INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position, is_sealed) values($1, $2, $3, $4) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n `\n \n type InsertCollectionParams struct {\n \tID                              string\n \tRecordEnumerationOffsetPosition int64\n \tRecordCompactionOffsetPosition  int64\n+\tIsSealed                        bool\n }\n \n func (q *Queries) InsertCollection(ctx context.Context, arg InsertCollectionParams) (Collection, error) {\n-\trow := q.db.QueryRow(ctx, insertCollection, arg.ID, arg.RecordEnumerationOffsetPosition, arg.RecordCompactionOffsetPosition)\n+\trow := q.db.QueryRow(ctx, insertCollection,\n+\t\targ.ID,\n+\t\targ.RecordEnumerationOffsetPosition,\n+\t\targ.RecordCompactionOffsetPosition,\n+\t\targ.IsSealed,\n+\t)\n \tvar i Collection\n \terr := row.Scan(\n \t\t&i.ID,\n---\ngo/pkg/log/store/queries/queries.sql\n@@ -4,6 +4,11 @@ FROM collection\n WHERE id = $1\n FOR UPDATE;\n \n+-- name: GetCollection :one\n+SELECT *\n+FROM collection\n+WHERE id = $1;\n+\n -- name: InsertRecord :copyfrom\n INSERT INTO record_log (collection_id, \"offset\", record, timestamp) values($1, $2, $3, $4);\n \n@@ -30,7 +35,7 @@ UPDATE collection set record_compaction_offset_position = $2 where id = $1;\n UPDATE collection set record_enumeration_offset_position = $2 where id = $1;\n \n -- name: InsertCollection :one\n-INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning *;\n+INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position, is_sealed) values($1, $2, $3, $4) returning *;\n \n -- name: PurgeRecords :exec\n DELETE FROM record_log r using collection c where r.collection_id = c.id and r.offset <= c.record_compaction_offset_position;\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nA load generator different from chroma-load.\n\n## Test plan\n\nNOCOMMIT\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/chroma-tmp/Cargo.toml\n@@ -0,0 +1,33 @@\n+[package]\n+name = \"chroma-tmp\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[dependencies]\n+async-trait = { workspace = true }\n+chrono = { workspace = true }\n+clap = { workspace = true }\n+figment = { workspace = true }\n+rand = { workspace = true }\n+serde = { workspace = true }\n+serde_json = { workspace = true }\n+tokio = { workspace = true }\n+uuid = { workspace = true }\n+axum = { workspace = true }\n+\n+tracing = { workspace = true }\n+tracing-bunyan-formatter = { workspace = true }\n+tracing-opentelemetry = { workspace = true }\n+tracing-subscriber = { workspace = true }\n+opentelemetry = { workspace = true }\n+opentelemetry-otlp = { workspace = true }\n+opentelemetry-http = { workspace = true }\n+opentelemetry_sdk = { workspace = true }\n+\n+# Unlikely to be used in the workspace.\n+chromadb = { git = \"https://github.com/rescrv/chromadb-rs\", rev = \"540c3e225e92ecea05039b73b69adf5875385c0e\" }\n+guacamole = { version = \"0.11\", default-features = false }\n+tower-http = { workspace = true }\n+reqwest = { workspace = true, features = [\"json\"] }\n+siphasher = \"1.0.1\"\n+futures.workspace = true\n---\nrust/chroma-tmp/src/main.rs\n@@ -0,0 +1,138 @@\n+use std::collections::HashMap;\n+use std::sync::atomic::{AtomicU64, Ordering};\n+use std::sync::Arc;\n+\n+use guacamole::combinators::*;\n+use guacamole::Guacamole;\n+\n+use tokio::sync::Semaphore;\n+\n+use chromadb::client::{ChromaAuthMethod, ChromaClientOptions, ChromaTokenHeader};\n+use chromadb::collection::{CollectionEntries, GetOptions};\n+use chromadb::ChromaClient;\n+\n+#[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]\n+pub struct Connection {\n+    pub url: String,\n+    pub api_key: Option<String>,\n+    pub database: String,\n+}\n+\n+pub async fn client(connection: Connection) -> ChromaClient {\n+    let auth = if let Some(api_key) = connection.api_key.clone() {\n+        ChromaAuthMethod::TokenAuth {\n+            token: api_key,\n+            header: ChromaTokenHeader::XChromaToken,\n+        }\n+    } else {\n+        ChromaAuthMethod::None\n+    };\n+    ChromaClient::new(ChromaClientOptions {\n+        url: Some(connection.url.clone()),\n+        auth,\n+        database: connection.database.clone(),\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::main]\n+async fn main() {\n+    let success = Arc::new(AtomicU64::new(0));\n+    let failure = Arc::new(AtomicU64::new(0));\n+    let client = client(Connection {\n+        url: \"https://api.devchroma.com:8000\".to_string(),\n+        api_key: std::env::var(\"CHROMA_API_KEY\").ok(),\n+        database: std::env::var(\"CHROMA_DATABASE\").expect(\"set CHROMA_DATABASE\"),\n+    })\n+    .await;\n+    let mut collections = vec![];\n+    let mut collection_locks: HashMap<String, Arc<tokio::sync::Mutex<()>>> = HashMap::default();\n+    const COLLECTIONS: usize = 1000;\n+    for i in 1..=COLLECTIONS {\n+        let collection = client\n+            .get_or_create_collection(&format!(\"many-collections-{i}\"), None)\n+            .await\n+            .unwrap();\n+        println!(\"loaded {collection:?}\");\n+        collection_locks.insert(\n+            collection.id().to_string(),\n+            Arc::new(tokio::sync::Mutex::new(())),\n+        );\n+        collections.push(collection);\n+    }\n+    const MAGIC_CONSTANT: usize = 2000;\n+    let (tx, mut rx) = tokio::sync::mpsc::channel(MAGIC_CONSTANT);\n+    tokio::task::spawn(async move {\n+        while let Some(x) = rx.recv().await {\n+            let _ = x.await;\n+        }\n+    });\n+    let mut guac = Guacamole::new(0);\n+    let semaphore = Arc::new(Semaphore::new(MAGIC_CONSTANT));\n+    let start = std::time::Instant::now();\n+    let mut i = 0;\n+    while start.elapsed() < std::time::Duration::from_secs(600) {\n+        let collection = collections[i % collections.len()].clone();\n+        i += 1;\n+        let mut ids = vec![];\n+        let mut documents = vec![];\n+        let mut embeddings = vec![];\n+        for i in 0..100 {\n+            ids.push(format!(\"key-{i}\"));\n+            documents.push(\"dummy\");\n+            embeddings.push(vec![\n+                any::<f32>(&mut guac),\n+                any::<f32>(&mut guac),\n+                any::<f32>(&mut guac),\n+            ]);\n+        }\n+        let per_collection = collection_locks\n+            .get(collections[i % collections.len()].id())\n+            .map(Arc::clone)\n+            .unwrap();\n+        let semaphore = Arc::clone(&semaphore);\n+        let success = Arc::clone(&success);\n+        let failure = Arc::clone(&failure);\n+        let handle = tokio::task::spawn(async move {\n+            let _guard = per_collection.lock().await;\n+            let _permit = semaphore.acquire().await;\n+            let mut results = vec![];\n+            for i in 0..4 {\n+                let collection = collection.clone();\n+                let success = Arc::clone(&success);\n+                let failure = Arc::clone(&failure);\n+                let jh = tokio::task::spawn(async move {\n+                    let is_err = collection\n+                        .get(GetOptions {\n+                            ids: vec![format!(\"key-{i}\")],\n+                            where_metadata: None,\n+                            limit: Some(10),\n+                            offset: None,\n+                            where_document: None,\n+                            include: None,\n+                        })\n+                        .await\n+                        .is_err();\n+                    if is_err {\n+                        failure.fetch_add(1, Ordering::Relaxed);\n+                    } else {\n+                        success.fetch_add(1, Ordering::Relaxed);\n+                    }\n+                });\n+                results.push(jh);\n+            }\n+            futures::future::join_all(results).await;\n+            let ids = ids.iter().map(String::as_str).collect::<Vec<_>>();\n+            let entries = CollectionEntries {\n+                ids,\n+                embeddings: Some(embeddings),\n+                metadatas: None,\n+                documents: Some(documents),\n+            };\n+            let _results = collection.upsert(entries, None).await;\n+        });\n+        let _ = tx.send(handle).await;\n+    }\n+    drop(tx);\n+}\n---\n\n\n---\n\nChoice B:\nchromadb/__init__.py\n@@ -1,4 +1,4 @@\n-from typing import Dict, Optional\n+from typing import Dict, Optional, Union\n import logging\n from chromadb.api.client import Client as ClientCreator\n from chromadb.api.client import AdminClient as AdminClientCreator\n@@ -26,6 +26,7 @@\n     WhereDocument,\n     UpdateCollectionMetadata,\n )\n+from pathlib import Path\n \n # Re-export types from chromadb.types\n __all__ = [\n@@ -135,7 +136,7 @@ def EphemeralClient(\n \n \n def PersistentClient(\n-    path: str = \"./chroma\",\n+    path: Union[str, Path] = \"./chroma\",\n     settings: Optional[Settings] = None,\n     tenant: str = DEFAULT_TENANT,\n     database: str = DEFAULT_DATABASE,\n@@ -151,7 +152,7 @@ def PersistentClient(\n     \"\"\"\n     if settings is None:\n         settings = Settings()\n-    settings.persist_directory = path\n+    settings.persist_directory = str(path)\n     settings.is_persistent = True\n \n     # Make sure paramaters are the correct types -- users can pass anything.\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/tower_tracing.rs\n@@ -6,6 +6,7 @@ use opentelemetry::trace::TraceContextExt;\n use std::time::Duration;\n use tower::Service;\n use tower_http::trace::{MakeSpan, OnResponse, TraceLayer};\n+use tracing::Instrument;\n \n use tracing_opentelemetry::OpenTelemetrySpanExt;\n \n@@ -16,8 +17,7 @@ impl<B> MakeSpan<B> for RequestTracing {\n         let http_route = request\n             .extensions()\n             .get::<MatchedPath>()\n-            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str())\n-            .to_owned();\n+            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str());\n \n         let host = request\n             .headers()\n@@ -56,15 +56,18 @@ impl<B> OnResponse<B> for RequestTracing {\n     }\n }\n \n+/// TracingMiddleware adds trace ID to the response headers\n+/// and wraps the inner handler with a span.\n #[derive(Clone)]\n-pub struct TraceIdMiddleware<S> {\n+pub struct TracingMiddleware<S> {\n     inner: S,\n }\n \n-impl<S, Request, Rs> Service<Request> for TraceIdMiddleware<S>\n+impl<S, B, Rs> Service<Request<B>> for TracingMiddleware<S>\n where\n-    S: Service<Request, Response = Response<Rs>> + Send + 'static,\n+    S: Service<Request<B>, Response = Response<Rs>> + Send + 'static,\n     S::Future: Send + 'static,\n+    B: Send + 'static,\n {\n     type Response = S::Response;\n     type Error = S::Error;\n@@ -77,10 +80,23 @@ where\n         self.inner.poll_ready(cx)\n     }\n \n-    fn call(&mut self, req: Request) -> Self::Future {\n+    fn call(&mut self, req: Request<B>) -> Self::Future {\n+        let http_route = req\n+            .extensions()\n+            .get::<MatchedPath>()\n+            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str());\n+\n+        let handler_span = tracing::span!(\n+            tracing::Level::DEBUG,\n+            \"HTTP request handler\",\n+            http.route = http_route,\n+            otel.name = format!(\"Handler {} {}\", req.method(), http_route),\n+        );\n+\n         let future = self.inner.call(req);\n+\n         Box::pin(async move {\n-            let mut response: Response<Rs> = future.await?;\n+            let mut response: Response<Rs> = future.instrument(handler_span).await?;\n             if response.status().is_client_error() || response.status().is_server_error() {\n                 let trace_id = tracing::Span::current()\n                     .context()\n@@ -109,10 +125,10 @@ impl SetTraceIdLayer {\n }\n \n impl<S> tower::layer::Layer<S> for SetTraceIdLayer {\n-    type Service = TraceIdMiddleware<S>;\n+    type Service = TracingMiddleware<S>;\n \n     fn layer(&self, inner: S) -> Self::Service {\n-        TraceIdMiddleware { inner }\n+        TracingMiddleware { inner }\n     }\n }\n \n---\n\n\n---\n\nChoice D:\nchromadb/utils/embedding_functions/instructor_embedding_function.py\n@@ -39,7 +39,7 @@ def __init__(\n         self.device = device\n         self.instruction = instruction\n \n-        self._model = INSTRUCTOR(model_name, device=device)\n+        self._model = INSTRUCTOR(model_name_or_path=model_name, device=device)\n \n     def __call__(self, input: Documents) -> Embeddings:\n         \"\"\"\n@@ -99,10 +99,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\nchromadb/utils/embedding_functions/sentence_transformer_embedding_function.py\n@@ -42,7 +42,7 @@ def __init__(\n \n         if model_name not in self.models:\n             self.models[model_name] = SentenceTransformer(\n-                model_name, device=device, **kwargs\n+                model_name_or_path=model_name, device=device, **kwargs\n             )\n         self._model = self.models[model_name]\n \n@@ -102,10 +102,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\nchromadb/utils/embedding_functions/text2vec_embedding_function.py\n@@ -71,10 +71,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nAdded comment explaining why this is needed.\r\n\n\n---\n\nChoice A:\nrust/segment/src/sqlite_metadata.rs\n@@ -705,28 +705,62 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            filter_limit_query\n-                .left_join(\n+            let (references_metadata, references_document) = whr.analyze_where_references();\n+            if references_metadata {\n+                filter_limit_query.inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n-                )\n-                .left_join(\n+                );\n+            } else if metadata {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            }\n+            if references_document {\n+                filter_limit_query.inner_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n-                )\n-                .distinct()\n-                .cond_where(whr.eval());\n+                );\n+            } else if document {\n+                filter_limit_query.left_join(\n+                    EmbeddingFulltextSearch::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n+                        EmbeddingFulltextSearch::Table,\n+                        EmbeddingFulltextSearch::Rowid,\n+                    )),\n+                );\n+            }\n+            filter_limit_query.distinct().cond_where(whr.eval());\n+        } else {\n+            if metadata {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            }\n+\n+            if document {\n+                filter_limit_query.left_join(\n+                    EmbeddingFulltextSearch::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n+                        EmbeddingFulltextSearch::Table,\n+                        EmbeddingFulltextSearch::Rowid,\n+                    )),\n+                );\n+            }\n         }\n \n         filter_limit_query\n             .order_by((Embeddings::Table, Embeddings::Id), sea_query::Order::Asc)\n             .offset(skip as u64)\n             .limit(fetch.unwrap_or(u32::MAX) as u64);\n-\n         let alias = Alias::new(SUBQ_ALIAS);\n         let mut projection_query = Query::select();\n         projection_query\n---\nrust/types/src/metadata.rs\n@@ -560,6 +560,26 @@ impl Where {\n             },\n         }\n     }\n+\n+    pub fn analyze_where_references(&self) -> (bool, bool) {\n+        let mut references_metadata = false;\n+        let mut references_document = false;\n+\n+        match self {\n+            Where::Composite(expr) => {\n+                // For composite expressions, recursively check all children\n+                for child in &expr.children {\n+                    let (child_meta, child_doc) = Self::analyze_where_references(&(child.clone()));\n+                    references_metadata |= child_meta;\n+                    references_document |= child_doc;\n+                }\n+            }\n+            Where::Document(_) => references_document = true,\n+            Where::Metadata(_) => references_metadata = true,\n+        }\n+\n+        (references_metadata, references_document)\n+    }\n }\n \n impl TryFrom<chroma_proto::Where> for Where {\n---\n\n\n---\n\nChoice B:\n.github/actions/tilt-setup-prebuild/action.yaml\n@@ -17,3 +17,4 @@ runs:\n           \"bash -c 'curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v${TILT_VERSION}/tilt.${TILT_VERSION}.linux.x86_64.tar.gz | tar -xzv -C /usr/local/bin tilt'\" \\\n           \"docker buildx bake -f ${{ github.action_path }}/docker-bake.hcl --load\" \\\n           \"bash ${{ github.action_path }}/pull_external_images.sh\"\n+      working-directory: ${{ github.action_path }}/../../../ # this allows other repos to reuse this workflow when this repo may not be the current working directory\n---\n\n\n---\n\nChoice C:\nrust/js_bindings/Cargo.toml\n@@ -14,7 +14,3 @@ chroma-cli = { workspace = true }\n \n [build-dependencies]\n napi-build = \"2.0.1\"\n-\n-[profile.release]\n-lto = true\n-strip = \"symbols\"\n---\n\n\n---\n\nChoice D:\nclients/js/packages/chromadb/package.json\n@@ -50,6 +50,13 @@\n     \"tsup\": \"^7.2.0\",\n     \"typescript\": \"^5.0.4\"\n   },\n+  \"optionalDependencies\": {\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+  },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n   },\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.0.0\"\n+$release = \"cli-1.1.0\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.0.0\"\n+RELEASE=\"cli-1.1.0\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\nrust/cli/src/client/collection.rs\n@@ -130,13 +130,7 @@ impl Collection {\n             self.chroma_client.tenant_id, self.chroma_client.db, self.collection_id\n         );\n \n-        let payload = AddCollectionRecordsPayload {\n-            ids,\n-            embeddings,\n-            documents,\n-            uris,\n-            metadatas,\n-        };\n+        let payload = AddCollectionRecordsPayload::new(ids, embeddings, documents, uris, metadatas);\n \n         let _response = send_request::<AddCollectionRecordsPayload, AddCollectionRecordsResponse>(\n             &self.chroma_client.host,\n---\nrust/cli/src/commands/copy.rs\n@@ -277,7 +277,7 @@ pub fn copy(args: CopyArgs) -> Result<(), CliError> {\n         if !args.all && args.collections.is_empty() {\n             return Err(CopyError::NoCollections.into());\n         }\n-        \n+\n         let (_, profile) = get_current_profile()?;\n         let (source, target) = get_target_and_destination(&args)?;\n         let (source_client, target_client, _handle) =\n---\nrust/frontend/src/server.rs\n@@ -1252,11 +1252,29 @@ async fn fork_collection(\n \n #[derive(Serialize, Deserialize, ToSchema, Debug, Clone)]\n pub struct AddCollectionRecordsPayload {\n-    pub ids: Vec<String>,\n-    pub embeddings: Option<Vec<Vec<f32>>>,\n-    pub documents: Option<Vec<Option<String>>>,\n-    pub uris: Option<Vec<Option<String>>>,\n-    pub metadatas: Option<Vec<Option<Metadata>>>,\n+    ids: Vec<String>,\n+    embeddings: Option<Vec<Vec<f32>>>,\n+    documents: Option<Vec<Option<String>>>,\n+    uris: Option<Vec<Option<String>>>,\n+    metadatas: Option<Vec<Option<Metadata>>>,\n+}\n+\n+impl AddCollectionRecordsPayload {\n+    pub fn new(\n+        ids: Vec<String>,\n+        embeddings: Option<Vec<Vec<f32>>>,\n+        documents: Option<Vec<Option<String>>>,\n+        uris: Option<Vec<Option<String>>>,\n+        metadatas: Option<Vec<Option<Metadata>>>,\n+    ) -> Self {\n+        Self {\n+            ids,\n+            embeddings,\n+            documents,\n+            uris,\n+            metadatas,\n+        }\n+    }\n }\n \n /// Adds records to a collection.\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis switches our testing from the go service to wal3.  Implications:\n- Tests of the go service should try without this set.\n- All collections in CI will be made on wal3/rust-log-service by\n  default.\n\n## Test plan\n\nCI\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/test/utils/wait_for_version_increase.py\n@@ -23,7 +23,8 @@ def wait_for_version_increase(\n     while curr_version == initial_version:\n         time.sleep(TIMEOUT_INTERVAL)\n         if time.time() - initial_time > timeout:\n-            raise TimeoutError(\"Model was not updated in time\")\n+            collection_id = client.get_collection(collection_name).id\n+            raise TimeoutError(f\"Model was not updated in time for {collection_id}\")\n         curr_version = get_collection_version(client, collection_name)\n \n     return curr_version\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -56,3 +56,5 @@ circuit_breaker:\n   requests: 1000\n enable_span_indexing: true\n default_knn_index: \"spann\"\n+tenants_to_migrate_immediately:\n+- \"default_tenant\"\n---\nrust/log-service/src/lib.rs\n@@ -896,6 +896,14 @@ impl LogServer {\n         self.metrics\n             .dirty_log_records_read\n             .add(dirty_markers.len() as u64, &[]);\n+        let Some((last_record_inserted, _)) = dirty_markers.last() else {\n+            let backpressure = vec![];\n+            self.set_backpressure(&backpressure);\n+            let mut need_to_compact = self.need_to_compact.lock();\n+            let mut rollups = HashMap::new();\n+            std::mem::swap(&mut *need_to_compact, &mut rollups);\n+            return Ok(());\n+        };\n         let mut rollups = DirtyMarker::coalesce_markers(&dirty_markers)?;\n         self.enrich_dirty_log(&mut rollups).await?;\n         let mut markers = vec![];\n@@ -919,7 +927,8 @@ impl LogServer {\n             markers.push(serde_json::to_string(&DirtyMarker::Cleared).map(Vec::from)?);\n         }\n         let mut new_cursor = cursor.clone();\n-        new_cursor.position = self.dirty_log.append_many(markers).await?;\n+        self.dirty_log.append_many(markers).await?;\n+        new_cursor.position = *last_record_inserted + 1u64;\n         let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n             return Err(Error::CouldNotGetDirtyLogCursors);\n         };\n---\n\n\n---\n\nChoice B:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.4\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.0.4\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.4\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.4\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.4\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.1.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.1\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\n\n\n---\n\nChoice C:\nchromadb/test/test_cli.py\n@@ -7,10 +7,10 @@\n \n import chromadb\n from chromadb.api.client import Client\n+from chromadb.api.client import ClientAPI\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,27 +19,59 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+    client: ClientAPI, max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n \n+\n def test_app() -> None:\n     kwargs = {\"path\": \"chroma_test_data\", \"port\": 8001}\n     args = [\"chroma\", \"run\"]\n     args.extend(build_cli_args(**kwargs))\n     print(args)\n     server_process = multiprocessing.Process(target=start_app, args=(args,))\n     server_process.start()\n-    time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    host = kwargs.get(\"host\", \"localhost\")\n+    port = int(kwargs.get(\"port\", 8001))\n \n     client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n+    assert wait_for_server(\n+        client\n+    ), \"Server failed to start within maximum retry attempts\"\n+\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -72,7 +104,13 @@ def add_records(collection: Collection, num: int) -> None:\n         cur.execute(sql, params)\n         assert cur.fetchall() == []\n \n-    sys.argv = [\"chroma\", \"vacuum\", \"--path\", system.settings.persist_directory, \"--force\"]\n+    sys.argv = [\n+        \"chroma\",\n+        \"vacuum\",\n+        \"--path\",\n+        system.settings.persist_directory,\n+        \"--force\",\n+    ]\n     cli.app()\n \n     # Maintenance log should have a vacuum entry\n@@ -124,7 +162,13 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\n+            \"chroma\",\n+            \"vacuum\",\n+            \"--path\",\n+            sqlite_persistent.settings.persist_directory,\n+            \"--force\",\n+        ]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\n\n\n---\n\nChoice D:\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -140,21 +140,20 @@ impl GarbageCollector {\n             .as_ref()\n             .ok_or(GarbageCollectCollectionError::Uninitialized)?;\n \n-        let use_v1_orchestrator = match cleanup_mode {\n-            CleanupMode::DryRun | CleanupMode::Rename | CleanupMode::Delete => true,\n-            CleanupMode::DryRunV2 | CleanupMode::DeleteV2 => false,\n-        };\n-\n-        if use_v1_orchestrator {\n+        if cleanup_mode.is_v2() {\n             let orchestrator =\n-                crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+                crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n                     collection.id,\n                     collection.version_file_path,\n+                    collection.lineage_file_path,\n                     absolute_cutoff_time,\n                     self.sysdb_client.clone(),\n                     dispatcher.clone(),\n+                    system.clone(),\n                     self.storage.clone(),\n+                    self.root_manager.clone(),\n                     cleanup_mode,\n+                    2,\n                 );\n \n             let started_at = SystemTime::now();\n@@ -178,23 +177,19 @@ impl GarbageCollector {\n                     format!(\"{:?}\", cleanup_mode),\n                 )],\n             );\n+\n             return Ok(result);\n         }\n \n-        let orchestrator =\n-            crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n-                collection.id,\n-                collection.version_file_path,\n-                collection.lineage_file_path,\n-                absolute_cutoff_time,\n-                self.sysdb_client.clone(),\n-                dispatcher.clone(),\n-                system.clone(),\n-                self.storage.clone(),\n-                self.root_manager.clone(),\n-                cleanup_mode,\n-                2,\n-            );\n+        let orchestrator = crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+            collection.id,\n+            collection.version_file_path,\n+            absolute_cutoff_time,\n+            self.sysdb_client.clone(),\n+            dispatcher.clone(),\n+            self.storage.clone(),\n+            cleanup_mode,\n+        );\n \n         let started_at = SystemTime::now();\n         let result = orchestrator.run(system.clone()).await?;\n@@ -217,7 +212,6 @@ impl GarbageCollector {\n                 format!(\"{:?}\", cleanup_mode),\n             )],\n         );\n-\n         Ok(result)\n     }\n }\n@@ -360,9 +354,18 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 continue;\n             }\n \n-            if collection.lineage_file_path.is_some() {\n+            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n+                tenant_mode_overrides\n+                    .get(&collection.tenant)\n+                    .cloned()\n+                    .unwrap_or(self.default_cleanup_mode)\n+            } else {\n+                self.default_cleanup_mode\n+            };\n+\n+            if collection.lineage_file_path.is_some() && !cleanup_mode.is_v2() {\n                 tracing::debug!(\n-                    \"Skipping garbage collection for root of fork tree: {}\",\n+                    \"Skipping garbage collection for root of fork tree because GC v1 cannot handle fork trees: {}\",\n                     collection.id\n                 );\n                 num_skipped_jobs += 1;\n@@ -376,17 +379,6 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 collection.version_file_path\n             );\n \n-            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n-                tenant_mode_overrides\n-                    .get(&collection.tenant)\n-                    .cloned()\n-                    .unwrap_or(self.default_cleanup_mode)\n-            } else {\n-                self.default_cleanup_mode\n-            };\n-\n-            tracing::info!(\"Creating gc orchestrator for collection: {}\", collection.id);\n-\n             let instrumented_span = span!(parent: None, tracing::Level::INFO, \"Garbage collection job\", collection_id = ?collection.id, tenant_id = %collection.tenant, cleanup_mode = ?cleanup_mode);\n             instrumented_span.follows_from(Span::current());\n \n@@ -1011,6 +1003,26 @@ mod tests {\n         let (collection_in_delete_mode, database_name_in_delete_mode) =\n             collection_in_delete_mode_handle.await.unwrap();\n \n+        // Fork collection in delete mode to give it a lineage file (only GC v2 can handle fork trees)\n+        {\n+            let source_collection = sysdb\n+                .get_collections(Some(collection_in_delete_mode), None, None, None, None, 0)\n+                .await\n+                .unwrap();\n+            let source_collection = source_collection.first().unwrap();\n+\n+            sysdb\n+                .fork_collection(\n+                    collection_in_delete_mode,\n+                    source_collection.total_records_post_compaction,\n+                    source_collection.total_records_post_compaction,\n+                    CollectionUuid::new(),\n+                    \"test-fork\".to_string(),\n+                )\n+                .await\n+                .unwrap();\n+        }\n+\n         // Wait 1 second for cutoff time\n         tokio::time::sleep(Duration::from_secs(1)).await;\n \n---\nrust/garbage_collector/src/types.rs\n@@ -19,6 +19,12 @@ pub enum CleanupMode {\n     DeleteV2,\n }\n \n+impl CleanupMode {\n+    pub fn is_v2(&self) -> bool {\n+        matches!(self, CleanupMode::DryRunV2 | CleanupMode::DeleteV2)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub enum VersionStatus {\n     #[allow(dead_code)]\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThese changes seem to fix most causes of the Go tests flaking. Ran 70 times with no flake, whereas the flake rate seemed to be 5-20% prior to these changes.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\n\n---\n\nChoice A:\n.github/workflows/_go-tests.yml\n@@ -23,6 +23,9 @@ jobs:\n       - name: Start Tilt services\n         uses: ./.github/actions/tilt\n       - run: bin/cluster-test.sh bash -c 'cd go && make test'\n+        env:\n+          # Ryuk cleans up containers and is enabled by default. In CI it causes tests to occasionally flake.\n+          TESTCONTAINERS_RYUK_DISABLED: \"true\"\n       - name: Save service logs to artifact\n         if: always()\n         uses: ./.github/actions/export-tilt-logs\n---\ngo/Makefile\n@@ -27,8 +27,12 @@ build: proto\n \tgo build -v -o bin/coordinator ./cmd/coordinator/\n \tgo build -v -o bin/logservice ./cmd/logservice/\n \n+# -p 1 runs tests sequentially. If run in parallel tests are pretty flaky in CI.\n+# I believe this is caused by go/script/migrate_up_test.sh, which creates the possibility (observed during CI runs) of running multiple `atlas schema apply --dev-url \"docker://postgres/15/dev\" ...` in parallel.\n+# This command spins up a new Docker container, so my theory is that there's a race condition inside atlas when used this way.\n+# Instead of specifying -p 1, it might be possible to add a cross-process lock to guarantee that only one instance of atlas is running at a time.\n test: build\n-\tgo test -race -cover ./...\n+\tgo test -p 1 -race -cover ./...\n \n \n lint:\n---\ngo/pkg/sysdb/metastore/db/dbcore/core.go\n@@ -224,7 +224,7 @@ func GetDBConfigForTesting() DBConfig {\n \tdbName := \"chroma\"\n \tdbUsername := \"chroma\"\n \tdbPassword := \"chroma\"\n-\tcontainer, _ = postgres2.RunContainer(context.Background(),\n+\tcontainer, err := postgres2.RunContainer(context.Background(),\n \t\ttestcontainers.WithImage(\"docker.io/postgres:15.2-alpine\"),\n \t\tpostgres2.WithDatabase(dbName),\n \t\tpostgres2.WithUsername(dbUsername),\n@@ -235,6 +235,10 @@ func GetDBConfigForTesting() DBConfig {\n \t\t\t\tWithStartupTimeout(5*time.Second)),\n \t)\n \n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n \tvar ports nat.PortMap\n \tports, _ = container.Ports(context.Background())\n \n---\n\n\n---\n\nChoice B:\nrust/load/src/data_sets.rs\n@@ -836,12 +836,12 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            let key = uq.key.select_from_reference(self, offset);\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n             if !keys.contains(&key) {\n                 keys.push(key);\n             }\n---\n\n\n---\n\nChoice C:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.8\"\n+__version__ = \"1.0.9\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\n\n\n---\n\nChoice D:\nrust/wal3/examples/wal3-bootstrap-reasoner.rs\n@@ -0,0 +1,182 @@\n+//! This file is not intended for public consumption, but is kept for completeness.\n+//!\n+//! In this file you will find that we reason about the bootstrap process by completely exploring\n+//! the state space and pruning known good states.  The goal is to prune every state or print a\n+//! list of states that are bad.\n+//!\n+//! This is ad-hoc machine-assisted proving without an environment or theorem prover.\n+\n+#[derive(Clone, Copy, Debug)]\n+enum FragmentState {\n+    BenignRace,\n+    Conflict,\n+    Success,\n+}\n+\n+impl FragmentState {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            FragmentState::BenignRace,\n+            FragmentState::Conflict,\n+            FragmentState::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum InitializeManifest {\n+    Uninitialized,\n+    AlreadyInitialized,\n+    Success,\n+}\n+\n+impl InitializeManifest {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            InitializeManifest::Uninitialized,\n+            InitializeManifest::AlreadyInitialized,\n+            InitializeManifest::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum RecoverManifest {\n+    Uninitialized,\n+    Failure,\n+    Success,\n+}\n+\n+impl RecoverManifest {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            RecoverManifest::Uninitialized,\n+            RecoverManifest::Failure,\n+            RecoverManifest::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+enum Disposition {\n+    /// The combination of states is considered a good case.\n+    Good,\n+    /// The combination of states is not considered by the rule.\n+    Pass,\n+    /// The case can be dropped with good conscience for not mattering.  The string is the reason.\n+    Drop(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+    /// The case must lead to an error at runtime.\n+    Panic(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+    /// The case must be raised to the user for inspection.\n+    Raise(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+}\n+\n+fn happy_paths(fs: FragmentState, im: InitializeManifest, rm: RecoverManifest) -> Disposition {\n+    match (fs, im, rm) {\n+        (\n+            FragmentState::Success | FragmentState::BenignRace,\n+            InitializeManifest::Uninitialized | InitializeManifest::Success,\n+            RecoverManifest::Success,\n+        ) => Disposition::Good,\n+        _ => Disposition::Pass,\n+    }\n+}\n+\n+fn error_paths(fs: FragmentState, im: InitializeManifest, rm: RecoverManifest) -> Disposition {\n+    match (fs, im, rm) {\n+        (_, InitializeManifest::AlreadyInitialized, _) => {\n+            Disposition::Panic(\"cannot double-initialize manifest\", fs, im, rm)\n+        }\n+        (_, _, RecoverManifest::Uninitialized) => {\n+            Disposition::Panic(\"cannot have manifest become uninitialized\", fs, im, rm)\n+        }\n+        (_, _, RecoverManifest::Failure) => {\n+            Disposition::Panic(\"failed to install recovered manifest\", fs, im, rm)\n+        }\n+        _ => Disposition::Pass,\n+    }\n+}\n+\n+fn conflict_on_fragment(\n+    fs: FragmentState,\n+    im: InitializeManifest,\n+    rm: RecoverManifest,\n+) -> Disposition {\n+    if matches!(fs, FragmentState::Conflict) {\n+        Disposition::Drop(\n+            \"no need to touch manifest if fragment conflicts\",\n+            fs,\n+            im,\n+            rm,\n+        )\n+    } else {\n+        Disposition::Pass\n+    }\n+}\n+\n+fn unconditionally_raise(\n+    fs: FragmentState,\n+    im: InitializeManifest,\n+    rm: RecoverManifest,\n+) -> Disposition {\n+    Disposition::Raise(\"unconditional raise\", fs, im, rm)\n+}\n+\n+pub fn main() {\n+    let mut states = vec![];\n+    for fs in FragmentState::all_states() {\n+        for im in InitializeManifest::all_states() {\n+            for rm in RecoverManifest::all_states() {\n+                states.push((fs, im, rm));\n+            }\n+        }\n+    }\n+    let rules = vec![\n+        happy_paths,\n+        conflict_on_fragment,\n+        error_paths,\n+        unconditionally_raise,\n+    ];\n+    for state in states.iter() {\n+        for rule in &rules {\n+            match (rule)(state.0, state.1, state.2) {\n+                Disposition::Pass => {}\n+                Disposition::Good => {\n+                    break;\n+                }\n+                Disposition::Panic(reason, fs, im, rm) => {\n+                    println!(\"panic({fs:?}, {im:?}, {rm:?}) -> {reason}\");\n+                    break;\n+                }\n+                Disposition::Drop(reason, fs, im, rm) => {\n+                    _ = reason;\n+                    _ = fs;\n+                    _ = im;\n+                    _ = rm;\n+                    break;\n+                }\n+                Disposition::Raise(reason, fs, im, rm) => {\n+                    println!(\"raise({fs:?}, {im:?}, {rm:?}) -> {reason}\");\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nShould significantly speed up image builds.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\nIn o3 we trust.\n\n---\n\nChoice A:\nchromadb/api/models/AsyncCollection.py\n@@ -256,6 +256,8 @@ async def modify(\n             new_name=name,\n             new_metadata=metadata,\n             new_configuration=configuration,\n+            tenant=self.tenant,\n+            database=self.database,\n         )\n \n         self._update_model_after_modify_success(name, metadata, configuration)\n---\n\n\n---\n\nChoice B:\n.github/actions/docker/action.yaml\n@@ -17,11 +17,6 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n-    # https://github.com/docker/setup-qemu-action - for multiplatform builds\n-    - name: Set up QEMU\n-      uses: docker/setup-qemu-action@v2\n-    - name: Set up Docker Buildx\n-      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n.github/workflows/_build_release_container.yml\n@@ -33,43 +33,106 @@ permissions:\n env:\n   GHCR_IMAGE_NAME: \"ghcr.io/chroma-core/chroma\"\n   DOCKERHUB_IMAGE_NAME: \"chromadb/chroma\"\n-  PLATFORMS: linux/amd64,linux/arm64 #linux/riscv64, linux/arm/v7\n \n jobs:\n   build:\n-    name: Build and publish container image\n+    name: Build image for ${{ matrix.platform }}\n     runs-on: blacksmith-16vcpu-ubuntu-2204\n+    strategy:\n+      matrix:\n+        platform: [amd64, arm64]\n+        include:\n+          - platform: amd64\n+            runner: blacksmith-16vcpu-ubuntu-2204\n+            docker_platform: linux/amd64\n+          - platform: arm64\n+            runner: blacksmith-16vcpu-ubuntu-2204-arm\n+            docker_platform: linux/arm64\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n         with:\n           fetch-depth: 0\n+\n       - name: Set up Docker\n         uses: ./.github/actions/docker\n         with:\n           ghcr-username: ${{ github.actor }}\n           ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n           dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-      - name: Compute tags\n+\n+      - name: Compute arch-specific tags\n+        id: tags\n         shell: bash\n-        id: compute_tags\n         run: |\n-          tags=\"${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }},${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\"\n-          if [ \"${{ inputs.tag_as_latest }}\" = \"true\" ]; then\n-            tags=\"${tags},${{ env.GHCR_IMAGE_NAME }}:latest,${{ env.DOCKERHUB_IMAGE_NAME }}:latest\"\n-          fi\n+          arch_tag=\"${{ inputs.tag }}-${{ matrix.platform }}\"\n+          ghcr=\"${{ env.GHCR_IMAGE_NAME }}:${arch_tag}\"\n+          dhub=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${arch_tag}\"\n+          echo \"arch_tag=$arch_tag\"      >> $GITHUB_OUTPUT\n \n-          echo \"tags=${tags}\" >> $GITHUB_OUTPUT\n+          # expose *matrix-unique* step outputs\n+          echo \"ghcr_tag_${{ matrix.platform }}=$ghcr\"         >> $GITHUB_OUTPUT\n+          echo \"dockerhub_tag_${{ matrix.platform }}=$dhub\"    >> $GITHUB_OUTPUT\n+\n+          # these two tags are what the build-push action will publish for *this* arch\n+          echo \"tags=$ghcr,$dhub\" >> $GITHUB_OUTPUT\n \n       - name: Build and push image\n         uses: useblacksmith/build-push-action@v1.1\n         with:\n           context: .\n           file: rust/Dockerfile\n           target: cli\n-          platforms: ${{ env.PLATFORMS }}\n+          platforms: ${{ matrix.docker_platform }}\n           push: true\n           build-args: |\n             RELEASE_MODE=1\n-          tags: ${{ steps.compute_tags.outputs.tags }}\n+          tags: ${{ steps.tags.outputs.tags }}\n+    outputs:\n+      ghcr_tag_amd64:      ${{ steps.tags.outputs.ghcr_tag_amd64 }}\n+      ghcr_tag_arm64:      ${{ steps.tags.outputs.ghcr_tag_arm64 }}\n+      dockerhub_tag_amd64: ${{ steps.tags.outputs.dockerhub_tag_amd64 }}\n+      dockerhub_tag_arm64: ${{ steps.tags.outputs.dockerhub_tag_arm64 }}\n+\n+  merge:\n+    name: Merge platform manifests\n+    runs-on: blacksmith-4vcpu-ubuntu-2204\n+    needs:\n+      - build\n+    steps:\n+      - name: Set up Docker\n+        uses: ./.github/actions/docker\n+        with:\n+          ghcr-username: ${{ github.actor }}\n+          ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n+          dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n+          dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n+\n+      - name: Create and push manifest\n+        shell: bash\n+        run: |\n+          set -euo pipefail\n+\n+          # Pull the per-arch tags from job-level outputs\n+          ghcr_amd64='${{ needs.build.outputs.ghcr_tag_amd64 }}'\n+          ghcr_arm64='${{ needs.build.outputs.ghcr_tag_arm64 }}'\n+          dhub_amd64='${{ needs.build.outputs.dockerhub_tag_amd64 }}'\n+          dhub_arm64='${{ needs.build.outputs.dockerhub_tag_arm64 }}'\n+\n+          base_tag='${{ inputs.tag }}'\n+          ghcr_base=\"${{ env.GHCR_IMAGE_NAME }}:${base_tag}\"\n+          dhub_base=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${base_tag}\"\n+\n+          docker buildx imagetools create --tag \"$ghcr_base\" $ghcr_amd64 $ghcr_arm64\n+          docker buildx imagetools create --tag \"$dhub_base\"  $dhub_amd64 $dhub_arm64\n+\n+          if [[ \"${{ inputs.tag_as_latest }}\" == \"true\" ]]; then\n+            docker buildx imagetools create --tag \"${{ env.GHCR_IMAGE_NAME }}:latest\"  $ghcr_amd64 $ghcr_arm64\n+            docker buildx imagetools create --tag \"${{ env.DOCKERHUB_IMAGE_NAME }}:latest\" $dhub_amd64 $dhub_arm64\n+          fi\n+\n+      - name: Inspect image\n+        run: |\n+          docker buildx imagetools inspect ${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }}\n+          docker buildx imagetools inspect ${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\n---\n\n\n---\n\nChoice C:\ndocs/docs.trychroma.com/markdoc/content/docs/collections/configure.md\n@@ -40,7 +40,7 @@ Here's how to configure the Cohere embedding function:\n import os\n assert os.environ.get(\"CHROMA_COHERE_API_KEY\"), \"CHROMA_COHERE_API_KEY environment variable not set\"\n \n-from chromadb.utils.embedding_functions import CohereEmbeddingFunction\n+from chromadb.utils.embedding_functions.cohere_embedding_function import CohereEmbeddingFunction\n \n # Create the Cohere embedding function (API key is read from environment variable)\n # By default, it reads from 'CHROMA_COHERE_API_KEY'\n@@ -109,7 +109,7 @@ Here is an example showing how to configure both the HNSW index and embedding fu\n import os\n assert os.environ.get(\"COHERE_API_KEY\"), \"COHERE_API_KEY environment variable not set\"\n \n-from chromadb.utils.embedding_functions import CohereEmbeddingFunction\n+from chromadb.utils.embedding_functions.cohere_embedding_function import CohereEmbeddingFunction\n \n # Create the Cohere embedding function\n cohere_ef = CohereEmbeddingFunction(model_name=\"embed-english-light-v2.0\")\n---\n\n\n---\n\nChoice D:\ngo/pkg/log/server/server.go\n@@ -54,16 +54,18 @@ func (s *logServer) ScoutLogs(ctx context.Context, req *logservicepb.ScoutLogsRe\n \tif err != nil {\n \t\treturn\n \t}\n+\tvar start int64\n \tvar limit int64\n-\t_, limit, err = s.lr.GetBoundsForCollection(ctx, collectionID.String())\n+\tstart, limit, err = s.lr.GetBoundsForCollection(ctx, collectionID.String())\n \tif err != nil {\n \t\treturn\n \t}\n \t// +1 to convert from the (] bound to a [) bound.\n \tres = &logservicepb.ScoutLogsResponse{\n+\t\tFirstUncompactedRecordOffset: int64(start + 1),\n \t\tFirstUninsertedRecordOffset: int64(limit + 1),\n \t}\n-\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n+\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"start\", int64(start + 1)), zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n \treturn\n }\n \n---\nidl/chromadb/proto/logservice.proto\n@@ -24,6 +24,8 @@ message ScoutLogsResponse {\n   reserved 1;\n   // The next record to insert will have this offset.\n   int64 first_uninserted_record_offset = 2;\n+  // The oldest record on the log will have this offset.\n+  int64 first_uncompacted_record_offset = 3;\n }\n \n message PullLogsRequest {\n---\nrust/log-service/src/lib.rs\n@@ -745,18 +745,24 @@ impl LogService for LogServer {\n                 Arc::clone(&self.storage),\n                 prefix,\n             );\n-            let limit_position = match log_reader.maximum_log_position().await {\n-                Ok(limit_position) => limit_position,\n+            let (start_position, limit_position) = match log_reader.manifest().await {\n+                Ok(Some(manifest)) => (\n+                    manifest.minimum_log_position(),\n+                    manifest.maximum_log_position(),\n+                ),\n+                Ok(None) => (LogPosition::from_offset(0), LogPosition::from_offset(1)),\n                 Err(err) => {\n                     if err.code() == chroma_error::ErrorCodes::FailedPrecondition {\n-                        LogPosition::from_offset(1)\n+                        (LogPosition::from_offset(1), LogPosition::from_offset(1))\n                     } else {\n                         return Err(Status::new(err.code().into(), err.to_string()));\n                     }\n                 }\n             };\n+            let start_offset = start_position.offset() as i64;\n             let limit_offset = limit_position.offset() as i64;\n             Ok(Response::new(ScoutLogsResponse {\n+                first_uncompacted_record_offset: start_offset,\n                 first_uninserted_record_offset: limit_offset,\n             }))\n         }\n---\nrust/wal3/src/manifest.rs\n@@ -276,7 +276,7 @@ impl Snapshot {\n             },\n             (Some(f), None) => f,\n             (None, Some(s)) => s,\n-            (None, None) => LogPosition::default(),\n+            (None, None) => LogPosition::from_offset(1),\n         }\n     }\n \n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nAdds tracing for continuous_verification crate.\r\n\r\n## Test plan\r\n\r\nTested locally via tilt.\r\n\r\n## Documentation Changes\r\n\r\nN/A\r\n\n\n---\n\nChoice A:\nrust/tracing/src/init_tracer.rs\n@@ -38,6 +38,7 @@ pub fn init_global_filter_layer() -> Box<dyn Layer<Registry> + Send + Sync> {\n                 \"wal3\",\n                 \"worker\",\n                 \"garbage_collector\",\n+                \"continuous_verification\",\n             ]\n             .into_iter()\n             .map(|s| s.to_string() + \"=trace\")\n@@ -147,6 +148,10 @@ pub fn init_stdout_layer() -> Box<dyn Layer<Registry> + Send + Sync> {\n                     .module_path()\n                     .unwrap_or(\"\")\n                     .starts_with(\"hosted-frontend\")\n+                || metadata\n+                    .module_path()\n+                    .unwrap_or(\"\")\n+                    .starts_with(\"continuous_verification\")\n         }))\n         .with_filter(tracing_subscriber::filter::LevelFilter::INFO)\n         .boxed()\n---\n\n\n---\n\nChoice B:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -835,7 +841,10 @@ impl DataSet for ReferencingDataSet {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice C:\nrust/load/src/lib.rs\n@@ -1271,13 +1271,11 @@ impl LoadService {\n             for declared in declared {\n                 if let Entry::Vacant(entry) = running.entry(declared.uuid) {\n                     tracing::info!(\"spawning workload {}\", declared.uuid);\n-                    let root = tracing::info_span!(parent: None, \"workload\");\n                     let this = Arc::clone(self);\n                     let done = Arc::new(AtomicBool::new(false));\n                     let done_p = Arc::clone(&done);\n                     let inhibit = Arc::clone(&self.inhibit);\n                     let task = tokio::task::spawn(async move {\n-                        let _enter = root.enter();\n                         this.run_one_workload(done, inhibit, declared).await\n                     });\n                     entry.insert((done_p, task));\n@@ -1295,36 +1293,6 @@ impl LoadService {\n         let client = Arc::new(client(spec.connection.clone()).await);\n         let mut guac = Guacamole::new(spec.expires.timestamp_millis() as u64);\n         let mut next_op = Instant::now();\n-        let (tx, mut rx) = tokio::sync::mpsc::channel(1000);\n-        let _ = tx\n-            .send(tokio::spawn(async move { Ok::<(), Error>(()) }))\n-            .await;\n-        let this = Arc::clone(&self);\n-        let data_set = Arc::clone(&spec.data_set);\n-        let reaper = tokio::spawn(async move {\n-            while let Some(task) = rx.recv().await {\n-                if let Err(err) = task.await.unwrap() {\n-                    if !format!(\"{err:?}\").contains(\"429\") {\n-                        this.metrics.failed.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                        tracing::error!(\"workload task failed: {err:?}\");\n-                    } else {\n-                        this.metrics.limited.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                    }\n-                }\n-            }\n-        });\n \n         // Initialize the data set.\n         let data_set = Arc::clone(&spec.data_set);\n@@ -1408,30 +1376,44 @@ impl LoadService {\n                         .await\n                         .map_err(|err| Error::FailWorkload(err.to_string()))\n                     {\n-                        Ok(()) => Ok(()),\n+                        Ok(()) => (),\n                         Err(err) => {\n-                            if err.to_string().contains(\"invalid request: No results\") {\n+                            if format!(\"{err:?}\").contains(\"invalid request: No results\") {\n                                 this.metrics.no_results.add(\n                                     1,\n                                     &[KeyValue::new(\n                                         Key::from_static_str(\"data_set\"),\n                                         Value::from(data_set.name()),\n                                     )],\n                                 );\n-                                Ok(())\n+                                tracing::warn!(\"workload step no results: {err:?}\");\n+                            } else if !format!(\"{err:?}\").contains(\"429\") {\n+                                this.metrics.failed.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::error!(\"workload step failed: {err:?}\");\n                             } else {\n-                                Err(err)\n+                                this.metrics.limited.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::warn!(\"workload step rate limited: {err:?}\");\n                             }\n                         }\n-                    }\n+                    };\n                 };\n-                tx.send(tokio::spawn(fut)).await.unwrap();\n+                let span = tracing::info_span!(parent: None, \"step\", workload_uuid = %spec.uuid);\n+                tokio::spawn(fut.instrument(span));\n             }\n         }\n-        // Not an error, just needs to show up in stdout.\n-        tracing::error!(\"workload done: {}/{}\", spec.name, spec.description());\n-        drop(tx);\n-        reaper.await.unwrap();\n+        tracing::info!(\"workload done: {}/{}\", spec.name, spec.description());\n     }\n \n     fn load_persistent(&self) -> Result<(), Error> {\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/quota/mod.rs\n@@ -20,6 +20,7 @@ pub enum Action {\n     Update,\n     Upsert,\n     Query,\n+    ForkCollection,\n }\n \n impl fmt::Display for Action {\n@@ -35,6 +36,7 @@ impl fmt::Display for Action {\n             Action::Update => write!(f, \"Update\"),\n             Action::Upsert => write!(f, \"Upsert\"),\n             Action::Query => write!(f, \"Query\"),\n+            Action::ForkCollection => write!(f, \"Fork Collection\"),\n         }\n     }\n }\n@@ -54,6 +56,7 @@ impl TryFrom<&str> for Action {\n             \"update\" => Ok(Action::Update),\n             \"upsert\" => Ok(Action::Upsert),\n             \"query\" => Ok(Action::Query),\n+            \"fork_collection\" => Ok(Action::ForkCollection),\n             _ => Err(format!(\"Invalid Action: {}\", value)),\n         }\n     }\n@@ -241,6 +244,7 @@ pub enum UsageType {\n     NumDatabases,          // Total number of databases for a tenant\n     NumQueryIDs,           // Number of IDs to filter by in a query\n     NumRegexPredicates,    // Number of regex predicates in the where_document\n+    NumForks,              // Number of forks a root collection may have\n }\n \n impl fmt::Display for UsageType {\n@@ -271,6 +275,7 @@ impl fmt::Display for UsageType {\n             UsageType::NumDatabases => write!(f, \"Number of databases\"),\n             UsageType::NumQueryIDs => write!(f, \"Number of IDs to filter by in a query\"),\n             UsageType::NumRegexPredicates => write!(f, \"Number of regex predicates\"),\n+            UsageType::NumForks => write!(f, \"Number of forks\"),\n         }\n     }\n }\n@@ -301,6 +306,7 @@ impl TryFrom<&str> for UsageType {\n             \"num_databases\" => Ok(UsageType::NumDatabases),\n             \"num_query_ids\" => Ok(UsageType::NumQueryIDs),\n             \"num_regex_predicates\" => Ok(UsageType::NumRegexPredicates),\n+            \"num_forks\" => Ok(UsageType::NumForks),\n             _ => Err(format!(\"Invalid UsageType: {}\", value)),\n         }\n     }\n@@ -330,6 +336,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n         m.insert(UsageType::NumRegexPredicates, 0);\n+        m.insert(UsageType::NumForks, 1_000_000);\n         m\n     };\n }\n---\nrust/frontend/src/server.rs\n@@ -1166,10 +1166,19 @@ async fn fork_collection(\n             },\n         )\n         .await?;\n-    let _guard =\n-        server.scorecard_request(&[\"op:fork_collection\", format!(\"tenant:{}\", tenant).as_str()])?;\n+\n+    let api_token = headers\n+        .get(\"x-chroma-token\")\n+        .map(|val| val.to_str().unwrap_or_default())\n+        .map(|val| val.to_string());\n     let collection_id =\n         CollectionUuid::from_str(&collection_id).map_err(|_| ValidationError::CollectionId)?;\n+    let mut quota_payload = QuotaPayload::new(Action::ForkCollection, tenant.clone(), api_token);\n+    quota_payload = quota_payload.with_collection_uuid(collection_id);\n+    server.quota_enforcer.enforce(&quota_payload).await?;\n+\n+    let _guard =\n+        server.scorecard_request(&[\"op:fork_collection\", format!(\"tenant:{}\", tenant).as_str()])?;\n \n     let request = chroma_types::ForkCollectionRequest::try_new(\n         tenant,\n---\nrust/sysdb/src/sysdb.rs\n@@ -343,11 +343,11 @@ impl SysDb {\n     pub async fn count_forks(\n         &mut self,\n         source_collection_id: CollectionUuid,\n-    ) -> Result<u64, CountForksError> {\n+    ) -> Result<usize, CountForksError> {\n         match self {\n             SysDb::Grpc(grpc) => grpc.count_forks(source_collection_id).await,\n             SysDb::Sqlite(_) => Err(CountForksError::Local),\n-            SysDb::Test(_) => Err(CountForksError::Local),\n+            SysDb::Test(test) => test.count_forks(source_collection_id).await,\n         }\n     }\n \n@@ -989,7 +989,7 @@ impl GrpcSysDb {\n     pub async fn count_forks(\n         &mut self,\n         source_collection_id: CollectionUuid,\n-    ) -> Result<u64, CountForksError> {\n+    ) -> Result<usize, CountForksError> {\n         let res = self\n             .client\n             .count_forks(chroma_proto::CountForksRequest {\n@@ -1002,7 +1002,7 @@ impl GrpcSysDb {\n             })?\n             .into_inner();\n \n-        Ok(res.count)\n+        Ok(res.count as usize)\n     }\n \n     pub async fn get_collections_to_gc(\n---\nrust/sysdb/src/test_sysdb.rs\n@@ -1,7 +1,8 @@\n use chroma_types::{\n-    Collection, CollectionAndSegments, CollectionUuid, Database, FlushCompactionResponse,\n-    GetCollectionSizeError, GetCollectionWithSegmentsError, GetSegmentsError, ListDatabasesError,\n-    ListDatabasesResponse, Segment, SegmentFlushInfo, SegmentScope, SegmentType, Tenant,\n+    Collection, CollectionAndSegments, CollectionUuid, CountForksError, Database,\n+    FlushCompactionResponse, GetCollectionSizeError, GetCollectionWithSegmentsError,\n+    GetSegmentsError, ListDatabasesError, ListDatabasesResponse, Segment, SegmentFlushInfo,\n+    SegmentScope, SegmentType, Tenant,\n };\n use chroma_types::{GetCollectionsError, SegmentUuid};\n use parking_lot::Mutex;\n@@ -541,4 +542,11 @@ impl TestSysDb {\n             vector_segment,\n         })\n     }\n+\n+    pub(crate) async fn count_forks(\n+        &mut self,\n+        _source_collection_id: CollectionUuid,\n+    ) -> Result<usize, CountForksError> {\n+        Ok(10)\n+    }\n }\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nReverts chroma-core/chroma#4734\n\n---\n\nChoice A:\nrust/frontend/src/quota/mod.rs\n@@ -240,6 +240,7 @@ pub enum UsageType {\n     NumCollections,        // Total number of collections for a tenant\n     NumDatabases,          // Total number of databases for a tenant\n     NumQueryIDs,           // Number of IDs to filter by in a query\n+    NumRegexPredicates,    // Number of regex predicates in the where_document\n }\n \n impl fmt::Display for UsageType {\n@@ -269,6 +270,7 @@ impl fmt::Display for UsageType {\n             UsageType::NumCollections => write!(f, \"Number of collections\"),\n             UsageType::NumDatabases => write!(f, \"Number of databases\"),\n             UsageType::NumQueryIDs => write!(f, \"Number of IDs to filter by in a query\"),\n+            UsageType::NumRegexPredicates => write!(f, \"Number of regex predicates\"),\n         }\n     }\n }\n@@ -298,6 +300,7 @@ impl TryFrom<&str> for UsageType {\n             \"num_collections\" => Ok(UsageType::NumCollections),\n             \"num_databases\" => Ok(UsageType::NumDatabases),\n             \"num_query_ids\" => Ok(UsageType::NumQueryIDs),\n+            \"num_regex_predicates\" => Ok(UsageType::NumRegexPredicates),\n             _ => Err(format!(\"Invalid UsageType: {}\", value)),\n         }\n     }\n@@ -326,6 +329,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumCollections, 1_000_000);\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n+        m.insert(UsageType::NumRegexPredicates, 0);\n         m\n     };\n }\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/repository/log.go\n@@ -153,17 +153,6 @@ func (r *LogRepository) PullRecords(ctx context.Context, collectionId string, of\n }\n \n func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID string, targetCollectionID string) (compactionOffset uint64, enumerationOffset uint64, err error) {\n-\tfor retries := 0; retries < 3; retries++ {\n-\t\tcompactionOffset, enumerationOffset, err = r.innerForkRecords(ctx, sourceCollectionID, targetCollectionID)\n-\t\tif err == nil {\n-\t\t\treturn\n-\t\t}\n-\t\ttime.Sleep(time.Millisecond * 100 * (1 << retries))\n-\t}\n-\treturn\n-}\n-\n-func (r *LogRepository) innerForkRecords(ctx context.Context, sourceCollectionID string, targetCollectionID string) (compactionOffset uint64, enumerationOffset uint64, err error) {\n \tvar tx pgx.Tx\n \ttx, err = r.conn.BeginTx(ctx, pgx.TxOptions{})\n \tif err != nil {\n@@ -179,8 +168,7 @@ func (r *LogRepository) innerForkRecords(ctx context.Context, sourceCollectionID\n \t\t}\n \t}()\n \n-\tvar sourceBounds log.GetBoundsForCollectionRow\n-\tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n+\tsourceBounds, err := queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in getting compaction and enumeration offset for source collection\", zap.Error(err), zap.String(\"collectionId\", sourceCollectionID))\n \t\treturn\n@@ -193,35 +181,34 @@ func (r *LogRepository) innerForkRecords(ctx context.Context, sourceCollectionID\n \t\ttrace_log.Error(\"Error forking log record\", zap.String(\"sourceCollectionID\", sourceCollectionID))\n \t\treturn\n \t}\n-\t_, err = queriesWithTx.InsertCollection(ctx, log.InsertCollectionParams{\n-\t\tID:                              targetCollectionID,\n-\t\tRecordCompactionOffsetPosition:  int64(sourceBounds.RecordCompactionOffsetPosition),\n-\t\tRecordEnumerationOffsetPosition: int64(sourceBounds.RecordEnumerationOffsetPosition),\n-\t})\n+\ttargetBounds, err := queriesWithTx.GetMinimumMaximumOffsetForCollection(ctx, targetCollectionID)\n \tif err != nil {\n-\t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n+\t\ttrace_log.Error(\"Error in deriving compaction and enumeration offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n \t\treturn\n \t}\n-\tvar targetBounds log.GetMinimumMaximumOffsetForCollectionRow\n-\ttargetBounds, err = queriesWithTx.GetMinimumMaximumOffsetForCollection(ctx, targetCollectionID)\n-\tif err != nil {\n-\t\ttrace_log.Error(\"Error in getting minimax for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n-\t\treturn\n+\n+\tif targetBounds.MinOffset == 0 {\n+\t\t// Either the source collection is not compacted yet or no log is forked\n+\t\tcompactionOffset = uint64(sourceBounds.RecordCompactionOffsetPosition)\n+\t} else {\n+\t\t// Some logs are forked, the min offset is guaranteed to be larger than source compaction offset\n+\t\tcompactionOffset = uint64(targetBounds.MinOffset - 1)\n \t}\n-\tif targetBounds.MinOffset > 0 && targetBounds.MinOffset != sourceBounds.RecordCompactionOffsetPosition + 1 {\n-\t\ttrace_log.Error(\"Race condition: Someone adjusted records during our transaction\",\n-\t\t\tzap.String(\"collectionId\", targetCollectionID),\n-\t\t\tzap.Int64(\"MinOffset\", targetBounds.MinOffset),\n-\t\t\tzap.Int64(\"CompactionOffset+1\", sourceBounds.RecordCompactionOffsetPosition + 1))\n-\t\terr = errors.New(\"concurrent updates caused fork to fail on compaction offset\")\n-\t\treturn\n+\tif targetBounds.MaxOffset == 0 {\n+\t\t// Either the source collection is empty or no log is forked\n+\t\tenumerationOffset = uint64(sourceBounds.RecordEnumerationOffsetPosition)\n+\t} else {\n+\t\t// Some logs are forked. The max offset is the enumeration offset\n+\t\tenumerationOffset = uint64(targetBounds.MaxOffset)\n \t}\n-\tif targetBounds.MaxOffset > 0 && targetBounds.MaxOffset != sourceBounds.RecordEnumerationOffsetPosition {\n-\t\ttrace_log.Error(\"Race condition: Someone adjusted records during our transaction\",\n-\t\t\tzap.String(\"collectionId\", targetCollectionID),\n-\t\t\tzap.Int64(\"MaxOffset\", targetBounds.MaxOffset),\n-\t\t\tzap.Int64(\"EnumerationOffset\", sourceBounds.RecordEnumerationOffsetPosition))\n-\t\terr = errors.New(\"concurrent updates caused fork to fail on enumeration offset\")\n+\n+\t_, err = queriesWithTx.InsertCollection(ctx, log.InsertCollectionParams{\n+\t\tID:                              targetCollectionID,\n+\t\tRecordCompactionOffsetPosition:  int64(compactionOffset),\n+\t\tRecordEnumerationOffsetPosition: int64(enumerationOffset),\n+\t})\n+\tif err != nil {\n+\t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n \t\treturn\n \t}\n \treturn\n---\n\n\n---\n\nChoice C:\nrust/chroma-tmp/Cargo.toml\n@@ -0,0 +1,33 @@\n+[package]\n+name = \"chroma-tmp\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[dependencies]\n+async-trait = { workspace = true }\n+chrono = { workspace = true }\n+clap = { workspace = true }\n+figment = { workspace = true }\n+rand = { workspace = true }\n+serde = { workspace = true }\n+serde_json = { workspace = true }\n+tokio = { workspace = true }\n+uuid = { workspace = true }\n+axum = { workspace = true }\n+\n+tracing = { workspace = true }\n+tracing-bunyan-formatter = { workspace = true }\n+tracing-opentelemetry = { workspace = true }\n+tracing-subscriber = { workspace = true }\n+opentelemetry = { workspace = true }\n+opentelemetry-otlp = { workspace = true }\n+opentelemetry-http = { workspace = true }\n+opentelemetry_sdk = { workspace = true }\n+\n+# Unlikely to be used in the workspace.\n+chromadb = { git = \"https://github.com/rescrv/chromadb-rs\", rev = \"540c3e225e92ecea05039b73b69adf5875385c0e\" }\n+guacamole = { version = \"0.11\", default-features = false }\n+tower-http = { workspace = true }\n+reqwest = { workspace = true, features = [\"json\"] }\n+siphasher = \"1.0.1\"\n+futures.workspace = true\n---\nrust/chroma-tmp/src/main.rs\n@@ -0,0 +1,138 @@\n+use std::collections::HashMap;\n+use std::sync::atomic::{AtomicU64, Ordering};\n+use std::sync::Arc;\n+\n+use guacamole::combinators::*;\n+use guacamole::Guacamole;\n+\n+use tokio::sync::Semaphore;\n+\n+use chromadb::client::{ChromaAuthMethod, ChromaClientOptions, ChromaTokenHeader};\n+use chromadb::collection::{CollectionEntries, GetOptions};\n+use chromadb::ChromaClient;\n+\n+#[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]\n+pub struct Connection {\n+    pub url: String,\n+    pub api_key: Option<String>,\n+    pub database: String,\n+}\n+\n+pub async fn client(connection: Connection) -> ChromaClient {\n+    let auth = if let Some(api_key) = connection.api_key.clone() {\n+        ChromaAuthMethod::TokenAuth {\n+            token: api_key,\n+            header: ChromaTokenHeader::XChromaToken,\n+        }\n+    } else {\n+        ChromaAuthMethod::None\n+    };\n+    ChromaClient::new(ChromaClientOptions {\n+        url: Some(connection.url.clone()),\n+        auth,\n+        database: connection.database.clone(),\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::main]\n+async fn main() {\n+    let success = Arc::new(AtomicU64::new(0));\n+    let failure = Arc::new(AtomicU64::new(0));\n+    let client = client(Connection {\n+        url: \"https://api.devchroma.com:8000\".to_string(),\n+        api_key: std::env::var(\"CHROMA_API_KEY\").ok(),\n+        database: std::env::var(\"CHROMA_DATABASE\").expect(\"set CHROMA_DATABASE\"),\n+    })\n+    .await;\n+    let mut collections = vec![];\n+    let mut collection_locks: HashMap<String, Arc<tokio::sync::Mutex<()>>> = HashMap::default();\n+    const COLLECTIONS: usize = 1000;\n+    for i in 1..=COLLECTIONS {\n+        let collection = client\n+            .get_or_create_collection(&format!(\"many-collections-{i}\"), None)\n+            .await\n+            .unwrap();\n+        println!(\"loaded {collection:?}\");\n+        collection_locks.insert(\n+            collection.id().to_string(),\n+            Arc::new(tokio::sync::Mutex::new(())),\n+        );\n+        collections.push(collection);\n+    }\n+    const MAGIC_CONSTANT: usize = 2000;\n+    let (tx, mut rx) = tokio::sync::mpsc::channel(MAGIC_CONSTANT);\n+    tokio::task::spawn(async move {\n+        while let Some(x) = rx.recv().await {\n+            let _ = x.await;\n+        }\n+    });\n+    let mut guac = Guacamole::new(0);\n+    let semaphore = Arc::new(Semaphore::new(MAGIC_CONSTANT));\n+    let start = std::time::Instant::now();\n+    let mut i = 0;\n+    while start.elapsed() < std::time::Duration::from_secs(600) {\n+        let collection = collections[i % collections.len()].clone();\n+        i += 1;\n+        let mut ids = vec![];\n+        let mut documents = vec![];\n+        let mut embeddings = vec![];\n+        for i in 0..100 {\n+            ids.push(format!(\"key-{i}\"));\n+            documents.push(\"dummy\");\n+            embeddings.push(vec![\n+                any::<f32>(&mut guac),\n+                any::<f32>(&mut guac),\n+                any::<f32>(&mut guac),\n+            ]);\n+        }\n+        let per_collection = collection_locks\n+            .get(collections[i % collections.len()].id())\n+            .map(Arc::clone)\n+            .unwrap();\n+        let semaphore = Arc::clone(&semaphore);\n+        let success = Arc::clone(&success);\n+        let failure = Arc::clone(&failure);\n+        let handle = tokio::task::spawn(async move {\n+            let _guard = per_collection.lock().await;\n+            let _permit = semaphore.acquire().await;\n+            let mut results = vec![];\n+            for i in 0..4 {\n+                let collection = collection.clone();\n+                let success = Arc::clone(&success);\n+                let failure = Arc::clone(&failure);\n+                let jh = tokio::task::spawn(async move {\n+                    let is_err = collection\n+                        .get(GetOptions {\n+                            ids: vec![format!(\"key-{i}\")],\n+                            where_metadata: None,\n+                            limit: Some(10),\n+                            offset: None,\n+                            where_document: None,\n+                            include: None,\n+                        })\n+                        .await\n+                        .is_err();\n+                    if is_err {\n+                        failure.fetch_add(1, Ordering::Relaxed);\n+                    } else {\n+                        success.fetch_add(1, Ordering::Relaxed);\n+                    }\n+                });\n+                results.push(jh);\n+            }\n+            futures::future::join_all(results).await;\n+            let ids = ids.iter().map(String::as_str).collect::<Vec<_>>();\n+            let entries = CollectionEntries {\n+                ids,\n+                embeddings: Some(embeddings),\n+                metadatas: None,\n+                documents: Some(documents),\n+            };\n+            let _results = collection.upsert(entries, None).await;\n+        });\n+        let _ = tx.send(handle).await;\n+    }\n+    drop(tx);\n+}\n---\n\n\n---\n\nChoice D:\nrust/log/src/log.rs\n@@ -30,7 +30,7 @@ pub enum Log {\n }\n \n impl Log {\n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn read(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -54,7 +54,7 @@ impl Log {\n     }\n \n     // ScoutLogs returns the offset of the next record to be inserted into the log.\n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn scout_logs(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -76,7 +76,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self, records))]\n+    #[tracing::instrument(skip(self, records), err(Display))]\n     pub async fn push_logs(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -95,7 +95,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn fork_logs(\n         &mut self,\n         source_collection_id: CollectionUuid,\n@@ -111,7 +111,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn get_collections_with_new_data(\n         &mut self,\n         min_compaction_size: u64,\n@@ -129,7 +129,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn update_collection_log_offset(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -153,7 +153,7 @@ impl Log {\n     }\n \n     /// Only supported in distributed. Sqlite has a different workflow.\n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn purge_dirty_for_collection(\n         &mut self,\n         collection_id: CollectionUuid,\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThe setup:\n- Fragments with LogPosition ranges [1, 101), [101, 201).\n- Query for 75 records at offset 50 should fetch both fragments.\n- Prior to this change only the first fragment was fetched.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/storage/src/admissioncontrolleds3.rs\n@@ -548,9 +548,19 @@ impl CountBasedPolicy {\n             match &mut channel_receiver {\n                 Some(rx) => {\n                     select! {\n-                        _ = rx.recv() => {\n+                        did_recv = rx.recv() => {\n                             // Reevaluate priority if we got a notification.\n-                            continue;\n+                            match did_recv {\n+                                Some(_) => {\n+                                    // If we got a notification, continue to acquire.\n+                                    continue;\n+                                }\n+                                None => {\n+                                    // If the channel was closed, break out of the loop.\n+                                    channel_receiver = None;\n+                                    continue;\n+                                }\n+                            }\n                         }\n                         token = self.remaining_tokens[current_priority.as_usize()].acquire() => {\n                             match token {\n---\nrust/worker/src/execution/operators/prefetch_record.rs\n@@ -6,7 +6,7 @@ use chroma_segment::{\n     blockfile_record::{RecordSegmentReader, RecordSegmentReaderCreationError},\n     types::{materialize_logs, LogMaterializerError},\n };\n-use chroma_system::Operator;\n+use chroma_system::{Operator, OperatorType};\n use thiserror::Error;\n use tracing::{trace, Instrument, Span};\n \n@@ -94,4 +94,8 @@ impl Operator<PrefetchRecordInput, PrefetchRecordOutput> for PrefetchRecordOpera\n     fn errors_when_sender_dropped(&self) -> bool {\n         false\n     }\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n }\n---\n\n\n---\n\nChoice B:\nrust/log/src/test.rs\n@@ -124,7 +124,7 @@ pub trait LoadFromGenerator<L: LogGenerator> {\n impl<L: LogGenerator + Send + 'static> LoadFromGenerator<L> for TestDistributedSegment {\n     async fn populate_with_generator(&mut self, log_count: usize, generator: L) {\n         let ids: Vec<_> = (1..=log_count).collect();\n-        for chunk in ids.chunks(100) {\n+        for chunk in ids.chunks(10_000) {\n             self.compact_log(\n                 generator.generate_chunk(chunk.iter().copied()),\n                 chunk\n---\n\n\n---\n\nChoice C:\nrust/cache/src/foyer.rs\n@@ -94,8 +94,17 @@ const fn default_trace_fetch_us() -> usize {\n     1000 * 100\n }\n \n+fn default_name() -> String {\n+    String::from(\"foyer\")\n+}\n+\n #[derive(Deserialize, Debug, Clone, Serialize, Parser)]\n pub struct FoyerCacheConfig {\n+    /// Name of the cache. All metrics for the cache are prefixed with name_.\n+    #[arg(long, default_value = \"foyer\")]\n+    #[serde(default = \"default_name\")]\n+    pub name: String,\n+\n     /// Directory for disk cache data.\n     #[arg(short, long)]\n     pub dir: Option<String>,\n@@ -262,6 +271,7 @@ impl FoyerCacheConfig {\n impl Default for FoyerCacheConfig {\n     fn default() -> Self {\n         FoyerCacheConfig {\n+            name: default_name(),\n             dir: None,\n             capacity: default_capacity(),\n             mem: default_mem(),\n@@ -352,6 +362,7 @@ where\n             ),\n         );\n         let builder = HybridCacheBuilder::<K, V>::new()\n+            .with_name(config.name.clone())\n             .with_metrics_registry(otel_0_27_metrics)\n             .with_tracing_options(tracing_options.clone())\n             .with_policy(foyer::HybridCachePolicy::WriteOnInsertion)\n@@ -537,6 +548,7 @@ where\n         config: &FoyerCacheConfig,\n     ) -> Result<FoyerPlainCache<K, V>, Box<dyn ChromaError>> {\n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .build();\n@@ -590,6 +602,7 @@ where\n         let evl = TokioEventListener(tx);\n \n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .with_event_listener(Arc::new(evl))\n---\nrust/frontend/sample_configs/distributed.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/worker/chroma_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     disk:\n+                        name: \"block_cache\"\n                         dir: \"/cache/chroma/query-service/block-cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n@@ -72,11 +73,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n \n@@ -138,15 +141,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\nrust/worker/tilt_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 block_cache_config:\n                     disk:\n                         dir: \"/cache/chroma/query-service/block-cache\"\n+                        name: \"block_cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n                         mem: 8000 # 8GiB\n@@ -71,11 +72,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n     fetch_log_batch_size: 1000\n@@ -141,15 +144,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\n\n\n---\n\nChoice D:\nrust/wal3/src/reader.rs\n@@ -141,7 +141,7 @@ impl LogReader {\n         }\n         fragments.retain(|f| f.limit > from);\n         fragments.sort_by_key(|f| f.start.offset());\n-        Ok(Self::post_process_fragments(fragments, limits))\n+        Ok(Self::post_process_fragments(fragments, from, limits))\n     }\n \n     /// Do a consistent stale read of the manifest.  If the read can be returned without I/O,\n@@ -174,10 +174,14 @@ impl LogReader {\n             .filter(|f| ranges_overlap(log_position_range, (f.start, f.limit)))\n             .cloned()\n             .collect::<Vec<_>>();\n-        Some(Self::post_process_fragments(fragments, limits))\n+        Some(Self::post_process_fragments(fragments, from, limits))\n     }\n \n-    fn post_process_fragments(mut fragments: Vec<Fragment>, limits: Limits) -> Vec<Fragment> {\n+    fn post_process_fragments(\n+        mut fragments: Vec<Fragment>,\n+        from: LogPosition,\n+        limits: Limits,\n+    ) -> Vec<Fragment> {\n         fragments.sort_by_key(|f| f.start.offset());\n         if let Some(max_files) = limits.max_files {\n             if fragments.len() as u64 > max_files {\n@@ -188,7 +192,7 @@ impl LogReader {\n         while fragments.len() > 1\n             // NOTE(rescrv):  We take the start of the last fragment, because if there are enough\n             // records without it we can pop.\n-            && fragments[fragments.len() - 1].start - fragments[0].start\n+            && fragments[fragments.len() - 1].start - from\n                 > limits.max_records.unwrap_or(u64::MAX)\n         {\n             tracing::info!(\n@@ -456,3 +460,143 @@ pub async fn read_fragment(\n         setsum,\n     }))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use setsum::Setsum;\n+\n+    use crate::{Fragment, FragmentSeqNo};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn post_process_fragments_uses_from_position_for_record_limits() {\n+        let fragments = vec![\n+            Fragment {\n+                path: \"fragment1\".to_string(),\n+                seq_no: FragmentSeqNo(1),\n+                start: LogPosition::from_offset(100),\n+                limit: LogPosition::from_offset(150),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+            Fragment {\n+                path: \"fragment2\".to_string(),\n+                seq_no: FragmentSeqNo(2),\n+                start: LogPosition::from_offset(150),\n+                limit: LogPosition::from_offset(200),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+            Fragment {\n+                path: \"fragment3\".to_string(),\n+                seq_no: FragmentSeqNo(3),\n+                start: LogPosition::from_offset(200),\n+                limit: LogPosition::from_offset(250),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+        ];\n+\n+        // Test case: from position is later than the first fragment's start\n+        // This tests the bug fix where we use 'from' instead of fragments[0].start\n+        let from = LogPosition::from_offset(125);\n+        let limits = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(100), // Set a limit that should trigger the record check\n+        };\n+\n+        let result = LogReader::post_process_fragments(fragments.clone(), from, limits);\n+\n+        // With the fix: last fragment start (200) - from (125) = 75 records\n+        // This should be under the 100 record limit, so all fragments should remain\n+        assert_eq!(result.len(), 3);\n+\n+        // Test case that would fail with the old bug:\n+        // If we were using fragments[0].start (100) instead of from (125),\n+        // then: last fragment start (200) - fragments[0].start (100) = 100 records\n+        // This would equal the limit, but the actual span from 'from' is only 75\n+        let limits_strict = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(74), // Just under the actual span from 'from'\n+        };\n+\n+        let result_strict =\n+            LogReader::post_process_fragments(fragments.clone(), from, limits_strict);\n+\n+        // With the fix: 200 - 125 = 75 > 74, so last fragment should be removed\n+        assert_eq!(result_strict.len(), 2);\n+        assert_eq!(result_strict[0].seq_no, FragmentSeqNo(1));\n+        assert_eq!(result_strict[1].seq_no, FragmentSeqNo(2));\n+    }\n+\n+    #[test]\n+    fn records_based_pruning_bug_from_commit_message() {\n+        // Test the exact scenario from the commit message:\n+        // - Fragments with LogPosition ranges [1, 101), [101, 201).\n+        // - Query for 75 records at offset 50 should fetch both fragments.\n+        // - Prior to this change only the first fragment was fetched.\n+\n+        let fragments = vec![\n+            Fragment {\n+                path: \"fragment1\".to_string(),\n+                seq_no: FragmentSeqNo(1),\n+                start: LogPosition::from_offset(1),\n+                limit: LogPosition::from_offset(101),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+            Fragment {\n+                path: \"fragment2\".to_string(),\n+                seq_no: FragmentSeqNo(2),\n+                start: LogPosition::from_offset(101),\n+                limit: LogPosition::from_offset(201),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+        ];\n+\n+        // Query for 75 records at offset 50\n+        let from = LogPosition::from_offset(50);\n+        let limits = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(75),\n+        };\n+\n+        let result = LogReader::post_process_fragments(fragments.clone(), from, limits);\n+\n+        // With the fix: both fragments should be returned\n+        // The calculation is: last fragment start (101) - from (50) = 51 records\n+        // Since 51 < 75, both fragments should remain\n+        assert_eq!(\n+            result.len(),\n+            2,\n+            \"Both fragments should be returned for 75 records from offset 50\"\n+        );\n+        assert_eq!(result[0].seq_no, FragmentSeqNo(1));\n+        assert_eq!(result[1].seq_no, FragmentSeqNo(2));\n+\n+        // Test the edge case where the old bug would have incorrectly calculated:\n+        // Old bug would use: fragments[1].start (101) - fragments[0].start (1) = 100 records\n+        // If max_records was 99, old code would incorrectly remove the second fragment\n+        let limits_edge_case = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(50), // Just under the actual span from 'from' (51)\n+        };\n+\n+        let result_edge =\n+            LogReader::post_process_fragments(fragments.clone(), from, limits_edge_case);\n+\n+        // With the fix: 101 - 50 = 51 > 50, so the second fragment should be removed\n+        assert_eq!(\n+            result_edge.len(),\n+            1,\n+            \"Only first fragment should remain with 50 record limit\"\n+        );\n+        assert_eq!(result_edge[0].seq_no, FragmentSeqNo(1));\n+    }\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nUpdate EF docs for new JS client\n\n---\n\nChoice A:\ndocs/docs.trychroma.com/markdoc/content/docs/collections/create-get-delete.md\n@@ -62,7 +62,20 @@ let collection = await client.createCollection({\n });\n ```\n \n-The embedding function takes text as input and embeds it. If no embedding function is supplied, Chroma will use [sentence transformer](https://www.sbert.net/index.html) as a default. You can learn more about [embedding functions](../embeddings/embedding-functions), and how to create your own.\n+The embedding function takes text as input and embeds it. Different embedding functions are available on npm under the `@chroma-core` organization. For example, if you want to use the `OpenAIEmbeddingFunction`, install `@chroma-core/openai`:\n+\n+```typescript\n+import { OpenAIEmbeddingFunction } from \"@chroma-core/openai\";\n+\n+let collection = await client.createCollection({\n+    name: \"my_collection\",\n+    embeddingFunction: new OpenAIEmbeddingFunction(),\n+});\n+```\n+\n+If no embedding function is supplied, Chroma will use [sentence transformer](https://www.sbert.net/index.html) as a default. Make sure the `@chroma-core/default-embed` package is installed. \n+\n+You can learn more about [embedding functions](../embeddings/embedding-functions), and how to create your own.\n \n When creating collections, you can pass the optional `metadata` argument to add a mapping of metadata key-value pairs to your collections. This can be useful for adding general about the collection like creation time, description of the data stored in the collection, and more.\n \n---\ndocs/docs.trychroma.com/markdoc/content/docs/embeddings/embedding-functions.md\n@@ -81,7 +81,7 @@ sentence_transformer_ef = embedding_functions.SentenceTransformerEmbeddingFuncti\n \n {% Tab label=\"typescript\" %}\n ```typescript\n-import { DefaultEmbeddingFunction } from \"chromadb\";\n+import { DefaultEmbeddingFunction } from \"@chroma-core/default-embed\";\n const modelName = \"all-MiniLM-L6-v2\";\n const defaultEF = new DefaultEmbeddingFunction(modelName);\n ```\n---\ndocs/docs.trychroma.com/markdoc/content/integrations/embedding-models/cloudflare-workers-ai.md\n@@ -30,9 +30,11 @@ ef(input=[\"This is my first text to embed\", \"This is my second document\"])\n {% Tab label=\"typescript\" %}\n \n ```typescript\n-import { CloudflareWorkersAIEmbeddingFunction } from 'chromadb';\n+// npm install @chroma-core/cloudflare-worker-ai\n \n-process.env.CHROMA_CLOUDFLARE_API_KEY = \"<INSERT API KEY HERE>\"\n+import { CloudflareWorkersAIEmbeddingFunction } from '@chroma-core/cloudflare-worker-ai';\n+\n+process.env.CLOUDFLARE_API_KEY = \"<INSERT API KEY HERE>\"\n \n const embedder = new CloudflareWorkersAIEmbeddingFunction({\n     account_id=\"<INSERT ACCOUNT ID HERE>\",\n---\ndocs/docs.trychroma.com/markdoc/content/integrations/embedding-models/cohere.md\n@@ -23,9 +23,11 @@ cohere_ef(input=[\"document1\",\"document2\"])\n {% Tab label=\"typescript\" %}\n \n ```typescript\n-import { CohereEmbeddingFunction } from 'chromadb';\n+// npm install @chroma-core/cohere\n \n-const embedder = new CohereEmbeddingFunction(\"apiKey\")\n+import { CohereEmbeddingFunction } from '@chroma-core/cohere';\n+\n+const embedder = new CohereEmbeddingFunction({ apiKey: \"apiKey\" })\n \n // use directly\n const embeddings = embedder.generate([\"document1\",\"document2\"])\n---\ndocs/docs.trychroma.com/markdoc/content/integrations/embedding-models/google-gemini.md\n@@ -36,12 +36,14 @@ For more info - please visit the [official Google python docs](https://ai.google\n \n {% Tab label=\"typescript\" %}\n \n-This embedding function relies on the `@google/generative-ai` npm package, which you can install with e.g. `npm install @google/generative-ai`.\n-\n ```typescript\n-import { ChromaClient, GoogleGenerativeAiEmbeddingFunction } from \"chromadb\";\n+// npm install @chroma-core/google-gemini\n+\n+import { ChromaClient } from \"chromadb\";\n+import { GoogleGenerativeAiEmbeddingFunction } from \"@chroma-core/google-gemini\";\n+\n const embedder = new GoogleGenerativeAiEmbeddingFunction({\n-  googleApiKey: \"<YOUR API KEY>\",\n+  apiKey: \"<YOUR API KEY>\",\n });\n \n // use directly\n---\ndocs/docs.trychroma.com/markdoc/content/integrations/embedding-models/hugging-face-server.md\n@@ -42,7 +42,10 @@ huggingface_ef = HuggingFaceEmbeddingServer(url=\"http://localhost:8001/embed\")\n \n \n ```typescript\n-import  {HuggingFaceEmbeddingServerFunction} from 'chromadb';\n+// npm install @chroma-core/huggingface-server\n+\n+import { HuggingFaceEmbeddingServerFunction } from '@chroma-core/huggingface-server';\n+\n const embedder = new HuggingFaceEmbeddingServerFunction({ url: \"http://localhost:8001/embed\" })\n \n // use directly\n---\ndocs/docs.trychroma.com/markdoc/content/integrations/embedding-models/jina-ai.md\n@@ -25,7 +25,9 @@ jinaai_ef(input=[\"This is my first text to embed\", \"This is my second document\"]\n {% Tab label=\"typescript\" %}\n \n ```typescript\n-import { JinaEmbeddingFunction } from 'chromadb';\n+// npm install @chroma-core/jina\n+\n+import { JinaEmbeddingFunction } from '@chroma-core/jina';\n \n const embedder = new JinaEmbeddingFunction({\n   jinaai_api_key: 'jina_****',\n---\ndocs/docs.trychroma.com/markdoc/content/integrations/embedding-models/mistral.md\n@@ -21,6 +21,21 @@ mistral_ef  = MistralEmbeddingFunction(model=\"mistral-embed\")\n mistral_ef(input=[\"document1\",\"document2\"])\n ```\n \n+{% /Tab %}\n+\n+{% Tab label=\"typescript\" %}\n+\n+```typescript\n+// npm install @chroma-core/mistral\n+\n+import { MistralEmbeddingFunction } from '@chroma-core/mistral';\n+\n+const embedder = new MistralEmbeddingFunction({\n+    apiKey: 'your-api-key', // Or set MISTRAL_API_KEY env var\n+    model: 'mistral-embed',\n+});\n+```\n+\n {% /Tab %}\n {% /Tabs %}\n \n---\ndocs/docs.trychroma.com/markdoc/content/integrations/embedding-models/ollama.md\n@@ -33,7 +33,9 @@ embeddings = ollama_ef([\"This is my first text to embed\",\n {% Tab label=\"typescript\" %}\n \n ```typescript\n-import { OllamaEmbeddingFunction } from \"chromadb\";\n+// npm install @chroma-core/ollama\n+\n+import { OllamaEmbeddingFunction } from \"@chroma-core/ollama\";\n const embedder = new OllamaEmbeddingFunction({\n     url: \"http://127.0.0.1:11434/\",\n     model: \"llama2\"\n---\ndocs/docs.trychroma.com/markdoc/content/integrations/embedding-models/openai.md\n@@ -49,10 +49,12 @@ openai_ef = embedding_functions.OpenAIEmbeddingFunction(\n \n {% Tab label=\"typescript\" %}\n \n-You can pass in an optional `model` argument, which lets you choose which OpenAI embeddings model to use. By default, Chroma uses `text-embedding-ada-002`.\n+You can pass in an optional `model` argument, which lets you choose which OpenAI embeddings model to use. By default, Chroma uses `text-embedding-3-small`.\n \n ```typescript\n-import { OpenAIEmbeddingFunction } from 'chromadb';\n+// npm install @chroma-core/openai\n+\n+import { OpenAIEmbeddingFunction } from '@chroma-core/ollama';\n \n const embeddingFunction = new OpenAIEmbeddingFunction({\n     openai_api_key: \"apiKey\",\n---\ndocs/docs.trychroma.com/markdoc/content/integrations/embedding-models/together-ai.md\n@@ -27,9 +27,11 @@ ef(input=[\"This is my first text to embed\", \"This is my second document\"])\n {% Tab label=\"typescript\" %}\n \n ```typescript\n-import { TogetherAIEmbeddingFunction } from 'chromadb';\n+// npm install @chroma-core/together-ai\n \n-process.env.CHROMA_TOGETHER_AI_API_KEY = \"<INSERT API KEY HERE>\"\n+import { TogetherAIEmbeddingFunction } from '@chroma-core/together-ai';\n+\n+process.env.TOGETHER_AI_API_KEY = \"<INSERT API KEY HERE>\"\n \n const embedder = new TogetherAIEmbeddingFunction({\n     model_name: \"togethercomputer/m2-bert-80M-32k-retrieval\",\n---\ndocs/docs.trychroma.com/markdoc/content/integrations/embedding-models/voyageai.md\n@@ -23,9 +23,14 @@ voyageai_ef(input=[\"document1\",\"document2\"])\n {% Tab label=\"typescript\" %}\n \n ```typescript\n-import { VoyageAIEmbeddingFunction } from 'chromadb';\n+// npm install @chroma-core/voyageai\n+\n+import { VoyageAIEmbeddingFunction } from '@chroma-core/voyageai';\n \n-const embedder = new VoyageAIEmbeddingFunction(\"apiKey\", \"model_name\")\n+const embedder = new VoyageAIEmbeddingFunction({\n+    apiKey: \"apiKey\", \n+    modelName: \"model_name\"\n+})\n \n // use directly\n const embeddings = embedder.generate([\"document1\",\"document2\"])\n---\n\n\n---\n\nChoice B:\nclients/js/packages/chromadb/package.json\n@@ -50,6 +50,13 @@\n     \"tsup\": \"^7.2.0\",\n     \"typescript\": \"^5.0.4\"\n   },\n+  \"optionalDependencies\": {\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+  },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n   },\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.0.0\"\n+$release = \"cli-1.1.0\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.0.0\"\n+RELEASE=\"cli-1.1.0\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\nrust/cli/src/client/collection.rs\n@@ -130,13 +130,7 @@ impl Collection {\n             self.chroma_client.tenant_id, self.chroma_client.db, self.collection_id\n         );\n \n-        let payload = AddCollectionRecordsPayload {\n-            ids,\n-            embeddings,\n-            documents,\n-            uris,\n-            metadatas,\n-        };\n+        let payload = AddCollectionRecordsPayload::new(ids, embeddings, documents, uris, metadatas);\n \n         let _response = send_request::<AddCollectionRecordsPayload, AddCollectionRecordsResponse>(\n             &self.chroma_client.host,\n---\nrust/cli/src/commands/copy.rs\n@@ -277,7 +277,7 @@ pub fn copy(args: CopyArgs) -> Result<(), CliError> {\n         if !args.all && args.collections.is_empty() {\n             return Err(CopyError::NoCollections.into());\n         }\n-        \n+\n         let (_, profile) = get_current_profile()?;\n         let (source, target) = get_target_and_destination(&args)?;\n         let (source_client, target_client, _handle) =\n---\nrust/frontend/src/server.rs\n@@ -1252,11 +1252,29 @@ async fn fork_collection(\n \n #[derive(Serialize, Deserialize, ToSchema, Debug, Clone)]\n pub struct AddCollectionRecordsPayload {\n-    pub ids: Vec<String>,\n-    pub embeddings: Option<Vec<Vec<f32>>>,\n-    pub documents: Option<Vec<Option<String>>>,\n-    pub uris: Option<Vec<Option<String>>>,\n-    pub metadatas: Option<Vec<Option<Metadata>>>,\n+    ids: Vec<String>,\n+    embeddings: Option<Vec<Vec<f32>>>,\n+    documents: Option<Vec<Option<String>>>,\n+    uris: Option<Vec<Option<String>>>,\n+    metadatas: Option<Vec<Option<Metadata>>>,\n+}\n+\n+impl AddCollectionRecordsPayload {\n+    pub fn new(\n+        ids: Vec<String>,\n+        embeddings: Option<Vec<Vec<f32>>>,\n+        documents: Option<Vec<Option<String>>>,\n+        uris: Option<Vec<Option<String>>>,\n+        metadatas: Option<Vec<Option<Metadata>>>,\n+    ) -> Self {\n+        Self {\n+            ids,\n+            embeddings,\n+            documents,\n+            uris,\n+            metadatas,\n+        }\n+    }\n }\n \n /// Adds records to a collection.\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\nChoice C:\n.github/actions/tilt/action.yaml\n@@ -10,13 +10,16 @@ runs:\n         curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v$TILT_VERSION/tilt.$TILT_VERSION.linux.x86_64.tar.gz | \\\n           tar -xzv -C /usr/local/bin tilt\n     - name: Set up kind\n-      id: kind\n-      uses: helm/kind-action@v1\n+      uses: Wandalen/wretry.action@v3.7.0\n       with:\n-        registry: true\n-        registry_name: my-registry\n-        registry_port: 5001\n-        registry_enable_delete: true\n+        action: helm/kind-action@v1\n+        attempt_limit: 3\n+        attempt_delay: 2000\n+        with: |\n+          registry: true\n+          registry_name: my-registry\n+          registry_port: 5001\n+          registry_enable_delete: true\n     - name: Add blacksmith registry mirror\n       shell: bash\n       run: |\n---\n\n\n---\n\nChoice D:\nrust/segment/src/sqlite_metadata.rs\n@@ -705,28 +705,62 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            filter_limit_query\n-                .left_join(\n+            let (references_metadata, references_document) = whr.analyze_where_references();\n+            if references_metadata {\n+                filter_limit_query.inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n-                )\n-                .left_join(\n+                );\n+            } else if metadata {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            }\n+            if references_document {\n+                filter_limit_query.inner_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n-                )\n-                .distinct()\n-                .cond_where(whr.eval());\n+                );\n+            } else if document {\n+                filter_limit_query.left_join(\n+                    EmbeddingFulltextSearch::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n+                        EmbeddingFulltextSearch::Table,\n+                        EmbeddingFulltextSearch::Rowid,\n+                    )),\n+                );\n+            }\n+            filter_limit_query.distinct().cond_where(whr.eval());\n+        } else {\n+            if metadata {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            }\n+\n+            if document {\n+                filter_limit_query.left_join(\n+                    EmbeddingFulltextSearch::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n+                        EmbeddingFulltextSearch::Table,\n+                        EmbeddingFulltextSearch::Rowid,\n+                    )),\n+                );\n+            }\n         }\n \n         filter_limit_query\n             .order_by((Embeddings::Table, Embeddings::Id), sea_query::Order::Asc)\n             .offset(skip as u64)\n             .limit(fetch.unwrap_or(u32::MAX) as u64);\n-\n         let alias = Alias::new(SUBQ_ALIAS);\n         let mut projection_query = Query::select();\n         projection_query\n---\nrust/types/src/metadata.rs\n@@ -560,6 +560,26 @@ impl Where {\n             },\n         }\n     }\n+\n+    pub fn analyze_where_references(&self) -> (bool, bool) {\n+        let mut references_metadata = false;\n+        let mut references_document = false;\n+\n+        match self {\n+            Where::Composite(expr) => {\n+                // For composite expressions, recursively check all children\n+                for child in &expr.children {\n+                    let (child_meta, child_doc) = Self::analyze_where_references(&(child.clone()));\n+                    references_metadata |= child_meta;\n+                    references_document |= child_doc;\n+                }\n+            }\n+            Where::Document(_) => references_document = true,\n+            Where::Metadata(_) => references_metadata = true,\n+        }\n+\n+        (references_metadata, references_document)\n+    }\n }\n \n impl TryFrom<chroma_proto::Where> for Where {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nOne rls gets all the compactor hate and it's spinning.\r\n\r\nEssentially, the dirty marker must be routed to the same location as the writes to said log.  Eventually.\r\n\r\nOtherwise they get misrouted and garbage piles up.\r\n\r\n## Test plan\r\n\r\nCI\r\n\r\n## Documentation Changes\r\n\r\nN/A\r\n\n\n---\n\nChoice A:\nrust/types/src/lib.rs\n@@ -23,6 +23,7 @@ mod tenant;\n mod validators;\n mod where_parsing;\n \n+pub mod optional_u128;\n pub mod regex;\n \n // Re-export the types module, so that we can use it as a single import in other modules.\n---\nrust/types/src/optional_u128.rs\n@@ -0,0 +1,74 @@\n+pub mod optional_u128_as_hex {\n+    use serde::de::Error;\n+    use serde::{Deserialize, Deserializer, Serializer};\n+\n+    /// Serializes `Option<u128>` as lowercase hex string if Some, skips if None.\n+    pub fn serialize<S>(val: &Option<u128>, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        match val {\n+            Some(v) => serializer.serialize_str(&format!(\"{:x}\", v)),\n+            None => serializer.serialize_none(),\n+        }\n+    }\n+\n+    /// Deserializes a lowercase hex string into `Option<u128>`.\n+    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<u128>, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let opt: Option<String> = Option::deserialize(deserializer)?;\n+        match opt {\n+            Some(s) => {\n+                let val = u128::from_str_radix(&s, 16).map_err(D::Error::custom)?;\n+                Ok(Some(val))\n+            }\n+            None => Ok(None),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::optional_u128_as_hex;\n+    use serde::{Deserialize, Serialize};\n+\n+    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n+    struct TestStruct {\n+        #[serde(\n+            with = \"optional_u128_as_hex\",\n+            default,\n+            skip_serializing_if = \"Option::is_none\"\n+        )]\n+        value: Option<u128>,\n+    }\n+\n+    #[test]\n+    fn test_serialize_some_u128() {\n+        let s = TestStruct { value: Some(255) };\n+        let json = serde_json::to_string(&s).unwrap();\n+        assert_eq!(json, r#\"{\"value\":\"ff\"}\"#);\n+    }\n+\n+    #[test]\n+    fn test_serialize_none() {\n+        let s = TestStruct { value: None };\n+        let json = serde_json::to_string(&s).unwrap();\n+        assert_eq!(json, r#\"{}\"#);\n+    }\n+\n+    #[test]\n+    fn test_deserialize_some_u128() {\n+        let json = r#\"{\"value\":\"ff\"}\"#;\n+        let s: TestStruct = serde_json::from_str(json).unwrap();\n+        assert_eq!(s, TestStruct { value: Some(255) });\n+    }\n+\n+    #[test]\n+    fn test_deserialize_none() {\n+        let json = r#\"{}\"#;\n+        let s: TestStruct = serde_json::from_str(json).unwrap();\n+        assert_eq!(s, TestStruct { value: None });\n+    }\n+}\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -398,9 +398,10 @@ impl DirtyMarker {\n             let num_records = rollup_pc.limit_log_position - rollup_pc.start_log_position;\n             let reinsert_count = rollup_pc.reinsert_count;\n             let initial_insertion_epoch_us = rollup_pc.initial_insertion_epoch_us;\n-            let to_compact = num_records >= record_count_threshold\n+            let to_compact = true/*\n+                || num_records >= record_count_threshold\n                 || now_us - initial_insertion_epoch_us >= timeout_us\n-                || reinsert_count >= reinsert_threshold;\n+                || reinsert_count >= reinsert_threshold*/;\n             if to_compact {\n                 compactable.push(collection_id);\n             }\n@@ -2063,6 +2064,7 @@ mod tests {\n                 },\n             ),\n         ];\n+        /*\n         assert!(DirtyMarker::rollup(\n             Arc::new(storage),\n             |storage, collection_id| async move {\n@@ -2084,6 +2086,7 @@ mod tests {\n         .await\n         .unwrap()\n         .is_none());\n+        */\n     }\n \n     #[tokio::test]\n---\n\n\n---\n\nChoice C:\nrust/log/src/grpc_log.rs\n@@ -383,9 +383,9 @@ impl GrpcLog {\n         match &mut self.alt_client_assigner {\n             Some(assigner) => assigner\n                 .clients(&collection_id.to_string())\n-                .unwrap_or_default()\n-                .first()\n-                .cloned(),\n+                .ok()?\n+                .drain(..)\n+                .next(),\n             None => None,\n         }\n     }\n---\n\n\n---\n\nChoice D:\nTiltfile\n@@ -81,22 +81,6 @@ else:\n     target='sysdb-migration'\n   )\n \n-\n-if config.tilt_subcommand == \"ci\":\n-  custom_build(\n-    'frontend-service',\n-    'docker buildx build --load -t $EXPECTED_REF -f ./Dockerfile . ',\n-    ['chromadb/', 'idl/', 'requirements.txt', 'bin/']\n-  )\n-else:\n-  docker_build(\n-    'frontend-service',\n-    '.',\n-    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/'],\n-    dockerfile='./Dockerfile',\n-    ignore=['**/*.pyc', 'chromadb/test/'],\n-  )\n-\n if config.tilt_subcommand == \"ci\":\n   custom_build(\n     'rust-frontend-service',\n@@ -239,7 +223,6 @@ k8s_resource('logservice-migration-latest', resource_deps=['postgres'], labels=[\n k8s_resource('logservice', resource_deps=['sysdb-migration-latest'], labels=[\"chroma\"], port_forwards='50052:50051')\n k8s_resource('rust-log-service', labels=[\"chroma\"], port_forwards='50054:50051')\n k8s_resource('sysdb', resource_deps=['sysdb-migration-latest'], labels=[\"chroma\"], port_forwards='50051:50051')\n-k8s_resource('frontend-service', resource_deps=['sysdb', 'logservice'],labels=[\"chroma\"], port_forwards='8000:8000')\n k8s_resource('rust-frontend-service', resource_deps=['sysdb', 'logservice', 'rust-log-service'], labels=[\"chroma\"], port_forwards='3000:8000')\n k8s_resource('query-service', resource_deps=['sysdb'], labels=[\"chroma\"], port_forwards='50053:50051')\n k8s_resource('compaction-service', resource_deps=['sysdb'], labels=[\"chroma\"])\n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.36\n+version: 0.1.37\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/frontend-service.yaml\n@@ -1,92 +0,0 @@\n-apiVersion: apps/v1\n-kind: Deployment\n-metadata:\n-  name: frontend-service\n-  namespace: {{ .Values.namespace }}\n-spec:\n-  replicas: {{ .Values.frontendService.replicaCount }}\n-  selector:\n-    matchLabels:\n-      app: frontend-service\n-  template:\n-    metadata:\n-      labels:\n-        app: frontend-service\n-    spec:\n-      containers:\n-        - name: frontend-service\n-          image: \"{{ .Values.frontendService.image.repository }}:{{ .Values.frontendService.image.tag }}\"\n-          imagePullPolicy: IfNotPresent\n-          ports:\n-            - containerPort: 8000\n-          {{ if .Values.frontendService.resources }}\n-          resources:\n-            limits:\n-              cpu: {{ .Values.frontendService.resources.limits.cpu }}\n-              memory: {{ .Values.frontendService.resources.limits.memory }}\n-            requests:\n-              cpu: {{ .Values.frontendService.resources.requests.cpu }}\n-              memory: {{ .Values.frontendService.resources.requests.memory }}\n-          {{ end }}\n-          volumeMounts:\n-            - name: chroma\n-              mountPath: /test\n-          env:\n-            - name: CHROMA_API_IMPL\n-              value: \"chromadb.api.segment.SegmentAPI\"\n-            - name: IS_PERSISTENT\n-              {{ .Values.frontendService.isPersistent }}\n-            - name: CHROMA_PRODUCER_IMPL\n-              {{ .Values.frontendService.producerImpl }}\n-            - name: CHROMA_CONSUMER_IMPL\n-              {{ .Values.frontendService.consumerImpl }}\n-            - name: CHROMA_SEGMENT_MANAGER_IMPL\n-              {{ .Values.frontendService.segmentManagerImpl }}\n-            - name: CHROMA_EXECUTOR_IMPL\n-              {{ .Values.frontendService.executorImpl }}\n-            - name: ALLOW_RESET\n-              {{ .Values.frontendService.allowReset }}\n-            - name: CHROMA_SYSDB_IMPL\n-              {{ .Values.frontendService.sysdbImpl }}\n-            - name: CHROMA_SERVER_GRPC_PORT\n-              {{ .Values.frontendService.serverGrpcPort }}\n-            - name: CHROMA_COORDINATOR_HOST\n-              {{ .Values.frontendService.coordinatorHost }}\n-            - name: CHROMA_SERVER_AUTHN_PROVIDER\n-              {{ .Values.frontendService.authnProvider }}\n-            - name: CHROMA_SERVER_AUTHZ_PROVIDER\n-              {{ .Values.frontendService.authzProvider }}\n-            - name: CHROMA_MEMBERLIST_PROVIDER_IMPL\n-              {{ .Values.frontendService.memberlistProviderImpl }}\n-            - name: CHROMA_LOGSERVICE_HOST\n-              {{ .Values.frontendService.logServiceHost }}\n-            - name: CHROMA_LOGSERVICE_PORT\n-              {{ .Values.frontendService.logServicePort }}\n-{{ .Values.frontendService.otherEnvConfig | nindent 12 }}\n-      {{if .Values.frontendService.tolerations}}\n-      tolerations:\n-        {{ toYaml .Values.frontendService.tolerations | nindent 8 }}\n-      {{ end }}\n-      {{if .Values.frontendService.nodeSelector}}\n-      nodeSelector:\n-        {{ toYaml .Values.frontendService.nodeSelector | nindent 8 }}\n-      {{ end }}\n-      volumes:\n-        - name: chroma\n-          emptyDir: {}\n-\n----\n-\n-apiVersion: v1\n-kind: Service\n-metadata:\n-  name: frontend-service\n-  namespace: {{ .Values.namespace }}\n-spec:\n-  ports:\n-    - name: server-port\n-      port: 8000\n-      targetPort: 8000\n-  selector:\n-    app: frontend-service\n-  type: ClusterIP\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -20,11 +20,6 @@ rustFrontendService:\n     - name: CONFIG_PATH\n       value: \"tilt_config.yaml\"\n \n-frontendService:\n-  otherEnvConfig: |\n-    - name: CHROMA_ALLOW_RESET\n-      value: \"true\"\n-\n queryService:\n   env:\n     - name: RUST_BACKTRACE\n---\nk8s/distributed-chroma/values.yaml\n@@ -3,39 +3,6 @@\n \n namespace: 'chroma'\n \n-frontendService:\n-  image:\n-    repository: 'frontend-service'\n-    tag: 'latest'\n-\n-  # Sometimes users (and us) want to pass values directly as flags. Sometimes, these are\n-  # populated from secrets or configMaps. So we let consumers fill these directly.\n-  # TODO we could maybe have mutually exclusive pieces of config, e.g. isPersistentValue\n-  # and isPersistentFromConfigMap or something.\n-  isPersistent: 'value: \"TRUE\"'\n-  producerImpl: 'value: \"chromadb.logservice.logservice.LogService\"'\n-  consumerImpl: 'value: \"chromadb.logservice.logservice.LogService\"'\n-  segmentManagerImpl: 'value: \"chromadb.segment.impl.manager.distributed.DistributedSegmentManager\"'\n-  executorImpl: 'value: \"chromadb.execution.executor.distributed.DistributedExecutor\"'\n-  allowReset: 'value: \"TRUE\"'\n-  sysdbImpl: 'value: \"chromadb.db.impl.grpc.client.GrpcSysDB\"'\n-  serverGrpcPort: 'value: \"50051\"'\n-  coordinatorHost: 'value: \"sysdb.chroma\"'\n-  authProvider: 'value: \"\"'\n-  authCredentialsProvider: 'value: \"\"'\n-  authzProvider: 'value: \"\"'\n-  authzConfigProvider: 'value: \"\"'\n-  memberlistProviderImpl: 'value: \"chromadb.segment.impl.distributed.segment_directory.CustomResourceMemberlistProvider\"'\n-  logServiceHost: 'value: \"logservice.chroma\"'\n-  logServicePort: 'value: \"50051\"'\n-  otherEnvConfig: |\n-    - name: CHROMA_OTEL_COLLECTION_ENDPOINT\n-      value: \"http://jaeger:4317\"\n-    - name: CHROMA_OTEL_GRANULARITY\n-      value: all\n-  replicaCount: 2\n-\n-\n rustFrontendService:\n   image:\n     repository: 'rust-frontend-service'\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nRename `collection` method to `getCollectionById` for clarity.\n\n---\n\nChoice A:\nchromadb/test/distributed/test_log_failover.py\n@@ -65,4 +65,6 @@ def test_log_failover(\n \n     for i in range(200):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n         assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -26,7 +26,7 @@ log:\n     connect_timeout_ms: 5000\n     request_timeout_ms: 60000 # 1 minute\n     alt_host: \"rust-log-service.chroma\"\n-    use_alt_host_for_everything: true\n+    alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n \n executor:\n   distributed:\n---\nrust/log/src/config.rs\n@@ -14,19 +14,20 @@ pub struct GrpcLogConfig {\n     pub max_encoding_message_size: usize,\n     #[serde(default = \"GrpcLogConfig::default_max_decoding_message_size\")]\n     pub max_decoding_message_size: usize,\n-    // NOTE(rescrv):  This is a hack to allow us to test two log services in parallel without\n-    // breaking the old service.  If alt host is specified, then the \"use_alt_host_for_everything\"\n-    // and \"use_alt_for_collections\" config parameters are consulted.  If\n-    // \"use_alt_host_for_everything\" is set (CI) or the collection being written is in the alt\n-    // collections vec (staging), then we can use the alt host.\n+    // NOTE(rescrv):  This is a hack to allow us to test migrate between two log services without\n+    // breaking things or having a hard cut-over.  If alt_host_threshold is specified, it will be\n+    // interpreted as a u128 (UUID == u128) and if the collection in question is <=\n+    // alt_host_threshold, it go to the alt-host first.\n+    //\n+    // alt tenants/collections will always initialize a new log\n     #[serde(default = \"Option::default\")]\n     pub alt_host: Option<String>,\n     #[serde(default)]\n-    pub use_alt_host_for_everything: bool,\n-    #[serde(default)]\n     pub use_alt_for_tenants: Vec<String>,\n     #[serde(default)]\n     pub use_alt_for_collections: Vec<String>,\n+    #[serde(default = \"Option::default\")]\n+    pub alt_host_threshold: Option<String>,\n }\n \n impl GrpcLogConfig {\n@@ -65,9 +66,9 @@ impl Default for GrpcLogConfig {\n             max_encoding_message_size: GrpcLogConfig::default_max_encoding_message_size(),\n             max_decoding_message_size: GrpcLogConfig::default_max_decoding_message_size(),\n             alt_host: None,\n-            use_alt_host_for_everything: false,\n             use_alt_for_tenants: vec![],\n             use_alt_for_collections: vec![],\n+            alt_host_threshold: None,\n         }\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -244,21 +244,41 @@ impl GrpcLog {\n         client_for_conn_str(connection_string)\n     }\n \n+    fn client_is_on_alt_log(to_evaluate: CollectionUuid, alt_host_threshold: Option<&str>) -> bool {\n+        if let Some(alt_host_threshold) = alt_host_threshold {\n+            let Ok(alt_host_threshold) = Uuid::parse_str(alt_host_threshold) else {\n+                tracing::error!(\"alt_host_threshold must be a valid UUID\");\n+                return false;\n+            };\n+            let to_evaluate = to_evaluate.0.as_u64_pair().0;\n+            let alt_host_threshold = alt_host_threshold.as_u64_pair().0;\n+            to_evaluate <= alt_host_threshold\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn client_for(\n         &mut self,\n         tenant: &str,\n         collection_id: CollectionUuid,\n     ) -> &mut LogServiceClient<chroma_tracing::GrpcTraceService<tonic::transport::Channel>> {\n-        let collection_id = collection_id.to_string();\n         if let Some(alt) = self.alt_client.as_mut() {\n-            if self.config.use_alt_host_for_everything\n-                || self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n-                || self.config.use_alt_for_collections.contains(&collection_id)\n+            if self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n+                || self\n+                    .config\n+                    .use_alt_for_collections\n+                    .contains(&collection_id.to_string())\n+                || Self::client_is_on_alt_log(\n+                    collection_id,\n+                    self.config.alt_host_threshold.as_deref(),\n+                )\n             {\n                 tracing::info!(\"using alt client for {collection_id}\");\n                 return alt;\n             }\n         }\n+        tracing::info!(\"using standard client for {collection_id}\");\n         &mut self.client\n     }\n \n@@ -413,7 +433,8 @@ impl GrpcLog {\n         let mut norm = self\n             ._get_collections_with_new_data(false, min_compaction_size)\n             .await?;\n-        if self.config.use_alt_host_for_everything\n+        if self.config.alt_host_threshold.is_some()\n+            || !self.config.use_alt_for_tenants.is_empty()\n             || !self.config.use_alt_for_collections.is_empty()\n         {\n             let alt = self\n@@ -524,3 +545,32 @@ impl GrpcLog {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn client_is_on_alt_log() {\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            None\n+        ));\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"00088272-cfc4-419d-997a-baebfb25034a\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"00088272-cfc4-419d-997a-baebfb25034a\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"ffffffff-ffff-ffff-ffff-ffffffffffff\"),\n+        ));\n+    }\n+}\n---\nrust/worker/tilt_config.yaml\n@@ -42,7 +42,7 @@ query_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -122,7 +122,7 @@ compaction_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -197,4 +197,4 @@ log_service:\n         connect_timeout_ms: 5000\n         request_timeout_ms: 60000 # 1 minute\n         alt_host: \"rust-log-service.chroma\"\n-        use_alt_host_for_everything: true\n+        alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n---\n\n\n---\n\nChoice B:\nrust/wal3/examples/wal3-bootstrap-reasoner.rs\n@@ -0,0 +1,182 @@\n+//! This file is not intended for public consumption, but is kept for completeness.\n+//!\n+//! In this file you will find that we reason about the bootstrap process by completely exploring\n+//! the state space and pruning known good states.  The goal is to prune every state or print a\n+//! list of states that are bad.\n+//!\n+//! This is ad-hoc machine-assisted proving without an environment or theorem prover.\n+\n+#[derive(Clone, Copy, Debug)]\n+enum FragmentState {\n+    BenignRace,\n+    Conflict,\n+    Success,\n+}\n+\n+impl FragmentState {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            FragmentState::BenignRace,\n+            FragmentState::Conflict,\n+            FragmentState::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum InitializeManifest {\n+    Uninitialized,\n+    AlreadyInitialized,\n+    Success,\n+}\n+\n+impl InitializeManifest {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            InitializeManifest::Uninitialized,\n+            InitializeManifest::AlreadyInitialized,\n+            InitializeManifest::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum RecoverManifest {\n+    Uninitialized,\n+    Failure,\n+    Success,\n+}\n+\n+impl RecoverManifest {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            RecoverManifest::Uninitialized,\n+            RecoverManifest::Failure,\n+            RecoverManifest::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+enum Disposition {\n+    /// The combination of states is considered a good case.\n+    Good,\n+    /// The combination of states is not considered by the rule.\n+    Pass,\n+    /// The case can be dropped with good conscience for not mattering.  The string is the reason.\n+    Drop(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+    /// The case must lead to an error at runtime.\n+    Panic(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+    /// The case must be raised to the user for inspection.\n+    Raise(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+}\n+\n+fn happy_paths(fs: FragmentState, im: InitializeManifest, rm: RecoverManifest) -> Disposition {\n+    match (fs, im, rm) {\n+        (\n+            FragmentState::Success | FragmentState::BenignRace,\n+            InitializeManifest::Uninitialized | InitializeManifest::Success,\n+            RecoverManifest::Success,\n+        ) => Disposition::Good,\n+        _ => Disposition::Pass,\n+    }\n+}\n+\n+fn error_paths(fs: FragmentState, im: InitializeManifest, rm: RecoverManifest) -> Disposition {\n+    match (fs, im, rm) {\n+        (_, InitializeManifest::AlreadyInitialized, _) => {\n+            Disposition::Panic(\"cannot double-initialize manifest\", fs, im, rm)\n+        }\n+        (_, _, RecoverManifest::Uninitialized) => {\n+            Disposition::Panic(\"cannot have manifest become uninitialized\", fs, im, rm)\n+        }\n+        (_, _, RecoverManifest::Failure) => {\n+            Disposition::Panic(\"failed to install recovered manifest\", fs, im, rm)\n+        }\n+        _ => Disposition::Pass,\n+    }\n+}\n+\n+fn conflict_on_fragment(\n+    fs: FragmentState,\n+    im: InitializeManifest,\n+    rm: RecoverManifest,\n+) -> Disposition {\n+    if matches!(fs, FragmentState::Conflict) {\n+        Disposition::Drop(\n+            \"no need to touch manifest if fragment conflicts\",\n+            fs,\n+            im,\n+            rm,\n+        )\n+    } else {\n+        Disposition::Pass\n+    }\n+}\n+\n+fn unconditionally_raise(\n+    fs: FragmentState,\n+    im: InitializeManifest,\n+    rm: RecoverManifest,\n+) -> Disposition {\n+    Disposition::Raise(\"unconditional raise\", fs, im, rm)\n+}\n+\n+pub fn main() {\n+    let mut states = vec![];\n+    for fs in FragmentState::all_states() {\n+        for im in InitializeManifest::all_states() {\n+            for rm in RecoverManifest::all_states() {\n+                states.push((fs, im, rm));\n+            }\n+        }\n+    }\n+    let rules = vec![\n+        happy_paths,\n+        conflict_on_fragment,\n+        error_paths,\n+        unconditionally_raise,\n+    ];\n+    for state in states.iter() {\n+        for rule in &rules {\n+            match (rule)(state.0, state.1, state.2) {\n+                Disposition::Pass => {}\n+                Disposition::Good => {\n+                    break;\n+                }\n+                Disposition::Panic(reason, fs, im, rm) => {\n+                    println!(\"panic({fs:?}, {im:?}, {rm:?}) -> {reason}\");\n+                    break;\n+                }\n+                Disposition::Drop(reason, fs, im, rm) => {\n+                    _ = reason;\n+                    _ = fs;\n+                    _ = im;\n+                    _ = rm;\n+                    break;\n+                }\n+                Disposition::Raise(reason, fs, im, rm) => {\n+                    println!(\"raise({fs:?}, {im:?}, {rm:?}) -> {reason}\");\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n---\n\n\n---\n\nChoice C:\nclients/new-js/packages/chromadb/src/chroma-client.ts\n@@ -411,7 +411,7 @@ export class ChromaClient {\n    * @param options.embeddingFunction - Optional embedding function to use\n    * @returns A CollectionAPI instance for the specified collection\n    */\n-  public collection({\n+  public getCollectionById({\n     id,\n     embeddingFunction,\n   }: {\n@@ -431,7 +431,7 @@ export class ChromaClient {\n    * @param items - Array of collection IDs or objects with ID and optional embedding function\n    * @returns Array of CollectionAPI instances\n    */\n-  public collections(\n+  public getCollectionsById(\n     items: string[] | { id: string; embeddingFunction?: EmbeddingFunction }[],\n   ) {\n     if (items.length === 0) return [];\n---\ndocs/docs.trychroma.com/markdoc/content/docs/collections/create-get-delete.md\n@@ -109,10 +109,10 @@ const [col1, col2] = client.getCollections([\n ])\n ```\n \n-The `getCollection` and `getCollections` methods issue an API call to a Chroma server to get collections with all their fields. If you only need access to collection actions on records and want to save the API call, you can get a \"thin\" collection object using the `collection` method. It takes in a collection **ID** and an embedding function.\n+The `getCollection` and `getCollections` methods issue an API call to a Chroma server to get collections with all their fields. If you only need access to collection actions on records, and want to save the API call, you can get a \"thin\" collection object using the `getCollectionById` method (and `getCollectionsById`). It takes in a collection **ID** and an embedding function.\n \n ```typescript\n-const collection = client.collection({ id: 'abc', embeddingFunction: openaiEF })\n+const collection = client.getCollectionById({ id: 'abc', embeddingFunction: openaiEF })\n ```\n \n You can also delete collections by name using `deleteCollection`:\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -339,11 +339,16 @@ impl RollupPerCollection {\n             std::cmp::max(self.initial_insertion_epoch_us, initial_insertion_epoch_us);\n     }\n \n-    fn witness_manifest_and_cursor(&mut self, manifest: &Manifest, witness: Option<&Witness>) {\n+    fn witness_cursor(&mut self, witness: Option<&Witness>) {\n+        // NOTE(rescrv):  There's an easy dance here to justify this as correct.  For the start log\n+        // position to advance, there must have been at least one GC cycle with a cursor that was\n+        // something other than 1.  That cursor should never get deleted, therefore we have a\n+        // witness and the unwrap_or call 0x90s.\n+        //\n+        // The consequence of this breaking is that the offset in the log will be behind sysdb.\n         self.start_log_position = witness\n             .map(|x| x.1.position)\n-            .unwrap_or(manifest.minimum_log_position());\n-        self.limit_log_position = manifest.maximum_log_position();\n+            .unwrap_or(LogPosition::from_offset(1));\n     }\n \n     fn is_empty(&self) -> bool {\n@@ -999,15 +1004,6 @@ impl LogServer {\n         &self,\n         rollups: &mut HashMap<CollectionUuid, RollupPerCollection>,\n     ) -> Result<(), Error> {\n-        let load_manifest = |storage, collection_id| async move {\n-            let reader = LogReader::new(\n-                LogReaderOptions::default(),\n-                Arc::clone(storage),\n-                storage_prefix_for_log(collection_id),\n-            );\n-            let span = tracing::info_span!(\"manifest load\", collection_id = ?collection_id);\n-            reader.manifest().instrument(span).await\n-        };\n         let load_cursor = |storage, collection_id| async move {\n             let cursor = &COMPACTION;\n             let cursor_store = CursorStore::new(\n@@ -1020,18 +1016,12 @@ impl LogServer {\n             cursor_store.load(cursor).instrument(span).await\n         };\n         for (collection_id, mut rollup) in std::mem::take(rollups) {\n-            // TODO(rescrv):  We can avoid loading the manifest and cursor by checking an\n-            // in-memory lookaside structure.\n-            let Some(manifest) = load_manifest(&self.storage, collection_id).await? else {\n-                tracing::warn!(\"{collection_id} has no manifest; this may mean it was deleted\");\n-                continue;\n-            };\n             let cursor = load_cursor(&self.storage, collection_id).await?;\n             // NOTE(rescrv):  There are two spreads that we have.\n             // `rollup` tracks the minimum and maximum offsets of a record on the dirty log.\n             // The spread between cursor (if it exists) and manifest.maximum_log_offset tracks the\n             // data that needs to be compacted.\n-            rollup.witness_manifest_and_cursor(&manifest, cursor.as_ref());\n+            rollup.witness_cursor(cursor.as_ref());\n             if !rollup.is_empty() {\n                 rollups.insert(collection_id, rollup);\n             }\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nFixes a few broken URLs\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -1484,6 +1484,7 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n         ALL_MINILM_L6_V2,\n         1_000_000,\n     )));\n+    data_sets.push(Arc::clone(&reference_data_set) as _);\n     data_sets.push(Arc::new(VerifyingDataSet {\n         reference_data_set,\n         test_data_set: \"test-all-MiniLM-L6-v2\".to_string(),\n---\n\n\n---\n\nChoice B:\nrust/cache/src/foyer.rs\n@@ -94,8 +94,17 @@ const fn default_trace_fetch_us() -> usize {\n     1000 * 100\n }\n \n+fn default_name() -> String {\n+    String::from(\"foyer\")\n+}\n+\n #[derive(Deserialize, Debug, Clone, Serialize, Parser)]\n pub struct FoyerCacheConfig {\n+    /// Name of the cache. All metrics for the cache are prefixed with name_.\n+    #[arg(long, default_value = \"foyer\")]\n+    #[serde(default = \"default_name\")]\n+    pub name: String,\n+\n     /// Directory for disk cache data.\n     #[arg(short, long)]\n     pub dir: Option<String>,\n@@ -262,6 +271,7 @@ impl FoyerCacheConfig {\n impl Default for FoyerCacheConfig {\n     fn default() -> Self {\n         FoyerCacheConfig {\n+            name: default_name(),\n             dir: None,\n             capacity: default_capacity(),\n             mem: default_mem(),\n@@ -352,6 +362,7 @@ where\n             ),\n         );\n         let builder = HybridCacheBuilder::<K, V>::new()\n+            .with_name(config.name.clone())\n             .with_metrics_registry(otel_0_27_metrics)\n             .with_tracing_options(tracing_options.clone())\n             .with_policy(foyer::HybridCachePolicy::WriteOnInsertion)\n@@ -537,6 +548,7 @@ where\n         config: &FoyerCacheConfig,\n     ) -> Result<FoyerPlainCache<K, V>, Box<dyn ChromaError>> {\n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .build();\n@@ -590,6 +602,7 @@ where\n         let evl = TokioEventListener(tx);\n \n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .with_event_listener(Arc::new(evl))\n---\nrust/frontend/sample_configs/distributed.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/worker/chroma_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     disk:\n+                        name: \"block_cache\"\n                         dir: \"/cache/chroma/query-service/block-cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n@@ -72,11 +73,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n \n@@ -138,15 +141,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\nrust/worker/tilt_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 block_cache_config:\n                     disk:\n                         dir: \"/cache/chroma/query-service/block-cache\"\n+                        name: \"block_cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n                         mem: 8000 # 8GiB\n@@ -71,11 +72,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n     fetch_log_batch_size: 1000\n@@ -141,15 +144,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\n\n\n---\n\nChoice C:\nchromadb/test/distributed/test_log_failover.py\n@@ -189,3 +189,99 @@ def test_log_failover_with_compaction(\n             assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n         else:\n             assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_query_operations(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    # Add initial RECORDS records with known embeddings for querying\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Perform baseline similarity queries before failover\n+    query_embeddings = [embeddings[0], embeddings[RECORDS//2], embeddings[-1]]\n+    baseline_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        baseline_results.append(result)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Trigger log failover\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Re-run the same queries after failover and verify results consistency\n+    post_failover_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        post_failover_results.append(result)\n+\n+    # Verify that query results are consistent before and after failover\n+    for i, (baseline, post_failover) in enumerate(zip(baseline_results, post_failover_results)):\n+        assert len(baseline[\"ids\"][0]) == len(post_failover[\"ids\"][0]), f\"Query {i} returned different number of results\"\n+        assert baseline[\"ids\"][0] == post_failover[\"ids\"][0], f\"Query {i} returned different IDs\"\n+        # Verify embeddings match (allowing for small floating point differences)\n+        for j, (base_emb, post_emb) in enumerate(zip(baseline[\"embeddings\"][0], post_failover[\"embeddings\"][0])):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(base_emb, post_emb)]), f\"Query {i} result {j} embeddings differ\"\n+\n+    # Add more data post-failover\n+    post_failover_start = RECORDS\n+    for i in range(post_failover_start, post_failover_start + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Query for both old and new data to ensure full functionality\n+    # Test that we can find old data\n+    old_data_query = collection.query(\n+        query_embeddings=[embeddings[0]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(old_data_query[\"ids\"][0]) == 3, \"Failed to query old data after failover\"\n+\n+    # Test that we can find new data\n+    new_data_query = collection.query(\n+        query_embeddings=[embeddings[-1]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(new_data_query[\"ids\"][0]) == 3, \"Failed to query new data after failover\"\n+\n+    # Verify all data is still accessible by ID\n+    for i in range(len(ids)):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        assert len(result[\"embeddings\"]) > 0, f\"Missing result for ID {i} after failover with new data\"\n+        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])]), f\"Embedding mismatch for ID {i}\"\n---\n\n\n---\n\nChoice D:\ndocs/docs.trychroma.com/markdoc/content/integrations/frameworks/llamaindex.md\n@@ -6,5 +6,5 @@ name: LlamaIndex\n # LlamaIndex\n \n - `LlamaIndex` [Vector Store page](https://docs.llamaindex.ai/en/stable/examples/vector_stores/ChromaIndexDemo.html)\n-- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n-- [Chroma Loader on Llamahub](https://llamahub.ai/l/chroma)\n+- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n+- [Chroma Loader on Llamahub](https://llamahub.ai/l/vector_stores/llama-index-vector-stores-chroma)\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis creates a variable named err, then within the function creates a new variable named err and\nreturns nil when the function exits.\n\n```go\nfunc foo() (err error) {\n    x, err := some_func()\n    return\n}\n```\n\n## Test plan\n\nEyeballs and elbow grease to get it to CI.\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/load/src/bin/chroma-load-start.rs\n@@ -24,8 +24,6 @@ struct Args {\n     #[arg(long)]\n     database: String,\n     #[arg(long)]\n-    api_key: String,\n-    #[arg(long)]\n     constant_throughput: Option<f64>,\n     #[arg(long)]\n     sinusoid_throughput: Option<String>,\n@@ -90,6 +88,10 @@ impl Args {\n #[tokio::main]\n async fn main() {\n     let args = Args::parse();\n+\n+    // Read API key from environment variable.\n+    let api_key = std::env::var(\"CHROMA_API_KEY\").expect(\"CHROMA_API_KEY is not set\");\n+\n     let client = reqwest::Client::new();\n     let throughput = args.throughput();\n     let mut workload = Workload::ByName(args.workload);\n@@ -108,7 +110,7 @@ async fn main() {\n         data_set: args.data_set,\n         connection: Connection {\n             url: args.url,\n-            api_key: args.api_key,\n+            api_key,\n             database: args.database,\n         },\n         throughput,\n---\nrust/load/src/lib.rs\n@@ -1026,8 +1026,16 @@ pub struct LoadHarness {\n \n impl LoadHarness {\n     /// The status of the load harness.\n+    /// This returns the list of running workloads with secrets redacted.\n     pub fn status(&self) -> Vec<RunningWorkload> {\n-        self.running.clone()\n+        self.running\n+            .iter()\n+            .map(|w| {\n+                let mut w = w.clone();\n+                w.connection.api_key = \"REDACTED\".to_string();\n+                w\n+            })\n+            .collect()\n     }\n \n     /// Start a workload on the load harness.\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/repository/log.go\n@@ -168,7 +168,8 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\t}\n \t}()\n \n-\tsourceBounds, err := queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n+\tvar sourceBounds log.GetBoundsForCollectionRow\n+\tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in getting compaction and enumeration offset for source collection\", zap.Error(err), zap.String(\"collectionId\", sourceCollectionID))\n \t\treturn\n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.2\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.1.2\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.2\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.2\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.2\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.3\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.1.3\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.3\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.3\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.3\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -376,6 +376,8 @@ impl DirtyMarker {\n         timeout_us: u64,\n         metrics: &Metrics,\n     ) -> Result<Option<Rollup>, wal3::Error> {\n+        let cpu_span = tracing::info_span!(\"cpu computation\");\n+        let cpu_span_guard = cpu_span.enter();\n         // NOTE(rescrv);  This is complicated code because it's a hard problem to do efficiently.\n         // To cut complexity, I've chosen to do it in a way that is not the most efficient but is\n         // readable and maintainable.  The most efficient way would be to do this in a single pass.\n@@ -420,6 +422,7 @@ impl DirtyMarker {\n         if compactable.is_empty() {\n             return Ok(None);\n         }\n+        drop(cpu_span_guard);\n         // Now fetch the compaction cursor for each collection.\n         let retrieve_manifest = Arc::new(retrieve_manifest);\n         let retrieve_cursor = Arc::new(retrieve_cursor);\n@@ -435,8 +438,10 @@ impl DirtyMarker {\n             })\n             .map(\n                 |(collection_id, storage, retrieve_manifest, retrieve_cursor)| async move {\n-                    let cursor = (*retrieve_cursor)(Arc::clone(&storage), collection_id);\n-                    let manifest = (*retrieve_manifest)(Arc::clone(&storage), collection_id);\n+                    let cursor = (*retrieve_cursor)(Arc::clone(&storage), collection_id)\n+                        .instrument(tracing::info_span!(\"fetching cursor\"));\n+                    let manifest = (*retrieve_manifest)(Arc::clone(&storage), collection_id)\n+                        .instrument(tracing::info_span!(\"fetching manifest\"));\n                     let (cursor, manifest) = futures::future::join(cursor, manifest).await;\n                     // NOTE(rescrv):  We silence the error so we log it instead.\n                     let cursor = match cursor {\n@@ -458,7 +463,12 @@ impl DirtyMarker {\n                 },\n             )\n             .collect::<Vec<_>>();\n-        let cursors = futures::future::join_all(futs).await;\n+        let rollup_span = tracing::info_span!(\"fetching cursors and manifests\");\n+        let cursors = futures::future::join_all(futs)\n+            .instrument(rollup_span)\n+            .await;\n+        let reprise_cpu_span = tracing::info_span!(\"cpu computation reprise\");\n+        let _reprise_cpu_span_guard = reprise_cpu_span.enter();\n         let cursors = cursors\n             .into_iter()\n             .flat_map(Result::ok)\n@@ -1361,6 +1371,7 @@ impl LogService for LogServer {\n                 );\n                 cursor_store.load(cursor).await\n             };\n+            let rollup_span = tracing::info_span!(\"DirtyMarker::rollup\");\n             let rollup = DirtyMarker::rollup(\n                 Arc::clone(&self.storage),\n                 load_manifest,\n@@ -1375,6 +1386,7 @@ impl LogService for LogServer {\n                 self.config.timeout_us,\n                 &self.metrics,\n             )\n+            .instrument(rollup_span)\n             .await\n             .map_err(|err| Status::unavailable(err.to_string()))?;\n             let Some(rollup) = rollup else {\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIn darkmode, markdoc table borders did not have a dark mode color assignment.\r\n\r\nLikewise, in dark mode, the hover state of the HeaderNav MenuItems had no darkmode assignment.\r\n\r\nFinally, this adds overflow to the HeaderNav and prevents MenuItems from wrapping.\r\n<img width=\"499\" alt=\"Screenshot 2025-06-03 at 3 08 40\u202fPM\" src=\"https://github.com/user-attachments/assets/503b69e5-82f1-4767-b5a0-b999ab325e58\" />\r\n\n\n---\n\nChoice A:\ndocs/docs.trychroma.com/components/header/header-nav.tsx\n@@ -1,17 +1,8 @@\n 'use client'\n \n import React from \"react\";\n-import Logo from \"@/components/header/logo\";\n-import ThemeToggle from \"@/components/header/theme-toggle\";\n-import GithubLink from \"@/components/header/github-link\";\n-import XLink from \"@/components/header/x-link\";\n-import DiscordLink from \"@/components/header/discord-link\";\n-import Link from \"next/link\";\n-import SearchBox from \"@/components/header/search-box\";\n-import UpdatesLink from \"@/components/header/updates-link\";\n import sidebarConfig from \"@/markdoc/content/sidebar-config\";\n import MenuItem from \"../sidebar/menu-item\";\n-import { useRouter } from \"next/router\";\n import { useParams } from \"next/navigation\";\n \n const HeaderNav: React.FC = () => {\n@@ -22,7 +13,7 @@ const HeaderNav: React.FC = () => {\n   );\n \n   return (\n-    <div className=\"flex items-center flex-shrink-0 px-5 border-b-[1px] dark:border-gray-700 \">\n+    <div className=\"flex items-center flex-shrink-0 px-5 border-b-[1px] dark:border-gray-700 w-full overflow-x-auto\">\n       {sidebarConfig.map((section) => (\n       <MenuItem\n       key={section.id}\n---\ndocs/docs.trychroma.com/components/markdoc/table.tsx\n@@ -13,7 +13,7 @@ export const Table = React.forwardRef<\n   React.HTMLAttributes<HTMLTableElement>\n >(({ ...props }, ref) => {\n   return (\n-    <div className=\"relative w-full overflow-auto rounded-md my-5 border-[0.5px] border-gray-300\">\n+    <div className=\"relative w-full overflow-auto rounded-md my-5 border-[0.5px] border-gray-300 dark:border-gray-700\">\n       <UITable ref={ref} className=\"m-0\" {...props} />\n     </div>\n   );\n---\ndocs/docs.trychroma.com/components/sidebar/menu-item.tsx\n@@ -10,7 +10,7 @@ const MenuItem: React.FC<{ section: AppSection; active: boolean }> = ({\n \n   return (\n     <Link\n-     className={`border-b-4 h-12 px-3 pt-3 pr-5 text-gray-700/80 ${active ? \"border-chroma-orange \" : \"border-transparent hover:border-gray-100\"} ${!section.disable && \"hover:text-gray-800\"} dark:text-gray-400/80 dark:hover:text-gray-300`}\n+     className={`border-b-4 h-12 px-3 pt-3 pr-5 text-gray-700/80 ${active ? \"border-chroma-orange \" : \"border-transparent hover:border-gray-100 dark:hover:border-gray-300\"} ${!section.disable && \"hover:text-gray-800\"} dark:text-gray-400/80 dark:hover:text-gray-300 text-nowrap`}\n       href={\n         section.disable\n           ? \"\"\n---\ndocs/docs.trychroma.com/components/ui/table.tsx\n@@ -58,7 +58,7 @@ const TableRow = React.forwardRef<\n   <tr\n     ref={ref}\n     className={cn(\n-      \"border-b transition-colors data-[state=selected]:bg-zinc-100 dark:data-[state=selected]:bg-zinc-800\",\n+      \"border-b transition-colors data-[state=selected]:bg-zinc-100 dark:data-[state=selected]:bg-zinc-800 dark:border-gray-700\",\n       className,\n     )}\n     {...props}\n---\n\n\n---\n\nChoice B:\nchromadb/test/property/test_fork.py\n@@ -21,6 +21,10 @@\n from overrides import overrides\n from typing import Dict, cast, Union, Tuple, Set\n \n+import grpc\n+from chromadb.proto.logservice_pb2 import SealLogRequest\n+from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n collection_st = hyst.shared(strategies.collections(with_hnsw_params=True), key=\"source\")\n \n \n@@ -38,6 +42,10 @@ def __init__(self, client: chromadb.api.ClientAPI):\n         self.client = client\n         self.collection_names = set()\n \n+        # Create go log service client\n+        channel = grpc.insecure_channel(\"localhost:50052\")\n+        self.go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n     @initialize(collection=collection_st, target=updated_collections)\n     def initialize(\n         self, collection: strategies.Collection\n@@ -77,12 +85,14 @@ def fork(\n     @rule(\n         cursor=consumes(forked_collections),\n         delta=strategies.recordsets(collection_st),\n+        seal=hyst.booleans(),\n         target=updated_collections,\n     )\n     def upsert(\n         self,\n         cursor: Tuple[Collection, strategies.StateMachineRecordSet],\n         delta: strategies.RecordSet,\n+        seal: bool,\n     ) -> Tuple[Collection, strategies.StateMachineRecordSet]:\n         collection, record_set_state = cursor\n         normalized_delta: strategies.NormalizedRecordSet = invariants.wrap_all(delta)\n@@ -148,6 +158,8 @@ def upsert(\n                     )\n                 else:\n                     record_set_state[\"documents\"].append(None)\n+        if seal:\n+            self.go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n         return collection, record_set_state\n \n     @rule(\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -215,7 +215,18 @@ async fn get_log_from_handle<'a>(\n     prefix: &str,\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n-    let mut active = handle.active.lock().await;\n+    let active = handle.active.lock().await;\n+    get_log_from_handle_with_mutex_held(handle, active, options, storage, prefix, mark_dirty).await\n+}\n+\n+async fn get_log_from_handle_with_mutex_held<'a>(\n+    handle: &'a crate::state_hash_table::Handle<LogKey, LogStub>,\n+    mut active: tokio::sync::MutexGuard<'_, ActiveLog>,\n+    options: &LogWriterOptions,\n+    storage: &Arc<Storage>,\n+    prefix: &str,\n+    mark_dirty: MarkDirty,\n+) -> Result<LogRef<'a>, wal3::Error> {\n     if active.log.is_some() {\n         active.keep_alive(Duration::from_secs(60));\n     }\n@@ -519,7 +530,12 @@ impl LogServer {\n         // Grab a lock on the state for this key, so that a racing initialize won't do anything.\n         let key = LogKey { collection_id };\n         let handle = self.open_logs.get_or_create_state(key);\n-        let mut _active = handle.active.lock().await;\n+        let active = handle.active.lock().await;\n+\n+        // Someone already initialized the log on a prior call.\n+        if active.log.is_some() {\n+            return Ok(());\n+        }\n \n         tracing::info!(\"log transfer to {collection_id}\");\n         let scout_request = Request::new(ScoutLogsRequest {\n@@ -641,6 +657,23 @@ impl LogServer {\n             log_offset: start as i64 - 1,\n         }))\n         .await?;\n+        // Set it up so that once we release the mutex, the next person won't do I/O and will\n+        // immediately be able to push logs.\n+        let storage_prefix = storage_prefix_for_log(collection_id);\n+        let mark_dirty = MarkDirty {\n+            collection_id,\n+            dirty_log: Arc::clone(&self.dirty_log),\n+        };\n+        // If this fails, the next writer will load manifest and continue unimpeded.\n+        let _ = get_log_from_handle_with_mutex_held(\n+            &handle,\n+            active,\n+            &self.config.writer,\n+            &self.storage,\n+            &storage_prefix,\n+            mark_dirty,\n+        )\n+        .await;\n         Ok(())\n     }\n \n---\n\n\n---\n\nChoice D:\n.github/actions/tilt/action.yaml\n@@ -6,18 +6,31 @@ runs:\n     - name: Install Tilt\n       shell: bash\n       run: |\n-        TILT_VERSION=\"0.33.3\"\n+        TILT_VERSION=\"0.34.2\"\n         curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v$TILT_VERSION/tilt.$TILT_VERSION.linux.x86_64.tar.gz | \\\n           tar -xzv -C /usr/local/bin tilt\n-    - name: Install ctlptlc\n-      shell: bash\n-      run: |\n-        CTLPTL_VERSION=\"0.8.20\"\n-        curl -fsSL https://github.com/tilt-dev/ctlptl/releases/download/v$CTLPTL_VERSION/ctlptl.$CTLPTL_VERSION.linux.x86_64.tar.gz | \\\n-          tar -xzv -C /usr/local/bin ctlptl\n     - name: Set up kind\n+      id: kind\n+      uses: helm/kind-action@v1\n+      with:\n+        registry: true\n+        registry_name: my-registry\n+        registry_port: 5001\n+        registry_enable_delete: true\n+    - name: Add blacksmith registry mirror\n       shell: bash\n-      run: ctlptl create cluster kind --registry=ctlptl-registry\n+      run: |\n+        REGISTRY_DIR=\"/etc/containerd/certs.d/docker.io\"\n+        for node in $(kind get nodes -n chart-testing); do\n+          docker exec \"${node}\" mkdir -p \"${REGISTRY_DIR}\"\n+          cat <<EOF | docker exec -i \"${node}\" cp /dev/stdin \"${REGISTRY_DIR}/hosts.toml\"\n+        server = \"http://192.168.127.1:5000\"\n+        [host.\"http://192.168.127.1:5000\"]\n+          capabilities = [\"pull\", \"resolve\"]\n+        EOF\n+          echo \"Added registry mirror to ${node}:\"\n+          docker exec \"${node}\" cat \"${REGISTRY_DIR}/hosts.toml\"\n+        done\n     - name: Start Tilt\n       shell: bash\n       run: tilt ci\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nsend a box\n\n---\n\nChoice A:\nrust/system/src/types.rs\n@@ -359,6 +359,11 @@ mod tests {\n         counter: Arc<AtomicUsize>,\n     }\n \n+    #[derive(Debug)]\n+    struct AStruct {\n+        value: usize,\n+    }\n+\n     impl TestComponent {\n         fn new(queue_size: usize, counter: Arc<AtomicUsize>) -> Self {\n             TestComponent {\n@@ -376,6 +381,19 @@ mod tests {\n             self.counter.fetch_add(message, Ordering::SeqCst);\n         }\n     }\n+    #[async_trait]\n+    impl Handler<Box<AStruct>> for TestComponent {\n+        type Result = ();\n+\n+        async fn handle(\n+            &mut self,\n+            message: Box<AStruct>,\n+            _ctx: &ComponentContext<TestComponent>,\n+        ) -> () {\n+            self.counter.fetch_add(message.value, Ordering::SeqCst);\n+        }\n+    }\n+\n     impl StreamHandler<usize> for TestComponent {}\n \n     #[async_trait]\n@@ -429,4 +447,16 @@ mod tests {\n         // Expected to panic\n         handle.consume().await.unwrap();\n     }\n+\n+    #[tokio::test]\n+    async fn it_can_recieve_a_box() {\n+        let system = System::new();\n+        let counter = Arc::new(AtomicUsize::new(0));\n+        let component = TestComponent::new(10, counter.clone());\n+        let mut handle = system.start_component(component);\n+        handle\n+            .send(Box::new(AStruct { value: 5 }), None)\n+            .await\n+            .unwrap();\n+    }\n }\n---\n\n\n---\n\nChoice B:\nrust/load/src/data_sets.rs\n@@ -836,12 +836,12 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            let key = uq.key.select_from_reference(self, offset);\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n             if !keys.contains(&key) {\n                 keys.push(key);\n             }\n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/server.rs\n@@ -1209,7 +1209,7 @@ pub struct ForkCollectionPayload {\n     )\n )]\n async fn fork_collection(\n-    _headers: HeaderMap,\n+    headers: HeaderMap,\n     Path((tenant, database, collection_id)): Path<(String, String, String)>,\n     State(mut server): State<FrontendServer>,\n     Json(payload): Json<ForkCollectionPayload>,\n@@ -1224,19 +1224,17 @@ async fn fork_collection(\n     tracing::info!(\n         \"Forking collection [{collection_id}] in database [{database}] for tenant [{tenant}]\"\n     );\n-    // NOTE: The quota check if skipped for fork collection for now, and we rely on the scorecard to limit access to certain tenents\n-    // TODO: Unify the quota and scorecard\n-    // server\n-    //     .authenticate_and_authorize(\n-    //         &headers,\n-    //         AuthzAction::ForkCollection,\n-    //         AuthzResource {\n-    //             tenant: Some(tenant.clone()),\n-    //             database: Some(database.clone()),\n-    //             collection: Some(collection_id.clone()),\n-    //         },\n-    //     )\n-    //     .await?;\n+    server\n+        .authenticate_and_authorize(\n+            &headers,\n+            AuthzAction::ForkCollection,\n+            AuthzResource {\n+                tenant: Some(tenant.clone()),\n+                database: Some(database.clone()),\n+                collection: Some(collection_id.clone()),\n+            },\n+        )\n+        .await?;\n     let _guard =\n         server.scorecard_request(&[\"op:fork_collection\", format!(\"tenant:{}\", tenant).as_str()])?;\n     let collection_id =\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nReading this code, it seems it should always preserve the offsets from the source on the\ndestination, but it takes the max of what's in the record table.\n\n## Test plan\n\nCI\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/test/property/test_fork.py\n@@ -189,3 +189,31 @@ def verify(\n def test_fork(caplog: pytest.LogCaptureFixture, client: chromadb.api.ClientAPI) -> None:\n     caplog.set_level(logging.ERROR)\n     run_state_machine_as_test(lambda: ForkStateMachine(client))  # type: ignore\n+\n+\n+@skip_if_not_cluster()\n+def test_fork_with_log_migration(\n+    caplog: pytest.LogCaptureFixture, client: chromadb.api.ClientAPI\n+) -> None:\n+    import grpc\n+    from chromadb.proto.logservice_pb2 import SealLogRequest\n+    from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n+    caplog.set_level(logging.ERROR)\n+    client.reset()\n+    channel = grpc.insecure_channel(\"localhost:50052\")\n+    go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n+    collection = client.create_collection(\"legacy-go-collection-0\")\n+    ids = [f\"id_{i}\" for i in range(6)]\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n+    fork_collection = collection.fork(\"fork-legacy-go-collection-0\")\n+    assert sorted(fork_collection.get()[\"ids\"]) == ids\n+\n+    collection = client.create_collection(\"legacy-go-collection-1\")\n+    go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n+    ids = [f\"id_{i}\" for i in range(6)]\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    fork_collection = collection.fork(\"fork-legacy-go-collection-1\")\n+    assert sorted(fork_collection.get()[\"ids\"]) == ids\n---\n\n\n---\n\nChoice B:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -835,7 +841,10 @@ impl DataSet for ReferencingDataSet {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/server.rs\n@@ -290,14 +290,23 @@ impl FrontendServer {\n         if let Some(cors_allow_origins) = cors_allow_origins {\n             let origins = cors_allow_origins\n                 .into_iter()\n-                .map(|origin| origin.parse().unwrap())\n+                .map(|origin| {\n+                    origin\n+                        .parse()\n+                        .unwrap_or_else(|_| panic!(\"Invalid origin: {}\", origin))\n+                })\n                 .collect::<Vec<_>>();\n \n-            let cors = CorsLayer::new()\n-                .allow_origin(origins)\n+            let mut cors_builder = CorsLayer::new()\n                 .allow_headers(tower_http::cors::Any)\n                 .allow_methods(tower_http::cors::Any);\n-            app = app.layer(cors);\n+            if origins.len() == 1 && origins[0] == \"*\" {\n+                cors_builder = cors_builder.allow_origin(tower_http::cors::Any);\n+            } else {\n+                cors_builder = cors_builder.allow_origin(origins);\n+            }\n+\n+            app = app.layer(cors_builder);\n         }\n \n         // TODO: tracing\n@@ -1972,6 +1981,54 @@ mod tests {\n         assert_eq!(allow_headers.unwrap(), \"*\");\n     }\n \n+    #[tokio::test]\n+    async fn test_cors_wildcard() {\n+        let registry = Registry::new();\n+        let system = System::new();\n+\n+        let port = random_port::PortPicker::new().pick().unwrap();\n+\n+        let mut config = FrontendServerConfig::single_node_default();\n+        config.port = port;\n+        config.cors_allow_origins = Some(vec![\"*\".to_string()]);\n+\n+        let frontend = Frontend::try_from_config(&(config.clone().frontend, system), &registry)\n+            .await\n+            .unwrap();\n+        let app = FrontendServer::new(\n+            config,\n+            frontend,\n+            vec![],\n+            Arc::new(()),\n+            Arc::new(()),\n+            System::new(),\n+        );\n+        tokio::task::spawn(async move {\n+            app.run().await;\n+        });\n+\n+        let client = reqwest::Client::new();\n+        let res = client\n+            .request(\n+                reqwest::Method::OPTIONS,\n+                format!(\"http://localhost:{}/api/v2/heartbeat\", port),\n+            )\n+            .header(\"Origin\", \"http://localhost:3000\")\n+            .send()\n+            .await\n+            .unwrap();\n+        assert_eq!(res.status(), 200);\n+\n+        let allow_origin = res.headers().get(\"Access-Control-Allow-Origin\");\n+        assert_eq!(allow_origin.unwrap(), \"*\");\n+\n+        let allow_methods = res.headers().get(\"Access-Control-Allow-Methods\");\n+        assert_eq!(allow_methods.unwrap(), \"*\");\n+\n+        let allow_headers = res.headers().get(\"Access-Control-Allow-Headers\");\n+        assert_eq!(allow_headers.unwrap(), \"*\");\n+    }\n+\n     #[tokio::test]\n     async fn test_defaults_to_json_content_type() {\n         let port = test_server().await;\n---\n\n\n---\n\nChoice D:\ngo/pkg/log/repository/log.go\n@@ -153,6 +153,17 @@ func (r *LogRepository) PullRecords(ctx context.Context, collectionId string, of\n }\n \n func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID string, targetCollectionID string) (compactionOffset uint64, enumerationOffset uint64, err error) {\n+\tfor retries := 0; retries < 3; retries++ {\n+\t\tcompactionOffset, enumerationOffset, err = r.innerForkRecords(ctx, sourceCollectionID, targetCollectionID)\n+\t\tif err == nil {\n+\t\t\treturn\n+\t\t}\n+\t\ttime.Sleep(time.Millisecond * 100 * (1 << retries))\n+\t}\n+\treturn\n+}\n+\n+func (r *LogRepository) innerForkRecords(ctx context.Context, sourceCollectionID string, targetCollectionID string) (compactionOffset uint64, enumerationOffset uint64, err error) {\n \tvar tx pgx.Tx\n \ttx, err = r.conn.BeginTx(ctx, pgx.TxOptions{})\n \tif err != nil {\n@@ -168,7 +179,8 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\t}\n \t}()\n \n-\tsourceBounds, err := queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n+\tvar sourceBounds log.GetBoundsForCollectionRow\n+\tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in getting compaction and enumeration offset for source collection\", zap.Error(err), zap.String(\"collectionId\", sourceCollectionID))\n \t\treturn\n@@ -181,36 +193,37 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\ttrace_log.Error(\"Error forking log record\", zap.String(\"sourceCollectionID\", sourceCollectionID))\n \t\treturn\n \t}\n-\ttargetBounds, err := queriesWithTx.GetMinimumMaximumOffsetForCollection(ctx, targetCollectionID)\n-\tif err != nil {\n-\t\ttrace_log.Error(\"Error in deriving compaction and enumeration offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n-\t\treturn\n-\t}\n-\n-\tif targetBounds.MinOffset == 0 {\n-\t\t// Either the source collection is not compacted yet or no log is forked\n-\t\tcompactionOffset = uint64(sourceBounds.RecordCompactionOffsetPosition)\n-\t} else {\n-\t\t// Some logs are forked, the min offset is guaranteed to be larger than source compaction offset\n-\t\tcompactionOffset = uint64(targetBounds.MinOffset - 1)\n-\t}\n-\tif targetBounds.MaxOffset == 0 {\n-\t\t// Either the source collection is empty or no log is forked\n-\t\tenumerationOffset = uint64(sourceBounds.RecordEnumerationOffsetPosition)\n-\t} else {\n-\t\t// Some logs are forked. The max offset is the enumeration offset\n-\t\tenumerationOffset = uint64(targetBounds.MaxOffset)\n-\t}\n-\n \t_, err = queriesWithTx.InsertCollection(ctx, log.InsertCollectionParams{\n \t\tID:                              targetCollectionID,\n-\t\tRecordCompactionOffsetPosition:  int64(compactionOffset),\n-\t\tRecordEnumerationOffsetPosition: int64(enumerationOffset),\n+\t\tRecordCompactionOffsetPosition:  int64(sourceBounds.RecordCompactionOffsetPosition),\n+\t\tRecordEnumerationOffsetPosition: int64(sourceBounds.RecordEnumerationOffsetPosition),\n \t})\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n \t\treturn\n \t}\n+\tvar targetBounds log.GetMinimumMaximumOffsetForCollectionRow\n+\ttargetBounds, err = queriesWithTx.GetMinimumMaximumOffsetForCollection(ctx, targetCollectionID)\n+\tif err != nil {\n+\t\ttrace_log.Error(\"Error in getting minimax for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n+\t\treturn\n+\t}\n+\tif targetBounds.MinOffset > 0 && targetBounds.MinOffset != sourceBounds.RecordCompactionOffsetPosition + 1 {\n+\t\ttrace_log.Error(\"Race condition: Someone adjusted records during our transaction\",\n+\t\t\tzap.String(\"collectionId\", targetCollectionID),\n+\t\t\tzap.Int64(\"MinOffset\", targetBounds.MinOffset),\n+\t\t\tzap.Int64(\"CompactionOffset+1\", sourceBounds.RecordCompactionOffsetPosition + 1))\n+\t\terr = errors.New(\"concurrent updates caused fork to fail on compaction offset\")\n+\t\treturn\n+\t}\n+\tif targetBounds.MaxOffset > 0 && targetBounds.MaxOffset != sourceBounds.RecordEnumerationOffsetPosition {\n+\t\ttrace_log.Error(\"Race condition: Someone adjusted records during our transaction\",\n+\t\t\tzap.String(\"collectionId\", targetCollectionID),\n+\t\t\tzap.Int64(\"MaxOffset\", targetBounds.MaxOffset),\n+\t\t\tzap.Int64(\"EnumerationOffset\", sourceBounds.RecordEnumerationOffsetPosition))\n+\t\terr = errors.New(\"concurrent updates caused fork to fail on enumeration offset\")\n+\t\treturn\n+\t}\n \treturn\n }\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis is not why the smoke test fails, but is a bug.  Update tests to\ncatch.\n\n## Test plan\n\nNew test locally; all others in CI\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/test/distributed/test_log_failover.py\n@@ -65,4 +65,6 @@ def test_log_failover(\n \n     for i in range(200):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n         assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -26,7 +26,7 @@ log:\n     connect_timeout_ms: 5000\n     request_timeout_ms: 60000 # 1 minute\n     alt_host: \"rust-log-service.chroma\"\n-    use_alt_host_for_everything: true\n+    alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n \n executor:\n   distributed:\n---\nrust/log/src/config.rs\n@@ -14,19 +14,20 @@ pub struct GrpcLogConfig {\n     pub max_encoding_message_size: usize,\n     #[serde(default = \"GrpcLogConfig::default_max_decoding_message_size\")]\n     pub max_decoding_message_size: usize,\n-    // NOTE(rescrv):  This is a hack to allow us to test two log services in parallel without\n-    // breaking the old service.  If alt host is specified, then the \"use_alt_host_for_everything\"\n-    // and \"use_alt_for_collections\" config parameters are consulted.  If\n-    // \"use_alt_host_for_everything\" is set (CI) or the collection being written is in the alt\n-    // collections vec (staging), then we can use the alt host.\n+    // NOTE(rescrv):  This is a hack to allow us to test migrate between two log services without\n+    // breaking things or having a hard cut-over.  If alt_host_threshold is specified, it will be\n+    // interpreted as a u128 (UUID == u128) and if the collection in question is <=\n+    // alt_host_threshold, it go to the alt-host first.\n+    //\n+    // alt tenants/collections will always initialize a new log\n     #[serde(default = \"Option::default\")]\n     pub alt_host: Option<String>,\n     #[serde(default)]\n-    pub use_alt_host_for_everything: bool,\n-    #[serde(default)]\n     pub use_alt_for_tenants: Vec<String>,\n     #[serde(default)]\n     pub use_alt_for_collections: Vec<String>,\n+    #[serde(default = \"Option::default\")]\n+    pub alt_host_threshold: Option<String>,\n }\n \n impl GrpcLogConfig {\n@@ -65,9 +66,9 @@ impl Default for GrpcLogConfig {\n             max_encoding_message_size: GrpcLogConfig::default_max_encoding_message_size(),\n             max_decoding_message_size: GrpcLogConfig::default_max_decoding_message_size(),\n             alt_host: None,\n-            use_alt_host_for_everything: false,\n             use_alt_for_tenants: vec![],\n             use_alt_for_collections: vec![],\n+            alt_host_threshold: None,\n         }\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -244,21 +244,41 @@ impl GrpcLog {\n         client_for_conn_str(connection_string)\n     }\n \n+    fn client_is_on_alt_log(to_evaluate: CollectionUuid, alt_host_threshold: Option<&str>) -> bool {\n+        if let Some(alt_host_threshold) = alt_host_threshold {\n+            let Ok(alt_host_threshold) = Uuid::parse_str(alt_host_threshold) else {\n+                tracing::error!(\"alt_host_threshold must be a valid UUID\");\n+                return false;\n+            };\n+            let to_evaluate = to_evaluate.0.as_u64_pair().0;\n+            let alt_host_threshold = alt_host_threshold.as_u64_pair().0;\n+            to_evaluate <= alt_host_threshold\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn client_for(\n         &mut self,\n         tenant: &str,\n         collection_id: CollectionUuid,\n     ) -> &mut LogServiceClient<chroma_tracing::GrpcTraceService<tonic::transport::Channel>> {\n-        let collection_id = collection_id.to_string();\n         if let Some(alt) = self.alt_client.as_mut() {\n-            if self.config.use_alt_host_for_everything\n-                || self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n-                || self.config.use_alt_for_collections.contains(&collection_id)\n+            if self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n+                || self\n+                    .config\n+                    .use_alt_for_collections\n+                    .contains(&collection_id.to_string())\n+                || Self::client_is_on_alt_log(\n+                    collection_id,\n+                    self.config.alt_host_threshold.as_deref(),\n+                )\n             {\n                 tracing::info!(\"using alt client for {collection_id}\");\n                 return alt;\n             }\n         }\n+        tracing::info!(\"using standard client for {collection_id}\");\n         &mut self.client\n     }\n \n@@ -413,7 +433,8 @@ impl GrpcLog {\n         let mut norm = self\n             ._get_collections_with_new_data(false, min_compaction_size)\n             .await?;\n-        if self.config.use_alt_host_for_everything\n+        if self.config.alt_host_threshold.is_some()\n+            || !self.config.use_alt_for_tenants.is_empty()\n             || !self.config.use_alt_for_collections.is_empty()\n         {\n             let alt = self\n@@ -524,3 +545,32 @@ impl GrpcLog {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn client_is_on_alt_log() {\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            None\n+        ));\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"00088272-cfc4-419d-997a-baebfb25034a\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"00088272-cfc4-419d-997a-baebfb25034a\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"ffffffff-ffff-ffff-ffff-ffffffffffff\"),\n+        ));\n+    }\n+}\n---\nrust/worker/tilt_config.yaml\n@@ -42,7 +42,7 @@ query_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -122,7 +122,7 @@ compaction_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -197,4 +197,4 @@ log_service:\n         connect_timeout_ms: 5000\n         request_timeout_ms: 60000 # 1 minute\n         alt_host: \"rust-log-service.chroma\"\n-        use_alt_host_for_everything: true\n+        alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n---\n\n\n---\n\nChoice B:\nrust/js_bindings/Cargo.toml\n@@ -14,7 +14,3 @@ chroma-cli = { workspace = true }\n \n [build-dependencies]\n napi-build = \"2.0.1\"\n-\n-[profile.release]\n-lto = true\n-strip = \"symbols\"\n---\n\n\n---\n\nChoice C:\nrust/wal3/src/manifest.rs\n@@ -599,7 +599,10 @@ impl Manifest {\n         let path = manifest_path(prefix);\n         loop {\n             match storage\n-                .get_with_e_tag(&path, GetOptions::new(StorageRequestPriority::P0))\n+                .get_with_e_tag(\n+                    &path,\n+                    GetOptions::new(StorageRequestPriority::P0).with_strong_consistency(),\n+                )\n                 .await\n                 .map_err(Arc::new)\n             {\n---\n\n\n---\n\nChoice D:\nchromadb/test/property/test_fork.py\n@@ -8,6 +8,7 @@\n \n from chromadb.api.models.Collection import Collection\n from chromadb.test.conftest import reset, skip_if_not_cluster\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n from hypothesis.stateful import (\n     Bundle,\n     RuleBasedStateMachine,\n@@ -198,22 +199,29 @@ def test_fork_with_log_migration(\n     import grpc\n     from chromadb.proto.logservice_pb2 import SealLogRequest\n     from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+    from chromadb.proto.coordinator_pb2_grpc import SysDBStub\n \n     caplog.set_level(logging.ERROR)\n     client.reset()\n     channel = grpc.insecure_channel(\"localhost:50052\")\n     go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n \n+    channel = grpc.insecure_channel(\"localhost:50051\")\n+    sysdb_service = SysDBStub(channel)  # type: ignore[no-untyped-call]\n+\n+    NUMBER = 100\n+\n     collection = client.create_collection(\"legacy-go-collection-0\")\n-    ids = [f\"id_{i}\" for i in range(6)]\n-    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    ids = sorted([f\"id_{i}\" for i in range(NUMBER)])\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(NUMBER)])  # type: ignore[arg-type]\n     go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n     fork_collection = collection.fork(\"fork-legacy-go-collection-0\")\n     assert sorted(fork_collection.get()[\"ids\"]) == ids\n \n     collection = client.create_collection(\"legacy-go-collection-1\")\n     go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n-    ids = [f\"id_{i}\" for i in range(6)]\n-    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    ids = sorted([f\"id_{i}\" for i in range(NUMBER)])\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(NUMBER)])  # type: ignore[arg-type]\n     fork_collection = collection.fork(\"fork-legacy-go-collection-1\")\n+    wait_for_version_increase(client, fork_collection.name, 0)\n     assert sorted(fork_collection.get()[\"ids\"]) == ids\n---\nrust/log-service/src/lib.rs\n@@ -38,7 +38,7 @@ use tracing::{Instrument, Level};\n use uuid::Uuid;\n use wal3::{\n     Cursor, CursorName, CursorStore, CursorStoreOptions, Fragment, Limits, LogPosition, LogReader,\n-    LogReaderOptions, LogWriter, LogWriterOptions, Manifest, Witness,\n+    LogReaderOptions, LogWriter, LogWriterOptions, Manifest, MarkDirty as MarkDirtyTrait, Witness,\n };\n \n pub mod state_hash_table;\n@@ -1427,15 +1427,22 @@ impl LogServer {\n             );\n             // This is the next record to insert, so we'll have to adjust downwards.\n             let max_offset = log_reader.maximum_log_position().await.map_err(|err| {\n-                Status::new(err.code().into(), format!(\"Failed to copy log: {}\", err))\n+                Status::new(err.code().into(), format!(\"Failed to read copied log: {}\", err))\n             })?;\n             if max_offset < offset {\n                 return Err(Status::new(\n                     chroma_error::ErrorCodes::Internal.into(),\n                     format!(\"max_offset={:?} < offset={:?}\", max_offset, offset),\n                 ));\n             }\n-            tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n+            if offset != max_offset{\n+                let mark_dirty = MarkDirty {\n+                    collection_id: target_collection_id,\n+                    dirty_log: Arc::clone(&self.dirty_log),\n+                };\n+                let _ = mark_dirty.mark_dirty(offset, (max_offset - offset) as usize).await;\n+            }\n+            tracing::event!(Level::INFO, compaction_offset =? offset.offset() - 1, enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n                 // NOTE: The upstream service expects the last compacted offset as compaction offset\n                 compaction_offset: (offset - 1u64).offset(),\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - Adds a stopwatch to nac delay in milliseconds\r\n  - I could use feedback on the choice of milliseconds, as in the happy path this will be ms and in bad situations it could be seconds\r\n- New functionality\r\n  - None\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\nValidated metric manually in tilt \r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nNone\n\n---\n\nChoice A:\nrust/blockstore/src/arrow/provider.rs\n@@ -469,6 +469,15 @@ pub struct RootManager {\n     prefetched_roots: Arc<parking_lot::Mutex<HashMap<Uuid, Duration>>>,\n }\n \n+impl std::fmt::Debug for RootManager {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"RootManager\")\n+            .field(\"cache\", &self.cache)\n+            .field(\"storage\", &self.storage)\n+            .finish()\n+    }\n+}\n+\n impl RootManager {\n     pub fn new(storage: Storage, cache: Box<dyn PersistentCache<Uuid, RootReader>>) -> Self {\n         let cache: Arc<dyn PersistentCache<Uuid, RootReader>> = cache.into();\n---\nrust/garbage_collector/src/operators/list_files_at_version.rs\n@@ -0,0 +1,160 @@\n+use async_trait::async_trait;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n+use chroma_system::{Operator, OperatorType};\n+use chroma_types::{chroma_proto::CollectionVersionFile, CollectionUuid, HNSW_PATH};\n+use std::{collections::HashSet, str::FromStr};\n+use thiserror::Error;\n+use tokio::task::{JoinError, JoinSet};\n+use uuid::Uuid;\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionInput {\n+    root_manager: RootManager,\n+    version_file: CollectionVersionFile,\n+    version: i64,\n+}\n+\n+impl ListFilesAtVersionInput {\n+    pub fn new(\n+        root_manager: RootManager,\n+        version_file: CollectionVersionFile,\n+        version: i64,\n+    ) -> Self {\n+        Self {\n+            root_manager,\n+            version_file,\n+            version,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionOutput {\n+    pub collection_id: CollectionUuid,\n+    pub version: i64,\n+    pub file_paths: HashSet<String>,\n+}\n+\n+#[derive(Debug, Error)]\n+pub enum ListFilesAtVersionError {\n+    #[error(\"Version history field missing\")]\n+    VersionHistoryMissing,\n+    #[error(\"Version {0} not found\")]\n+    VersionNotFound(i64),\n+    #[error(\"Invalid UUID: {0}\")]\n+    InvalidUuid(uuid::Error),\n+    #[error(\"Sparse index fetch task failed: {0}\")]\n+    SparseIndexTaskFailed(JoinError),\n+    #[error(\"Error fetching block IDs for sparse index: {0}\")]\n+    FetchBlockIdsError(#[from] RootManagerError),\n+    #[error(\"Version file missing collection ID\")]\n+    VersionFileMissingCollectionId,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ListFilesAtVersionsOperator {}\n+\n+#[async_trait]\n+impl Operator<ListFilesAtVersionInput, ListFilesAtVersionOutput> for ListFilesAtVersionsOperator {\n+    type Error = ListFilesAtVersionError;\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n+\n+    async fn run(\n+        &self,\n+        input: &ListFilesAtVersionInput,\n+    ) -> Result<ListFilesAtVersionOutput, Self::Error> {\n+        let collection_id = CollectionUuid::from_str(\n+            &input\n+                .version_file\n+                .collection_info_immutable\n+                .as_ref()\n+                .ok_or_else(|| ListFilesAtVersionError::VersionFileMissingCollectionId)?\n+                .collection_id,\n+        )\n+        .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+        let version_history = input\n+            .version_file\n+            .version_history\n+            .as_ref()\n+            .ok_or_else(|| ListFilesAtVersionError::VersionHistoryMissing)?;\n+\n+        let mut file_paths = HashSet::new();\n+        let mut sparse_index_ids = HashSet::new();\n+\n+        let version = version_history\n+            .versions\n+            .iter()\n+            .find(|v| v.version == input.version)\n+            .ok_or_else(|| ListFilesAtVersionError::VersionNotFound(input.version))?;\n+\n+        tracing::debug!(\n+            \"Listing files at version {} for collection {}.\",\n+            version.version,\n+            collection_id,\n+        );\n+        tracing::trace!(\n+            \"Processing version {:#?} for collection {}\",\n+            version,\n+            collection_id\n+        );\n+\n+        if let Some(segment_info) = &version.segment_info {\n+            for segment in &segment_info.segment_compaction_info {\n+                for (file_type, segment_paths) in &segment.file_paths {\n+                    if file_type == \"hnsw_index\" || file_type == HNSW_PATH {\n+                        for path in &segment_paths.paths {\n+                            for hnsw_file in [\n+                                \"header.bin\",\n+                                \"data_level0.bin\",\n+                                \"length.bin\",\n+                                \"link_lists.bin\",\n+                            ] {\n+                                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                                file_paths.insert(format!(\"hnsw/{}/{}\", path, hnsw_file));\n+                            }\n+                        }\n+                    } else {\n+                        // Must be a sparse index\n+                        for path in &segment_paths.paths {\n+                            // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                            file_paths.insert(format!(\"sparse_index/{}\", path));\n+\n+                            let sparse_index_id = Uuid::parse_str(path)\n+                                .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+                            sparse_index_ids.insert(sparse_index_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut block_id_tasks = JoinSet::new();\n+        for sparse_index_id in sparse_index_ids {\n+            let root_manager = input.root_manager.clone();\n+            block_id_tasks\n+                .spawn(async move { root_manager.get_all_block_ids(&sparse_index_id).await });\n+        }\n+\n+        while let Some(res) = block_id_tasks.join_next().await {\n+            let block_ids = res\n+                .map_err(ListFilesAtVersionError::SparseIndexTaskFailed)?\n+                .map_err(ListFilesAtVersionError::FetchBlockIdsError)?;\n+\n+            for block_id in block_ids {\n+                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                file_paths.insert(format!(\"block/{}\", block_id));\n+            }\n+        }\n+\n+        Ok(ListFilesAtVersionOutput {\n+            collection_id,\n+            version: input.version,\n+            file_paths,\n+        })\n+    }\n+}\n---\nrust/garbage_collector/src/operators/mod.rs\n@@ -8,4 +8,5 @@ pub mod fetch_lineage_file;\n pub mod fetch_sparse_index_files;\n pub mod fetch_version_file;\n pub mod get_version_file_paths;\n+pub mod list_files_at_version;\n pub mod mark_versions_at_sysdb;\n---\n\n\n---\n\nChoice B:\n.github/workflows/release-chromadb.yml\n@@ -220,7 +220,7 @@ jobs:\n                 // - This workflow finishes for A and deploys A to Chroma Cloud\n                 // Chroma Cloud is now running A, but the last commit was B.\n                 \"environment\": \"staging\",\n-                \"planes\": \"data,control\"\n+                \"planes\": \"control,data\"\n               }\n             })\n \n---\n.github/workflows/trigger-deploy.yaml\n@@ -5,8 +5,9 @@ on:\n   push:\n     branches:\n       # main is not included here because it is handled by the release-chromadb.yaml workflow\n+      # production deploys (release branches) are also not here because they are currently\n+      # meant to be handled manually.\n       - rc/**-**-**\n-      - release/**-**-**\n \n jobs:\n   deploy:\n@@ -25,7 +26,7 @@ jobs:\n               ref: 'main',\n               inputs: {\n                 'planes': 'control,data',\n-                 environment: '${{ contains(github.ref, 'release/') && 'production' || 'staging' }}',\n+                 environment: 'staging',\n                 'ignore-lock': true,\n                 'oss-ref': '${{ github.ref_name }}',\n                 'hosted-ref': '${{ github.ref_name }}'\n---\n\n\n---\n\nChoice C:\nCargo.lock\n@@ -1813,8 +1813,10 @@ dependencies = [\n  \"bytes\",\n  \"chroma-config\",\n  \"chroma-error\",\n+ \"chroma-tracing\",\n  \"futures\",\n  \"object_store\",\n+ \"opentelemetry\",\n  \"parking_lot\",\n  \"rand 0.8.5\",\n  \"rand_xorshift\",\n---\nrust/storage/Cargo.toml\n@@ -23,9 +23,11 @@ thiserror.workspace = true\n tokio = { workspace = true }\n tokio-util = { workspace = true }\n tracing = { workspace = true }\n+opentelemetry = { workspace = true }\n \n chroma-config = { workspace = true }\n chroma-error = { workspace = true }\n+chroma-tracing = { workspace = true }\n \n [dev-dependencies]\n rand_xorshift = { workspace = true }\n---\nrust/storage/src/admissioncontrolleds3.rs\n@@ -10,6 +10,7 @@ use bytes::Bytes;\n use chroma_config::registry::Registry;\n use chroma_config::Configurable;\n use chroma_error::ChromaError;\n+use chroma_tracing::util::Stopwatch;\n use futures::future::BoxFuture;\n use futures::{future::Shared, stream, FutureExt, StreamExt};\n use std::{\n@@ -524,9 +525,30 @@ impl RateLimitPolicy {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct CountBasedPolicyMetrics {\n+    // The delay in milliseconds before a request is allowed to proceed.\n+    pub nac_delay_ms: opentelemetry::metrics::Histogram<u64>,\n+}\n+\n+impl Default for CountBasedPolicyMetrics {\n+    fn default() -> Self {\n+        Self {\n+            nac_delay_ms: opentelemetry::global::meter(\"chroma.storage.admission_control\")\n+                .u64_histogram(\"nac_delay_ms\")\n+                .with_description(\n+                    \"The delay in milliseconds before a request is allowed to proceed.\",\n+                )\n+                .with_unit(\"ms\")\n+                .build(),\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct CountBasedPolicy {\n     remaining_tokens: Vec<Semaphore>,\n+    metrics: CountBasedPolicyMetrics,\n }\n \n impl CountBasedPolicy {\n@@ -537,14 +559,18 @@ impl CountBasedPolicy {\n                 (max_allowed_outstanding as f32 * allocation).ceil() as usize,\n             ));\n         }\n-        Self { remaining_tokens }\n+        Self {\n+            remaining_tokens,\n+            metrics: CountBasedPolicyMetrics::default(),\n+        }\n     }\n \n     async fn acquire(\n         &self,\n         priority: Arc<AtomicUsize>,\n         mut channel_receiver: Option<tokio::sync::mpsc::Receiver<()>>,\n     ) -> SemaphorePermit<'_> {\n+        let _stopwatch = Stopwatch::new(&self.metrics.nac_delay_ms, &[]);\n         loop {\n             let current_priority = priority.load(Ordering::SeqCst);\n             let current_priority: StorageRequestPriority = current_priority.into();\n---\n\n\n---\n\nChoice D:\nrust/cache/src/foyer.rs\n@@ -492,6 +492,10 @@ where\n         }\n         Ok(res)\n     }\n+\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.cache.contains(key)\n+    }\n }\n \n impl<K, V> super::PersistentCache<K, V> for FoyerHybridCache<K, V>\n@@ -820,4 +824,26 @@ mod test {\n             .expect(\"Value should not be None\");\n         assert_eq!(value, \"foo\");\n     }\n+\n+    #[tokio::test]\n+    async fn test_may_contain() {\n+        let dir = tempfile::tempdir()\n+            .expect(\"To be able to create temp path\")\n+            .path()\n+            .to_str()\n+            .expect(\"To be able to parse path\")\n+            .to_string();\n+        let cache = FoyerCacheConfig {\n+            dir: Some(dir.clone()),\n+            flush: true,\n+            ..Default::default()\n+        }\n+        .build_hybrid_test::<String, String>()\n+        .await\n+        .unwrap();\n+\n+        cache.insert(\"key1\".to_string(), \"foo\".to_string()).await;\n+        assert!(cache.may_contain(&\"key1\".to_string()).await);\n+        assert!(!cache.may_contain(&\"key2\".to_string()).await);\n+    }\n }\n---\nrust/cache/src/lib.rs\n@@ -69,6 +69,11 @@ where\n {\n     async fn insert(&self, key: K, value: V);\n     async fn get(&self, key: &K) -> Result<Option<V>, CacheError>;\n+    // Returns true if the cache contains the key. This method may return a\n+    // false-positive.\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.get(key).await.map(|v| v.is_some()).unwrap_or(false)\n+    }\n     async fn remove(&self, key: &K);\n     async fn clear(&self) -> Result<(), CacheError>;\n     async fn obtain(&self, key: K) -> Result<Option<V>, CacheError>;\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Implement a simple unit test for log forking under log migration\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\ngo/pkg/log/server/server.go\n@@ -54,16 +54,18 @@ func (s *logServer) ScoutLogs(ctx context.Context, req *logservicepb.ScoutLogsRe\n \tif err != nil {\n \t\treturn\n \t}\n+\tvar start int64\n \tvar limit int64\n-\t_, limit, err = s.lr.GetBoundsForCollection(ctx, collectionID.String())\n+\tstart, limit, err = s.lr.GetBoundsForCollection(ctx, collectionID.String())\n \tif err != nil {\n \t\treturn\n \t}\n \t// +1 to convert from the (] bound to a [) bound.\n \tres = &logservicepb.ScoutLogsResponse{\n+\t\tFirstUncompactedRecordOffset: int64(start + 1),\n \t\tFirstUninsertedRecordOffset: int64(limit + 1),\n \t}\n-\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n+\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"start\", int64(start + 1)), zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n \treturn\n }\n \n---\nidl/chromadb/proto/logservice.proto\n@@ -24,6 +24,8 @@ message ScoutLogsResponse {\n   reserved 1;\n   // The next record to insert will have this offset.\n   int64 first_uninserted_record_offset = 2;\n+  // The oldest record on the log will have this offset.\n+  int64 first_uncompacted_record_offset = 3;\n }\n \n message PullLogsRequest {\n---\nrust/log-service/src/lib.rs\n@@ -745,18 +745,24 @@ impl LogService for LogServer {\n                 Arc::clone(&self.storage),\n                 prefix,\n             );\n-            let limit_position = match log_reader.maximum_log_position().await {\n-                Ok(limit_position) => limit_position,\n+            let (start_position, limit_position) = match log_reader.manifest().await {\n+                Ok(Some(manifest)) => (\n+                    manifest.minimum_log_position(),\n+                    manifest.maximum_log_position(),\n+                ),\n+                Ok(None) => (LogPosition::from_offset(0), LogPosition::from_offset(1)),\n                 Err(err) => {\n                     if err.code() == chroma_error::ErrorCodes::FailedPrecondition {\n-                        LogPosition::from_offset(1)\n+                        (LogPosition::from_offset(1), LogPosition::from_offset(1))\n                     } else {\n                         return Err(Status::new(err.code().into(), err.to_string()));\n                     }\n                 }\n             };\n+            let start_offset = start_position.offset() as i64;\n             let limit_offset = limit_position.offset() as i64;\n             Ok(Response::new(ScoutLogsResponse {\n+                first_uncompacted_record_offset: start_offset,\n                 first_uninserted_record_offset: limit_offset,\n             }))\n         }\n---\nrust/wal3/src/manifest.rs\n@@ -276,7 +276,7 @@ impl Snapshot {\n             },\n             (Some(f), None) => f,\n             (None, Some(s)) => s,\n-            (None, None) => LogPosition::default(),\n+            (None, None) => LogPosition::from_offset(1),\n         }\n     }\n \n---\n\n\n---\n\nChoice B:\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -549,6 +549,8 @@ impl ServiceBasedFrontend {\n     pub async fn retryable_fork(\n         &mut self,\n         ForkCollectionRequest {\n+            tenant_id,\n+            database_name,\n             source_collection_id,\n             target_collection_name,\n             ..\n@@ -570,12 +572,25 @@ impl ServiceBasedFrontend {\n             )\n             .await?;\n         let collection = collection_and_segments.collection.clone();\n+        let latest_collection_logical_size_bytes = collection_and_segments\n+            .collection\n+            .size_bytes_post_compaction;\n \n         // Update the cache.\n         self.collections_with_segments_provider\n             .set_collection_with_segments(collection_and_segments)\n             .await;\n \n+        // TODO: Submit event after the response is sent\n+        MeterEvent::CollectionFork {\n+            tenant: tenant_id,\n+            database: database_name,\n+            collection_id: source_collection_id.0,\n+            latest_collection_logical_size_bytes,\n+        }\n+        .submit()\n+        .await;\n+\n         Ok(collection)\n     }\n \n---\nrust/tracing/src/meter_event.rs\n@@ -26,6 +26,12 @@ pub enum WriteAction {\n #[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]\n #[serde(rename_all = \"snake_case\", tag = \"event_name\")]\n pub enum MeterEvent {\n+    CollectionFork {\n+        tenant: String,\n+        database: String,\n+        collection_id: Uuid,\n+        latest_collection_logical_size_bytes: u64,\n+    },\n     CollectionRead {\n         tenant: String,\n         database: String,\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/config.rs\n@@ -64,6 +64,8 @@ pub struct FrontendConfig {\n     pub executor: ExecutorConfig,\n     #[serde(default = \"default_default_knn_index\")]\n     pub default_knn_index: KnnIndex,\n+    #[serde(default = \"Default::default\")]\n+    pub tenants_to_migrate_immediately: Vec<String>,\n }\n \n impl FrontendConfig {\n@@ -80,6 +82,7 @@ impl FrontendConfig {\n             log: default_log_config(),\n             executor: default_executor_config(),\n             default_knn_index: default_default_knn_index(),\n+            tenants_to_migrate_immediately: vec![],\n         }\n     }\n }\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -66,9 +66,11 @@ pub struct ServiceBasedFrontend {\n     metrics: Arc<Metrics>,\n     default_knn_index: KnnIndex,\n     retries_builder: ExponentialBuilder,\n+    tenants_to_migrate_immediately: HashSet<String>,\n }\n \n impl ServiceBasedFrontend {\n+    #[allow(clippy::too_many_arguments)]\n     pub fn new(\n         allow_reset: bool,\n         sysdb_client: SysDb,\n@@ -77,6 +79,7 @@ impl ServiceBasedFrontend {\n         executor: Executor,\n         max_batch_size: u32,\n         default_knn_index: KnnIndex,\n+        tenants_to_migrate_immediately: HashSet<String>,\n     ) -> Self {\n         let meter = global::meter(\"chroma\");\n         let fork_retries_counter = meter.u64_counter(\"fork_retries\").build();\n@@ -119,6 +122,7 @@ impl ServiceBasedFrontend {\n             metrics,\n             default_knn_index,\n             retries_builder,\n+            tenants_to_migrate_immediately,\n         }\n     }\n \n@@ -489,7 +493,7 @@ impl ServiceBasedFrontend {\n         let collection = self\n             .sysdb_client\n             .create_collection(\n-                tenant_id,\n+                tenant_id.clone(),\n                 database_name,\n                 collection_id,\n                 name,\n@@ -505,10 +509,18 @@ impl ServiceBasedFrontend {\n             .collections_with_segments_cache\n             .remove(&collection_id)\n             .await;\n-\n+        if self.tenant_is_on_new_log_by_default(&tenant_id) {\n+            if let Err(err) = self.log_client.seal_log(&tenant_id, collection_id).await {\n+                tracing::error!(\"could not seal collection right away: {err}\");\n+            }\n+        }\n         Ok(collection)\n     }\n \n+    fn tenant_is_on_new_log_by_default(&self, tenant_id: &str) -> bool {\n+        self.tenants_to_migrate_immediately.contains(tenant_id)\n+    }\n+\n     pub async fn update_collection(\n         &mut self,\n         UpdateCollectionRequest {\n@@ -1471,6 +1483,11 @@ impl Configurable<(FrontendConfig, System)> for ServiceBasedFrontend {\n         let executor =\n             Executor::try_from_config(&(config.executor.clone(), system.clone()), registry).await?;\n \n+        let tenants_to_migrate_immediately = config\n+            .tenants_to_migrate_immediately\n+            .iter()\n+            .cloned()\n+            .collect::<HashSet<String>>();\n         Ok(ServiceBasedFrontend::new(\n             config.allow_reset,\n             sysdb,\n@@ -1479,6 +1496,7 @@ impl Configurable<(FrontendConfig, System)> for ServiceBasedFrontend {\n             executor,\n             max_batch_size,\n             config.default_knn_index,\n+            tenants_to_migrate_immediately,\n         ))\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -125,6 +125,20 @@ impl ChromaError for GrpcPurgeDirtyForCollectionError {\n     }\n }\n \n+#[derive(Error, Debug)]\n+pub enum GrpcSealLogError {\n+    #[error(\"Failed to seal collection: {0}\")]\n+    FailedToSeal(#[from] tonic::Status),\n+}\n+\n+impl ChromaError for GrpcSealLogError {\n+    fn code(&self) -> ErrorCodes {\n+        match self {\n+            GrpcSealLogError::FailedToSeal(_) => ErrorCodes::Internal,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct GrpcLog {\n     config: GrpcLogConfig,\n@@ -544,6 +558,20 @@ impl GrpcLog {\n             Ok(())\n         }\n     }\n+\n+    pub(super) async fn seal_log(\n+        &mut self,\n+        tenant: &str,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcSealLogError> {\n+        let _response = self\n+            .client_for(tenant, collection_id)\n+            .seal_log(chroma_proto::SealLogRequest {\n+                collection_id: collection_id.to_string(),\n+            })\n+            .await?;\n+        Ok(())\n+    }\n }\n \n #[cfg(test)]\n---\nrust/log/src/log.rs\n@@ -1,4 +1,4 @@\n-use crate::grpc_log::GrpcLog;\n+use crate::grpc_log::{GrpcLog, GrpcSealLogError};\n use crate::in_memory_log::InMemoryLog;\n use crate::sqlite_log::SqliteLog;\n use crate::types::CollectionInfo;\n@@ -210,4 +210,16 @@ impl Log {\n             Log::InMemory(_) => Ok(ResetResponse {}),\n         }\n     }\n+\n+    pub async fn seal_log(\n+        &mut self,\n+        tenant: &str,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcSealLogError> {\n+        match self {\n+            Log::Grpc(log) => log.seal_log(tenant, collection_id).await,\n+            Log::Sqlite(_) => unimplemented!(),\n+            Log::InMemory(_) => unimplemented!(),\n+        }\n+    }\n }\n---\nrust/python_bindings/src/bindings.rs\n@@ -122,6 +122,7 @@ impl Bindings {\n             log: log_config,\n             executor: executor_config,\n             default_knn_index: knn_index,\n+            tenants_to_migrate_immediately: vec![],\n         };\n \n         let frontend = runtime.block_on(async {\n---\n\n\n---\n\nChoice D:\nchromadb/test/property/test_fork.py\n@@ -189,3 +189,31 @@ def verify(\n def test_fork(caplog: pytest.LogCaptureFixture, client: chromadb.api.ClientAPI) -> None:\n     caplog.set_level(logging.ERROR)\n     run_state_machine_as_test(lambda: ForkStateMachine(client))  # type: ignore\n+\n+\n+@skip_if_not_cluster()\n+def test_fork_with_log_migration(\n+    caplog: pytest.LogCaptureFixture, client: chromadb.api.ClientAPI\n+) -> None:\n+    import grpc\n+    from chromadb.proto.logservice_pb2 import SealLogRequest\n+    from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n+    caplog.set_level(logging.ERROR)\n+    client.reset()\n+    channel = grpc.insecure_channel(\"localhost:50052\")\n+    go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n+    collection = client.create_collection(\"legacy-go-collection-0\")\n+    ids = [f\"id_{i}\" for i in range(6)]\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n+    fork_collection = collection.fork(\"fork-legacy-go-collection-0\")\n+    assert sorted(fork_collection.get()[\"ids\"]) == ids\n+\n+    collection = client.create_collection(\"legacy-go-collection-1\")\n+    go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n+    ids = [f\"id_{i}\" for i in range(6)]\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    fork_collection = collection.fork(\"fork-legacy-go-collection-1\")\n+    assert sorted(fork_collection.get()[\"ids\"]) == ids\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nWhen the coalesced dirty log was empty, it would do no adjusting of the\nlog offsets.  Thus the log would read longer and longer.\n\nTo trigger this, make many collections and then delete them all.  No\nother writes.\n\n## Test plan\n\nCI\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/load/src/bin/chroma-load-start.rs\n@@ -90,7 +90,7 @@ async fn main() {\n     let args = Args::parse();\n \n     // Read API key from environment variable.\n-    let api_key = std::env::var(\"CHROMA_API_KEY\").expect(\"CHROMA_API_KEY is not set\");\n+    let api_key = std::env::var(\"CHROMA_API_KEY\").ok();\n \n     let client = reqwest::Client::new();\n     let throughput = args.throughput();\n---\nrust/load/src/lib.rs\n@@ -180,20 +180,25 @@ impl ZipfCache {\n #[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]\n pub struct Connection {\n     pub url: String,\n-    pub api_key: String,\n+    pub api_key: Option<String>,\n     pub database: String,\n }\n \n ////////////////////////////////////////////// client //////////////////////////////////////////////\n \n /// Instantiate a new Chroma client.\n pub async fn client(connection: Connection) -> ChromaClient {\n+    let auth = if let Some(api_key) = connection.api_key.clone() {\n+        ChromaAuthMethod::TokenAuth {\n+            token: api_key,\n+            header: ChromaTokenHeader::XChromaToken,\n+        }\n+    } else {\n+        ChromaAuthMethod::None\n+    };\n     ChromaClient::new(ChromaClientOptions {\n         url: Some(connection.url.clone()),\n-        auth: ChromaAuthMethod::TokenAuth {\n-            token: connection.api_key.clone(),\n-            header: ChromaTokenHeader::XChromaToken,\n-        },\n+        auth,\n         database: connection.database.clone(),\n     })\n     .await\n@@ -1032,7 +1037,7 @@ impl LoadHarness {\n             .iter()\n             .map(|w| {\n                 let mut w = w.clone();\n-                w.connection.api_key = \"REDACTED\".to_string();\n+                w.connection.api_key = Some(\"REDACTED\".to_string());\n                 w\n             })\n             .collect()\n@@ -1744,7 +1749,7 @@ mod tests {\n             \"nop\".to_string(),\n             Connection {\n                 url: \"http://localhost:8000\".to_string(),\n-                api_key: \"\".to_string(),\n+                api_key: None,\n                 database: \"\".to_string(),\n             },\n             (chrono::Utc::now() + chrono::Duration::seconds(10)).into(),\n@@ -1856,7 +1861,7 @@ mod tests {\n             \"nop\".to_string(),\n             Connection {\n                 url: \"http://localhost:8000\".to_string(),\n-                api_key: \"\".to_string(),\n+                api_key: None,\n                 database: \"\".to_string(),\n             },\n             (chrono::Utc::now() + chrono::Duration::seconds(10)).into(),\n---\n\n\n---\n\nChoice B:\n.github/workflows/_build_release_container.yml\n@@ -38,7 +38,7 @@ env:\n jobs:\n   build:\n     name: Build and publish container image\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n+    runs-on: blacksmith-16vcpu-ubuntu-2204\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -1104,6 +1104,7 @@ impl LogServer {\n                     manifest.maximum_log_position(),\n                 ),\n                 Ok(None) | Err(wal3::Error::UninitializedLog) => {\n+                    tracing::info!(\"Log is uninitialized on rust log service. Forwarding ScoutLog request to legacy log service\");\n                     return self.forward_scout_logs(Request::new(scout_logs)).await;\n                 }\n                 Err(err) => {\n@@ -1113,6 +1114,13 @@ impl LogServer {\n                     ));\n                 }\n             };\n+\n+            // NOTE(sicheng): This is temporary trace added for analyzing number of frags between the offsets\n+            match log_reader.scan(start_position, Default::default()).await {\n+                Ok(frags) => tracing::info!(name: \"Counting live fragments\", frag_count = frags.len()),\n+                Err(e) => tracing::error!(name: \"Unable to scout number of live fragments\", error = e.to_string()),\n+            }\n+\n             let start_offset = start_position.offset() as i64;\n             let limit_offset = limit_position.offset() as i64;\n             Ok(Response::new(ScoutLogsResponse {\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -364,6 +364,10 @@ pub enum DirtyMarker {\n     },\n     #[serde(rename = \"purge\")]\n     Purge { collection_id: CollectionUuid },\n+    // A Cleared marker is a no-op.  It exists so that a log consisting of mark-dirty markers that\n+    // map onto purge markers will be cleared and can be erased.\n+    #[serde(rename = \"clear\")]\n+    Cleared,\n }\n \n impl DirtyMarker {\n@@ -372,6 +376,7 @@ impl DirtyMarker {\n         match self {\n             DirtyMarker::MarkDirty { collection_id, .. } => *collection_id,\n             DirtyMarker::Purge { collection_id } => *collection_id,\n+            DirtyMarker::Cleared => CollectionUuid::default(),\n         }\n     }\n \n@@ -416,6 +421,7 @@ impl DirtyMarker {\n                 DirtyMarker::Purge { collection_id } => {\n                     forget.push(*collection_id);\n                 }\n+                DirtyMarker::Cleared => {}\n             }\n         }\n         for collection_id in forget {\n@@ -865,22 +871,23 @@ impl LogServer {\n                 backpressure.push(*collection_id);\n             }\n         }\n-        if !markers.is_empty() {\n-            let mut new_cursor = cursor.clone();\n-            new_cursor.position = self.dirty_log.append_many(markers).await?;\n-            let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n-                return Err(Error::CouldNotGetDirtyLogCursors);\n-            };\n-            tracing::info!(\n-                \"Advancing dirty log cursor {:?} -> {:?}\",\n-                cursor.position,\n-                new_cursor.position\n-            );\n-            if let Some(witness) = witness {\n-                cursors.save(&STABLE_PREFIX, &new_cursor, &witness).await?;\n-            } else {\n-                cursors.init(&STABLE_PREFIX, new_cursor).await?;\n-            }\n+        if markers.is_empty() {\n+            markers.push(serde_json::to_string(&DirtyMarker::Cleared).map(Vec::from)?);\n+        }\n+        let mut new_cursor = cursor.clone();\n+        new_cursor.position = self.dirty_log.append_many(markers).await?;\n+        let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n+            return Err(Error::CouldNotGetDirtyLogCursors);\n+        };\n+        tracing::info!(\n+            \"Advancing dirty log cursor {:?} -> {:?}\",\n+            cursor.position,\n+            new_cursor.position\n+        );\n+        if let Some(witness) = witness {\n+            cursors.save(&STABLE_PREFIX, &new_cursor, &witness).await?;\n+        } else {\n+            cursors.init(&STABLE_PREFIX, new_cursor).await?;\n         }\n         self.metrics\n             .log_total_uncompacted_records_count\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nSkip using the results of the manifest load to make things faster for rollup/enrich.\r\n\r\n## Test plan\r\n\r\nCI.\r\n\r\n## Documentation Changes\r\n\r\nN/A\r\n\n\n---\n\nChoice A:\nchromadb/test/utils/wait_for_version_increase.py\n@@ -23,7 +23,8 @@ def wait_for_version_increase(\n     while curr_version == initial_version:\n         time.sleep(TIMEOUT_INTERVAL)\n         if time.time() - initial_time > timeout:\n-            raise TimeoutError(\"Model was not updated in time\")\n+            collection_id = client.get_collection(collection_name).id\n+            raise TimeoutError(f\"Model was not updated in time for {collection_id}\")\n         curr_version = get_collection_version(client, collection_name)\n \n     return curr_version\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -56,3 +56,5 @@ circuit_breaker:\n   requests: 1000\n enable_span_indexing: true\n default_knn_index: \"spann\"\n+tenants_to_migrate_immediately:\n+- \"default_tenant\"\n---\nrust/log-service/src/lib.rs\n@@ -896,6 +896,14 @@ impl LogServer {\n         self.metrics\n             .dirty_log_records_read\n             .add(dirty_markers.len() as u64, &[]);\n+        let Some((last_record_inserted, _)) = dirty_markers.last() else {\n+            let backpressure = vec![];\n+            self.set_backpressure(&backpressure);\n+            let mut need_to_compact = self.need_to_compact.lock();\n+            let mut rollups = HashMap::new();\n+            std::mem::swap(&mut *need_to_compact, &mut rollups);\n+            return Ok(());\n+        };\n         let mut rollups = DirtyMarker::coalesce_markers(&dirty_markers)?;\n         self.enrich_dirty_log(&mut rollups).await?;\n         let mut markers = vec![];\n@@ -919,7 +927,8 @@ impl LogServer {\n             markers.push(serde_json::to_string(&DirtyMarker::Cleared).map(Vec::from)?);\n         }\n         let mut new_cursor = cursor.clone();\n-        new_cursor.position = self.dirty_log.append_many(markers).await?;\n+        self.dirty_log.append_many(markers).await?;\n+        new_cursor.position = *last_record_inserted + 1u64;\n         let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n             return Err(Error::CouldNotGetDirtyLogCursors);\n         };\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/server/server.go\n@@ -162,6 +162,15 @@ func (s *logServer) InspectDirtyLog(ctx context.Context, req *logservicepb.Inspe\n \treturn\n }\n \n+func (s *logServer) SealLog(ctx context.Context, req *logservicepb.SealLogRequest) (res *logservicepb.SealLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n+\n+func (s *logServer) MigrateLog(ctx context.Context, req *logservicepb.MigrateLogRequest) (res *logservicepb.MigrateLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n \n func NewLogServer(lr *repository.LogRepository) logservicepb.LogServiceServer {\n \treturn &logServer{\n---\nidl/chromadb/proto/logservice.proto\n@@ -96,6 +96,22 @@ message InspectDirtyLogResponse {\n   repeated string markers = 1;\n }\n \n+message SealLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message SealLogResponse {\n+  // Empty\n+}\n+\n+message MigrateLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message MigrateLogResponse {\n+  // Empty\n+}\n+\n service LogService {\n   rpc PushLogs(PushLogsRequest) returns (PushLogsResponse) {}\n   rpc ScoutLogs(ScoutLogsRequest) returns (ScoutLogsResponse) {}\n@@ -104,5 +120,11 @@ service LogService {\n   rpc GetAllCollectionInfoToCompact(GetAllCollectionInfoToCompactRequest) returns (GetAllCollectionInfoToCompactResponse) {}\n   rpc UpdateCollectionLogOffset(UpdateCollectionLogOffsetRequest) returns (UpdateCollectionLogOffsetResponse) {}\n   rpc PurgeDirtyForCollection(PurgeDirtyForCollectionRequest) returns (PurgeDirtyForCollectionResponse) {}\n+  // RPC endpoints to expose for operator debuggability.\n+  // This endpoint must route to the rust log service.\n   rpc InspectDirtyLog(InspectDirtyLogRequest) returns (InspectDirtyLogResponse) {}\n+  // This endpoint must route to the go log service.\n+  rpc SealLog(SealLogRequest) returns (SealLogResponse) {}\n+  // This endpoint must route to the rust log service.\n+  rpc MigrateLog(MigrateLogRequest) returns (MigrateLogResponse) {}\n }\n---\nrust/log-service/src/lib.rs\n@@ -16,9 +16,10 @@ use chroma_storage::Storage;\n use chroma_types::chroma_proto::{\n     log_service_server::LogService, CollectionInfo, GetAllCollectionInfoToCompactRequest,\n     GetAllCollectionInfoToCompactResponse, InspectDirtyLogRequest, InspectDirtyLogResponse,\n-    LogRecord, OperationRecord, PullLogsRequest, PullLogsResponse, PurgeDirtyForCollectionRequest,\n-    PurgeDirtyForCollectionResponse, PushLogsRequest, PushLogsResponse, ScoutLogsRequest,\n-    ScoutLogsResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n+    LogRecord, MigrateLogRequest, MigrateLogResponse, OperationRecord, PullLogsRequest,\n+    PullLogsResponse, PurgeDirtyForCollectionRequest, PurgeDirtyForCollectionResponse,\n+    PushLogsRequest, PushLogsResponse, ScoutLogsRequest, ScoutLogsResponse, SealLogRequest,\n+    SealLogResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n };\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n@@ -1230,6 +1231,24 @@ impl LogService for LogServer {\n         }\n         Ok(Response::new(InspectDirtyLogResponse { markers }))\n     }\n+\n+    async fn seal_log(\n+        &self,\n+        _request: Request<SealLogRequest>,\n+    ) -> Result<Response<SealLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do sealing\",\n+        ))\n+    }\n+\n+    async fn migrate_log(\n+        &self,\n+        _request: Request<MigrateLogRequest>,\n+    ) -> Result<Response<MigrateLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do migrating yet\",\n+        ))\n+    }\n }\n \n fn parquet_to_records(parquet: Arc<Vec<u8>>) -> Result<Vec<(LogPosition, Vec<u8>)>, Status> {\n---\n\n\n---\n\nChoice C:\n.github/workflows/release-javascript-client.yml\n@@ -64,7 +64,7 @@ jobs:\n         cache: 'pnpm'\n         cache-dependency-path: 'clients/js/pnpm-lock.yaml'\n     - name: Install dependencies\n-      run: pnpm install --frozen-lockfile\n+      run: pnpm install --no-frozen-lockfile\n       working-directory: ./clients/js/\n     - name: Build packages\n       run: pnpm build\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -339,11 +339,16 @@ impl RollupPerCollection {\n             std::cmp::max(self.initial_insertion_epoch_us, initial_insertion_epoch_us);\n     }\n \n-    fn witness_manifest_and_cursor(&mut self, manifest: &Manifest, witness: Option<&Witness>) {\n+    fn witness_cursor(&mut self, witness: Option<&Witness>) {\n+        // NOTE(rescrv):  There's an easy dance here to justify this as correct.  For the start log\n+        // position to advance, there must have been at least one GC cycle with a cursor that was\n+        // something other than 1.  That cursor should never get deleted, therefore we have a\n+        // witness and the unwrap_or call 0x90s.\n+        //\n+        // The consequence of this breaking is that the offset in the log will be behind sysdb.\n         self.start_log_position = witness\n             .map(|x| x.1.position)\n-            .unwrap_or(manifest.minimum_log_position());\n-        self.limit_log_position = manifest.maximum_log_position();\n+            .unwrap_or(LogPosition::from_offset(1));\n     }\n \n     fn is_empty(&self) -> bool {\n@@ -999,15 +1004,6 @@ impl LogServer {\n         &self,\n         rollups: &mut HashMap<CollectionUuid, RollupPerCollection>,\n     ) -> Result<(), Error> {\n-        let load_manifest = |storage, collection_id| async move {\n-            let reader = LogReader::new(\n-                LogReaderOptions::default(),\n-                Arc::clone(storage),\n-                storage_prefix_for_log(collection_id),\n-            );\n-            let span = tracing::info_span!(\"manifest load\", collection_id = ?collection_id);\n-            reader.manifest().instrument(span).await\n-        };\n         let load_cursor = |storage, collection_id| async move {\n             let cursor = &COMPACTION;\n             let cursor_store = CursorStore::new(\n@@ -1020,18 +1016,12 @@ impl LogServer {\n             cursor_store.load(cursor).instrument(span).await\n         };\n         for (collection_id, mut rollup) in std::mem::take(rollups) {\n-            // TODO(rescrv):  We can avoid loading the manifest and cursor by checking an\n-            // in-memory lookaside structure.\n-            let Some(manifest) = load_manifest(&self.storage, collection_id).await? else {\n-                tracing::warn!(\"{collection_id} has no manifest; this may mean it was deleted\");\n-                continue;\n-            };\n             let cursor = load_cursor(&self.storage, collection_id).await?;\n             // NOTE(rescrv):  There are two spreads that we have.\n             // `rollup` tracks the minimum and maximum offsets of a record on the dirty log.\n             // The spread between cursor (if it exists) and manifest.maximum_log_offset tracks the\n             // data that needs to be compacted.\n-            rollup.witness_manifest_and_cursor(&manifest, cursor.as_ref());\n+            rollup.witness_cursor(cursor.as_ref());\n             if !rollup.is_empty() {\n                 rollups.insert(collection_id, rollup);\n             }\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThe first few parallel inserts could do the following:\n- Race to the effectuate_log_transfer's mutex acquisition and pile up.\n- First thread through bootstraps the log.\n- Remaining threads try to bootstrap again which fails with\n  LogContention.\n\n## Test plan\n\nCI + plan for staging.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\n.github/workflows/release-javascript-client.yml\n@@ -64,7 +64,7 @@ jobs:\n         cache: 'pnpm'\n         cache-dependency-path: 'clients/js/pnpm-lock.yaml'\n     - name: Install dependencies\n-      run: pnpm install --frozen-lockfile\n+      run: pnpm install --no-frozen-lockfile\n       working-directory: ./clients/js/\n     - name: Build packages\n       run: pnpm build\n---\n\n\n---\n\nChoice B:\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -140,21 +140,20 @@ impl GarbageCollector {\n             .as_ref()\n             .ok_or(GarbageCollectCollectionError::Uninitialized)?;\n \n-        let use_v1_orchestrator = match cleanup_mode {\n-            CleanupMode::DryRun | CleanupMode::Rename | CleanupMode::Delete => true,\n-            CleanupMode::DryRunV2 | CleanupMode::DeleteV2 => false,\n-        };\n-\n-        if use_v1_orchestrator {\n+        if cleanup_mode.is_v2() {\n             let orchestrator =\n-                crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+                crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n                     collection.id,\n                     collection.version_file_path,\n+                    collection.lineage_file_path,\n                     absolute_cutoff_time,\n                     self.sysdb_client.clone(),\n                     dispatcher.clone(),\n+                    system.clone(),\n                     self.storage.clone(),\n+                    self.root_manager.clone(),\n                     cleanup_mode,\n+                    2,\n                 );\n \n             let started_at = SystemTime::now();\n@@ -178,23 +177,19 @@ impl GarbageCollector {\n                     format!(\"{:?}\", cleanup_mode),\n                 )],\n             );\n+\n             return Ok(result);\n         }\n \n-        let orchestrator =\n-            crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n-                collection.id,\n-                collection.version_file_path,\n-                collection.lineage_file_path,\n-                absolute_cutoff_time,\n-                self.sysdb_client.clone(),\n-                dispatcher.clone(),\n-                system.clone(),\n-                self.storage.clone(),\n-                self.root_manager.clone(),\n-                cleanup_mode,\n-                2,\n-            );\n+        let orchestrator = crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+            collection.id,\n+            collection.version_file_path,\n+            absolute_cutoff_time,\n+            self.sysdb_client.clone(),\n+            dispatcher.clone(),\n+            self.storage.clone(),\n+            cleanup_mode,\n+        );\n \n         let started_at = SystemTime::now();\n         let result = orchestrator.run(system.clone()).await?;\n@@ -217,7 +212,6 @@ impl GarbageCollector {\n                 format!(\"{:?}\", cleanup_mode),\n             )],\n         );\n-\n         Ok(result)\n     }\n }\n@@ -360,9 +354,18 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 continue;\n             }\n \n-            if collection.lineage_file_path.is_some() {\n+            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n+                tenant_mode_overrides\n+                    .get(&collection.tenant)\n+                    .cloned()\n+                    .unwrap_or(self.default_cleanup_mode)\n+            } else {\n+                self.default_cleanup_mode\n+            };\n+\n+            if collection.lineage_file_path.is_some() && !cleanup_mode.is_v2() {\n                 tracing::debug!(\n-                    \"Skipping garbage collection for root of fork tree: {}\",\n+                    \"Skipping garbage collection for root of fork tree because GC v1 cannot handle fork trees: {}\",\n                     collection.id\n                 );\n                 num_skipped_jobs += 1;\n@@ -376,17 +379,6 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 collection.version_file_path\n             );\n \n-            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n-                tenant_mode_overrides\n-                    .get(&collection.tenant)\n-                    .cloned()\n-                    .unwrap_or(self.default_cleanup_mode)\n-            } else {\n-                self.default_cleanup_mode\n-            };\n-\n-            tracing::info!(\"Creating gc orchestrator for collection: {}\", collection.id);\n-\n             let instrumented_span = span!(parent: None, tracing::Level::INFO, \"Garbage collection job\", collection_id = ?collection.id, tenant_id = %collection.tenant, cleanup_mode = ?cleanup_mode);\n             instrumented_span.follows_from(Span::current());\n \n@@ -1011,6 +1003,26 @@ mod tests {\n         let (collection_in_delete_mode, database_name_in_delete_mode) =\n             collection_in_delete_mode_handle.await.unwrap();\n \n+        // Fork collection in delete mode to give it a lineage file (only GC v2 can handle fork trees)\n+        {\n+            let source_collection = sysdb\n+                .get_collections(Some(collection_in_delete_mode), None, None, None, None, 0)\n+                .await\n+                .unwrap();\n+            let source_collection = source_collection.first().unwrap();\n+\n+            sysdb\n+                .fork_collection(\n+                    collection_in_delete_mode,\n+                    source_collection.total_records_post_compaction,\n+                    source_collection.total_records_post_compaction,\n+                    CollectionUuid::new(),\n+                    \"test-fork\".to_string(),\n+                )\n+                .await\n+                .unwrap();\n+        }\n+\n         // Wait 1 second for cutoff time\n         tokio::time::sleep(Duration::from_secs(1)).await;\n \n---\nrust/garbage_collector/src/types.rs\n@@ -19,6 +19,12 @@ pub enum CleanupMode {\n     DeleteV2,\n }\n \n+impl CleanupMode {\n+    pub fn is_v2(&self) -> bool {\n+        matches!(self, CleanupMode::DryRunV2 | CleanupMode::DeleteV2)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub enum VersionStatus {\n     #[allow(dead_code)]\n---\n\n\n---\n\nChoice C:\nrust/load/src/opentelemetry_config.rs\n@@ -5,114 +5,41 @@\n \n use opentelemetry::global;\n use opentelemetry::trace::TracerProvider;\n-use opentelemetry_otlp::{WithExportConfig, WithHttpConfig};\n+use opentelemetry_otlp::WithExportConfig;\n use opentelemetry_sdk::propagation::TraceContextPropagator;\n use tracing_bunyan_formatter::BunyanFormattingLayer;\n use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Layer};\n \n-#[derive(Clone, Debug, Default)]\n-struct ChromaShouldSample;\n-\n-const BUSY_NS: opentelemetry::Key = opentelemetry::Key::from_static_str(\"busy_ns\");\n-const IDLE_NS: opentelemetry::Key = opentelemetry::Key::from_static_str(\"idle_ns\");\n-\n-fn is_slow(attributes: &[opentelemetry::KeyValue]) -> bool {\n-    let mut nanos = 0i64;\n-    for attr in attributes {\n-        if attr.key == BUSY_NS || attr.key == IDLE_NS {\n-            if let opentelemetry::Value::I64(ns) = attr.value {\n-                nanos += ns;\n-            }\n-        }\n-    }\n-    nanos > 20_000_000\n-}\n-\n-impl opentelemetry_sdk::trace::ShouldSample for ChromaShouldSample {\n-    fn should_sample(\n-        &self,\n-        _: Option<&opentelemetry::Context>,\n-        _: opentelemetry::trace::TraceId,\n-        name: &str,\n-        _: &opentelemetry::trace::SpanKind,\n-        attributes: &[opentelemetry::KeyValue],\n-        _: &[opentelemetry::trace::Link],\n-    ) -> opentelemetry::trace::SamplingResult {\n-        // NOTE(rescrv):  THIS IS A HACK!  If you find yourself seriously extending it, it's time\n-        // to investigate honeycomb's sampling capabilities.\n-\n-        // If the name is not get and not insert, or the request is slow, sample it.\n-        // Otherwise, drop.\n-        // This filters filters foyer calls in-process so they won't be overwhelming the tracing.\n-        if (name != \"get\" && name != \"insert\") || is_slow(attributes) {\n-            opentelemetry::trace::SamplingResult {\n-                decision: opentelemetry::trace::SamplingDecision::RecordAndSample,\n-                attributes: vec![],\n-                trace_state: opentelemetry::trace::TraceState::default(),\n-            }\n-        } else {\n-            opentelemetry::trace::SamplingResult {\n-                decision: opentelemetry::trace::SamplingDecision::Drop,\n-                attributes: vec![],\n-                trace_state: opentelemetry::trace::TraceState::default(),\n-            }\n-        }\n-    }\n-}\n-\n pub(crate) fn init_otel_tracing(service_name: &String, otel_endpoint: &String) {\n-    println!(\n+    tracing::info!(\n         \"Registering jaeger subscriber for {} at endpoint {}\",\n-        service_name, otel_endpoint\n+        service_name,\n+        otel_endpoint\n     );\n     let resource = opentelemetry_sdk::Resource::new(vec![opentelemetry::KeyValue::new(\n         \"service.name\",\n         service_name.clone(),\n     )]);\n \n     // Prepare tracer.\n-    let client = reqwest::Client::new();\n-    let span_exporter = opentelemetry_otlp::SpanExporter::builder()\n-        .with_http()\n-        .with_http_client(client)\n+    let tracing_span_exporter = opentelemetry_otlp::SpanExporter::builder()\n+        .with_tonic()\n         .with_endpoint(otel_endpoint)\n         .build()\n-        .expect(\"could not build span exporter\");\n-    let trace_config = opentelemetry_sdk::trace::Config::default()\n-        .with_sampler(ChromaShouldSample)\n-        .with_resource(resource.clone());\n+        .expect(\"could not build span exporter for tracing\");\n+    let trace_config = opentelemetry_sdk::trace::Config::default().with_resource(resource.clone());\n     let tracer_provider = opentelemetry_sdk::trace::TracerProvider::builder()\n-        .with_batch_exporter(span_exporter, opentelemetry_sdk::runtime::Tokio)\n+        .with_batch_exporter(tracing_span_exporter, opentelemetry_sdk::runtime::Tokio)\n         .with_config(trace_config)\n         .build();\n     let tracer = tracer_provider.tracer(service_name.clone());\n-    // TODO(MrCroxx): Should we the tracer provider as global?\n-    // global::set_tracer_provider(tracer_provider);\n \n     // Prepare meter.\n-    let mut headers = reqwest::header::HeaderMap::new();\n-    headers.insert(\n-        \"x-honeycomb-dataset\",\n-        reqwest::header::HeaderValue::from_static(\"chroma-load\"),\n-    );\n-    if let Ok(api_key) = std::env::var(\"OTEL_EXPORTER_OTLP_HEADERS\") {\n-        if let Some((header, value)) = api_key.split_once(\"=\") {\n-            if header == \"x-honeycomb-team\" {\n-                headers.insert(\n-                    reqwest::header::HeaderName::from_static(\"x-honeycomb-team\"),\n-                    reqwest::header::HeaderValue::from_bytes(value.trim().as_bytes()).unwrap(),\n-                );\n-            }\n-        }\n-    }\n-    let client = reqwest::ClientBuilder::new()\n-        .default_headers(headers)\n-        .build()\n-        .unwrap();\n     let metric_exporter = opentelemetry_otlp::MetricExporter::builder()\n-        .with_http()\n-        .with_http_client(client)\n-        .with_endpoint(otel_endpoint)\n+        .with_tonic()\n+        .with_endpoint(\n+            std::env::var(\"OTEL_EXPORTER_OTLP_METRICS_ENDPOINT\").unwrap_or(otel_endpoint.clone()),\n+        )\n         .build()\n         .expect(\"could not build metric exporter\");\n \n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -215,7 +215,18 @@ async fn get_log_from_handle<'a>(\n     prefix: &str,\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n-    let mut active = handle.active.lock().await;\n+    let active = handle.active.lock().await;\n+    get_log_from_handle_with_mutex_held(handle, active, options, storage, prefix, mark_dirty).await\n+}\n+\n+async fn get_log_from_handle_with_mutex_held<'a>(\n+    handle: &'a crate::state_hash_table::Handle<LogKey, LogStub>,\n+    mut active: tokio::sync::MutexGuard<'_, ActiveLog>,\n+    options: &LogWriterOptions,\n+    storage: &Arc<Storage>,\n+    prefix: &str,\n+    mark_dirty: MarkDirty,\n+) -> Result<LogRef<'a>, wal3::Error> {\n     if active.log.is_some() {\n         active.keep_alive(Duration::from_secs(60));\n     }\n@@ -519,7 +530,12 @@ impl LogServer {\n         // Grab a lock on the state for this key, so that a racing initialize won't do anything.\n         let key = LogKey { collection_id };\n         let handle = self.open_logs.get_or_create_state(key);\n-        let mut _active = handle.active.lock().await;\n+        let active = handle.active.lock().await;\n+\n+        // Someone already initialized the log on a prior call.\n+        if active.log.is_some() {\n+            return Ok(());\n+        }\n \n         tracing::info!(\"log transfer to {collection_id}\");\n         let scout_request = Request::new(ScoutLogsRequest {\n@@ -641,6 +657,23 @@ impl LogServer {\n             log_offset: start as i64 - 1,\n         }))\n         .await?;\n+        // Set it up so that once we release the mutex, the next person won't do I/O and will\n+        // immediately be able to push logs.\n+        let storage_prefix = storage_prefix_for_log(collection_id);\n+        let mark_dirty = MarkDirty {\n+            collection_id,\n+            dirty_log: Arc::clone(&self.dirty_log),\n+        };\n+        // If this fails, the next writer will load manifest and continue unimpeded.\n+        let _ = get_log_from_handle_with_mutex_held(\n+            &handle,\n+            active,\n+            &self.config.writer,\n+            &self.storage,\n+            &storage_prefix,\n+            mark_dirty,\n+        )\n+        .await;\n         Ok(())\n     }\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - ...\r\n- New functionality\r\n  - Updates `AuthenticateAndAuthorize`'s `authenticate_and_authorize` and `authenticate_and_authorize_collection` methods to return an `AuthzResource` instead of an empty result. This is so that we may indicate that the authorized resource is something the same or different than the requested `AuthzResource`\r\n  - Adds a `message` field to `AuthError` to allow for custom error messages\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nk8s/test/minio.yaml\n@@ -16,7 +16,9 @@ spec:\n     spec:\n       volumes:\n         - name: minio\n-          emptyDir: {}\n+          emptyDir:\n+            medium: Memory\n+            sizeLimit: 2Gi\n       containers:\n         - name: minio\n           image: minio/minio:latest\n@@ -46,7 +48,7 @@ metadata:\n spec:\n   ports:\n     - name: http\n-    # Put the lb on a different port so we can run minio locally since the port is already in use\n+      # Put the lb on a different port so we can run minio locally since the port is already in use\n       port: 9001\n       targetPort: 9000\n   selector:\n---\nrust/garbage_collector/src/operators/delete_unused_files.rs\n@@ -147,27 +147,30 @@ impl Operator<DeleteUnusedFilesInput, DeleteUnusedFilesOutput> for DeleteUnusedF\n             CleanupMode::Delete | CleanupMode::DeleteV2 => {\n                 // Hard delete - remove the file\n                 if !all_files.is_empty() {\n-                    let mut delete_stream = futures::stream::iter(all_files.clone())\n-                        .map(move |file_path| self.delete_with_path(file_path))\n-                        .buffer_unordered(100);\n-\n-                    // Process any errors that occurred\n-                    while let Some(result) = delete_stream.next().await {\n-                        if let Err(e) = result {\n-                            match e {\n-                                StorageError::NotFound { path, source } => {\n-                                    tracing::info!(\"Rename file {path} not found: {source}\")\n-                                }\n-                                err => tracing::error!(\"Failed to delete: {err}\"),\n-                            }\n-                        }\n-                    }\n+                    // let mut delete_stream = futures::stream::iter(all_files.clone())\n+                    //     .map(move |file_path| self.delete_with_path(file_path))\n+                    //     .buffer_unordered(100);\n+\n+                    // // Process any errors that occurred\n+                    // while let Some(result) = delete_stream.next().await {\n+                    //     if let Err(e) = result {\n+                    //         match e {\n+                    //             StorageError::NotFound { path, source } => {\n+                    //                 tracing::info!(\"Rename file {path} not found: {source}\")\n+                    //             }\n+                    //             err => tracing::error!(\"Failed to delete: {err}\"),\n+                    //         }\n+                    //     }\n+                    // }\n+\n+                    self.storage.delete_many(all_files).await.unwrap();\n                 }\n             }\n         }\n \n         Ok(DeleteUnusedFilesOutput {\n-            deleted_files: all_files.into_iter().collect(),\n+            // deleted_files: all_files.into_iter().collect(),\n+            deleted_files: HashSet::new(),\n         })\n     }\n }\n---\nrust/storage/src/lib.rs\n@@ -302,6 +302,15 @@ impl Storage {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        match self {\n+            Storage::ObjectStore(object_store) => object_store.delete_many(keys).await,\n+            Storage::S3(s3) => s3.delete_many(keys).await,\n+            Storage::Local(_) => unimplemented!(),\n+            Storage::AdmissionControlledS3(_) => unimplemented!(),\n+        }\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         match self {\n             Storage::ObjectStore(object_store) => object_store.rename(src_key, dst_key).await,\n---\nrust/storage/src/object_store.rs\n@@ -284,6 +284,30 @@ impl ObjectStore {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        let mut locations = Vec::new();\n+        for key in keys {\n+            locations.push(Ok(Path::from(key)));\n+        }\n+\n+        let mut stream = self\n+            .object_store\n+            .delete_stream(futures::stream::iter(locations).boxed());\n+\n+        while let Some(result) = stream.next().await {\n+            match result {\n+                Ok(_) => {\n+                    tracing::info!(\"Successfully deleted object\");\n+                }\n+                Err(e) => {\n+                    tracing::error!(error = %e, \"Failed to delete object\");\n+                    return Err(e.into());\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         tracing::info!(src = %src_key, dst = %dst_key, \"Renaming object\");\n \n---\nrust/storage/src/s3.rs\n@@ -647,6 +647,49 @@ impl S3Storage {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        tracing::debug!(keys = ?keys, \"Deleting multiple objects from S3\");\n+\n+        // batch by 1000 keys as per S3 limits\n+        let mut futures = Vec::new();\n+        for chunk in keys.chunks(1000) {\n+            let delete_req = self.client.delete_objects().bucket(&self.bucket).delete(\n+                aws_sdk_s3::types::Delete::builder()\n+                    .set_objects(Some(\n+                        chunk\n+                            .iter()\n+                            .map(|key| {\n+                                aws_sdk_s3::types::ObjectIdentifier::builder()\n+                                    .key(key)\n+                                    .build()\n+                                    .unwrap()\n+                            })\n+                            .collect::<Vec<_>>(),\n+                    ))\n+                    .build()\n+                    .unwrap(),\n+            );\n+\n+            futures.push(delete_req.send());\n+        }\n+        let results = futures::future::join_all(futures).await;\n+        for res in results {\n+            match res {\n+                Ok(_) => {\n+                    tracing::debug!(\"Successfully deleted objects from S3\");\n+                }\n+                Err(e) => {\n+                    tracing::error!(error = %e, \"Failed to delete objects from S3\");\n+                    return Err(StorageError::Generic {\n+                        source: Arc::new(e.into_service_error()),\n+                    });\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         tracing::info!(src = %src_key, dst = %dst_key, \"Renaming object in S3\");\n \n---\n\n\n---\n\nChoice B:\nrust/frontend/src/auth/mod.rs\n@@ -70,12 +70,40 @@ pub struct AuthzResource {\n }\n \n #[derive(thiserror::Error, Debug)]\n-#[error(\"Permission denied.\")]\n-pub struct AuthError(pub StatusCode);\n+pub struct AuthError {\n+    pub status_code: StatusCode,\n+    pub message: Option<String>,\n+}\n+\n+impl Display for AuthError {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(\n+            f,\n+            \"{}\",\n+            self.message.as_deref().unwrap_or(\"Permission denied.\")\n+        )\n+    }\n+}\n+\n+impl AuthError {\n+    pub fn new(status_code: StatusCode) -> Self {\n+        Self {\n+            status_code,\n+            message: None,\n+        }\n+    }\n+\n+    pub fn with_message(status_code: StatusCode, message: impl Into<String>) -> Self {\n+        Self {\n+            status_code,\n+            message: Some(message.into()),\n+        }\n+    }\n+}\n \n impl chroma_error::ChromaError for AuthError {\n     fn code(&self) -> chroma_error::ErrorCodes {\n-        match self.0 {\n+        match self.status_code {\n             StatusCode::UNAUTHORIZED => chroma_error::ErrorCodes::Unauthenticated,\n             StatusCode::FORBIDDEN => chroma_error::ErrorCodes::PermissionDenied,\n             _ => chroma_error::ErrorCodes::Internal,\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -235,6 +235,22 @@ impl ServiceBasedFrontend {\n         }\n     }\n \n+    fn _parse_universal_collection_identifier(input: String) -> Option<(String, String, String)> {\n+        let parts: Vec<&str> = input.split('/').collect();\n+        match parts.as_slice() {\n+            [tenant, database, collection]\n+                if !tenant.is_empty() && !database.is_empty() && !collection.is_empty() =>\n+            {\n+                Some((\n+                    tenant.to_string(),\n+                    database.to_string(),\n+                    collection.to_string(),\n+                ))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub async fn reset(&mut self) -> Result<ResetResponse, ResetError> {\n         if !self.allow_reset {\n             return Err(ResetError::NotAllowed);\n@@ -362,12 +378,19 @@ impl ServiceBasedFrontend {\n             ..\n         }: GetCollectionRequest,\n     ) -> Result<GetCollectionResponse, GetCollectionError> {\n+        let (resolved_tenant_id, resolved_database_name, resolved_collection_name) =\n+            Self::_parse_universal_collection_identifier(collection_name.clone()).unwrap_or((\n+                tenant_id.clone(),\n+                database_name.clone(),\n+                collection_name.clone(),\n+            ));\n+\n         let mut collections = self\n             .sysdb_client\n             .get_collections(GetCollectionsOptions {\n-                name: Some(collection_name.clone()),\n-                tenant: Some(tenant_id.clone()),\n-                database: Some(database_name.clone()),\n+                name: Some(resolved_collection_name.clone()),\n+                tenant: Some(resolved_tenant_id.clone()),\n+                database: Some(resolved_database_name.clone()),\n                 limit: Some(1),\n                 ..Default::default()\n             })\n---\n\n\n---\n\nChoice C:\nrust/types/src/api_types.rs\n@@ -82,7 +82,7 @@ impl ChromaError for GetCollectionWithSegmentsError {\n             GetCollectionWithSegmentsError::CollectionConversionError(\n                 collection_conversion_error,\n             ) => collection_conversion_error.code(),\n-            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::Internal,\n             GetCollectionWithSegmentsError::Field(_) => ErrorCodes::FailedPrecondition,\n             GetCollectionWithSegmentsError::SegmentConversionError(segment_conversion_error) => {\n                 segment_conversion_error.code()\n@@ -832,7 +832,7 @@ impl ChromaError for ForkCollectionError {\n             ForkCollectionError::CollectionConversionError(collection_conversion_error) => {\n                 collection_conversion_error.code()\n             }\n-            ForkCollectionError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            ForkCollectionError::DuplicateSegment => ErrorCodes::Internal,\n             ForkCollectionError::Field(_) => ErrorCodes::FailedPrecondition,\n             ForkCollectionError::Local => ErrorCodes::Unimplemented,\n             ForkCollectionError::Internal(chroma_error) => chroma_error.code(),\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/impls/utils.rs\n@@ -8,6 +8,8 @@ use chroma_types::{\n pub(crate) enum ToRecordsError {\n     #[error(\"Inconsistent number of IDs, embeddings, documents, URIs and metadatas\")]\n     InconsistentLength,\n+    #[error(\"Empty ID, ID must have at least one character\")]\n+    EmptyId,\n }\n \n impl ChromaError for ToRecordsError {\n@@ -47,6 +49,9 @@ pub(crate) fn to_records<\n     let mut records = Vec::with_capacity(len);\n \n     for id in ids {\n+        if id.is_empty() {\n+            return Err(ToRecordsError::EmptyId);\n+        }\n         let embedding = embeddings_iter.next().flatten();\n         let document = documents_iter.next().flatten();\n         let uri = uris_iter.next().flatten();\n@@ -87,3 +92,59 @@ pub(crate) fn to_records<\n \n     Ok((records, total_bytes))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use chroma_types::Operation;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_to_records_empty_id() {\n+        let ids = vec![String::from(\"\")];\n+        let embeddings = vec![Some(vec![1.0, 2.0, 3.0])];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(ids, Some(embeddings), None, None, None, Operation::Add);\n+        assert!(matches!(result, Err(ToRecordsError::EmptyId)));\n+    }\n+\n+    #[test]\n+    fn test_normal_ids() {\n+        let ids = vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\")];\n+        let embeddings = vec![\n+            Some(vec![1.0, 2.0, 3.0]),\n+            Some(vec![4.0, 5.0, 6.0]),\n+            Some(vec![7.0, 8.0, 9.0]),\n+        ];\n+        let documents = vec![\n+            Some(String::from(\"document 1\")),\n+            Some(String::from(\"document 2\")),\n+            Some(String::from(\"document 3\")),\n+        ];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(\n+            ids,\n+            Some(embeddings),\n+            Some(documents),\n+            None,\n+            None,\n+            Operation::Add,\n+        );\n+        assert!(result.is_ok());\n+        let records = result.unwrap().0;\n+        assert_eq!(records.len(), 3);\n+        assert_eq!(records[0].id, \"1\");\n+        assert_eq!(records[1].id, \"2\");\n+        assert_eq!(records[2].id, \"3\");\n+        assert_eq!(records[0].embedding, Some(vec![1.0, 2.0, 3.0]));\n+        assert_eq!(records[1].embedding, Some(vec![4.0, 5.0, 6.0]));\n+        assert_eq!(records[2].embedding, Some(vec![7.0, 8.0, 9.0]));\n+        assert_eq!(records[0].document, Some(String::from(\"document 1\")));\n+        assert_eq!(records[1].document, Some(String::from(\"document 2\")));\n+        assert_eq!(records[2].document, Some(String::from(\"document 3\")));\n+    }\n+}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nFix bug in 'where' clause validation for the JS client. Previously, the validation function recursed on the array of `$and` or `$or`, instead of the array elements themselves.\n\n---\n\nChoice A:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.4\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.0.4\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.4\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.4\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.4\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.1.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.1\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\n\n\n---\n\nChoice B:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.4\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.4\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.4\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.4\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.4\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\n\n\n---\n\nChoice C:\nclients/new-js/packages/chromadb/src/utils.ts\n@@ -350,7 +350,8 @@ export const validateWhere = (where: Where) => {\n         );\n       }\n \n-      Object.values(where).forEach((w: Where) => validateWhere(w));\n+      value.forEach((w: Where) => validateWhere(w));\n+      return;\n     }\n \n     if (typeof value === \"object\") {\n---\n\n\n---\n\nChoice D:\n.github/workflows/release-chromadb.yml\n@@ -61,6 +61,7 @@ jobs:\n   go-tests:\n     name: Go tests\n     uses: ./.github/workflows/_go-tests.yml\n+    secrets: inherit\n \n   release-docker:\n     name: Publish to DockerHub and GHCR\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Trace frag count in rust log service during scout log\n- New functionality\n  - N/A\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/cache/src/foyer.rs\n@@ -94,8 +94,17 @@ const fn default_trace_fetch_us() -> usize {\n     1000 * 100\n }\n \n+fn default_name() -> String {\n+    String::from(\"foyer\")\n+}\n+\n #[derive(Deserialize, Debug, Clone, Serialize, Parser)]\n pub struct FoyerCacheConfig {\n+    /// Name of the cache. All metrics for the cache are prefixed with name_.\n+    #[arg(long, default_value = \"foyer\")]\n+    #[serde(default = \"default_name\")]\n+    pub name: String,\n+\n     /// Directory for disk cache data.\n     #[arg(short, long)]\n     pub dir: Option<String>,\n@@ -262,6 +271,7 @@ impl FoyerCacheConfig {\n impl Default for FoyerCacheConfig {\n     fn default() -> Self {\n         FoyerCacheConfig {\n+            name: default_name(),\n             dir: None,\n             capacity: default_capacity(),\n             mem: default_mem(),\n@@ -352,6 +362,7 @@ where\n             ),\n         );\n         let builder = HybridCacheBuilder::<K, V>::new()\n+            .with_name(config.name.clone())\n             .with_metrics_registry(otel_0_27_metrics)\n             .with_tracing_options(tracing_options.clone())\n             .with_policy(foyer::HybridCachePolicy::WriteOnInsertion)\n@@ -537,6 +548,7 @@ where\n         config: &FoyerCacheConfig,\n     ) -> Result<FoyerPlainCache<K, V>, Box<dyn ChromaError>> {\n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .build();\n@@ -590,6 +602,7 @@ where\n         let evl = TokioEventListener(tx);\n \n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .with_event_listener(Arc::new(evl))\n---\nrust/frontend/sample_configs/distributed.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/worker/chroma_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     disk:\n+                        name: \"block_cache\"\n                         dir: \"/cache/chroma/query-service/block-cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n@@ -72,11 +73,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n \n@@ -138,15 +141,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\nrust/worker/tilt_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 block_cache_config:\n                     disk:\n                         dir: \"/cache/chroma/query-service/block-cache\"\n+                        name: \"block_cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n                         mem: 8000 # 8GiB\n@@ -71,11 +72,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n     fetch_log_batch_size: 1000\n@@ -141,15 +144,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -1104,6 +1104,7 @@ impl LogServer {\n                     manifest.maximum_log_position(),\n                 ),\n                 Ok(None) | Err(wal3::Error::UninitializedLog) => {\n+                    tracing::info!(\"Log is uninitialized on rust log service. Forwarding ScoutLog request to legacy log service\");\n                     return self.forward_scout_logs(Request::new(scout_logs)).await;\n                 }\n                 Err(err) => {\n@@ -1113,6 +1114,13 @@ impl LogServer {\n                     ));\n                 }\n             };\n+\n+            // NOTE(sicheng): This is temporary trace added for analyzing number of frags between the offsets\n+            match log_reader.scan(start_position, Default::default()).await {\n+                Ok(frags) => tracing::info!(name: \"Counting live fragments\", frag_count = frags.len()),\n+                Err(e) => tracing::error!(name: \"Unable to scout number of live fragments\", error = e.to_string()),\n+            }\n+\n             let start_offset = start_position.offset() as i64;\n             let limit_offset = limit_position.offset() as i64;\n             Ok(Response::new(ScoutLogsResponse {\n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.4\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.4\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.4\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.4\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.4\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -497,11 +497,6 @@ impl DirtyMarker {\n                         None\n                     }\n                     Ordering::Greater => {\n-                        tracing::info!(\n-                            \"{collection_id} has range ({}, {}]\",\n-                            record_compaction_position,\n-                            record_enumeration_position,\n-                        );\n                         uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_backpressure {\n                             backpressure.push(*collection_id);\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nHere's the scenario:  A client is writing in batches to the log.  The\r\nbatches come in groups, and wal3 does de-amplification of batches.\r\nImagine running a pull logs.  Prior to this change, the pull logs can\r\nonly knows which files to fetch based upon the number of files or number\r\nof bytes.\r\n\r\nBy pruning to number of records, we allow for the case where there's one\r\nfragment that has BatchSize records, and so we only need to fetch one\r\nfragment to read its records.\r\n\r\n## Test plan\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\nN/A\r\n\n\n---\n\nChoice A:\nCargo.lock\n@@ -1314,9 +1314,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.2.1\"\n+version = \"1.2.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fd9de9f2205d5ef3fd67e685b0df337994ddd4495e2a28d185500d0e1edfea47\"\n+checksum = \"8691782945451c1c383942c4874dbe63814f61cb57ef773cda2972682b7bb3c0\"\n dependencies = [\n  \"jobserver\",\n  \"libc\",\n@@ -2319,9 +2319,9 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.5.12\"\n+version = \"0.5.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab3db02a9c5b5121e1e42fbdb1aeb65f5e02624cc58c43f2884c6ccac0b82f95\"\n+checksum = \"82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2\"\n dependencies = [\n  \"crossbeam-utils\",\n ]\n@@ -4502,7 +4502,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34\"\n dependencies = [\n  \"cfg-if\",\n- \"windows-targets 0.52.6\",\n+ \"windows-targets 0.48.5\",\n ]\n \n [[package]]\n@@ -5315,9 +5315,9 @@ checksum = \"0ab1bc2a289d34bd04a330323ac98a1b4bc82c9d9fcb1e66b63caa84da26b575\"\n \n [[package]]\n name = \"openssl\"\n-version = \"0.10.66\"\n+version = \"0.10.72\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9529f4786b70a3e8c61e11179af17ab6188ad8d0ded78c5529441ed39d4bd9c1\"\n+checksum = \"fedfea7d58a1f73118430a55da6a286e7b044961736ce96a16a17068ea25e5da\"\n dependencies = [\n  \"bitflags 2.9.0\",\n  \"cfg-if\",\n@@ -5347,9 +5347,9 @@ checksum = \"ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf\"\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.103\"\n+version = \"0.9.108\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7f9e8deee91df40a943c71b917e5874b951d32a802526c85721ce3b776c929d6\"\n+checksum = \"e145e1651e858e820e4860f7b9c5e169bc1d8ce1c86043be79fa7b7634821847\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -6029,9 +6029,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"57fe09249128b3173d092de9523eaa75136bf7ba85e0d69eca241c7939c933cc\"\n+checksum = \"7778bffd85cf38175ac1f545509665d0b9b92a198ca7941f131f85f7a4f9a872\"\n dependencies = [\n  \"cfg-if\",\n  \"indoc\",\n@@ -6047,29 +6047,29 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-build-config\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cd3927b5a78757a0d71aa9dff669f903b1eb64b54142a9bd9f757f8fde65fd7\"\n+checksum = \"94f6cbe86ef3bf18998d9df6e0f3fc1050a8c5efa409bf712e661a4366e010fb\"\n dependencies = [\n  \"once_cell\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"pyo3-ffi\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dab6bb2102bd8f991e7749f130a70d05dd557613e39ed2deeee8e9ca0c4d548d\"\n+checksum = \"e9f1b4c431c0bb1c8fb0a338709859eed0d030ff6daa34368d3b152a63dfdd8d\"\n dependencies = [\n  \"libc\",\n  \"pyo3-build-config\",\n ]\n \n [[package]]\n name = \"pyo3-macros\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"91871864b353fd5ffcb3f91f2f703a22a9797c91b9ab497b1acac7b07ae509c7\"\n+checksum = \"fbc2201328f63c4710f68abdf653c89d8dbc2858b88c5d88b0ff38a75288a9da\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"pyo3-macros-backend\",\n@@ -6079,9 +6079,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-macros-backend\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"43abc3b80bc20f3facd86cd3c60beed58c3e2aa26213f3cda368de39c60a27e4\"\n+checksum = \"fca6726ad0f3da9c9de093d6f116a93c1a38e417ed73bf138472cf4064f72028\"\n dependencies = [\n  \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n@@ -6517,15 +6517,14 @@ dependencies = [\n \n [[package]]\n name = \"ring\"\n-version = \"0.17.8\"\n+version = \"0.17.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c17fa4cb658e3583423e915b9f3acc01cceaee1860e33d59ebae66adc3a2dc0d\"\n+checksum = \"a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7\"\n dependencies = [\n  \"cc\",\n  \"cfg-if\",\n  \"getrandom 0.2.15\",\n  \"libc\",\n- \"spin\",\n  \"untrusted\",\n  \"windows-sys 0.52.0\",\n ]\n@@ -7303,7 +7302,7 @@ version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"03c3c6b7927ffe7ecaa769ee0e3994da3b8cafc8f444578982c83ecb161af917\"\n dependencies = [\n- \"heck 0.5.0\",\n+ \"heck 0.4.1\",\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n  \"syn 2.0.101\",\n@@ -8058,9 +8057,9 @@ checksum = \"1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20\"\n \n [[package]]\n name = \"tokio\"\n-version = \"1.41.1\"\n+version = \"1.45.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22cfb5bee7a6a52939ca9224d6ac897bb669134078daa8735560897f69de4d33\"\n+checksum = \"2513ca694ef9ede0fb23fe71a4ee4107cb102b9dc1930f6d0fd77aae068ae165\"\n dependencies = [\n  \"backtrace\",\n  \"bytes\",\n@@ -8086,9 +8085,9 @@ dependencies = [\n \n [[package]]\n name = \"tokio-macros\"\n-version = \"2.4.0\"\n+version = \"2.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752\"\n+checksum = \"6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n---\n\n\n---\n\nChoice B:\nCargo.lock\n@@ -7563,6 +7563,7 @@ dependencies = [\n  \"libsqlite3-sys\",\n  \"log\",\n  \"percent-encoding\",\n+ \"regex\",\n  \"serde\",\n  \"serde_urlencoded\",\n  \"sqlx-core\",\n---\nchromadb/test/property/test_filtering.py\n@@ -6,6 +6,7 @@\n from chromadb.test.property import invariants\n from chromadb.api.types import (\n     Document,\n+    Documents,\n     Embedding,\n     Embeddings,\n     GetResult,\n@@ -566,3 +567,33 @@ def test_query_ids_filter_property(\n     # Also check that the number of results is reasonable\n     assert len(result_ids) <= n_results\n     assert len(result_ids) <= len(filter_ids_set)\n+\n+\n+def test_regex(client: ClientAPI) -> None:\n+    \"\"\"Tests that regex works\"\"\"\n+\n+    reset(client)\n+    coll = client.create_collection(name=\"test\")\n+\n+    test_ids: IDs = [\"1\", \"2\", \"3\"]\n+    test_documents: Documents = [\"cat\", \"Cat\", \"CAT\"]\n+    test_embeddings: Embeddings = [np.array([1, 1]), np.array([2, 2]), np.array([3, 3])]\n+    test_metadatas: Metadatas = [{\"test\": 10}, {\"test\": 20}, {\"test\": 30}]\n+\n+    coll.add(\n+        ids=test_ids,\n+        documents=test_documents,\n+        embeddings=test_embeddings,\n+        metadatas=test_metadatas,\n+    )\n+\n+    res = coll.get(where_document={\"$regex\": \"cat\"})\n+    assert res[\"ids\"] == [\"1\"]\n+\n+    res = coll.get(where_document={\"$regex\": \"(?i)cat\"})\n+    assert sorted(res[\"ids\"]) == [\"1\", \"2\", \"3\"]\n+\n+    res = coll.get(\n+        where={\"test\": {\"$ne\": 10}}, where_document={\"$regex\": \"(?i)c(?-i)at\"}  # type: ignore[dict-item]\n+    )\n+    assert res[\"ids\"] == [\"2\"]\n---\nrust/segment/src/sqlite_metadata.rs\n@@ -523,16 +523,27 @@ impl IntoSqliteExpr for DocumentExpression {\n         let subq = Query::select()\n             .column(EmbeddingFulltextSearch::Rowid)\n             .from(EmbeddingFulltextSearch::Table)\n-            .and_where(\n-                Expr::col(EmbeddingFulltextSearch::StringValue)\n-                    .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\"))),\n-            )\n+            .and_where(match self.operator {\n+                DocumentOperator::Contains | DocumentOperator::NotContains => {\n+                    Expr::col(EmbeddingFulltextSearch::StringValue)\n+                        .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n+                }\n+                DocumentOperator::Regex | DocumentOperator::NotRegex => Expr::cust_with_exprs(\n+                    \"? REGEXP ?\",\n+                    [\n+                        Expr::col(EmbeddingFulltextSearch::StringValue).into(),\n+                        Expr::value(&self.pattern),\n+                    ],\n+                ),\n+            })\n             .to_owned();\n         match self.operator {\n-            DocumentOperator::Contains => Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq),\n-            DocumentOperator::NotContains => Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq),\n-            DocumentOperator::Regex => todo!(\"Implement Regex matching. The result must be a not-nullable boolean (use `<expr>.is(true)`)\"),\n-            DocumentOperator::NotRegex => todo!(\"Implement negated Regex matching. This must be exact opposite of Regex matching (use `<expr>.not()`)\"),\n+            DocumentOperator::Contains | DocumentOperator::Regex => {\n+                Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n+            }\n+            DocumentOperator::NotContains | DocumentOperator::NotRegex => {\n+                Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq)\n+            }\n         }\n     }\n }\n---\nrust/sqlite/Cargo.toml\n@@ -9,7 +9,7 @@ regex = { workspace = true }\n sea-query = { workspace = true, features = [\"derive\"] }\n sea-query-binder = { workspace = true, features = [\"sqlx-sqlite\"] }\n sha2 = { workspace = true }\n-sqlx = { workspace = true }\n+sqlx = { workspace = true, features = [\"regexp\"] }\n tempfile = { workspace = true }\n pyo3 = { workspace = true, optional = true }\n thiserror = { workspace = true }\n@@ -22,4 +22,3 @@ rust-embed = { workspace = true }\n chroma-error = { workspace = true, features = [\"sqlx\"] }\n chroma-types = { workspace = true }\n chroma-config = { workspace = true }\n-\n---\nrust/sqlite/src/config.rs\n@@ -104,7 +104,8 @@ impl Configurable<SqliteDBConfig, SqliteCreationError> for SqliteDb {\n             // we turn it off\n             .pragma(\"foreign_keys\", \"OFF\")\n             .pragma(\"case_sensitive_like\", \"ON\")\n-            .busy_timeout(Duration::from_secs(1000));\n+            .busy_timeout(Duration::from_secs(1000))\n+            .with_regexp();\n         let conn = if let Some(url) = &config.url {\n             let path = Path::new(url);\n             if let Some(parent) = path.parent() {\n---\n\n\n---\n\nChoice C:\nrust/segment/src/sqlite_metadata.rs\n@@ -579,17 +579,17 @@ impl IntoSqliteExpr for CompositeExpression {\n \n impl IntoSqliteExpr for DocumentExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let doc_col = Expr::col((\n-            EmbeddingFulltextSearch::Table,\n-            EmbeddingFulltextSearch::StringValue,\n-        ));\n-        let doc_contains = doc_col\n-            .clone()\n-            .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .and(doc_col.is_not_null());\n+        let subq = Query::select()\n+            .column(EmbeddingFulltextSearch::Rowid)\n+            .from(EmbeddingFulltextSearch::Table)\n+            .and_where(\n+                Expr::col(EmbeddingFulltextSearch::StringValue)\n+                    .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\"))),\n+            )\n+            .to_owned();\n         match self.operator {\n-            DocumentOperator::Contains => doc_contains,\n-            DocumentOperator::NotContains => doc_contains.not(),\n+            DocumentOperator::Contains => Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq),\n+            DocumentOperator::NotContains => Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq),\n             DocumentOperator::Regex => todo!(\"Implement Regex matching. The result must be a not-nullable boolean (use `<expr>.is(true)`)\"),\n             DocumentOperator::NotRegex => todo!(\"Implement negated Regex matching. This must be exact opposite of Regex matching (use `<expr>.not()`)\"),\n         }\n@@ -805,20 +805,11 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            let (has_document_expr, has_metadata_expr) = match whr {\n+            let (_, has_metadata_expr) = match whr {\n                 Where::Composite(expr) => expr.has_document_and_metadata(),\n                 Where::Document(_) => (true, false),\n                 Where::Metadata(_) => (false, true),\n             };\n-            if has_document_expr {\n-                filter_limit_query.left_join(\n-                    EmbeddingFulltextSearch::Table,\n-                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n-                        EmbeddingFulltextSearch::Table,\n-                        EmbeddingFulltextSearch::Rowid,\n-                    )),\n-                );\n-            }\n             if has_metadata_expr {\n                 filter_limit_query.left_join(\n                     EmbeddingMetadata::Table,\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -917,6 +917,7 @@ impl LogServer {\n                 Limits {\n                     max_files: Some(10_000),\n                     max_bytes: Some(1_000_000_000),\n+                    max_records: Some(10_000),\n                 },\n             )\n             .await?;\n@@ -1151,6 +1152,7 @@ impl LogServer {\n             let limits = Limits {\n                 max_files: Some(pull_logs.batch_size as u64 + 1),\n                 max_bytes: None,\n+                max_records: Some(pull_logs.batch_size as u64),\n             };\n             let fragments = match log_reader\n                 .scan(\n@@ -1172,17 +1174,25 @@ impl LogServer {\n                 .map(|fragment| async {\n                     let cache_key = format!(\"{collection_id}::{}\", fragment.path);\n                     if let Some(cache) = self.cache.as_ref() {\n-                        if let Ok(Some(answer)) = cache.get(&cache_key).await {\n+                        let cache_span = tracing::info_span!(\"cache get\");\n+                        if let Ok(Some(answer)) = cache.get(&cache_key).instrument(cache_span).await\n+                        {\n                             return Ok(Arc::new(answer.bytes));\n                         }\n-                        let answer = log_reader.fetch(fragment).await?;\n+                        let fetch_span = tracing::info_span!(\"fragment fetch\");\n+                        let answer = log_reader.fetch(fragment).instrument(fetch_span).await?;\n                         let cache_value = CachedParquetFragment {\n                             bytes: Clone::clone(&*answer),\n                         };\n-                        cache.insert(cache_key, cache_value).await;\n+                        let insert_span = tracing::info_span!(\"cache insert\");\n+                        cache\n+                            .insert(cache_key, cache_value)\n+                            .instrument(insert_span)\n+                            .await;\n                         Ok(answer)\n                     } else {\n-                        log_reader.fetch(fragment).await\n+                        let fetch_span = tracing::info_span!(\"fragment fetch\");\n+                        log_reader.fetch(fragment).instrument(fetch_span).await\n                     }\n                 })\n                 .collect::<Vec<_>>();\n@@ -1411,6 +1421,7 @@ impl LogServer {\n                 Limits {\n                     max_files: Some(1_000_000),\n                     max_bytes: Some(1_000_000_000),\n+                    max_records: Some(1_000_000),\n                 },\n             )\n             .await\n---\nrust/wal3/src/reader.rs\n@@ -22,6 +22,7 @@ use crate::{\n pub struct Limits {\n     pub max_files: Option<u64>,\n     pub max_bytes: Option<u64>,\n+    pub max_records: Option<u64>,\n }\n \n /// LogReader is a reader for the log.\n@@ -90,16 +91,27 @@ impl LogReader {\n         else {\n             return Err(Error::UninitializedLog);\n         };\n+        let log_position_range = if let Some(max_records) = limits.max_records {\n+            (from, from + max_records)\n+        } else {\n+            (from, LogPosition::MAX)\n+        };\n+        fn ranges_overlap(\n+            lhs: (LogPosition, LogPosition),\n+            rhs: (LogPosition, LogPosition),\n+        ) -> bool {\n+            lhs.0 <= rhs.1 && rhs.0 <= lhs.1\n+        }\n         let mut snapshots = manifest\n             .snapshots\n             .iter()\n-            .filter(|s| s.limit.offset() > from.offset())\n+            .filter(|s| ranges_overlap(log_position_range, (s.start, s.limit)))\n             .cloned()\n             .collect::<Vec<_>>();\n         let mut fragments = manifest\n             .fragments\n             .iter()\n-            .filter(|f| f.limit.offset() > from.offset())\n+            .filter(|f| ranges_overlap(log_position_range, (f.start, f.limit)))\n             .cloned()\n             .collect::<Vec<_>>();\n         while !snapshots.is_empty() {\n@@ -137,6 +149,18 @@ impl LogReader {\n                 fragments.truncate(max_files as usize);\n             }\n         }\n+        while fragments.len() > 1\n+            // NOTE(rescrv):  We take the start of the last fragment, because if there are enough\n+            // records without it we can pop.\n+            && fragments[fragments.len() - 1].start - fragments[0].start\n+                > limits.max_records.unwrap_or(u64::MAX)\n+        {\n+            tracing::info!(\n+                \"truncating to {} files because records restrictions\",\n+                fragments.len() - 1\n+            );\n+            fragments.pop();\n+        }\n         while fragments.len() > 1\n             && fragments\n                 .iter()\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nAdds support to pass pathlib.Path for persistence\r\nhttps://github.com/chroma-core/chroma/issues/4704\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -1484,6 +1484,7 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n         ALL_MINILM_L6_V2,\n         1_000_000,\n     )));\n+    data_sets.push(Arc::clone(&reference_data_set) as _);\n     data_sets.push(Arc::new(VerifyingDataSet {\n         reference_data_set,\n         test_data_set: \"test-all-MiniLM-L6-v2\".to_string(),\n---\n\n\n---\n\nChoice B:\nchromadb/__init__.py\n@@ -1,4 +1,4 @@\n-from typing import Dict, Optional\n+from typing import Dict, Optional, Union\n import logging\n from chromadb.api.client import Client as ClientCreator\n from chromadb.api.client import AdminClient as AdminClientCreator\n@@ -26,6 +26,7 @@\n     WhereDocument,\n     UpdateCollectionMetadata,\n )\n+from pathlib import Path\n \n # Re-export types from chromadb.types\n __all__ = [\n@@ -135,7 +136,7 @@ def EphemeralClient(\n \n \n def PersistentClient(\n-    path: str = \"./chroma\",\n+    path: Union[str, Path] = \"./chroma\",\n     settings: Optional[Settings] = None,\n     tenant: str = DEFAULT_TENANT,\n     database: str = DEFAULT_DATABASE,\n@@ -151,7 +152,7 @@ def PersistentClient(\n     \"\"\"\n     if settings is None:\n         settings = Settings()\n-    settings.persist_directory = path\n+    settings.persist_directory = str(path)\n     settings.is_persistent = True\n \n     # Make sure paramaters are the correct types -- users can pass anything.\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/quota/mod.rs\n@@ -240,6 +240,7 @@ pub enum UsageType {\n     NumCollections,        // Total number of collections for a tenant\n     NumDatabases,          // Total number of databases for a tenant\n     NumQueryIDs,           // Number of IDs to filter by in a query\n+    NumRegexPredicates,    // Number of regex predicates in the where_document\n }\n \n impl fmt::Display for UsageType {\n@@ -269,6 +270,7 @@ impl fmt::Display for UsageType {\n             UsageType::NumCollections => write!(f, \"Number of collections\"),\n             UsageType::NumDatabases => write!(f, \"Number of databases\"),\n             UsageType::NumQueryIDs => write!(f, \"Number of IDs to filter by in a query\"),\n+            UsageType::NumRegexPredicates => write!(f, \"Number of regex predicates\"),\n         }\n     }\n }\n@@ -298,6 +300,7 @@ impl TryFrom<&str> for UsageType {\n             \"num_collections\" => Ok(UsageType::NumCollections),\n             \"num_databases\" => Ok(UsageType::NumDatabases),\n             \"num_query_ids\" => Ok(UsageType::NumQueryIDs),\n+            \"num_regex_predicates\" => Ok(UsageType::NumRegexPredicates),\n             _ => Err(format!(\"Invalid UsageType: {}\", value)),\n         }\n     }\n@@ -326,6 +329,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumCollections, 1_000_000);\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n+        m.insert(UsageType::NumRegexPredicates, 0);\n         m\n     };\n }\n---\n\n\n---\n\nChoice D:\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -140,21 +140,20 @@ impl GarbageCollector {\n             .as_ref()\n             .ok_or(GarbageCollectCollectionError::Uninitialized)?;\n \n-        let use_v1_orchestrator = match cleanup_mode {\n-            CleanupMode::DryRun | CleanupMode::Rename | CleanupMode::Delete => true,\n-            CleanupMode::DryRunV2 | CleanupMode::DeleteV2 => false,\n-        };\n-\n-        if use_v1_orchestrator {\n+        if cleanup_mode.is_v2() {\n             let orchestrator =\n-                crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+                crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n                     collection.id,\n                     collection.version_file_path,\n+                    collection.lineage_file_path,\n                     absolute_cutoff_time,\n                     self.sysdb_client.clone(),\n                     dispatcher.clone(),\n+                    system.clone(),\n                     self.storage.clone(),\n+                    self.root_manager.clone(),\n                     cleanup_mode,\n+                    2,\n                 );\n \n             let started_at = SystemTime::now();\n@@ -178,23 +177,19 @@ impl GarbageCollector {\n                     format!(\"{:?}\", cleanup_mode),\n                 )],\n             );\n+\n             return Ok(result);\n         }\n \n-        let orchestrator =\n-            crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n-                collection.id,\n-                collection.version_file_path,\n-                collection.lineage_file_path,\n-                absolute_cutoff_time,\n-                self.sysdb_client.clone(),\n-                dispatcher.clone(),\n-                system.clone(),\n-                self.storage.clone(),\n-                self.root_manager.clone(),\n-                cleanup_mode,\n-                2,\n-            );\n+        let orchestrator = crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+            collection.id,\n+            collection.version_file_path,\n+            absolute_cutoff_time,\n+            self.sysdb_client.clone(),\n+            dispatcher.clone(),\n+            self.storage.clone(),\n+            cleanup_mode,\n+        );\n \n         let started_at = SystemTime::now();\n         let result = orchestrator.run(system.clone()).await?;\n@@ -217,7 +212,6 @@ impl GarbageCollector {\n                 format!(\"{:?}\", cleanup_mode),\n             )],\n         );\n-\n         Ok(result)\n     }\n }\n@@ -360,9 +354,18 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 continue;\n             }\n \n-            if collection.lineage_file_path.is_some() {\n+            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n+                tenant_mode_overrides\n+                    .get(&collection.tenant)\n+                    .cloned()\n+                    .unwrap_or(self.default_cleanup_mode)\n+            } else {\n+                self.default_cleanup_mode\n+            };\n+\n+            if collection.lineage_file_path.is_some() && !cleanup_mode.is_v2() {\n                 tracing::debug!(\n-                    \"Skipping garbage collection for root of fork tree: {}\",\n+                    \"Skipping garbage collection for root of fork tree because GC v1 cannot handle fork trees: {}\",\n                     collection.id\n                 );\n                 num_skipped_jobs += 1;\n@@ -376,17 +379,6 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 collection.version_file_path\n             );\n \n-            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n-                tenant_mode_overrides\n-                    .get(&collection.tenant)\n-                    .cloned()\n-                    .unwrap_or(self.default_cleanup_mode)\n-            } else {\n-                self.default_cleanup_mode\n-            };\n-\n-            tracing::info!(\"Creating gc orchestrator for collection: {}\", collection.id);\n-\n             let instrumented_span = span!(parent: None, tracing::Level::INFO, \"Garbage collection job\", collection_id = ?collection.id, tenant_id = %collection.tenant, cleanup_mode = ?cleanup_mode);\n             instrumented_span.follows_from(Span::current());\n \n@@ -1011,6 +1003,26 @@ mod tests {\n         let (collection_in_delete_mode, database_name_in_delete_mode) =\n             collection_in_delete_mode_handle.await.unwrap();\n \n+        // Fork collection in delete mode to give it a lineage file (only GC v2 can handle fork trees)\n+        {\n+            let source_collection = sysdb\n+                .get_collections(Some(collection_in_delete_mode), None, None, None, None, 0)\n+                .await\n+                .unwrap();\n+            let source_collection = source_collection.first().unwrap();\n+\n+            sysdb\n+                .fork_collection(\n+                    collection_in_delete_mode,\n+                    source_collection.total_records_post_compaction,\n+                    source_collection.total_records_post_compaction,\n+                    CollectionUuid::new(),\n+                    \"test-fork\".to_string(),\n+                )\n+                .await\n+                .unwrap();\n+        }\n+\n         // Wait 1 second for cutoff time\n         tokio::time::sleep(Duration::from_secs(1)).await;\n \n---\nrust/garbage_collector/src/types.rs\n@@ -19,6 +19,12 @@ pub enum CleanupMode {\n     DeleteV2,\n }\n \n+impl CleanupMode {\n+    pub fn is_v2(&self) -> bool {\n+        matches!(self, CleanupMode::DryRunV2 | CleanupMode::DeleteV2)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub enum VersionStatus {\n     #[allow(dead_code)]\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nUnpins fastapi and moves to dev dependency. only use of it is in python fastapi server.\r\nhttps://github.com/chroma-core/chroma/issues/4243\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nrust/frontend/src/quota/mod.rs\n@@ -240,6 +240,7 @@ pub enum UsageType {\n     NumCollections,        // Total number of collections for a tenant\n     NumDatabases,          // Total number of databases for a tenant\n     NumQueryIDs,           // Number of IDs to filter by in a query\n+    NumRegexPredicates,    // Number of regex predicates in the where_document\n }\n \n impl fmt::Display for UsageType {\n@@ -269,6 +270,7 @@ impl fmt::Display for UsageType {\n             UsageType::NumCollections => write!(f, \"Number of collections\"),\n             UsageType::NumDatabases => write!(f, \"Number of databases\"),\n             UsageType::NumQueryIDs => write!(f, \"Number of IDs to filter by in a query\"),\n+            UsageType::NumRegexPredicates => write!(f, \"Number of regex predicates\"),\n         }\n     }\n }\n@@ -298,6 +300,7 @@ impl TryFrom<&str> for UsageType {\n             \"num_collections\" => Ok(UsageType::NumCollections),\n             \"num_databases\" => Ok(UsageType::NumDatabases),\n             \"num_query_ids\" => Ok(UsageType::NumQueryIDs),\n+            \"num_regex_predicates\" => Ok(UsageType::NumRegexPredicates),\n             _ => Err(format!(\"Invalid UsageType: {}\", value)),\n         }\n     }\n@@ -326,6 +329,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumCollections, 1_000_000);\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n+        m.insert(UsageType::NumRegexPredicates, 0);\n         m\n     };\n }\n---\n\n\n---\n\nChoice B:\ndocs/docs.trychroma.com/components/header/header-nav.tsx\n@@ -1,17 +1,8 @@\n 'use client'\n \n import React from \"react\";\n-import Logo from \"@/components/header/logo\";\n-import ThemeToggle from \"@/components/header/theme-toggle\";\n-import GithubLink from \"@/components/header/github-link\";\n-import XLink from \"@/components/header/x-link\";\n-import DiscordLink from \"@/components/header/discord-link\";\n-import Link from \"next/link\";\n-import SearchBox from \"@/components/header/search-box\";\n-import UpdatesLink from \"@/components/header/updates-link\";\n import sidebarConfig from \"@/markdoc/content/sidebar-config\";\n import MenuItem from \"../sidebar/menu-item\";\n-import { useRouter } from \"next/router\";\n import { useParams } from \"next/navigation\";\n \n const HeaderNav: React.FC = () => {\n@@ -22,7 +13,7 @@ const HeaderNav: React.FC = () => {\n   );\n \n   return (\n-    <div className=\"flex items-center flex-shrink-0 px-5 border-b-[1px] dark:border-gray-700 \">\n+    <div className=\"flex items-center flex-shrink-0 px-5 border-b-[1px] dark:border-gray-700 w-full overflow-x-auto\">\n       {sidebarConfig.map((section) => (\n       <MenuItem\n       key={section.id}\n---\ndocs/docs.trychroma.com/components/markdoc/table.tsx\n@@ -13,7 +13,7 @@ export const Table = React.forwardRef<\n   React.HTMLAttributes<HTMLTableElement>\n >(({ ...props }, ref) => {\n   return (\n-    <div className=\"relative w-full overflow-auto rounded-md my-5 border-[0.5px] border-gray-300\">\n+    <div className=\"relative w-full overflow-auto rounded-md my-5 border-[0.5px] border-gray-300 dark:border-gray-700\">\n       <UITable ref={ref} className=\"m-0\" {...props} />\n     </div>\n   );\n---\ndocs/docs.trychroma.com/components/sidebar/menu-item.tsx\n@@ -10,7 +10,7 @@ const MenuItem: React.FC<{ section: AppSection; active: boolean }> = ({\n \n   return (\n     <Link\n-     className={`border-b-4 h-12 px-3 pt-3 pr-5 text-gray-700/80 ${active ? \"border-chroma-orange \" : \"border-transparent hover:border-gray-100\"} ${!section.disable && \"hover:text-gray-800\"} dark:text-gray-400/80 dark:hover:text-gray-300`}\n+     className={`border-b-4 h-12 px-3 pt-3 pr-5 text-gray-700/80 ${active ? \"border-chroma-orange \" : \"border-transparent hover:border-gray-100 dark:hover:border-gray-300\"} ${!section.disable && \"hover:text-gray-800\"} dark:text-gray-400/80 dark:hover:text-gray-300 text-nowrap`}\n       href={\n         section.disable\n           ? \"\"\n---\ndocs/docs.trychroma.com/components/ui/table.tsx\n@@ -58,7 +58,7 @@ const TableRow = React.forwardRef<\n   <tr\n     ref={ref}\n     className={cn(\n-      \"border-b transition-colors data-[state=selected]:bg-zinc-100 dark:data-[state=selected]:bg-zinc-800\",\n+      \"border-b transition-colors data-[state=selected]:bg-zinc-100 dark:data-[state=selected]:bg-zinc-800 dark:border-gray-700\",\n       className,\n     )}\n     {...props}\n---\n\n\n---\n\nChoice C:\npyproject.toml\n@@ -7,10 +7,10 @@ description = \"Chroma.\"\n readme = \"README.md\"\n requires-python = \">=3.9\"\n classifiers = [\"Programming Language :: Python :: 3\", \"License :: OSI Approved :: Apache Software License\", \"Operating System :: OS Independent\"]\n-dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n \n [project.optional-dependencies]\n-dev = ['chroma-hnswlib==0.7.6']\n+dev = ['chroma-hnswlib==0.7.6', 'fastapi>=0.115.9', 'opentelemetry-instrumentation-fastapi>=0.41b0']\n \n [tool.black]\n line-length = 88\n---\nrequirements.txt\n@@ -1,5 +1,4 @@\n bcrypt>=4.0.1\n-fastapi==0.115.9\n graphlib_backport==1.0.3; python_version < '3.9'\n grpcio>=1.58.0\n httpx>=0.27.0\n@@ -11,7 +10,6 @@ numpy>=1.22.5\n onnxruntime>=1.14.1\n opentelemetry-api>=1.24.0\n opentelemetry-exporter-otlp-proto-grpc>=1.24.0\n-opentelemetry-instrumentation-fastapi>=0.41b0\n opentelemetry-sdk>=1.24.0\n orjson>=3.9.12\n overrides>=7.3.1\n---\nrequirements_dev.txt\n@@ -1,11 +1,13 @@\n black==23.3.0 # match what's in pyproject.toml\n build\n chroma-hnswlib==0.7.6\n+fastapi>=0.115.9\n grpcio-tools==1.67.1 # Later version not compatible with protobuf 4.25.5\n httpx\n hypothesis==6.112.2 # TODO: Resolve breaking changes and bump version\n hypothesis[numpy]==6.112.2 # TODO: Resolve breaking changes and bump version\n mypy-protobuf\n+opentelemetry-instrumentation-fastapi>=0.41b0\n pandas\n pre-commit\n protobuf==5.28.0 # Later version not compatible with opentelemetry 1.27.0\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -215,7 +215,18 @@ async fn get_log_from_handle<'a>(\n     prefix: &str,\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n-    let mut active = handle.active.lock().await;\n+    let active = handle.active.lock().await;\n+    get_log_from_handle_with_mutex_held(handle, active, options, storage, prefix, mark_dirty).await\n+}\n+\n+async fn get_log_from_handle_with_mutex_held<'a>(\n+    handle: &'a crate::state_hash_table::Handle<LogKey, LogStub>,\n+    mut active: tokio::sync::MutexGuard<'_, ActiveLog>,\n+    options: &LogWriterOptions,\n+    storage: &Arc<Storage>,\n+    prefix: &str,\n+    mark_dirty: MarkDirty,\n+) -> Result<LogRef<'a>, wal3::Error> {\n     if active.log.is_some() {\n         active.keep_alive(Duration::from_secs(60));\n     }\n@@ -519,7 +530,12 @@ impl LogServer {\n         // Grab a lock on the state for this key, so that a racing initialize won't do anything.\n         let key = LogKey { collection_id };\n         let handle = self.open_logs.get_or_create_state(key);\n-        let mut _active = handle.active.lock().await;\n+        let active = handle.active.lock().await;\n+\n+        // Someone already initialized the log on a prior call.\n+        if active.log.is_some() {\n+            return Ok(());\n+        }\n \n         tracing::info!(\"log transfer to {collection_id}\");\n         let scout_request = Request::new(ScoutLogsRequest {\n@@ -641,6 +657,23 @@ impl LogServer {\n             log_offset: start as i64 - 1,\n         }))\n         .await?;\n+        // Set it up so that once we release the mutex, the next person won't do I/O and will\n+        // immediately be able to push logs.\n+        let storage_prefix = storage_prefix_for_log(collection_id);\n+        let mark_dirty = MarkDirty {\n+            collection_id,\n+            dirty_log: Arc::clone(&self.dirty_log),\n+        };\n+        // If this fails, the next writer will load manifest and continue unimpeded.\n+        let _ = get_log_from_handle_with_mutex_held(\n+            &handle,\n+            active,\n+            &self.config.writer,\n+            &self.storage,\n+            &storage_prefix,\n+            mark_dirty,\n+        )\n+        .await;\n         Ok(())\n     }\n \n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nI'd like to be able to add instrumentation and not call it a chore.\n\n## Test plan\n\n- [N/A] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/log/src/grpc_log.rs\n@@ -383,9 +383,9 @@ impl GrpcLog {\n         match &mut self.alt_client_assigner {\n             Some(assigner) => assigner\n                 .clients(&collection_id.to_string())\n-                .unwrap_or_default()\n-                .first()\n-                .cloned(),\n+                .ok()?\n+                .drain(..)\n+                .next(),\n             None => None,\n         }\n     }\n---\n\n\n---\n\nChoice B:\nrust/segment/src/sqlite_metadata.rs\n@@ -579,17 +579,17 @@ impl IntoSqliteExpr for CompositeExpression {\n \n impl IntoSqliteExpr for DocumentExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let doc_col = Expr::col((\n-            EmbeddingFulltextSearch::Table,\n-            EmbeddingFulltextSearch::StringValue,\n-        ));\n-        let doc_contains = doc_col\n-            .clone()\n-            .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .and(doc_col.is_not_null());\n+        let subq = Query::select()\n+            .column(EmbeddingFulltextSearch::Rowid)\n+            .from(EmbeddingFulltextSearch::Table)\n+            .and_where(\n+                Expr::col(EmbeddingFulltextSearch::StringValue)\n+                    .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\"))),\n+            )\n+            .to_owned();\n         match self.operator {\n-            DocumentOperator::Contains => doc_contains,\n-            DocumentOperator::NotContains => doc_contains.not(),\n+            DocumentOperator::Contains => Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq),\n+            DocumentOperator::NotContains => Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq),\n             DocumentOperator::Regex => todo!(\"Implement Regex matching. The result must be a not-nullable boolean (use `<expr>.is(true)`)\"),\n             DocumentOperator::NotRegex => todo!(\"Implement negated Regex matching. This must be exact opposite of Regex matching (use `<expr>.not()`)\"),\n         }\n@@ -805,20 +805,11 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            let (has_document_expr, has_metadata_expr) = match whr {\n+            let (_, has_metadata_expr) = match whr {\n                 Where::Composite(expr) => expr.has_document_and_metadata(),\n                 Where::Document(_) => (true, false),\n                 Where::Metadata(_) => (false, true),\n             };\n-            if has_document_expr {\n-                filter_limit_query.left_join(\n-                    EmbeddingFulltextSearch::Table,\n-                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n-                        EmbeddingFulltextSearch::Table,\n-                        EmbeddingFulltextSearch::Rowid,\n-                    )),\n-                );\n-            }\n             if has_metadata_expr {\n                 filter_limit_query.left_join(\n                     EmbeddingMetadata::Table,\n---\n\n\n---\n\nChoice C:\n.github/workflows/pr.yml\n@@ -200,7 +200,7 @@ jobs:\n         - name: Check PR Title\n           uses: Slashgear/action-check-pr-title@v4.3.0\n           with:\n-            regexp: '\\[(ENH|BUG|DOC|TST|BLD|PERF|TYP|CLN|CHORE|RELEASE|HOTFIX)\\].*'\n+            regexp: '\\[(ENH|BUG|DOC|TST|BLD|PERF|TYP|CLN|CHORE|RELEASE|HOTFIX|INST)\\].*'\n             helpMessage: \"Please tag your PR title. See https://docs.trychroma.com/contributing#contributing-code-and-ideas. You must push new code to this PR for this check to run again.\"\n         - name: Comment explaining failure\n           if: failure()\n---\n\n\n---\n\nChoice D:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.41\n+version: 0.1.42\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -35,4 +35,4 @@ compactionService:\n       value: 'value: \"/tilt_config.yaml\"'\n \n rustLogService:\n-  replicaCount: 2\n+  replicaCount: 1\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nAdd tracing spans to see individual calls to get cursors and manifests.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\n.github/workflows/pr.yml\n@@ -200,7 +200,7 @@ jobs:\n         - name: Check PR Title\n           uses: Slashgear/action-check-pr-title@v4.3.0\n           with:\n-            regexp: '\\[(ENH|BUG|DOC|TST|BLD|PERF|TYP|CLN|CHORE|RELEASE|HOTFIX)\\].*'\n+            regexp: '\\[(ENH|BUG|DOC|TST|BLD|PERF|TYP|CLN|CHORE|RELEASE|HOTFIX|INST)\\].*'\n             helpMessage: \"Please tag your PR title. See https://docs.trychroma.com/contributing#contributing-code-and-ideas. You must push new code to this PR for this check to run again.\"\n         - name: Comment explaining failure\n           if: failure()\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -398,9 +398,10 @@ impl DirtyMarker {\n             let num_records = rollup_pc.limit_log_position - rollup_pc.start_log_position;\n             let reinsert_count = rollup_pc.reinsert_count;\n             let initial_insertion_epoch_us = rollup_pc.initial_insertion_epoch_us;\n-            let to_compact = num_records >= record_count_threshold\n+            let to_compact = true/*\n+                || num_records >= record_count_threshold\n                 || now_us - initial_insertion_epoch_us >= timeout_us\n-                || reinsert_count >= reinsert_threshold;\n+                || reinsert_count >= reinsert_threshold*/;\n             if to_compact {\n                 compactable.push(collection_id);\n             }\n@@ -2063,6 +2064,7 @@ mod tests {\n                 },\n             ),\n         ];\n+        /*\n         assert!(DirtyMarker::rollup(\n             Arc::new(storage),\n             |storage, collection_id| async move {\n@@ -2084,6 +2086,7 @@ mod tests {\n         .await\n         .unwrap()\n         .is_none());\n+        */\n     }\n \n     #[tokio::test]\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -376,6 +376,8 @@ impl DirtyMarker {\n         timeout_us: u64,\n         metrics: &Metrics,\n     ) -> Result<Option<Rollup>, wal3::Error> {\n+        let cpu_span = tracing::info_span!(\"cpu computation\");\n+        let cpu_span_guard = cpu_span.enter();\n         // NOTE(rescrv);  This is complicated code because it's a hard problem to do efficiently.\n         // To cut complexity, I've chosen to do it in a way that is not the most efficient but is\n         // readable and maintainable.  The most efficient way would be to do this in a single pass.\n@@ -420,6 +422,7 @@ impl DirtyMarker {\n         if compactable.is_empty() {\n             return Ok(None);\n         }\n+        drop(cpu_span_guard);\n         // Now fetch the compaction cursor for each collection.\n         let retrieve_manifest = Arc::new(retrieve_manifest);\n         let retrieve_cursor = Arc::new(retrieve_cursor);\n@@ -435,8 +438,10 @@ impl DirtyMarker {\n             })\n             .map(\n                 |(collection_id, storage, retrieve_manifest, retrieve_cursor)| async move {\n-                    let cursor = (*retrieve_cursor)(Arc::clone(&storage), collection_id);\n-                    let manifest = (*retrieve_manifest)(Arc::clone(&storage), collection_id);\n+                    let cursor = (*retrieve_cursor)(Arc::clone(&storage), collection_id)\n+                        .instrument(tracing::info_span!(\"fetching cursor\"));\n+                    let manifest = (*retrieve_manifest)(Arc::clone(&storage), collection_id)\n+                        .instrument(tracing::info_span!(\"fetching manifest\"));\n                     let (cursor, manifest) = futures::future::join(cursor, manifest).await;\n                     // NOTE(rescrv):  We silence the error so we log it instead.\n                     let cursor = match cursor {\n@@ -458,7 +463,12 @@ impl DirtyMarker {\n                 },\n             )\n             .collect::<Vec<_>>();\n-        let cursors = futures::future::join_all(futs).await;\n+        let rollup_span = tracing::info_span!(\"fetching cursors and manifests\");\n+        let cursors = futures::future::join_all(futs)\n+            .instrument(rollup_span)\n+            .await;\n+        let reprise_cpu_span = tracing::info_span!(\"cpu computation reprise\");\n+        let _reprise_cpu_span_guard = reprise_cpu_span.enter();\n         let cursors = cursors\n             .into_iter()\n             .flat_map(Result::ok)\n@@ -1361,6 +1371,7 @@ impl LogService for LogServer {\n                 );\n                 cursor_store.load(cursor).await\n             };\n+            let rollup_span = tracing::info_span!(\"DirtyMarker::rollup\");\n             let rollup = DirtyMarker::rollup(\n                 Arc::clone(&self.storage),\n                 load_manifest,\n@@ -1375,6 +1386,7 @@ impl LogService for LogServer {\n                 self.config.timeout_us,\n                 &self.metrics,\n             )\n+            .instrument(rollup_span)\n             .await\n             .map_err(|err| Status::unavailable(err.to_string()))?;\n             let Some(rollup) = rollup else {\n---\n\n\n---\n\nChoice D:\ndocs/docs.trychroma.com/markdoc/content/docs/collections/configure.md\n@@ -40,7 +40,7 @@ Here's how to configure the Cohere embedding function:\n import os\n assert os.environ.get(\"CHROMA_COHERE_API_KEY\"), \"CHROMA_COHERE_API_KEY environment variable not set\"\n \n-from chromadb.utils.embedding_functions import CohereEmbeddingFunction\n+from chromadb.utils.embedding_functions.cohere_embedding_function import CohereEmbeddingFunction\n \n # Create the Cohere embedding function (API key is read from environment variable)\n # By default, it reads from 'CHROMA_COHERE_API_KEY'\n@@ -109,7 +109,7 @@ Here is an example showing how to configure both the HNSW index and embedding fu\n import os\n assert os.environ.get(\"COHERE_API_KEY\"), \"COHERE_API_KEY environment variable not set\"\n \n-from chromadb.utils.embedding_functions import CohereEmbeddingFunction\n+from chromadb.utils.embedding_functions.cohere_embedding_function import CohereEmbeddingFunction\n \n # Create the Cohere embedding function\n cohere_ef = CohereEmbeddingFunction(model_name=\"embed-english-light-v2.0\")\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nFix Dockerhub release action\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -22,6 +22,7 @@ use chroma_types::chroma_proto::{\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n use figment::providers::{Env, Format, Yaml};\n+use opentelemetry::metrics::Meter;\n use parquet::arrow::arrow_reader::ParquetRecordBatchReaderBuilder;\n use prost::Message;\n use serde::{Deserialize, Serialize};\n@@ -48,6 +49,22 @@ const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n static STABLE_PREFIX: CursorName = unsafe { CursorName::from_string_unchecked(\"stable_prefix\") };\n static COMPACTION: CursorName = unsafe { CursorName::from_string_unchecked(\"compaction\") };\n \n+////////////////////////////////////////////// Metrics /////////////////////////////////////////////\n+\n+pub struct Metrics {\n+    log_total_uncompacted_records_count: opentelemetry::metrics::Gauge<f64>,\n+}\n+\n+impl Metrics {\n+    pub fn new(meter: Meter) -> Self {\n+        Self {\n+            log_total_uncompacted_records_count: meter\n+                .f64_gauge(\"log_total_uncompacted_records_count\")\n+                .build(),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////// state maintenance ////////////////////////////////////////\n \n // NOTE(rescrv):  This code dynamically opens and closes logs.  An opened log will stay open until\n@@ -334,6 +351,7 @@ impl DirtyMarker {\n \n     /// Given a contiguous prefix of markers, process the log into a rollup.  That is, a set of\n     /// markers to reinsert, a set of collections to compact, and an advance_to log position.\n+    #[allow(clippy::too_many_arguments)]\n     pub async fn rollup<\n         F1: Future<Output = Result<Option<Manifest>, wal3::Error>>,\n         F2: Future<Output = Result<Option<Witness>, wal3::Error>>,\n@@ -345,6 +363,7 @@ impl DirtyMarker {\n         record_count_threshold: u64,\n         reinsert_threshold: u64,\n         timeout_us: u64,\n+        metrics: &Metrics,\n     ) -> Result<Option<Rollup>, wal3::Error> {\n         // NOTE(rescrv);  This is complicated code because it's a hard problem to do efficiently.\n         // To cut complexity, I've chosen to do it in a way that is not the most efficient but is\n@@ -434,6 +453,7 @@ impl DirtyMarker {\n             .into_iter()\n             .flat_map(Result::ok)\n             .collect::<HashMap<_, _>>();\n+        let mut uncompacted = 0u64;\n         let compactable = compactable\n             .into_iter()\n             .filter_map(|collection_id| {\n@@ -473,6 +493,7 @@ impl DirtyMarker {\n                             cursor.position,\n                             manifest.maximum_log_position(),\n                         );\n+                        uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_threshold {\n                             Some(CollectionInfo {\n                                 collection_id: collection_id.to_string(),\n@@ -514,6 +535,9 @@ impl DirtyMarker {\n                 }\n             }\n         }\n+        metrics\n+            .log_total_uncompacted_records_count\n+            .record(uncompacted as f64, &[]);\n         Ok(Some(Rollup {\n             advance_to,\n             reinsert,\n@@ -608,6 +632,7 @@ pub struct LogServer {\n     dirty_log: Arc<LogWriter>,\n     compacting: tokio::sync::Mutex<()>,\n     cache: Option<Box<dyn chroma_cache::PersistentCache<String, CachedParquetFragment>>>,\n+    metrics: Metrics,\n }\n \n #[async_trait::async_trait]\n@@ -977,6 +1002,7 @@ impl LogService for LogServer {\n             ),\n             self.config.reinsert_threshold,\n             self.config.timeout_us,\n+            &self.metrics,\n         )\n         .await\n         .map_err(|err| Status::unavailable(err.to_string()))?;\n@@ -1456,13 +1482,15 @@ impl Configurable<LogServerConfig> for LogServer {\n         .map_err(|err| -> Box<dyn ChromaError> { Box::new(err) as _ })?;\n         let dirty_log = Arc::new(dirty_log);\n         let compacting = tokio::sync::Mutex::new(());\n+        let metrics = Metrics::new(opentelemetry::global::meter(\"chroma\"));\n         Ok(Self {\n             config: config.clone(),\n             open_logs: Arc::new(StateHashTable::default()),\n             storage,\n             dirty_log,\n             compacting,\n             cache,\n+            metrics,\n         })\n     }\n }\n@@ -1565,6 +1593,7 @@ mod tests {\n             1,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1626,6 +1655,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1709,6 +1739,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1822,6 +1853,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n---\n\n\n---\n\nChoice B:\nrust/chroma-tmp/Cargo.toml\n@@ -0,0 +1,33 @@\n+[package]\n+name = \"chroma-tmp\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[dependencies]\n+async-trait = { workspace = true }\n+chrono = { workspace = true }\n+clap = { workspace = true }\n+figment = { workspace = true }\n+rand = { workspace = true }\n+serde = { workspace = true }\n+serde_json = { workspace = true }\n+tokio = { workspace = true }\n+uuid = { workspace = true }\n+axum = { workspace = true }\n+\n+tracing = { workspace = true }\n+tracing-bunyan-formatter = { workspace = true }\n+tracing-opentelemetry = { workspace = true }\n+tracing-subscriber = { workspace = true }\n+opentelemetry = { workspace = true }\n+opentelemetry-otlp = { workspace = true }\n+opentelemetry-http = { workspace = true }\n+opentelemetry_sdk = { workspace = true }\n+\n+# Unlikely to be used in the workspace.\n+chromadb = { git = \"https://github.com/rescrv/chromadb-rs\", rev = \"540c3e225e92ecea05039b73b69adf5875385c0e\" }\n+guacamole = { version = \"0.11\", default-features = false }\n+tower-http = { workspace = true }\n+reqwest = { workspace = true, features = [\"json\"] }\n+siphasher = \"1.0.1\"\n+futures.workspace = true\n---\nrust/chroma-tmp/src/main.rs\n@@ -0,0 +1,138 @@\n+use std::collections::HashMap;\n+use std::sync::atomic::{AtomicU64, Ordering};\n+use std::sync::Arc;\n+\n+use guacamole::combinators::*;\n+use guacamole::Guacamole;\n+\n+use tokio::sync::Semaphore;\n+\n+use chromadb::client::{ChromaAuthMethod, ChromaClientOptions, ChromaTokenHeader};\n+use chromadb::collection::{CollectionEntries, GetOptions};\n+use chromadb::ChromaClient;\n+\n+#[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]\n+pub struct Connection {\n+    pub url: String,\n+    pub api_key: Option<String>,\n+    pub database: String,\n+}\n+\n+pub async fn client(connection: Connection) -> ChromaClient {\n+    let auth = if let Some(api_key) = connection.api_key.clone() {\n+        ChromaAuthMethod::TokenAuth {\n+            token: api_key,\n+            header: ChromaTokenHeader::XChromaToken,\n+        }\n+    } else {\n+        ChromaAuthMethod::None\n+    };\n+    ChromaClient::new(ChromaClientOptions {\n+        url: Some(connection.url.clone()),\n+        auth,\n+        database: connection.database.clone(),\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::main]\n+async fn main() {\n+    let success = Arc::new(AtomicU64::new(0));\n+    let failure = Arc::new(AtomicU64::new(0));\n+    let client = client(Connection {\n+        url: \"https://api.devchroma.com:8000\".to_string(),\n+        api_key: std::env::var(\"CHROMA_API_KEY\").ok(),\n+        database: std::env::var(\"CHROMA_DATABASE\").expect(\"set CHROMA_DATABASE\"),\n+    })\n+    .await;\n+    let mut collections = vec![];\n+    let mut collection_locks: HashMap<String, Arc<tokio::sync::Mutex<()>>> = HashMap::default();\n+    const COLLECTIONS: usize = 1000;\n+    for i in 1..=COLLECTIONS {\n+        let collection = client\n+            .get_or_create_collection(&format!(\"many-collections-{i}\"), None)\n+            .await\n+            .unwrap();\n+        println!(\"loaded {collection:?}\");\n+        collection_locks.insert(\n+            collection.id().to_string(),\n+            Arc::new(tokio::sync::Mutex::new(())),\n+        );\n+        collections.push(collection);\n+    }\n+    const MAGIC_CONSTANT: usize = 2000;\n+    let (tx, mut rx) = tokio::sync::mpsc::channel(MAGIC_CONSTANT);\n+    tokio::task::spawn(async move {\n+        while let Some(x) = rx.recv().await {\n+            let _ = x.await;\n+        }\n+    });\n+    let mut guac = Guacamole::new(0);\n+    let semaphore = Arc::new(Semaphore::new(MAGIC_CONSTANT));\n+    let start = std::time::Instant::now();\n+    let mut i = 0;\n+    while start.elapsed() < std::time::Duration::from_secs(600) {\n+        let collection = collections[i % collections.len()].clone();\n+        i += 1;\n+        let mut ids = vec![];\n+        let mut documents = vec![];\n+        let mut embeddings = vec![];\n+        for i in 0..100 {\n+            ids.push(format!(\"key-{i}\"));\n+            documents.push(\"dummy\");\n+            embeddings.push(vec![\n+                any::<f32>(&mut guac),\n+                any::<f32>(&mut guac),\n+                any::<f32>(&mut guac),\n+            ]);\n+        }\n+        let per_collection = collection_locks\n+            .get(collections[i % collections.len()].id())\n+            .map(Arc::clone)\n+            .unwrap();\n+        let semaphore = Arc::clone(&semaphore);\n+        let success = Arc::clone(&success);\n+        let failure = Arc::clone(&failure);\n+        let handle = tokio::task::spawn(async move {\n+            let _guard = per_collection.lock().await;\n+            let _permit = semaphore.acquire().await;\n+            let mut results = vec![];\n+            for i in 0..4 {\n+                let collection = collection.clone();\n+                let success = Arc::clone(&success);\n+                let failure = Arc::clone(&failure);\n+                let jh = tokio::task::spawn(async move {\n+                    let is_err = collection\n+                        .get(GetOptions {\n+                            ids: vec![format!(\"key-{i}\")],\n+                            where_metadata: None,\n+                            limit: Some(10),\n+                            offset: None,\n+                            where_document: None,\n+                            include: None,\n+                        })\n+                        .await\n+                        .is_err();\n+                    if is_err {\n+                        failure.fetch_add(1, Ordering::Relaxed);\n+                    } else {\n+                        success.fetch_add(1, Ordering::Relaxed);\n+                    }\n+                });\n+                results.push(jh);\n+            }\n+            futures::future::join_all(results).await;\n+            let ids = ids.iter().map(String::as_str).collect::<Vec<_>>();\n+            let entries = CollectionEntries {\n+                ids,\n+                embeddings: Some(embeddings),\n+                metadatas: None,\n+                documents: Some(documents),\n+            };\n+            let _results = collection.upsert(entries, None).await;\n+        });\n+        let _ = tx.send(handle).await;\n+    }\n+    drop(tx);\n+}\n---\n\n\n---\n\nChoice C:\n.github/actions/docker/action.yaml\n@@ -20,6 +20,8 @@ runs:\n     # https://github.com/docker/setup-qemu-action - for multiplatform builds\n     - name: Set up QEMU\n       uses: docker/setup-qemu-action@v2\n+    - name: Set up Docker Buildx\n+      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.11\"\n+__version__ = \"1.0.12\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.11\"\n+      \"Default\": \"1.0.12\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n- Fixes the off by one error during collection forking in rust log service\r\n- New functionality\r\n  - N/A\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs\r\nsection](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - ...\r\n- New functionality\r\n  - ...\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nrust/mdac/src/scorecard.rs\n@@ -622,4 +622,56 @@ mod tests {\n         assert_eq!(metrics.successful_untrack.load(Ordering::SeqCst), 0);\n         assert_eq!(metrics.failed_track.load(Ordering::SeqCst), 1);\n     }\n+\n+    #[test]\n+    fn three_patterns() {\n+        // Test an exact pattern-based override.\n+        let metrics = TestMetrics::default();\n+        let sc = Scorecard::new(\n+            &metrics,\n+            vec![\n+                Rule::new(\n+                    vec![\n+                        Pattern::must(\"op:*\"),\n+                        Pattern::must(\"tenant:me\"),\n+                        Pattern::must(\"collection:*\"),\n+                    ],\n+                    20,\n+                ),\n+                Rule::new(\n+                    vec![\n+                        Pattern::must(\"op:*\"),\n+                        Pattern::must(\"tenant:*\"),\n+                        Pattern::must(\"collection:*\"),\n+                    ],\n+                    10,\n+                ),\n+            ],\n+            1.try_into().unwrap(),\n+        );\n+        let mut saved_tickets = vec![];\n+        // Fill to the limit specified in the first rule.\n+        for _ in 0..20 {\n+            let t = sc.track(&[\"op:read\", \"tenant:me\", \"collection:foo\"]);\n+            assert!(t.is_some());\n+            saved_tickets.push(t);\n+        }\n+        // Reject\n+        let t = sc.track(&[\"op:read\", \"tenant:me\", \"collection:foo\"]);\n+        assert!(t.is_none());\n+        // Fill to the limit specified in the second rule.\n+        for _ in 0..10 {\n+            let t = sc.track(&[\"op:read\", \"tenant:you\", \"collection:foo\"]);\n+            assert!(t.is_some());\n+            saved_tickets.push(t);\n+        }\n+        // Reject\n+        let t = sc.track(&[\"op:read\", \"tenant:you\", \"collection:foo\"]);\n+        assert!(t.is_none());\n+\n+        assert_eq!(metrics.new_scorecard.load(Ordering::SeqCst), 1);\n+        assert_eq!(metrics.successful_track.load(Ordering::SeqCst), 30);\n+        assert_eq!(metrics.successful_untrack.load(Ordering::SeqCst), 0);\n+        assert_eq!(metrics.failed_track.load(Ordering::SeqCst), 2);\n+    }\n }\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -1219,17 +1219,16 @@ impl LogService for LogServer {\n             let witness = cursors.load(cursor_name).await.map_err(|err| {\n                 Status::new(err.code().into(), format!(\"Failed to load cursor: {}\", err))\n             })?;\n-            // This is the existing compaction_offset, which is the last record that was compacted.\n+            // This is the existing compaction_offset, which is the next record to compact.\n             let offset = witness\n                 .map(|x| x.1.position)\n-                .unwrap_or(LogPosition::from_offset(0));\n+                .unwrap_or(LogPosition::from_offset(1));\n             tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n                 &log_reader,\n-                // + 1 to get to the first uncompacted record.\n-                offset + 1u64,\n+                offset,\n                 target_prefix.clone(),\n             )\n             .await\n@@ -1253,7 +1252,9 @@ impl LogService for LogServer {\n             }\n             tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n-                compaction_offset: offset.offset(),\n+                // NOTE: The upstream service expects the last compacted offset as compaction offset\n+                compaction_offset: (offset - 1u64).offset(),\n+                // NOTE: The upstream service expects the last uncompacted offset as enumeration offset\n                 enumeration_offset: (max_offset - 1u64).offset(),\n             }))\n         }\n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\nChoice D:\nrust/load/src/bin/chroma-load-start.rs\n@@ -24,8 +24,6 @@ struct Args {\n     #[arg(long)]\n     database: String,\n     #[arg(long)]\n-    api_key: String,\n-    #[arg(long)]\n     constant_throughput: Option<f64>,\n     #[arg(long)]\n     sinusoid_throughput: Option<String>,\n@@ -90,6 +88,10 @@ impl Args {\n #[tokio::main]\n async fn main() {\n     let args = Args::parse();\n+\n+    // Read API key from environment variable.\n+    let api_key = std::env::var(\"CHROMA_API_KEY\").expect(\"CHROMA_API_KEY is not set\");\n+\n     let client = reqwest::Client::new();\n     let throughput = args.throughput();\n     let mut workload = Workload::ByName(args.workload);\n@@ -108,7 +110,7 @@ async fn main() {\n         data_set: args.data_set,\n         connection: Connection {\n             url: args.url,\n-            api_key: args.api_key,\n+            api_key,\n             database: args.database,\n         },\n         throughput,\n---\nrust/load/src/lib.rs\n@@ -1026,8 +1026,16 @@ pub struct LoadHarness {\n \n impl LoadHarness {\n     /// The status of the load harness.\n+    /// This returns the list of running workloads with secrets redacted.\n     pub fn status(&self) -> Vec<RunningWorkload> {\n-        self.running.clone()\n+        self.running\n+            .iter()\n+            .map(|w| {\n+                let mut w = w.clone();\n+                w.connection.api_key = \"REDACTED\".to_string();\n+                w\n+            })\n+            .collect()\n     }\n \n     /// Start a workload on the load harness.\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThere's an explicit assumption in wal3 that logs will be bound to a\nsingle writer.  To make concurrent writes possible we use the state hash\ntable to get to a single log.\n\nIf there was a case of serial writes, we would end up creating an entry in\nthe hash table, do the write, and then tear down the entry in the hash\ntable as part of the RAII-driven return.  This means every operation\nwould be a re-opening.\n\nInstead we keep the logs around for 60 seconds.  This could be made\nconfigurable.\n\nThis PR makes it so we only keep logs around for collections that are\nalready initialized.\n\n## Test plan\n\nCI\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -199,7 +199,9 @@ async fn get_log_from_handle<'a>(\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n     let mut active = handle.active.lock().await;\n-    active.keep_alive(Duration::from_secs(60));\n+    if active.log.is_some() {\n+        active.keep_alive(Duration::from_secs(60));\n+    }\n     if let Some(log) = active.log.as_ref() {\n         return Ok(LogRef {\n             log: Arc::clone(log),\n@@ -215,6 +217,7 @@ async fn get_log_from_handle<'a>(\n         mark_dirty.clone(),\n     )\n     .await?;\n+    active.keep_alive(Duration::from_secs(60));\n     tracing::info!(\"Opened log at {}\", prefix);\n     let opened = Arc::new(opened);\n     active.log = Some(Arc::clone(&opened));\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/server/server.go\n@@ -8,7 +8,9 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb\"\n \t\"github.com/chroma-core/chroma/go/pkg/proto/logservicepb\"\n \t\"github.com/chroma-core/chroma/go/pkg/types\"\n+\ttrace_log \"github.com/pingcap/log\"\n \t\"google.golang.org/protobuf/proto\"\n+\t\"go.uber.org/zap\"\n )\n \n type logServer struct {\n@@ -59,6 +61,7 @@ func (s *logServer) ScoutLogs(ctx context.Context, req *logservicepb.ScoutLogsRe\n \tres = &logservicepb.ScoutLogsResponse{\n \t\tFirstUninsertedRecordOffset: int64(limit + 1),\n \t}\n+\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n \treturn\n }\n \n---\n\n\n---\n\nChoice C:\nchromadb/test/distributed/test_log_failover.py\n@@ -189,3 +189,99 @@ def test_log_failover_with_compaction(\n             assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n         else:\n             assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_query_operations(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    # Add initial RECORDS records with known embeddings for querying\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Perform baseline similarity queries before failover\n+    query_embeddings = [embeddings[0], embeddings[RECORDS//2], embeddings[-1]]\n+    baseline_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        baseline_results.append(result)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Trigger log failover\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Re-run the same queries after failover and verify results consistency\n+    post_failover_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        post_failover_results.append(result)\n+\n+    # Verify that query results are consistent before and after failover\n+    for i, (baseline, post_failover) in enumerate(zip(baseline_results, post_failover_results)):\n+        assert len(baseline[\"ids\"][0]) == len(post_failover[\"ids\"][0]), f\"Query {i} returned different number of results\"\n+        assert baseline[\"ids\"][0] == post_failover[\"ids\"][0], f\"Query {i} returned different IDs\"\n+        # Verify embeddings match (allowing for small floating point differences)\n+        for j, (base_emb, post_emb) in enumerate(zip(baseline[\"embeddings\"][0], post_failover[\"embeddings\"][0])):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(base_emb, post_emb)]), f\"Query {i} result {j} embeddings differ\"\n+\n+    # Add more data post-failover\n+    post_failover_start = RECORDS\n+    for i in range(post_failover_start, post_failover_start + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Query for both old and new data to ensure full functionality\n+    # Test that we can find old data\n+    old_data_query = collection.query(\n+        query_embeddings=[embeddings[0]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(old_data_query[\"ids\"][0]) == 3, \"Failed to query old data after failover\"\n+\n+    # Test that we can find new data\n+    new_data_query = collection.query(\n+        query_embeddings=[embeddings[-1]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(new_data_query[\"ids\"][0]) == 3, \"Failed to query new data after failover\"\n+\n+    # Verify all data is still accessible by ID\n+    for i in range(len(ids)):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        assert len(result[\"embeddings\"]) > 0, f\"Missing result for ID {i} after failover with new data\"\n+        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])]), f\"Embedding mismatch for ID {i}\"\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1138,6 +1138,7 @@ func (tc *Catalog) createSegmentImpl(txCtx context.Context, createSegment *model\n \t\tType:         createSegment.Type,\n \t\tScope:        createSegment.Scope,\n \t\tTs:           ts,\n+\t\tFilePaths:    createSegment.FilePaths,\n \t}\n \terr := tc.metaDomain.SegmentDb(txCtx).Insert(dbSegment)\n \tif err != nil {\n@@ -2000,11 +2001,11 @@ func (tc *Catalog) getNumberOfActiveVersions(versionFilePb *coordinatorpb.Collec\n }\n \n func (tc *Catalog) getOldestVersionTs(versionFilePb *coordinatorpb.CollectionVersionFile) time.Time {\n-\tif versionFilePb.GetVersionHistory() == nil || len(versionFilePb.GetVersionHistory().Versions) <= 1 {\n+\tif versionFilePb.GetVersionHistory() == nil || len(versionFilePb.GetVersionHistory().Versions) == 0 {\n \t\t// Returning a zero timestamp that represents an unset value.\n \t\treturn time.Time{}\n \t}\n-\toldestVersionTs := versionFilePb.GetVersionHistory().Versions[1].CreatedAtSecs\n+\toldestVersionTs := versionFilePb.GetVersionHistory().Versions[0].CreatedAtSecs\n \n \treturn time.Unix(oldestVersionTs, 0)\n }\n@@ -2041,7 +2042,7 @@ func (tc *Catalog) DeleteVersionEntriesForCollection(ctx context.Context, tenant\n \t\t}\n \n \t\tnumActiveVersions := tc.getNumberOfActiveVersions(versionFilePb)\n-\t\tif numActiveVersions <= 1 {\n+\t\tif numActiveVersions < 1 {\n \t\t\t// No remaining valid versions after GC.\n \t\t\treturn errors.New(\"no valid versions after gc\")\n \t\t}\n@@ -2091,11 +2092,15 @@ func (tc *Catalog) DeleteCollectionVersion(ctx context.Context, req *coordinator\n \tresult := coordinatorpb.DeleteCollectionVersionResponse{\n \t\tCollectionIdToSuccess: make(map[string]bool),\n \t}\n+\tvar firstErr error\n \tfor _, collectionVersionList := range req.Versions {\n \t\terr := tc.DeleteVersionEntriesForCollection(ctx, collectionVersionList.TenantId, collectionVersionList.CollectionId, collectionVersionList.Versions)\n \t\tresult.CollectionIdToSuccess[collectionVersionList.CollectionId] = err == nil\n+\t\tif firstErr == nil && err != nil {\n+\t\t\tfirstErr = err\n+\t\t}\n \t}\n-\treturn &result, nil\n+\treturn &result, firstErr\n }\n \n func (tc *Catalog) BatchGetCollectionVersionFilePaths(ctx context.Context, collectionIds []string) (*coordinatorpb.BatchGetCollectionVersionFilePathsResponse, error) {\n---\ngo/pkg/sysdb/coordinator/table_catalog_test.go\n@@ -759,7 +759,7 @@ func TestCatalog_DeleteCollectionVersion_CollectionNotFound(t *testing.T) {\n \tresp, err := catalog.DeleteCollectionVersion(context.Background(), req)\n \n \t// Verify results\n-\tassert.NoError(t, err)\n+\tassert.Error(t, err)\n \tassert.NotNil(t, resp)\n \tassert.False(t, resp.CollectionIdToSuccess[collectionID])\n \n---\ngo/pkg/sysdb/grpc/proto_model_convert.go\n@@ -1,6 +1,8 @@\n package grpc\n \n import (\n+\t\"time\"\n+\n \t\"github.com/chroma-core/chroma/go/pkg/common\"\n \t\"github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb\"\n \t\"github.com/chroma-core/chroma/go/pkg/sysdb/coordinator/model\"\n@@ -131,6 +133,7 @@ func convertToCreateCollectionModel(req *coordinatorpb.CreateCollectionRequest)\n \t\tGetOrCreate:          req.GetGetOrCreate(),\n \t\tTenantID:             req.GetTenant(),\n \t\tDatabaseName:         req.GetDatabase(),\n+\t\tTs:                   time.Now().Unix(),\n \t}, nil\n }\n \n---\nrust/garbage_collector/src/operators/delete_versions_at_sysdb.rs\n@@ -38,6 +38,8 @@ pub struct DeleteVersionsAtSysDbOutput {\n \n #[derive(Error, Debug)]\n pub enum DeleteVersionsAtSysDbError {\n+    #[error(\"Unknown error occurred when deleting versions at sysdb\")]\n+    UnknownError,\n     #[error(\"Error deleting versions in sysdb: {0}\")]\n     SysDBError(String),\n     #[error(\"Error deleting version file {path}: {message}\")]\n@@ -157,7 +159,13 @@ impl Operator<DeleteVersionsAtSysDbInput, DeleteVersionsAtSysDbOutput>\n                 .delete_collection_version(vec![input.versions_to_delete.clone()])\n                 .await\n             {\n-                Ok(_) => {\n+                Ok(results) => {\n+                    for (_, was_successful) in results {\n+                        if !was_successful {\n+                            return Err(DeleteVersionsAtSysDbError::UnknownError);\n+                        }\n+                    }\n+\n                     tracing::info!(\n                         versions = ?input.versions_to_delete.versions,\n                         \"Successfully deleted versions from SysDB\"\n---\nrust/sysdb/src/sysdb.rs\n@@ -1331,14 +1331,14 @@ impl ChromaError for MarkVersionForDeletionError {\n \n #[derive(Error, Debug)]\n pub enum DeleteCollectionVersionError {\n-    #[error(\"Failed to delete version\")]\n+    #[error(\"Failed to delete version: {0}\")]\n     FailedToDeleteVersion(#[from] tonic::Status),\n }\n \n impl ChromaError for DeleteCollectionVersionError {\n     fn code(&self) -> ErrorCodes {\n         match self {\n-            DeleteCollectionVersionError::FailedToDeleteVersion(_) => ErrorCodes::Internal,\n+            DeleteCollectionVersionError::FailedToDeleteVersion(e) => e.code().into(),\n         }\n     }\n }\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Fixes the off by one error during collection forking in rust log service\n- New functionality\n  - N/A\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\ndocs/docs.trychroma.com/markdoc/content/docs/collections/configure.md\n@@ -40,7 +40,7 @@ Here's how to configure the Cohere embedding function:\n import os\n assert os.environ.get(\"CHROMA_COHERE_API_KEY\"), \"CHROMA_COHERE_API_KEY environment variable not set\"\n \n-from chromadb.utils.embedding_functions import CohereEmbeddingFunction\n+from chromadb.utils.embedding_functions.cohere_embedding_function import CohereEmbeddingFunction\n \n # Create the Cohere embedding function (API key is read from environment variable)\n # By default, it reads from 'CHROMA_COHERE_API_KEY'\n@@ -109,7 +109,7 @@ Here is an example showing how to configure both the HNSW index and embedding fu\n import os\n assert os.environ.get(\"COHERE_API_KEY\"), \"COHERE_API_KEY environment variable not set\"\n \n-from chromadb.utils.embedding_functions import CohereEmbeddingFunction\n+from chromadb.utils.embedding_functions.cohere_embedding_function import CohereEmbeddingFunction\n \n # Create the Cohere embedding function\n cohere_ef = CohereEmbeddingFunction(model_name=\"embed-english-light-v2.0\")\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -1219,17 +1219,16 @@ impl LogService for LogServer {\n             let witness = cursors.load(cursor_name).await.map_err(|err| {\n                 Status::new(err.code().into(), format!(\"Failed to load cursor: {}\", err))\n             })?;\n-            // This is the existing compaction_offset, which is the last record that was compacted.\n+            // This is the existing compaction_offset, which is the next record to compact.\n             let offset = witness\n                 .map(|x| x.1.position)\n-                .unwrap_or(LogPosition::from_offset(0));\n+                .unwrap_or(LogPosition::from_offset(1));\n             tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n                 &log_reader,\n-                // + 1 to get to the first uncompacted record.\n-                offset + 1u64,\n+                offset,\n                 target_prefix.clone(),\n             )\n             .await\n@@ -1253,7 +1252,9 @@ impl LogService for LogServer {\n             }\n             tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n-                compaction_offset: offset.offset(),\n+                // NOTE: The upstream service expects the last compacted offset as compaction offset\n+                compaction_offset: (offset - 1u64).offset(),\n+                // NOTE: The upstream service expects the last uncompacted offset as enumeration offset\n                 enumeration_offset: (max_offset - 1u64).offset(),\n             }))\n         }\n---\n\n\n---\n\nChoice C:\nCargo.lock\n@@ -3340,6 +3340,7 @@ dependencies = [\n  \"tokio\",\n  \"tokio-test\",\n  \"tonic\",\n+ \"tonic-health\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-test\",\n---\nidl/chromadb/proto/garbage_collector.proto\n@@ -0,0 +1,6 @@\n+syntax = \"proto3\";\n+\n+package chroma;\n+\n+// This is a placeholder service. The garbage collector currently only exposes a health service.\n+service GarbageCollector {}\n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.43\n+version: 0.1.44\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/garbage-collector.yaml\n@@ -40,6 +40,9 @@ spec:\n       - name: garbage-collector\n         image: \"{{ .Values.garbageCollector.image.repository }}:{{ .Values.garbageCollector.image.tag }}\"\n         imagePullPolicy: IfNotPresent\n+        readinessProbe:\n+          grpc:\n+            port: 50055\n         {{ if .Values.garbageCollector.resources }}\n         resources:\n           limits:\n---\nrust/garbage_collector/Cargo.toml\n@@ -27,6 +27,7 @@ tokio = { workspace = true }\n uuid = { workspace = true }\n futures = { workspace = true }\n tonic = { workspace = true }\n+tonic-health = { workspace = true }\n tempfile = { workspace = true }\n tracing = { workspace = true }\n thiserror = { workspace = true }\n---\nrust/garbage_collector/src/config.rs\n@@ -38,6 +38,8 @@ pub(super) struct GarbageCollectorConfig {\n     pub(super) assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig,\n     pub(super) memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig,\n     pub my_member_id: String,\n+    #[serde(default = \"GarbageCollectorConfig::default_port\")]\n+    pub port: u16,\n }\n \n impl GarbageCollectorConfig {\n@@ -61,6 +63,10 @@ impl GarbageCollectorConfig {\n             Err(e) => panic!(\"Error loading config: {}\", e),\n         }\n     }\n+\n+    fn default_port() -> u16 {\n+        50055\n+    }\n }\n \n #[cfg(test)]\n---\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -633,6 +633,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n@@ -753,6 +754,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n---\nrust/garbage_collector/src/lib.rs\n@@ -6,9 +6,11 @@ use chroma_tracing::{\n     init_global_filter_layer, init_otel_layer, init_panic_tracing_hook, init_stdout_layer,\n     init_tracing,\n };\n+use chroma_types::chroma_proto::garbage_collector_server::GarbageCollectorServer;\n use config::GarbageCollectorConfig;\n use garbage_collector_component::GarbageCollector;\n use tokio::signal::unix::{signal, SignalKind};\n+use tonic::transport::Server;\n use tracing::{debug, error, info};\n \n mod config;\n@@ -24,7 +26,20 @@ pub mod types;\n \n const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n \n+// This is a placeholder service so that we can expose a health service\n+struct GarbageCollectorService {}\n+\n+impl chroma_types::chroma_proto::garbage_collector_server::GarbageCollector\n+    for GarbageCollectorService\n+{\n+}\n+\n pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::error::Error>> {\n+    let (mut health_reporter, health_service) = tonic_health::server::health_reporter();\n+    health_reporter\n+        .set_not_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     debug!(\"Loading configuration from environment\");\n     // Parse configuration. Configuration includes sysdb connection details, and\n     // gc run details amongst others.\n@@ -49,6 +64,27 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n \n     info!(\"Loaded configuration successfully: {:#?}\", config);\n \n+    let addr = format!(\"[::]:{}\", config.port)\n+        .parse()\n+        .expect(\"Invalid address format\");\n+    let server_join_handle = tokio::spawn(async move {\n+        let server = Server::builder().add_service(health_service);\n+        server\n+            .serve_with_shutdown(addr, async {\n+                match signal(SignalKind::terminate()) {\n+                    Ok(mut sigterm) => {\n+                        sigterm.recv().await;\n+                        tracing::info!(\"Received SIGTERM, shutting down gRPC server\");\n+                    }\n+                    Err(err) => {\n+                        tracing::error!(\"Failed to create SIGTERM handler: {err}\")\n+                    }\n+                }\n+            })\n+            .await\n+            .expect(\"Failed to start gRPC server\");\n+    });\n+\n     let registry = chroma_config::registry::Registry::new();\n     let system = System::new();\n \n@@ -79,6 +115,10 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n     memberlist.subscribe(garbage_collector_handle.receiver());\n     let mut memberlist_handle = system.start_component(memberlist);\n \n+    health_reporter\n+        .set_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     // Keep the service running and handle shutdown signals\n     let mut sigterm = signal(SignalKind::terminate())?;\n     let mut sigint = signal(SignalKind::interrupt())?;\n@@ -112,6 +152,7 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n         .expect(\"Dispatcher should be stoppable\");\n     system.stop().await;\n     system.join().await;\n+    let _ = server_join_handle.await;\n \n     info!(\"Shutting down garbage collector service\");\n     Ok(())\n---\nrust/types/build.rs\n@@ -6,6 +6,7 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n         \"idl/chromadb/proto/coordinator.proto\",\n         \"idl/chromadb/proto/logservice.proto\",\n         \"idl/chromadb/proto/query_executor.proto\",\n+        \"idl/chromadb/proto/garbage_collector.proto\",\n     ];\n \n     // Can't use #[cfg(test)] here because a build for tests is technically a regular debug build, meaning that #[cfg(test)] is useless in build.rs.\n---\nrust/types/src/lib.rs\n@@ -47,6 +47,7 @@ pub use tenant::*;\n pub use types::*;\n pub use where_parsing::*;\n \n+#[allow(clippy::all)]\n pub mod chroma_proto {\n     tonic::include_proto!(\"chroma\");\n }\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -549,6 +549,8 @@ impl ServiceBasedFrontend {\n     pub async fn retryable_fork(\n         &mut self,\n         ForkCollectionRequest {\n+            tenant_id,\n+            database_name,\n             source_collection_id,\n             target_collection_name,\n             ..\n@@ -570,12 +572,25 @@ impl ServiceBasedFrontend {\n             )\n             .await?;\n         let collection = collection_and_segments.collection.clone();\n+        let latest_collection_logical_size_bytes = collection_and_segments\n+            .collection\n+            .size_bytes_post_compaction;\n \n         // Update the cache.\n         self.collections_with_segments_provider\n             .set_collection_with_segments(collection_and_segments)\n             .await;\n \n+        // TODO: Submit event after the response is sent\n+        MeterEvent::CollectionFork {\n+            tenant: tenant_id,\n+            database: database_name,\n+            collection_id: source_collection_id.0,\n+            latest_collection_logical_size_bytes,\n+        }\n+        .submit()\n+        .await;\n+\n         Ok(collection)\n     }\n \n---\nrust/tracing/src/meter_event.rs\n@@ -26,6 +26,12 @@ pub enum WriteAction {\n #[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]\n #[serde(rename_all = \"snake_case\", tag = \"event_name\")]\n pub enum MeterEvent {\n+    CollectionFork {\n+        tenant: String,\n+        database: String,\n+        collection_id: Uuid,\n+        latest_collection_logical_size_bytes: u64,\n+    },\n     CollectionRead {\n         tenant: String,\n         database: String,\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Interleave log seal with fork during test for debugging purpose\n- New functionality\n  - N/A\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.41\n+version: 0.1.42\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -35,4 +35,4 @@ compactionService:\n       value: 'value: \"/tilt_config.yaml\"'\n \n rustLogService:\n-  replicaCount: 2\n+  replicaCount: 1\n---\n\n\n---\n\nChoice B:\ndocs/docs.trychroma.com/markdoc/content/docs/collections/configure.md\n@@ -40,7 +40,7 @@ Here's how to configure the Cohere embedding function:\n import os\n assert os.environ.get(\"CHROMA_COHERE_API_KEY\"), \"CHROMA_COHERE_API_KEY environment variable not set\"\n \n-from chromadb.utils.embedding_functions import CohereEmbeddingFunction\n+from chromadb.utils.embedding_functions.cohere_embedding_function import CohereEmbeddingFunction\n \n # Create the Cohere embedding function (API key is read from environment variable)\n # By default, it reads from 'CHROMA_COHERE_API_KEY'\n@@ -109,7 +109,7 @@ Here is an example showing how to configure both the HNSW index and embedding fu\n import os\n assert os.environ.get(\"COHERE_API_KEY\"), \"COHERE_API_KEY environment variable not set\"\n \n-from chromadb.utils.embedding_functions import CohereEmbeddingFunction\n+from chromadb.utils.embedding_functions.cohere_embedding_function import CohereEmbeddingFunction\n \n # Create the Cohere embedding function\n cohere_ef = CohereEmbeddingFunction(model_name=\"embed-english-light-v2.0\")\n---\n\n\n---\n\nChoice C:\nchromadb/test/property/test_fork.py\n@@ -21,6 +21,10 @@\n from overrides import overrides\n from typing import Dict, cast, Union, Tuple, Set\n \n+import grpc\n+from chromadb.proto.logservice_pb2 import SealLogRequest\n+from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n collection_st = hyst.shared(strategies.collections(with_hnsw_params=True), key=\"source\")\n \n \n@@ -38,6 +42,10 @@ def __init__(self, client: chromadb.api.ClientAPI):\n         self.client = client\n         self.collection_names = set()\n \n+        # Create go log service client\n+        channel = grpc.insecure_channel(\"localhost:50052\")\n+        self.go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n     @initialize(collection=collection_st, target=updated_collections)\n     def initialize(\n         self, collection: strategies.Collection\n@@ -77,12 +85,14 @@ def fork(\n     @rule(\n         cursor=consumes(forked_collections),\n         delta=strategies.recordsets(collection_st),\n+        seal=hyst.booleans(),\n         target=updated_collections,\n     )\n     def upsert(\n         self,\n         cursor: Tuple[Collection, strategies.StateMachineRecordSet],\n         delta: strategies.RecordSet,\n+        seal: bool,\n     ) -> Tuple[Collection, strategies.StateMachineRecordSet]:\n         collection, record_set_state = cursor\n         normalized_delta: strategies.NormalizedRecordSet = invariants.wrap_all(delta)\n@@ -148,6 +158,8 @@ def upsert(\n                     )\n                 else:\n                     record_set_state[\"documents\"].append(None)\n+        if seal:\n+            self.go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n         return collection, record_set_state\n \n     @rule(\n---\n\n\n---\n\nChoice D:\n.github/actions/tilt/action.yaml\n@@ -6,18 +6,31 @@ runs:\n     - name: Install Tilt\n       shell: bash\n       run: |\n-        TILT_VERSION=\"0.33.3\"\n+        TILT_VERSION=\"0.34.2\"\n         curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v$TILT_VERSION/tilt.$TILT_VERSION.linux.x86_64.tar.gz | \\\n           tar -xzv -C /usr/local/bin tilt\n-    - name: Install ctlptlc\n-      shell: bash\n-      run: |\n-        CTLPTL_VERSION=\"0.8.20\"\n-        curl -fsSL https://github.com/tilt-dev/ctlptl/releases/download/v$CTLPTL_VERSION/ctlptl.$CTLPTL_VERSION.linux.x86_64.tar.gz | \\\n-          tar -xzv -C /usr/local/bin ctlptl\n     - name: Set up kind\n+      id: kind\n+      uses: helm/kind-action@v1\n+      with:\n+        registry: true\n+        registry_name: my-registry\n+        registry_port: 5001\n+        registry_enable_delete: true\n+    - name: Add blacksmith registry mirror\n       shell: bash\n-      run: ctlptl create cluster kind --registry=ctlptl-registry\n+      run: |\n+        REGISTRY_DIR=\"/etc/containerd/certs.d/docker.io\"\n+        for node in $(kind get nodes -n chart-testing); do\n+          docker exec \"${node}\" mkdir -p \"${REGISTRY_DIR}\"\n+          cat <<EOF | docker exec -i \"${node}\" cp /dev/stdin \"${REGISTRY_DIR}/hosts.toml\"\n+        server = \"http://192.168.127.1:5000\"\n+        [host.\"http://192.168.127.1:5000\"]\n+          capabilities = [\"pull\", \"resolve\"]\n+        EOF\n+          echo \"Added registry mirror to ${node}:\"\n+          docker exec \"${node}\" cat \"${REGISTRY_DIR}/hosts.toml\"\n+        done\n     - name: Start Tilt\n       shell: bash\n       run: tilt ci\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThe reference data set isn't usable from the command line.  This makes it so.\n\n## Test plan\n\nLocally.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -1219,17 +1219,16 @@ impl LogService for LogServer {\n             let witness = cursors.load(cursor_name).await.map_err(|err| {\n                 Status::new(err.code().into(), format!(\"Failed to load cursor: {}\", err))\n             })?;\n-            // This is the existing compaction_offset, which is the last record that was compacted.\n+            // This is the existing compaction_offset, which is the next record to compact.\n             let offset = witness\n                 .map(|x| x.1.position)\n-                .unwrap_or(LogPosition::from_offset(0));\n+                .unwrap_or(LogPosition::from_offset(1));\n             tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n                 &log_reader,\n-                // + 1 to get to the first uncompacted record.\n-                offset + 1u64,\n+                offset,\n                 target_prefix.clone(),\n             )\n             .await\n@@ -1253,7 +1252,9 @@ impl LogService for LogServer {\n             }\n             tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n-                compaction_offset: offset.offset(),\n+                // NOTE: The upstream service expects the last compacted offset as compaction offset\n+                compaction_offset: (offset - 1u64).offset(),\n+                // NOTE: The upstream service expects the last uncompacted offset as enumeration offset\n                 enumeration_offset: (max_offset - 1u64).offset(),\n             }))\n         }\n---\n\n\n---\n\nChoice B:\nrust/storage/src/admissioncontrolleds3.rs\n@@ -206,10 +206,10 @@ impl AdmissionControlledS3Storage {\n         rate_limiter: Arc<RateLimitPolicy>,\n         key: String,\n         priority: Arc<AtomicUsize>,\n-        channel_receiver: tokio::sync::mpsc::Receiver<()>,\n+        channel_receiver: Option<tokio::sync::mpsc::Receiver<()>>,\n     ) -> Result<(Arc<Vec<u8>>, Option<ETag>), StorageError> {\n         // Acquire permit.\n-        let _permit = rate_limiter.enter(priority, Some(channel_receiver)).await;\n+        let _permit = rate_limiter.enter(priority, channel_receiver).await;\n         storage\n             .get_with_e_tag(&key)\n             .instrument(tracing::trace_span!(parent: Span::current(), \"S3 get\"))\n@@ -277,6 +277,9 @@ impl AdmissionControlledS3Storage {\n         key: &str,\n         options: GetOptions,\n     ) -> Result<(Arc<Vec<u8>>, Option<ETag>), StorageError> {\n+        if options.requires_strong_consistency {\n+            return self.strongly_consistent_get_with_e_tag(key, options).await;\n+        }\n         // If there is a duplicate request and the original request finishes\n         // before we look it up in the map below then we will end up with another\n         // request to S3.\n@@ -298,7 +301,7 @@ impl AdmissionControlledS3Storage {\n                         self.rate_limiter.clone(),\n                         key.to_string(),\n                         atomic_priority.clone(),\n-                        rx,\n+                        Some(rx),\n                     )\n                     .boxed()\n                     .shared();\n@@ -323,6 +326,22 @@ impl AdmissionControlledS3Storage {\n         res\n     }\n \n+    pub async fn strongly_consistent_get_with_e_tag(\n+        &self,\n+        key: &str,\n+        options: GetOptions,\n+    ) -> Result<(Arc<Vec<u8>>, Option<ETag>), StorageError> {\n+        let atomic_priority = Arc::new(AtomicUsize::new(options.priority.as_usize()));\n+        AdmissionControlledS3Storage::read_from_storage(\n+            self.storage.clone(),\n+            self.rate_limiter.clone(),\n+            key.to_string(),\n+            atomic_priority,\n+            None,\n+        )\n+        .await\n+    }\n+\n     async fn oneshot_upload(\n         &self,\n         key: &str,\n---\nrust/storage/src/lib.rs\n@@ -400,11 +400,20 @@ impl PutOptions {\n #[derive(Clone, Debug, Default)]\n pub struct GetOptions {\n     priority: StorageRequestPriority,\n+    requires_strong_consistency: bool,\n }\n \n impl GetOptions {\n     pub fn new(priority: StorageRequestPriority) -> Self {\n-        Self { priority }\n+        Self {\n+            priority,\n+            requires_strong_consistency: false,\n+        }\n+    }\n+\n+    pub fn with_strong_consistency(mut self) -> Self {\n+        self.requires_strong_consistency = true;\n+        self\n     }\n }\n \n---\nrust/storage/src/s3.rs\n@@ -310,6 +310,7 @@ impl S3Storage {\n         self.get_with_e_tag(key).await.map(|(buf, _)| buf)\n     }\n \n+    /// Perform a strongly consistent get and return the e_tag.\n     #[tracing::instrument(skip(self))]\n     pub async fn get_with_e_tag(\n         &self,\n---\n\n\n---\n\nChoice C:\nchromadb/test/utils/cross_version.py\n@@ -5,7 +5,11 @@\n from types import ModuleType\n from typing import Dict, List\n \n-base_install_dir = tempfile.gettempdir() + \"/persistence_test_chromadb_versions\"\n+base_install_dir = (\n+    tempfile.gettempdir()\n+    + f\"/worker-{os.environ.get('PYTEST_XDIST_WORKER', 'unknown')}\"\n+    + \"/persistence_test_chromadb_versions\"\n+)\n \n \n def get_path_to_version_install(version: str) -> str:\n@@ -48,6 +52,8 @@ def install_version(version: str, dep_overrides: Dict[str, str]) -> None:\n \n \n def install(pkg: str, path: str, dep_overrides: Dict[str, str]) -> int:\n+    os.makedirs(path, exist_ok=True)\n+\n     # -q -q to suppress pip output to ERROR level\n     # https://pip.pypa.io/en/stable/cli/pip/#quiet\n     command = [sys.executable, \"-m\", \"pip\", \"-q\", \"-q\", \"install\", pkg]\n---\n\n\n---\n\nChoice D:\nrust/load/src/data_sets.rs\n@@ -1484,6 +1484,7 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n         ALL_MINILM_L6_V2,\n         1_000_000,\n     )));\n+    data_sets.push(Arc::clone(&reference_data_set) as _);\n     data_sets.push(Arc::new(VerifyingDataSet {\n         reference_data_set,\n         test_data_set: \"test-all-MiniLM-L6-v2\".to_string(),\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nRelease Python 1.0.12\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nchromadb/utils/embedding_functions/instructor_embedding_function.py\n@@ -39,7 +39,7 @@ def __init__(\n         self.device = device\n         self.instruction = instruction\n \n-        self._model = INSTRUCTOR(model_name, device=device)\n+        self._model = INSTRUCTOR(model_name_or_path=model_name, device=device)\n \n     def __call__(self, input: Documents) -> Embeddings:\n         \"\"\"\n@@ -99,10 +99,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\nchromadb/utils/embedding_functions/sentence_transformer_embedding_function.py\n@@ -42,7 +42,7 @@ def __init__(\n \n         if model_name not in self.models:\n             self.models[model_name] = SentenceTransformer(\n-                model_name, device=device, **kwargs\n+                model_name_or_path=model_name, device=device, **kwargs\n             )\n         self._model = self.models[model_name]\n \n@@ -102,10 +102,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\nchromadb/utils/embedding_functions/text2vec_embedding_function.py\n@@ -71,10 +71,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\n\n\n---\n\nChoice B:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\nChoice C:\ngo/cmd/logservice/main.go\n@@ -2,8 +2,8 @@ package main\n \n import (\n \t\"context\"\n-\t\"net\"\n \n+\t\"github.com/chroma-core/chroma/go/pkg/grpcutils\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/configuration\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/leader\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/metrics\"\n@@ -15,7 +15,6 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/utils\"\n \tlibs \"github.com/chroma-core/chroma/go/shared/libs\"\n \t\"github.com/chroma-core/chroma/go/shared/otel\"\n-\tsharedOtel \"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"github.com/pingcap/log\"\n \t\"github.com/rs/zerolog\"\n \t\"go.uber.org/automaxprocs/maxprocs\"\n@@ -50,22 +49,21 @@ func main() {\n \tsysDb := sysdb.NewSysDB(config.SYSDB_CONN)\n \tlr := repository.NewLogRepository(conn, sysDb)\n \tserver := server.NewLogServer(lr)\n-\tvar listener net.Listener\n-\tlistener, err = net.Listen(\"tcp\", \":\"+config.PORT)\n+\n+\t_, err = grpcutils.Default.StartGrpcServer(\"log-service\", &grpcutils.GrpcConfig{\n+\t\tBindAddress: \":\" + config.PORT,\n+\t}, func(registrar grpc.ServiceRegistrar) {\n+\t\thealthcheck := health.NewServer()\n+\t\thealthgrpc.RegisterHealthServer(registrar, healthcheck)\n+\t\tlogservicepb.RegisterLogServiceServer(registrar, server)\n+\t})\n \tif err != nil {\n-\t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n+\t\tlog.Fatal(\"failed to create grpc server\", zap.Error(err))\n \t}\n-\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n-\thealthcheck := health.NewServer()\n-\thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n-\tlogservicepb.RegisterLogServiceServer(s, server)\n-\tlog.Info(\"log service started\", zap.String(\"address\", listener.Addr().String()))\n+\tlog.Info(\"log service started\")\n \tgo leader.AcquireLeaderLock(ctx, func(ctx context.Context) {\n \t\tgo purging.PerformPurgingLoop(ctx, lr)\n \t\tgo metrics.PerformMetricsLoop(ctx, lr)\n \t})\n-\tif err := s.Serve(listener); err != nil {\n-\t\tlog.Fatal(\"failed to serve\", zap.Error(err))\n-\t}\n }\n---\ngo/pkg/grpcutils/service.go\n@@ -4,11 +4,12 @@ import (\n \t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n-\t\"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"io\"\n \t\"net\"\n \t\"os\"\n \n+\t\"github.com/chroma-core/chroma/go/shared/otel\"\n+\n \t\"github.com/pingcap/log\"\n \t\"go.uber.org/zap\"\n \t\"google.golang.org/grpc\"\n@@ -82,7 +83,7 @@ func newDefaultGrpcProvider(name string, grpcConfig *GrpcConfig, registerFunc fu\n \tOPTL_TRACING_ENDPOINT := os.Getenv(\"OPTL_TRACING_ENDPOINT\")\n \tif OPTL_TRACING_ENDPOINT != \"\" {\n \t\totel.InitTracing(context.Background(), &otel.TracingConfig{\n-\t\t\tService:  \"sysdb-service\",\n+\t\t\tService:  name,\n \t\t\tEndpoint: OPTL_TRACING_ENDPOINT,\n \t\t})\n \t}\n---\ngo/pkg/sysdb/grpc/server.go\n@@ -158,7 +158,7 @@ func NewWithGrpcProvider(config Config, provider grpcutils.GrpcProvider) (*Serve\n \t\ts.softDeleteCleaner.Start()\n \n \t\tlog.Info(\"Starting GRPC server\")\n-\t\ts.grpcServer, err = provider.StartGrpcServer(\"coordinator\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n+\t\ts.grpcServer, err = provider.StartGrpcServer(\"sysdb-service\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n \t\t\tcoordinatorpb.RegisterSysDBServer(registrar, s)\n \t\t\thealthgrpc.RegisterHealthServer(registrar, s.healthServer)\n \t\t})\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.11\"\n+__version__ = \"1.0.12\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.11\"\n+      \"Default\": \"1.0.12\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis PR cherry-picks the commit 2d50100d9da6f333092fc04ffef27aaebdbe4de7 onto rc/2025-05-30. If there are unresolved conflicts, please resolve them manually.\n\n---\n\nChoice A:\ndocs/docs.trychroma.com/markdoc/content/integrations/frameworks/llamaindex.md\n@@ -6,5 +6,5 @@ name: LlamaIndex\n # LlamaIndex\n \n - `LlamaIndex` [Vector Store page](https://docs.llamaindex.ai/en/stable/examples/vector_stores/ChromaIndexDemo.html)\n-- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n-- [Chroma Loader on Llamahub](https://llamahub.ai/l/chroma)\n+- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n+- [Chroma Loader on Llamahub](https://llamahub.ai/l/vector_stores/llama-index-vector-stores-chroma)\n---\n\n\n---\n\nChoice B:\nrust/garbage_collector/src/operators/compute_unused_files.rs\n@@ -1,5 +1,5 @@\n use async_trait::async_trait;\n-use chroma_blockstore::RootManager;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n use chroma_cache::nop::NopCache;\n use chroma_error::{ChromaError, ErrorCodes};\n use chroma_storage::Storage;\n@@ -145,14 +145,14 @@ impl ComputeUnusedFilesOperator {\n         for si_id in si_ids {\n             let uuid = Uuid::parse_str(&si_id).map_err(|e| {\n                 tracing::error!(error = %e, \"Failed to parse UUID\");\n-                ComputeUnusedFilesError::ParseError(si_id.clone(), e.to_string())\n+                ComputeUnusedFilesError::InvalidUuid(e, si_id.clone())\n             })?;\n \n             let block_ids = match self.root_manager.get_all_block_ids(&uuid).await {\n                 Ok(ids) => ids,\n                 Err(e) => {\n                     tracing::error!(error = %e, \"Failed to get block IDs\");\n-                    return Err(ComputeUnusedFilesError::ParseError(si_id, e.to_string()));\n+                    return Err(ComputeUnusedFilesError::FailedToFetchBlockIDs(e));\n                 }\n             };\n             tracing::debug!(\n@@ -193,8 +193,10 @@ pub struct ComputeUnusedFilesOutput {\n \n #[derive(Error, Debug)]\n pub enum ComputeUnusedFilesError {\n-    #[error(\"Error parsing sparse index file: {0}\")]\n-    ParseError(String, String),\n+    #[error(\"Error parsing UUID: {0} from {1}\")]\n+    InvalidUuid(uuid::Error, String),\n+    #[error(\"Failed to fetch block IDs: {0}\")]\n+    FailedToFetchBlockIDs(RootManagerError),\n     #[error(\"Version file has missing content\")]\n     VersionFileMissingContent(i64),\n     #[error(\"Version history is missing\")]\n---\n\n\n---\n\nChoice C:\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -140,21 +140,20 @@ impl GarbageCollector {\n             .as_ref()\n             .ok_or(GarbageCollectCollectionError::Uninitialized)?;\n \n-        let use_v1_orchestrator = match cleanup_mode {\n-            CleanupMode::DryRun | CleanupMode::Rename | CleanupMode::Delete => true,\n-            CleanupMode::DryRunV2 | CleanupMode::DeleteV2 => false,\n-        };\n-\n-        if use_v1_orchestrator {\n+        if cleanup_mode.is_v2() {\n             let orchestrator =\n-                crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+                crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n                     collection.id,\n                     collection.version_file_path,\n+                    collection.lineage_file_path,\n                     absolute_cutoff_time,\n                     self.sysdb_client.clone(),\n                     dispatcher.clone(),\n+                    system.clone(),\n                     self.storage.clone(),\n+                    self.root_manager.clone(),\n                     cleanup_mode,\n+                    2,\n                 );\n \n             let started_at = SystemTime::now();\n@@ -178,23 +177,19 @@ impl GarbageCollector {\n                     format!(\"{:?}\", cleanup_mode),\n                 )],\n             );\n+\n             return Ok(result);\n         }\n \n-        let orchestrator =\n-            crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n-                collection.id,\n-                collection.version_file_path,\n-                collection.lineage_file_path,\n-                absolute_cutoff_time,\n-                self.sysdb_client.clone(),\n-                dispatcher.clone(),\n-                system.clone(),\n-                self.storage.clone(),\n-                self.root_manager.clone(),\n-                cleanup_mode,\n-                2,\n-            );\n+        let orchestrator = crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+            collection.id,\n+            collection.version_file_path,\n+            absolute_cutoff_time,\n+            self.sysdb_client.clone(),\n+            dispatcher.clone(),\n+            self.storage.clone(),\n+            cleanup_mode,\n+        );\n \n         let started_at = SystemTime::now();\n         let result = orchestrator.run(system.clone()).await?;\n@@ -217,7 +212,6 @@ impl GarbageCollector {\n                 format!(\"{:?}\", cleanup_mode),\n             )],\n         );\n-\n         Ok(result)\n     }\n }\n@@ -360,9 +354,18 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 continue;\n             }\n \n-            if collection.lineage_file_path.is_some() {\n+            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n+                tenant_mode_overrides\n+                    .get(&collection.tenant)\n+                    .cloned()\n+                    .unwrap_or(self.default_cleanup_mode)\n+            } else {\n+                self.default_cleanup_mode\n+            };\n+\n+            if collection.lineage_file_path.is_some() && !cleanup_mode.is_v2() {\n                 tracing::debug!(\n-                    \"Skipping garbage collection for root of fork tree: {}\",\n+                    \"Skipping garbage collection for root of fork tree because GC v1 cannot handle fork trees: {}\",\n                     collection.id\n                 );\n                 num_skipped_jobs += 1;\n@@ -376,17 +379,6 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 collection.version_file_path\n             );\n \n-            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n-                tenant_mode_overrides\n-                    .get(&collection.tenant)\n-                    .cloned()\n-                    .unwrap_or(self.default_cleanup_mode)\n-            } else {\n-                self.default_cleanup_mode\n-            };\n-\n-            tracing::info!(\"Creating gc orchestrator for collection: {}\", collection.id);\n-\n             let instrumented_span = span!(parent: None, tracing::Level::INFO, \"Garbage collection job\", collection_id = ?collection.id, tenant_id = %collection.tenant, cleanup_mode = ?cleanup_mode);\n             instrumented_span.follows_from(Span::current());\n \n@@ -1011,6 +1003,26 @@ mod tests {\n         let (collection_in_delete_mode, database_name_in_delete_mode) =\n             collection_in_delete_mode_handle.await.unwrap();\n \n+        // Fork collection in delete mode to give it a lineage file (only GC v2 can handle fork trees)\n+        {\n+            let source_collection = sysdb\n+                .get_collections(Some(collection_in_delete_mode), None, None, None, None, 0)\n+                .await\n+                .unwrap();\n+            let source_collection = source_collection.first().unwrap();\n+\n+            sysdb\n+                .fork_collection(\n+                    collection_in_delete_mode,\n+                    source_collection.total_records_post_compaction,\n+                    source_collection.total_records_post_compaction,\n+                    CollectionUuid::new(),\n+                    \"test-fork\".to_string(),\n+                )\n+                .await\n+                .unwrap();\n+        }\n+\n         // Wait 1 second for cutoff time\n         tokio::time::sleep(Duration::from_secs(1)).await;\n \n---\nrust/garbage_collector/src/types.rs\n@@ -19,6 +19,12 @@ pub enum CleanupMode {\n     DeleteV2,\n }\n \n+impl CleanupMode {\n+    pub fn is_v2(&self) -> bool {\n+        matches!(self, CleanupMode::DryRunV2 | CleanupMode::DeleteV2)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub enum VersionStatus {\n     #[allow(dead_code)]\n---\n\n\n---\n\nChoice D:\nrust/types/src/lib.rs\n@@ -23,6 +23,7 @@ mod tenant;\n mod validators;\n mod where_parsing;\n \n+pub mod optional_u128;\n pub mod regex;\n \n // Re-export the types module, so that we can use it as a single import in other modules.\n---\nrust/types/src/optional_u128.rs\n@@ -0,0 +1,74 @@\n+pub mod optional_u128_as_hex {\n+    use serde::de::Error;\n+    use serde::{Deserialize, Deserializer, Serializer};\n+\n+    /// Serializes `Option<u128>` as lowercase hex string if Some, skips if None.\n+    pub fn serialize<S>(val: &Option<u128>, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        match val {\n+            Some(v) => serializer.serialize_str(&format!(\"{:x}\", v)),\n+            None => serializer.serialize_none(),\n+        }\n+    }\n+\n+    /// Deserializes a lowercase hex string into `Option<u128>`.\n+    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<u128>, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let opt: Option<String> = Option::deserialize(deserializer)?;\n+        match opt {\n+            Some(s) => {\n+                let val = u128::from_str_radix(&s, 16).map_err(D::Error::custom)?;\n+                Ok(Some(val))\n+            }\n+            None => Ok(None),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::optional_u128_as_hex;\n+    use serde::{Deserialize, Serialize};\n+\n+    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n+    struct TestStruct {\n+        #[serde(\n+            with = \"optional_u128_as_hex\",\n+            default,\n+            skip_serializing_if = \"Option::is_none\"\n+        )]\n+        value: Option<u128>,\n+    }\n+\n+    #[test]\n+    fn test_serialize_some_u128() {\n+        let s = TestStruct { value: Some(255) };\n+        let json = serde_json::to_string(&s).unwrap();\n+        assert_eq!(json, r#\"{\"value\":\"ff\"}\"#);\n+    }\n+\n+    #[test]\n+    fn test_serialize_none() {\n+        let s = TestStruct { value: None };\n+        let json = serde_json::to_string(&s).unwrap();\n+        assert_eq!(json, r#\"{}\"#);\n+    }\n+\n+    #[test]\n+    fn test_deserialize_some_u128() {\n+        let json = r#\"{\"value\":\"ff\"}\"#;\n+        let s: TestStruct = serde_json::from_str(json).unwrap();\n+        assert_eq!(s, TestStruct { value: Some(255) });\n+    }\n+\n+    #[test]\n+    fn test_deserialize_none() {\n+        let json = r#\"{}\"#;\n+        let s: TestStruct = serde_json::from_str(json).unwrap();\n+        assert_eq!(s, TestStruct { value: None });\n+    }\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nRelease Python 1.0.12\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nCargo.lock\n@@ -3340,6 +3340,7 @@ dependencies = [\n  \"tokio\",\n  \"tokio-test\",\n  \"tonic\",\n+ \"tonic-health\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-test\",\n---\nidl/chromadb/proto/garbage_collector.proto\n@@ -0,0 +1,6 @@\n+syntax = \"proto3\";\n+\n+package chroma;\n+\n+// This is a placeholder service. The garbage collector currently only exposes a health service.\n+service GarbageCollector {}\n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.43\n+version: 0.1.44\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/garbage-collector.yaml\n@@ -40,6 +40,9 @@ spec:\n       - name: garbage-collector\n         image: \"{{ .Values.garbageCollector.image.repository }}:{{ .Values.garbageCollector.image.tag }}\"\n         imagePullPolicy: IfNotPresent\n+        readinessProbe:\n+          grpc:\n+            port: 50055\n         {{ if .Values.garbageCollector.resources }}\n         resources:\n           limits:\n---\nrust/garbage_collector/Cargo.toml\n@@ -27,6 +27,7 @@ tokio = { workspace = true }\n uuid = { workspace = true }\n futures = { workspace = true }\n tonic = { workspace = true }\n+tonic-health = { workspace = true }\n tempfile = { workspace = true }\n tracing = { workspace = true }\n thiserror = { workspace = true }\n---\nrust/garbage_collector/src/config.rs\n@@ -38,6 +38,8 @@ pub(super) struct GarbageCollectorConfig {\n     pub(super) assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig,\n     pub(super) memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig,\n     pub my_member_id: String,\n+    #[serde(default = \"GarbageCollectorConfig::default_port\")]\n+    pub port: u16,\n }\n \n impl GarbageCollectorConfig {\n@@ -61,6 +63,10 @@ impl GarbageCollectorConfig {\n             Err(e) => panic!(\"Error loading config: {}\", e),\n         }\n     }\n+\n+    fn default_port() -> u16 {\n+        50055\n+    }\n }\n \n #[cfg(test)]\n---\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -633,6 +633,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n@@ -753,6 +754,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n---\nrust/garbage_collector/src/lib.rs\n@@ -6,9 +6,11 @@ use chroma_tracing::{\n     init_global_filter_layer, init_otel_layer, init_panic_tracing_hook, init_stdout_layer,\n     init_tracing,\n };\n+use chroma_types::chroma_proto::garbage_collector_server::GarbageCollectorServer;\n use config::GarbageCollectorConfig;\n use garbage_collector_component::GarbageCollector;\n use tokio::signal::unix::{signal, SignalKind};\n+use tonic::transport::Server;\n use tracing::{debug, error, info};\n \n mod config;\n@@ -24,7 +26,20 @@ pub mod types;\n \n const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n \n+// This is a placeholder service so that we can expose a health service\n+struct GarbageCollectorService {}\n+\n+impl chroma_types::chroma_proto::garbage_collector_server::GarbageCollector\n+    for GarbageCollectorService\n+{\n+}\n+\n pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::error::Error>> {\n+    let (mut health_reporter, health_service) = tonic_health::server::health_reporter();\n+    health_reporter\n+        .set_not_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     debug!(\"Loading configuration from environment\");\n     // Parse configuration. Configuration includes sysdb connection details, and\n     // gc run details amongst others.\n@@ -49,6 +64,27 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n \n     info!(\"Loaded configuration successfully: {:#?}\", config);\n \n+    let addr = format!(\"[::]:{}\", config.port)\n+        .parse()\n+        .expect(\"Invalid address format\");\n+    let server_join_handle = tokio::spawn(async move {\n+        let server = Server::builder().add_service(health_service);\n+        server\n+            .serve_with_shutdown(addr, async {\n+                match signal(SignalKind::terminate()) {\n+                    Ok(mut sigterm) => {\n+                        sigterm.recv().await;\n+                        tracing::info!(\"Received SIGTERM, shutting down gRPC server\");\n+                    }\n+                    Err(err) => {\n+                        tracing::error!(\"Failed to create SIGTERM handler: {err}\")\n+                    }\n+                }\n+            })\n+            .await\n+            .expect(\"Failed to start gRPC server\");\n+    });\n+\n     let registry = chroma_config::registry::Registry::new();\n     let system = System::new();\n \n@@ -79,6 +115,10 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n     memberlist.subscribe(garbage_collector_handle.receiver());\n     let mut memberlist_handle = system.start_component(memberlist);\n \n+    health_reporter\n+        .set_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     // Keep the service running and handle shutdown signals\n     let mut sigterm = signal(SignalKind::terminate())?;\n     let mut sigint = signal(SignalKind::interrupt())?;\n@@ -112,6 +152,7 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n         .expect(\"Dispatcher should be stoppable\");\n     system.stop().await;\n     system.join().await;\n+    let _ = server_join_handle.await;\n \n     info!(\"Shutting down garbage collector service\");\n     Ok(())\n---\nrust/types/build.rs\n@@ -6,6 +6,7 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n         \"idl/chromadb/proto/coordinator.proto\",\n         \"idl/chromadb/proto/logservice.proto\",\n         \"idl/chromadb/proto/query_executor.proto\",\n+        \"idl/chromadb/proto/garbage_collector.proto\",\n     ];\n \n     // Can't use #[cfg(test)] here because a build for tests is technically a regular debug build, meaning that #[cfg(test)] is useless in build.rs.\n---\nrust/types/src/lib.rs\n@@ -47,6 +47,7 @@ pub use tenant::*;\n pub use types::*;\n pub use where_parsing::*;\n \n+#[allow(clippy::all)]\n pub mod chroma_proto {\n     tonic::include_proto!(\"chroma\");\n }\n---\n\n\n---\n\nChoice B:\nTiltfile\n@@ -92,7 +92,7 @@ else:\n   docker_build(\n     'frontend-service',\n     '.',\n-    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/'],\n+    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/', 'Cargo.toml', 'Cargo.lock', 'rust/', 'pyproject.toml', 'README.md'],\n     dockerfile='./Dockerfile',\n     ignore=['**/*.pyc', 'chromadb/test/'],\n   )\n---\n\n\n---\n\nChoice C:\nrust/segment/src/sqlite_metadata.rs\n@@ -482,8 +482,9 @@ impl IntoSqliteExpr for DocumentExpression {\n             EmbeddingFulltextSearch::StringValue,\n         ));\n         let doc_contains = doc_col\n+            .clone()\n             .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .is(true);\n+            .and(doc_col.is_not_null());\n         match self.operator {\n             DocumentOperator::Contains => doc_contains,\n             DocumentOperator::NotContains => doc_contains.not(),\n@@ -495,9 +496,11 @@ impl IntoSqliteExpr for DocumentExpression {\n \n impl IntoSqliteExpr for MetadataExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let key_cond = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key))\n+        let key_col = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key));\n+        let key_cond = key_col\n+            .clone()\n             .eq(self.key.to_string())\n-            .is(true);\n+            .and(key_col.is_not_null());\n         match &self.comparison {\n             MetadataComparison::Primitive(op, val) => {\n                 let (col, sval) = match val {\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.11\"\n+__version__ = \"1.0.12\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.11\"\n+      \"Default\": \"1.0.12\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nDoes what the title says. Missed this in the original PR.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\nUpdated the basic GC v2 E2E test to include a forked collection.\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -140,21 +140,20 @@ impl GarbageCollector {\n             .as_ref()\n             .ok_or(GarbageCollectCollectionError::Uninitialized)?;\n \n-        let use_v1_orchestrator = match cleanup_mode {\n-            CleanupMode::DryRun | CleanupMode::Rename | CleanupMode::Delete => true,\n-            CleanupMode::DryRunV2 | CleanupMode::DeleteV2 => false,\n-        };\n-\n-        if use_v1_orchestrator {\n+        if cleanup_mode.is_v2() {\n             let orchestrator =\n-                crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+                crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n                     collection.id,\n                     collection.version_file_path,\n+                    collection.lineage_file_path,\n                     absolute_cutoff_time,\n                     self.sysdb_client.clone(),\n                     dispatcher.clone(),\n+                    system.clone(),\n                     self.storage.clone(),\n+                    self.root_manager.clone(),\n                     cleanup_mode,\n+                    2,\n                 );\n \n             let started_at = SystemTime::now();\n@@ -178,23 +177,19 @@ impl GarbageCollector {\n                     format!(\"{:?}\", cleanup_mode),\n                 )],\n             );\n+\n             return Ok(result);\n         }\n \n-        let orchestrator =\n-            crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n-                collection.id,\n-                collection.version_file_path,\n-                collection.lineage_file_path,\n-                absolute_cutoff_time,\n-                self.sysdb_client.clone(),\n-                dispatcher.clone(),\n-                system.clone(),\n-                self.storage.clone(),\n-                self.root_manager.clone(),\n-                cleanup_mode,\n-                2,\n-            );\n+        let orchestrator = crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+            collection.id,\n+            collection.version_file_path,\n+            absolute_cutoff_time,\n+            self.sysdb_client.clone(),\n+            dispatcher.clone(),\n+            self.storage.clone(),\n+            cleanup_mode,\n+        );\n \n         let started_at = SystemTime::now();\n         let result = orchestrator.run(system.clone()).await?;\n@@ -217,7 +212,6 @@ impl GarbageCollector {\n                 format!(\"{:?}\", cleanup_mode),\n             )],\n         );\n-\n         Ok(result)\n     }\n }\n@@ -360,9 +354,18 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 continue;\n             }\n \n-            if collection.lineage_file_path.is_some() {\n+            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n+                tenant_mode_overrides\n+                    .get(&collection.tenant)\n+                    .cloned()\n+                    .unwrap_or(self.default_cleanup_mode)\n+            } else {\n+                self.default_cleanup_mode\n+            };\n+\n+            if collection.lineage_file_path.is_some() && !cleanup_mode.is_v2() {\n                 tracing::debug!(\n-                    \"Skipping garbage collection for root of fork tree: {}\",\n+                    \"Skipping garbage collection for root of fork tree because GC v1 cannot handle fork trees: {}\",\n                     collection.id\n                 );\n                 num_skipped_jobs += 1;\n@@ -376,17 +379,6 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 collection.version_file_path\n             );\n \n-            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n-                tenant_mode_overrides\n-                    .get(&collection.tenant)\n-                    .cloned()\n-                    .unwrap_or(self.default_cleanup_mode)\n-            } else {\n-                self.default_cleanup_mode\n-            };\n-\n-            tracing::info!(\"Creating gc orchestrator for collection: {}\", collection.id);\n-\n             let instrumented_span = span!(parent: None, tracing::Level::INFO, \"Garbage collection job\", collection_id = ?collection.id, tenant_id = %collection.tenant, cleanup_mode = ?cleanup_mode);\n             instrumented_span.follows_from(Span::current());\n \n@@ -1011,6 +1003,26 @@ mod tests {\n         let (collection_in_delete_mode, database_name_in_delete_mode) =\n             collection_in_delete_mode_handle.await.unwrap();\n \n+        // Fork collection in delete mode to give it a lineage file (only GC v2 can handle fork trees)\n+        {\n+            let source_collection = sysdb\n+                .get_collections(Some(collection_in_delete_mode), None, None, None, None, 0)\n+                .await\n+                .unwrap();\n+            let source_collection = source_collection.first().unwrap();\n+\n+            sysdb\n+                .fork_collection(\n+                    collection_in_delete_mode,\n+                    source_collection.total_records_post_compaction,\n+                    source_collection.total_records_post_compaction,\n+                    CollectionUuid::new(),\n+                    \"test-fork\".to_string(),\n+                )\n+                .await\n+                .unwrap();\n+        }\n+\n         // Wait 1 second for cutoff time\n         tokio::time::sleep(Duration::from_secs(1)).await;\n \n---\nrust/garbage_collector/src/types.rs\n@@ -19,6 +19,12 @@ pub enum CleanupMode {\n     DeleteV2,\n }\n \n+impl CleanupMode {\n+    pub fn is_v2(&self) -> bool {\n+        matches!(self, CleanupMode::DryRunV2 | CleanupMode::DeleteV2)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub enum VersionStatus {\n     #[allow(dead_code)]\n---\n\n\n---\n\nChoice B:\nrust/load/src/data_sets.rs\n@@ -1484,6 +1484,7 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n         ALL_MINILM_L6_V2,\n         1_000_000,\n     )));\n+    data_sets.push(Arc::clone(&reference_data_set) as _);\n     data_sets.push(Arc::new(VerifyingDataSet {\n         reference_data_set,\n         test_data_set: \"test-all-MiniLM-L6-v2\".to_string(),\n---\n\n\n---\n\nChoice C:\nchromadb/test/distributed/test_log_failover.py\n@@ -19,6 +19,9 @@\n     skip_if_not_cluster,\n )\n from chromadb.test.property import invariants\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n+\n+RECORDS = 100\n \n @skip_if_not_cluster()\n def test_log_failover(\n@@ -39,32 +42,106 @@ def test_log_failover(\n     channel = grpc.insecure_channel('localhost:50052')\n     log_service_stub = LogServiceStub(channel)\n \n-    # Add 100 records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n+    # and 1\n+    for i in range(RECORDS, RECORDS + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_compaction(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n     ids = []\n     embeddings = []\n-    for i in range(100):\n+    for i in range(RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n+        if i == RECORDS / 2:\n+            # NOTE(rescrv):  This compaction tests a very particular race when migrating logs.\n+            # Imagine this sequence:\n+            # 1. Write 51 records to the go log.\n+            # 2. Compact all 51 records.\n+            # 3. Write 49 more records to the go log.\n+            # 4. Seal the go log.\n+            # 5. Log migration moves the remaining 49 records to the rust service.\n+            # 6. Cached frontend tries to read from a timestamp that includes all 100 records, using\n+            #    the initial compaction, but from a log that only has 49 records.\n+            # The fix is to make sure the log returns not found when a prefix of the log is\n+            # compacted.  This forces a fallback to repopulate the cache of the sysdb.\n+            wait_for_version_increase(client, collection.name, 0)\n \n     request = SealLogRequest(collection_id=str(collection.id))\n     response = log_service_stub.SealLog(request, timeout=60)\n \n-    # Add another 100 records, where each embedding has 3 dimensions randomly generated between 0\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n     # and 1\n-    for i in range(100, 200):\n+    for i in range(RECORDS, RECORDS + RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n \n-    for i in range(200):\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n         if len(result[\"embeddings\"]) == 0:\n             print(\"missing result\", i)\n-        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n---\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1545,14 +1545,15 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \tif tc.versionFileEnabled {\n \t\treturn tc.FlushCollectionCompactionForVersionedCollection(ctx, flushCollectionCompaction)\n \t}\n+\tcollectionID := types.FromUniqueID(flushCollectionCompaction.ID)\n \n \tflushCollectionInfo := &model.FlushCollectionInfo{\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n \terr := tc.txImpl.Transaction(ctx, func(txCtx context.Context) error {\n \t\t// Check if collection exists.\n-\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(types.FromUniqueID(flushCollectionCompaction.ID), nil, nil)\n+\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(collectionID, nil, nil)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1589,6 +1590,7 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \t\t// return nil will commit the transaction\n \t\treturn nil\n \t})\n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", *collectionID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1641,6 +1643,8 @@ func (tc *Catalog) FlushCollectionCompactionForVersionedCollection(ctx context.C\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", flushCollectionInfo.ID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n+\n \t// Do the operation in a loop until the CollectionEntry is updated,\n \t// \t\tOR FAIL the operation if the version is stale\n \t//      OR other DB error.\n---\nrust/log-service/src/lib.rs\n@@ -1080,6 +1080,9 @@ impl LogService for LogServer {\n                     });\n                 }\n             }\n+            if !records.is_empty() && records[0].log_offset != pull_logs.start_from_offset {\n+                return Err(Status::not_found(\"Some entries have been purged\"));\n+            }\n             tracing::info!(\"pulled {} records\", records.len());\n             Ok(Response::new(PullLogsResponse { records }))\n         }\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/auth/mod.rs\n@@ -70,12 +70,40 @@ pub struct AuthzResource {\n }\n \n #[derive(thiserror::Error, Debug)]\n-#[error(\"Permission denied.\")]\n-pub struct AuthError(pub StatusCode);\n+pub struct AuthError {\n+    pub status_code: StatusCode,\n+    pub message: Option<String>,\n+}\n+\n+impl Display for AuthError {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(\n+            f,\n+            \"{}\",\n+            self.message.as_deref().unwrap_or(\"Permission denied.\")\n+        )\n+    }\n+}\n+\n+impl AuthError {\n+    pub fn new(status_code: StatusCode) -> Self {\n+        Self {\n+            status_code,\n+            message: None,\n+        }\n+    }\n+\n+    pub fn with_message(status_code: StatusCode, message: impl Into<String>) -> Self {\n+        Self {\n+            status_code,\n+            message: Some(message.into()),\n+        }\n+    }\n+}\n \n impl chroma_error::ChromaError for AuthError {\n     fn code(&self) -> chroma_error::ErrorCodes {\n-        match self.0 {\n+        match self.status_code {\n             StatusCode::UNAUTHORIZED => chroma_error::ErrorCodes::Unauthenticated,\n             StatusCode::FORBIDDEN => chroma_error::ErrorCodes::PermissionDenied,\n             _ => chroma_error::ErrorCodes::Internal,\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -235,6 +235,22 @@ impl ServiceBasedFrontend {\n         }\n     }\n \n+    fn _parse_universal_collection_identifier(input: String) -> Option<(String, String, String)> {\n+        let parts: Vec<&str> = input.split('/').collect();\n+        match parts.as_slice() {\n+            [tenant, database, collection]\n+                if !tenant.is_empty() && !database.is_empty() && !collection.is_empty() =>\n+            {\n+                Some((\n+                    tenant.to_string(),\n+                    database.to_string(),\n+                    collection.to_string(),\n+                ))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub async fn reset(&mut self) -> Result<ResetResponse, ResetError> {\n         if !self.allow_reset {\n             return Err(ResetError::NotAllowed);\n@@ -362,12 +378,19 @@ impl ServiceBasedFrontend {\n             ..\n         }: GetCollectionRequest,\n     ) -> Result<GetCollectionResponse, GetCollectionError> {\n+        let (resolved_tenant_id, resolved_database_name, resolved_collection_name) =\n+            Self::_parse_universal_collection_identifier(collection_name.clone()).unwrap_or((\n+                tenant_id.clone(),\n+                database_name.clone(),\n+                collection_name.clone(),\n+            ));\n+\n         let mut collections = self\n             .sysdb_client\n             .get_collections(GetCollectionsOptions {\n-                name: Some(collection_name.clone()),\n-                tenant: Some(tenant_id.clone()),\n-                database: Some(database_name.clone()),\n+                name: Some(resolved_collection_name.clone()),\n+                tenant: Some(resolved_tenant_id.clone()),\n+                database: Some(resolved_database_name.clone()),\n                 limit: Some(1),\n                 ..Default::default()\n             })\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nSmoke test is failing on fork.  Add debug to see what's what.\n\n## Test plan\n\nLog lines should \"just work\".\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js,\n`cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -967,7 +967,10 @@ func (tc *Catalog) ForkCollection(ctx context.Context, forkCollection *model.For\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\n+\t\t// Defensive backstop to prevent too many forks\n+\t\tif len(lineageFile.Dependencies) > 1000000 {\n+\t\t\treturn common.ErrCollectionTooManyFork\n+\t\t}\n \t\tlineageFile.Dependencies = append(lineageFile.Dependencies, &coordinatorpb.CollectionVersionDependency{\n \t\t\tSourceCollectionId:      sourceCollectionIDStr,\n \t\t\tSourceCollectionVersion: uint64(sourceCollection.Version),\n---\n\n\n---\n\nChoice B:\nk8s/distributed-chroma/values.dev.yaml\n@@ -33,3 +33,6 @@ compactionService:\n       value: 'value: \"1\"'\n     - name: CONFIG_PATH\n       value: 'value: \"/tilt_config.yaml\"'\n+\n+rustLogService:\n+  replicaCount: 2\n---\n\n\n---\n\nChoice C:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -835,7 +841,10 @@ impl DataSet for ReferencingDataSet {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1052,9 +1052,11 @@ func (tc *Catalog) ForkCollection(ctx context.Context, forkCollection *model.For\n \t\t// t2: Fork source collection in sysdb, the latest source collection compaction offset is 400. If we add new logs, it will start after offset 300, and the data is lost after compaction.\n \t\tlatestSourceCompactionOffset := uint64(sourceCollection.LogPosition)\n \t\tif forkCollection.SourceCollectionLogEnumerationOffset < latestSourceCompactionOffset {\n+\t\t\tlog.Error(\"CollectionLogPositionStale\", zap.Uint64(\"latestSourceCompactionOffset\", latestSourceCompactionOffset), zap.Uint64(\"forkCollection.SourceCollectionLogEnumerationOffset \", forkCollection.SourceCollectionLogEnumerationOffset))\n \t\t\treturn common.ErrCollectionLogPositionStale\n \t\t}\n \t\tif latestSourceCompactionOffset < forkCollection.SourceCollectionLogCompactionOffset {\n+\t\t\tlog.Error(\"CompactionOffsetSomehowAhead\", zap.Uint64(\"latestSourceCompactionOffset\", latestSourceCompactionOffset), zap.Uint64(\"forkCollection.SourceCollectionLogCompactionOffset\", forkCollection.SourceCollectionLogCompactionOffset))\n \t\t\treturn common.ErrCompactionOffsetSomehowAhead\n \t\t}\n \n---\nrust/log-service/src/lib.rs\n@@ -34,7 +34,7 @@ use prost::Message;\n use serde::{Deserialize, Serialize};\n use tokio::signal::unix::{signal, SignalKind};\n use tonic::{transport::Server, Code, Request, Response, Status};\n-use tracing::Instrument;\n+use tracing::{Instrument, Level};\n use uuid::Uuid;\n use wal3::{\n     Cursor, CursorName, CursorStore, CursorStoreOptions, Limits, LogPosition, LogReader,\n@@ -1223,6 +1223,7 @@ impl LogService for LogServer {\n             let offset = witness\n                 .map(|x| x.1.position)\n                 .unwrap_or(LogPosition::from_offset(0));\n+            tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n@@ -1250,6 +1251,7 @@ impl LogService for LogServer {\n                     format!(\"max_offset={:?} < offset={:?}\", max_offset, offset),\n                 ));\n             }\n+            tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n                 compaction_offset: offset.offset(),\n                 enumeration_offset: (max_offset - 1u64).offset(),\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nSmoke test is failing on fork.  Add debug to see what's what.\n\n## Test plan\n\nLog lines should \"just work\".\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/log/src/grpc_log.rs\n@@ -383,9 +383,9 @@ impl GrpcLog {\n         match &mut self.alt_client_assigner {\n             Some(assigner) => assigner\n                 .clients(&collection_id.to_string())\n-                .unwrap_or_default()\n-                .first()\n-                .cloned(),\n+                .ok()?\n+                .drain(..)\n+                .next(),\n             None => None,\n         }\n     }\n---\n\n\n---\n\nChoice B:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.42\n+version: 0.1.43\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/rust-log-service.yaml\n@@ -82,7 +82,7 @@ spec:\n           env:\n             - name: CONFIG_PATH\n               value: \"/config/config.yaml\"\n-            - name: CHROMA_QUERY_SERVICE__MY_MEMBER_ID\n+            - name: CHROMA_LOG_SERVICE__MY_MEMBER_ID\n               valueFrom:\n                 fieldRef:\n                   fieldPath: metadata.name\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1052,9 +1052,11 @@ func (tc *Catalog) ForkCollection(ctx context.Context, forkCollection *model.For\n \t\t// t2: Fork source collection in sysdb, the latest source collection compaction offset is 400. If we add new logs, it will start after offset 300, and the data is lost after compaction.\n \t\tlatestSourceCompactionOffset := uint64(sourceCollection.LogPosition)\n \t\tif forkCollection.SourceCollectionLogEnumerationOffset < latestSourceCompactionOffset {\n+\t\t\tlog.Error(\"CollectionLogPositionStale\", zap.Uint64(\"latestSourceCompactionOffset\", latestSourceCompactionOffset), zap.Uint64(\"forkCollection.SourceCollectionLogEnumerationOffset \", forkCollection.SourceCollectionLogEnumerationOffset))\n \t\t\treturn common.ErrCollectionLogPositionStale\n \t\t}\n \t\tif latestSourceCompactionOffset < forkCollection.SourceCollectionLogCompactionOffset {\n+\t\t\tlog.Error(\"CompactionOffsetSomehowAhead\", zap.Uint64(\"latestSourceCompactionOffset\", latestSourceCompactionOffset), zap.Uint64(\"forkCollection.SourceCollectionLogCompactionOffset\", forkCollection.SourceCollectionLogCompactionOffset))\n \t\t\treturn common.ErrCompactionOffsetSomehowAhead\n \t\t}\n \n---\nrust/log-service/src/lib.rs\n@@ -34,7 +34,7 @@ use prost::Message;\n use serde::{Deserialize, Serialize};\n use tokio::signal::unix::{signal, SignalKind};\n use tonic::{transport::Server, Code, Request, Response, Status};\n-use tracing::Instrument;\n+use tracing::{Instrument, Level};\n use uuid::Uuid;\n use wal3::{\n     Cursor, CursorName, CursorStore, CursorStoreOptions, Limits, LogPosition, LogReader,\n@@ -1223,6 +1223,7 @@ impl LogService for LogServer {\n             let offset = witness\n                 .map(|x| x.1.position)\n                 .unwrap_or(LogPosition::from_offset(0));\n+            tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n@@ -1250,6 +1251,7 @@ impl LogService for LogServer {\n                     format!(\"max_offset={:?} < offset={:?}\", max_offset, offset),\n                 ));\n             }\n+            tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n                 compaction_offset: offset.offset(),\n                 enumeration_offset: (max_offset - 1u64).offset(),\n---\n\n\n---\n\nChoice D:\nchromadb/test/distributed/test_log_failover.py\n@@ -19,6 +19,9 @@\n     skip_if_not_cluster,\n )\n from chromadb.test.property import invariants\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n+\n+RECORDS = 100\n \n @skip_if_not_cluster()\n def test_log_failover(\n@@ -39,32 +42,106 @@ def test_log_failover(\n     channel = grpc.insecure_channel('localhost:50052')\n     log_service_stub = LogServiceStub(channel)\n \n-    # Add 100 records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n+    # and 1\n+    for i in range(RECORDS, RECORDS + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_compaction(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n     ids = []\n     embeddings = []\n-    for i in range(100):\n+    for i in range(RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n+        if i == RECORDS / 2:\n+            # NOTE(rescrv):  This compaction tests a very particular race when migrating logs.\n+            # Imagine this sequence:\n+            # 1. Write 51 records to the go log.\n+            # 2. Compact all 51 records.\n+            # 3. Write 49 more records to the go log.\n+            # 4. Seal the go log.\n+            # 5. Log migration moves the remaining 49 records to the rust service.\n+            # 6. Cached frontend tries to read from a timestamp that includes all 100 records, using\n+            #    the initial compaction, but from a log that only has 49 records.\n+            # The fix is to make sure the log returns not found when a prefix of the log is\n+            # compacted.  This forces a fallback to repopulate the cache of the sysdb.\n+            wait_for_version_increase(client, collection.name, 0)\n \n     request = SealLogRequest(collection_id=str(collection.id))\n     response = log_service_stub.SealLog(request, timeout=60)\n \n-    # Add another 100 records, where each embedding has 3 dimensions randomly generated between 0\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n     # and 1\n-    for i in range(100, 200):\n+    for i in range(RECORDS, RECORDS + RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n \n-    for i in range(200):\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n         if len(result[\"embeddings\"]) == 0:\n             print(\"missing result\", i)\n-        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n---\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1545,14 +1545,15 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \tif tc.versionFileEnabled {\n \t\treturn tc.FlushCollectionCompactionForVersionedCollection(ctx, flushCollectionCompaction)\n \t}\n+\tcollectionID := types.FromUniqueID(flushCollectionCompaction.ID)\n \n \tflushCollectionInfo := &model.FlushCollectionInfo{\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n \terr := tc.txImpl.Transaction(ctx, func(txCtx context.Context) error {\n \t\t// Check if collection exists.\n-\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(types.FromUniqueID(flushCollectionCompaction.ID), nil, nil)\n+\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(collectionID, nil, nil)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1589,6 +1590,7 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \t\t// return nil will commit the transaction\n \t\treturn nil\n \t})\n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", *collectionID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1641,6 +1643,8 @@ func (tc *Catalog) FlushCollectionCompactionForVersionedCollection(ctx context.C\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", flushCollectionInfo.ID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n+\n \t// Do the operation in a loop until the CollectionEntry is updated,\n \t// \t\tOR FAIL the operation if the version is stale\n \t//      OR other DB error.\n---\nrust/log-service/src/lib.rs\n@@ -1080,6 +1080,9 @@ impl LogService for LogServer {\n                     });\n                 }\n             }\n+            if !records.is_empty() && records[0].log_offset != pull_logs.start_from_offset {\n+                return Err(Status::not_found(\"Some entries have been purged\"));\n+            }\n             tracing::info!(\"pulled {} records\", records.len());\n             Ok(Response::new(PullLogsResponse { records }))\n         }\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nIf the old and new documents are identical, we can save compute by ignoring the update.\r\n\r\nA customer on Chroma Cloud seems to have a workload with a lot of no-op updates, so this should improve compaction speed for their collections.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\nrust/index/src/fulltext/types.rs\n@@ -106,6 +106,11 @@ impl FullTextIndexWriter {\n                     old_document,\n                     new_document,\n                 } => {\n+                    if old_document == new_document {\n+                        // Don't need to do anything if document is identical\n+                        continue;\n+                    }\n+\n                     // Remove old version\n                     let mut trigrams_to_delete = HashSet::new(); // (need to filter out duplicates, each trigram may appear multiple times in a document)\n                     self.tokenizer\n@@ -1067,7 +1072,7 @@ mod tests {\n         let flusher = index_writer.commit().await.unwrap();\n         flusher.flush().await.unwrap();\n \n-        // Update document 3\n+        // Update document document 1 with same content, update document 3 with new content\n         let pl_blockfile_writer = provider\n             .write::<u32, Vec<u32>>(\n                 BlockfileWriterOptions::new()\n@@ -1079,11 +1084,18 @@ mod tests {\n         let pl_blockfile_id = pl_blockfile_writer.id();\n         let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer);\n         index_writer\n-            .handle_batch([DocumentMutation::Update {\n-                offset_id: 3,\n-                old_document: \"world\",\n-                new_document: \"hello\",\n-            }])\n+            .handle_batch([\n+                DocumentMutation::Update {\n+                    offset_id: 1,\n+                    old_document: \"hello world\",\n+                    new_document: \"hello world\",\n+                },\n+                DocumentMutation::Update {\n+                    offset_id: 3,\n+                    old_document: \"world\",\n+                    new_document: \"hello\",\n+                },\n+            ])\n             .unwrap();\n \n         index_writer.write_to_blockfiles().await.unwrap();\n@@ -1102,6 +1114,89 @@ mod tests {\n \n         let res = index_reader.search(\"world\").await.unwrap();\n         assert_eq!(res, RoaringBitmap::from([1]));\n+\n+        let res = index_reader.search(\"hello world\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([1]));\n+    }\n+\n+    #[tokio::test]\n+    async fn test_update_document_noop() {\n+        let tmp_dir = tempdir().unwrap();\n+        let storage = Storage::Local(LocalStorage::new(tmp_dir.path().to_str().unwrap()));\n+        let block_cache = new_cache_for_test();\n+        let root_cache = new_cache_for_test();\n+        let provider = BlockfileProvider::new_arrow(storage, 1024 * 1024, block_cache, root_cache);\n+        let pl_blockfile_writer = provider\n+            .write::<u32, Vec<u32>>(BlockfileWriterOptions::default().ordered_mutations())\n+            .await\n+            .unwrap();\n+        let pl_blockfile_id = pl_blockfile_writer.id();\n+\n+        let tokenizer = NgramTokenizer::new(1, 1, false).unwrap();\n+\n+        // Create empty index\n+        let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer.clone());\n+\n+        index_writer.handle_batch([]).unwrap();\n+\n+        index_writer.write_to_blockfiles().await.unwrap();\n+        let flusher = index_writer.commit().await.unwrap();\n+        flusher.flush().await.unwrap();\n+\n+        // Add document to index\n+        let pl_blockfile_writer = provider\n+            .write::<u32, Vec<u32>>(\n+                BlockfileWriterOptions::new()\n+                    .ordered_mutations()\n+                    .fork(pl_blockfile_id),\n+            )\n+            .await\n+            .unwrap();\n+        let pl_blockfile_id = pl_blockfile_writer.id();\n+        let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer.clone());\n+        index_writer\n+            .handle_batch([DocumentMutation::Create {\n+                offset_id: 1,\n+                new_document: \"hello world\",\n+            }])\n+            .unwrap();\n+\n+        index_writer.write_to_blockfiles().await.unwrap();\n+        let flusher = index_writer.commit().await.unwrap();\n+        flusher.flush().await.unwrap();\n+\n+        // Update document with same content, should be a noop\n+        let pl_blockfile_writer = provider\n+            .write::<u32, Vec<u32>>(\n+                BlockfileWriterOptions::new()\n+                    .ordered_mutations()\n+                    .fork(pl_blockfile_id),\n+            )\n+            .await\n+            .unwrap();\n+        let pl_blockfile_id = pl_blockfile_writer.id();\n+        let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer);\n+        index_writer\n+            .handle_batch([DocumentMutation::Update {\n+                offset_id: 1,\n+                old_document: \"hello world\",\n+                new_document: \"hello world\",\n+            }])\n+            .unwrap();\n+\n+        index_writer.write_to_blockfiles().await.unwrap();\n+        let flusher = index_writer.commit().await.unwrap();\n+        flusher.flush().await.unwrap();\n+\n+        let pl_blockfile_reader = provider\n+            .read::<u32, &[u32]>(&pl_blockfile_id)\n+            .await\n+            .unwrap();\n+        let tokenizer = NgramTokenizer::new(1, 1, false).unwrap();\n+        let index_reader = FullTextIndexReader::new(pl_blockfile_reader, tokenizer);\n+\n+        let res = index_reader.search(\"hello world\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([1]));\n     }\n \n     #[tokio::test]\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -22,6 +22,7 @@ use chroma_types::chroma_proto::{\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n use figment::providers::{Env, Format, Yaml};\n+use opentelemetry::metrics::Meter;\n use parquet::arrow::arrow_reader::ParquetRecordBatchReaderBuilder;\n use prost::Message;\n use serde::{Deserialize, Serialize};\n@@ -48,6 +49,22 @@ const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n static STABLE_PREFIX: CursorName = unsafe { CursorName::from_string_unchecked(\"stable_prefix\") };\n static COMPACTION: CursorName = unsafe { CursorName::from_string_unchecked(\"compaction\") };\n \n+////////////////////////////////////////////// Metrics /////////////////////////////////////////////\n+\n+pub struct Metrics {\n+    log_total_uncompacted_records_count: opentelemetry::metrics::Gauge<f64>,\n+}\n+\n+impl Metrics {\n+    pub fn new(meter: Meter) -> Self {\n+        Self {\n+            log_total_uncompacted_records_count: meter\n+                .f64_gauge(\"log_total_uncompacted_records_count\")\n+                .build(),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////// state maintenance ////////////////////////////////////////\n \n // NOTE(rescrv):  This code dynamically opens and closes logs.  An opened log will stay open until\n@@ -334,6 +351,7 @@ impl DirtyMarker {\n \n     /// Given a contiguous prefix of markers, process the log into a rollup.  That is, a set of\n     /// markers to reinsert, a set of collections to compact, and an advance_to log position.\n+    #[allow(clippy::too_many_arguments)]\n     pub async fn rollup<\n         F1: Future<Output = Result<Option<Manifest>, wal3::Error>>,\n         F2: Future<Output = Result<Option<Witness>, wal3::Error>>,\n@@ -345,6 +363,7 @@ impl DirtyMarker {\n         record_count_threshold: u64,\n         reinsert_threshold: u64,\n         timeout_us: u64,\n+        metrics: &Metrics,\n     ) -> Result<Option<Rollup>, wal3::Error> {\n         // NOTE(rescrv);  This is complicated code because it's a hard problem to do efficiently.\n         // To cut complexity, I've chosen to do it in a way that is not the most efficient but is\n@@ -434,6 +453,7 @@ impl DirtyMarker {\n             .into_iter()\n             .flat_map(Result::ok)\n             .collect::<HashMap<_, _>>();\n+        let mut uncompacted = 0u64;\n         let compactable = compactable\n             .into_iter()\n             .filter_map(|collection_id| {\n@@ -473,6 +493,7 @@ impl DirtyMarker {\n                             cursor.position,\n                             manifest.maximum_log_position(),\n                         );\n+                        uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_threshold {\n                             Some(CollectionInfo {\n                                 collection_id: collection_id.to_string(),\n@@ -514,6 +535,9 @@ impl DirtyMarker {\n                 }\n             }\n         }\n+        metrics\n+            .log_total_uncompacted_records_count\n+            .record(uncompacted as f64, &[]);\n         Ok(Some(Rollup {\n             advance_to,\n             reinsert,\n@@ -608,6 +632,7 @@ pub struct LogServer {\n     dirty_log: Arc<LogWriter>,\n     compacting: tokio::sync::Mutex<()>,\n     cache: Option<Box<dyn chroma_cache::PersistentCache<String, CachedParquetFragment>>>,\n+    metrics: Metrics,\n }\n \n #[async_trait::async_trait]\n@@ -977,6 +1002,7 @@ impl LogService for LogServer {\n             ),\n             self.config.reinsert_threshold,\n             self.config.timeout_us,\n+            &self.metrics,\n         )\n         .await\n         .map_err(|err| Status::unavailable(err.to_string()))?;\n@@ -1456,13 +1482,15 @@ impl Configurable<LogServerConfig> for LogServer {\n         .map_err(|err| -> Box<dyn ChromaError> { Box::new(err) as _ })?;\n         let dirty_log = Arc::new(dirty_log);\n         let compacting = tokio::sync::Mutex::new(());\n+        let metrics = Metrics::new(opentelemetry::global::meter(\"chroma\"));\n         Ok(Self {\n             config: config.clone(),\n             open_logs: Arc::new(StateHashTable::default()),\n             storage,\n             dirty_log,\n             compacting,\n             cache,\n+            metrics,\n         })\n     }\n }\n@@ -1565,6 +1593,7 @@ mod tests {\n             1,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1626,6 +1655,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1709,6 +1739,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1822,6 +1853,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -215,7 +215,18 @@ async fn get_log_from_handle<'a>(\n     prefix: &str,\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n-    let mut active = handle.active.lock().await;\n+    let active = handle.active.lock().await;\n+    get_log_from_handle_with_mutex_held(handle, active, options, storage, prefix, mark_dirty).await\n+}\n+\n+async fn get_log_from_handle_with_mutex_held<'a>(\n+    handle: &'a crate::state_hash_table::Handle<LogKey, LogStub>,\n+    mut active: tokio::sync::MutexGuard<'_, ActiveLog>,\n+    options: &LogWriterOptions,\n+    storage: &Arc<Storage>,\n+    prefix: &str,\n+    mark_dirty: MarkDirty,\n+) -> Result<LogRef<'a>, wal3::Error> {\n     if active.log.is_some() {\n         active.keep_alive(Duration::from_secs(60));\n     }\n@@ -519,7 +530,12 @@ impl LogServer {\n         // Grab a lock on the state for this key, so that a racing initialize won't do anything.\n         let key = LogKey { collection_id };\n         let handle = self.open_logs.get_or_create_state(key);\n-        let mut _active = handle.active.lock().await;\n+        let active = handle.active.lock().await;\n+\n+        // Someone already initialized the log on a prior call.\n+        if active.log.is_some() {\n+            return Ok(());\n+        }\n \n         tracing::info!(\"log transfer to {collection_id}\");\n         let scout_request = Request::new(ScoutLogsRequest {\n@@ -641,6 +657,23 @@ impl LogServer {\n             log_offset: start as i64 - 1,\n         }))\n         .await?;\n+        // Set it up so that once we release the mutex, the next person won't do I/O and will\n+        // immediately be able to push logs.\n+        let storage_prefix = storage_prefix_for_log(collection_id);\n+        let mark_dirty = MarkDirty {\n+            collection_id,\n+            dirty_log: Arc::clone(&self.dirty_log),\n+        };\n+        // If this fails, the next writer will load manifest and continue unimpeded.\n+        let _ = get_log_from_handle_with_mutex_held(\n+            &handle,\n+            active,\n+            &self.config.writer,\n+            &self.storage,\n+            &storage_prefix,\n+            mark_dirty,\n+        )\n+        .await;\n         Ok(())\n     }\n \n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1555,6 +1555,10 @@ func (tc *Catalog) FlushCollectionCompactionForVersionedCollection(ctx context.C\n \t\t\t\treturn nil, err\n \t\t\t}\n \n+\t\t\t// There was previously a bug that resulted in the tenant ID missing from some version files (https://github.com/chroma-core/chroma/pull/4408).\n+\t\t\t// This line can be removed once all corrupted version files are fixed.\n+\t\t\texistingVersionFilePb.CollectionInfoImmutable.TenantId = collectionEntry.Tenant\n+\n \t\t\t// Do a simple validation of the version file.\n \t\t\terr = tc.validateVersionFile(existingVersionFilePb, collectionEntry.ID, existingVersion)\n \t\t\tif err != nil {\n---\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionEntry(collectionID *string, databaseName *string) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, databases.tenant_id, collections.version, collections.version_file_name, collections.root_collection_id\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nOne path is timing out in staging.  Add tolerance for that and some\ndebugging.\n\n## Test plan\n\nCompiles\n\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -376,6 +376,8 @@ impl DirtyMarker {\n         timeout_us: u64,\n         metrics: &Metrics,\n     ) -> Result<Option<Rollup>, wal3::Error> {\n+        let cpu_span = tracing::info_span!(\"cpu computation\");\n+        let cpu_span_guard = cpu_span.enter();\n         // NOTE(rescrv);  This is complicated code because it's a hard problem to do efficiently.\n         // To cut complexity, I've chosen to do it in a way that is not the most efficient but is\n         // readable and maintainable.  The most efficient way would be to do this in a single pass.\n@@ -420,6 +422,7 @@ impl DirtyMarker {\n         if compactable.is_empty() {\n             return Ok(None);\n         }\n+        drop(cpu_span_guard);\n         // Now fetch the compaction cursor for each collection.\n         let retrieve_manifest = Arc::new(retrieve_manifest);\n         let retrieve_cursor = Arc::new(retrieve_cursor);\n@@ -435,8 +438,10 @@ impl DirtyMarker {\n             })\n             .map(\n                 |(collection_id, storage, retrieve_manifest, retrieve_cursor)| async move {\n-                    let cursor = (*retrieve_cursor)(Arc::clone(&storage), collection_id);\n-                    let manifest = (*retrieve_manifest)(Arc::clone(&storage), collection_id);\n+                    let cursor = (*retrieve_cursor)(Arc::clone(&storage), collection_id)\n+                        .instrument(tracing::info_span!(\"fetching cursor\"));\n+                    let manifest = (*retrieve_manifest)(Arc::clone(&storage), collection_id)\n+                        .instrument(tracing::info_span!(\"fetching manifest\"));\n                     let (cursor, manifest) = futures::future::join(cursor, manifest).await;\n                     // NOTE(rescrv):  We silence the error so we log it instead.\n                     let cursor = match cursor {\n@@ -458,7 +463,12 @@ impl DirtyMarker {\n                 },\n             )\n             .collect::<Vec<_>>();\n-        let cursors = futures::future::join_all(futs).await;\n+        let rollup_span = tracing::info_span!(\"fetching cursors and manifests\");\n+        let cursors = futures::future::join_all(futs)\n+            .instrument(rollup_span)\n+            .await;\n+        let reprise_cpu_span = tracing::info_span!(\"cpu computation reprise\");\n+        let _reprise_cpu_span_guard = reprise_cpu_span.enter();\n         let cursors = cursors\n             .into_iter()\n             .flat_map(Result::ok)\n@@ -1361,6 +1371,7 @@ impl LogService for LogServer {\n                 );\n                 cursor_store.load(cursor).await\n             };\n+            let rollup_span = tracing::info_span!(\"DirtyMarker::rollup\");\n             let rollup = DirtyMarker::rollup(\n                 Arc::clone(&self.storage),\n                 load_manifest,\n@@ -1375,6 +1386,7 @@ impl LogService for LogServer {\n                 self.config.timeout_us,\n                 &self.metrics,\n             )\n+            .instrument(rollup_span)\n             .await\n             .map_err(|err| Status::unavailable(err.to_string()))?;\n             let Some(rollup) = rollup else {\n---\n\n\n---\n\nChoice B:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1555,6 +1555,10 @@ func (tc *Catalog) FlushCollectionCompactionForVersionedCollection(ctx context.C\n \t\t\t\treturn nil, err\n \t\t\t}\n \n+\t\t\t// There was previously a bug that resulted in the tenant ID missing from some version files (https://github.com/chroma-core/chroma/pull/4408).\n+\t\t\t// This line can be removed once all corrupted version files are fixed.\n+\t\t\texistingVersionFilePb.CollectionInfoImmutable.TenantId = collectionEntry.Tenant\n+\n \t\t\t// Do a simple validation of the version file.\n \t\t\terr = tc.validateVersionFile(existingVersionFilePb, collectionEntry.ID, existingVersion)\n \t\t\tif err != nil {\n---\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionEntry(collectionID *string, databaseName *string) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, databases.tenant_id, collections.version, collections.version_file_name, collections.root_collection_id\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\nChoice D:\nrust/log/src/grpc_log.rs\n@@ -554,6 +554,7 @@ impl GrpcLog {\n         min_compaction_size: u64,\n     ) -> Result<Vec<CollectionInfo>, GrpcGetCollectionsWithNewDataError> {\n         let mut combined_response = Vec::new();\n+        let mut error = None;\n \n         if use_alt_log {\n             // Iterate over all alt clients and gather collections\n@@ -567,14 +568,25 @@ impl GrpcLog {\n                 }\n                 for mut alt_client in all_alt_clients.drain(..) {\n                     // We error if any subrequest errors\n-                    let response = alt_client\n+                    match alt_client\n                         .get_all_collection_info_to_compact(\n                             chroma_proto::GetAllCollectionInfoToCompactRequest {\n                                 min_compaction_size,\n                             },\n                         )\n-                        .await?;\n-                    combined_response.push(response.into_inner());\n+                        .await\n+                    {\n+                        Ok(response) => {\n+                            combined_response.push(response.into_inner());\n+                        }\n+                        Err(err) => {\n+                            tracing::error!(\"could not get all collection info to compact: {err}\");\n+                            if error.is_none() {\n+                                error = Some(err);\n+                            }\n+                            continue;\n+                        }\n+                    };\n                 }\n             } else {\n                 tracing::warn!(\n@@ -583,17 +595,33 @@ impl GrpcLog {\n                 return Ok(vec![]);\n             }\n         } else {\n-            let response = self\n+            match self\n                 .client\n                 .get_all_collection_info_to_compact(\n                     chroma_proto::GetAllCollectionInfoToCompactRequest {\n                         min_compaction_size,\n                     },\n                 )\n-                .await?;\n-            combined_response.push(response.into_inner());\n+                .await\n+            {\n+                Ok(response) => {\n+                    combined_response.push(response.into_inner());\n+                }\n+                Err(err) => {\n+                    tracing::error!(\"could not get all collection info to compact: {err}\");\n+                    if error.is_none() {\n+                        error = Some(err);\n+                    }\n+                }\n+            };\n         };\n \n+        if let Some(status) = error {\n+            if combined_response.is_empty() {\n+                return Err(status.into());\n+            }\n+        }\n+\n         let mut all_collections = Vec::new();\n         for response in combined_response {\n             let collections = response.all_collection_info;\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nDecreases wall time of integration tests from ~18m to ~16m.\r\n\r\nUnfortunately the bulk of the time is still spent by the garbage collector proptest, which can't really be sped up without decreasing the number of cases tested.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\n\n---\n\nChoice A:\n.github/workflows/_rust-tests.yml\n@@ -42,7 +42,9 @@ jobs:\n     strategy:\n       matrix:\n         platform: [blacksmith-16vcpu-ubuntu-2204]\n+        partition: [1, 2]\n     runs-on: ${{ matrix.platform }}\n+    name: Integration test ${{ matrix.partition }}/2\n     # OIDC token auth for AWS\n     permissions:\n       contents: read\n@@ -66,12 +68,12 @@ jobs:\n       - name: Build CLI\n         run: cargo build --bin chroma\n       - name: Run tests\n-        run: cargo nextest run --profile ci_k8s_integration\n+        run: cargo nextest run --profile ci_k8s_integration --partition hash:${{ matrix.partition }}/2\n       - name: Save service logs to artifact\n         if: always()\n         uses: ./.github/actions/export-tilt-logs\n         with:\n-          artifact-name: \"rust-integration-test\"\n+          artifact-name: \"rust-integration-test-${{ matrix.partition }}\"\n   test-benches:\n     strategy:\n       matrix:\n---\n\n\n---\n\nChoice B:\nCargo.lock\n@@ -1813,8 +1813,10 @@ dependencies = [\n  \"bytes\",\n  \"chroma-config\",\n  \"chroma-error\",\n+ \"chroma-tracing\",\n  \"futures\",\n  \"object_store\",\n+ \"opentelemetry\",\n  \"parking_lot\",\n  \"rand 0.8.5\",\n  \"rand_xorshift\",\n---\nrust/storage/Cargo.toml\n@@ -23,9 +23,11 @@ thiserror.workspace = true\n tokio = { workspace = true }\n tokio-util = { workspace = true }\n tracing = { workspace = true }\n+opentelemetry = { workspace = true }\n \n chroma-config = { workspace = true }\n chroma-error = { workspace = true }\n+chroma-tracing = { workspace = true }\n \n [dev-dependencies]\n rand_xorshift = { workspace = true }\n---\nrust/storage/src/admissioncontrolleds3.rs\n@@ -10,6 +10,7 @@ use bytes::Bytes;\n use chroma_config::registry::Registry;\n use chroma_config::Configurable;\n use chroma_error::ChromaError;\n+use chroma_tracing::util::Stopwatch;\n use futures::future::BoxFuture;\n use futures::{future::Shared, stream, FutureExt, StreamExt};\n use std::{\n@@ -524,9 +525,30 @@ impl RateLimitPolicy {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct CountBasedPolicyMetrics {\n+    // The delay in milliseconds before a request is allowed to proceed.\n+    pub nac_delay_ms: opentelemetry::metrics::Histogram<u64>,\n+}\n+\n+impl Default for CountBasedPolicyMetrics {\n+    fn default() -> Self {\n+        Self {\n+            nac_delay_ms: opentelemetry::global::meter(\"chroma.storage.admission_control\")\n+                .u64_histogram(\"nac_delay_ms\")\n+                .with_description(\n+                    \"The delay in milliseconds before a request is allowed to proceed.\",\n+                )\n+                .with_unit(\"ms\")\n+                .build(),\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct CountBasedPolicy {\n     remaining_tokens: Vec<Semaphore>,\n+    metrics: CountBasedPolicyMetrics,\n }\n \n impl CountBasedPolicy {\n@@ -537,14 +559,18 @@ impl CountBasedPolicy {\n                 (max_allowed_outstanding as f32 * allocation).ceil() as usize,\n             ));\n         }\n-        Self { remaining_tokens }\n+        Self {\n+            remaining_tokens,\n+            metrics: CountBasedPolicyMetrics::default(),\n+        }\n     }\n \n     async fn acquire(\n         &self,\n         priority: Arc<AtomicUsize>,\n         mut channel_receiver: Option<tokio::sync::mpsc::Receiver<()>>,\n     ) -> SemaphorePermit<'_> {\n+        let _stopwatch = Stopwatch::new(&self.metrics.nac_delay_ms, &[]);\n         loop {\n             let current_priority = priority.load(Ordering::SeqCst);\n             let current_priority: StorageRequestPriority = current_priority.into();\n---\n\n\n---\n\nChoice C:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.42\n+version: 0.1.43\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/rust-log-service.yaml\n@@ -82,7 +82,7 @@ spec:\n           env:\n             - name: CONFIG_PATH\n               value: \"/config/config.yaml\"\n-            - name: CHROMA_QUERY_SERVICE__MY_MEMBER_ID\n+            - name: CHROMA_LOG_SERVICE__MY_MEMBER_ID\n               valueFrom:\n                 fieldRef:\n                   fieldPath: metadata.name\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/tower_tracing.rs\n@@ -6,6 +6,7 @@ use opentelemetry::trace::TraceContextExt;\n use std::time::Duration;\n use tower::Service;\n use tower_http::trace::{MakeSpan, OnResponse, TraceLayer};\n+use tracing::Instrument;\n \n use tracing_opentelemetry::OpenTelemetrySpanExt;\n \n@@ -16,8 +17,7 @@ impl<B> MakeSpan<B> for RequestTracing {\n         let http_route = request\n             .extensions()\n             .get::<MatchedPath>()\n-            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str())\n-            .to_owned();\n+            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str());\n \n         let host = request\n             .headers()\n@@ -56,15 +56,18 @@ impl<B> OnResponse<B> for RequestTracing {\n     }\n }\n \n+/// TracingMiddleware adds trace ID to the response headers\n+/// and wraps the inner handler with a span.\n #[derive(Clone)]\n-pub struct TraceIdMiddleware<S> {\n+pub struct TracingMiddleware<S> {\n     inner: S,\n }\n \n-impl<S, Request, Rs> Service<Request> for TraceIdMiddleware<S>\n+impl<S, B, Rs> Service<Request<B>> for TracingMiddleware<S>\n where\n-    S: Service<Request, Response = Response<Rs>> + Send + 'static,\n+    S: Service<Request<B>, Response = Response<Rs>> + Send + 'static,\n     S::Future: Send + 'static,\n+    B: Send + 'static,\n {\n     type Response = S::Response;\n     type Error = S::Error;\n@@ -77,10 +80,23 @@ where\n         self.inner.poll_ready(cx)\n     }\n \n-    fn call(&mut self, req: Request) -> Self::Future {\n+    fn call(&mut self, req: Request<B>) -> Self::Future {\n+        let http_route = req\n+            .extensions()\n+            .get::<MatchedPath>()\n+            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str());\n+\n+        let handler_span = tracing::span!(\n+            tracing::Level::DEBUG,\n+            \"HTTP request handler\",\n+            http.route = http_route,\n+            otel.name = format!(\"Handler {} {}\", req.method(), http_route),\n+        );\n+\n         let future = self.inner.call(req);\n+\n         Box::pin(async move {\n-            let mut response: Response<Rs> = future.await?;\n+            let mut response: Response<Rs> = future.instrument(handler_span).await?;\n             if response.status().is_client_error() || response.status().is_server_error() {\n                 let trace_id = tracing::Span::current()\n                     .context()\n@@ -109,10 +125,10 @@ impl SetTraceIdLayer {\n }\n \n impl<S> tower::layer::Layer<S> for SetTraceIdLayer {\n-    type Service = TraceIdMiddleware<S>;\n+    type Service = TracingMiddleware<S>;\n \n     fn layer(&self, inner: S) -> Self::Service {\n-        TraceIdMiddleware { inner }\n+        TracingMiddleware { inner }\n     }\n }\n \n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nDecreases test time of cross_test_version_persist from 13m11s to 5m47s for a 2.3x speedup. We have tried this in the past and ended up having [strange non-deterministic behavior](https://github.com/chroma-core/chroma/issues/4263), but [I ran a stress test here of 30x runs in a row](https://github.com/chroma-core/chroma/actions/runs/15336971977/job/43156007261?pr=4675) and it no longer seems to happen.\r\n\n\n---\n\nChoice A:\n.github/workflows/_go-tests.yml\n@@ -23,6 +23,9 @@ jobs:\n       - name: Start Tilt services\n         uses: ./.github/actions/tilt\n       - run: bin/cluster-test.sh bash -c 'cd go && make test'\n+        env:\n+          # Ryuk cleans up containers and is enabled by default. In CI it causes tests to occasionally flake.\n+          TESTCONTAINERS_RYUK_DISABLED: \"true\"\n       - name: Save service logs to artifact\n         if: always()\n         uses: ./.github/actions/export-tilt-logs\n---\ngo/Makefile\n@@ -27,8 +27,12 @@ build: proto\n \tgo build -v -o bin/coordinator ./cmd/coordinator/\n \tgo build -v -o bin/logservice ./cmd/logservice/\n \n+# -p 1 runs tests sequentially. If run in parallel tests are pretty flaky in CI.\n+# I believe this is caused by go/script/migrate_up_test.sh, which creates the possibility (observed during CI runs) of running multiple `atlas schema apply --dev-url \"docker://postgres/15/dev\" ...` in parallel.\n+# This command spins up a new Docker container, so my theory is that there's a race condition inside atlas when used this way.\n+# Instead of specifying -p 1, it might be possible to add a cross-process lock to guarantee that only one instance of atlas is running at a time.\n test: build\n-\tgo test -race -cover ./...\n+\tgo test -p 1 -race -cover ./...\n \n \n lint:\n---\ngo/pkg/sysdb/metastore/db/dbcore/core.go\n@@ -224,7 +224,7 @@ func GetDBConfigForTesting() DBConfig {\n \tdbName := \"chroma\"\n \tdbUsername := \"chroma\"\n \tdbPassword := \"chroma\"\n-\tcontainer, _ = postgres2.RunContainer(context.Background(),\n+\tcontainer, err := postgres2.RunContainer(context.Background(),\n \t\ttestcontainers.WithImage(\"docker.io/postgres:15.2-alpine\"),\n \t\tpostgres2.WithDatabase(dbName),\n \t\tpostgres2.WithUsername(dbUsername),\n@@ -235,6 +235,10 @@ func GetDBConfigForTesting() DBConfig {\n \t\t\t\tWithStartupTimeout(5*time.Second)),\n \t)\n \n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n \tvar ports nat.PortMap\n \tports, _ = container.Ports(context.Background())\n \n---\n\n\n---\n\nChoice B:\n.github/workflows/release-chromadb.yml\n@@ -220,7 +220,7 @@ jobs:\n                 // - This workflow finishes for A and deploys A to Chroma Cloud\n                 // Chroma Cloud is now running A, but the last commit was B.\n                 \"environment\": \"staging\",\n-                \"planes\": \"data,control\"\n+                \"planes\": \"control,data\"\n               }\n             })\n \n---\n.github/workflows/trigger-deploy.yaml\n@@ -5,8 +5,9 @@ on:\n   push:\n     branches:\n       # main is not included here because it is handled by the release-chromadb.yaml workflow\n+      # production deploys (release branches) are also not here because they are currently\n+      # meant to be handled manually.\n       - rc/**-**-**\n-      - release/**-**-**\n \n jobs:\n   deploy:\n@@ -25,7 +26,7 @@ jobs:\n               ref: 'main',\n               inputs: {\n                 'planes': 'control,data',\n-                 environment: '${{ contains(github.ref, 'release/') && 'production' || 'staging' }}',\n+                 environment: 'staging',\n                 'ignore-lock': true,\n                 'oss-ref': '${{ github.ref_name }}',\n                 'hosted-ref': '${{ github.ref_name }}'\n---\n\n\n---\n\nChoice C:\nrust/wal3/src/writer.rs\n@@ -518,9 +518,7 @@ impl OnceLogWriter {\n             log_position,\n             messages,\n         );\n-        let fut2 = self\n-            .mark_dirty\n-            .mark_dirty(log_position + messages_len, messages_len);\n+        let fut2 = self.mark_dirty.mark_dirty(log_position, messages_len);\n         let (res1, res2) = futures::future::join(fut1, fut2).await;\n         res2?;\n         let (path, setsum, num_bytes) = res1?;\n---\n\n\n---\n\nChoice D:\n.github/workflows/_python-tests.yml\n@@ -24,11 +24,12 @@ jobs:\n         test-globs:\n           - \"--ignore-glob 'chromadb/test/property/*' --ignore-glob 'chromadb/test/stress/*' --ignore-glob 'chromadb/test/distributed/*'\"\n           - \"chromadb/test/property --ignore-glob chromadb/test/property/test_cross_version_persist.py\"\n-          # TODO(@codetheweb): this test should be parallelized, but it frequently flakes in CI when parallelized. We have not been able to reproduce the failure locally. See https://github.com/chroma-core/chroma/issues/4263.\n           - \"chromadb/test/property/test_cross_version_persist.py\"\n         include:\n           - test-globs: \"chromadb/test/property --ignore-glob chromadb/test/property/test_cross_version_persist.py\"\n             parallelized: true\n+          - test-globs: \"chromadb/test/property/test_cross_version_persist.py\"\n+            parallelized: true\n \n     runs-on: ${{ matrix.platform }}\n     steps:\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nQuote was in wrong position.\r\n\n\n---\n\nChoice A:\nchromadb/utils/embedding_functions/instructor_embedding_function.py\n@@ -39,7 +39,7 @@ def __init__(\n         self.device = device\n         self.instruction = instruction\n \n-        self._model = INSTRUCTOR(model_name, device=device)\n+        self._model = INSTRUCTOR(model_name_or_path=model_name, device=device)\n \n     def __call__(self, input: Documents) -> Embeddings:\n         \"\"\"\n@@ -99,10 +99,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\nchromadb/utils/embedding_functions/sentence_transformer_embedding_function.py\n@@ -42,7 +42,7 @@ def __init__(\n \n         if model_name not in self.models:\n             self.models[model_name] = SentenceTransformer(\n-                model_name, device=device, **kwargs\n+                model_name_or_path=model_name, device=device, **kwargs\n             )\n         self._model = self.models[model_name]\n \n@@ -102,10 +102,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\nchromadb/utils/embedding_functions/text2vec_embedding_function.py\n@@ -71,10 +71,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\n\n\n---\n\nChoice B:\n.github/workflows/_python-tests.yml\n@@ -155,7 +155,7 @@ jobs:\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n       - uses: ./.github/actions/tilt\n       - name: Test\n-        run: bin/cluster-test.sh bash -c 'python -m pytest \"${{ matrix.test-globs }}\"' --durations 10\n+        run: bin/cluster-test.sh bash -c 'python -m pytest \"${{ matrix.test-globs }}\" --durations 10'\n         shell: bash\n         env:\n           PROPERTY_TESTING_PRESET: ${{ inputs.property_testing_preset }}\n---\n\n\n---\n\nChoice C:\nchromadb/test/distributed/test_log_failover.py\n@@ -19,6 +19,9 @@\n     skip_if_not_cluster,\n )\n from chromadb.test.property import invariants\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n+\n+RECORDS = 100\n \n @skip_if_not_cluster()\n def test_log_failover(\n@@ -39,32 +42,106 @@ def test_log_failover(\n     channel = grpc.insecure_channel('localhost:50052')\n     log_service_stub = LogServiceStub(channel)\n \n-    # Add 100 records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n+    # and 1\n+    for i in range(RECORDS, RECORDS + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_compaction(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n     ids = []\n     embeddings = []\n-    for i in range(100):\n+    for i in range(RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n+        if i == RECORDS / 2:\n+            # NOTE(rescrv):  This compaction tests a very particular race when migrating logs.\n+            # Imagine this sequence:\n+            # 1. Write 51 records to the go log.\n+            # 2. Compact all 51 records.\n+            # 3. Write 49 more records to the go log.\n+            # 4. Seal the go log.\n+            # 5. Log migration moves the remaining 49 records to the rust service.\n+            # 6. Cached frontend tries to read from a timestamp that includes all 100 records, using\n+            #    the initial compaction, but from a log that only has 49 records.\n+            # The fix is to make sure the log returns not found when a prefix of the log is\n+            # compacted.  This forces a fallback to repopulate the cache of the sysdb.\n+            wait_for_version_increase(client, collection.name, 0)\n \n     request = SealLogRequest(collection_id=str(collection.id))\n     response = log_service_stub.SealLog(request, timeout=60)\n \n-    # Add another 100 records, where each embedding has 3 dimensions randomly generated between 0\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n     # and 1\n-    for i in range(100, 200):\n+    for i in range(RECORDS, RECORDS + RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n \n-    for i in range(200):\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n         if len(result[\"embeddings\"]) == 0:\n             print(\"missing result\", i)\n-        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n---\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1545,14 +1545,15 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \tif tc.versionFileEnabled {\n \t\treturn tc.FlushCollectionCompactionForVersionedCollection(ctx, flushCollectionCompaction)\n \t}\n+\tcollectionID := types.FromUniqueID(flushCollectionCompaction.ID)\n \n \tflushCollectionInfo := &model.FlushCollectionInfo{\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n \terr := tc.txImpl.Transaction(ctx, func(txCtx context.Context) error {\n \t\t// Check if collection exists.\n-\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(types.FromUniqueID(flushCollectionCompaction.ID), nil, nil)\n+\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(collectionID, nil, nil)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1589,6 +1590,7 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \t\t// return nil will commit the transaction\n \t\treturn nil\n \t})\n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", *collectionID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1641,6 +1643,8 @@ func (tc *Catalog) FlushCollectionCompactionForVersionedCollection(ctx context.C\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", flushCollectionInfo.ID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n+\n \t// Do the operation in a loop until the CollectionEntry is updated,\n \t// \t\tOR FAIL the operation if the version is stale\n \t//      OR other DB error.\n---\nrust/log-service/src/lib.rs\n@@ -1080,6 +1080,9 @@ impl LogService for LogServer {\n                     });\n                 }\n             }\n+            if !records.is_empty() && records[0].log_offset != pull_logs.start_from_offset {\n+                return Err(Status::not_found(\"Some entries have been purged\"));\n+            }\n             tracing::info!(\"pulled {} records\", records.len());\n             Ok(Response::new(PullLogsResponse { records }))\n         }\n---\n\n\n---\n\nChoice D:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb-core/src/embeddings/DefaultEmbeddingFunction.ts\n@@ -6,7 +6,7 @@ import { IEmbeddingFunction } from \"./IEmbeddingFunction\";\n let TransformersApi: Promise<any>;\n \n interface StoredConfig {\n-  model_name: string;\n+  model: string;\n   revision: string;\n   quantized: boolean;\n }\n@@ -77,24 +77,24 @@ export class DefaultEmbeddingFunction implements IEmbeddingFunction {\n \n   getConfig(): StoredConfig {\n     return {\n-      model_name: this.model,\n+      model: this.model,\n       revision: this.revision,\n       quantized: this.quantized,\n     };\n   }\n \n   buildFromConfig(config: StoredConfig): DefaultEmbeddingFunction {\n     return new DefaultEmbeddingFunction({\n-      model: config.model_name,\n+      model: config.model,\n       revision: config.revision,\n       quantized: config.quantized,\n     });\n   }\n \n   validateConfigUpdate(oldConfig: StoredConfig, newConfig: StoredConfig): void {\n-    if (oldConfig.model_name !== newConfig.model_name) {\n+    if (oldConfig.model !== newConfig.model) {\n       throw new Error(\n-        \"DefaultEmbeddingFunction model_name cannot be changed after initialization.\",\n+        \"DefaultEmbeddingFunction model cannot be changed after initialization.\",\n       );\n     }\n   }\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis exposes `seal` and `migrate` to work the way they're expected/intended:\n- seal always goes to the classic/go log service\n- migrate always goes to the rust log service\n\n## Test plan\n\nCI + nextest run\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -830,12 +836,15 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -1219,17 +1219,16 @@ impl LogService for LogServer {\n             let witness = cursors.load(cursor_name).await.map_err(|err| {\n                 Status::new(err.code().into(), format!(\"Failed to load cursor: {}\", err))\n             })?;\n-            // This is the existing compaction_offset, which is the last record that was compacted.\n+            // This is the existing compaction_offset, which is the next record to compact.\n             let offset = witness\n                 .map(|x| x.1.position)\n-                .unwrap_or(LogPosition::from_offset(0));\n+                .unwrap_or(LogPosition::from_offset(1));\n             tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n                 &log_reader,\n-                // + 1 to get to the first uncompacted record.\n-                offset + 1u64,\n+                offset,\n                 target_prefix.clone(),\n             )\n             .await\n@@ -1253,7 +1252,9 @@ impl LogService for LogServer {\n             }\n             tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n-                compaction_offset: offset.offset(),\n+                // NOTE: The upstream service expects the last compacted offset as compaction offset\n+                compaction_offset: (offset - 1u64).offset(),\n+                // NOTE: The upstream service expects the last uncompacted offset as enumeration offset\n                 enumeration_offset: (max_offset - 1u64).offset(),\n             }))\n         }\n---\n\n\n---\n\nChoice C:\nTiltfile\n@@ -92,7 +92,7 @@ else:\n   docker_build(\n     'frontend-service',\n     '.',\n-    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/'],\n+    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/', 'Cargo.toml', 'Cargo.lock', 'rust/', 'pyproject.toml', 'README.md'],\n     dockerfile='./Dockerfile',\n     ignore=['**/*.pyc', 'chromadb/test/'],\n   )\n---\n\n\n---\n\nChoice D:\nrust/log/src/grpc_log.rs\n@@ -165,6 +165,26 @@ impl ChromaError for GrpcSealLogError {\n     }\n }\n \n+#[derive(Error, Debug)]\n+pub enum GrpcMigrateLogError {\n+    #[error(\"Failed to migrate collection: {0}\")]\n+    FailedToMigrate(#[from] tonic::Status),\n+    #[error(transparent)]\n+    ClientAssignerError(#[from] ClientAssignmentError),\n+    #[error(\"not supported by this service\")]\n+    NotSupported,\n+}\n+\n+impl ChromaError for GrpcMigrateLogError {\n+    fn code(&self) -> ErrorCodes {\n+        match self {\n+            GrpcMigrateLogError::FailedToMigrate(status) => status.code().into(),\n+            GrpcMigrateLogError::ClientAssignerError(e) => e.code(),\n+            GrpcMigrateLogError::NotSupported => ErrorCodes::Unimplemented,\n+        }\n+    }\n+}\n+\n type LogClient = LogServiceClient<chroma_tracing::GrpcTraceService<tonic::transport::Channel>>;\n \n #[derive(Clone, Debug)]\n@@ -176,7 +196,7 @@ pub struct GrpcLog {\n \n impl GrpcLog {\n     #[allow(clippy::type_complexity)]\n-    pub(crate) fn new(\n+    pub fn new(\n         config: GrpcLogConfig,\n         client: LogClient,\n         alt_client_assigner: Option<ClientAssigner<LogClient>>,\n@@ -190,7 +210,7 @@ impl GrpcLog {\n }\n \n #[derive(Error, Debug)]\n-pub(crate) enum GrpcLogError {\n+pub enum GrpcLogError {\n     #[error(\"Failed to connect to log service\")]\n     FailedToConnect(#[from] tonic::transport::Error),\n }\n@@ -639,19 +659,43 @@ impl GrpcLog {\n         }\n     }\n \n-    pub(super) async fn seal_log(\n+    pub async fn seal_log(\n         &mut self,\n-        tenant: &str,\n         collection_id: CollectionUuid,\n     ) -> Result<(), GrpcSealLogError> {\n+        // NOTE(rescrv):  Seal log only goes to the go log service, so use the classic connection.\n         let _response = self\n-            .client_for(tenant, collection_id)?\n+            .client\n             .seal_log(chroma_proto::SealLogRequest {\n                 collection_id: collection_id.to_string(),\n             })\n             .await?;\n         Ok(())\n     }\n+\n+    pub async fn migrate_log(\n+        &mut self,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcMigrateLogError> {\n+        // NOTE(rescrv): Migrate log only goes to the rust log service, so use alt client assigner.\n+        if let Some(client_assigner) = self.alt_client_assigner.as_mut() {\n+            let mut client = client_assigner\n+                .clients(&collection_id.to_string())?\n+                .drain(..)\n+                .next()\n+                .ok_or(ClientAssignmentError::NoClientFound(\n+                    \"Impossible state: no client found for collection\".to_string(),\n+                ))?;\n+            client\n+                .migrate_log(chroma_proto::MigrateLogRequest {\n+                    collection_id: collection_id.to_string(),\n+                })\n+                .await?;\n+            Ok(())\n+        } else {\n+            Err(GrpcMigrateLogError::NotSupported)\n+        }\n+    }\n }\n \n #[cfg(test)]\n---\nrust/log/src/log.rs\n@@ -213,11 +213,11 @@ impl Log {\n \n     pub async fn seal_log(\n         &mut self,\n-        tenant: &str,\n+        _: &str,\n         collection_id: CollectionUuid,\n     ) -> Result<(), GrpcSealLogError> {\n         match self {\n-            Log::Grpc(log) => log.seal_log(tenant, collection_id).await,\n+            Log::Grpc(log) => log.seal_log(collection_id).await,\n             Log::Sqlite(_) => unimplemented!(),\n             Log::InMemory(_) => unimplemented!(),\n         }\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - ...\r\n- New functionality\r\n  - ...\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js,\r\n`cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need\r\nto make documentation changes in the [docs\r\nsection](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -551,8 +551,9 @@ func (s *collectionDb) LockCollection(collectionID string) (*bool, error) {\n }\n \n func (s *collectionDb) UpdateCollectionLineageFilePath(collectionID string, currentLineageFileName *string, newLineageFileName string) error {\n+\t// TODO(@codetheweb): should error if no rows affected\n \treturn s.db.Model(&dbmodel.Collection{}).\n-\t\tWhere(\"id = ? AND (lineage_file_name IS NULL OR lineage_file_name = ?)\", collectionID, currentLineageFileName).\n+\t\tWhere(\"id = ? AND (lineage_file_name IS NULL OR lineage_file_name = '' OR lineage_file_name = ?)\", collectionID, currentLineageFileName).\n \t\tUpdates(map[string]interface{}{\n \t\t\t\"lineage_file_name\": newLineageFileName,\n \t\t}).Error\n---\n\n\n---\n\nChoice B:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.9\"\n+__version__ = \"1.0.10\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.8\"\n+      \"Default\": \"1.0.10\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.8\"\n+chroma_version                  = \"1.0.10\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.8\"\n+  default     = \"1.0.10\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.8\"\n+chroma_version                  = \"1.0.10\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.8\"\n+  default     = \"1.0.10\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionWithoutMetadata(collectionID *string, databaseName *string, softDeletedFlag *bool) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, NULLIF(collections.root_collection_id, '') AS root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\nChoice D:\nrust/frontend/src/auth/mod.rs\n@@ -70,12 +70,40 @@ pub struct AuthzResource {\n }\n \n #[derive(thiserror::Error, Debug)]\n-#[error(\"Permission denied.\")]\n-pub struct AuthError(pub StatusCode);\n+pub struct AuthError {\n+    pub status_code: StatusCode,\n+    pub message: Option<String>,\n+}\n+\n+impl Display for AuthError {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(\n+            f,\n+            \"{}\",\n+            self.message.as_deref().unwrap_or(\"Permission denied.\")\n+        )\n+    }\n+}\n+\n+impl AuthError {\n+    pub fn new(status_code: StatusCode) -> Self {\n+        Self {\n+            status_code,\n+            message: None,\n+        }\n+    }\n+\n+    pub fn with_message(status_code: StatusCode, message: impl Into<String>) -> Self {\n+        Self {\n+            status_code,\n+            message: Some(message.into()),\n+        }\n+    }\n+}\n \n impl chroma_error::ChromaError for AuthError {\n     fn code(&self) -> chroma_error::ErrorCodes {\n-        match self.0 {\n+        match self.status_code {\n             StatusCode::UNAUTHORIZED => chroma_error::ErrorCodes::Unauthenticated,\n             StatusCode::FORBIDDEN => chroma_error::ErrorCodes::PermissionDenied,\n             _ => chroma_error::ErrorCodes::Internal,\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -235,6 +235,22 @@ impl ServiceBasedFrontend {\n         }\n     }\n \n+    fn _parse_universal_collection_identifier(input: String) -> Option<(String, String, String)> {\n+        let parts: Vec<&str> = input.split('/').collect();\n+        match parts.as_slice() {\n+            [tenant, database, collection]\n+                if !tenant.is_empty() && !database.is_empty() && !collection.is_empty() =>\n+            {\n+                Some((\n+                    tenant.to_string(),\n+                    database.to_string(),\n+                    collection.to_string(),\n+                ))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub async fn reset(&mut self) -> Result<ResetResponse, ResetError> {\n         if !self.allow_reset {\n             return Err(ResetError::NotAllowed);\n@@ -362,12 +378,19 @@ impl ServiceBasedFrontend {\n             ..\n         }: GetCollectionRequest,\n     ) -> Result<GetCollectionResponse, GetCollectionError> {\n+        let (resolved_tenant_id, resolved_database_name, resolved_collection_name) =\n+            Self::_parse_universal_collection_identifier(collection_name.clone()).unwrap_or((\n+                tenant_id.clone(),\n+                database_name.clone(),\n+                collection_name.clone(),\n+            ));\n+\n         let mut collections = self\n             .sysdb_client\n             .get_collections(GetCollectionsOptions {\n-                name: Some(collection_name.clone()),\n-                tenant: Some(tenant_id.clone()),\n-                database: Some(database_name.clone()),\n+                name: Some(resolved_collection_name.clone()),\n+                tenant: Some(resolved_tenant_id.clone()),\n+                database: Some(resolved_database_name.clone()),\n                 limit: Some(1),\n                 ..Default::default()\n             })\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis PR cherry-picks the commit a6f30a387fb27cb91823a8c61f78fab9d9861841 onto release/2025-05-23. If there are unresolved conflicts, please resolve them manually.\n\n---\n\nChoice A:\n.github/actions/docker/action.yaml\n@@ -17,6 +17,11 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n+    # https://github.com/docker/setup-qemu-action - for multiplatform builds\n+    - name: Set up QEMU\n+      uses: docker/setup-qemu-action@v2\n+    - name: Set up Docker Buildx\n+      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n.github/workflows/_build_release_container.yml\n@@ -33,106 +33,43 @@ permissions:\n env:\n   GHCR_IMAGE_NAME: \"ghcr.io/chroma-core/chroma\"\n   DOCKERHUB_IMAGE_NAME: \"chromadb/chroma\"\n+  PLATFORMS: linux/amd64,linux/arm64 #linux/riscv64, linux/arm/v7\n \n jobs:\n   build:\n-    name: Build image for ${{ matrix.platform }}\n+    name: Build and publish container image\n     runs-on: blacksmith-16vcpu-ubuntu-2204\n-    strategy:\n-      matrix:\n-        platform: [amd64, arm64]\n-        include:\n-          - platform: amd64\n-            runner: blacksmith-16vcpu-ubuntu-2204\n-            docker_platform: linux/amd64\n-          - platform: arm64\n-            runner: blacksmith-16vcpu-ubuntu-2204-arm\n-            docker_platform: linux/arm64\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n         with:\n           fetch-depth: 0\n-\n       - name: Set up Docker\n         uses: ./.github/actions/docker\n         with:\n           ghcr-username: ${{ github.actor }}\n           ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n           dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-\n-      - name: Compute arch-specific tags\n-        id: tags\n+      - name: Compute tags\n         shell: bash\n+        id: compute_tags\n         run: |\n-          arch_tag=\"${{ inputs.tag }}-${{ matrix.platform }}\"\n-          ghcr=\"${{ env.GHCR_IMAGE_NAME }}:${arch_tag}\"\n-          dhub=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${arch_tag}\"\n-          echo \"arch_tag=$arch_tag\"      >> $GITHUB_OUTPUT\n-\n-          # expose *matrix-unique* step outputs\n-          echo \"ghcr_tag_${{ matrix.platform }}=$ghcr\"         >> $GITHUB_OUTPUT\n-          echo \"dockerhub_tag_${{ matrix.platform }}=$dhub\"    >> $GITHUB_OUTPUT\n+          tags=\"${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }},${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\"\n+          if [ \"${{ inputs.tag_as_latest }}\" = \"true\" ]; then\n+            tags=\"${tags},${{ env.GHCR_IMAGE_NAME }}:latest,${{ env.DOCKERHUB_IMAGE_NAME }}:latest\"\n+          fi\n \n-          # these two tags are what the build-push action will publish for *this* arch\n-          echo \"tags=$ghcr,$dhub\" >> $GITHUB_OUTPUT\n+          echo \"tags=${tags}\" >> $GITHUB_OUTPUT\n \n       - name: Build and push image\n         uses: useblacksmith/build-push-action@v1.1\n         with:\n           context: .\n           file: rust/Dockerfile\n           target: cli\n-          platforms: ${{ matrix.docker_platform }}\n+          platforms: ${{ env.PLATFORMS }}\n           push: true\n           build-args: |\n             RELEASE_MODE=1\n-          tags: ${{ steps.tags.outputs.tags }}\n-    outputs:\n-      ghcr_tag_amd64:      ${{ steps.tags.outputs.ghcr_tag_amd64 }}\n-      ghcr_tag_arm64:      ${{ steps.tags.outputs.ghcr_tag_arm64 }}\n-      dockerhub_tag_amd64: ${{ steps.tags.outputs.dockerhub_tag_amd64 }}\n-      dockerhub_tag_arm64: ${{ steps.tags.outputs.dockerhub_tag_arm64 }}\n-\n-  merge:\n-    name: Merge platform manifests\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n-    needs:\n-      - build\n-    steps:\n-      - name: Set up Docker\n-        uses: ./.github/actions/docker\n-        with:\n-          ghcr-username: ${{ github.actor }}\n-          ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n-          dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n-          dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-\n-      - name: Create and push manifest\n-        shell: bash\n-        run: |\n-          set -euo pipefail\n-\n-          # Pull the per-arch tags from job-level outputs\n-          ghcr_amd64='${{ needs.build.outputs.ghcr_tag_amd64 }}'\n-          ghcr_arm64='${{ needs.build.outputs.ghcr_tag_arm64 }}'\n-          dhub_amd64='${{ needs.build.outputs.dockerhub_tag_amd64 }}'\n-          dhub_arm64='${{ needs.build.outputs.dockerhub_tag_arm64 }}'\n-\n-          base_tag='${{ inputs.tag }}'\n-          ghcr_base=\"${{ env.GHCR_IMAGE_NAME }}:${base_tag}\"\n-          dhub_base=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${base_tag}\"\n-\n-          docker buildx imagetools create --tag \"$ghcr_base\" $ghcr_amd64 $ghcr_arm64\n-          docker buildx imagetools create --tag \"$dhub_base\"  $dhub_amd64 $dhub_arm64\n-\n-          if [[ \"${{ inputs.tag_as_latest }}\" == \"true\" ]]; then\n-            docker buildx imagetools create --tag \"${{ env.GHCR_IMAGE_NAME }}:latest\"  $ghcr_amd64 $ghcr_arm64\n-            docker buildx imagetools create --tag \"${{ env.DOCKERHUB_IMAGE_NAME }}:latest\" $dhub_amd64 $dhub_arm64\n-          fi\n-\n-      - name: Inspect image\n-        run: |\n-          docker buildx imagetools inspect ${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }}\n-          docker buildx imagetools inspect ${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\n+          tags: ${{ steps.compute_tags.outputs.tags }}\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/server/server.go\n@@ -162,6 +162,15 @@ func (s *logServer) InspectDirtyLog(ctx context.Context, req *logservicepb.Inspe\n \treturn\n }\n \n+func (s *logServer) SealLog(ctx context.Context, req *logservicepb.SealLogRequest) (res *logservicepb.SealLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n+\n+func (s *logServer) MigrateLog(ctx context.Context, req *logservicepb.MigrateLogRequest) (res *logservicepb.MigrateLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n \n func NewLogServer(lr *repository.LogRepository) logservicepb.LogServiceServer {\n \treturn &logServer{\n---\nidl/chromadb/proto/logservice.proto\n@@ -96,6 +96,22 @@ message InspectDirtyLogResponse {\n   repeated string markers = 1;\n }\n \n+message SealLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message SealLogResponse {\n+  // Empty\n+}\n+\n+message MigrateLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message MigrateLogResponse {\n+  // Empty\n+}\n+\n service LogService {\n   rpc PushLogs(PushLogsRequest) returns (PushLogsResponse) {}\n   rpc ScoutLogs(ScoutLogsRequest) returns (ScoutLogsResponse) {}\n@@ -104,5 +120,11 @@ service LogService {\n   rpc GetAllCollectionInfoToCompact(GetAllCollectionInfoToCompactRequest) returns (GetAllCollectionInfoToCompactResponse) {}\n   rpc UpdateCollectionLogOffset(UpdateCollectionLogOffsetRequest) returns (UpdateCollectionLogOffsetResponse) {}\n   rpc PurgeDirtyForCollection(PurgeDirtyForCollectionRequest) returns (PurgeDirtyForCollectionResponse) {}\n+  // RPC endpoints to expose for operator debuggability.\n+  // This endpoint must route to the rust log service.\n   rpc InspectDirtyLog(InspectDirtyLogRequest) returns (InspectDirtyLogResponse) {}\n+  // This endpoint must route to the go log service.\n+  rpc SealLog(SealLogRequest) returns (SealLogResponse) {}\n+  // This endpoint must route to the rust log service.\n+  rpc MigrateLog(MigrateLogRequest) returns (MigrateLogResponse) {}\n }\n---\nrust/log-service/src/lib.rs\n@@ -16,9 +16,10 @@ use chroma_storage::Storage;\n use chroma_types::chroma_proto::{\n     log_service_server::LogService, CollectionInfo, GetAllCollectionInfoToCompactRequest,\n     GetAllCollectionInfoToCompactResponse, InspectDirtyLogRequest, InspectDirtyLogResponse,\n-    LogRecord, OperationRecord, PullLogsRequest, PullLogsResponse, PurgeDirtyForCollectionRequest,\n-    PurgeDirtyForCollectionResponse, PushLogsRequest, PushLogsResponse, ScoutLogsRequest,\n-    ScoutLogsResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n+    LogRecord, MigrateLogRequest, MigrateLogResponse, OperationRecord, PullLogsRequest,\n+    PullLogsResponse, PurgeDirtyForCollectionRequest, PurgeDirtyForCollectionResponse,\n+    PushLogsRequest, PushLogsResponse, ScoutLogsRequest, ScoutLogsResponse, SealLogRequest,\n+    SealLogResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n };\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n@@ -1230,6 +1231,24 @@ impl LogService for LogServer {\n         }\n         Ok(Response::new(InspectDirtyLogResponse { markers }))\n     }\n+\n+    async fn seal_log(\n+        &self,\n+        _request: Request<SealLogRequest>,\n+    ) -> Result<Response<SealLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do sealing\",\n+        ))\n+    }\n+\n+    async fn migrate_log(\n+        &self,\n+        _request: Request<MigrateLogRequest>,\n+    ) -> Result<Response<MigrateLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do migrating yet\",\n+        ))\n+    }\n }\n \n fn parquet_to_records(parquet: Arc<Vec<u8>>) -> Result<Vec<(LogPosition, Vec<u8>)>, Status> {\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionWithoutMetadata(collectionID *string, databaseName *string, softDeletedFlag *bool) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, NULLIF(collections.root_collection_id, '') AS root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\nChoice D:\nTiltfile\n@@ -92,7 +92,7 @@ else:\n   docker_build(\n     'frontend-service',\n     '.',\n-    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/'],\n+    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/', 'Cargo.toml', 'Cargo.lock', 'rust/', 'pyproject.toml', 'README.md'],\n     dockerfile='./Dockerfile',\n     ignore=['**/*.pyc', 'chromadb/test/'],\n   )\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nSome rows in our database have `root_collection_id: \"\"` instead of having it set to null. We're not sure why this happened, this is a quick patch as a short-term fix while we continue to investigate.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nchromadb/test/distributed/test_log_failover.py\n@@ -189,3 +189,99 @@ def test_log_failover_with_compaction(\n             assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n         else:\n             assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_query_operations(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    # Add initial RECORDS records with known embeddings for querying\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Perform baseline similarity queries before failover\n+    query_embeddings = [embeddings[0], embeddings[RECORDS//2], embeddings[-1]]\n+    baseline_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        baseline_results.append(result)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Trigger log failover\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Re-run the same queries after failover and verify results consistency\n+    post_failover_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        post_failover_results.append(result)\n+\n+    # Verify that query results are consistent before and after failover\n+    for i, (baseline, post_failover) in enumerate(zip(baseline_results, post_failover_results)):\n+        assert len(baseline[\"ids\"][0]) == len(post_failover[\"ids\"][0]), f\"Query {i} returned different number of results\"\n+        assert baseline[\"ids\"][0] == post_failover[\"ids\"][0], f\"Query {i} returned different IDs\"\n+        # Verify embeddings match (allowing for small floating point differences)\n+        for j, (base_emb, post_emb) in enumerate(zip(baseline[\"embeddings\"][0], post_failover[\"embeddings\"][0])):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(base_emb, post_emb)]), f\"Query {i} result {j} embeddings differ\"\n+\n+    # Add more data post-failover\n+    post_failover_start = RECORDS\n+    for i in range(post_failover_start, post_failover_start + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Query for both old and new data to ensure full functionality\n+    # Test that we can find old data\n+    old_data_query = collection.query(\n+        query_embeddings=[embeddings[0]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(old_data_query[\"ids\"][0]) == 3, \"Failed to query old data after failover\"\n+\n+    # Test that we can find new data\n+    new_data_query = collection.query(\n+        query_embeddings=[embeddings[-1]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(new_data_query[\"ids\"][0]) == 3, \"Failed to query new data after failover\"\n+\n+    # Verify all data is still accessible by ID\n+    for i in range(len(ids)):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        assert len(result[\"embeddings\"]) > 0, f\"Missing result for ID {i} after failover with new data\"\n+        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])]), f\"Embedding mismatch for ID {i}\"\n---\n\n\n---\n\nChoice B:\nchromadb/test/property/test_filtering.py\n@@ -20,7 +20,6 @@\n import chromadb.test.property.strategies as strategies\n import hypothesis.strategies as st\n import logging\n-import re\n from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n import numpy as np\n \n@@ -95,20 +94,10 @@ def _filter_where_doc_clause(clause: WhereDocument, doc: Document) -> bool:\n     if key == \"$contains\":\n         if not doc:\n             return False\n-        # SQLite FTS handles % and _ as word boundaries that are ignored so we need to\n-        # treat them as wildcards\n-        if \"%\" in expr or \"_\" in expr:\n-            expr = expr.replace(\"%\", \".\").replace(\"_\", \".\")\n-            return re.search(expr, doc) is not None\n         return expr in doc\n     elif key == \"$not_contains\":\n         if not doc:\n             return True\n-        # SQLite FTS handles % and _ as word boundaries that are ignored so we need to\n-        # treat them as wildcards\n-        if \"%\" in expr or \"_\" in expr:\n-            expr = expr.replace(\"%\", \".\").replace(\"_\", \".\")\n-            return re.search(expr, doc) is None\n         return expr not in doc\n     else:\n         raise ValueError(\"Unknown operator: {}\".format(key))\n---\n\n\n---\n\nChoice C:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -835,7 +841,10 @@ impl DataSet for ReferencingDataSet {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionWithoutMetadata(collectionID *string, databaseName *string, softDeletedFlag *bool) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, NULLIF(collections.root_collection_id, '') AS root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nAdds a readiness probe for GC.\n\n## Test plan\n\n_How are these changes tested?_\n\nVerified that the service was marked ready using kubectl.\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\nn/a\n\n\n---\n\nChoice A:\nrust/log/src/grpc_log.rs\n@@ -165,6 +165,26 @@ impl ChromaError for GrpcSealLogError {\n     }\n }\n \n+#[derive(Error, Debug)]\n+pub enum GrpcMigrateLogError {\n+    #[error(\"Failed to migrate collection: {0}\")]\n+    FailedToMigrate(#[from] tonic::Status),\n+    #[error(transparent)]\n+    ClientAssignerError(#[from] ClientAssignmentError),\n+    #[error(\"not supported by this service\")]\n+    NotSupported,\n+}\n+\n+impl ChromaError for GrpcMigrateLogError {\n+    fn code(&self) -> ErrorCodes {\n+        match self {\n+            GrpcMigrateLogError::FailedToMigrate(status) => status.code().into(),\n+            GrpcMigrateLogError::ClientAssignerError(e) => e.code(),\n+            GrpcMigrateLogError::NotSupported => ErrorCodes::Unimplemented,\n+        }\n+    }\n+}\n+\n type LogClient = LogServiceClient<chroma_tracing::GrpcTraceService<tonic::transport::Channel>>;\n \n #[derive(Clone, Debug)]\n@@ -176,7 +196,7 @@ pub struct GrpcLog {\n \n impl GrpcLog {\n     #[allow(clippy::type_complexity)]\n-    pub(crate) fn new(\n+    pub fn new(\n         config: GrpcLogConfig,\n         client: LogClient,\n         alt_client_assigner: Option<ClientAssigner<LogClient>>,\n@@ -190,7 +210,7 @@ impl GrpcLog {\n }\n \n #[derive(Error, Debug)]\n-pub(crate) enum GrpcLogError {\n+pub enum GrpcLogError {\n     #[error(\"Failed to connect to log service\")]\n     FailedToConnect(#[from] tonic::transport::Error),\n }\n@@ -639,19 +659,43 @@ impl GrpcLog {\n         }\n     }\n \n-    pub(super) async fn seal_log(\n+    pub async fn seal_log(\n         &mut self,\n-        tenant: &str,\n         collection_id: CollectionUuid,\n     ) -> Result<(), GrpcSealLogError> {\n+        // NOTE(rescrv):  Seal log only goes to the go log service, so use the classic connection.\n         let _response = self\n-            .client_for(tenant, collection_id)?\n+            .client\n             .seal_log(chroma_proto::SealLogRequest {\n                 collection_id: collection_id.to_string(),\n             })\n             .await?;\n         Ok(())\n     }\n+\n+    pub async fn migrate_log(\n+        &mut self,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcMigrateLogError> {\n+        // NOTE(rescrv): Migrate log only goes to the rust log service, so use alt client assigner.\n+        if let Some(client_assigner) = self.alt_client_assigner.as_mut() {\n+            let mut client = client_assigner\n+                .clients(&collection_id.to_string())?\n+                .drain(..)\n+                .next()\n+                .ok_or(ClientAssignmentError::NoClientFound(\n+                    \"Impossible state: no client found for collection\".to_string(),\n+                ))?;\n+            client\n+                .migrate_log(chroma_proto::MigrateLogRequest {\n+                    collection_id: collection_id.to_string(),\n+                })\n+                .await?;\n+            Ok(())\n+        } else {\n+            Err(GrpcMigrateLogError::NotSupported)\n+        }\n+    }\n }\n \n #[cfg(test)]\n---\nrust/log/src/log.rs\n@@ -213,11 +213,11 @@ impl Log {\n \n     pub async fn seal_log(\n         &mut self,\n-        tenant: &str,\n+        _: &str,\n         collection_id: CollectionUuid,\n     ) -> Result<(), GrpcSealLogError> {\n         match self {\n-            Log::Grpc(log) => log.seal_log(tenant, collection_id).await,\n+            Log::Grpc(log) => log.seal_log(collection_id).await,\n             Log::Sqlite(_) => unimplemented!(),\n             Log::InMemory(_) => unimplemented!(),\n         }\n---\n\n\n---\n\nChoice B:\nCargo.lock\n@@ -3340,6 +3340,7 @@ dependencies = [\n  \"tokio\",\n  \"tokio-test\",\n  \"tonic\",\n+ \"tonic-health\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-test\",\n---\nidl/chromadb/proto/garbage_collector.proto\n@@ -0,0 +1,6 @@\n+syntax = \"proto3\";\n+\n+package chroma;\n+\n+// This is a placeholder service. The garbage collector currently only exposes a health service.\n+service GarbageCollector {}\n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.43\n+version: 0.1.44\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/garbage-collector.yaml\n@@ -40,6 +40,9 @@ spec:\n       - name: garbage-collector\n         image: \"{{ .Values.garbageCollector.image.repository }}:{{ .Values.garbageCollector.image.tag }}\"\n         imagePullPolicy: IfNotPresent\n+        readinessProbe:\n+          grpc:\n+            port: 50055\n         {{ if .Values.garbageCollector.resources }}\n         resources:\n           limits:\n---\nrust/garbage_collector/Cargo.toml\n@@ -27,6 +27,7 @@ tokio = { workspace = true }\n uuid = { workspace = true }\n futures = { workspace = true }\n tonic = { workspace = true }\n+tonic-health = { workspace = true }\n tempfile = { workspace = true }\n tracing = { workspace = true }\n thiserror = { workspace = true }\n---\nrust/garbage_collector/src/config.rs\n@@ -38,6 +38,8 @@ pub(super) struct GarbageCollectorConfig {\n     pub(super) assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig,\n     pub(super) memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig,\n     pub my_member_id: String,\n+    #[serde(default = \"GarbageCollectorConfig::default_port\")]\n+    pub port: u16,\n }\n \n impl GarbageCollectorConfig {\n@@ -61,6 +63,10 @@ impl GarbageCollectorConfig {\n             Err(e) => panic!(\"Error loading config: {}\", e),\n         }\n     }\n+\n+    fn default_port() -> u16 {\n+        50055\n+    }\n }\n \n #[cfg(test)]\n---\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -633,6 +633,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n@@ -753,6 +754,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n---\nrust/garbage_collector/src/lib.rs\n@@ -6,9 +6,11 @@ use chroma_tracing::{\n     init_global_filter_layer, init_otel_layer, init_panic_tracing_hook, init_stdout_layer,\n     init_tracing,\n };\n+use chroma_types::chroma_proto::garbage_collector_server::GarbageCollectorServer;\n use config::GarbageCollectorConfig;\n use garbage_collector_component::GarbageCollector;\n use tokio::signal::unix::{signal, SignalKind};\n+use tonic::transport::Server;\n use tracing::{debug, error, info};\n \n mod config;\n@@ -24,7 +26,20 @@ pub mod types;\n \n const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n \n+// This is a placeholder service so that we can expose a health service\n+struct GarbageCollectorService {}\n+\n+impl chroma_types::chroma_proto::garbage_collector_server::GarbageCollector\n+    for GarbageCollectorService\n+{\n+}\n+\n pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::error::Error>> {\n+    let (mut health_reporter, health_service) = tonic_health::server::health_reporter();\n+    health_reporter\n+        .set_not_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     debug!(\"Loading configuration from environment\");\n     // Parse configuration. Configuration includes sysdb connection details, and\n     // gc run details amongst others.\n@@ -49,6 +64,27 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n \n     info!(\"Loaded configuration successfully: {:#?}\", config);\n \n+    let addr = format!(\"[::]:{}\", config.port)\n+        .parse()\n+        .expect(\"Invalid address format\");\n+    let server_join_handle = tokio::spawn(async move {\n+        let server = Server::builder().add_service(health_service);\n+        server\n+            .serve_with_shutdown(addr, async {\n+                match signal(SignalKind::terminate()) {\n+                    Ok(mut sigterm) => {\n+                        sigterm.recv().await;\n+                        tracing::info!(\"Received SIGTERM, shutting down gRPC server\");\n+                    }\n+                    Err(err) => {\n+                        tracing::error!(\"Failed to create SIGTERM handler: {err}\")\n+                    }\n+                }\n+            })\n+            .await\n+            .expect(\"Failed to start gRPC server\");\n+    });\n+\n     let registry = chroma_config::registry::Registry::new();\n     let system = System::new();\n \n@@ -79,6 +115,10 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n     memberlist.subscribe(garbage_collector_handle.receiver());\n     let mut memberlist_handle = system.start_component(memberlist);\n \n+    health_reporter\n+        .set_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     // Keep the service running and handle shutdown signals\n     let mut sigterm = signal(SignalKind::terminate())?;\n     let mut sigint = signal(SignalKind::interrupt())?;\n@@ -112,6 +152,7 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n         .expect(\"Dispatcher should be stoppable\");\n     system.stop().await;\n     system.join().await;\n+    let _ = server_join_handle.await;\n \n     info!(\"Shutting down garbage collector service\");\n     Ok(())\n---\nrust/types/build.rs\n@@ -6,6 +6,7 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n         \"idl/chromadb/proto/coordinator.proto\",\n         \"idl/chromadb/proto/logservice.proto\",\n         \"idl/chromadb/proto/query_executor.proto\",\n+        \"idl/chromadb/proto/garbage_collector.proto\",\n     ];\n \n     // Can't use #[cfg(test)] here because a build for tests is technically a regular debug build, meaning that #[cfg(test)] is useless in build.rs.\n---\nrust/types/src/lib.rs\n@@ -47,6 +47,7 @@ pub use tenant::*;\n pub use types::*;\n pub use where_parsing::*;\n \n+#[allow(clippy::all)]\n pub mod chroma_proto {\n     tonic::include_proto!(\"chroma\");\n }\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionWithoutMetadata(collectionID *string, databaseName *string, softDeletedFlag *bool) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, NULLIF(collections.root_collection_id, '') AS root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\nChoice D:\nrust/types/src/api_types.rs\n@@ -82,7 +82,7 @@ impl ChromaError for GetCollectionWithSegmentsError {\n             GetCollectionWithSegmentsError::CollectionConversionError(\n                 collection_conversion_error,\n             ) => collection_conversion_error.code(),\n-            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::Internal,\n             GetCollectionWithSegmentsError::Field(_) => ErrorCodes::FailedPrecondition,\n             GetCollectionWithSegmentsError::SegmentConversionError(segment_conversion_error) => {\n                 segment_conversion_error.code()\n@@ -832,7 +832,7 @@ impl ChromaError for ForkCollectionError {\n             ForkCollectionError::CollectionConversionError(collection_conversion_error) => {\n                 collection_conversion_error.code()\n             }\n-            ForkCollectionError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            ForkCollectionError::DuplicateSegment => ErrorCodes::Internal,\n             ForkCollectionError::Field(_) => ErrorCodes::FailedPrecondition,\n             ForkCollectionError::Local => ErrorCodes::Unimplemented,\n             ForkCollectionError::Internal(chroma_error) => chroma_error.code(),\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nIntroduces a type module for serializing and deserializing optional u128. Serde doesn't natively support serializing and deserializing 128-bit integers because the maximum integer size in JSON is a 64-bit integer. This module solves this problem by serializing 128-bit integers into their hex string equivalents.\r\n\r\n## Test plan\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\nN/A\n\n---\n\nChoice A:\n.github/workflows/_python-tests.yml\n@@ -291,7 +291,7 @@ jobs:\n         api_key: ${{ secrets.DD_API_KEY }}\n         site: ${{ vars.DD_SITE }}\n     - name: Integration Test\n-      run: bin/python-integration-test ${{ matrix.test-globs }}\n+      run: python -m pytest ${{ matrix.test-globs }}\n       shell: bash\n       env:\n         ENV_FILE: ${{ matrix.env-file }}\n---\nchromadb/test/test_cli.py\n@@ -1,6 +1,5 @@\n import multiprocessing\n import multiprocessing.context\n-import os\n import sys\n import time\n from multiprocessing.synchronize import Event\n@@ -10,7 +9,6 @@\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,6 +17,36 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+        host: str, port: int,\n+    max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            client = chromadb.HttpClient(host=host, port=port)\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            print(\"Heartbeat failed, trying again...\")\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n@@ -32,14 +60,10 @@ def test_app() -> None:\n     server_process.start()\n     time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    assert wait_for_server(host=\"localhost\", port=8001), \"Server failed to start within maximum retry attempts\"\n \n-    client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -124,7 +148,7 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\", \"--timeout\", \"10\"]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\nrust/cli/src/commands/vacuum.rs\n@@ -20,8 +20,10 @@ use sqlx::Row;\n use std::error::Error;\n use std::path::Path;\n use std::str::FromStr;\n+use std::time::Duration;\n use std::{fs, io};\n use thiserror::Error;\n+use tokio::time::timeout;\n \n #[derive(Debug, Error)]\n pub enum VacuumError {\n@@ -43,6 +45,8 @@ pub struct VacuumArgs {\n     path: Option<String>,\n     #[clap(long, default_value_t = false, help = \"Skip vacuum confirmation\")]\n     force: bool,\n+    #[clap(long, help = \"Maximum time (in seconds) to wait for vacuum\")]\n+    timeout: Option<u64>,\n }\n \n fn sizeof_fmt(num: u64, suffix: Option<&str>) -> String {\n@@ -195,10 +199,6 @@ pub async fn vacuum_chroma(config: FrontendConfig) -> Result<(), Box<dyn Error>>\n \n     println!(\"Vacuuming (this may take a while)...\\n\");\n \n-    sqlx::query(&format!(\"PRAGMA busy_timeout = {}\", 5000))\n-        .execute(sqlite.get_conn())\n-        .await?;\n-\n     sqlx::query(\"VACUUM\").execute(sqlite.get_conn()).await?;\n \n     sqlx::query(\n@@ -264,9 +264,19 @@ pub fn vacuum(args: VacuumArgs) -> Result<(), CliError> {\n     };\n \n     let runtime = tokio::runtime::Runtime::new().expect(\"Failed to start Chroma\");\n-    runtime\n-        .block_on(vacuum_chroma(config.frontend))\n-        .map_err(|_| VacuumError::VacuumFailed)?;\n+\n+    let res = if let Some(secs) = args.timeout {\n+        runtime.block_on(async {\n+            timeout(Duration::from_secs(secs), vacuum_chroma(config.frontend))\n+                .await\n+                .unwrap_or_else(|_elapsed| {\n+                    Err(Box::new(VacuumError::VacuumFailed) as Box<dyn std::error::Error>)\n+                })\n+        })\n+    } else {\n+        runtime.block_on(vacuum_chroma(config.frontend))\n+    };\n+    res.map_err(|_| VacuumError::VacuumFailed)?;\n \n     let post_vacuum_size =\n         get_dir_size(Path::new(&persistent_path)).map_err(|_| VacuumError::DirSizeFailed)?;\n---\n\n\n---\n\nChoice B:\nrust/load/src/bin/chroma-load-start.rs\n@@ -1,7 +1,10 @@\n //! Start a workload on the chroma-load server.\n \n+use std::sync::Arc;\n+\n use clap::Parser;\n \n+use chroma_load::data_sets::{all_data_sets, References};\n use chroma_load::rest::StartRequest;\n use chroma_load::{humanize_expires, Connection, Throughput, Workload};\n \n@@ -18,7 +21,13 @@ struct Args {\n     #[arg(long)]\n     workload: String,\n     #[arg(long)]\n-    data_set: String,\n+    data_set: Option<String>,\n+    #[arg(long)]\n+    references_data_set: Option<String>,\n+    #[arg(long)]\n+    operates_on_data_set: Option<String>,\n+    #[arg(long)]\n+    operates_on_cardinality: Option<usize>,\n     #[arg(long)]\n     url: String,\n     #[arg(long)]\n@@ -103,11 +112,47 @@ async fn main() {\n             wrap: Box::new(workload),\n         };\n     }\n+    let (data_set, custom_data_set) = match (\n+        args.data_set,\n+        args.references_data_set,\n+        args.operates_on_data_set,\n+        args.operates_on_cardinality,\n+    ) {\n+        (Some(data_set), None, None, None) => (Some(data_set.clone()), None),\n+        (None, Some(references), Some(operates_on), Some(cardinality)) => {\n+            let Some(referred_to) = all_data_sets()\n+                .iter()\n+                .find(|ds| ds.name() == references)\n+                .map(Arc::clone)\n+            else {\n+                eprintln!(\"Could not find a data set to reference named {references}\");\n+                std::process::exit(13);\n+            };\n+            let to_start = References {\n+                references: referred_to.json(),\n+                operates_on,\n+                cardinality,\n+            };\n+            let to_start = match serde_json::to_value(&to_start) {\n+                Ok(to_start) => to_start,\n+                Err(err) => {\n+                    eprintln!(\"could not serialize referencing data set: {err:?}\");\n+                    std::process::exit(13);\n+                }\n+            };\n+            (None, Some(to_start))\n+        }\n+        _ => {\n+            eprintln!(\"must provide data_set XOR (references_data_set, operates_on_data_set, operates_on_cardinality)\");\n+            std::process::exit(13);\n+        }\n+    };\n     let req = StartRequest {\n         name: args.name,\n         expires: humanize_expires(&args.expires).unwrap_or(args.expires),\n         workload,\n-        data_set: args.data_set,\n+        data_set,\n+        custom_data_set,\n         connection: Connection {\n             url: args.url,\n             api_key,\n---\nrust/load/src/data_sets.rs\n@@ -1496,9 +1496,9 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n \n #[derive(Clone, Debug, Default, serde::Deserialize, serde::Serialize)]\n pub struct References {\n-    references: serde_json::Value,\n-    operates_on: String,\n-    cardinality: usize,\n+    pub references: serde_json::Value,\n+    pub operates_on: String,\n+    pub cardinality: usize,\n }\n \n /// Get a data set from a particular JSON value.\n---\nrust/load/src/lib.rs\n@@ -1190,7 +1190,7 @@ impl LoadService {\n     pub fn start(\n         &self,\n         name: String,\n-        mut workload: Workload,\n+        workload: Workload,\n         data_set: String,\n         connection: Connection,\n         expires: chrono::DateTime<chrono::FixedOffset>,\n@@ -1199,14 +1199,28 @@ impl LoadService {\n         let Some(data_set) = self.data_sets().iter().find(|ds| ds.name() == data_set) else {\n             return Err(Error::NotFound(\"data set not found\".to_string()));\n         };\n+        let data_set = Arc::clone(data_set);\n+        self.start_struct(name, workload, data_set, connection, expires, throughput)\n+    }\n+\n+    /// Start a workload on the load service using structs rather than resolving strings.\n+    pub fn start_struct(\n+        &self,\n+        name: String,\n+        mut workload: Workload,\n+        data_set: Arc<dyn DataSet>,\n+        connection: Connection,\n+        expires: chrono::DateTime<chrono::FixedOffset>,\n+        throughput: Throughput,\n+    ) -> Result<Uuid, Error> {\n         workload.resolve_by_name(self.workloads())?;\n         let res = {\n             // SAFETY(rescrv):  Mutex poisoning.\n             let mut harness = self.harness.lock().unwrap();\n             Ok(harness.start(\n                 name,\n                 workload.clone(),\n-                data_set,\n+                &data_set,\n                 connection,\n                 expires,\n                 throughput,\n@@ -1625,15 +1639,41 @@ async fn start(\n ) -> Result<String, Error> {\n     let expires = chrono::DateTime::parse_from_rfc3339(&req.expires)\n         .map_err(|err| Error::InvalidRequest(format!(\"could not parse rfc3339: {err:?}\")))?;\n-    let uuid = state.load.start(\n-        req.name,\n-        req.workload,\n-        req.data_set,\n-        req.connection,\n-        expires,\n-        req.throughput,\n-    )?;\n-    Ok(uuid.to_string() + \"\\n\")\n+    match (req.data_set, req.custom_data_set) {\n+        (Some(_), Some(_)) => Err(Error::InvalidRequest(\n+            \"provide at most one of data_set and custom_data_set\".to_string(),\n+        )),\n+        (None, None) => Err(Error::InvalidRequest(\n+            \"provide at least one of data_set and custom_data_set\".to_string(),\n+        )),\n+        (Some(data_set), None) => {\n+            let uuid = state.load.start(\n+                req.name,\n+                req.workload,\n+                data_set,\n+                req.connection,\n+                expires,\n+                req.throughput,\n+            )?;\n+            Ok(uuid.to_string() + \"\\n\")\n+        }\n+        (None, Some(custom_data_set)) => {\n+            let Some(data_set) = data_sets::from_json(&custom_data_set) else {\n+                return Err(Error::InvalidRequest(\n+                    \"custom data set returned nothing\".to_string(),\n+                ));\n+            };\n+            let uuid = state.load.start_struct(\n+                req.name,\n+                req.workload,\n+                data_set,\n+                req.connection,\n+                expires,\n+                req.throughput,\n+            )?;\n+            Ok(uuid.to_string() + \"\\n\")\n+        }\n+    }\n }\n \n async fn stop(\n---\nrust/load/src/rest.rs\n@@ -43,8 +43,10 @@ pub struct StartRequest {\n     pub name: String,\n     /// The workload to run.\n     pub workload: Workload,\n-    /// The data set to use.\n-    pub data_set: String,\n+    /// The data set to use, referred to by name.\n+    pub data_set: Option<String>,\n+    /// The custom data set to use.\n+    pub custom_data_set: Option<serde_json::Value>,\n     /// The connection to use.\n     pub connection: Connection,\n     /// When the workload should expire.\n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.4\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.0.4\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.4\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.4\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.4\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.1.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.1\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\n\n\n---\n\nChoice D:\nrust/types/src/lib.rs\n@@ -23,6 +23,7 @@ mod tenant;\n mod validators;\n mod where_parsing;\n \n+pub mod optional_u128;\n pub mod regex;\n \n // Re-export the types module, so that we can use it as a single import in other modules.\n---\nrust/types/src/optional_u128.rs\n@@ -0,0 +1,74 @@\n+pub mod optional_u128_as_hex {\n+    use serde::de::Error;\n+    use serde::{Deserialize, Deserializer, Serializer};\n+\n+    /// Serializes `Option<u128>` as lowercase hex string if Some, skips if None.\n+    pub fn serialize<S>(val: &Option<u128>, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        match val {\n+            Some(v) => serializer.serialize_str(&format!(\"{:x}\", v)),\n+            None => serializer.serialize_none(),\n+        }\n+    }\n+\n+    /// Deserializes a lowercase hex string into `Option<u128>`.\n+    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<u128>, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let opt: Option<String> = Option::deserialize(deserializer)?;\n+        match opt {\n+            Some(s) => {\n+                let val = u128::from_str_radix(&s, 16).map_err(D::Error::custom)?;\n+                Ok(Some(val))\n+            }\n+            None => Ok(None),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::optional_u128_as_hex;\n+    use serde::{Deserialize, Serialize};\n+\n+    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n+    struct TestStruct {\n+        #[serde(\n+            with = \"optional_u128_as_hex\",\n+            default,\n+            skip_serializing_if = \"Option::is_none\"\n+        )]\n+        value: Option<u128>,\n+    }\n+\n+    #[test]\n+    fn test_serialize_some_u128() {\n+        let s = TestStruct { value: Some(255) };\n+        let json = serde_json::to_string(&s).unwrap();\n+        assert_eq!(json, r#\"{\"value\":\"ff\"}\"#);\n+    }\n+\n+    #[test]\n+    fn test_serialize_none() {\n+        let s = TestStruct { value: None };\n+        let json = serde_json::to_string(&s).unwrap();\n+        assert_eq!(json, r#\"{}\"#);\n+    }\n+\n+    #[test]\n+    fn test_deserialize_some_u128() {\n+        let json = r#\"{\"value\":\"ff\"}\"#;\n+        let s: TestStruct = serde_json::from_str(json).unwrap();\n+        assert_eq!(s, TestStruct { value: Some(255) });\n+    }\n+\n+    #[test]\n+    fn test_deserialize_none() {\n+        let json = r#\"{}\"#;\n+        let s: TestStruct = serde_json::from_str(json).unwrap();\n+        assert_eq!(s, TestStruct { value: None });\n+    }\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis line is logged once per collection on the dirty log.\n\n## Test plan\n\nI removed a line, relying upon CI.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nTiltfile\n@@ -202,6 +202,7 @@ k8s_resource(\n     'query-service-memberlist:MemberList',\n     'compaction-service-memberlist:MemberList',\n     'garbage-collection-service-memberlist:MemberList',\n+    'rust-log-service-memberlist:MemberList',\n \n     'sysdb-serviceaccount:serviceaccount',\n     'sysdb-serviceaccount-rolebinding:RoleBinding',\n---\ngo/cmd/coordinator/cmd.go\n@@ -69,6 +69,10 @@ func init() {\n \tCmd.Flags().StringVar(&conf.GarbageCollectionServiceMemberlistName, \"garbage-collection-memberlist-name\", \"garbage-collection-service-memberlist\", \"Garbage collection memberlist name\")\n \tCmd.Flags().StringVar(&conf.GarbageCollectionServicePodLabel, \"garbage-collection-pod-label\", \"garbage-collection-service\", \"Garbage collection pod label\")\n \n+\t// Log service Memberlist\n+\tCmd.Flags().StringVar(&conf.LogServiceMemberlistName, \"log-memberlist-name\", \"rust-log-service-memberlist\", \"Log service memberlist name\")\n+\tCmd.Flags().StringVar(&conf.LogServicePodLabel, \"log-pod-label\", \"rust-log-service\", \"Log service pod label\")\n+\n \t// S3 config\n \tCmd.Flags().BoolVar(&conf.MetaStoreConfig.CreateBucketIfNotExists, \"create-bucket-if-not-exists\", false, \"Create bucket if not exists\")\n \tCmd.Flags().StringVar(&conf.MetaStoreConfig.BucketName, \"bucket-name\", \"chroma-storage\", \"Bucket name\")\n---\ngo/pkg/sysdb/grpc/server.go\n@@ -53,6 +53,10 @@ type Config struct {\n \tGarbageCollectionServiceMemberlistName string\n \tGarbageCollectionServicePodLabel       string\n \n+\t// Log service memberlist config\n+\tLogServiceMemberlistName string\n+\tLogServicePodLabel       string\n+\n \t// Config for soft deletes.\n \tSoftDeleteEnabled          bool\n \tSoftDeleteCleanupInterval  time.Duration\n@@ -136,6 +140,15 @@ func NewWithGrpcProvider(config Config, provider grpcutils.GrpcProvider) (*Serve\n \n \t\t// Create memberlist manager for garbage collection service\n \t\tgarbageCollectionMemberlistManager, err := createMemberlistManager(namespace, config.GarbageCollectionServiceMemberlistName, config.GarbageCollectionServicePodLabel, config.WatchInterval, config.ReconcileInterval, config.ReconcileCount)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\t// Create memberlist manager for log service\n+\t\tlogServiceMemberlistManager, err := createMemberlistManager(namespace, config.LogServiceMemberlistName, config.LogServicePodLabel, config.WatchInterval, config.ReconcileInterval, config.ReconcileCount)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \n \t\t// Start the memberlist manager for query service\n \t\terr = queryMemberlistManager.Start()\n@@ -154,6 +167,12 @@ func NewWithGrpcProvider(config Config, provider grpcutils.GrpcProvider) (*Serve\n \t\t\treturn nil, err\n \t\t}\n \n+\t\t// Start the memberlist manager for log service\n+\t\terr = logServiceMemberlistManager.Start()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n \t\tlog.Info(\"Starting soft delete cleaner\", zap.Duration(\"cleanup_interval\", s.softDeleteCleaner.cleanupInterval), zap.Duration(\"max_age\", s.softDeleteCleaner.maxAge), zap.Uint(\"limit_per_check\", s.softDeleteCleaner.limitPerCheck))\n \t\ts.softDeleteCleaner.Start()\n \n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.39\n+version: 0.1.40\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/rust-log-service-memberlist-cr.yaml\n@@ -0,0 +1,59 @@\n+apiVersion: chroma.cluster/v1\n+kind: MemberList\n+metadata:\n+  name: rust-log-service-memberlist\n+  namespace: {{ .Values.namespace }}\n+spec:\n+  members:\n+\n+---\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: ClusterRole\n+metadata:\n+  name: rust-log-service-memberlist-readerwriter\n+rules:\n+- apiGroups:\n+    - chroma.cluster\n+  resources:\n+    - memberlists\n+  verbs:\n+    - get\n+    - list\n+    - watch\n+    # TODO: FIX THIS LEAKY PERMISSION\n+    - create\n+    - update\n+    - patch\n+    - delete\n+\n+---\n+\n+# Allows the sysdb service to read and write to the memberlist\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: ClusterRoleBinding\n+metadata:\n+  name: sysdb-rust-log-service-memberlist-binding\n+roleRef:\n+  apiGroup: rbac.authorization.k8s.io\n+  kind: ClusterRole\n+  name: rust-log-service-memberlist-readerwriter\n+subjects:\n+- kind: ServiceAccount\n+  name: sysdb-serviceaccount\n+  namespace: {{ .Values.namespace }}\n+\n+---\n+\n+# Allows the rust-frontend-service to read and write to the memberlist\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: ClusterRoleBinding\n+metadata:\n+  name: rust-frontend-service-rust-log-service-memberlist-binding\n+roleRef:\n+  apiGroup: rbac.authorization.k8s.io\n+  kind: ClusterRole\n+  name: rust-log-service-memberlist-readerwriter\n+subjects:\n+- kind: ServiceAccount\n+  name: rust-frontend-service-serviceaccount\n+  namespace: {{ .Values.namespace }}\n---\n\n\n---\n\nChoice B:\ndocs/docs.trychroma.com/markdoc/content/integrations/frameworks/llamaindex.md\n@@ -6,5 +6,5 @@ name: LlamaIndex\n # LlamaIndex\n \n - `LlamaIndex` [Vector Store page](https://docs.llamaindex.ai/en/stable/examples/vector_stores/ChromaIndexDemo.html)\n-- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n-- [Chroma Loader on Llamahub](https://llamahub.ai/l/chroma)\n+- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n+- [Chroma Loader on Llamahub](https://llamahub.ai/l/vector_stores/llama-index-vector-stores-chroma)\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -967,7 +967,10 @@ func (tc *Catalog) ForkCollection(ctx context.Context, forkCollection *model.For\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\n+\t\t// Defensive backstop to prevent too many forks\n+\t\tif len(lineageFile.Dependencies) > 1000000 {\n+\t\t\treturn common.ErrCollectionTooManyFork\n+\t\t}\n \t\tlineageFile.Dependencies = append(lineageFile.Dependencies, &coordinatorpb.CollectionVersionDependency{\n \t\t\tSourceCollectionId:      sourceCollectionIDStr,\n \t\t\tSourceCollectionVersion: uint64(sourceCollection.Version),\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -497,11 +497,6 @@ impl DirtyMarker {\n                         None\n                     }\n                     Ordering::Greater => {\n-                        tracing::info!(\n-                            \"{collection_id} has range ({}, {}]\",\n-                            record_compaction_position,\n-                            record_enumeration_position,\n-                        );\n                         uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_backpressure {\n                             backpressure.push(*collection_id);\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis PR properly sets my_member_id for rust-log-service nodes.\n\n## Test plan\n\nI bumped to two replicas and observed the log of the second one say\nthis:\n\nFrom the log:  my_member_id: rust-log-service-1\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.42\n+version: 0.1.43\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/rust-log-service.yaml\n@@ -82,7 +82,7 @@ spec:\n           env:\n             - name: CONFIG_PATH\n               value: \"/config/config.yaml\"\n-            - name: CHROMA_QUERY_SERVICE__MY_MEMBER_ID\n+            - name: CHROMA_LOG_SERVICE__MY_MEMBER_ID\n               valueFrom:\n                 fieldRef:\n                   fieldPath: metadata.name\n---\n\n\n---\n\nChoice B:\nrust/blockstore/src/arrow/blockfile.rs\n@@ -471,6 +471,15 @@ impl<'me, K: ArrowReadableKey<'me> + Into<KeyWrapper>, V: ArrowReadableValue<'me\n         self.load_blocks(&target_block_ids).await;\n     }\n \n+    pub(crate) async fn load_blocks_for_prefixes(&self, prefixes: impl IntoIterator<Item = &str>) {\n+        let prefix_vec = prefixes.into_iter().collect();\n+        let target_block_ids = self\n+            .root\n+            .sparse_index\n+            .get_block_ids_for_prefixes(prefix_vec);\n+        self.load_blocks(&target_block_ids).await;\n+    }\n+\n     pub(crate) async fn get(\n         &'me self,\n         prefix: &str,\n---\nrust/blockstore/src/arrow/sparse_index.rs\n@@ -362,7 +362,47 @@ impl SparseIndexReader {\n         result_uuids\n     }\n \n-    pub(super) fn get_block_ids_range<'prefix, 'referred_data, PrefixRange>(\n+    pub(super) fn get_block_ids_for_prefixes(&self, mut prefixes: Vec<&str>) -> Vec<Uuid> {\n+        prefixes.sort();\n+        let mut result_uuids = Vec::new();\n+        let block_start = self.data.forward.iter();\n+        let block_end = block_start\n+            .clone()\n+            .skip(1)\n+            .map(|(delim, _)| match delim {\n+                SparseIndexDelimiter::Start => {\n+                    unreachable!(\"The start delimiter should only appear in the first block\")\n+                }\n+                SparseIndexDelimiter::Key(composite_key) => Some(composite_key.prefix.as_str()),\n+            })\n+            .chain([None]);\n+        let mut prefix_iter = prefixes.into_iter().peekable();\n+        for ((start_delim, block), end_prefix) in block_start.zip(block_end) {\n+            if let SparseIndexDelimiter::Key(CompositeKey {\n+                prefix: start_prefix,\n+                key: _,\n+            }) = start_delim\n+            {\n+                while let Some(&prefix) = prefix_iter.peek() {\n+                    if start_prefix.as_str() <= prefix {\n+                        break;\n+                    }\n+                    prefix_iter.next();\n+                }\n+            }\n+            if let Some(&prefix) = prefix_iter.peek() {\n+                if end_prefix.is_none() || end_prefix.is_some_and(|end_prefix| prefix <= end_prefix)\n+                {\n+                    result_uuids.push(block.id);\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+        result_uuids\n+    }\n+\n+    pub(super) fn get_block_ids_range<'prefix, PrefixRange>(\n         &self,\n         prefix_range: PrefixRange,\n     ) -> Vec<Uuid>\n---\nrust/blockstore/src/types/reader.rs\n@@ -125,6 +125,18 @@ impl<\n         }\n     }\n \n+    pub async fn load_blocks_for_prefixes<'prefix>(\n+        &self,\n+        prefixes: impl IntoIterator<Item = &'prefix str>,\n+    ) {\n+        match self {\n+            BlockfileReader::MemoryBlockfileReader(_reader) => unimplemented!(),\n+            BlockfileReader::ArrowBlockfileReader(reader) => {\n+                reader.load_blocks_for_prefixes(prefixes).await\n+            }\n+        }\n+    }\n+\n     pub async fn rank(\n         &'referred_data self,\n         prefix: &'referred_data str,\n---\n\n\n---\n\nChoice C:\n.github/workflows/_python-tests.yml\n@@ -291,7 +291,7 @@ jobs:\n         api_key: ${{ secrets.DD_API_KEY }}\n         site: ${{ vars.DD_SITE }}\n     - name: Integration Test\n-      run: bin/python-integration-test ${{ matrix.test-globs }}\n+      run: python -m pytest ${{ matrix.test-globs }}\n       shell: bash\n       env:\n         ENV_FILE: ${{ matrix.env-file }}\n---\nchromadb/test/test_cli.py\n@@ -1,6 +1,5 @@\n import multiprocessing\n import multiprocessing.context\n-import os\n import sys\n import time\n from multiprocessing.synchronize import Event\n@@ -10,7 +9,6 @@\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,6 +17,36 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+        host: str, port: int,\n+    max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            client = chromadb.HttpClient(host=host, port=port)\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            print(\"Heartbeat failed, trying again...\")\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n@@ -32,14 +60,10 @@ def test_app() -> None:\n     server_process.start()\n     time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    assert wait_for_server(host=\"localhost\", port=8001), \"Server failed to start within maximum retry attempts\"\n \n-    client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -124,7 +148,7 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\", \"--timeout\", \"10\"]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\nrust/cli/src/commands/vacuum.rs\n@@ -20,8 +20,10 @@ use sqlx::Row;\n use std::error::Error;\n use std::path::Path;\n use std::str::FromStr;\n+use std::time::Duration;\n use std::{fs, io};\n use thiserror::Error;\n+use tokio::time::timeout;\n \n #[derive(Debug, Error)]\n pub enum VacuumError {\n@@ -43,6 +45,8 @@ pub struct VacuumArgs {\n     path: Option<String>,\n     #[clap(long, default_value_t = false, help = \"Skip vacuum confirmation\")]\n     force: bool,\n+    #[clap(long, help = \"Maximum time (in seconds) to wait for vacuum\")]\n+    timeout: Option<u64>,\n }\n \n fn sizeof_fmt(num: u64, suffix: Option<&str>) -> String {\n@@ -195,10 +199,6 @@ pub async fn vacuum_chroma(config: FrontendConfig) -> Result<(), Box<dyn Error>>\n \n     println!(\"Vacuuming (this may take a while)...\\n\");\n \n-    sqlx::query(&format!(\"PRAGMA busy_timeout = {}\", 5000))\n-        .execute(sqlite.get_conn())\n-        .await?;\n-\n     sqlx::query(\"VACUUM\").execute(sqlite.get_conn()).await?;\n \n     sqlx::query(\n@@ -264,9 +264,19 @@ pub fn vacuum(args: VacuumArgs) -> Result<(), CliError> {\n     };\n \n     let runtime = tokio::runtime::Runtime::new().expect(\"Failed to start Chroma\");\n-    runtime\n-        .block_on(vacuum_chroma(config.frontend))\n-        .map_err(|_| VacuumError::VacuumFailed)?;\n+\n+    let res = if let Some(secs) = args.timeout {\n+        runtime.block_on(async {\n+            timeout(Duration::from_secs(secs), vacuum_chroma(config.frontend))\n+                .await\n+                .unwrap_or_else(|_elapsed| {\n+                    Err(Box::new(VacuumError::VacuumFailed) as Box<dyn std::error::Error>)\n+                })\n+        })\n+    } else {\n+        runtime.block_on(vacuum_chroma(config.frontend))\n+    };\n+    res.map_err(|_| VacuumError::VacuumFailed)?;\n \n     let post_vacuum_size =\n         get_dir_size(Path::new(&persistent_path)).map_err(|_| VacuumError::DirSizeFailed)?;\n---\n\n\n---\n\nChoice D:\nrust/cache/src/foyer.rs\n@@ -492,6 +492,10 @@ where\n         }\n         Ok(res)\n     }\n+\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.cache.contains(key)\n+    }\n }\n \n impl<K, V> super::PersistentCache<K, V> for FoyerHybridCache<K, V>\n@@ -820,4 +824,26 @@ mod test {\n             .expect(\"Value should not be None\");\n         assert_eq!(value, \"foo\");\n     }\n+\n+    #[tokio::test]\n+    async fn test_may_contain() {\n+        let dir = tempfile::tempdir()\n+            .expect(\"To be able to create temp path\")\n+            .path()\n+            .to_str()\n+            .expect(\"To be able to parse path\")\n+            .to_string();\n+        let cache = FoyerCacheConfig {\n+            dir: Some(dir.clone()),\n+            flush: true,\n+            ..Default::default()\n+        }\n+        .build_hybrid_test::<String, String>()\n+        .await\n+        .unwrap();\n+\n+        cache.insert(\"key1\".to_string(), \"foo\".to_string()).await;\n+        assert!(cache.may_contain(&\"key1\".to_string()).await);\n+        assert!(!cache.may_contain(&\"key2\".to_string()).await);\n+    }\n }\n---\nrust/cache/src/lib.rs\n@@ -69,6 +69,11 @@ where\n {\n     async fn insert(&self, key: K, value: V);\n     async fn get(&self, key: &K) -> Result<Option<V>, CacheError>;\n+    // Returns true if the cache contains the key. This method may return a\n+    // false-positive.\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.get(key).await.map(|v| v.is_some()).unwrap_or(false)\n+    }\n     async fn remove(&self, key: &K);\n     async fn clear(&self) -> Result<(), CacheError>;\n     async fn obtain(&self, key: K) -> Result<Option<V>, CacheError>;\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis PR cherry-picks the commit aaea8f752f8ce8618a233f387c1e171d1f4823ec onto release/2025-05-16. If there are unresolved conflicts, please resolve them manually.\n\n---\n\nChoice A:\nrust/types/src/api_types.rs\n@@ -82,7 +82,7 @@ impl ChromaError for GetCollectionWithSegmentsError {\n             GetCollectionWithSegmentsError::CollectionConversionError(\n                 collection_conversion_error,\n             ) => collection_conversion_error.code(),\n-            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::Internal,\n             GetCollectionWithSegmentsError::Field(_) => ErrorCodes::FailedPrecondition,\n             GetCollectionWithSegmentsError::SegmentConversionError(segment_conversion_error) => {\n                 segment_conversion_error.code()\n@@ -832,7 +832,7 @@ impl ChromaError for ForkCollectionError {\n             ForkCollectionError::CollectionConversionError(collection_conversion_error) => {\n                 collection_conversion_error.code()\n             }\n-            ForkCollectionError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            ForkCollectionError::DuplicateSegment => ErrorCodes::Internal,\n             ForkCollectionError::Field(_) => ErrorCodes::FailedPrecondition,\n             ForkCollectionError::Local => ErrorCodes::Unimplemented,\n             ForkCollectionError::Internal(chroma_error) => chroma_error.code(),\n---\n\n\n---\n\nChoice B:\nrust/segment/src/sqlite_metadata.rs\n@@ -705,28 +705,62 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            filter_limit_query\n-                .left_join(\n+            let (references_metadata, references_document) = whr.analyze_where_references();\n+            if references_metadata {\n+                filter_limit_query.inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n-                )\n-                .left_join(\n+                );\n+            } else if metadata {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            }\n+            if references_document {\n+                filter_limit_query.inner_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n-                )\n-                .distinct()\n-                .cond_where(whr.eval());\n+                );\n+            } else if document {\n+                filter_limit_query.left_join(\n+                    EmbeddingFulltextSearch::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n+                        EmbeddingFulltextSearch::Table,\n+                        EmbeddingFulltextSearch::Rowid,\n+                    )),\n+                );\n+            }\n+            filter_limit_query.distinct().cond_where(whr.eval());\n+        } else {\n+            if metadata {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            }\n+\n+            if document {\n+                filter_limit_query.left_join(\n+                    EmbeddingFulltextSearch::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n+                        EmbeddingFulltextSearch::Table,\n+                        EmbeddingFulltextSearch::Rowid,\n+                    )),\n+                );\n+            }\n         }\n \n         filter_limit_query\n             .order_by((Embeddings::Table, Embeddings::Id), sea_query::Order::Asc)\n             .offset(skip as u64)\n             .limit(fetch.unwrap_or(u32::MAX) as u64);\n-\n         let alias = Alias::new(SUBQ_ALIAS);\n         let mut projection_query = Query::select();\n         projection_query\n---\nrust/types/src/metadata.rs\n@@ -560,6 +560,26 @@ impl Where {\n             },\n         }\n     }\n+\n+    pub fn analyze_where_references(&self) -> (bool, bool) {\n+        let mut references_metadata = false;\n+        let mut references_document = false;\n+\n+        match self {\n+            Where::Composite(expr) => {\n+                // For composite expressions, recursively check all children\n+                for child in &expr.children {\n+                    let (child_meta, child_doc) = Self::analyze_where_references(&(child.clone()));\n+                    references_metadata |= child_meta;\n+                    references_document |= child_doc;\n+                }\n+            }\n+            Where::Document(_) => references_document = true,\n+            Where::Metadata(_) => references_metadata = true,\n+        }\n+\n+        (references_metadata, references_document)\n+    }\n }\n \n impl TryFrom<chroma_proto::Where> for Where {\n---\n\n\n---\n\nChoice C:\nchromadb/test/distributed/test_log_failover.py\n@@ -65,4 +65,6 @@ def test_log_failover(\n \n     for i in range(200):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n         assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -26,7 +26,7 @@ log:\n     connect_timeout_ms: 5000\n     request_timeout_ms: 60000 # 1 minute\n     alt_host: \"rust-log-service.chroma\"\n-    use_alt_host_for_everything: true\n+    alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n \n executor:\n   distributed:\n---\nrust/log/src/config.rs\n@@ -14,19 +14,20 @@ pub struct GrpcLogConfig {\n     pub max_encoding_message_size: usize,\n     #[serde(default = \"GrpcLogConfig::default_max_decoding_message_size\")]\n     pub max_decoding_message_size: usize,\n-    // NOTE(rescrv):  This is a hack to allow us to test two log services in parallel without\n-    // breaking the old service.  If alt host is specified, then the \"use_alt_host_for_everything\"\n-    // and \"use_alt_for_collections\" config parameters are consulted.  If\n-    // \"use_alt_host_for_everything\" is set (CI) or the collection being written is in the alt\n-    // collections vec (staging), then we can use the alt host.\n+    // NOTE(rescrv):  This is a hack to allow us to test migrate between two log services without\n+    // breaking things or having a hard cut-over.  If alt_host_threshold is specified, it will be\n+    // interpreted as a u128 (UUID == u128) and if the collection in question is <=\n+    // alt_host_threshold, it go to the alt-host first.\n+    //\n+    // alt tenants/collections will always initialize a new log\n     #[serde(default = \"Option::default\")]\n     pub alt_host: Option<String>,\n     #[serde(default)]\n-    pub use_alt_host_for_everything: bool,\n-    #[serde(default)]\n     pub use_alt_for_tenants: Vec<String>,\n     #[serde(default)]\n     pub use_alt_for_collections: Vec<String>,\n+    #[serde(default = \"Option::default\")]\n+    pub alt_host_threshold: Option<String>,\n }\n \n impl GrpcLogConfig {\n@@ -65,9 +66,9 @@ impl Default for GrpcLogConfig {\n             max_encoding_message_size: GrpcLogConfig::default_max_encoding_message_size(),\n             max_decoding_message_size: GrpcLogConfig::default_max_decoding_message_size(),\n             alt_host: None,\n-            use_alt_host_for_everything: false,\n             use_alt_for_tenants: vec![],\n             use_alt_for_collections: vec![],\n+            alt_host_threshold: None,\n         }\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -244,21 +244,41 @@ impl GrpcLog {\n         client_for_conn_str(connection_string)\n     }\n \n+    fn client_is_on_alt_log(to_evaluate: CollectionUuid, alt_host_threshold: Option<&str>) -> bool {\n+        if let Some(alt_host_threshold) = alt_host_threshold {\n+            let Ok(alt_host_threshold) = Uuid::parse_str(alt_host_threshold) else {\n+                tracing::error!(\"alt_host_threshold must be a valid UUID\");\n+                return false;\n+            };\n+            let to_evaluate = to_evaluate.0.as_u64_pair().0;\n+            let alt_host_threshold = alt_host_threshold.as_u64_pair().0;\n+            to_evaluate <= alt_host_threshold\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn client_for(\n         &mut self,\n         tenant: &str,\n         collection_id: CollectionUuid,\n     ) -> &mut LogServiceClient<chroma_tracing::GrpcTraceService<tonic::transport::Channel>> {\n-        let collection_id = collection_id.to_string();\n         if let Some(alt) = self.alt_client.as_mut() {\n-            if self.config.use_alt_host_for_everything\n-                || self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n-                || self.config.use_alt_for_collections.contains(&collection_id)\n+            if self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n+                || self\n+                    .config\n+                    .use_alt_for_collections\n+                    .contains(&collection_id.to_string())\n+                || Self::client_is_on_alt_log(\n+                    collection_id,\n+                    self.config.alt_host_threshold.as_deref(),\n+                )\n             {\n                 tracing::info!(\"using alt client for {collection_id}\");\n                 return alt;\n             }\n         }\n+        tracing::info!(\"using standard client for {collection_id}\");\n         &mut self.client\n     }\n \n@@ -413,7 +433,8 @@ impl GrpcLog {\n         let mut norm = self\n             ._get_collections_with_new_data(false, min_compaction_size)\n             .await?;\n-        if self.config.use_alt_host_for_everything\n+        if self.config.alt_host_threshold.is_some()\n+            || !self.config.use_alt_for_tenants.is_empty()\n             || !self.config.use_alt_for_collections.is_empty()\n         {\n             let alt = self\n@@ -524,3 +545,32 @@ impl GrpcLog {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn client_is_on_alt_log() {\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            None\n+        ));\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"00088272-cfc4-419d-997a-baebfb25034a\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"00088272-cfc4-419d-997a-baebfb25034a\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"ffffffff-ffff-ffff-ffff-ffffffffffff\"),\n+        ));\n+    }\n+}\n---\nrust/worker/tilt_config.yaml\n@@ -42,7 +42,7 @@ query_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -122,7 +122,7 @@ compaction_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -197,4 +197,4 @@ log_service:\n         connect_timeout_ms: 5000\n         request_timeout_ms: 60000 # 1 minute\n         alt_host: \"rust-log-service.chroma\"\n-        use_alt_host_for_everything: true\n+        alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n---\n\n\n---\n\nChoice D:\n.github/workflows/release-chromadb.yml\n@@ -220,7 +220,7 @@ jobs:\n                 // - This workflow finishes for A and deploys A to Chroma Cloud\n                 // Chroma Cloud is now running A, but the last commit was B.\n                 \"environment\": \"staging\",\n-                \"planes\": \"data,control\"\n+                \"planes\": \"control,data\"\n               }\n             })\n \n---\n.github/workflows/trigger-deploy.yaml\n@@ -5,8 +5,9 @@ on:\n   push:\n     branches:\n       # main is not included here because it is handled by the release-chromadb.yaml workflow\n+      # production deploys (release branches) are also not here because they are currently\n+      # meant to be handled manually.\n       - rc/**-**-**\n-      - release/**-**-**\n \n jobs:\n   deploy:\n@@ -25,7 +26,7 @@ jobs:\n               ref: 'main',\n               inputs: {\n                 'planes': 'control,data',\n-                 environment: '${{ contains(github.ref, 'release/') && 'production' || 'staging' }}',\n+                 environment: 'staging',\n                 'ignore-lock': true,\n                 'oss-ref': '${{ github.ref_name }}',\n                 'hosted-ref': '${{ github.ref_name }}'\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis PR cherry-picks the commit 316cd5fda5de5bad462eb396161e9cf400a0492c onto release/2025-05-16. If there are unresolved conflicts, please resolve them manually.\n\n---\n\nChoice A:\nrust/frontend/src/impls/in_memory_frontend.rs\n@@ -664,6 +664,7 @@ impl InMemoryFrontend {\n     pub fn healthcheck(&self) -> chroma_types::HealthCheckResponse {\n         chroma_types::HealthCheckResponse {\n             is_executor_ready: true,\n+            is_log_client_ready: true,\n         }\n     }\n }\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -1433,6 +1433,7 @@ impl ServiceBasedFrontend {\n     pub async fn healthcheck(&self) -> HealthCheckResponse {\n         HealthCheckResponse {\n             is_executor_ready: self.executor.is_ready().await,\n+            is_log_client_ready: self.log_client.is_ready(),\n         }\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -738,6 +738,18 @@ impl GrpcLog {\n             Err(GrpcMigrateLogError::NotSupported)\n         }\n     }\n+\n+    /// If the log client is configured to use a memberlist-based client assigner,\n+    /// this function checks if the client assigner is ready to serve requests.\n+    /// This is useful to ensure that the client assigner has enough information about the cluster\n+    /// before making requests to the log service.\n+    pub fn is_ready(&self) -> bool {\n+        if let Some(client_assigner) = &self.alt_client_assigner {\n+            !client_assigner.is_empty()\n+        } else {\n+            true // If no client assigner is configured, we assume it's ready.\n+        }\n+    }\n }\n \n #[cfg(test)]\n---\nrust/log/src/log.rs\n@@ -222,4 +222,12 @@ impl Log {\n             Log::InMemory(_) => unimplemented!(),\n         }\n     }\n+\n+    pub fn is_ready(&self) -> bool {\n+        match self {\n+            Log::Sqlite(_) => true,\n+            Log::Grpc(log) => log.is_ready(),\n+            Log::InMemory(_) => true,\n+        }\n+    }\n }\n---\nrust/types/src/api_types.rs\n@@ -1719,11 +1719,12 @@ impl ChromaError for QueryError {\n #[derive(Serialize, ToSchema)]\n pub struct HealthCheckResponse {\n     pub is_executor_ready: bool,\n+    pub is_log_client_ready: bool,\n }\n \n impl HealthCheckResponse {\n     pub fn get_status_code(&self) -> tonic::Code {\n-        if self.is_executor_ready {\n+        if self.is_executor_ready && self.is_log_client_ready {\n             tonic::Code::Ok\n         } else {\n             tonic::Code::Unavailable\n---\n\n\n---\n\nChoice B:\nCargo.lock\n@@ -4508,7 +4508,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34\"\n dependencies = [\n  \"cfg-if\",\n- \"windows-targets 0.48.5\",\n+ \"windows-targets 0.52.6\",\n ]\n \n [[package]]\n@@ -5147,16 +5147,17 @@ checksum = \"830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3\"\n \n [[package]]\n name = \"numpy\"\n-version = \"0.23.0\"\n+version = \"0.24.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b94caae805f998a07d33af06e6a3891e38556051b8045c615470a71590e13e78\"\n+checksum = \"a7cfbf3f0feededcaa4d289fe3079b03659e85c5b5a177f4ba6fb01ab4fb3e39\"\n dependencies = [\n  \"libc\",\n  \"ndarray\",\n  \"num-complex\",\n  \"num-integer\",\n  \"num-traits\",\n  \"pyo3\",\n+ \"pyo3-build-config\",\n  \"rustc-hash 2.0.0\",\n ]\n \n@@ -6035,9 +6036,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7778bffd85cf38175ac1f545509665d0b9b92a198ca7941f131f85f7a4f9a872\"\n+checksum = \"e5203598f366b11a02b13aa20cab591229ff0a89fd121a308a5df751d5fc9219\"\n dependencies = [\n  \"cfg-if\",\n  \"indoc\",\n@@ -6053,29 +6054,29 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-build-config\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94f6cbe86ef3bf18998d9df6e0f3fc1050a8c5efa409bf712e661a4366e010fb\"\n+checksum = \"99636d423fa2ca130fa5acde3059308006d46f98caac629418e53f7ebb1e9999\"\n dependencies = [\n  \"once_cell\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"pyo3-ffi\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e9f1b4c431c0bb1c8fb0a338709859eed0d030ff6daa34368d3b152a63dfdd8d\"\n+checksum = \"78f9cf92ba9c409279bc3305b5409d90db2d2c22392d443a87df3a1adad59e33\"\n dependencies = [\n  \"libc\",\n  \"pyo3-build-config\",\n ]\n \n [[package]]\n name = \"pyo3-macros\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbc2201328f63c4710f68abdf653c89d8dbc2858b88c5d88b0ff38a75288a9da\"\n+checksum = \"0b999cb1a6ce21f9a6b147dcf1be9ffedf02e0043aec74dc390f3007047cecd9\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"pyo3-macros-backend\",\n@@ -6085,9 +6086,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-macros-backend\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fca6726ad0f3da9c9de093d6f116a93c1a38e417ed73bf138472cf4064f72028\"\n+checksum = \"822ece1c7e1012745607d5cf0bcb2874769f0f7cb34c4cde03b9358eb9ef911a\"\n dependencies = [\n  \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n@@ -7308,7 +7309,7 @@ version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"03c3c6b7927ffe7ecaa769ee0e3994da3b8cafc8f444578982c83ecb161af917\"\n dependencies = [\n- \"heck 0.4.1\",\n+ \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n  \"syn 2.0.101\",\n@@ -7866,9 +7867,9 @@ checksum = \"55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.16\"\n+version = \"0.13.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61c41af27dd6d1e27b1b16b489db798443478cef1f06a660c96db617ba5de3b1\"\n+checksum = \"e502f78cdbb8ba4718f566c418c52bc729126ffd16baee5baa718cf25dd5a69a\"\n \n [[package]]\n name = \"tempfile\"\n---\nCargo.toml\n@@ -44,6 +44,7 @@ flatbuffers = \"24.3.25\"\n futures = \"0.3\"\n futures-core = \"0.3\"\n lazy_static = { version = \"1.4\" }\n+lexical-core = \"1.0\"\n num_cpus = \"1.16.0\"\n opentelemetry = { version = \"0.27.0\", default-features = false, features = [\"trace\", \"metrics\"] }\n opentelemetry-otlp = { version = \"0.27\", features = [\"http-proto\"] }\n@@ -78,7 +79,7 @@ utoipa = { version = \"5.0.0\", features = [\"macros\", \"axum_extras\", \"debug\", \"uui\n sqlx = { version = \"0.8.3\", features = [\"runtime-tokio\", \"sqlite\"] }\n sha2 = \"0.10.8\"\n md5 = \"0.7.0\"\n-pyo3 = { version = \"0.23.3\", features = [\"abi3-py39\"] }\n+pyo3 = { version = \"0.24.1\", features = [\"abi3-py39\"] }\n http = \"1.1.0\"\n tower-http = { version = \"0.6.2\", features = [\"trace\", \"cors\"] }\n bytemuck = \"1.21.0\"\n@@ -125,6 +126,7 @@ shuttle = \"0.7.1\"\n tempfile = \"3.14.0\"\n itertools = \"0.13.0\"\n serial_test = \"3.2.0\"\n+zip = \"2.3.0\"\n \n [profile.dev]\n # Significantly reduces compile times\n---\nrust/python_bindings/Cargo.toml\n@@ -13,7 +13,7 @@ async-trait = { workspace = true }\n pyo3 = { workspace = true }\n tokio = { workspace = true }\n uuid = { workspace = true }\n-numpy = \"0.23.0\"\n+numpy = \"0.24.0\"\n serde = { workspace = true }\n serde_json = { workspace = true }\n thiserror = { workspace = true }\n---\n\n\n---\n\nChoice C:\nrust/storage/src/admissioncontrolleds3.rs\n@@ -548,9 +548,19 @@ impl CountBasedPolicy {\n             match &mut channel_receiver {\n                 Some(rx) => {\n                     select! {\n-                        _ = rx.recv() => {\n+                        did_recv = rx.recv() => {\n                             // Reevaluate priority if we got a notification.\n-                            continue;\n+                            match did_recv {\n+                                Some(_) => {\n+                                    // If we got a notification, continue to acquire.\n+                                    continue;\n+                                }\n+                                None => {\n+                                    // If the channel was closed, break out of the loop.\n+                                    channel_receiver = None;\n+                                    continue;\n+                                }\n+                            }\n                         }\n                         token = self.remaining_tokens[current_priority.as_usize()].acquire() => {\n                             match token {\n---\nrust/worker/src/execution/operators/prefetch_record.rs\n@@ -6,7 +6,7 @@ use chroma_segment::{\n     blockfile_record::{RecordSegmentReader, RecordSegmentReaderCreationError},\n     types::{materialize_logs, LogMaterializerError},\n };\n-use chroma_system::Operator;\n+use chroma_system::{Operator, OperatorType};\n use thiserror::Error;\n use tracing::{trace, Instrument, Span};\n \n@@ -94,4 +94,8 @@ impl Operator<PrefetchRecordInput, PrefetchRecordOutput> for PrefetchRecordOpera\n     fn errors_when_sender_dropped(&self) -> bool {\n         false\n     }\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n }\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -374,7 +374,7 @@ func (tc *Catalog) createCollectionImpl(txCtx context.Context, createCollection\n \t\treturn nil, false, common.ErrConcurrentDeleteCollection\n \t}\n \tresult := convertCollectionToModel(collectionList)[0]\n-\treturn result, true, nil\n+\treturn result, created, nil\n }\n \n func (tc *Catalog) CreateCollection(ctx context.Context, createCollection *model.CreateCollection, ts types.Timestamp) (*model.Collection, bool, error) {\n@@ -1249,7 +1249,6 @@ func (tc *Catalog) CreateCollectionAndSegments(ctx context.Context, createCollec\n \t\t}\n \n \t\t// If collection already exists, then do not create segments.\n-\t\t// TODO: Should we check to see if segments does not exist? and create them?\n \t\tif !created {\n \t\t\treturn nil\n \t\t}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThe docs for list_collections had a discrepancy, where the code block showed it returning a Sequence[Collection], while the documentation below said it returned CollectionName. They are reconciled to show list_collections now returns Collection objects. The migration guide has also been udpated\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\n.github/workflows/release-chromadb.yml\n@@ -220,7 +220,7 @@ jobs:\n                 // - This workflow finishes for A and deploys A to Chroma Cloud\n                 // Chroma Cloud is now running A, but the last commit was B.\n                 \"environment\": \"staging\",\n-                \"planes\": \"data,control\"\n+                \"planes\": \"control,data\"\n               }\n             })\n \n---\n.github/workflows/trigger-deploy.yaml\n@@ -5,8 +5,9 @@ on:\n   push:\n     branches:\n       # main is not included here because it is handled by the release-chromadb.yaml workflow\n+      # production deploys (release branches) are also not here because they are currently\n+      # meant to be handled manually.\n       - rc/**-**-**\n-      - release/**-**-**\n \n jobs:\n   deploy:\n@@ -25,7 +26,7 @@ jobs:\n               ref: 'main',\n               inputs: {\n                 'planes': 'control,data',\n-                 environment: '${{ contains(github.ref, 'release/') && 'production' || 'staging' }}',\n+                 environment: 'staging',\n                 'ignore-lock': true,\n                 'oss-ref': '${{ github.ref_name }}',\n                 'hosted-ref': '${{ github.ref_name }}'\n---\n\n\n---\n\nChoice B:\nrust/wal3/src/reader.rs\n@@ -141,7 +141,7 @@ impl LogReader {\n         }\n         fragments.retain(|f| f.limit > from);\n         fragments.sort_by_key(|f| f.start.offset());\n-        Ok(Self::post_process_fragments(fragments, limits))\n+        Ok(Self::post_process_fragments(fragments, from, limits))\n     }\n \n     /// Do a consistent stale read of the manifest.  If the read can be returned without I/O,\n@@ -174,10 +174,14 @@ impl LogReader {\n             .filter(|f| ranges_overlap(log_position_range, (f.start, f.limit)))\n             .cloned()\n             .collect::<Vec<_>>();\n-        Some(Self::post_process_fragments(fragments, limits))\n+        Some(Self::post_process_fragments(fragments, from, limits))\n     }\n \n-    fn post_process_fragments(mut fragments: Vec<Fragment>, limits: Limits) -> Vec<Fragment> {\n+    fn post_process_fragments(\n+        mut fragments: Vec<Fragment>,\n+        from: LogPosition,\n+        limits: Limits,\n+    ) -> Vec<Fragment> {\n         fragments.sort_by_key(|f| f.start.offset());\n         if let Some(max_files) = limits.max_files {\n             if fragments.len() as u64 > max_files {\n@@ -188,7 +192,7 @@ impl LogReader {\n         while fragments.len() > 1\n             // NOTE(rescrv):  We take the start of the last fragment, because if there are enough\n             // records without it we can pop.\n-            && fragments[fragments.len() - 1].start - fragments[0].start\n+            && fragments[fragments.len() - 1].start - from\n                 > limits.max_records.unwrap_or(u64::MAX)\n         {\n             tracing::info!(\n@@ -456,3 +460,143 @@ pub async fn read_fragment(\n         setsum,\n     }))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use setsum::Setsum;\n+\n+    use crate::{Fragment, FragmentSeqNo};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn post_process_fragments_uses_from_position_for_record_limits() {\n+        let fragments = vec![\n+            Fragment {\n+                path: \"fragment1\".to_string(),\n+                seq_no: FragmentSeqNo(1),\n+                start: LogPosition::from_offset(100),\n+                limit: LogPosition::from_offset(150),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+            Fragment {\n+                path: \"fragment2\".to_string(),\n+                seq_no: FragmentSeqNo(2),\n+                start: LogPosition::from_offset(150),\n+                limit: LogPosition::from_offset(200),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+            Fragment {\n+                path: \"fragment3\".to_string(),\n+                seq_no: FragmentSeqNo(3),\n+                start: LogPosition::from_offset(200),\n+                limit: LogPosition::from_offset(250),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+        ];\n+\n+        // Test case: from position is later than the first fragment's start\n+        // This tests the bug fix where we use 'from' instead of fragments[0].start\n+        let from = LogPosition::from_offset(125);\n+        let limits = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(100), // Set a limit that should trigger the record check\n+        };\n+\n+        let result = LogReader::post_process_fragments(fragments.clone(), from, limits);\n+\n+        // With the fix: last fragment start (200) - from (125) = 75 records\n+        // This should be under the 100 record limit, so all fragments should remain\n+        assert_eq!(result.len(), 3);\n+\n+        // Test case that would fail with the old bug:\n+        // If we were using fragments[0].start (100) instead of from (125),\n+        // then: last fragment start (200) - fragments[0].start (100) = 100 records\n+        // This would equal the limit, but the actual span from 'from' is only 75\n+        let limits_strict = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(74), // Just under the actual span from 'from'\n+        };\n+\n+        let result_strict =\n+            LogReader::post_process_fragments(fragments.clone(), from, limits_strict);\n+\n+        // With the fix: 200 - 125 = 75 > 74, so last fragment should be removed\n+        assert_eq!(result_strict.len(), 2);\n+        assert_eq!(result_strict[0].seq_no, FragmentSeqNo(1));\n+        assert_eq!(result_strict[1].seq_no, FragmentSeqNo(2));\n+    }\n+\n+    #[test]\n+    fn records_based_pruning_bug_from_commit_message() {\n+        // Test the exact scenario from the commit message:\n+        // - Fragments with LogPosition ranges [1, 101), [101, 201).\n+        // - Query for 75 records at offset 50 should fetch both fragments.\n+        // - Prior to this change only the first fragment was fetched.\n+\n+        let fragments = vec![\n+            Fragment {\n+                path: \"fragment1\".to_string(),\n+                seq_no: FragmentSeqNo(1),\n+                start: LogPosition::from_offset(1),\n+                limit: LogPosition::from_offset(101),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+            Fragment {\n+                path: \"fragment2\".to_string(),\n+                seq_no: FragmentSeqNo(2),\n+                start: LogPosition::from_offset(101),\n+                limit: LogPosition::from_offset(201),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+        ];\n+\n+        // Query for 75 records at offset 50\n+        let from = LogPosition::from_offset(50);\n+        let limits = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(75),\n+        };\n+\n+        let result = LogReader::post_process_fragments(fragments.clone(), from, limits);\n+\n+        // With the fix: both fragments should be returned\n+        // The calculation is: last fragment start (101) - from (50) = 51 records\n+        // Since 51 < 75, both fragments should remain\n+        assert_eq!(\n+            result.len(),\n+            2,\n+            \"Both fragments should be returned for 75 records from offset 50\"\n+        );\n+        assert_eq!(result[0].seq_no, FragmentSeqNo(1));\n+        assert_eq!(result[1].seq_no, FragmentSeqNo(2));\n+\n+        // Test the edge case where the old bug would have incorrectly calculated:\n+        // Old bug would use: fragments[1].start (101) - fragments[0].start (1) = 100 records\n+        // If max_records was 99, old code would incorrectly remove the second fragment\n+        let limits_edge_case = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(50), // Just under the actual span from 'from' (51)\n+        };\n+\n+        let result_edge =\n+            LogReader::post_process_fragments(fragments.clone(), from, limits_edge_case);\n+\n+        // With the fix: 101 - 50 = 51 > 50, so the second fragment should be removed\n+        assert_eq!(\n+            result_edge.len(),\n+            1,\n+            \"Only first fragment should remain with 50 record limit\"\n+        );\n+        assert_eq!(result_edge[0].seq_no, FragmentSeqNo(1));\n+    }\n+}\n---\n\n\n---\n\nChoice C:\ndocs/docs.trychroma.com/markdoc/content/reference/python/client.md\n@@ -272,7 +272,7 @@ List all collections.\n \n **Returns**:\n \n-- `Sequence[CollectionName]` - A list of collection names. `CollectionName` is a string.\n+- `Sequence[Collection]` - A list of collection objects.\n \n \n **Examples**:\n---\ndocs/docs.trychroma.com/markdoc/content/updates/migration.md\n@@ -26,6 +26,8 @@ In this release, we've rewritten much of Chroma in Rust. Performance has signifi\n \n Chroma no longer provides built-in authentication implementations.\n \n+`list_collections` now reverts back to returning `Collection` objects.\n+\n **Chroma in-process changes**\n \n This section is applicable to you if you use Chroma via\n---\n\n\n---\n\nChoice D:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.4\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.4\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.4\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.4\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.4\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nIt demonstrates that the configuration works, but doesn't guarantee that\nthe log failover test is actually failing over anything.  Moving back to\none replica gives us that assurance on each CI run rather than 50% of\nthem.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.40\n+version: 0.1.41\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/rust-log-service.yaml\n@@ -82,6 +82,10 @@ spec:\n           env:\n             - name: CONFIG_PATH\n               value: \"/config/config.yaml\"\n+            - name: CHROMA_QUERY_SERVICE__MY_MEMBER_ID\n+              valueFrom:\n+                fieldRef:\n+                  fieldPath: metadata.name\n             {{ if .Values.rustLogService.otherEnvConfig }}\n               {{ .Values.rustLogService.otherEnvConfig | nindent 12 }}\n             {{ end }}\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -33,3 +33,6 @@ compactionService:\n       value: 'value: \"1\"'\n     - name: CONFIG_PATH\n       value: 'value: \"/tilt_config.yaml\"'\n+\n+rustLogService:\n+  replicaCount: 2\n---\nrust/log-service/src/lib.rs\n@@ -1821,6 +1821,8 @@ pub struct OpenTelemetryConfig {\n pub struct LogServerConfig {\n     #[serde(default = \"default_port\")]\n     pub port: u16,\n+    #[serde(default = \"LogServerConfig::default_my_member_id\")]\n+    pub my_member_id: String,\n     #[serde(default)]\n     pub opentelemetry: Option<OpenTelemetryConfig>,\n     #[serde(default)]\n@@ -1849,6 +1851,10 @@ impl LogServerConfig {\n         100\n     }\n \n+    fn default_my_member_id() -> String {\n+        \"rust-log-service-0\".to_string()\n+    }\n+\n     /// one million records on the log.\n     fn default_num_records_before_backpressure() -> u64 {\n         1_000_000\n@@ -1869,6 +1875,7 @@ impl Default for LogServerConfig {\n     fn default() -> Self {\n         Self {\n             port: default_port(),\n+            my_member_id: LogServerConfig::default_my_member_id(),\n             opentelemetry: None,\n             storage: StorageConfig::default(),\n             writer: LogWriterOptions::default(),\n@@ -1909,7 +1916,7 @@ impl Configurable<LogServerConfig> for LogServer {\n         let dirty_log = LogWriter::open_or_initialize(\n             config.writer.clone(),\n             Arc::clone(&storage),\n-            \"dirty\",\n+            &format!(\"dirty-{}\", config.my_member_id),\n             \"dirty log writer\",\n             (),\n         )\n@@ -1952,6 +1959,7 @@ pub async fn log_entrypoint() {\n         Err(_) => RootConfig::load(),\n     };\n     let config = config.log_service;\n+    eprintln!(\"my_member_id: {}\", config.my_member_id);\n     let registry = chroma_config::registry::Registry::new();\n     if let Some(otel_config) = &config.opentelemetry {\n         eprintln!(\"enabling tracing\");\n---\n\n\n---\n\nChoice B:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.41\n+version: 0.1.42\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -35,4 +35,4 @@ compactionService:\n       value: 'value: \"/tilt_config.yaml\"'\n \n rustLogService:\n-  replicaCount: 2\n+  replicaCount: 1\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -215,7 +215,18 @@ async fn get_log_from_handle<'a>(\n     prefix: &str,\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n-    let mut active = handle.active.lock().await;\n+    let active = handle.active.lock().await;\n+    get_log_from_handle_with_mutex_held(handle, active, options, storage, prefix, mark_dirty).await\n+}\n+\n+async fn get_log_from_handle_with_mutex_held<'a>(\n+    handle: &'a crate::state_hash_table::Handle<LogKey, LogStub>,\n+    mut active: tokio::sync::MutexGuard<'_, ActiveLog>,\n+    options: &LogWriterOptions,\n+    storage: &Arc<Storage>,\n+    prefix: &str,\n+    mark_dirty: MarkDirty,\n+) -> Result<LogRef<'a>, wal3::Error> {\n     if active.log.is_some() {\n         active.keep_alive(Duration::from_secs(60));\n     }\n@@ -519,7 +530,12 @@ impl LogServer {\n         // Grab a lock on the state for this key, so that a racing initialize won't do anything.\n         let key = LogKey { collection_id };\n         let handle = self.open_logs.get_or_create_state(key);\n-        let mut _active = handle.active.lock().await;\n+        let active = handle.active.lock().await;\n+\n+        // Someone already initialized the log on a prior call.\n+        if active.log.is_some() {\n+            return Ok(());\n+        }\n \n         tracing::info!(\"log transfer to {collection_id}\");\n         let scout_request = Request::new(ScoutLogsRequest {\n@@ -641,6 +657,23 @@ impl LogServer {\n             log_offset: start as i64 - 1,\n         }))\n         .await?;\n+        // Set it up so that once we release the mutex, the next person won't do I/O and will\n+        // immediately be able to push logs.\n+        let storage_prefix = storage_prefix_for_log(collection_id);\n+        let mark_dirty = MarkDirty {\n+            collection_id,\n+            dirty_log: Arc::clone(&self.dirty_log),\n+        };\n+        // If this fails, the next writer will load manifest and continue unimpeded.\n+        let _ = get_log_from_handle_with_mutex_held(\n+            &handle,\n+            active,\n+            &self.config.writer,\n+            &self.storage,\n+            &storage_prefix,\n+            mark_dirty,\n+        )\n+        .await;\n         Ok(())\n     }\n \n---\n\n\n---\n\nChoice D:\n.github/actions/tilt/action.yaml\n@@ -10,13 +10,16 @@ runs:\n         curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v$TILT_VERSION/tilt.$TILT_VERSION.linux.x86_64.tar.gz | \\\n           tar -xzv -C /usr/local/bin tilt\n     - name: Set up kind\n-      id: kind\n-      uses: helm/kind-action@v1\n+      uses: Wandalen/wretry.action@v3.7.0\n       with:\n-        registry: true\n-        registry_name: my-registry\n-        registry_port: 5001\n-        registry_enable_delete: true\n+        action: helm/kind-action@v1\n+        attempt_limit: 3\n+        attempt_delay: 2000\n+        with: |\n+          registry: true\n+          registry_name: my-registry\n+          registry_port: 5001\n+          registry_enable_delete: true\n     - name: Add blacksmith registry mirror\n       shell: bash\n       run: |\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nPrior to this change, the `was_created` flag was not correctly propagated up to the caller of `createCollectionImpl()`. This resulted in two concurrent create collection requests with `get_or_create: true` creating duplicate segments.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\nDid not add a new test.\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -374,7 +374,7 @@ func (tc *Catalog) createCollectionImpl(txCtx context.Context, createCollection\n \t\treturn nil, false, common.ErrConcurrentDeleteCollection\n \t}\n \tresult := convertCollectionToModel(collectionList)[0]\n-\treturn result, true, nil\n+\treturn result, created, nil\n }\n \n func (tc *Catalog) CreateCollection(ctx context.Context, createCollection *model.CreateCollection, ts types.Timestamp) (*model.Collection, bool, error) {\n@@ -1251,7 +1251,6 @@ func (tc *Catalog) CreateCollectionAndSegments(ctx context.Context, createCollec\n \t\t}\n \n \t\t// If collection already exists, then do not create segments.\n-\t\t// TODO: Should we check to see if segments does not exist? and create them?\n \t\tif !created {\n \t\t\treturn nil\n \t\t}\n---\n\n\n---\n\nChoice B:\nrust/worker/src/execution/orchestration/compact.rs\n@@ -794,10 +794,14 @@ impl Handler<TaskResult<FetchLogOutput, FetchLogError>> for CompactOrchestrator\n                 tracing::info!(\"Pulled Logs Up To Offset: {:?}\", self.pulled_log_offset);\n             }\n             None => {\n+                tracing::warn!(\"No logs were pulled from the log service, this can happen when the log compaction offset is behing the sysdb.\");\n+                // TODO(hammadb): We can repair the log service's understanding of the offset here, as this only happens\n+                // when the log service is not up to date on the latest compacted offset, which leads it to schedule an already\n+                // compacted collection.\n                 self.terminate_with_result(\n-                    Err(CompactionError::InvariantViolation(\n-                        \"Logs should be present for compaction\",\n-                    )),\n+                    Ok(CompactionResponse {\n+                        collection_id: self.collection_id,\n+                    }),\n                     ctx,\n                 )\n                 .await;\n---\n\n\n---\n\nChoice C:\nrust/load/src/bin/chroma-load-start.rs\n@@ -1,7 +1,10 @@\n //! Start a workload on the chroma-load server.\n \n+use std::sync::Arc;\n+\n use clap::Parser;\n \n+use chroma_load::data_sets::{all_data_sets, References};\n use chroma_load::rest::StartRequest;\n use chroma_load::{humanize_expires, Connection, Throughput, Workload};\n \n@@ -18,7 +21,13 @@ struct Args {\n     #[arg(long)]\n     workload: String,\n     #[arg(long)]\n-    data_set: String,\n+    data_set: Option<String>,\n+    #[arg(long)]\n+    references_data_set: Option<String>,\n+    #[arg(long)]\n+    operates_on_data_set: Option<String>,\n+    #[arg(long)]\n+    operates_on_cardinality: Option<usize>,\n     #[arg(long)]\n     url: String,\n     #[arg(long)]\n@@ -103,11 +112,47 @@ async fn main() {\n             wrap: Box::new(workload),\n         };\n     }\n+    let (data_set, custom_data_set) = match (\n+        args.data_set,\n+        args.references_data_set,\n+        args.operates_on_data_set,\n+        args.operates_on_cardinality,\n+    ) {\n+        (Some(data_set), None, None, None) => (Some(data_set.clone()), None),\n+        (None, Some(references), Some(operates_on), Some(cardinality)) => {\n+            let Some(referred_to) = all_data_sets()\n+                .iter()\n+                .find(|ds| ds.name() == references)\n+                .map(Arc::clone)\n+            else {\n+                eprintln!(\"Could not find a data set to reference named {references}\");\n+                std::process::exit(13);\n+            };\n+            let to_start = References {\n+                references: referred_to.json(),\n+                operates_on,\n+                cardinality,\n+            };\n+            let to_start = match serde_json::to_value(&to_start) {\n+                Ok(to_start) => to_start,\n+                Err(err) => {\n+                    eprintln!(\"could not serialize referencing data set: {err:?}\");\n+                    std::process::exit(13);\n+                }\n+            };\n+            (None, Some(to_start))\n+        }\n+        _ => {\n+            eprintln!(\"must provide data_set XOR (references_data_set, operates_on_data_set, operates_on_cardinality)\");\n+            std::process::exit(13);\n+        }\n+    };\n     let req = StartRequest {\n         name: args.name,\n         expires: humanize_expires(&args.expires).unwrap_or(args.expires),\n         workload,\n-        data_set: args.data_set,\n+        data_set,\n+        custom_data_set,\n         connection: Connection {\n             url: args.url,\n             api_key,\n---\nrust/load/src/data_sets.rs\n@@ -1496,9 +1496,9 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n \n #[derive(Clone, Debug, Default, serde::Deserialize, serde::Serialize)]\n pub struct References {\n-    references: serde_json::Value,\n-    operates_on: String,\n-    cardinality: usize,\n+    pub references: serde_json::Value,\n+    pub operates_on: String,\n+    pub cardinality: usize,\n }\n \n /// Get a data set from a particular JSON value.\n---\nrust/load/src/lib.rs\n@@ -1190,7 +1190,7 @@ impl LoadService {\n     pub fn start(\n         &self,\n         name: String,\n-        mut workload: Workload,\n+        workload: Workload,\n         data_set: String,\n         connection: Connection,\n         expires: chrono::DateTime<chrono::FixedOffset>,\n@@ -1199,14 +1199,28 @@ impl LoadService {\n         let Some(data_set) = self.data_sets().iter().find(|ds| ds.name() == data_set) else {\n             return Err(Error::NotFound(\"data set not found\".to_string()));\n         };\n+        let data_set = Arc::clone(data_set);\n+        self.start_struct(name, workload, data_set, connection, expires, throughput)\n+    }\n+\n+    /// Start a workload on the load service using structs rather than resolving strings.\n+    pub fn start_struct(\n+        &self,\n+        name: String,\n+        mut workload: Workload,\n+        data_set: Arc<dyn DataSet>,\n+        connection: Connection,\n+        expires: chrono::DateTime<chrono::FixedOffset>,\n+        throughput: Throughput,\n+    ) -> Result<Uuid, Error> {\n         workload.resolve_by_name(self.workloads())?;\n         let res = {\n             // SAFETY(rescrv):  Mutex poisoning.\n             let mut harness = self.harness.lock().unwrap();\n             Ok(harness.start(\n                 name,\n                 workload.clone(),\n-                data_set,\n+                &data_set,\n                 connection,\n                 expires,\n                 throughput,\n@@ -1625,15 +1639,41 @@ async fn start(\n ) -> Result<String, Error> {\n     let expires = chrono::DateTime::parse_from_rfc3339(&req.expires)\n         .map_err(|err| Error::InvalidRequest(format!(\"could not parse rfc3339: {err:?}\")))?;\n-    let uuid = state.load.start(\n-        req.name,\n-        req.workload,\n-        req.data_set,\n-        req.connection,\n-        expires,\n-        req.throughput,\n-    )?;\n-    Ok(uuid.to_string() + \"\\n\")\n+    match (req.data_set, req.custom_data_set) {\n+        (Some(_), Some(_)) => Err(Error::InvalidRequest(\n+            \"provide at most one of data_set and custom_data_set\".to_string(),\n+        )),\n+        (None, None) => Err(Error::InvalidRequest(\n+            \"provide at least one of data_set and custom_data_set\".to_string(),\n+        )),\n+        (Some(data_set), None) => {\n+            let uuid = state.load.start(\n+                req.name,\n+                req.workload,\n+                data_set,\n+                req.connection,\n+                expires,\n+                req.throughput,\n+            )?;\n+            Ok(uuid.to_string() + \"\\n\")\n+        }\n+        (None, Some(custom_data_set)) => {\n+            let Some(data_set) = data_sets::from_json(&custom_data_set) else {\n+                return Err(Error::InvalidRequest(\n+                    \"custom data set returned nothing\".to_string(),\n+                ));\n+            };\n+            let uuid = state.load.start_struct(\n+                req.name,\n+                req.workload,\n+                data_set,\n+                req.connection,\n+                expires,\n+                req.throughput,\n+            )?;\n+            Ok(uuid.to_string() + \"\\n\")\n+        }\n+    }\n }\n \n async fn stop(\n---\nrust/load/src/rest.rs\n@@ -43,8 +43,10 @@ pub struct StartRequest {\n     pub name: String,\n     /// The workload to run.\n     pub workload: Workload,\n-    /// The data set to use.\n-    pub data_set: String,\n+    /// The data set to use, referred to by name.\n+    pub data_set: Option<String>,\n+    /// The custom data set to use.\n+    pub custom_data_set: Option<serde_json::Value>,\n     /// The connection to use.\n     pub connection: Connection,\n     /// When the workload should expire.\n---\n\n\n---\n\nChoice D:\nchromadb/test/test_cli.py\n@@ -7,10 +7,10 @@\n \n import chromadb\n from chromadb.api.client import Client\n+from chromadb.api.client import ClientAPI\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,27 +19,59 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+    client: ClientAPI, max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n \n+\n def test_app() -> None:\n     kwargs = {\"path\": \"chroma_test_data\", \"port\": 8001}\n     args = [\"chroma\", \"run\"]\n     args.extend(build_cli_args(**kwargs))\n     print(args)\n     server_process = multiprocessing.Process(target=start_app, args=(args,))\n     server_process.start()\n-    time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    host = kwargs.get(\"host\", \"localhost\")\n+    port = int(kwargs.get(\"port\", 8001))\n \n     client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n+    assert wait_for_server(\n+        client\n+    ), \"Server failed to start within maximum retry attempts\"\n+\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -72,7 +104,13 @@ def add_records(collection: Collection, num: int) -> None:\n         cur.execute(sql, params)\n         assert cur.fetchall() == []\n \n-    sys.argv = [\"chroma\", \"vacuum\", \"--path\", system.settings.persist_directory, \"--force\"]\n+    sys.argv = [\n+        \"chroma\",\n+        \"vacuum\",\n+        \"--path\",\n+        system.settings.persist_directory,\n+        \"--force\",\n+    ]\n     cli.app()\n \n     # Maintenance log should have a vacuum entry\n@@ -124,7 +162,13 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\n+            \"chroma\",\n+            \"vacuum\",\n+            \"--path\",\n+            sqlite_persistent.settings.persist_directory,\n+            \"--force\",\n+        ]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - This should be an internal error as failedprecondition reports downstream as a 412.\r\n- New functionality\r\n  - None\r\n\r\n## Test plan\r\n_How are these changes tested?_\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nNone\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -1212,13 +1212,6 @@ impl DataSet for VerifyingDataSet {\n             }\n         };\n \n-        event!(\n-            Level::INFO,\n-            \"Upserting {} keys, new cardinality: {}\",\n-            uq.batch_size,\n-            key_start_index + uq.batch_size\n-        );\n-\n         for offset in 0..uq.batch_size {\n             let key = uq.key.select_from_reference(self, offset);\n             if !keys.contains(&key) {\n---\n\n\n---\n\nChoice B:\nrust/types/src/api_types.rs\n@@ -82,7 +82,7 @@ impl ChromaError for GetCollectionWithSegmentsError {\n             GetCollectionWithSegmentsError::CollectionConversionError(\n                 collection_conversion_error,\n             ) => collection_conversion_error.code(),\n-            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::Internal,\n             GetCollectionWithSegmentsError::Field(_) => ErrorCodes::FailedPrecondition,\n             GetCollectionWithSegmentsError::SegmentConversionError(segment_conversion_error) => {\n                 segment_conversion_error.code()\n@@ -849,7 +849,7 @@ impl ChromaError for ForkCollectionError {\n             ForkCollectionError::CollectionConversionError(collection_conversion_error) => {\n                 collection_conversion_error.code()\n             }\n-            ForkCollectionError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            ForkCollectionError::DuplicateSegment => ErrorCodes::Internal,\n             ForkCollectionError::Field(_) => ErrorCodes::FailedPrecondition,\n             ForkCollectionError::Local => ErrorCodes::Unimplemented,\n             ForkCollectionError::Internal(chroma_error) => chroma_error.code(),\n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/server.rs\n@@ -290,14 +290,23 @@ impl FrontendServer {\n         if let Some(cors_allow_origins) = cors_allow_origins {\n             let origins = cors_allow_origins\n                 .into_iter()\n-                .map(|origin| origin.parse().unwrap())\n+                .map(|origin| {\n+                    origin\n+                        .parse()\n+                        .unwrap_or_else(|_| panic!(\"Invalid origin: {}\", origin))\n+                })\n                 .collect::<Vec<_>>();\n \n-            let cors = CorsLayer::new()\n-                .allow_origin(origins)\n+            let mut cors_builder = CorsLayer::new()\n                 .allow_headers(tower_http::cors::Any)\n                 .allow_methods(tower_http::cors::Any);\n-            app = app.layer(cors);\n+            if origins.len() == 1 && origins[0] == \"*\" {\n+                cors_builder = cors_builder.allow_origin(tower_http::cors::Any);\n+            } else {\n+                cors_builder = cors_builder.allow_origin(origins);\n+            }\n+\n+            app = app.layer(cors_builder);\n         }\n \n         // TODO: tracing\n@@ -1972,6 +1981,54 @@ mod tests {\n         assert_eq!(allow_headers.unwrap(), \"*\");\n     }\n \n+    #[tokio::test]\n+    async fn test_cors_wildcard() {\n+        let registry = Registry::new();\n+        let system = System::new();\n+\n+        let port = random_port::PortPicker::new().pick().unwrap();\n+\n+        let mut config = FrontendServerConfig::single_node_default();\n+        config.port = port;\n+        config.cors_allow_origins = Some(vec![\"*\".to_string()]);\n+\n+        let frontend = Frontend::try_from_config(&(config.clone().frontend, system), &registry)\n+            .await\n+            .unwrap();\n+        let app = FrontendServer::new(\n+            config,\n+            frontend,\n+            vec![],\n+            Arc::new(()),\n+            Arc::new(()),\n+            System::new(),\n+        );\n+        tokio::task::spawn(async move {\n+            app.run().await;\n+        });\n+\n+        let client = reqwest::Client::new();\n+        let res = client\n+            .request(\n+                reqwest::Method::OPTIONS,\n+                format!(\"http://localhost:{}/api/v2/heartbeat\", port),\n+            )\n+            .header(\"Origin\", \"http://localhost:3000\")\n+            .send()\n+            .await\n+            .unwrap();\n+        assert_eq!(res.status(), 200);\n+\n+        let allow_origin = res.headers().get(\"Access-Control-Allow-Origin\");\n+        assert_eq!(allow_origin.unwrap(), \"*\");\n+\n+        let allow_methods = res.headers().get(\"Access-Control-Allow-Methods\");\n+        assert_eq!(allow_methods.unwrap(), \"*\");\n+\n+        let allow_headers = res.headers().get(\"Access-Control-Allow-Headers\");\n+        assert_eq!(allow_headers.unwrap(), \"*\");\n+    }\n+\n     #[tokio::test]\n     async fn test_defaults_to_json_content_type() {\n         let port = test_server().await;\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nPutting two logs on the same dirty log wasn't incorrect but wasn't going\nto perform.  This PR makes multiple log services possible now that the\nfrontend routes to them by collection ID.\n\nThis PR creates two rust-log-services and relies upon CI to uncover problems.\n\n## Test plan\n\nCI\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.40\n+version: 0.1.41\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/rust-log-service.yaml\n@@ -82,6 +82,10 @@ spec:\n           env:\n             - name: CONFIG_PATH\n               value: \"/config/config.yaml\"\n+            - name: CHROMA_QUERY_SERVICE__MY_MEMBER_ID\n+              valueFrom:\n+                fieldRef:\n+                  fieldPath: metadata.name\n             {{ if .Values.rustLogService.otherEnvConfig }}\n               {{ .Values.rustLogService.otherEnvConfig | nindent 12 }}\n             {{ end }}\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -33,3 +33,6 @@ compactionService:\n       value: 'value: \"1\"'\n     - name: CONFIG_PATH\n       value: 'value: \"/tilt_config.yaml\"'\n+\n+rustLogService:\n+  replicaCount: 2\n---\nrust/log-service/src/lib.rs\n@@ -1821,6 +1821,8 @@ pub struct OpenTelemetryConfig {\n pub struct LogServerConfig {\n     #[serde(default = \"default_port\")]\n     pub port: u16,\n+    #[serde(default = \"LogServerConfig::default_my_member_id\")]\n+    pub my_member_id: String,\n     #[serde(default)]\n     pub opentelemetry: Option<OpenTelemetryConfig>,\n     #[serde(default)]\n@@ -1849,6 +1851,10 @@ impl LogServerConfig {\n         100\n     }\n \n+    fn default_my_member_id() -> String {\n+        \"rust-log-service-0\".to_string()\n+    }\n+\n     /// one million records on the log.\n     fn default_num_records_before_backpressure() -> u64 {\n         1_000_000\n@@ -1869,6 +1875,7 @@ impl Default for LogServerConfig {\n     fn default() -> Self {\n         Self {\n             port: default_port(),\n+            my_member_id: LogServerConfig::default_my_member_id(),\n             opentelemetry: None,\n             storage: StorageConfig::default(),\n             writer: LogWriterOptions::default(),\n@@ -1909,7 +1916,7 @@ impl Configurable<LogServerConfig> for LogServer {\n         let dirty_log = LogWriter::open_or_initialize(\n             config.writer.clone(),\n             Arc::clone(&storage),\n-            \"dirty\",\n+            &format!(\"dirty-{}\", config.my_member_id),\n             \"dirty log writer\",\n             (),\n         )\n@@ -1952,6 +1959,7 @@ pub async fn log_entrypoint() {\n         Err(_) => RootConfig::load(),\n     };\n     let config = config.log_service;\n+    eprintln!(\"my_member_id: {}\", config.my_member_id);\n     let registry = chroma_config::registry::Registry::new();\n     if let Some(otel_config) = &config.opentelemetry {\n         eprintln!(\"enabling tracing\");\n---\n\n\n---\n\nChoice B:\ndocs/docs.trychroma.com/markdoc/content/reference/python/client.md\n@@ -272,7 +272,7 @@ List all collections.\n \n **Returns**:\n \n-- `Sequence[CollectionName]` - A list of collection names. `CollectionName` is a string.\n+- `Sequence[Collection]` - A list of collection objects.\n \n \n **Examples**:\n---\ndocs/docs.trychroma.com/markdoc/content/updates/migration.md\n@@ -26,6 +26,8 @@ In this release, we've rewritten much of Chroma in Rust. Performance has signifi\n \n Chroma no longer provides built-in authentication implementations.\n \n+`list_collections` now reverts back to returning `Collection` objects.\n+\n **Chroma in-process changes**\n \n This section is applicable to you if you use Chroma via\n---\n\n\n---\n\nChoice C:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.8\"\n+__version__ = \"1.0.9\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\n\n\n---\n\nChoice D:\nchromadb/api/types.py\n@@ -790,9 +790,10 @@ def validate_where(where: Where) -> None:\n                     \"$eq\",\n                     \"$in\",\n                     \"$nin\",\n+                    \"$distinct\",\n                 ]:\n                     raise ValueError(\n-                        f\"Expected where operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, \"\n+                        f\"Expected where operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, $distinct, \"\n                         f\"got {operator}\"\n                     )\n \n---\nchromadb/base_types.py\n@@ -17,6 +17,7 @@\n     Literal[\"$lte\"],\n     Literal[\"$ne\"],\n     Literal[\"$eq\"],\n+    Literal[\"$distinct\"],\n ]\n InclusionExclusionOperator = Union[Literal[\"$in\"], Literal[\"$nin\"]]\n OperatorExpression = Union[\n---\nrust/segment/src/sqlite_metadata.rs\n@@ -675,6 +675,12 @@ impl IntoSqliteExpr for MetadataExpression {\n                         }\n                         Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n+                    PrimitiveOperator::Distinct => {\n+                        subq.and_where(scol.eq(sval));\n+                        subq.order_by((Embeddings::Table, Embeddings::Id), sea_query::Order::Asc);\n+                        subq.limit(1);\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n+                    }\n                 }\n             }\n             MetadataComparison::Set(op, vals) => {\n---\nrust/segment/src/test.rs\n@@ -541,6 +541,9 @@ impl CheckRecord for MetadataExpression {\n                     PrimitiveOperator::LessThanOrEqual => {\n                         match_type && stored.is_some_and(|v| *v <= metadata_value)\n                     }\n+                    PrimitiveOperator::Distinct => {\n+                        match_type && stored.is_some_and(|v| *v == metadata_value)\n+                    }\n                 }\n             }\n             MetadataComparison::Set(set_operator, metadata_set_value) => {\n---\nrust/types/src/metadata.rs\n@@ -901,6 +901,7 @@ pub enum PrimitiveOperator {\n     GreaterThanOrEqual,\n     LessThan,\n     LessThanOrEqual,\n+    Distinct,\n }\n \n impl From<chroma_proto::GenericComparator> for PrimitiveOperator {\n---\nrust/types/src/where_parsing.rs\n@@ -320,6 +320,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::Equal;\n             } else if operator == \"$ne\" {\n                 operator_type = PrimitiveOperator::NotEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n@@ -338,6 +340,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::Equal;\n             } else if operator == \"$ne\" {\n                 operator_type = PrimitiveOperator::NotEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n@@ -364,6 +368,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::GreaterThan;\n             } else if operator == \"$gte\" {\n                 operator_type = PrimitiveOperator::GreaterThanOrEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n@@ -390,6 +396,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::GreaterThan;\n             } else if operator == \"$gte\" {\n                 operator_type = PrimitiveOperator::GreaterThanOrEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n---\nrust/worker/src/execution/operators/filter.rs\n@@ -80,6 +80,8 @@ pub enum FilterError {\n     RecordReader(#[from] RecordSegmentReaderCreationError),\n     #[error(\"Error parsing regular expression: {0}\")]\n     Regex(#[from] ChromaRegexError),\n+    #[error(\"Distinct filter is not supported\")]\n+    Distinct,\n }\n \n impl ChromaError for FilterError {\n@@ -91,6 +93,7 @@ impl ChromaError for FilterError {\n             FilterError::Record(e) => e.code(),\n             FilterError::RecordReader(e) => e.code(),\n             FilterError::Regex(_) => ErrorCodes::InvalidArgument,\n+            FilterError::Distinct => ErrorCodes::InvalidArgument,\n         }\n     }\n }\n@@ -170,6 +173,7 @@ impl<'me> MetadataLogReader<'me> {\n                 PrimitiveOperator::NotEqual => unreachable!(\n                     \"Inequality filter should be handled above the metadata provider level\"\n                 ),\n+                PrimitiveOperator::Distinct => return Err(FilterError::Distinct),\n             };\n             Ok(metadata_value_to_offset_ids\n                 .range(bounds)\n@@ -334,6 +338,7 @@ impl<'me> MetadataProvider<'me> {\n                         PrimitiveOperator::NotEqual => unreachable!(\n                             \"Inequality filter should be handled above the metadata provider level\"\n                         ),\n+                        PrimitiveOperator::Distinct => return Err(FilterError::Distinct),\n                     }\n                 } else {\n                     Ok(RoaringBitmap::new())\n@@ -391,7 +396,8 @@ impl<'me> RoaringMetadataFilter<'me> for MetadataExpression {\n                     | PrimitiveOperator::GreaterThan\n                     | PrimitiveOperator::GreaterThanOrEqual\n                     | PrimitiveOperator::LessThan\n-                    | PrimitiveOperator::LessThanOrEqual => SignedRoaringBitmap::Include(\n+                    | PrimitiveOperator::LessThanOrEqual\n+                    | PrimitiveOperator::Distinct => SignedRoaringBitmap::Include(\n                         metadata_provider\n                             .filter_by_metadata(&self.key, metadata_value, primitive_operator)\n                             .await?,\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis PR creates two rust-log-services and relies upon CI to uncover problems.\n\n## Test plan\n\nI'm depending on CI to run cluster-rust-frontend tests.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\n.github/actions/rust/action.yaml\n@@ -19,6 +19,10 @@ runs:\n       uses: actions-rust-lang/setup-rust-toolchain@v1\n       with:\n         cache: false # we use Blacksmith's cache package below\n+    - name: Set channel in rust-toolchain.toml as default\n+      shell: bash\n+      run: |\n+        rustup default $(grep -m1 '^channel' rust-toolchain.toml | cut -d'\"' -f2)\n     - name: Install Protoc\n       uses: arduino/setup-protoc@v3\n       with:\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -398,9 +398,10 @@ impl DirtyMarker {\n             let num_records = rollup_pc.limit_log_position - rollup_pc.start_log_position;\n             let reinsert_count = rollup_pc.reinsert_count;\n             let initial_insertion_epoch_us = rollup_pc.initial_insertion_epoch_us;\n-            let to_compact = num_records >= record_count_threshold\n+            let to_compact = true/*\n+                || num_records >= record_count_threshold\n                 || now_us - initial_insertion_epoch_us >= timeout_us\n-                || reinsert_count >= reinsert_threshold;\n+                || reinsert_count >= reinsert_threshold*/;\n             if to_compact {\n                 compactable.push(collection_id);\n             }\n@@ -2063,6 +2064,7 @@ mod tests {\n                 },\n             ),\n         ];\n+        /*\n         assert!(DirtyMarker::rollup(\n             Arc::new(storage),\n             |storage, collection_id| async move {\n@@ -2084,6 +2086,7 @@ mod tests {\n         .await\n         .unwrap()\n         .is_none());\n+        */\n     }\n \n     #[tokio::test]\n---\n\n\n---\n\nChoice C:\nclients/new-js/packages/chromadb/src/chroma-client.ts\n@@ -411,7 +411,7 @@ export class ChromaClient {\n    * @param options.embeddingFunction - Optional embedding function to use\n    * @returns A CollectionAPI instance for the specified collection\n    */\n-  public collection({\n+  public getCollectionById({\n     id,\n     embeddingFunction,\n   }: {\n@@ -431,7 +431,7 @@ export class ChromaClient {\n    * @param items - Array of collection IDs or objects with ID and optional embedding function\n    * @returns Array of CollectionAPI instances\n    */\n-  public collections(\n+  public getCollectionsById(\n     items: string[] | { id: string; embeddingFunction?: EmbeddingFunction }[],\n   ) {\n     if (items.length === 0) return [];\n---\ndocs/docs.trychroma.com/markdoc/content/docs/collections/create-get-delete.md\n@@ -109,10 +109,10 @@ const [col1, col2] = client.getCollections([\n ])\n ```\n \n-The `getCollection` and `getCollections` methods issue an API call to a Chroma server to get collections with all their fields. If you only need access to collection actions on records and want to save the API call, you can get a \"thin\" collection object using the `collection` method. It takes in a collection **ID** and an embedding function.\n+The `getCollection` and `getCollections` methods issue an API call to a Chroma server to get collections with all their fields. If you only need access to collection actions on records, and want to save the API call, you can get a \"thin\" collection object using the `getCollectionById` method (and `getCollectionsById`). It takes in a collection **ID** and an embedding function.\n \n ```typescript\n-const collection = client.collection({ id: 'abc', embeddingFunction: openaiEF })\n+const collection = client.getCollectionById({ id: 'abc', embeddingFunction: openaiEF })\n ```\n \n You can also delete collections by name using `deleteCollection`:\n---\n\n\n---\n\nChoice D:\nk8s/distributed-chroma/values.dev.yaml\n@@ -33,3 +33,6 @@ compactionService:\n       value: 'value: \"1\"'\n     - name: CONFIG_PATH\n       value: 'value: \"/tilt_config.yaml\"'\n+\n+rustLogService:\n+  replicaCount: 2\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis is a test of functionality we will soon rely upon.\n\n## Test plan\n\nTested locally; will test in CI.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/mdac/src/scorecard.rs\n@@ -622,4 +622,56 @@ mod tests {\n         assert_eq!(metrics.successful_untrack.load(Ordering::SeqCst), 0);\n         assert_eq!(metrics.failed_track.load(Ordering::SeqCst), 1);\n     }\n+\n+    #[test]\n+    fn three_patterns() {\n+        // Test an exact pattern-based override.\n+        let metrics = TestMetrics::default();\n+        let sc = Scorecard::new(\n+            &metrics,\n+            vec![\n+                Rule::new(\n+                    vec![\n+                        Pattern::must(\"op:*\"),\n+                        Pattern::must(\"tenant:me\"),\n+                        Pattern::must(\"collection:*\"),\n+                    ],\n+                    20,\n+                ),\n+                Rule::new(\n+                    vec![\n+                        Pattern::must(\"op:*\"),\n+                        Pattern::must(\"tenant:*\"),\n+                        Pattern::must(\"collection:*\"),\n+                    ],\n+                    10,\n+                ),\n+            ],\n+            1.try_into().unwrap(),\n+        );\n+        let mut saved_tickets = vec![];\n+        // Fill to the limit specified in the first rule.\n+        for _ in 0..20 {\n+            let t = sc.track(&[\"op:read\", \"tenant:me\", \"collection:foo\"]);\n+            assert!(t.is_some());\n+            saved_tickets.push(t);\n+        }\n+        // Reject\n+        let t = sc.track(&[\"op:read\", \"tenant:me\", \"collection:foo\"]);\n+        assert!(t.is_none());\n+        // Fill to the limit specified in the second rule.\n+        for _ in 0..10 {\n+            let t = sc.track(&[\"op:read\", \"tenant:you\", \"collection:foo\"]);\n+            assert!(t.is_some());\n+            saved_tickets.push(t);\n+        }\n+        // Reject\n+        let t = sc.track(&[\"op:read\", \"tenant:you\", \"collection:foo\"]);\n+        assert!(t.is_none());\n+\n+        assert_eq!(metrics.new_scorecard.load(Ordering::SeqCst), 1);\n+        assert_eq!(metrics.successful_track.load(Ordering::SeqCst), 30);\n+        assert_eq!(metrics.successful_untrack.load(Ordering::SeqCst), 0);\n+        assert_eq!(metrics.failed_track.load(Ordering::SeqCst), 2);\n+    }\n }\n---\n\n\n---\n\nChoice B:\n.github/workflows/_python-tests.yml\n@@ -155,7 +155,7 @@ jobs:\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n       - uses: ./.github/actions/tilt\n       - name: Test\n-        run: bin/cluster-test.sh bash -c 'python -m pytest \"${{ matrix.test-globs }}\"' --durations 10\n+        run: bin/cluster-test.sh bash -c 'python -m pytest \"${{ matrix.test-globs }}\" --durations 10'\n         shell: bash\n         env:\n           PROPERTY_TESTING_PRESET: ${{ inputs.property_testing_preset }}\n---\n\n\n---\n\nChoice C:\nrust/index/src/fulltext/types.rs\n@@ -313,7 +313,7 @@ impl<'me> FullTextIndexReader<'me> {\n         }\n \n         // Retrieve posting lists for each token.\n-        let posting_lists = futures::stream::iter(tokens)\n+        let posting_lists = futures::stream::iter(&tokens)\n             .then(|token| async move {\n                 let positional_posting_list = self\n                     .posting_lists_blockfile_reader\n@@ -355,39 +355,37 @@ impl<'me> FullTextIndexReader<'me> {\n \n             if min_doc_id == max_doc_id {\n                 // All tokens appear in the same document, so check positional alignment.\n-                let mut positions_per_posting_list = Vec::with_capacity(num_tokens);\n-                for (i, posting_list) in posting_lists.iter().enumerate() {\n-                    let (_, _, positions) = posting_list[pointers[i]];\n-                    positions_per_posting_list.push(positions);\n-                }\n-\n-                // Adjust positions and check for sequential alignment.\n                 // Imagine you're searching for \"brown fox\" over the document \"the quick brown fox\".\n                 // The positions for \"brown\" are {2} and for \"fox\" are {3}. The adjusted positions after subtracting the token's position in the query are {2} for \"brown\" and 3 - 1 = {2} for \"fox\".\n                 // The intersection of these two sets is non-empty, so we know that the two tokens are adjacent.\n+                // In practice, we must adjust the positions by using the byte offset of the token rather than the token's position in the query, because Unicode characters can be variable-length and the posting lists are stored as byte offsets.\n+                // E.x. imagine we're using a 1-gram tokenizer and processing the string \"\u00e9m\". The token positions are {0, 1}, but the byte offsets are {0, 2} (because \u00e9 is two bytes long).\n \n                 // Seed with the positions of the first token.\n-                let mut adjusted_positions = positions_per_posting_list[0]\n+                let mut adjusted = posting_lists[0][pointers[0]]\n+                    .2\n                     .iter()\n                     .copied()\n                     .collect::<HashSet<_>>();\n \n-                for (offset, positions_set) in positions_per_posting_list.iter().enumerate().skip(1)\n-                {\n-                    let positions_set = positions_set\n+                for i in 1..num_tokens {\n+                    let byte_delta_from_first_token =\n+                        tokens[i].offset_from as u32 - tokens[0].offset_from as u32;\n+                    let positions = &posting_lists[i][pointers[i]].2;\n+\n+                    let shifted = positions\n                         .iter()\n-                        // (We can discard any positions that the token appears at before the current offset)\n-                        .filter_map(|&p| p.checked_sub(offset as u32))\n+                        .filter_map(|&p| p.checked_sub(byte_delta_from_first_token))\n                         .collect::<HashSet<_>>();\n-                    adjusted_positions = &adjusted_positions & &positions_set;\n \n-                    if adjusted_positions.is_empty() {\n+                    adjusted = &adjusted & &shifted;\n+                    if adjusted.is_empty() {\n                         break;\n                     }\n                 }\n \n                 // All tokens are sequential\n-                if !adjusted_positions.is_empty() {\n+                if !adjusted.is_empty() {\n                     results.insert(min_doc_id);\n                 }\n \n@@ -991,6 +989,47 @@ mod tests {\n         assert_eq!(res, RoaringBitmap::from([1]));\n     }\n \n+    #[tokio::test]\n+    async fn test_document_with_multibyte_characters() {\n+        let tmp_dir = tempdir().unwrap();\n+        let storage = Storage::Local(LocalStorage::new(tmp_dir.path().to_str().unwrap()));\n+        let block_cache = new_cache_for_test();\n+        let root_cache = new_cache_for_test();\n+        let provider = BlockfileProvider::new_arrow(storage, 1024 * 1024, block_cache, root_cache);\n+        let pl_blockfile_writer = provider\n+            .write::<u32, Vec<u32>>(BlockfileWriterOptions::default().ordered_mutations())\n+            .await\n+            .unwrap();\n+        let pl_blockfile_id = pl_blockfile_writer.id();\n+\n+        let tokenizer = NgramTokenizer::new(3, 3, false).unwrap();\n+        let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer.clone());\n+\n+        index_writer\n+            .handle_batch([DocumentMutation::Create {\n+                offset_id: 1,\n+                new_document: \"pret\u00e9rito\",\n+            }])\n+            .unwrap();\n+\n+        index_writer.write_to_blockfiles().await.unwrap();\n+        let flusher = index_writer.commit().await.unwrap();\n+        flusher.flush().await.unwrap();\n+\n+        let pl_blockfile_reader = provider\n+            .read::<u32, &[u32]>(&pl_blockfile_id)\n+            .await\n+            .unwrap();\n+        let tokenizer = NgramTokenizer::new(3, 3, false).unwrap();\n+        let index_reader = FullTextIndexReader::new(pl_blockfile_reader, tokenizer);\n+\n+        let res = index_reader.search(\"pret\u00e9rito\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([1]));\n+\n+        let res = index_reader.search(\"bret\u00e9rito\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([]));\n+    }\n+\n     #[tokio::test]\n     async fn test_update_document() {\n         let tmp_dir = tempdir().unwrap();\n---\n\n\n---\n\nChoice D:\ngo/pkg/log/repository/log.go\n@@ -168,6 +168,13 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\t}\n \t}()\n \n+\t// NOTE(rescrv):  Only sourceInfo.IsSealed should be used on this struct.\n+\tvar sourceInfo log.Collection\n+\tsourceInfo, err = queriesWithTx.GetCollection(ctx, sourceCollectionID)\n+\tif err != nil {\n+\t\tsourceInfo.IsSealed = false\n+\t}\n+\n \tvar sourceBounds log.GetBoundsForCollectionRow\n \tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n@@ -207,6 +214,7 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\tID:                              targetCollectionID,\n \t\tRecordCompactionOffsetPosition:  int64(compactionOffset),\n \t\tRecordEnumerationOffsetPosition: int64(enumerationOffset),\n+\t\tIsSealed:                        sourceInfo.IsSealed,\n \t})\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n---\ngo/pkg/log/repository/log_test.go\n@@ -116,17 +116,17 @@ func (suite *LogTestSuite) TestUniqueConstraintPushLogs() {\n func (suite *LogTestSuite) TestSealedLogWontPush() {\n \tctx := context.Background()\n \tcollectionId := types.NewUniqueID()\n-\tparams := log.InsertCollectionParams {\n-\t\tID: collectionId.String(),\n+\tparams := log.InsertCollectionParams{\n+\t\tID:                              collectionId.String(),\n \t\tRecordEnumerationOffsetPosition: 1,\n-\t\tRecordCompactionOffsetPosition: 0,\n+\t\tRecordCompactionOffsetPosition:  0,\n \t}\n \t_, err := suite.lr.queries.InsertCollection(ctx, params)\n \tassert.NoError(suite.t, err, \"Initializing log should not fail.\")\n \t_, err = suite.lr.queries.SealLog(ctx, collectionId.String())\n \tassert.NoError(suite.t, err, \"Sealing log should not fail.\")\n \tvar isSealed bool\n-\t_, isSealed, err = suite.lr.InsertRecords(ctx, collectionId.String(), [][]byte{{1,2,3}})\n+\t_, isSealed, err = suite.lr.InsertRecords(ctx, collectionId.String(), [][]byte{{1, 2, 3}})\n \tassert.NoError(suite.t, err, \"Failed to push logs\")\n \tassert.True(suite.t, isSealed, \"Did not report was sealed\")\n }\n---\ngo/pkg/log/store/db/queries.sql.go\n@@ -138,6 +138,24 @@ func (q *Queries) GetBoundsForCollection(ctx context.Context, id string) (GetBou\n \treturn i, err\n }\n \n+const getCollection = `-- name: GetCollection :one\n+SELECT id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+FROM collection\n+WHERE id = $1\n+`\n+\n+func (q *Queries) GetCollection(ctx context.Context, id string) (Collection, error) {\n+\trow := q.db.QueryRow(ctx, getCollection, id)\n+\tvar i Collection\n+\terr := row.Scan(\n+\t\t&i.ID,\n+\t\t&i.RecordCompactionOffsetPosition,\n+\t\t&i.RecordEnumerationOffsetPosition,\n+\t\t&i.IsSealed,\n+\t)\n+\treturn i, err\n+}\n+\n const getCollectionForUpdate = `-- name: GetCollectionForUpdate :one\n SELECT id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n FROM collection\n@@ -239,17 +257,23 @@ func (q *Queries) GetTotalUncompactedRecordsCount(ctx context.Context) (int64, e\n }\n \n const insertCollection = `-- name: InsertCollection :one\n-INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position, is_sealed) values($1, $2, $3, $4) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n `\n \n type InsertCollectionParams struct {\n \tID                              string\n \tRecordEnumerationOffsetPosition int64\n \tRecordCompactionOffsetPosition  int64\n+\tIsSealed                        bool\n }\n \n func (q *Queries) InsertCollection(ctx context.Context, arg InsertCollectionParams) (Collection, error) {\n-\trow := q.db.QueryRow(ctx, insertCollection, arg.ID, arg.RecordEnumerationOffsetPosition, arg.RecordCompactionOffsetPosition)\n+\trow := q.db.QueryRow(ctx, insertCollection,\n+\t\targ.ID,\n+\t\targ.RecordEnumerationOffsetPosition,\n+\t\targ.RecordCompactionOffsetPosition,\n+\t\targ.IsSealed,\n+\t)\n \tvar i Collection\n \terr := row.Scan(\n \t\t&i.ID,\n---\ngo/pkg/log/store/queries/queries.sql\n@@ -4,6 +4,11 @@ FROM collection\n WHERE id = $1\n FOR UPDATE;\n \n+-- name: GetCollection :one\n+SELECT *\n+FROM collection\n+WHERE id = $1;\n+\n -- name: InsertRecord :copyfrom\n INSERT INTO record_log (collection_id, \"offset\", record, timestamp) values($1, $2, $3, $4);\n \n@@ -30,7 +35,7 @@ UPDATE collection set record_compaction_offset_position = $2 where id = $1;\n UPDATE collection set record_enumeration_offset_position = $2 where id = $1;\n \n -- name: InsertCollection :one\n-INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning *;\n+INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position, is_sealed) values($1, $2, $3, $4) returning *;\n \n -- name: PurgeRecords :exec\n DELETE FROM record_log r using collection c where r.collection_id = c.id and r.offset <= c.record_compaction_offset_position;\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nRelease Python 1.0.11\n\n---\n\nChoice A:\ndocs/docs.trychroma.com/components/header/header-nav.tsx\n@@ -1,17 +1,8 @@\n 'use client'\n \n import React from \"react\";\n-import Logo from \"@/components/header/logo\";\n-import ThemeToggle from \"@/components/header/theme-toggle\";\n-import GithubLink from \"@/components/header/github-link\";\n-import XLink from \"@/components/header/x-link\";\n-import DiscordLink from \"@/components/header/discord-link\";\n-import Link from \"next/link\";\n-import SearchBox from \"@/components/header/search-box\";\n-import UpdatesLink from \"@/components/header/updates-link\";\n import sidebarConfig from \"@/markdoc/content/sidebar-config\";\n import MenuItem from \"../sidebar/menu-item\";\n-import { useRouter } from \"next/router\";\n import { useParams } from \"next/navigation\";\n \n const HeaderNav: React.FC = () => {\n@@ -22,7 +13,7 @@ const HeaderNav: React.FC = () => {\n   );\n \n   return (\n-    <div className=\"flex items-center flex-shrink-0 px-5 border-b-[1px] dark:border-gray-700 \">\n+    <div className=\"flex items-center flex-shrink-0 px-5 border-b-[1px] dark:border-gray-700 w-full overflow-x-auto\">\n       {sidebarConfig.map((section) => (\n       <MenuItem\n       key={section.id}\n---\ndocs/docs.trychroma.com/components/markdoc/table.tsx\n@@ -13,7 +13,7 @@ export const Table = React.forwardRef<\n   React.HTMLAttributes<HTMLTableElement>\n >(({ ...props }, ref) => {\n   return (\n-    <div className=\"relative w-full overflow-auto rounded-md my-5 border-[0.5px] border-gray-300\">\n+    <div className=\"relative w-full overflow-auto rounded-md my-5 border-[0.5px] border-gray-300 dark:border-gray-700\">\n       <UITable ref={ref} className=\"m-0\" {...props} />\n     </div>\n   );\n---\ndocs/docs.trychroma.com/components/sidebar/menu-item.tsx\n@@ -10,7 +10,7 @@ const MenuItem: React.FC<{ section: AppSection; active: boolean }> = ({\n \n   return (\n     <Link\n-     className={`border-b-4 h-12 px-3 pt-3 pr-5 text-gray-700/80 ${active ? \"border-chroma-orange \" : \"border-transparent hover:border-gray-100\"} ${!section.disable && \"hover:text-gray-800\"} dark:text-gray-400/80 dark:hover:text-gray-300`}\n+     className={`border-b-4 h-12 px-3 pt-3 pr-5 text-gray-700/80 ${active ? \"border-chroma-orange \" : \"border-transparent hover:border-gray-100 dark:hover:border-gray-300\"} ${!section.disable && \"hover:text-gray-800\"} dark:text-gray-400/80 dark:hover:text-gray-300 text-nowrap`}\n       href={\n         section.disable\n           ? \"\"\n---\ndocs/docs.trychroma.com/components/ui/table.tsx\n@@ -58,7 +58,7 @@ const TableRow = React.forwardRef<\n   <tr\n     ref={ref}\n     className={cn(\n-      \"border-b transition-colors data-[state=selected]:bg-zinc-100 dark:data-[state=selected]:bg-zinc-800\",\n+      \"border-b transition-colors data-[state=selected]:bg-zinc-100 dark:data-[state=selected]:bg-zinc-800 dark:border-gray-700\",\n       className,\n     )}\n     {...props}\n---\n\n\n---\n\nChoice B:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.10\"\n+__version__ = \"1.0.11\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.10\"\n+      \"Default\": \"1.0.11\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice C:\n.github/actions/tilt/action.yaml\n@@ -10,13 +10,16 @@ runs:\n         curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v$TILT_VERSION/tilt.$TILT_VERSION.linux.x86_64.tar.gz | \\\n           tar -xzv -C /usr/local/bin tilt\n     - name: Set up kind\n-      id: kind\n-      uses: helm/kind-action@v1\n+      uses: Wandalen/wretry.action@v3.7.0\n       with:\n-        registry: true\n-        registry_name: my-registry\n-        registry_port: 5001\n-        registry_enable_delete: true\n+        action: helm/kind-action@v1\n+        attempt_limit: 3\n+        attempt_delay: 2000\n+        with: |\n+          registry: true\n+          registry_name: my-registry\n+          registry_port: 5001\n+          registry_enable_delete: true\n     - name: Add blacksmith registry mirror\n       shell: bash\n       run: |\n---\n\n\n---\n\nChoice D:\ngo/pkg/log/server/server.go\n@@ -8,7 +8,9 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb\"\n \t\"github.com/chroma-core/chroma/go/pkg/proto/logservicepb\"\n \t\"github.com/chroma-core/chroma/go/pkg/types\"\n+\ttrace_log \"github.com/pingcap/log\"\n \t\"google.golang.org/protobuf/proto\"\n+\t\"go.uber.org/zap\"\n )\n \n type logServer struct {\n@@ -59,6 +61,7 @@ func (s *logServer) ScoutLogs(ctx context.Context, req *logservicepb.ScoutLogsRe\n \tres = &logservicepb.ScoutLogsResponse{\n \t\tFirstUninsertedRecordOffset: int64(limit + 1),\n \t}\n+\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n \treturn\n }\n \n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - `tenant` and `database` were not being sent in `AsyncCollection.modify()`, resulting in auth issues (it was present as of https://github.com/chroma-core/chroma/pull/2982).\r\n- New functionality\r\n  - ...\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb-core/src/embeddings/DefaultEmbeddingFunction.ts\n@@ -6,7 +6,7 @@ import { IEmbeddingFunction } from \"./IEmbeddingFunction\";\n let TransformersApi: Promise<any>;\n \n interface StoredConfig {\n-  model_name: string;\n+  model: string;\n   revision: string;\n   quantized: boolean;\n }\n@@ -77,24 +77,24 @@ export class DefaultEmbeddingFunction implements IEmbeddingFunction {\n \n   getConfig(): StoredConfig {\n     return {\n-      model_name: this.model,\n+      model: this.model,\n       revision: this.revision,\n       quantized: this.quantized,\n     };\n   }\n \n   buildFromConfig(config: StoredConfig): DefaultEmbeddingFunction {\n     return new DefaultEmbeddingFunction({\n-      model: config.model_name,\n+      model: config.model,\n       revision: config.revision,\n       quantized: config.quantized,\n     });\n   }\n \n   validateConfigUpdate(oldConfig: StoredConfig, newConfig: StoredConfig): void {\n-    if (oldConfig.model_name !== newConfig.model_name) {\n+    if (oldConfig.model !== newConfig.model) {\n       throw new Error(\n-        \"DefaultEmbeddingFunction model_name cannot be changed after initialization.\",\n+        \"DefaultEmbeddingFunction model cannot be changed after initialization.\",\n       );\n     }\n   }\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\nChoice B:\nchromadb/api/models/AsyncCollection.py\n@@ -256,6 +256,8 @@ async def modify(\n             new_name=name,\n             new_metadata=metadata,\n             new_configuration=configuration,\n+            tenant=self.tenant,\n+            database=self.database,\n         )\n \n         self._update_model_after_modify_success(name, metadata, configuration)\n---\n\n\n---\n\nChoice C:\nrust/load/src/lib.rs\n@@ -1271,13 +1271,11 @@ impl LoadService {\n             for declared in declared {\n                 if let Entry::Vacant(entry) = running.entry(declared.uuid) {\n                     tracing::info!(\"spawning workload {}\", declared.uuid);\n-                    let root = tracing::info_span!(parent: None, \"workload\");\n                     let this = Arc::clone(self);\n                     let done = Arc::new(AtomicBool::new(false));\n                     let done_p = Arc::clone(&done);\n                     let inhibit = Arc::clone(&self.inhibit);\n                     let task = tokio::task::spawn(async move {\n-                        let _enter = root.enter();\n                         this.run_one_workload(done, inhibit, declared).await\n                     });\n                     entry.insert((done_p, task));\n@@ -1295,36 +1293,6 @@ impl LoadService {\n         let client = Arc::new(client(spec.connection.clone()).await);\n         let mut guac = Guacamole::new(spec.expires.timestamp_millis() as u64);\n         let mut next_op = Instant::now();\n-        let (tx, mut rx) = tokio::sync::mpsc::channel(1000);\n-        let _ = tx\n-            .send(tokio::spawn(async move { Ok::<(), Error>(()) }))\n-            .await;\n-        let this = Arc::clone(&self);\n-        let data_set = Arc::clone(&spec.data_set);\n-        let reaper = tokio::spawn(async move {\n-            while let Some(task) = rx.recv().await {\n-                if let Err(err) = task.await.unwrap() {\n-                    if !format!(\"{err:?}\").contains(\"429\") {\n-                        this.metrics.failed.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                        tracing::error!(\"workload task failed: {err:?}\");\n-                    } else {\n-                        this.metrics.limited.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                    }\n-                }\n-            }\n-        });\n \n         // Initialize the data set.\n         let data_set = Arc::clone(&spec.data_set);\n@@ -1408,30 +1376,45 @@ impl LoadService {\n                         .await\n                         .map_err(|err| Error::FailWorkload(err.to_string()))\n                     {\n-                        Ok(()) => Ok(()),\n+                        Ok(()) => (),\n                         Err(err) => {\n-                            if err.to_string().contains(\"invalid request: No results\") {\n+                            if format!(\"{err:?}\").contains(\"invalid request: No results\") {\n                                 this.metrics.no_results.add(\n                                     1,\n                                     &[KeyValue::new(\n                                         Key::from_static_str(\"data_set\"),\n                                         Value::from(data_set.name()),\n                                     )],\n                                 );\n-                                Ok(())\n+                                tracing::warn!(\"workload step no results: {err:?}\");\n+                            } else if !format!(\"{err:?}\").contains(\"429\") {\n+                                this.metrics.failed.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::error!(\"workload step failed: {err:?}\");\n                             } else {\n-                                Err(err)\n+                                this.metrics.limited.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::warn!(\"workload step rate limited: {err:?}\");\n                             }\n                         }\n-                    }\n+                    };\n                 };\n-                tx.send(tokio::spawn(fut)).await.unwrap();\n+                let span = tracing::info_span!(parent: None, \"step\", workload_uuid = %spec.uuid);\n+                tokio::spawn(fut.instrument(span));\n             }\n         }\n         // Not an error, just needs to show up in stdout.\n         tracing::error!(\"workload done: {}/{}\", spec.name, spec.description());\n-        drop(tx);\n-        reaper.await.unwrap();\n     }\n \n     fn load_persistent(&self) -> Result<(), Error> {\n---\n\n\n---\n\nChoice D:\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -140,21 +140,20 @@ impl GarbageCollector {\n             .as_ref()\n             .ok_or(GarbageCollectCollectionError::Uninitialized)?;\n \n-        let use_v1_orchestrator = match cleanup_mode {\n-            CleanupMode::DryRun | CleanupMode::Rename | CleanupMode::Delete => true,\n-            CleanupMode::DryRunV2 | CleanupMode::DeleteV2 => false,\n-        };\n-\n-        if use_v1_orchestrator {\n+        if cleanup_mode.is_v2() {\n             let orchestrator =\n-                crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+                crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n                     collection.id,\n                     collection.version_file_path,\n+                    collection.lineage_file_path,\n                     absolute_cutoff_time,\n                     self.sysdb_client.clone(),\n                     dispatcher.clone(),\n+                    system.clone(),\n                     self.storage.clone(),\n+                    self.root_manager.clone(),\n                     cleanup_mode,\n+                    2,\n                 );\n \n             let started_at = SystemTime::now();\n@@ -178,23 +177,19 @@ impl GarbageCollector {\n                     format!(\"{:?}\", cleanup_mode),\n                 )],\n             );\n+\n             return Ok(result);\n         }\n \n-        let orchestrator =\n-            crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n-                collection.id,\n-                collection.version_file_path,\n-                collection.lineage_file_path,\n-                absolute_cutoff_time,\n-                self.sysdb_client.clone(),\n-                dispatcher.clone(),\n-                system.clone(),\n-                self.storage.clone(),\n-                self.root_manager.clone(),\n-                cleanup_mode,\n-                2,\n-            );\n+        let orchestrator = crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+            collection.id,\n+            collection.version_file_path,\n+            absolute_cutoff_time,\n+            self.sysdb_client.clone(),\n+            dispatcher.clone(),\n+            self.storage.clone(),\n+            cleanup_mode,\n+        );\n \n         let started_at = SystemTime::now();\n         let result = orchestrator.run(system.clone()).await?;\n@@ -217,7 +212,6 @@ impl GarbageCollector {\n                 format!(\"{:?}\", cleanup_mode),\n             )],\n         );\n-\n         Ok(result)\n     }\n }\n@@ -360,9 +354,18 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 continue;\n             }\n \n-            if collection.lineage_file_path.is_some() {\n+            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n+                tenant_mode_overrides\n+                    .get(&collection.tenant)\n+                    .cloned()\n+                    .unwrap_or(self.default_cleanup_mode)\n+            } else {\n+                self.default_cleanup_mode\n+            };\n+\n+            if collection.lineage_file_path.is_some() && !cleanup_mode.is_v2() {\n                 tracing::debug!(\n-                    \"Skipping garbage collection for root of fork tree: {}\",\n+                    \"Skipping garbage collection for root of fork tree because GC v1 cannot handle fork trees: {}\",\n                     collection.id\n                 );\n                 num_skipped_jobs += 1;\n@@ -376,17 +379,6 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 collection.version_file_path\n             );\n \n-            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n-                tenant_mode_overrides\n-                    .get(&collection.tenant)\n-                    .cloned()\n-                    .unwrap_or(self.default_cleanup_mode)\n-            } else {\n-                self.default_cleanup_mode\n-            };\n-\n-            tracing::info!(\"Creating gc orchestrator for collection: {}\", collection.id);\n-\n             let instrumented_span = span!(parent: None, tracing::Level::INFO, \"Garbage collection job\", collection_id = ?collection.id, tenant_id = %collection.tenant, cleanup_mode = ?cleanup_mode);\n             instrumented_span.follows_from(Span::current());\n \n@@ -1011,6 +1003,26 @@ mod tests {\n         let (collection_in_delete_mode, database_name_in_delete_mode) =\n             collection_in_delete_mode_handle.await.unwrap();\n \n+        // Fork collection in delete mode to give it a lineage file (only GC v2 can handle fork trees)\n+        {\n+            let source_collection = sysdb\n+                .get_collections(Some(collection_in_delete_mode), None, None, None, None, 0)\n+                .await\n+                .unwrap();\n+            let source_collection = source_collection.first().unwrap();\n+\n+            sysdb\n+                .fork_collection(\n+                    collection_in_delete_mode,\n+                    source_collection.total_records_post_compaction,\n+                    source_collection.total_records_post_compaction,\n+                    CollectionUuid::new(),\n+                    \"test-fork\".to_string(),\n+                )\n+                .await\n+                .unwrap();\n+        }\n+\n         // Wait 1 second for cutoff time\n         tokio::time::sleep(Duration::from_secs(1)).await;\n \n---\nrust/garbage_collector/src/types.rs\n@@ -19,6 +19,12 @@ pub enum CleanupMode {\n     DeleteV2,\n }\n \n+impl CleanupMode {\n+    pub fn is_v2(&self) -> bool {\n+        matches!(self, CleanupMode::DryRunV2 | CleanupMode::DeleteV2)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub enum VersionStatus {\n     #[allow(dead_code)]\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - N/A\n- New functionality\n  - Implements blockfile prefetch by prefix\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/wal3/src/reader.rs\n@@ -141,7 +141,7 @@ impl LogReader {\n         }\n         fragments.retain(|f| f.limit > from);\n         fragments.sort_by_key(|f| f.start.offset());\n-        Ok(Self::post_process_fragments(fragments, limits))\n+        Ok(Self::post_process_fragments(fragments, from, limits))\n     }\n \n     /// Do a consistent stale read of the manifest.  If the read can be returned without I/O,\n@@ -174,10 +174,14 @@ impl LogReader {\n             .filter(|f| ranges_overlap(log_position_range, (f.start, f.limit)))\n             .cloned()\n             .collect::<Vec<_>>();\n-        Some(Self::post_process_fragments(fragments, limits))\n+        Some(Self::post_process_fragments(fragments, from, limits))\n     }\n \n-    fn post_process_fragments(mut fragments: Vec<Fragment>, limits: Limits) -> Vec<Fragment> {\n+    fn post_process_fragments(\n+        mut fragments: Vec<Fragment>,\n+        from: LogPosition,\n+        limits: Limits,\n+    ) -> Vec<Fragment> {\n         fragments.sort_by_key(|f| f.start.offset());\n         if let Some(max_files) = limits.max_files {\n             if fragments.len() as u64 > max_files {\n@@ -188,7 +192,7 @@ impl LogReader {\n         while fragments.len() > 1\n             // NOTE(rescrv):  We take the start of the last fragment, because if there are enough\n             // records without it we can pop.\n-            && fragments[fragments.len() - 1].start - fragments[0].start\n+            && fragments[fragments.len() - 1].start - from\n                 > limits.max_records.unwrap_or(u64::MAX)\n         {\n             tracing::info!(\n@@ -456,3 +460,143 @@ pub async fn read_fragment(\n         setsum,\n     }))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use setsum::Setsum;\n+\n+    use crate::{Fragment, FragmentSeqNo};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn post_process_fragments_uses_from_position_for_record_limits() {\n+        let fragments = vec![\n+            Fragment {\n+                path: \"fragment1\".to_string(),\n+                seq_no: FragmentSeqNo(1),\n+                start: LogPosition::from_offset(100),\n+                limit: LogPosition::from_offset(150),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+            Fragment {\n+                path: \"fragment2\".to_string(),\n+                seq_no: FragmentSeqNo(2),\n+                start: LogPosition::from_offset(150),\n+                limit: LogPosition::from_offset(200),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+            Fragment {\n+                path: \"fragment3\".to_string(),\n+                seq_no: FragmentSeqNo(3),\n+                start: LogPosition::from_offset(200),\n+                limit: LogPosition::from_offset(250),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+        ];\n+\n+        // Test case: from position is later than the first fragment's start\n+        // This tests the bug fix where we use 'from' instead of fragments[0].start\n+        let from = LogPosition::from_offset(125);\n+        let limits = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(100), // Set a limit that should trigger the record check\n+        };\n+\n+        let result = LogReader::post_process_fragments(fragments.clone(), from, limits);\n+\n+        // With the fix: last fragment start (200) - from (125) = 75 records\n+        // This should be under the 100 record limit, so all fragments should remain\n+        assert_eq!(result.len(), 3);\n+\n+        // Test case that would fail with the old bug:\n+        // If we were using fragments[0].start (100) instead of from (125),\n+        // then: last fragment start (200) - fragments[0].start (100) = 100 records\n+        // This would equal the limit, but the actual span from 'from' is only 75\n+        let limits_strict = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(74), // Just under the actual span from 'from'\n+        };\n+\n+        let result_strict =\n+            LogReader::post_process_fragments(fragments.clone(), from, limits_strict);\n+\n+        // With the fix: 200 - 125 = 75 > 74, so last fragment should be removed\n+        assert_eq!(result_strict.len(), 2);\n+        assert_eq!(result_strict[0].seq_no, FragmentSeqNo(1));\n+        assert_eq!(result_strict[1].seq_no, FragmentSeqNo(2));\n+    }\n+\n+    #[test]\n+    fn records_based_pruning_bug_from_commit_message() {\n+        // Test the exact scenario from the commit message:\n+        // - Fragments with LogPosition ranges [1, 101), [101, 201).\n+        // - Query for 75 records at offset 50 should fetch both fragments.\n+        // - Prior to this change only the first fragment was fetched.\n+\n+        let fragments = vec![\n+            Fragment {\n+                path: \"fragment1\".to_string(),\n+                seq_no: FragmentSeqNo(1),\n+                start: LogPosition::from_offset(1),\n+                limit: LogPosition::from_offset(101),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+            Fragment {\n+                path: \"fragment2\".to_string(),\n+                seq_no: FragmentSeqNo(2),\n+                start: LogPosition::from_offset(101),\n+                limit: LogPosition::from_offset(201),\n+                num_bytes: 1000,\n+                setsum: Setsum::default(),\n+            },\n+        ];\n+\n+        // Query for 75 records at offset 50\n+        let from = LogPosition::from_offset(50);\n+        let limits = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(75),\n+        };\n+\n+        let result = LogReader::post_process_fragments(fragments.clone(), from, limits);\n+\n+        // With the fix: both fragments should be returned\n+        // The calculation is: last fragment start (101) - from (50) = 51 records\n+        // Since 51 < 75, both fragments should remain\n+        assert_eq!(\n+            result.len(),\n+            2,\n+            \"Both fragments should be returned for 75 records from offset 50\"\n+        );\n+        assert_eq!(result[0].seq_no, FragmentSeqNo(1));\n+        assert_eq!(result[1].seq_no, FragmentSeqNo(2));\n+\n+        // Test the edge case where the old bug would have incorrectly calculated:\n+        // Old bug would use: fragments[1].start (101) - fragments[0].start (1) = 100 records\n+        // If max_records was 99, old code would incorrectly remove the second fragment\n+        let limits_edge_case = Limits {\n+            max_files: None,\n+            max_bytes: None,\n+            max_records: Some(50), // Just under the actual span from 'from' (51)\n+        };\n+\n+        let result_edge =\n+            LogReader::post_process_fragments(fragments.clone(), from, limits_edge_case);\n+\n+        // With the fix: 101 - 50 = 51 > 50, so the second fragment should be removed\n+        assert_eq!(\n+            result_edge.len(),\n+            1,\n+            \"Only first fragment should remain with 50 record limit\"\n+        );\n+        assert_eq!(result_edge[0].seq_no, FragmentSeqNo(1));\n+    }\n+}\n---\n\n\n---\n\nChoice B:\nrust/load/src/data_sets.rs\n@@ -836,12 +836,12 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            let key = uq.key.select_from_reference(self, offset);\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n             if !keys.contains(&key) {\n                 keys.push(key);\n             }\n---\n\n\n---\n\nChoice C:\nrust/blockstore/src/arrow/blockfile.rs\n@@ -471,6 +471,15 @@ impl<'me, K: ArrowReadableKey<'me> + Into<KeyWrapper>, V: ArrowReadableValue<'me\n         self.load_blocks(&target_block_ids).await;\n     }\n \n+    pub(crate) async fn load_blocks_for_prefixes(&self, prefixes: impl IntoIterator<Item = &str>) {\n+        let prefix_vec = prefixes.into_iter().collect();\n+        let target_block_ids = self\n+            .root\n+            .sparse_index\n+            .get_block_ids_for_prefixes(prefix_vec);\n+        self.load_blocks(&target_block_ids).await;\n+    }\n+\n     pub(crate) async fn get(\n         &'me self,\n         prefix: &str,\n---\nrust/blockstore/src/arrow/sparse_index.rs\n@@ -362,7 +362,47 @@ impl SparseIndexReader {\n         result_uuids\n     }\n \n-    pub(super) fn get_block_ids_range<'prefix, 'referred_data, PrefixRange>(\n+    pub(super) fn get_block_ids_for_prefixes(&self, mut prefixes: Vec<&str>) -> Vec<Uuid> {\n+        prefixes.sort();\n+        let mut result_uuids = Vec::new();\n+        let block_start = self.data.forward.iter();\n+        let block_end = block_start\n+            .clone()\n+            .skip(1)\n+            .map(|(delim, _)| match delim {\n+                SparseIndexDelimiter::Start => {\n+                    unreachable!(\"The start delimiter should only appear in the first block\")\n+                }\n+                SparseIndexDelimiter::Key(composite_key) => Some(composite_key.prefix.as_str()),\n+            })\n+            .chain([None]);\n+        let mut prefix_iter = prefixes.into_iter().peekable();\n+        for ((start_delim, block), end_prefix) in block_start.zip(block_end) {\n+            if let SparseIndexDelimiter::Key(CompositeKey {\n+                prefix: start_prefix,\n+                key: _,\n+            }) = start_delim\n+            {\n+                while let Some(&prefix) = prefix_iter.peek() {\n+                    if start_prefix.as_str() <= prefix {\n+                        break;\n+                    }\n+                    prefix_iter.next();\n+                }\n+            }\n+            if let Some(&prefix) = prefix_iter.peek() {\n+                if end_prefix.is_none() || end_prefix.is_some_and(|end_prefix| prefix <= end_prefix)\n+                {\n+                    result_uuids.push(block.id);\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+        result_uuids\n+    }\n+\n+    pub(super) fn get_block_ids_range<'prefix, PrefixRange>(\n         &self,\n         prefix_range: PrefixRange,\n     ) -> Vec<Uuid>\n---\nrust/blockstore/src/types/reader.rs\n@@ -125,6 +125,18 @@ impl<\n         }\n     }\n \n+    pub async fn load_blocks_for_prefixes<'prefix>(\n+        &self,\n+        prefixes: impl IntoIterator<Item = &'prefix str>,\n+    ) {\n+        match self {\n+            BlockfileReader::MemoryBlockfileReader(_reader) => unimplemented!(),\n+            BlockfileReader::ArrowBlockfileReader(reader) => {\n+                reader.load_blocks_for_prefixes(prefixes).await\n+            }\n+        }\n+    }\n+\n     pub async fn rank(\n         &'referred_data self,\n         prefix: &'referred_data str,\n---\n\n\n---\n\nChoice D:\nrust/storage/src/admissioncontrolleds3.rs\n@@ -206,10 +206,10 @@ impl AdmissionControlledS3Storage {\n         rate_limiter: Arc<RateLimitPolicy>,\n         key: String,\n         priority: Arc<AtomicUsize>,\n-        channel_receiver: tokio::sync::mpsc::Receiver<()>,\n+        channel_receiver: Option<tokio::sync::mpsc::Receiver<()>>,\n     ) -> Result<(Arc<Vec<u8>>, Option<ETag>), StorageError> {\n         // Acquire permit.\n-        let _permit = rate_limiter.enter(priority, Some(channel_receiver)).await;\n+        let _permit = rate_limiter.enter(priority, channel_receiver).await;\n         storage\n             .get_with_e_tag(&key)\n             .instrument(tracing::trace_span!(parent: Span::current(), \"S3 get\"))\n@@ -277,6 +277,9 @@ impl AdmissionControlledS3Storage {\n         key: &str,\n         options: GetOptions,\n     ) -> Result<(Arc<Vec<u8>>, Option<ETag>), StorageError> {\n+        if options.requires_strong_consistency {\n+            return self.strongly_consistent_get_with_e_tag(key, options).await;\n+        }\n         // If there is a duplicate request and the original request finishes\n         // before we look it up in the map below then we will end up with another\n         // request to S3.\n@@ -298,7 +301,7 @@ impl AdmissionControlledS3Storage {\n                         self.rate_limiter.clone(),\n                         key.to_string(),\n                         atomic_priority.clone(),\n-                        rx,\n+                        Some(rx),\n                     )\n                     .boxed()\n                     .shared();\n@@ -323,6 +326,22 @@ impl AdmissionControlledS3Storage {\n         res\n     }\n \n+    pub async fn strongly_consistent_get_with_e_tag(\n+        &self,\n+        key: &str,\n+        options: GetOptions,\n+    ) -> Result<(Arc<Vec<u8>>, Option<ETag>), StorageError> {\n+        let atomic_priority = Arc::new(AtomicUsize::new(options.priority.as_usize()));\n+        AdmissionControlledS3Storage::read_from_storage(\n+            self.storage.clone(),\n+            self.rate_limiter.clone(),\n+            key.to_string(),\n+            atomic_priority,\n+            None,\n+        )\n+        .await\n+    }\n+\n     async fn oneshot_upload(\n         &self,\n         key: &str,\n---\nrust/storage/src/lib.rs\n@@ -400,11 +400,20 @@ impl PutOptions {\n #[derive(Clone, Debug, Default)]\n pub struct GetOptions {\n     priority: StorageRequestPriority,\n+    requires_strong_consistency: bool,\n }\n \n impl GetOptions {\n     pub fn new(priority: StorageRequestPriority) -> Self {\n-        Self { priority }\n+        Self {\n+            priority,\n+            requires_strong_consistency: false,\n+        }\n+    }\n+\n+    pub fn with_strong_consistency(mut self) -> Self {\n+        self.requires_strong_consistency = true;\n+        self\n     }\n }\n \n---\nrust/storage/src/s3.rs\n@@ -310,6 +310,7 @@ impl S3Storage {\n         self.get_with_e_tag(key).await.map(|(buf, _)| buf)\n     }\n \n+    /// Perform a strongly consistent get and return the e_tag.\n     #[tracing::instrument(skip(self))]\n     pub async fn get_with_e_tag(\n         &self,\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nCloses #4620\n\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Adds support for `cors_allow_origins: [\"*\"]` and prevents Chroma from panicking when users supply a wildcard \n\n## Test plan\n\n_How are these changes tested?_\n\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/index/src/fulltext/types.rs\n@@ -313,7 +313,7 @@ impl<'me> FullTextIndexReader<'me> {\n         }\n \n         // Retrieve posting lists for each token.\n-        let posting_lists = futures::stream::iter(tokens)\n+        let posting_lists = futures::stream::iter(&tokens)\n             .then(|token| async move {\n                 let positional_posting_list = self\n                     .posting_lists_blockfile_reader\n@@ -355,39 +355,37 @@ impl<'me> FullTextIndexReader<'me> {\n \n             if min_doc_id == max_doc_id {\n                 // All tokens appear in the same document, so check positional alignment.\n-                let mut positions_per_posting_list = Vec::with_capacity(num_tokens);\n-                for (i, posting_list) in posting_lists.iter().enumerate() {\n-                    let (_, _, positions) = posting_list[pointers[i]];\n-                    positions_per_posting_list.push(positions);\n-                }\n-\n-                // Adjust positions and check for sequential alignment.\n                 // Imagine you're searching for \"brown fox\" over the document \"the quick brown fox\".\n                 // The positions for \"brown\" are {2} and for \"fox\" are {3}. The adjusted positions after subtracting the token's position in the query are {2} for \"brown\" and 3 - 1 = {2} for \"fox\".\n                 // The intersection of these two sets is non-empty, so we know that the two tokens are adjacent.\n+                // In practice, we must adjust the positions by using the byte offset of the token rather than the token's position in the query, because Unicode characters can be variable-length and the posting lists are stored as byte offsets.\n+                // E.x. imagine we're using a 1-gram tokenizer and processing the string \"\u00e9m\". The token positions are {0, 1}, but the byte offsets are {0, 2} (because \u00e9 is two bytes long).\n \n                 // Seed with the positions of the first token.\n-                let mut adjusted_positions = positions_per_posting_list[0]\n+                let mut adjusted = posting_lists[0][pointers[0]]\n+                    .2\n                     .iter()\n                     .copied()\n                     .collect::<HashSet<_>>();\n \n-                for (offset, positions_set) in positions_per_posting_list.iter().enumerate().skip(1)\n-                {\n-                    let positions_set = positions_set\n+                for i in 1..num_tokens {\n+                    let byte_delta_from_first_token =\n+                        tokens[i].offset_from as u32 - tokens[0].offset_from as u32;\n+                    let positions = &posting_lists[i][pointers[i]].2;\n+\n+                    let shifted = positions\n                         .iter()\n-                        // (We can discard any positions that the token appears at before the current offset)\n-                        .filter_map(|&p| p.checked_sub(offset as u32))\n+                        .filter_map(|&p| p.checked_sub(byte_delta_from_first_token))\n                         .collect::<HashSet<_>>();\n-                    adjusted_positions = &adjusted_positions & &positions_set;\n \n-                    if adjusted_positions.is_empty() {\n+                    adjusted = &adjusted & &shifted;\n+                    if adjusted.is_empty() {\n                         break;\n                     }\n                 }\n \n                 // All tokens are sequential\n-                if !adjusted_positions.is_empty() {\n+                if !adjusted.is_empty() {\n                     results.insert(min_doc_id);\n                 }\n \n@@ -991,6 +989,47 @@ mod tests {\n         assert_eq!(res, RoaringBitmap::from([1]));\n     }\n \n+    #[tokio::test]\n+    async fn test_document_with_multibyte_characters() {\n+        let tmp_dir = tempdir().unwrap();\n+        let storage = Storage::Local(LocalStorage::new(tmp_dir.path().to_str().unwrap()));\n+        let block_cache = new_cache_for_test();\n+        let root_cache = new_cache_for_test();\n+        let provider = BlockfileProvider::new_arrow(storage, 1024 * 1024, block_cache, root_cache);\n+        let pl_blockfile_writer = provider\n+            .write::<u32, Vec<u32>>(BlockfileWriterOptions::default().ordered_mutations())\n+            .await\n+            .unwrap();\n+        let pl_blockfile_id = pl_blockfile_writer.id();\n+\n+        let tokenizer = NgramTokenizer::new(3, 3, false).unwrap();\n+        let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer.clone());\n+\n+        index_writer\n+            .handle_batch([DocumentMutation::Create {\n+                offset_id: 1,\n+                new_document: \"pret\u00e9rito\",\n+            }])\n+            .unwrap();\n+\n+        index_writer.write_to_blockfiles().await.unwrap();\n+        let flusher = index_writer.commit().await.unwrap();\n+        flusher.flush().await.unwrap();\n+\n+        let pl_blockfile_reader = provider\n+            .read::<u32, &[u32]>(&pl_blockfile_id)\n+            .await\n+            .unwrap();\n+        let tokenizer = NgramTokenizer::new(3, 3, false).unwrap();\n+        let index_reader = FullTextIndexReader::new(pl_blockfile_reader, tokenizer);\n+\n+        let res = index_reader.search(\"pret\u00e9rito\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([1]));\n+\n+        let res = index_reader.search(\"bret\u00e9rito\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([]));\n+    }\n+\n     #[tokio::test]\n     async fn test_update_document() {\n         let tmp_dir = tempdir().unwrap();\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/repository/log.go\n@@ -153,17 +153,6 @@ func (r *LogRepository) PullRecords(ctx context.Context, collectionId string, of\n }\n \n func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID string, targetCollectionID string) (compactionOffset uint64, enumerationOffset uint64, err error) {\n-\tfor retries := 0; retries < 3; retries++ {\n-\t\tcompactionOffset, enumerationOffset, err = r.innerForkRecords(ctx, sourceCollectionID, targetCollectionID)\n-\t\tif err == nil {\n-\t\t\treturn\n-\t\t}\n-\t\ttime.Sleep(time.Millisecond * 100 * (1 << retries))\n-\t}\n-\treturn\n-}\n-\n-func (r *LogRepository) innerForkRecords(ctx context.Context, sourceCollectionID string, targetCollectionID string) (compactionOffset uint64, enumerationOffset uint64, err error) {\n \tvar tx pgx.Tx\n \ttx, err = r.conn.BeginTx(ctx, pgx.TxOptions{})\n \tif err != nil {\n@@ -179,8 +168,7 @@ func (r *LogRepository) innerForkRecords(ctx context.Context, sourceCollectionID\n \t\t}\n \t}()\n \n-\tvar sourceBounds log.GetBoundsForCollectionRow\n-\tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n+\tsourceBounds, err := queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in getting compaction and enumeration offset for source collection\", zap.Error(err), zap.String(\"collectionId\", sourceCollectionID))\n \t\treturn\n@@ -193,35 +181,34 @@ func (r *LogRepository) innerForkRecords(ctx context.Context, sourceCollectionID\n \t\ttrace_log.Error(\"Error forking log record\", zap.String(\"sourceCollectionID\", sourceCollectionID))\n \t\treturn\n \t}\n-\t_, err = queriesWithTx.InsertCollection(ctx, log.InsertCollectionParams{\n-\t\tID:                              targetCollectionID,\n-\t\tRecordCompactionOffsetPosition:  int64(sourceBounds.RecordCompactionOffsetPosition),\n-\t\tRecordEnumerationOffsetPosition: int64(sourceBounds.RecordEnumerationOffsetPosition),\n-\t})\n+\ttargetBounds, err := queriesWithTx.GetMinimumMaximumOffsetForCollection(ctx, targetCollectionID)\n \tif err != nil {\n-\t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n+\t\ttrace_log.Error(\"Error in deriving compaction and enumeration offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n \t\treturn\n \t}\n-\tvar targetBounds log.GetMinimumMaximumOffsetForCollectionRow\n-\ttargetBounds, err = queriesWithTx.GetMinimumMaximumOffsetForCollection(ctx, targetCollectionID)\n-\tif err != nil {\n-\t\ttrace_log.Error(\"Error in getting minimax for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n-\t\treturn\n+\n+\tif targetBounds.MinOffset == 0 {\n+\t\t// Either the source collection is not compacted yet or no log is forked\n+\t\tcompactionOffset = uint64(sourceBounds.RecordCompactionOffsetPosition)\n+\t} else {\n+\t\t// Some logs are forked, the min offset is guaranteed to be larger than source compaction offset\n+\t\tcompactionOffset = uint64(targetBounds.MinOffset - 1)\n \t}\n-\tif targetBounds.MinOffset > 0 && targetBounds.MinOffset != sourceBounds.RecordCompactionOffsetPosition + 1 {\n-\t\ttrace_log.Error(\"Race condition: Someone adjusted records during our transaction\",\n-\t\t\tzap.String(\"collectionId\", targetCollectionID),\n-\t\t\tzap.Int64(\"MinOffset\", targetBounds.MinOffset),\n-\t\t\tzap.Int64(\"CompactionOffset+1\", sourceBounds.RecordCompactionOffsetPosition + 1))\n-\t\terr = errors.New(\"concurrent updates caused fork to fail on compaction offset\")\n-\t\treturn\n+\tif targetBounds.MaxOffset == 0 {\n+\t\t// Either the source collection is empty or no log is forked\n+\t\tenumerationOffset = uint64(sourceBounds.RecordEnumerationOffsetPosition)\n+\t} else {\n+\t\t// Some logs are forked. The max offset is the enumeration offset\n+\t\tenumerationOffset = uint64(targetBounds.MaxOffset)\n \t}\n-\tif targetBounds.MaxOffset > 0 && targetBounds.MaxOffset != sourceBounds.RecordEnumerationOffsetPosition {\n-\t\ttrace_log.Error(\"Race condition: Someone adjusted records during our transaction\",\n-\t\t\tzap.String(\"collectionId\", targetCollectionID),\n-\t\t\tzap.Int64(\"MaxOffset\", targetBounds.MaxOffset),\n-\t\t\tzap.Int64(\"EnumerationOffset\", sourceBounds.RecordEnumerationOffsetPosition))\n-\t\terr = errors.New(\"concurrent updates caused fork to fail on enumeration offset\")\n+\n+\t_, err = queriesWithTx.InsertCollection(ctx, log.InsertCollectionParams{\n+\t\tID:                              targetCollectionID,\n+\t\tRecordCompactionOffsetPosition:  int64(compactionOffset),\n+\t\tRecordEnumerationOffsetPosition: int64(enumerationOffset),\n+\t})\n+\tif err != nil {\n+\t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n \t\treturn\n \t}\n \treturn\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/server.rs\n@@ -290,14 +290,23 @@ impl FrontendServer {\n         if let Some(cors_allow_origins) = cors_allow_origins {\n             let origins = cors_allow_origins\n                 .into_iter()\n-                .map(|origin| origin.parse().unwrap())\n+                .map(|origin| {\n+                    origin\n+                        .parse()\n+                        .unwrap_or_else(|_| panic!(\"Invalid origin: {}\", origin))\n+                })\n                 .collect::<Vec<_>>();\n \n-            let cors = CorsLayer::new()\n-                .allow_origin(origins)\n+            let mut cors_builder = CorsLayer::new()\n                 .allow_headers(tower_http::cors::Any)\n                 .allow_methods(tower_http::cors::Any);\n-            app = app.layer(cors);\n+            if origins.len() == 1 && origins[0] == \"*\" {\n+                cors_builder = cors_builder.allow_origin(tower_http::cors::Any);\n+            } else {\n+                cors_builder = cors_builder.allow_origin(origins);\n+            }\n+\n+            app = app.layer(cors_builder);\n         }\n \n         // TODO: tracing\n@@ -1972,6 +1981,54 @@ mod tests {\n         assert_eq!(allow_headers.unwrap(), \"*\");\n     }\n \n+    #[tokio::test]\n+    async fn test_cors_wildcard() {\n+        let registry = Registry::new();\n+        let system = System::new();\n+\n+        let port = random_port::PortPicker::new().pick().unwrap();\n+\n+        let mut config = FrontendServerConfig::single_node_default();\n+        config.port = port;\n+        config.cors_allow_origins = Some(vec![\"*\".to_string()]);\n+\n+        let frontend = Frontend::try_from_config(&(config.clone().frontend, system), &registry)\n+            .await\n+            .unwrap();\n+        let app = FrontendServer::new(\n+            config,\n+            frontend,\n+            vec![],\n+            Arc::new(()),\n+            Arc::new(()),\n+            System::new(),\n+        );\n+        tokio::task::spawn(async move {\n+            app.run().await;\n+        });\n+\n+        let client = reqwest::Client::new();\n+        let res = client\n+            .request(\n+                reqwest::Method::OPTIONS,\n+                format!(\"http://localhost:{}/api/v2/heartbeat\", port),\n+            )\n+            .header(\"Origin\", \"http://localhost:3000\")\n+            .send()\n+            .await\n+            .unwrap();\n+        assert_eq!(res.status(), 200);\n+\n+        let allow_origin = res.headers().get(\"Access-Control-Allow-Origin\");\n+        assert_eq!(allow_origin.unwrap(), \"*\");\n+\n+        let allow_methods = res.headers().get(\"Access-Control-Allow-Methods\");\n+        assert_eq!(allow_methods.unwrap(), \"*\");\n+\n+        let allow_headers = res.headers().get(\"Access-Control-Allow-Headers\");\n+        assert_eq!(allow_headers.unwrap(), \"*\");\n+    }\n+\n     #[tokio::test]\n     async fn test_defaults_to_json_content_type() {\n         let port = test_server().await;\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.9\"\n+__version__ = \"1.0.10\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.8\"\n+      \"Default\": \"1.0.10\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.8\"\n+chroma_version                  = \"1.0.10\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.8\"\n+  default     = \"1.0.10\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.8\"\n+chroma_version                  = \"1.0.10\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.8\"\n+  default     = \"1.0.10\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - By default Chroma Cloud allows keepalive (we use HAProxy and it is on by default) and uses the http-request timeout if the keepalive timeout is not set - which for us is 50s. This raises the keepalive timeout from default 5s to < the haproxy timeout. We choose to not make this configurable for now, since the bottleneck will be the downstream config. This at least allows reusing the connection in a larger window\r\n- New functionality\r\n  - None\r\n\r\n## Test plan\r\n_How are these changes tested?_\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nNone\n\n---\n\nChoice A:\ngo/pkg/log/server/server.go\n@@ -162,6 +162,15 @@ func (s *logServer) InspectDirtyLog(ctx context.Context, req *logservicepb.Inspe\n \treturn\n }\n \n+func (s *logServer) SealLog(ctx context.Context, req *logservicepb.SealLogRequest) (res *logservicepb.SealLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n+\n+func (s *logServer) MigrateLog(ctx context.Context, req *logservicepb.MigrateLogRequest) (res *logservicepb.MigrateLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n \n func NewLogServer(lr *repository.LogRepository) logservicepb.LogServiceServer {\n \treturn &logServer{\n---\nidl/chromadb/proto/logservice.proto\n@@ -96,6 +96,22 @@ message InspectDirtyLogResponse {\n   repeated string markers = 1;\n }\n \n+message SealLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message SealLogResponse {\n+  // Empty\n+}\n+\n+message MigrateLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message MigrateLogResponse {\n+  // Empty\n+}\n+\n service LogService {\n   rpc PushLogs(PushLogsRequest) returns (PushLogsResponse) {}\n   rpc ScoutLogs(ScoutLogsRequest) returns (ScoutLogsResponse) {}\n@@ -104,5 +120,11 @@ service LogService {\n   rpc GetAllCollectionInfoToCompact(GetAllCollectionInfoToCompactRequest) returns (GetAllCollectionInfoToCompactResponse) {}\n   rpc UpdateCollectionLogOffset(UpdateCollectionLogOffsetRequest) returns (UpdateCollectionLogOffsetResponse) {}\n   rpc PurgeDirtyForCollection(PurgeDirtyForCollectionRequest) returns (PurgeDirtyForCollectionResponse) {}\n+  // RPC endpoints to expose for operator debuggability.\n+  // This endpoint must route to the rust log service.\n   rpc InspectDirtyLog(InspectDirtyLogRequest) returns (InspectDirtyLogResponse) {}\n+  // This endpoint must route to the go log service.\n+  rpc SealLog(SealLogRequest) returns (SealLogResponse) {}\n+  // This endpoint must route to the rust log service.\n+  rpc MigrateLog(MigrateLogRequest) returns (MigrateLogResponse) {}\n }\n---\nrust/log-service/src/lib.rs\n@@ -16,9 +16,10 @@ use chroma_storage::Storage;\n use chroma_types::chroma_proto::{\n     log_service_server::LogService, CollectionInfo, GetAllCollectionInfoToCompactRequest,\n     GetAllCollectionInfoToCompactResponse, InspectDirtyLogRequest, InspectDirtyLogResponse,\n-    LogRecord, OperationRecord, PullLogsRequest, PullLogsResponse, PurgeDirtyForCollectionRequest,\n-    PurgeDirtyForCollectionResponse, PushLogsRequest, PushLogsResponse, ScoutLogsRequest,\n-    ScoutLogsResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n+    LogRecord, MigrateLogRequest, MigrateLogResponse, OperationRecord, PullLogsRequest,\n+    PullLogsResponse, PurgeDirtyForCollectionRequest, PurgeDirtyForCollectionResponse,\n+    PushLogsRequest, PushLogsResponse, ScoutLogsRequest, ScoutLogsResponse, SealLogRequest,\n+    SealLogResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n };\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n@@ -1230,6 +1231,24 @@ impl LogService for LogServer {\n         }\n         Ok(Response::new(InspectDirtyLogResponse { markers }))\n     }\n+\n+    async fn seal_log(\n+        &self,\n+        _request: Request<SealLogRequest>,\n+    ) -> Result<Response<SealLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do sealing\",\n+        ))\n+    }\n+\n+    async fn migrate_log(\n+        &self,\n+        _request: Request<MigrateLogRequest>,\n+    ) -> Result<Response<MigrateLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do migrating yet\",\n+        ))\n+    }\n }\n \n fn parquet_to_records(parquet: Arc<Vec<u8>>) -> Result<Vec<(LogPosition, Vec<u8>)>, Status> {\n---\n\n\n---\n\nChoice B:\nrust/log/src/test.rs\n@@ -124,7 +124,7 @@ pub trait LoadFromGenerator<L: LogGenerator> {\n impl<L: LogGenerator + Send + 'static> LoadFromGenerator<L> for TestDistributedSegment {\n     async fn populate_with_generator(&mut self, log_count: usize, generator: L) {\n         let ids: Vec<_> = (1..=log_count).collect();\n-        for chunk in ids.chunks(100) {\n+        for chunk in ids.chunks(10_000) {\n             self.compact_log(\n                 generator.generate_chunk(chunk.iter().copied()),\n                 chunk\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/impls/utils.rs\n@@ -8,6 +8,8 @@ use chroma_types::{\n pub(crate) enum ToRecordsError {\n     #[error(\"Inconsistent number of IDs, embeddings, documents, URIs and metadatas\")]\n     InconsistentLength,\n+    #[error(\"Empty ID, ID must have at least one character\")]\n+    EmptyId,\n }\n \n impl ChromaError for ToRecordsError {\n@@ -47,6 +49,9 @@ pub(crate) fn to_records<\n     let mut records = Vec::with_capacity(len);\n \n     for id in ids {\n+        if id.is_empty() {\n+            return Err(ToRecordsError::EmptyId);\n+        }\n         let embedding = embeddings_iter.next().flatten();\n         let document = documents_iter.next().flatten();\n         let uri = uris_iter.next().flatten();\n@@ -87,3 +92,59 @@ pub(crate) fn to_records<\n \n     Ok((records, total_bytes))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use chroma_types::Operation;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_to_records_empty_id() {\n+        let ids = vec![String::from(\"\")];\n+        let embeddings = vec![Some(vec![1.0, 2.0, 3.0])];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(ids, Some(embeddings), None, None, None, Operation::Add);\n+        assert!(matches!(result, Err(ToRecordsError::EmptyId)));\n+    }\n+\n+    #[test]\n+    fn test_normal_ids() {\n+        let ids = vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\")];\n+        let embeddings = vec![\n+            Some(vec![1.0, 2.0, 3.0]),\n+            Some(vec![4.0, 5.0, 6.0]),\n+            Some(vec![7.0, 8.0, 9.0]),\n+        ];\n+        let documents = vec![\n+            Some(String::from(\"document 1\")),\n+            Some(String::from(\"document 2\")),\n+            Some(String::from(\"document 3\")),\n+        ];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(\n+            ids,\n+            Some(embeddings),\n+            Some(documents),\n+            None,\n+            None,\n+            Operation::Add,\n+        );\n+        assert!(result.is_ok());\n+        let records = result.unwrap().0;\n+        assert_eq!(records.len(), 3);\n+        assert_eq!(records[0].id, \"1\");\n+        assert_eq!(records[1].id, \"2\");\n+        assert_eq!(records[2].id, \"3\");\n+        assert_eq!(records[0].embedding, Some(vec![1.0, 2.0, 3.0]));\n+        assert_eq!(records[1].embedding, Some(vec![4.0, 5.0, 6.0]));\n+        assert_eq!(records[2].embedding, Some(vec![7.0, 8.0, 9.0]));\n+        assert_eq!(records[0].document, Some(String::from(\"document 1\")));\n+        assert_eq!(records[1].document, Some(String::from(\"document 2\")));\n+        assert_eq!(records[2].document, Some(String::from(\"document 3\")));\n+    }\n+}\n---\n\n\n---\n\nChoice D:\nchromadb/api/async_fastapi.py\n@@ -123,10 +123,12 @@ def _get_client(self) -> httpx.AsyncClient:\n                 + \" (https://github.com/chroma-core/chroma)\"\n             )\n \n+            limits = httpx.Limits(max_keepalive_connections=self.keepalive_secs)\n             self._clients[loop_hash] = httpx.AsyncClient(\n                 timeout=None,\n                 headers=headers,\n                 verify=self._settings.chroma_server_ssl_verify or False,\n+                limits=limits,\n             )\n \n         return self._clients[loop_hash]\n---\nchromadb/api/base_http_client.py\n@@ -13,6 +13,7 @@\n class BaseHTTPClient:\n     _settings: Settings\n     _max_batch_size: int = -1\n+    keepalive_secs: int = 40\n \n     @staticmethod\n     def _validate_host(host: str) -> None:\n---\nchromadb/api/fastapi.py\n@@ -69,7 +69,8 @@ def __init__(self, system: System):\n             default_api_path=system.settings.chroma_server_api_default_path,\n         )\n \n-        self._session = httpx.Client(timeout=None)\n+        limits = httpx.Limits(max_keepalive_connections=self.keepalive_secs)\n+        self._session = httpx.Client(timeout=None, limits=limits)\n \n         self._header = system.settings.chroma_server_headers or {}\n         self._header[\"Content-Type\"] = \"application/json\"\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis PR fixes open dependabot problems in the Rust codebase.\n\n## Test plan\n\nCI\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nCargo.lock\n@@ -4508,7 +4508,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34\"\n dependencies = [\n  \"cfg-if\",\n- \"windows-targets 0.48.5\",\n+ \"windows-targets 0.52.6\",\n ]\n \n [[package]]\n@@ -5147,16 +5147,17 @@ checksum = \"830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3\"\n \n [[package]]\n name = \"numpy\"\n-version = \"0.23.0\"\n+version = \"0.24.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b94caae805f998a07d33af06e6a3891e38556051b8045c615470a71590e13e78\"\n+checksum = \"a7cfbf3f0feededcaa4d289fe3079b03659e85c5b5a177f4ba6fb01ab4fb3e39\"\n dependencies = [\n  \"libc\",\n  \"ndarray\",\n  \"num-complex\",\n  \"num-integer\",\n  \"num-traits\",\n  \"pyo3\",\n+ \"pyo3-build-config\",\n  \"rustc-hash 2.0.0\",\n ]\n \n@@ -6035,9 +6036,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7778bffd85cf38175ac1f545509665d0b9b92a198ca7941f131f85f7a4f9a872\"\n+checksum = \"e5203598f366b11a02b13aa20cab591229ff0a89fd121a308a5df751d5fc9219\"\n dependencies = [\n  \"cfg-if\",\n  \"indoc\",\n@@ -6053,29 +6054,29 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-build-config\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94f6cbe86ef3bf18998d9df6e0f3fc1050a8c5efa409bf712e661a4366e010fb\"\n+checksum = \"99636d423fa2ca130fa5acde3059308006d46f98caac629418e53f7ebb1e9999\"\n dependencies = [\n  \"once_cell\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"pyo3-ffi\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e9f1b4c431c0bb1c8fb0a338709859eed0d030ff6daa34368d3b152a63dfdd8d\"\n+checksum = \"78f9cf92ba9c409279bc3305b5409d90db2d2c22392d443a87df3a1adad59e33\"\n dependencies = [\n  \"libc\",\n  \"pyo3-build-config\",\n ]\n \n [[package]]\n name = \"pyo3-macros\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbc2201328f63c4710f68abdf653c89d8dbc2858b88c5d88b0ff38a75288a9da\"\n+checksum = \"0b999cb1a6ce21f9a6b147dcf1be9ffedf02e0043aec74dc390f3007047cecd9\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"pyo3-macros-backend\",\n@@ -6085,9 +6086,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-macros-backend\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fca6726ad0f3da9c9de093d6f116a93c1a38e417ed73bf138472cf4064f72028\"\n+checksum = \"822ece1c7e1012745607d5cf0bcb2874769f0f7cb34c4cde03b9358eb9ef911a\"\n dependencies = [\n  \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n@@ -7308,7 +7309,7 @@ version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"03c3c6b7927ffe7ecaa769ee0e3994da3b8cafc8f444578982c83ecb161af917\"\n dependencies = [\n- \"heck 0.4.1\",\n+ \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n  \"syn 2.0.101\",\n@@ -7866,9 +7867,9 @@ checksum = \"55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.16\"\n+version = \"0.13.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61c41af27dd6d1e27b1b16b489db798443478cef1f06a660c96db617ba5de3b1\"\n+checksum = \"e502f78cdbb8ba4718f566c418c52bc729126ffd16baee5baa718cf25dd5a69a\"\n \n [[package]]\n name = \"tempfile\"\n---\nCargo.toml\n@@ -44,6 +44,7 @@ flatbuffers = \"24.3.25\"\n futures = \"0.3\"\n futures-core = \"0.3\"\n lazy_static = { version = \"1.4\" }\n+lexical-core = \"1.0\"\n num_cpus = \"1.16.0\"\n opentelemetry = { version = \"0.27.0\", default-features = false, features = [\"trace\", \"metrics\"] }\n opentelemetry-otlp = { version = \"0.27\", features = [\"http-proto\"] }\n@@ -78,7 +79,7 @@ utoipa = { version = \"5.0.0\", features = [\"macros\", \"axum_extras\", \"debug\", \"uui\n sqlx = { version = \"0.8.3\", features = [\"runtime-tokio\", \"sqlite\"] }\n sha2 = \"0.10.8\"\n md5 = \"0.7.0\"\n-pyo3 = { version = \"0.23.3\", features = [\"abi3-py39\"] }\n+pyo3 = { version = \"0.24.1\", features = [\"abi3-py39\"] }\n http = \"1.1.0\"\n tower-http = { version = \"0.6.2\", features = [\"trace\", \"cors\"] }\n bytemuck = \"1.21.0\"\n@@ -125,6 +126,7 @@ shuttle = \"0.7.1\"\n tempfile = \"3.14.0\"\n itertools = \"0.13.0\"\n serial_test = \"3.2.0\"\n+zip = \"2.3.0\"\n \n [profile.dev]\n # Significantly reduces compile times\n---\nrust/python_bindings/Cargo.toml\n@@ -13,7 +13,7 @@ async-trait = { workspace = true }\n pyo3 = { workspace = true }\n tokio = { workspace = true }\n uuid = { workspace = true }\n-numpy = \"0.23.0\"\n+numpy = \"0.24.0\"\n serde = { workspace = true }\n serde_json = { workspace = true }\n thiserror = { workspace = true }\n---\n\n\n---\n\nChoice B:\nrust/wal3/src/writer.rs\n@@ -518,9 +518,7 @@ impl OnceLogWriter {\n             log_position,\n             messages,\n         );\n-        let fut2 = self\n-            .mark_dirty\n-            .mark_dirty(log_position + messages_len, messages_len);\n+        let fut2 = self.mark_dirty.mark_dirty(log_position, messages_len);\n         let (res1, res2) = futures::future::join(fut1, fut2).await;\n         res2?;\n         let (path, setsum, num_bytes) = res1?;\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/quota/mod.rs\n@@ -337,7 +337,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n         m.insert(UsageType::RegexPatternLength, 0);\n-        m.insert(UsageType::NumForks, 10000);\n+        m.insert(UsageType::NumForks, 256);\n         m\n     };\n }\n---\n\n\n---\n\nChoice D:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nI'm adding a test.\n\n## Test plan\n\nCI; new test passes locally.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1138,6 +1138,7 @@ func (tc *Catalog) createSegmentImpl(txCtx context.Context, createSegment *model\n \t\tType:         createSegment.Type,\n \t\tScope:        createSegment.Scope,\n \t\tTs:           ts,\n+\t\tFilePaths:    createSegment.FilePaths,\n \t}\n \terr := tc.metaDomain.SegmentDb(txCtx).Insert(dbSegment)\n \tif err != nil {\n@@ -2000,11 +2001,11 @@ func (tc *Catalog) getNumberOfActiveVersions(versionFilePb *coordinatorpb.Collec\n }\n \n func (tc *Catalog) getOldestVersionTs(versionFilePb *coordinatorpb.CollectionVersionFile) time.Time {\n-\tif versionFilePb.GetVersionHistory() == nil || len(versionFilePb.GetVersionHistory().Versions) <= 1 {\n+\tif versionFilePb.GetVersionHistory() == nil || len(versionFilePb.GetVersionHistory().Versions) == 0 {\n \t\t// Returning a zero timestamp that represents an unset value.\n \t\treturn time.Time{}\n \t}\n-\toldestVersionTs := versionFilePb.GetVersionHistory().Versions[1].CreatedAtSecs\n+\toldestVersionTs := versionFilePb.GetVersionHistory().Versions[0].CreatedAtSecs\n \n \treturn time.Unix(oldestVersionTs, 0)\n }\n@@ -2041,7 +2042,7 @@ func (tc *Catalog) DeleteVersionEntriesForCollection(ctx context.Context, tenant\n \t\t}\n \n \t\tnumActiveVersions := tc.getNumberOfActiveVersions(versionFilePb)\n-\t\tif numActiveVersions <= 1 {\n+\t\tif numActiveVersions < 1 {\n \t\t\t// No remaining valid versions after GC.\n \t\t\treturn errors.New(\"no valid versions after gc\")\n \t\t}\n@@ -2091,11 +2092,15 @@ func (tc *Catalog) DeleteCollectionVersion(ctx context.Context, req *coordinator\n \tresult := coordinatorpb.DeleteCollectionVersionResponse{\n \t\tCollectionIdToSuccess: make(map[string]bool),\n \t}\n+\tvar firstErr error\n \tfor _, collectionVersionList := range req.Versions {\n \t\terr := tc.DeleteVersionEntriesForCollection(ctx, collectionVersionList.TenantId, collectionVersionList.CollectionId, collectionVersionList.Versions)\n \t\tresult.CollectionIdToSuccess[collectionVersionList.CollectionId] = err == nil\n+\t\tif firstErr == nil && err != nil {\n+\t\t\tfirstErr = err\n+\t\t}\n \t}\n-\treturn &result, nil\n+\treturn &result, firstErr\n }\n \n func (tc *Catalog) BatchGetCollectionVersionFilePaths(ctx context.Context, collectionIds []string) (*coordinatorpb.BatchGetCollectionVersionFilePathsResponse, error) {\n---\ngo/pkg/sysdb/coordinator/table_catalog_test.go\n@@ -759,7 +759,7 @@ func TestCatalog_DeleteCollectionVersion_CollectionNotFound(t *testing.T) {\n \tresp, err := catalog.DeleteCollectionVersion(context.Background(), req)\n \n \t// Verify results\n-\tassert.NoError(t, err)\n+\tassert.Error(t, err)\n \tassert.NotNil(t, resp)\n \tassert.False(t, resp.CollectionIdToSuccess[collectionID])\n \n---\ngo/pkg/sysdb/grpc/proto_model_convert.go\n@@ -1,6 +1,8 @@\n package grpc\n \n import (\n+\t\"time\"\n+\n \t\"github.com/chroma-core/chroma/go/pkg/common\"\n \t\"github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb\"\n \t\"github.com/chroma-core/chroma/go/pkg/sysdb/coordinator/model\"\n@@ -131,6 +133,7 @@ func convertToCreateCollectionModel(req *coordinatorpb.CreateCollectionRequest)\n \t\tGetOrCreate:          req.GetGetOrCreate(),\n \t\tTenantID:             req.GetTenant(),\n \t\tDatabaseName:         req.GetDatabase(),\n+\t\tTs:                   time.Now().Unix(),\n \t}, nil\n }\n \n---\nrust/garbage_collector/src/operators/delete_versions_at_sysdb.rs\n@@ -38,6 +38,8 @@ pub struct DeleteVersionsAtSysDbOutput {\n \n #[derive(Error, Debug)]\n pub enum DeleteVersionsAtSysDbError {\n+    #[error(\"Unknown error occurred when deleting versions at sysdb\")]\n+    UnknownError,\n     #[error(\"Error deleting versions in sysdb: {0}\")]\n     SysDBError(String),\n     #[error(\"Error deleting version file {path}: {message}\")]\n@@ -157,7 +159,13 @@ impl Operator<DeleteVersionsAtSysDbInput, DeleteVersionsAtSysDbOutput>\n                 .delete_collection_version(vec![input.versions_to_delete.clone()])\n                 .await\n             {\n-                Ok(_) => {\n+                Ok(results) => {\n+                    for (_, was_successful) in results {\n+                        if !was_successful {\n+                            return Err(DeleteVersionsAtSysDbError::UnknownError);\n+                        }\n+                    }\n+\n                     tracing::info!(\n                         versions = ?input.versions_to_delete.versions,\n                         \"Successfully deleted versions from SysDB\"\n---\nrust/sysdb/src/sysdb.rs\n@@ -1331,14 +1331,14 @@ impl ChromaError for MarkVersionForDeletionError {\n \n #[derive(Error, Debug)]\n pub enum DeleteCollectionVersionError {\n-    #[error(\"Failed to delete version\")]\n+    #[error(\"Failed to delete version: {0}\")]\n     FailedToDeleteVersion(#[from] tonic::Status),\n }\n \n impl ChromaError for DeleteCollectionVersionError {\n     fn code(&self) -> ErrorCodes {\n         match self {\n-            DeleteCollectionVersionError::FailedToDeleteVersion(_) => ErrorCodes::Internal,\n+            DeleteCollectionVersionError::FailedToDeleteVersion(e) => e.code().into(),\n         }\n     }\n }\n---\n\n\n---\n\nChoice B:\nchromadb/test/distributed/test_log_failover.py\n@@ -189,3 +189,99 @@ def test_log_failover_with_compaction(\n             assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n         else:\n             assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_query_operations(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    # Add initial RECORDS records with known embeddings for querying\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Perform baseline similarity queries before failover\n+    query_embeddings = [embeddings[0], embeddings[RECORDS//2], embeddings[-1]]\n+    baseline_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        baseline_results.append(result)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Trigger log failover\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Re-run the same queries after failover and verify results consistency\n+    post_failover_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        post_failover_results.append(result)\n+\n+    # Verify that query results are consistent before and after failover\n+    for i, (baseline, post_failover) in enumerate(zip(baseline_results, post_failover_results)):\n+        assert len(baseline[\"ids\"][0]) == len(post_failover[\"ids\"][0]), f\"Query {i} returned different number of results\"\n+        assert baseline[\"ids\"][0] == post_failover[\"ids\"][0], f\"Query {i} returned different IDs\"\n+        # Verify embeddings match (allowing for small floating point differences)\n+        for j, (base_emb, post_emb) in enumerate(zip(baseline[\"embeddings\"][0], post_failover[\"embeddings\"][0])):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(base_emb, post_emb)]), f\"Query {i} result {j} embeddings differ\"\n+\n+    # Add more data post-failover\n+    post_failover_start = RECORDS\n+    for i in range(post_failover_start, post_failover_start + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Query for both old and new data to ensure full functionality\n+    # Test that we can find old data\n+    old_data_query = collection.query(\n+        query_embeddings=[embeddings[0]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(old_data_query[\"ids\"][0]) == 3, \"Failed to query old data after failover\"\n+\n+    # Test that we can find new data\n+    new_data_query = collection.query(\n+        query_embeddings=[embeddings[-1]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(new_data_query[\"ids\"][0]) == 3, \"Failed to query new data after failover\"\n+\n+    # Verify all data is still accessible by ID\n+    for i in range(len(ids)):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        assert len(result[\"embeddings\"]) > 0, f\"Missing result for ID {i} after failover with new data\"\n+        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])]), f\"Embedding mismatch for ID {i}\"\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -967,11 +967,7 @@ func (tc *Catalog) ForkCollection(ctx context.Context, forkCollection *model.For\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\t// NOTE: This is a temporary hardcoded limit for the size of the lineage file\n-\t\t// TODO: Load the limit value from quota / scorecard, and/or improve the lineage file design to avoid large lineage file\n-\t\tif len(lineageFile.Dependencies) > 1000000 {\n-\t\t\treturn common.ErrCollectionTooManyFork\n-\t\t}\n+\n \t\tlineageFile.Dependencies = append(lineageFile.Dependencies, &coordinatorpb.CollectionVersionDependency{\n \t\t\tSourceCollectionId:      sourceCollectionIDStr,\n \t\t\tSourceCollectionVersion: uint64(sourceCollection.Version),\n---\nrust/frontend/src/quota/mod.rs\n@@ -336,7 +336,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n         m.insert(UsageType::RegexPatternLength, 0);\n-        m.insert(UsageType::NumForks, 1_000_000);\n+        m.insert(UsageType::NumForks, 10000);\n         m\n     };\n }\n---\nrust/frontend/src/server.rs\n@@ -1175,6 +1175,7 @@ async fn fork_collection(\n         CollectionUuid::from_str(&collection_id).map_err(|_| ValidationError::CollectionId)?;\n     let mut quota_payload = QuotaPayload::new(Action::ForkCollection, tenant.clone(), api_token);\n     quota_payload = quota_payload.with_collection_uuid(collection_id);\n+    quota_payload = quota_payload.with_collection_name(&payload.new_name);\n     server.quota_enforcer.enforce(&quota_payload).await?;\n \n     let _guard =\n---\n\n\n---\n\nChoice D:\nrust/segment/src/sqlite_metadata.rs\n@@ -579,17 +579,17 @@ impl IntoSqliteExpr for CompositeExpression {\n \n impl IntoSqliteExpr for DocumentExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let doc_col = Expr::col((\n-            EmbeddingFulltextSearch::Table,\n-            EmbeddingFulltextSearch::StringValue,\n-        ));\n-        let doc_contains = doc_col\n-            .clone()\n-            .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .and(doc_col.is_not_null());\n+        let subq = Query::select()\n+            .column(EmbeddingFulltextSearch::Rowid)\n+            .from(EmbeddingFulltextSearch::Table)\n+            .and_where(\n+                Expr::col(EmbeddingFulltextSearch::StringValue)\n+                    .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\"))),\n+            )\n+            .to_owned();\n         match self.operator {\n-            DocumentOperator::Contains => doc_contains,\n-            DocumentOperator::NotContains => doc_contains.not(),\n+            DocumentOperator::Contains => Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq),\n+            DocumentOperator::NotContains => Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq),\n             DocumentOperator::Regex => todo!(\"Implement Regex matching. The result must be a not-nullable boolean (use `<expr>.is(true)`)\"),\n             DocumentOperator::NotRegex => todo!(\"Implement negated Regex matching. This must be exact opposite of Regex matching (use `<expr>.not()`)\"),\n         }\n@@ -805,20 +805,11 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            let (has_document_expr, has_metadata_expr) = match whr {\n+            let (_, has_metadata_expr) = match whr {\n                 Where::Composite(expr) => expr.has_document_and_metadata(),\n                 Where::Document(_) => (true, false),\n                 Where::Metadata(_) => (false, true),\n             };\n-            if has_document_expr {\n-                filter_limit_query.left_join(\n-                    EmbeddingFulltextSearch::Table,\n-                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n-                        EmbeddingFulltextSearch::Table,\n-                        EmbeddingFulltextSearch::Rowid,\n-                    )),\n-                );\n-            }\n             if has_metadata_expr {\n                 filter_limit_query.left_join(\n                     EmbeddingMetadata::Table,\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThe `build-sdist` release job [is failing](https://github.com/chroma-core/chroma/actions/runs/15193462410/job/42739524860) because it's using the version of Rust provided in the runner image (1.80) instead of the version we install with rustup (1.81). This change sets the global default to 1.81, from our `rust-toolchain.toml`, so it should resolve the build issue.\n\n---\n\nChoice A:\nrust/tracing/src/init_tracer.rs\n@@ -143,6 +143,10 @@ pub fn init_stdout_layer() -> Box<dyn Layer<Registry> + Send + Sync> {\n                     .module_path()\n                     .unwrap_or(\"\")\n                     .starts_with(\"opentelemetry_sdk\")\n+                || metadata\n+                    .module_path()\n+                    .unwrap_or(\"\")\n+                    .starts_with(\"hosted-frontend\")\n         }))\n         .with_filter(tracing_subscriber::filter::LevelFilter::INFO)\n         .boxed()\n---\n\n\n---\n\nChoice B:\nrust/blockstore/src/arrow/blockfile.rs\n@@ -471,6 +471,15 @@ impl<'me, K: ArrowReadableKey<'me> + Into<KeyWrapper>, V: ArrowReadableValue<'me\n         self.load_blocks(&target_block_ids).await;\n     }\n \n+    pub(crate) async fn load_blocks_for_prefixes(&self, prefixes: impl IntoIterator<Item = &str>) {\n+        let prefix_vec = prefixes.into_iter().collect();\n+        let target_block_ids = self\n+            .root\n+            .sparse_index\n+            .get_block_ids_for_prefixes(prefix_vec);\n+        self.load_blocks(&target_block_ids).await;\n+    }\n+\n     pub(crate) async fn get(\n         &'me self,\n         prefix: &str,\n---\nrust/blockstore/src/arrow/sparse_index.rs\n@@ -362,7 +362,47 @@ impl SparseIndexReader {\n         result_uuids\n     }\n \n-    pub(super) fn get_block_ids_range<'prefix, 'referred_data, PrefixRange>(\n+    pub(super) fn get_block_ids_for_prefixes(&self, mut prefixes: Vec<&str>) -> Vec<Uuid> {\n+        prefixes.sort();\n+        let mut result_uuids = Vec::new();\n+        let block_start = self.data.forward.iter();\n+        let block_end = block_start\n+            .clone()\n+            .skip(1)\n+            .map(|(delim, _)| match delim {\n+                SparseIndexDelimiter::Start => {\n+                    unreachable!(\"The start delimiter should only appear in the first block\")\n+                }\n+                SparseIndexDelimiter::Key(composite_key) => Some(composite_key.prefix.as_str()),\n+            })\n+            .chain([None]);\n+        let mut prefix_iter = prefixes.into_iter().peekable();\n+        for ((start_delim, block), end_prefix) in block_start.zip(block_end) {\n+            if let SparseIndexDelimiter::Key(CompositeKey {\n+                prefix: start_prefix,\n+                key: _,\n+            }) = start_delim\n+            {\n+                while let Some(&prefix) = prefix_iter.peek() {\n+                    if start_prefix.as_str() <= prefix {\n+                        break;\n+                    }\n+                    prefix_iter.next();\n+                }\n+            }\n+            if let Some(&prefix) = prefix_iter.peek() {\n+                if end_prefix.is_none() || end_prefix.is_some_and(|end_prefix| prefix <= end_prefix)\n+                {\n+                    result_uuids.push(block.id);\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+        result_uuids\n+    }\n+\n+    pub(super) fn get_block_ids_range<'prefix, PrefixRange>(\n         &self,\n         prefix_range: PrefixRange,\n     ) -> Vec<Uuid>\n---\nrust/blockstore/src/types/reader.rs\n@@ -125,6 +125,18 @@ impl<\n         }\n     }\n \n+    pub async fn load_blocks_for_prefixes<'prefix>(\n+        &self,\n+        prefixes: impl IntoIterator<Item = &'prefix str>,\n+    ) {\n+        match self {\n+            BlockfileReader::MemoryBlockfileReader(_reader) => unimplemented!(),\n+            BlockfileReader::ArrowBlockfileReader(reader) => {\n+                reader.load_blocks_for_prefixes(prefixes).await\n+            }\n+        }\n+    }\n+\n     pub async fn rank(\n         &'referred_data self,\n         prefix: &'referred_data str,\n---\n\n\n---\n\nChoice C:\nrust/segment/src/sqlite_metadata.rs\n@@ -482,8 +482,9 @@ impl IntoSqliteExpr for DocumentExpression {\n             EmbeddingFulltextSearch::StringValue,\n         ));\n         let doc_contains = doc_col\n+            .clone()\n             .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .is(true);\n+            .and(doc_col.is_not_null());\n         match self.operator {\n             DocumentOperator::Contains => doc_contains,\n             DocumentOperator::NotContains => doc_contains.not(),\n@@ -495,9 +496,11 @@ impl IntoSqliteExpr for DocumentExpression {\n \n impl IntoSqliteExpr for MetadataExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let key_cond = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key))\n+        let key_col = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key));\n+        let key_cond = key_col\n+            .clone()\n             .eq(self.key.to_string())\n-            .is(true);\n+            .and(key_col.is_not_null());\n         match &self.comparison {\n             MetadataComparison::Primitive(op, val) => {\n                 let (col, sval) = match val {\n---\n\n\n---\n\nChoice D:\n.github/actions/rust/action.yaml\n@@ -19,6 +19,10 @@ runs:\n       uses: actions-rust-lang/setup-rust-toolchain@v1\n       with:\n         cache: false # we use Blacksmith's cache package below\n+    - name: Set channel in rust-toolchain.toml as default\n+      shell: bash\n+      run: |\n+        rustup default $(grep -m1 '^channel' rust-toolchain.toml | cut -d'\"' -f2)\n     - name: Install Protoc\n       uses: arduino/setup-protoc@v3\n       with:\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nI made a small change to effectively ignore the compactor-specified batch size request.  I want to\nsee what breaks.\n\n## Test plan\n\nThe plan is to use tests to see what breaks.\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -398,9 +398,10 @@ impl DirtyMarker {\n             let num_records = rollup_pc.limit_log_position - rollup_pc.start_log_position;\n             let reinsert_count = rollup_pc.reinsert_count;\n             let initial_insertion_epoch_us = rollup_pc.initial_insertion_epoch_us;\n-            let to_compact = num_records >= record_count_threshold\n+            let to_compact = true/*\n+                || num_records >= record_count_threshold\n                 || now_us - initial_insertion_epoch_us >= timeout_us\n-                || reinsert_count >= reinsert_threshold;\n+                || reinsert_count >= reinsert_threshold*/;\n             if to_compact {\n                 compactable.push(collection_id);\n             }\n@@ -2063,6 +2064,7 @@ mod tests {\n                 },\n             ),\n         ];\n+        /*\n         assert!(DirtyMarker::rollup(\n             Arc::new(storage),\n             |storage, collection_id| async move {\n@@ -2084,6 +2086,7 @@ mod tests {\n         .await\n         .unwrap()\n         .is_none());\n+        */\n     }\n \n     #[tokio::test]\n---\n\n\n---\n\nChoice B:\nclients/new-js/packages/chromadb/src/chroma-client.ts\n@@ -411,7 +411,7 @@ export class ChromaClient {\n    * @param options.embeddingFunction - Optional embedding function to use\n    * @returns A CollectionAPI instance for the specified collection\n    */\n-  public collection({\n+  public getCollectionById({\n     id,\n     embeddingFunction,\n   }: {\n@@ -431,7 +431,7 @@ export class ChromaClient {\n    * @param items - Array of collection IDs or objects with ID and optional embedding function\n    * @returns Array of CollectionAPI instances\n    */\n-  public collections(\n+  public getCollectionsById(\n     items: string[] | { id: string; embeddingFunction?: EmbeddingFunction }[],\n   ) {\n     if (items.length === 0) return [];\n---\ndocs/docs.trychroma.com/markdoc/content/docs/collections/create-get-delete.md\n@@ -109,10 +109,10 @@ const [col1, col2] = client.getCollections([\n ])\n ```\n \n-The `getCollection` and `getCollections` methods issue an API call to a Chroma server to get collections with all their fields. If you only need access to collection actions on records and want to save the API call, you can get a \"thin\" collection object using the `collection` method. It takes in a collection **ID** and an embedding function.\n+The `getCollection` and `getCollections` methods issue an API call to a Chroma server to get collections with all their fields. If you only need access to collection actions on records, and want to save the API call, you can get a \"thin\" collection object using the `getCollectionById` method (and `getCollectionsById`). It takes in a collection **ID** and an embedding function.\n \n ```typescript\n-const collection = client.collection({ id: 'abc', embeddingFunction: openaiEF })\n+const collection = client.getCollectionById({ id: 'abc', embeddingFunction: openaiEF })\n ```\n \n You can also delete collections by name using `deleteCollection`:\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -339,11 +339,16 @@ impl RollupPerCollection {\n             std::cmp::max(self.initial_insertion_epoch_us, initial_insertion_epoch_us);\n     }\n \n-    fn witness_manifest_and_cursor(&mut self, manifest: &Manifest, witness: Option<&Witness>) {\n+    fn witness_cursor(&mut self, witness: Option<&Witness>) {\n+        // NOTE(rescrv):  There's an easy dance here to justify this as correct.  For the start log\n+        // position to advance, there must have been at least one GC cycle with a cursor that was\n+        // something other than 1.  That cursor should never get deleted, therefore we have a\n+        // witness and the unwrap_or call 0x90s.\n+        //\n+        // The consequence of this breaking is that the offset in the log will be behind sysdb.\n         self.start_log_position = witness\n             .map(|x| x.1.position)\n-            .unwrap_or(manifest.minimum_log_position());\n-        self.limit_log_position = manifest.maximum_log_position();\n+            .unwrap_or(LogPosition::from_offset(1));\n     }\n \n     fn is_empty(&self) -> bool {\n@@ -999,15 +1004,6 @@ impl LogServer {\n         &self,\n         rollups: &mut HashMap<CollectionUuid, RollupPerCollection>,\n     ) -> Result<(), Error> {\n-        let load_manifest = |storage, collection_id| async move {\n-            let reader = LogReader::new(\n-                LogReaderOptions::default(),\n-                Arc::clone(storage),\n-                storage_prefix_for_log(collection_id),\n-            );\n-            let span = tracing::info_span!(\"manifest load\", collection_id = ?collection_id);\n-            reader.manifest().instrument(span).await\n-        };\n         let load_cursor = |storage, collection_id| async move {\n             let cursor = &COMPACTION;\n             let cursor_store = CursorStore::new(\n@@ -1020,18 +1016,12 @@ impl LogServer {\n             cursor_store.load(cursor).instrument(span).await\n         };\n         for (collection_id, mut rollup) in std::mem::take(rollups) {\n-            // TODO(rescrv):  We can avoid loading the manifest and cursor by checking an\n-            // in-memory lookaside structure.\n-            let Some(manifest) = load_manifest(&self.storage, collection_id).await? else {\n-                tracing::warn!(\"{collection_id} has no manifest; this may mean it was deleted\");\n-                continue;\n-            };\n             let cursor = load_cursor(&self.storage, collection_id).await?;\n             // NOTE(rescrv):  There are two spreads that we have.\n             // `rollup` tracks the minimum and maximum offsets of a record on the dirty log.\n             // The spread between cursor (if it exists) and manifest.maximum_log_offset tracks the\n             // data that needs to be compacted.\n-            rollup.witness_manifest_and_cursor(&manifest, cursor.as_ref());\n+            rollup.witness_cursor(cursor.as_ref());\n             if !rollup.is_empty() {\n                 rollups.insert(collection_id, rollup);\n             }\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.7\"\n+__version__ = \"1.0.8\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.7\"\n+      \"Default\": \"1.0.8\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThis change significantly speeds up dev builds. Timings when adding a comment to a specific file and observing the incremental build time in `tilt`:\r\n\r\n|                                            | before | after | speedup |\r\n|--------------------------------------------|--------|-------|---------|\r\n| `rust/sqlite/src/db.rs`                    | 41s    | 18s   | 2.3x    |\r\n| `rust/log-service/src/state_hash_table.rs` | 15s    | 9s    | 1.7x    |\r\n\r\n`split-debuginfo = unpacked` is the default on macOS, however because we build inside Docker the Linux default (off) is used instead.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\nrust/frontend/src/impls/in_memory_frontend.rs\n@@ -664,6 +664,7 @@ impl InMemoryFrontend {\n     pub fn healthcheck(&self) -> chroma_types::HealthCheckResponse {\n         chroma_types::HealthCheckResponse {\n             is_executor_ready: true,\n+            is_log_client_ready: true,\n         }\n     }\n }\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -1433,6 +1433,7 @@ impl ServiceBasedFrontend {\n     pub async fn healthcheck(&self) -> HealthCheckResponse {\n         HealthCheckResponse {\n             is_executor_ready: self.executor.is_ready().await,\n+            is_log_client_ready: self.log_client.is_ready(),\n         }\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -738,6 +738,18 @@ impl GrpcLog {\n             Err(GrpcMigrateLogError::NotSupported)\n         }\n     }\n+\n+    /// If the log client is configured to use a memberlist-based client assigner,\n+    /// this function checks if the client assigner is ready to serve requests.\n+    /// This is useful to ensure that the client assigner has enough information about the cluster\n+    /// before making requests to the log service.\n+    pub fn is_ready(&self) -> bool {\n+        if let Some(client_assigner) = &self.alt_client_assigner {\n+            !client_assigner.is_empty()\n+        } else {\n+            true // If no client assigner is configured, we assume it's ready.\n+        }\n+    }\n }\n \n #[cfg(test)]\n---\nrust/log/src/log.rs\n@@ -222,4 +222,12 @@ impl Log {\n             Log::InMemory(_) => unimplemented!(),\n         }\n     }\n+\n+    pub fn is_ready(&self) -> bool {\n+        match self {\n+            Log::Sqlite(_) => true,\n+            Log::Grpc(log) => log.is_ready(),\n+            Log::InMemory(_) => true,\n+        }\n+    }\n }\n---\nrust/types/src/api_types.rs\n@@ -1719,11 +1719,12 @@ impl ChromaError for QueryError {\n #[derive(Serialize, ToSchema)]\n pub struct HealthCheckResponse {\n     pub is_executor_ready: bool,\n+    pub is_log_client_ready: bool,\n }\n \n impl HealthCheckResponse {\n     pub fn get_status_code(&self) -> tonic::Code {\n-        if self.is_executor_ready {\n+        if self.is_executor_ready && self.is_log_client_ready {\n             tonic::Code::Ok\n         } else {\n             tonic::Code::Unavailable\n---\n\n\n---\n\nChoice B:\nrust/wal3/examples/wal3-bootstrap-reasoner.rs\n@@ -0,0 +1,182 @@\n+//! This file is not intended for public consumption, but is kept for completeness.\n+//!\n+//! In this file you will find that we reason about the bootstrap process by completely exploring\n+//! the state space and pruning known good states.  The goal is to prune every state or print a\n+//! list of states that are bad.\n+//!\n+//! This is ad-hoc machine-assisted proving without an environment or theorem prover.\n+\n+#[derive(Clone, Copy, Debug)]\n+enum FragmentState {\n+    BenignRace,\n+    Conflict,\n+    Success,\n+}\n+\n+impl FragmentState {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            FragmentState::BenignRace,\n+            FragmentState::Conflict,\n+            FragmentState::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum InitializeManifest {\n+    Uninitialized,\n+    AlreadyInitialized,\n+    Success,\n+}\n+\n+impl InitializeManifest {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            InitializeManifest::Uninitialized,\n+            InitializeManifest::AlreadyInitialized,\n+            InitializeManifest::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum RecoverManifest {\n+    Uninitialized,\n+    Failure,\n+    Success,\n+}\n+\n+impl RecoverManifest {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            RecoverManifest::Uninitialized,\n+            RecoverManifest::Failure,\n+            RecoverManifest::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+enum Disposition {\n+    /// The combination of states is considered a good case.\n+    Good,\n+    /// The combination of states is not considered by the rule.\n+    Pass,\n+    /// The case can be dropped with good conscience for not mattering.  The string is the reason.\n+    Drop(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+    /// The case must lead to an error at runtime.\n+    Panic(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+    /// The case must be raised to the user for inspection.\n+    Raise(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+}\n+\n+fn happy_paths(fs: FragmentState, im: InitializeManifest, rm: RecoverManifest) -> Disposition {\n+    match (fs, im, rm) {\n+        (\n+            FragmentState::Success | FragmentState::BenignRace,\n+            InitializeManifest::Uninitialized | InitializeManifest::Success,\n+            RecoverManifest::Success,\n+        ) => Disposition::Good,\n+        _ => Disposition::Pass,\n+    }\n+}\n+\n+fn error_paths(fs: FragmentState, im: InitializeManifest, rm: RecoverManifest) -> Disposition {\n+    match (fs, im, rm) {\n+        (_, InitializeManifest::AlreadyInitialized, _) => {\n+            Disposition::Panic(\"cannot double-initialize manifest\", fs, im, rm)\n+        }\n+        (_, _, RecoverManifest::Uninitialized) => {\n+            Disposition::Panic(\"cannot have manifest become uninitialized\", fs, im, rm)\n+        }\n+        (_, _, RecoverManifest::Failure) => {\n+            Disposition::Panic(\"failed to install recovered manifest\", fs, im, rm)\n+        }\n+        _ => Disposition::Pass,\n+    }\n+}\n+\n+fn conflict_on_fragment(\n+    fs: FragmentState,\n+    im: InitializeManifest,\n+    rm: RecoverManifest,\n+) -> Disposition {\n+    if matches!(fs, FragmentState::Conflict) {\n+        Disposition::Drop(\n+            \"no need to touch manifest if fragment conflicts\",\n+            fs,\n+            im,\n+            rm,\n+        )\n+    } else {\n+        Disposition::Pass\n+    }\n+}\n+\n+fn unconditionally_raise(\n+    fs: FragmentState,\n+    im: InitializeManifest,\n+    rm: RecoverManifest,\n+) -> Disposition {\n+    Disposition::Raise(\"unconditional raise\", fs, im, rm)\n+}\n+\n+pub fn main() {\n+    let mut states = vec![];\n+    for fs in FragmentState::all_states() {\n+        for im in InitializeManifest::all_states() {\n+            for rm in RecoverManifest::all_states() {\n+                states.push((fs, im, rm));\n+            }\n+        }\n+    }\n+    let rules = vec![\n+        happy_paths,\n+        conflict_on_fragment,\n+        error_paths,\n+        unconditionally_raise,\n+    ];\n+    for state in states.iter() {\n+        for rule in &rules {\n+            match (rule)(state.0, state.1, state.2) {\n+                Disposition::Pass => {}\n+                Disposition::Good => {\n+                    break;\n+                }\n+                Disposition::Panic(reason, fs, im, rm) => {\n+                    println!(\"panic({fs:?}, {im:?}, {rm:?}) -> {reason}\");\n+                    break;\n+                }\n+                Disposition::Drop(reason, fs, im, rm) => {\n+                    _ = reason;\n+                    _ = fs;\n+                    _ = im;\n+                    _ = rm;\n+                    break;\n+                }\n+                Disposition::Raise(reason, fs, im, rm) => {\n+                    println!(\"raise({fs:?}, {im:?}, {rm:?}) -> {reason}\");\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -917,6 +917,7 @@ impl LogServer {\n                 Limits {\n                     max_files: Some(10_000),\n                     max_bytes: Some(1_000_000_000),\n+                    max_records: Some(10_000),\n                 },\n             )\n             .await?;\n@@ -1151,6 +1152,7 @@ impl LogServer {\n             let limits = Limits {\n                 max_files: Some(pull_logs.batch_size as u64 + 1),\n                 max_bytes: None,\n+                max_records: Some(pull_logs.batch_size as u64),\n             };\n             let fragments = match log_reader\n                 .scan(\n@@ -1172,17 +1174,25 @@ impl LogServer {\n                 .map(|fragment| async {\n                     let cache_key = format!(\"{collection_id}::{}\", fragment.path);\n                     if let Some(cache) = self.cache.as_ref() {\n-                        if let Ok(Some(answer)) = cache.get(&cache_key).await {\n+                        let cache_span = tracing::info_span!(\"cache get\");\n+                        if let Ok(Some(answer)) = cache.get(&cache_key).instrument(cache_span).await\n+                        {\n                             return Ok(Arc::new(answer.bytes));\n                         }\n-                        let answer = log_reader.fetch(fragment).await?;\n+                        let fetch_span = tracing::info_span!(\"fragment fetch\");\n+                        let answer = log_reader.fetch(fragment).instrument(fetch_span).await?;\n                         let cache_value = CachedParquetFragment {\n                             bytes: Clone::clone(&*answer),\n                         };\n-                        cache.insert(cache_key, cache_value).await;\n+                        let insert_span = tracing::info_span!(\"cache insert\");\n+                        cache\n+                            .insert(cache_key, cache_value)\n+                            .instrument(insert_span)\n+                            .await;\n                         Ok(answer)\n                     } else {\n-                        log_reader.fetch(fragment).await\n+                        let fetch_span = tracing::info_span!(\"fragment fetch\");\n+                        log_reader.fetch(fragment).instrument(fetch_span).await\n                     }\n                 })\n                 .collect::<Vec<_>>();\n@@ -1411,6 +1421,7 @@ impl LogServer {\n                 Limits {\n                     max_files: Some(1_000_000),\n                     max_bytes: Some(1_000_000_000),\n+                    max_records: Some(1_000_000),\n                 },\n             )\n             .await\n---\nrust/wal3/src/reader.rs\n@@ -22,6 +22,7 @@ use crate::{\n pub struct Limits {\n     pub max_files: Option<u64>,\n     pub max_bytes: Option<u64>,\n+    pub max_records: Option<u64>,\n }\n \n /// LogReader is a reader for the log.\n@@ -90,16 +91,27 @@ impl LogReader {\n         else {\n             return Err(Error::UninitializedLog);\n         };\n+        let log_position_range = if let Some(max_records) = limits.max_records {\n+            (from, from + max_records)\n+        } else {\n+            (from, LogPosition::MAX)\n+        };\n+        fn ranges_overlap(\n+            lhs: (LogPosition, LogPosition),\n+            rhs: (LogPosition, LogPosition),\n+        ) -> bool {\n+            lhs.0 <= rhs.1 && rhs.0 <= lhs.1\n+        }\n         let mut snapshots = manifest\n             .snapshots\n             .iter()\n-            .filter(|s| s.limit.offset() > from.offset())\n+            .filter(|s| ranges_overlap(log_position_range, (s.start, s.limit)))\n             .cloned()\n             .collect::<Vec<_>>();\n         let mut fragments = manifest\n             .fragments\n             .iter()\n-            .filter(|f| f.limit.offset() > from.offset())\n+            .filter(|f| ranges_overlap(log_position_range, (f.start, f.limit)))\n             .cloned()\n             .collect::<Vec<_>>();\n         while !snapshots.is_empty() {\n@@ -137,6 +149,18 @@ impl LogReader {\n                 fragments.truncate(max_files as usize);\n             }\n         }\n+        while fragments.len() > 1\n+            // NOTE(rescrv):  We take the start of the last fragment, because if there are enough\n+            // records without it we can pop.\n+            && fragments[fragments.len() - 1].start - fragments[0].start\n+                > limits.max_records.unwrap_or(u64::MAX)\n+        {\n+            tracing::info!(\n+                \"truncating to {} files because records restrictions\",\n+                fragments.len() - 1\n+            );\n+            fragments.pop();\n+        }\n         while fragments.len() > 1\n             && fragments\n                 .iter()\n---\n\n\n---\n\nChoice D:\nCargo.toml\n@@ -126,6 +126,10 @@ tempfile = \"3.14.0\"\n itertools = \"0.13.0\"\n serial_test = \"3.2.0\"\n \n+[profile.dev]\n+# Significantly reduces compile times\n+split-debuginfo = \"unpacked\"\n+\n [profile.release]\n debug = 2\n lto = \"thin\"\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nI want a way to make a tenant bound to the new log for all collections,\nno matter when they are created.  One way to handle this would be to\nmake the log service tenant-aware and have it do the selection\nintelligently on the fly.  This would require threading the tenant\ninformation in the proto and trusting it all the way down.\n\nThe alternative taken in this PR is to deal with it entirely from the\nfrontend by sealing the collection on the critical path of collection\ncreation, opting to trace an error rather than fail the op entirely if\nsealing the log fails.\n\n## Test plan\n\nCI\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nTiltfile\n@@ -92,7 +92,7 @@ else:\n   docker_build(\n     'frontend-service',\n     '.',\n-    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/'],\n+    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/', 'Cargo.toml', 'Cargo.lock', 'rust/', 'pyproject.toml', 'README.md'],\n     dockerfile='./Dockerfile',\n     ignore=['**/*.pyc', 'chromadb/test/'],\n   )\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -22,6 +22,7 @@ use chroma_types::chroma_proto::{\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n use figment::providers::{Env, Format, Yaml};\n+use opentelemetry::metrics::Meter;\n use parquet::arrow::arrow_reader::ParquetRecordBatchReaderBuilder;\n use prost::Message;\n use serde::{Deserialize, Serialize};\n@@ -48,6 +49,22 @@ const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n static STABLE_PREFIX: CursorName = unsafe { CursorName::from_string_unchecked(\"stable_prefix\") };\n static COMPACTION: CursorName = unsafe { CursorName::from_string_unchecked(\"compaction\") };\n \n+////////////////////////////////////////////// Metrics /////////////////////////////////////////////\n+\n+pub struct Metrics {\n+    log_total_uncompacted_records_count: opentelemetry::metrics::Gauge<f64>,\n+}\n+\n+impl Metrics {\n+    pub fn new(meter: Meter) -> Self {\n+        Self {\n+            log_total_uncompacted_records_count: meter\n+                .f64_gauge(\"log_total_uncompacted_records_count\")\n+                .build(),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////// state maintenance ////////////////////////////////////////\n \n // NOTE(rescrv):  This code dynamically opens and closes logs.  An opened log will stay open until\n@@ -334,6 +351,7 @@ impl DirtyMarker {\n \n     /// Given a contiguous prefix of markers, process the log into a rollup.  That is, a set of\n     /// markers to reinsert, a set of collections to compact, and an advance_to log position.\n+    #[allow(clippy::too_many_arguments)]\n     pub async fn rollup<\n         F1: Future<Output = Result<Option<Manifest>, wal3::Error>>,\n         F2: Future<Output = Result<Option<Witness>, wal3::Error>>,\n@@ -345,6 +363,7 @@ impl DirtyMarker {\n         record_count_threshold: u64,\n         reinsert_threshold: u64,\n         timeout_us: u64,\n+        metrics: &Metrics,\n     ) -> Result<Option<Rollup>, wal3::Error> {\n         // NOTE(rescrv);  This is complicated code because it's a hard problem to do efficiently.\n         // To cut complexity, I've chosen to do it in a way that is not the most efficient but is\n@@ -434,6 +453,7 @@ impl DirtyMarker {\n             .into_iter()\n             .flat_map(Result::ok)\n             .collect::<HashMap<_, _>>();\n+        let mut uncompacted = 0u64;\n         let compactable = compactable\n             .into_iter()\n             .filter_map(|collection_id| {\n@@ -473,6 +493,7 @@ impl DirtyMarker {\n                             cursor.position,\n                             manifest.maximum_log_position(),\n                         );\n+                        uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_threshold {\n                             Some(CollectionInfo {\n                                 collection_id: collection_id.to_string(),\n@@ -514,6 +535,9 @@ impl DirtyMarker {\n                 }\n             }\n         }\n+        metrics\n+            .log_total_uncompacted_records_count\n+            .record(uncompacted as f64, &[]);\n         Ok(Some(Rollup {\n             advance_to,\n             reinsert,\n@@ -608,6 +632,7 @@ pub struct LogServer {\n     dirty_log: Arc<LogWriter>,\n     compacting: tokio::sync::Mutex<()>,\n     cache: Option<Box<dyn chroma_cache::PersistentCache<String, CachedParquetFragment>>>,\n+    metrics: Metrics,\n }\n \n #[async_trait::async_trait]\n@@ -977,6 +1002,7 @@ impl LogService for LogServer {\n             ),\n             self.config.reinsert_threshold,\n             self.config.timeout_us,\n+            &self.metrics,\n         )\n         .await\n         .map_err(|err| Status::unavailable(err.to_string()))?;\n@@ -1456,13 +1482,15 @@ impl Configurable<LogServerConfig> for LogServer {\n         .map_err(|err| -> Box<dyn ChromaError> { Box::new(err) as _ })?;\n         let dirty_log = Arc::new(dirty_log);\n         let compacting = tokio::sync::Mutex::new(());\n+        let metrics = Metrics::new(opentelemetry::global::meter(\"chroma\"));\n         Ok(Self {\n             config: config.clone(),\n             open_logs: Arc::new(StateHashTable::default()),\n             storage,\n             dirty_log,\n             compacting,\n             cache,\n+            metrics,\n         })\n     }\n }\n@@ -1565,6 +1593,7 @@ mod tests {\n             1,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1626,6 +1655,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1709,6 +1739,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1822,6 +1853,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n---\n\n\n---\n\nChoice C:\n.github/actions/docker/action.yaml\n@@ -17,6 +17,11 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n+    # https://github.com/docker/setup-qemu-action - for multiplatform builds\n+    - name: Set up QEMU\n+      uses: docker/setup-qemu-action@v2\n+    - name: Set up Docker Buildx\n+      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n.github/workflows/_build_release_container.yml\n@@ -33,106 +33,43 @@ permissions:\n env:\n   GHCR_IMAGE_NAME: \"ghcr.io/chroma-core/chroma\"\n   DOCKERHUB_IMAGE_NAME: \"chromadb/chroma\"\n+  PLATFORMS: linux/amd64,linux/arm64 #linux/riscv64, linux/arm/v7\n \n jobs:\n   build:\n-    name: Build image for ${{ matrix.platform }}\n+    name: Build and publish container image\n     runs-on: blacksmith-16vcpu-ubuntu-2204\n-    strategy:\n-      matrix:\n-        platform: [amd64, arm64]\n-        include:\n-          - platform: amd64\n-            runner: blacksmith-16vcpu-ubuntu-2204\n-            docker_platform: linux/amd64\n-          - platform: arm64\n-            runner: blacksmith-16vcpu-ubuntu-2204-arm\n-            docker_platform: linux/arm64\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n         with:\n           fetch-depth: 0\n-\n       - name: Set up Docker\n         uses: ./.github/actions/docker\n         with:\n           ghcr-username: ${{ github.actor }}\n           ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n           dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-\n-      - name: Compute arch-specific tags\n-        id: tags\n+      - name: Compute tags\n         shell: bash\n+        id: compute_tags\n         run: |\n-          arch_tag=\"${{ inputs.tag }}-${{ matrix.platform }}\"\n-          ghcr=\"${{ env.GHCR_IMAGE_NAME }}:${arch_tag}\"\n-          dhub=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${arch_tag}\"\n-          echo \"arch_tag=$arch_tag\"      >> $GITHUB_OUTPUT\n-\n-          # expose *matrix-unique* step outputs\n-          echo \"ghcr_tag_${{ matrix.platform }}=$ghcr\"         >> $GITHUB_OUTPUT\n-          echo \"dockerhub_tag_${{ matrix.platform }}=$dhub\"    >> $GITHUB_OUTPUT\n+          tags=\"${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }},${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\"\n+          if [ \"${{ inputs.tag_as_latest }}\" = \"true\" ]; then\n+            tags=\"${tags},${{ env.GHCR_IMAGE_NAME }}:latest,${{ env.DOCKERHUB_IMAGE_NAME }}:latest\"\n+          fi\n \n-          # these two tags are what the build-push action will publish for *this* arch\n-          echo \"tags=$ghcr,$dhub\" >> $GITHUB_OUTPUT\n+          echo \"tags=${tags}\" >> $GITHUB_OUTPUT\n \n       - name: Build and push image\n         uses: useblacksmith/build-push-action@v1.1\n         with:\n           context: .\n           file: rust/Dockerfile\n           target: cli\n-          platforms: ${{ matrix.docker_platform }}\n+          platforms: ${{ env.PLATFORMS }}\n           push: true\n           build-args: |\n             RELEASE_MODE=1\n-          tags: ${{ steps.tags.outputs.tags }}\n-    outputs:\n-      ghcr_tag_amd64:      ${{ steps.tags.outputs.ghcr_tag_amd64 }}\n-      ghcr_tag_arm64:      ${{ steps.tags.outputs.ghcr_tag_arm64 }}\n-      dockerhub_tag_amd64: ${{ steps.tags.outputs.dockerhub_tag_amd64 }}\n-      dockerhub_tag_arm64: ${{ steps.tags.outputs.dockerhub_tag_arm64 }}\n-\n-  merge:\n-    name: Merge platform manifests\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n-    needs:\n-      - build\n-    steps:\n-      - name: Set up Docker\n-        uses: ./.github/actions/docker\n-        with:\n-          ghcr-username: ${{ github.actor }}\n-          ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n-          dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n-          dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-\n-      - name: Create and push manifest\n-        shell: bash\n-        run: |\n-          set -euo pipefail\n-\n-          # Pull the per-arch tags from job-level outputs\n-          ghcr_amd64='${{ needs.build.outputs.ghcr_tag_amd64 }}'\n-          ghcr_arm64='${{ needs.build.outputs.ghcr_tag_arm64 }}'\n-          dhub_amd64='${{ needs.build.outputs.dockerhub_tag_amd64 }}'\n-          dhub_arm64='${{ needs.build.outputs.dockerhub_tag_arm64 }}'\n-\n-          base_tag='${{ inputs.tag }}'\n-          ghcr_base=\"${{ env.GHCR_IMAGE_NAME }}:${base_tag}\"\n-          dhub_base=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${base_tag}\"\n-\n-          docker buildx imagetools create --tag \"$ghcr_base\" $ghcr_amd64 $ghcr_arm64\n-          docker buildx imagetools create --tag \"$dhub_base\"  $dhub_amd64 $dhub_arm64\n-\n-          if [[ \"${{ inputs.tag_as_latest }}\" == \"true\" ]]; then\n-            docker buildx imagetools create --tag \"${{ env.GHCR_IMAGE_NAME }}:latest\"  $ghcr_amd64 $ghcr_arm64\n-            docker buildx imagetools create --tag \"${{ env.DOCKERHUB_IMAGE_NAME }}:latest\" $dhub_amd64 $dhub_arm64\n-          fi\n-\n-      - name: Inspect image\n-        run: |\n-          docker buildx imagetools inspect ${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }}\n-          docker buildx imagetools inspect ${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\n+          tags: ${{ steps.compute_tags.outputs.tags }}\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/config.rs\n@@ -64,6 +64,8 @@ pub struct FrontendConfig {\n     pub executor: ExecutorConfig,\n     #[serde(default = \"default_default_knn_index\")]\n     pub default_knn_index: KnnIndex,\n+    #[serde(default = \"Default::default\")]\n+    pub tenants_to_migrate_immediately: Vec<String>,\n }\n \n impl FrontendConfig {\n@@ -80,6 +82,7 @@ impl FrontendConfig {\n             log: default_log_config(),\n             executor: default_executor_config(),\n             default_knn_index: default_default_knn_index(),\n+            tenants_to_migrate_immediately: vec![],\n         }\n     }\n }\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -66,9 +66,11 @@ pub struct ServiceBasedFrontend {\n     metrics: Arc<Metrics>,\n     default_knn_index: KnnIndex,\n     retries_builder: ExponentialBuilder,\n+    tenants_to_migrate_immediately: HashSet<String>,\n }\n \n impl ServiceBasedFrontend {\n+    #[allow(clippy::too_many_arguments)]\n     pub fn new(\n         allow_reset: bool,\n         sysdb_client: SysDb,\n@@ -77,6 +79,7 @@ impl ServiceBasedFrontend {\n         executor: Executor,\n         max_batch_size: u32,\n         default_knn_index: KnnIndex,\n+        tenants_to_migrate_immediately: HashSet<String>,\n     ) -> Self {\n         let meter = global::meter(\"chroma\");\n         let fork_retries_counter = meter.u64_counter(\"fork_retries\").build();\n@@ -119,6 +122,7 @@ impl ServiceBasedFrontend {\n             metrics,\n             default_knn_index,\n             retries_builder,\n+            tenants_to_migrate_immediately,\n         }\n     }\n \n@@ -489,7 +493,7 @@ impl ServiceBasedFrontend {\n         let collection = self\n             .sysdb_client\n             .create_collection(\n-                tenant_id,\n+                tenant_id.clone(),\n                 database_name,\n                 collection_id,\n                 name,\n@@ -505,10 +509,18 @@ impl ServiceBasedFrontend {\n             .collections_with_segments_cache\n             .remove(&collection_id)\n             .await;\n-\n+        if self.tenant_is_on_new_log_by_default(&tenant_id) {\n+            if let Err(err) = self.log_client.seal_log(&tenant_id, collection_id).await {\n+                tracing::error!(\"could not seal collection right away: {err}\");\n+            }\n+        }\n         Ok(collection)\n     }\n \n+    fn tenant_is_on_new_log_by_default(&self, tenant_id: &str) -> bool {\n+        self.tenants_to_migrate_immediately.contains(tenant_id)\n+    }\n+\n     pub async fn update_collection(\n         &mut self,\n         UpdateCollectionRequest {\n@@ -1471,6 +1483,11 @@ impl Configurable<(FrontendConfig, System)> for ServiceBasedFrontend {\n         let executor =\n             Executor::try_from_config(&(config.executor.clone(), system.clone()), registry).await?;\n \n+        let tenants_to_migrate_immediately = config\n+            .tenants_to_migrate_immediately\n+            .iter()\n+            .cloned()\n+            .collect::<HashSet<String>>();\n         Ok(ServiceBasedFrontend::new(\n             config.allow_reset,\n             sysdb,\n@@ -1479,6 +1496,7 @@ impl Configurable<(FrontendConfig, System)> for ServiceBasedFrontend {\n             executor,\n             max_batch_size,\n             config.default_knn_index,\n+            tenants_to_migrate_immediately,\n         ))\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -125,6 +125,20 @@ impl ChromaError for GrpcPurgeDirtyForCollectionError {\n     }\n }\n \n+#[derive(Error, Debug)]\n+pub enum GrpcSealLogError {\n+    #[error(\"Failed to seal collection: {0}\")]\n+    FailedToSeal(#[from] tonic::Status),\n+}\n+\n+impl ChromaError for GrpcSealLogError {\n+    fn code(&self) -> ErrorCodes {\n+        match self {\n+            GrpcSealLogError::FailedToSeal(_) => ErrorCodes::Internal,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct GrpcLog {\n     config: GrpcLogConfig,\n@@ -544,6 +558,20 @@ impl GrpcLog {\n             Ok(())\n         }\n     }\n+\n+    pub(super) async fn seal_log(\n+        &mut self,\n+        tenant: &str,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcSealLogError> {\n+        let _response = self\n+            .client_for(tenant, collection_id)\n+            .seal_log(chroma_proto::SealLogRequest {\n+                collection_id: collection_id.to_string(),\n+            })\n+            .await?;\n+        Ok(())\n+    }\n }\n \n #[cfg(test)]\n---\nrust/log/src/log.rs\n@@ -1,4 +1,4 @@\n-use crate::grpc_log::GrpcLog;\n+use crate::grpc_log::{GrpcLog, GrpcSealLogError};\n use crate::in_memory_log::InMemoryLog;\n use crate::sqlite_log::SqliteLog;\n use crate::types::CollectionInfo;\n@@ -210,4 +210,16 @@ impl Log {\n             Log::InMemory(_) => Ok(ResetResponse {}),\n         }\n     }\n+\n+    pub async fn seal_log(\n+        &mut self,\n+        tenant: &str,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcSealLogError> {\n+        match self {\n+            Log::Grpc(log) => log.seal_log(tenant, collection_id).await,\n+            Log::Sqlite(_) => unimplemented!(),\n+            Log::InMemory(_) => unimplemented!(),\n+        }\n+    }\n }\n---\nrust/python_bindings/src/bindings.rs\n@@ -122,6 +122,7 @@ impl Bindings {\n             log: log_config,\n             executor: executor_config,\n             default_knn_index: knn_index,\n+            tenants_to_migrate_immediately: vec![],\n         };\n \n         let frontend = runtime.block_on(async {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nBecause there would be no row in the DB, sealing the collection fails to\nupdate is_sealed to true.   Add a fallback to insert a sealed row if the\nupdate fails.  Add a test to capture that this works.\n\n## Test plan\n\nCI.  Ran the new test locally.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\ngo/pkg/log/server/server.go\n@@ -162,6 +162,15 @@ func (s *logServer) InspectDirtyLog(ctx context.Context, req *logservicepb.Inspe\n \treturn\n }\n \n+func (s *logServer) SealLog(ctx context.Context, req *logservicepb.SealLogRequest) (res *logservicepb.SealLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n+\n+func (s *logServer) MigrateLog(ctx context.Context, req *logservicepb.MigrateLogRequest) (res *logservicepb.MigrateLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n \n func NewLogServer(lr *repository.LogRepository) logservicepb.LogServiceServer {\n \treturn &logServer{\n---\nidl/chromadb/proto/logservice.proto\n@@ -96,6 +96,22 @@ message InspectDirtyLogResponse {\n   repeated string markers = 1;\n }\n \n+message SealLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message SealLogResponse {\n+  // Empty\n+}\n+\n+message MigrateLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message MigrateLogResponse {\n+  // Empty\n+}\n+\n service LogService {\n   rpc PushLogs(PushLogsRequest) returns (PushLogsResponse) {}\n   rpc ScoutLogs(ScoutLogsRequest) returns (ScoutLogsResponse) {}\n@@ -104,5 +120,11 @@ service LogService {\n   rpc GetAllCollectionInfoToCompact(GetAllCollectionInfoToCompactRequest) returns (GetAllCollectionInfoToCompactResponse) {}\n   rpc UpdateCollectionLogOffset(UpdateCollectionLogOffsetRequest) returns (UpdateCollectionLogOffsetResponse) {}\n   rpc PurgeDirtyForCollection(PurgeDirtyForCollectionRequest) returns (PurgeDirtyForCollectionResponse) {}\n+  // RPC endpoints to expose for operator debuggability.\n+  // This endpoint must route to the rust log service.\n   rpc InspectDirtyLog(InspectDirtyLogRequest) returns (InspectDirtyLogResponse) {}\n+  // This endpoint must route to the go log service.\n+  rpc SealLog(SealLogRequest) returns (SealLogResponse) {}\n+  // This endpoint must route to the rust log service.\n+  rpc MigrateLog(MigrateLogRequest) returns (MigrateLogResponse) {}\n }\n---\nrust/log-service/src/lib.rs\n@@ -16,9 +16,10 @@ use chroma_storage::Storage;\n use chroma_types::chroma_proto::{\n     log_service_server::LogService, CollectionInfo, GetAllCollectionInfoToCompactRequest,\n     GetAllCollectionInfoToCompactResponse, InspectDirtyLogRequest, InspectDirtyLogResponse,\n-    LogRecord, OperationRecord, PullLogsRequest, PullLogsResponse, PurgeDirtyForCollectionRequest,\n-    PurgeDirtyForCollectionResponse, PushLogsRequest, PushLogsResponse, ScoutLogsRequest,\n-    ScoutLogsResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n+    LogRecord, MigrateLogRequest, MigrateLogResponse, OperationRecord, PullLogsRequest,\n+    PullLogsResponse, PurgeDirtyForCollectionRequest, PurgeDirtyForCollectionResponse,\n+    PushLogsRequest, PushLogsResponse, ScoutLogsRequest, ScoutLogsResponse, SealLogRequest,\n+    SealLogResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n };\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n@@ -1230,6 +1231,24 @@ impl LogService for LogServer {\n         }\n         Ok(Response::new(InspectDirtyLogResponse { markers }))\n     }\n+\n+    async fn seal_log(\n+        &self,\n+        _request: Request<SealLogRequest>,\n+    ) -> Result<Response<SealLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do sealing\",\n+        ))\n+    }\n+\n+    async fn migrate_log(\n+        &self,\n+        _request: Request<MigrateLogRequest>,\n+    ) -> Result<Response<MigrateLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do migrating yet\",\n+        ))\n+    }\n }\n \n fn parquet_to_records(parquet: Arc<Vec<u8>>) -> Result<Vec<(LogPosition, Vec<u8>)>, Status> {\n---\n\n\n---\n\nChoice B:\nchromadb/test/distributed/test_log_failover.py\n@@ -23,6 +23,50 @@\n \n RECORDS = 100\n \n+@skip_if_not_cluster()\n+def test_log_immediate_failover(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n+\n @skip_if_not_cluster()\n def test_log_failover(\n     client: ClientAPI,\n---\ngo/pkg/log/repository/log.go\n@@ -4,6 +4,7 @@ import (\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"strings\"\n \t\"time\"\n \n \tlog \"github.com/chroma-core/chroma/go/pkg/log/store/db\"\n@@ -215,6 +216,9 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \n func (r *LogRepository) SealCollection(ctx context.Context, collectionID string) (err error) {\n \t_, err = r.queries.SealLog(ctx, collectionID)\n+\tif err != nil && strings.Contains(err.Error(), \"no rows in result set\") {\n+\t\t_, err = r.queries.SealLogInsert(ctx, collectionID)\n+\t}\n \treturn\n }\n \n---\ngo/pkg/log/store/db/queries.sql.go\n@@ -292,6 +292,22 @@ func (q *Queries) SealLog(ctx context.Context, id string) (Collection, error) {\n \treturn i, err\n }\n \n+const sealLogInsert = `-- name: SealLogInsert :one\n+INSERT INTO collection(id, is_sealed, record_compaction_offset_position, record_enumeration_offset_position) VALUES ($1, true, 0, 0) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+`\n+\n+func (q *Queries) SealLogInsert(ctx context.Context, id string) (Collection, error) {\n+\trow := q.db.QueryRow(ctx, sealLogInsert, id)\n+\tvar i Collection\n+\terr := row.Scan(\n+\t\t&i.ID,\n+\t\t&i.RecordCompactionOffsetPosition,\n+\t\t&i.RecordEnumerationOffsetPosition,\n+\t\t&i.IsSealed,\n+\t)\n+\treturn i, err\n+}\n+\n const updateCollectionCompactionOffsetPosition = `-- name: UpdateCollectionCompactionOffsetPosition :exec\n UPDATE collection set record_compaction_offset_position = $2 where id = $1\n `\n---\ngo/pkg/log/store/queries/queries.sql\n@@ -68,3 +68,6 @@ INSERT INTO record_log (\"offset\", collection_id, timestamp, record)\n \n -- name: SealLog :one\n UPDATE collection SET is_sealed = true WHERE id = $1 returning *;\n+\n+-- name: SealLogInsert :one\n+INSERT INTO collection(id, is_sealed, record_compaction_offset_position, record_enumeration_offset_position) VALUES ($1, true, 0, 0) returning *;\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -364,6 +364,10 @@ pub enum DirtyMarker {\n     },\n     #[serde(rename = \"purge\")]\n     Purge { collection_id: CollectionUuid },\n+    // A Cleared marker is a no-op.  It exists so that a log consisting of mark-dirty markers that\n+    // map onto purge markers will be cleared and can be erased.\n+    #[serde(rename = \"clear\")]\n+    Cleared,\n }\n \n impl DirtyMarker {\n@@ -372,6 +376,7 @@ impl DirtyMarker {\n         match self {\n             DirtyMarker::MarkDirty { collection_id, .. } => *collection_id,\n             DirtyMarker::Purge { collection_id } => *collection_id,\n+            DirtyMarker::Cleared => CollectionUuid::default(),\n         }\n     }\n \n@@ -416,6 +421,7 @@ impl DirtyMarker {\n                 DirtyMarker::Purge { collection_id } => {\n                     forget.push(*collection_id);\n                 }\n+                DirtyMarker::Cleared => {}\n             }\n         }\n         for collection_id in forget {\n@@ -865,22 +871,23 @@ impl LogServer {\n                 backpressure.push(*collection_id);\n             }\n         }\n-        if !markers.is_empty() {\n-            let mut new_cursor = cursor.clone();\n-            new_cursor.position = self.dirty_log.append_many(markers).await?;\n-            let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n-                return Err(Error::CouldNotGetDirtyLogCursors);\n-            };\n-            tracing::info!(\n-                \"Advancing dirty log cursor {:?} -> {:?}\",\n-                cursor.position,\n-                new_cursor.position\n-            );\n-            if let Some(witness) = witness {\n-                cursors.save(&STABLE_PREFIX, &new_cursor, &witness).await?;\n-            } else {\n-                cursors.init(&STABLE_PREFIX, new_cursor).await?;\n-            }\n+        if markers.is_empty() {\n+            markers.push(serde_json::to_string(&DirtyMarker::Cleared).map(Vec::from)?);\n+        }\n+        let mut new_cursor = cursor.clone();\n+        new_cursor.position = self.dirty_log.append_many(markers).await?;\n+        let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n+            return Err(Error::CouldNotGetDirtyLogCursors);\n+        };\n+        tracing::info!(\n+            \"Advancing dirty log cursor {:?} -> {:?}\",\n+            cursor.position,\n+            new_cursor.position\n+        );\n+        if let Some(witness) = witness {\n+            cursors.save(&STABLE_PREFIX, &new_cursor, &witness).await?;\n+        } else {\n+            cursors.init(&STABLE_PREFIX, new_cursor).await?;\n         }\n         self.metrics\n             .log_total_uncompacted_records_count\n---\n\n\n---\n\nChoice D:\n.github/workflows/release-chromadb.yml\n@@ -220,7 +220,7 @@ jobs:\n                 // - This workflow finishes for A and deploys A to Chroma Cloud\n                 // Chroma Cloud is now running A, but the last commit was B.\n                 \"environment\": \"staging\",\n-                \"planes\": \"data,control\"\n+                \"planes\": \"control,data\"\n               }\n             })\n \n---\n.github/workflows/trigger-deploy.yaml\n@@ -5,8 +5,9 @@ on:\n   push:\n     branches:\n       # main is not included here because it is handled by the release-chromadb.yaml workflow\n+      # production deploys (release branches) are also not here because they are currently\n+      # meant to be handled manually.\n       - rc/**-**-**\n-      - release/**-**-**\n \n jobs:\n   deploy:\n@@ -25,7 +26,7 @@ jobs:\n               ref: 'main',\n               inputs: {\n                 'planes': 'control,data',\n-                 environment: '${{ contains(github.ref, 'release/') && 'production' || 'staging' }}',\n+                 environment: 'staging',\n                 'ignore-lock': true,\n                 'oss-ref': '${{ github.ref_name }}',\n                 'hosted-ref': '${{ github.ref_name }}'\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nRelease JS client 2.4.7\n\n---\n\nChoice A:\nrust/load/src/lib.rs\n@@ -1271,13 +1271,11 @@ impl LoadService {\n             for declared in declared {\n                 if let Entry::Vacant(entry) = running.entry(declared.uuid) {\n                     tracing::info!(\"spawning workload {}\", declared.uuid);\n-                    let root = tracing::info_span!(parent: None, \"workload\");\n                     let this = Arc::clone(self);\n                     let done = Arc::new(AtomicBool::new(false));\n                     let done_p = Arc::clone(&done);\n                     let inhibit = Arc::clone(&self.inhibit);\n                     let task = tokio::task::spawn(async move {\n-                        let _enter = root.enter();\n                         this.run_one_workload(done, inhibit, declared).await\n                     });\n                     entry.insert((done_p, task));\n@@ -1295,36 +1293,6 @@ impl LoadService {\n         let client = Arc::new(client(spec.connection.clone()).await);\n         let mut guac = Guacamole::new(spec.expires.timestamp_millis() as u64);\n         let mut next_op = Instant::now();\n-        let (tx, mut rx) = tokio::sync::mpsc::channel(1000);\n-        let _ = tx\n-            .send(tokio::spawn(async move { Ok::<(), Error>(()) }))\n-            .await;\n-        let this = Arc::clone(&self);\n-        let data_set = Arc::clone(&spec.data_set);\n-        let reaper = tokio::spawn(async move {\n-            while let Some(task) = rx.recv().await {\n-                if let Err(err) = task.await.unwrap() {\n-                    if !format!(\"{err:?}\").contains(\"429\") {\n-                        this.metrics.failed.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                        tracing::error!(\"workload task failed: {err:?}\");\n-                    } else {\n-                        this.metrics.limited.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                    }\n-                }\n-            }\n-        });\n \n         // Initialize the data set.\n         let data_set = Arc::clone(&spec.data_set);\n@@ -1408,30 +1376,44 @@ impl LoadService {\n                         .await\n                         .map_err(|err| Error::FailWorkload(err.to_string()))\n                     {\n-                        Ok(()) => Ok(()),\n+                        Ok(()) => (),\n                         Err(err) => {\n-                            if err.to_string().contains(\"invalid request: No results\") {\n+                            if format!(\"{err:?}\").contains(\"invalid request: No results\") {\n                                 this.metrics.no_results.add(\n                                     1,\n                                     &[KeyValue::new(\n                                         Key::from_static_str(\"data_set\"),\n                                         Value::from(data_set.name()),\n                                     )],\n                                 );\n-                                Ok(())\n+                                tracing::warn!(\"workload step no results: {err:?}\");\n+                            } else if !format!(\"{err:?}\").contains(\"429\") {\n+                                this.metrics.failed.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::error!(\"workload step failed: {err:?}\");\n                             } else {\n-                                Err(err)\n+                                this.metrics.limited.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::warn!(\"workload step rate limited: {err:?}\");\n                             }\n                         }\n-                    }\n+                    };\n                 };\n-                tx.send(tokio::spawn(fut)).await.unwrap();\n+                let span = tracing::info_span!(parent: None, \"step\", workload_uuid = %spec.uuid);\n+                tokio::spawn(fut.instrument(span));\n             }\n         }\n-        // Not an error, just needs to show up in stdout.\n-        tracing::error!(\"workload done: {}/{}\", spec.name, spec.description());\n-        drop(tx);\n-        reaper.await.unwrap();\n+        tracing::info!(\"workload done: {}/{}\", spec.name, spec.description());\n     }\n \n     fn load_persistent(&self) -> Result<(), Error> {\n---\n\n\n---\n\nChoice B:\nCargo.lock\n@@ -1442,7 +1442,7 @@ dependencies = [\n \n [[package]]\n name = \"chroma-cli\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n dependencies = [\n  \"arboard\",\n  \"axum 0.8.1\",\n---\nclients/js/packages/chromadb/src/cli.ts\n@@ -23,7 +23,7 @@ const update = async (): Promise<void> => {\n     const installedVersion = process.env.CHROMADB_VERSION || \"0.0.0\";\n     const latestVersion = await getLatestVersion(\"chromadb\");\n \n-    if (semver.lte(installedVersion, latestVersion)) {\n+    if (semver.lt(installedVersion, latestVersion)) {\n       console.log(`\\nA new chromadb version (${latestVersion}) is available!`);\n       console.log(\"\\n\\x1b[4mUpdat with npm\\x1b[0m\");\n       console.log(\"npm install chromadb@latest\");\n---\nrust/cli/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"chroma-cli\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n edition = \"2021\"\n \n [dependencies]\n---\nrust/cli/src/commands/install.rs\n@@ -390,7 +390,7 @@ async fn get_app(\n         Version::parse(&app.cli_version).map_err(|_| InstallError::ListingFailed)?;\n     let cli_version =\n         Version::parse(env!(\"CARGO_PKG_VERSION\")).map_err(|_| InstallError::ListingFailed)?;\n-    if app_cli_version < cli_version {\n+    if app_cli_version > cli_version {\n         return Err(\n             InstallError::VersionMismatch(app_name.clone(), app_cli_version.to_string()).into(),\n         );\n---\nrust/cli/src/commands/update.rs\n@@ -2,6 +2,7 @@ use crate::utils::CliError;\n use colored::Colorize;\n use regex::Regex;\n use semver::Version;\n+use serde::Deserialize;\n use std::error::Error;\n use thiserror::Error;\n \n@@ -19,25 +20,26 @@ pub enum UpdateError {\n     UpdateFailed,\n }\n \n+#[derive(Debug, Deserialize)]\n+struct Release {\n+    tag_name: String,\n+}\n+\n async fn version_check(current_version: Version) -> Result<(), Box<dyn Error>> {\n     let client = reqwest::Client::new();\n-    let response = client\n+    let releases = client\n         .get(GITHUB_RELEASES_URL)\n         .header(\"User-Agent\", \"reqwest\")\n         .send()\n+        .await?\n+        .json::<Vec<Release>>()\n         .await?;\n \n-    if !response.status().is_success() {\n-        return Err(UpdateError::FailedVersionFetch.into());\n-    }\n-\n-    let releases: Vec<String> = response.json().await?;\n-\n     let cli_version_pattern = Regex::new(r\"^cli-(\\d+\\.\\d+\\.\\d+)$\")?;\n     let mut cli_versions = Vec::new();\n \n     for release in releases {\n-        if let Some(caps) = cli_version_pattern.captures(&release) {\n+        if let Some(caps) = cli_version_pattern.captures(&release.tag_name) {\n             if let Some(ver_match) = caps.get(1) {\n                 let ver_str = ver_match.as_str();\n                 if let Ok(ver) = Version::parse(ver_str) {\n---\n\n\n---\n\nChoice C:\nCargo.lock\n@@ -3340,6 +3340,7 @@ dependencies = [\n  \"tokio\",\n  \"tokio-test\",\n  \"tonic\",\n+ \"tonic-health\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-test\",\n---\nidl/chromadb/proto/garbage_collector.proto\n@@ -0,0 +1,6 @@\n+syntax = \"proto3\";\n+\n+package chroma;\n+\n+// This is a placeholder service. The garbage collector currently only exposes a health service.\n+service GarbageCollector {}\n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.43\n+version: 0.1.44\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/garbage-collector.yaml\n@@ -40,6 +40,9 @@ spec:\n       - name: garbage-collector\n         image: \"{{ .Values.garbageCollector.image.repository }}:{{ .Values.garbageCollector.image.tag }}\"\n         imagePullPolicy: IfNotPresent\n+        readinessProbe:\n+          grpc:\n+            port: 50055\n         {{ if .Values.garbageCollector.resources }}\n         resources:\n           limits:\n---\nrust/garbage_collector/Cargo.toml\n@@ -27,6 +27,7 @@ tokio = { workspace = true }\n uuid = { workspace = true }\n futures = { workspace = true }\n tonic = { workspace = true }\n+tonic-health = { workspace = true }\n tempfile = { workspace = true }\n tracing = { workspace = true }\n thiserror = { workspace = true }\n---\nrust/garbage_collector/src/config.rs\n@@ -38,6 +38,8 @@ pub(super) struct GarbageCollectorConfig {\n     pub(super) assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig,\n     pub(super) memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig,\n     pub my_member_id: String,\n+    #[serde(default = \"GarbageCollectorConfig::default_port\")]\n+    pub port: u16,\n }\n \n impl GarbageCollectorConfig {\n@@ -61,6 +63,10 @@ impl GarbageCollectorConfig {\n             Err(e) => panic!(\"Error loading config: {}\", e),\n         }\n     }\n+\n+    fn default_port() -> u16 {\n+        50055\n+    }\n }\n \n #[cfg(test)]\n---\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -633,6 +633,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n@@ -753,6 +754,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n---\nrust/garbage_collector/src/lib.rs\n@@ -6,9 +6,11 @@ use chroma_tracing::{\n     init_global_filter_layer, init_otel_layer, init_panic_tracing_hook, init_stdout_layer,\n     init_tracing,\n };\n+use chroma_types::chroma_proto::garbage_collector_server::GarbageCollectorServer;\n use config::GarbageCollectorConfig;\n use garbage_collector_component::GarbageCollector;\n use tokio::signal::unix::{signal, SignalKind};\n+use tonic::transport::Server;\n use tracing::{debug, error, info};\n \n mod config;\n@@ -24,7 +26,20 @@ pub mod types;\n \n const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n \n+// This is a placeholder service so that we can expose a health service\n+struct GarbageCollectorService {}\n+\n+impl chroma_types::chroma_proto::garbage_collector_server::GarbageCollector\n+    for GarbageCollectorService\n+{\n+}\n+\n pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::error::Error>> {\n+    let (mut health_reporter, health_service) = tonic_health::server::health_reporter();\n+    health_reporter\n+        .set_not_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     debug!(\"Loading configuration from environment\");\n     // Parse configuration. Configuration includes sysdb connection details, and\n     // gc run details amongst others.\n@@ -49,6 +64,27 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n \n     info!(\"Loaded configuration successfully: {:#?}\", config);\n \n+    let addr = format!(\"[::]:{}\", config.port)\n+        .parse()\n+        .expect(\"Invalid address format\");\n+    let server_join_handle = tokio::spawn(async move {\n+        let server = Server::builder().add_service(health_service);\n+        server\n+            .serve_with_shutdown(addr, async {\n+                match signal(SignalKind::terminate()) {\n+                    Ok(mut sigterm) => {\n+                        sigterm.recv().await;\n+                        tracing::info!(\"Received SIGTERM, shutting down gRPC server\");\n+                    }\n+                    Err(err) => {\n+                        tracing::error!(\"Failed to create SIGTERM handler: {err}\")\n+                    }\n+                }\n+            })\n+            .await\n+            .expect(\"Failed to start gRPC server\");\n+    });\n+\n     let registry = chroma_config::registry::Registry::new();\n     let system = System::new();\n \n@@ -79,6 +115,10 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n     memberlist.subscribe(garbage_collector_handle.receiver());\n     let mut memberlist_handle = system.start_component(memberlist);\n \n+    health_reporter\n+        .set_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     // Keep the service running and handle shutdown signals\n     let mut sigterm = signal(SignalKind::terminate())?;\n     let mut sigint = signal(SignalKind::interrupt())?;\n@@ -112,6 +152,7 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n         .expect(\"Dispatcher should be stoppable\");\n     system.stop().await;\n     system.join().await;\n+    let _ = server_join_handle.await;\n \n     info!(\"Shutting down garbage collector service\");\n     Ok(())\n---\nrust/types/build.rs\n@@ -6,6 +6,7 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n         \"idl/chromadb/proto/coordinator.proto\",\n         \"idl/chromadb/proto/logservice.proto\",\n         \"idl/chromadb/proto/query_executor.proto\",\n+        \"idl/chromadb/proto/garbage_collector.proto\",\n     ];\n \n     // Can't use #[cfg(test)] here because a build for tests is technically a regular debug build, meaning that #[cfg(test)] is useless in build.rs.\n---\nrust/types/src/lib.rs\n@@ -47,6 +47,7 @@ pub use tenant::*;\n pub use types::*;\n pub use where_parsing::*;\n \n+#[allow(clippy::all)]\n pub mod chroma_proto {\n     tonic::include_proto!(\"chroma\");\n }\n---\n\n\n---\n\nChoice D:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.2\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.1.2\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.2\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.2\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.2\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.3\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.1.3\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.3\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.3\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.3\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nDescription of how it happens in the tests.\n\n## Test plan\n\nCI + local testing of the new test.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/test/distributed/test_log_failover.py\n@@ -19,6 +19,9 @@\n     skip_if_not_cluster,\n )\n from chromadb.test.property import invariants\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n+\n+RECORDS = 100\n \n @skip_if_not_cluster()\n def test_log_failover(\n@@ -39,32 +42,106 @@ def test_log_failover(\n     channel = grpc.insecure_channel('localhost:50052')\n     log_service_stub = LogServiceStub(channel)\n \n-    # Add 100 records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n+    # and 1\n+    for i in range(RECORDS, RECORDS + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_compaction(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n     ids = []\n     embeddings = []\n-    for i in range(100):\n+    for i in range(RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n+        if i == RECORDS / 2:\n+            # NOTE(rescrv):  This compaction tests a very particular race when migrating logs.\n+            # Imagine this sequence:\n+            # 1. Write 51 records to the go log.\n+            # 2. Compact all 51 records.\n+            # 3. Write 49 more records to the go log.\n+            # 4. Seal the go log.\n+            # 5. Log migration moves the remaining 49 records to the rust service.\n+            # 6. Cached frontend tries to read from a timestamp that includes all 100 records, using\n+            #    the initial compaction, but from a log that only has 49 records.\n+            # The fix is to make sure the log returns not found when a prefix of the log is\n+            # compacted.  This forces a fallback to repopulate the cache of the sysdb.\n+            wait_for_version_increase(client, collection.name, 0)\n \n     request = SealLogRequest(collection_id=str(collection.id))\n     response = log_service_stub.SealLog(request, timeout=60)\n \n-    # Add another 100 records, where each embedding has 3 dimensions randomly generated between 0\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n     # and 1\n-    for i in range(100, 200):\n+    for i in range(RECORDS, RECORDS + RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n \n-    for i in range(200):\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n         if len(result[\"embeddings\"]) == 0:\n             print(\"missing result\", i)\n-        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n---\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1545,14 +1545,15 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \tif tc.versionFileEnabled {\n \t\treturn tc.FlushCollectionCompactionForVersionedCollection(ctx, flushCollectionCompaction)\n \t}\n+\tcollectionID := types.FromUniqueID(flushCollectionCompaction.ID)\n \n \tflushCollectionInfo := &model.FlushCollectionInfo{\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n \terr := tc.txImpl.Transaction(ctx, func(txCtx context.Context) error {\n \t\t// Check if collection exists.\n-\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(types.FromUniqueID(flushCollectionCompaction.ID), nil, nil)\n+\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(collectionID, nil, nil)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1589,6 +1590,7 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \t\t// return nil will commit the transaction\n \t\treturn nil\n \t})\n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", *collectionID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1641,6 +1643,8 @@ func (tc *Catalog) FlushCollectionCompactionForVersionedCollection(ctx context.C\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", flushCollectionInfo.ID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n+\n \t// Do the operation in a loop until the CollectionEntry is updated,\n \t// \t\tOR FAIL the operation if the version is stale\n \t//      OR other DB error.\n---\nrust/log-service/src/lib.rs\n@@ -1080,6 +1080,9 @@ impl LogService for LogServer {\n                     });\n                 }\n             }\n+            if !records.is_empty() && records[0].log_offset != pull_logs.start_from_offset {\n+                return Err(Status::not_found(\"Some entries have been purged\"));\n+            }\n             tracing::info!(\"pulled {} records\", records.len());\n             Ok(Response::new(PullLogsResponse { records }))\n         }\n---\n\n\n---\n\nChoice B:\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -549,6 +549,8 @@ impl ServiceBasedFrontend {\n     pub async fn retryable_fork(\n         &mut self,\n         ForkCollectionRequest {\n+            tenant_id,\n+            database_name,\n             source_collection_id,\n             target_collection_name,\n             ..\n@@ -570,12 +572,25 @@ impl ServiceBasedFrontend {\n             )\n             .await?;\n         let collection = collection_and_segments.collection.clone();\n+        let latest_collection_logical_size_bytes = collection_and_segments\n+            .collection\n+            .size_bytes_post_compaction;\n \n         // Update the cache.\n         self.collections_with_segments_provider\n             .set_collection_with_segments(collection_and_segments)\n             .await;\n \n+        // TODO: Submit event after the response is sent\n+        MeterEvent::CollectionFork {\n+            tenant: tenant_id,\n+            database: database_name,\n+            collection_id: source_collection_id.0,\n+            latest_collection_logical_size_bytes,\n+        }\n+        .submit()\n+        .await;\n+\n         Ok(collection)\n     }\n \n---\nrust/tracing/src/meter_event.rs\n@@ -26,6 +26,12 @@ pub enum WriteAction {\n #[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]\n #[serde(rename_all = \"snake_case\", tag = \"event_name\")]\n pub enum MeterEvent {\n+    CollectionFork {\n+        tenant: String,\n+        database: String,\n+        collection_id: Uuid,\n+        latest_collection_logical_size_bytes: u64,\n+    },\n     CollectionRead {\n         tenant: String,\n         database: String,\n---\n\n\n---\n\nChoice C:\nrust/cli/src/commands/mod.rs\n@@ -7,3 +7,4 @@ pub mod profile;\n pub mod run;\n pub mod update;\n pub mod vacuum;\n+pub mod webpage;\n---\nrust/cli/src/commands/webpage.rs\n@@ -0,0 +1,29 @@\n+use crate::utils::CliError;\n+use thiserror::Error;\n+\n+#[derive(Debug, Error)]\n+pub enum WebPageError {\n+    #[error(\"Failed to open browser. {0}\")]\n+    BrowserOpenFailed(String),\n+}\n+\n+pub enum WebPageCommand {\n+    Discord,\n+    Docs,\n+}\n+\n+impl WebPageCommand {\n+    fn url(&self) -> &'static str {\n+        match self {\n+            WebPageCommand::Discord => \"https://discord.gg/MMeYNTmh3x\",\n+            WebPageCommand::Docs => \"https://docs.trychroma.com\",\n+        }\n+    }\n+}\n+\n+pub fn open_browser(command: WebPageCommand) -> Result<(), CliError> {\n+    let url = command.url();\n+    let error_message = format!(\"Visit {}\", url);\n+    webbrowser::open(url).map_err(|_| WebPageError::BrowserOpenFailed(error_message))?;\n+    Ok(())\n+}\n---\nrust/cli/src/lib.rs\n@@ -13,10 +13,9 @@ use crate::commands::profile::{profile_command, ProfileCommand};\n use crate::commands::run::{run, RunArgs};\n use crate::commands::update::update;\n use crate::commands::vacuum::{vacuum, VacuumArgs};\n+use crate::commands::webpage::{open_browser, WebPageCommand};\n use clap::{Parser, Subcommand};\n use colored::Colorize;\n-use utils::CliError;\n-use utils::UtilsError;\n \n #[derive(Subcommand, Debug)]\n enum Command {\n@@ -44,12 +43,6 @@ struct Cli {\n     command: Command,\n }\n \n-fn open_browser(url: &str) -> Result<(), CliError> {\n-    let error_message = format!(\"Visit {}\", url);\n-    webbrowser::open(url).map_err(|_| UtilsError::BrowserOpenFailed(error_message))?;\n-    Ok(())\n-}\n-\n pub fn chroma_cli(args: Vec<String>) {\n     let cli = Cli::parse_from(args);\n \n@@ -59,18 +52,12 @@ pub fn chroma_cli(args: Vec<String>) {\n         Command::Browse(args) => browse(args),\n         Command::Copy(args) => copy(args),\n         Command::Db(db_subcommand) => db_command(db_subcommand),\n-        Command::Docs => {\n-            let url = \"https://docs.trychroma.com\";\n-            open_browser(url)\n-        }\n+        Command::Docs => open_browser(WebPageCommand::Docs),\n         Command::Install(args) => install(args),\n         Command::Login(args) => login(args),\n         Command::Profile(profile_subcommand) => profile_command(profile_subcommand),\n         Command::Run(args) => run(args),\n-        Command::Support => {\n-            let url = \"https://discord.gg/MMeYNTmh3x\";\n-            open_browser(url)\n-        }\n+        Command::Support => open_browser(WebPageCommand::Discord),\n         Command::Update => update(),\n         Command::Vacuum(args) => vacuum(args),\n     };\n---\nrust/cli/src/utils.rs\n@@ -11,6 +11,7 @@ use crate::commands::profile::ProfileError;\n use crate::commands::run::RunError;\n use crate::commands::update::UpdateError;\n use crate::commands::vacuum::VacuumError;\n+use crate::commands::webpage::WebPageError;\n use crate::ui_utils::Theme;\n use chroma_frontend::config::FrontendServerConfig;\n use chroma_frontend::frontend_service_entrypoint_with_config;\n@@ -64,6 +65,8 @@ pub enum CliError {\n     Copy(#[from] CopyError),\n     #[error(\"{0}\")]\n     Collection(#[from] CollectionAPIError),\n+    #[error(\"{0}\")]\n+    WebPage(#[from] WebPageError),\n }\n \n #[derive(Debug, Error)]\n@@ -90,8 +93,6 @@ pub enum UtilsError {\n     ConfigFileWriteFailed,\n     #[error(\"Failed to get user input\")]\n     UserInputFailed,\n-    #[error(\"Failed to open browser. {0}\")]\n-    BrowserOpenFailed(String),\n     #[error(\"Failed to copy to clipboard\")]\n     CopyToClipboardFailed,\n     #[error(\"Input validation failed\")]\n---\n\n\n---\n\nChoice D:\n.github/actions/docker/action.yaml\n@@ -17,11 +17,6 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n-    # https://github.com/docker/setup-qemu-action - for multiplatform builds\n-    - name: Set up QEMU\n-      uses: docker/setup-qemu-action@v2\n-    - name: Set up Docker Buildx\n-      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n.github/workflows/_build_release_container.yml\n@@ -33,43 +33,106 @@ permissions:\n env:\n   GHCR_IMAGE_NAME: \"ghcr.io/chroma-core/chroma\"\n   DOCKERHUB_IMAGE_NAME: \"chromadb/chroma\"\n-  PLATFORMS: linux/amd64,linux/arm64 #linux/riscv64, linux/arm/v7\n \n jobs:\n   build:\n-    name: Build and publish container image\n+    name: Build image for ${{ matrix.platform }}\n     runs-on: blacksmith-16vcpu-ubuntu-2204\n+    strategy:\n+      matrix:\n+        platform: [amd64, arm64]\n+        include:\n+          - platform: amd64\n+            runner: blacksmith-16vcpu-ubuntu-2204\n+            docker_platform: linux/amd64\n+          - platform: arm64\n+            runner: blacksmith-16vcpu-ubuntu-2204-arm\n+            docker_platform: linux/arm64\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n         with:\n           fetch-depth: 0\n+\n       - name: Set up Docker\n         uses: ./.github/actions/docker\n         with:\n           ghcr-username: ${{ github.actor }}\n           ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n           dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-      - name: Compute tags\n+\n+      - name: Compute arch-specific tags\n+        id: tags\n         shell: bash\n-        id: compute_tags\n         run: |\n-          tags=\"${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }},${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\"\n-          if [ \"${{ inputs.tag_as_latest }}\" = \"true\" ]; then\n-            tags=\"${tags},${{ env.GHCR_IMAGE_NAME }}:latest,${{ env.DOCKERHUB_IMAGE_NAME }}:latest\"\n-          fi\n+          arch_tag=\"${{ inputs.tag }}-${{ matrix.platform }}\"\n+          ghcr=\"${{ env.GHCR_IMAGE_NAME }}:${arch_tag}\"\n+          dhub=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${arch_tag}\"\n+          echo \"arch_tag=$arch_tag\"      >> $GITHUB_OUTPUT\n \n-          echo \"tags=${tags}\" >> $GITHUB_OUTPUT\n+          # expose *matrix-unique* step outputs\n+          echo \"ghcr_tag_${{ matrix.platform }}=$ghcr\"         >> $GITHUB_OUTPUT\n+          echo \"dockerhub_tag_${{ matrix.platform }}=$dhub\"    >> $GITHUB_OUTPUT\n+\n+          # these two tags are what the build-push action will publish for *this* arch\n+          echo \"tags=$ghcr,$dhub\" >> $GITHUB_OUTPUT\n \n       - name: Build and push image\n         uses: useblacksmith/build-push-action@v1.1\n         with:\n           context: .\n           file: rust/Dockerfile\n           target: cli\n-          platforms: ${{ env.PLATFORMS }}\n+          platforms: ${{ matrix.docker_platform }}\n           push: true\n           build-args: |\n             RELEASE_MODE=1\n-          tags: ${{ steps.compute_tags.outputs.tags }}\n+          tags: ${{ steps.tags.outputs.tags }}\n+    outputs:\n+      ghcr_tag_amd64:      ${{ steps.tags.outputs.ghcr_tag_amd64 }}\n+      ghcr_tag_arm64:      ${{ steps.tags.outputs.ghcr_tag_arm64 }}\n+      dockerhub_tag_amd64: ${{ steps.tags.outputs.dockerhub_tag_amd64 }}\n+      dockerhub_tag_arm64: ${{ steps.tags.outputs.dockerhub_tag_arm64 }}\n+\n+  merge:\n+    name: Merge platform manifests\n+    runs-on: blacksmith-4vcpu-ubuntu-2204\n+    needs:\n+      - build\n+    steps:\n+      - name: Set up Docker\n+        uses: ./.github/actions/docker\n+        with:\n+          ghcr-username: ${{ github.actor }}\n+          ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n+          dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n+          dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n+\n+      - name: Create and push manifest\n+        shell: bash\n+        run: |\n+          set -euo pipefail\n+\n+          # Pull the per-arch tags from job-level outputs\n+          ghcr_amd64='${{ needs.build.outputs.ghcr_tag_amd64 }}'\n+          ghcr_arm64='${{ needs.build.outputs.ghcr_tag_arm64 }}'\n+          dhub_amd64='${{ needs.build.outputs.dockerhub_tag_amd64 }}'\n+          dhub_arm64='${{ needs.build.outputs.dockerhub_tag_arm64 }}'\n+\n+          base_tag='${{ inputs.tag }}'\n+          ghcr_base=\"${{ env.GHCR_IMAGE_NAME }}:${base_tag}\"\n+          dhub_base=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${base_tag}\"\n+\n+          docker buildx imagetools create --tag \"$ghcr_base\" $ghcr_amd64 $ghcr_arm64\n+          docker buildx imagetools create --tag \"$dhub_base\"  $dhub_amd64 $dhub_arm64\n+\n+          if [[ \"${{ inputs.tag_as_latest }}\" == \"true\" ]]; then\n+            docker buildx imagetools create --tag \"${{ env.GHCR_IMAGE_NAME }}:latest\"  $ghcr_amd64 $ghcr_arm64\n+            docker buildx imagetools create --tag \"${{ env.DOCKERHUB_IMAGE_NAME }}:latest\" $dhub_amd64 $dhub_arm64\n+          fi\n+\n+      - name: Inspect image\n+        run: |\n+          docker buildx imagetools inspect ${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }}\n+          docker buildx imagetools inspect ${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis PR cherry-picks the commit 87561f7932208f28c335a15e3856156b4da2c14f onto release/2025-05-16. If there are unresolved conflicts, please resolve them manually.\n\n---\n\nChoice A:\n.github/workflows/release-chromadb.yml\n@@ -220,7 +220,7 @@ jobs:\n                 // - This workflow finishes for A and deploys A to Chroma Cloud\n                 // Chroma Cloud is now running A, but the last commit was B.\n                 \"environment\": \"staging\",\n-                \"planes\": \"data,control\"\n+                \"planes\": \"control,data\"\n               }\n             })\n \n---\n.github/workflows/trigger-deploy.yaml\n@@ -5,8 +5,9 @@ on:\n   push:\n     branches:\n       # main is not included here because it is handled by the release-chromadb.yaml workflow\n+      # production deploys (release branches) are also not here because they are currently\n+      # meant to be handled manually.\n       - rc/**-**-**\n-      - release/**-**-**\n \n jobs:\n   deploy:\n@@ -25,7 +26,7 @@ jobs:\n               ref: 'main',\n               inputs: {\n                 'planes': 'control,data',\n-                 environment: '${{ contains(github.ref, 'release/') && 'production' || 'staging' }}',\n+                 environment: 'staging',\n                 'ignore-lock': true,\n                 'oss-ref': '${{ github.ref_name }}',\n                 'hosted-ref': '${{ github.ref_name }}'\n---\n\n\n---\n\nChoice B:\ndocs/docs.trychroma.com/markdoc/content/reference/python/client.md\n@@ -272,7 +272,7 @@ List all collections.\n \n **Returns**:\n \n-- `Sequence[CollectionName]` - A list of collection names. `CollectionName` is a string.\n+- `Sequence[Collection]` - A list of collection objects.\n \n \n **Examples**:\n---\ndocs/docs.trychroma.com/markdoc/content/updates/migration.md\n@@ -26,6 +26,8 @@ In this release, we've rewritten much of Chroma in Rust. Performance has signifi\n \n Chroma no longer provides built-in authentication implementations.\n \n+`list_collections` now reverts back to returning `Collection` objects.\n+\n **Chroma in-process changes**\n \n This section is applicable to you if you use Chroma via\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/impls/utils.rs\n@@ -8,6 +8,8 @@ use chroma_types::{\n pub(crate) enum ToRecordsError {\n     #[error(\"Inconsistent number of IDs, embeddings, documents, URIs and metadatas\")]\n     InconsistentLength,\n+    #[error(\"Empty ID, ID must have at least one character\")]\n+    EmptyId,\n }\n \n impl ChromaError for ToRecordsError {\n@@ -47,6 +49,9 @@ pub(crate) fn to_records<\n     let mut records = Vec::with_capacity(len);\n \n     for id in ids {\n+        if id.is_empty() {\n+            return Err(ToRecordsError::EmptyId);\n+        }\n         let embedding = embeddings_iter.next().flatten();\n         let document = documents_iter.next().flatten();\n         let uri = uris_iter.next().flatten();\n@@ -87,3 +92,59 @@ pub(crate) fn to_records<\n \n     Ok((records, total_bytes))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use chroma_types::Operation;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_to_records_empty_id() {\n+        let ids = vec![String::from(\"\")];\n+        let embeddings = vec![Some(vec![1.0, 2.0, 3.0])];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(ids, Some(embeddings), None, None, None, Operation::Add);\n+        assert!(matches!(result, Err(ToRecordsError::EmptyId)));\n+    }\n+\n+    #[test]\n+    fn test_normal_ids() {\n+        let ids = vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\")];\n+        let embeddings = vec![\n+            Some(vec![1.0, 2.0, 3.0]),\n+            Some(vec![4.0, 5.0, 6.0]),\n+            Some(vec![7.0, 8.0, 9.0]),\n+        ];\n+        let documents = vec![\n+            Some(String::from(\"document 1\")),\n+            Some(String::from(\"document 2\")),\n+            Some(String::from(\"document 3\")),\n+        ];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(\n+            ids,\n+            Some(embeddings),\n+            Some(documents),\n+            None,\n+            None,\n+            Operation::Add,\n+        );\n+        assert!(result.is_ok());\n+        let records = result.unwrap().0;\n+        assert_eq!(records.len(), 3);\n+        assert_eq!(records[0].id, \"1\");\n+        assert_eq!(records[1].id, \"2\");\n+        assert_eq!(records[2].id, \"3\");\n+        assert_eq!(records[0].embedding, Some(vec![1.0, 2.0, 3.0]));\n+        assert_eq!(records[1].embedding, Some(vec![4.0, 5.0, 6.0]));\n+        assert_eq!(records[2].embedding, Some(vec![7.0, 8.0, 9.0]));\n+        assert_eq!(records[0].document, Some(String::from(\"document 1\")));\n+        assert_eq!(records[1].document, Some(String::from(\"document 2\")));\n+        assert_eq!(records[2].document, Some(String::from(\"document 3\")));\n+    }\n+}\n---\n\n\n---\n\nChoice D:\ngo/cmd/logservice/main.go\n@@ -2,8 +2,8 @@ package main\n \n import (\n \t\"context\"\n-\t\"net\"\n \n+\t\"github.com/chroma-core/chroma/go/pkg/grpcutils\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/configuration\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/leader\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/metrics\"\n@@ -15,7 +15,6 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/utils\"\n \tlibs \"github.com/chroma-core/chroma/go/shared/libs\"\n \t\"github.com/chroma-core/chroma/go/shared/otel\"\n-\tsharedOtel \"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"github.com/pingcap/log\"\n \t\"github.com/rs/zerolog\"\n \t\"go.uber.org/automaxprocs/maxprocs\"\n@@ -50,22 +49,21 @@ func main() {\n \tsysDb := sysdb.NewSysDB(config.SYSDB_CONN)\n \tlr := repository.NewLogRepository(conn, sysDb)\n \tserver := server.NewLogServer(lr)\n-\tvar listener net.Listener\n-\tlistener, err = net.Listen(\"tcp\", \":\"+config.PORT)\n+\n+\t_, err = grpcutils.Default.StartGrpcServer(\"log-service\", &grpcutils.GrpcConfig{\n+\t\tBindAddress: \":\" + config.PORT,\n+\t}, func(registrar grpc.ServiceRegistrar) {\n+\t\thealthcheck := health.NewServer()\n+\t\thealthgrpc.RegisterHealthServer(registrar, healthcheck)\n+\t\tlogservicepb.RegisterLogServiceServer(registrar, server)\n+\t})\n \tif err != nil {\n-\t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n+\t\tlog.Fatal(\"failed to create grpc server\", zap.Error(err))\n \t}\n-\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n-\thealthcheck := health.NewServer()\n-\thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n-\tlogservicepb.RegisterLogServiceServer(s, server)\n-\tlog.Info(\"log service started\", zap.String(\"address\", listener.Addr().String()))\n+\tlog.Info(\"log service started\")\n \tgo leader.AcquireLeaderLock(ctx, func(ctx context.Context) {\n \t\tgo purging.PerformPurgingLoop(ctx, lr)\n \t\tgo metrics.PerformMetricsLoop(ctx, lr)\n \t})\n-\tif err := s.Serve(listener); err != nil {\n-\t\tlog.Fatal(\"failed to serve\", zap.Error(err))\n-\t}\n }\n---\ngo/pkg/grpcutils/service.go\n@@ -4,11 +4,12 @@ import (\n \t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n-\t\"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"io\"\n \t\"net\"\n \t\"os\"\n \n+\t\"github.com/chroma-core/chroma/go/shared/otel\"\n+\n \t\"github.com/pingcap/log\"\n \t\"go.uber.org/zap\"\n \t\"google.golang.org/grpc\"\n@@ -82,7 +83,7 @@ func newDefaultGrpcProvider(name string, grpcConfig *GrpcConfig, registerFunc fu\n \tOPTL_TRACING_ENDPOINT := os.Getenv(\"OPTL_TRACING_ENDPOINT\")\n \tif OPTL_TRACING_ENDPOINT != \"\" {\n \t\totel.InitTracing(context.Background(), &otel.TracingConfig{\n-\t\t\tService:  \"sysdb-service\",\n+\t\t\tService:  name,\n \t\t\tEndpoint: OPTL_TRACING_ENDPOINT,\n \t\t})\n \t}\n---\ngo/pkg/sysdb/grpc/server.go\n@@ -158,7 +158,7 @@ func NewWithGrpcProvider(config Config, provider grpcutils.GrpcProvider) (*Serve\n \t\ts.softDeleteCleaner.Start()\n \n \t\tlog.Info(\"Starting GRPC server\")\n-\t\ts.grpcServer, err = provider.StartGrpcServer(\"coordinator\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n+\t\ts.grpcServer, err = provider.StartGrpcServer(\"sysdb-service\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n \t\t\tcoordinatorpb.RegisterSysDBServer(registrar, s)\n \t\t\thealthgrpc.RegisterHealthServer(registrar, s.healthServer)\n \t\t})\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - Adds a inner trace handler for requests, the current span starts when clients connect, so it includes request upload. This will only include the inner type to handle the request\r\n  - Pic of jaeger to demonstrate, only `HANDLER` actually includes the request processing time\r\n<img width=\"1728\" alt=\"Screenshot 2025-05-20 at 4 03 30 PM\" src=\"https://github.com/user-attachments/assets/00d8c0d7-cae4-4154-92b0-544c12f004f5\" />\r\n\r\n- New functionality\r\n  - ...\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\nI checked via jaeger, by trickling requests\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nclients/new-js/packages/chromadb/src/utils.ts\n@@ -350,7 +350,8 @@ export const validateWhere = (where: Where) => {\n         );\n       }\n \n-      Object.values(where).forEach((w: Where) => validateWhere(w));\n+      value.forEach((w: Where) => validateWhere(w));\n+      return;\n     }\n \n     if (typeof value === \"object\") {\n---\n\n\n---\n\nChoice B:\n.github/workflows/release-chromadb.yml\n@@ -220,7 +220,7 @@ jobs:\n                 // - This workflow finishes for A and deploys A to Chroma Cloud\n                 // Chroma Cloud is now running A, but the last commit was B.\n                 \"environment\": \"staging\",\n-                \"planes\": \"data,control\"\n+                \"planes\": \"control,data\"\n               }\n             })\n \n---\n.github/workflows/trigger-deploy.yaml\n@@ -5,8 +5,9 @@ on:\n   push:\n     branches:\n       # main is not included here because it is handled by the release-chromadb.yaml workflow\n+      # production deploys (release branches) are also not here because they are currently\n+      # meant to be handled manually.\n       - rc/**-**-**\n-      - release/**-**-**\n \n jobs:\n   deploy:\n@@ -25,7 +26,7 @@ jobs:\n               ref: 'main',\n               inputs: {\n                 'planes': 'control,data',\n-                 environment: '${{ contains(github.ref, 'release/') && 'production' || 'staging' }}',\n+                 environment: 'staging',\n                 'ignore-lock': true,\n                 'oss-ref': '${{ github.ref_name }}',\n                 'hosted-ref': '${{ github.ref_name }}'\n---\n\n\n---\n\nChoice C:\nchromadb/api/async_client.py\n@@ -184,8 +184,11 @@ async def create_collection(\n     ) -> AsyncCollection:\n         if configuration is None:\n             configuration = {}\n-            if embedding_function is not None:\n-                configuration[\"embedding_function\"] = embedding_function\n+        if (\n+            embedding_function is not None\n+            and configuration.get(\"embedding_function\") is None\n+        ):\n+            configuration[\"embedding_function\"] = embedding_function\n         model = await self._server.create_collection(\n             name=name,\n             configuration=configuration,\n@@ -235,8 +238,11 @@ async def get_or_create_collection(\n     ) -> AsyncCollection:\n         if configuration is None:\n             configuration = {}\n-            if embedding_function is not None:\n-                configuration[\"embedding_function\"] = embedding_function\n+        if (\n+            embedding_function is not None\n+            and configuration.get(\"embedding_function\") is None\n+        ):\n+            configuration[\"embedding_function\"] = embedding_function\n         model = await self._server.get_or_create_collection(\n             name=name,\n             configuration=configuration,\n---\nchromadb/api/client.py\n@@ -151,8 +151,11 @@ def create_collection(\n     ) -> Collection:\n         if configuration is None:\n             configuration = {}\n-            if embedding_function is not None:\n-                configuration[\"embedding_function\"] = embedding_function\n+        if (\n+            embedding_function is not None\n+            and configuration.get(\"embedding_function\") is None\n+        ):\n+            configuration[\"embedding_function\"] = embedding_function\n         model = self._server.create_collection(\n             name=name,\n             metadata=metadata,\n@@ -202,8 +205,11 @@ def get_or_create_collection(\n     ) -> Collection:\n         if configuration is None:\n             configuration = {}\n-            if embedding_function is not None:\n-                configuration[\"embedding_function\"] = embedding_function\n+        if (\n+            embedding_function is not None\n+            and configuration.get(\"embedding_function\") is None\n+        ):\n+            configuration[\"embedding_function\"] = embedding_function\n         model = self._server.get_or_create_collection(\n             name=name,\n             metadata=metadata,\n---\nchromadb/test/configurations/test_collection_configuration.py\n@@ -543,6 +543,10 @@ def test_spann_default_parameters(client: ClientAPI) -> None:\n             assert hnsw_config_loaded.get(\"ef_construction\") == 100\n             assert hnsw_config_loaded.get(\"ef_search\") == 100\n             assert hnsw_config_loaded.get(\"max_neighbors\") == 16\n+\n+            ef = loaded_config.get(\"embedding_function\")\n+            assert ef is not None\n+            assert ef.name() == \"default\"\n     else:\n         coll = client.create_collection(\n             name=\"test_spann_defaults\",\n@@ -558,11 +562,15 @@ def test_spann_default_parameters(client: ClientAPI) -> None:\n                 CreateSpannConfiguration, loaded_config.get(\"spann\", {})\n             )\n             assert spann_config_loaded.get(\"space\") == \"cosine\"\n-            assert spann_config_loaded.get(\"ef_construction\") == 200  # default\n-            assert spann_config_loaded.get(\"max_neighbors\") == 16  # default\n-            assert spann_config_loaded.get(\"ef_search\") == 200  # default\n-            assert spann_config_loaded.get(\"search_nprobe\") == 128  # default\n-            assert spann_config_loaded.get(\"write_nprobe\") == 128  # default\n+            assert spann_config_loaded.get(\"ef_construction\") == 200\n+            assert spann_config_loaded.get(\"max_neighbors\") == 16\n+            assert spann_config_loaded.get(\"ef_search\") == 200\n+            assert spann_config_loaded.get(\"search_nprobe\") == 128\n+            assert spann_config_loaded.get(\"write_nprobe\") == 128\n+\n+            ef = loaded_config.get(\"embedding_function\")\n+            assert ef is not None\n+            assert ef.name() == \"default\"\n \n \n def test_spann_json_serialization(client: ClientAPI) -> None:\n---\nclients/js/packages/chromadb-core/src/ChromaClient.ts\n@@ -228,6 +228,12 @@ export class ChromaClient {\n     configuration,\n   }: CreateCollectionParams): Promise<Collection> {\n     await this.init();\n+    if (!configuration) {\n+      configuration = {};\n+    }\n+    if (embeddingFunction && !configuration.embedding_function) {\n+      configuration.embedding_function = embeddingFunction;\n+    }\n     let collectionConfiguration: Api.CollectionConfiguration | undefined =\n       undefined;\n     if (configuration) {\n@@ -293,10 +299,14 @@ export class ChromaClient {\n     configuration,\n   }: GetOrCreateCollectionParams): Promise<Collection> {\n     await this.init();\n-\n+    if (!configuration) {\n+      configuration = {};\n+    }\n+    if (embeddingFunction && !configuration.embedding_function) {\n+      configuration.embedding_function = embeddingFunction;\n+    }\n     let collectionConfiguration: Api.CollectionConfiguration | undefined =\n       undefined;\n-\n     if (configuration) {\n       collectionConfiguration =\n         loadApiCollectionConfigurationFromCreateCollectionConfiguration(\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/tower_tracing.rs\n@@ -6,6 +6,7 @@ use opentelemetry::trace::TraceContextExt;\n use std::time::Duration;\n use tower::Service;\n use tower_http::trace::{MakeSpan, OnResponse, TraceLayer};\n+use tracing::Instrument;\n \n use tracing_opentelemetry::OpenTelemetrySpanExt;\n \n@@ -16,8 +17,7 @@ impl<B> MakeSpan<B> for RequestTracing {\n         let http_route = request\n             .extensions()\n             .get::<MatchedPath>()\n-            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str())\n-            .to_owned();\n+            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str());\n \n         let host = request\n             .headers()\n@@ -56,15 +56,18 @@ impl<B> OnResponse<B> for RequestTracing {\n     }\n }\n \n+/// TracingMiddleware adds trace ID to the response headers\n+/// and wraps the inner handler with a span.\n #[derive(Clone)]\n-pub struct TraceIdMiddleware<S> {\n+pub struct TracingMiddleware<S> {\n     inner: S,\n }\n \n-impl<S, Request, Rs> Service<Request> for TraceIdMiddleware<S>\n+impl<S, B, Rs> Service<Request<B>> for TracingMiddleware<S>\n where\n-    S: Service<Request, Response = Response<Rs>> + Send + 'static,\n+    S: Service<Request<B>, Response = Response<Rs>> + Send + 'static,\n     S::Future: Send + 'static,\n+    B: Send + 'static,\n {\n     type Response = S::Response;\n     type Error = S::Error;\n@@ -77,10 +80,23 @@ where\n         self.inner.poll_ready(cx)\n     }\n \n-    fn call(&mut self, req: Request) -> Self::Future {\n+    fn call(&mut self, req: Request<B>) -> Self::Future {\n+        let http_route = req\n+            .extensions()\n+            .get::<MatchedPath>()\n+            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str());\n+\n+        let handler_span = tracing::span!(\n+            tracing::Level::DEBUG,\n+            \"HTTP request handler\",\n+            http.route = http_route,\n+            otel.name = format!(\"Handler {} {}\", req.method(), http_route),\n+        );\n+\n         let future = self.inner.call(req);\n+\n         Box::pin(async move {\n-            let mut response: Response<Rs> = future.await?;\n+            let mut response: Response<Rs> = future.instrument(handler_span).await?;\n             if response.status().is_client_error() || response.status().is_server_error() {\n                 let trace_id = tracing::Span::current()\n                     .context()\n@@ -109,10 +125,10 @@ impl SetTraceIdLayer {\n }\n \n impl<S> tower::layer::Layer<S> for SetTraceIdLayer {\n-    type Service = TraceIdMiddleware<S>;\n+    type Service = TracingMiddleware<S>;\n \n     fn layer(&self, inner: S) -> Self::Service {\n-        TraceIdMiddleware { inner }\n+        TracingMiddleware { inner }\n     }\n }\n \n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThe log config now takes a UUID.  Every UUID <= to that UUID (so that\nff... will be repesentable) will be forwarded to the rust log prior to\nthe go log.  Every UUID > the configured UUID hits the legacy service.\n\nThis is so that we can incrementally move production traffic to the rust\nlog service from the go log service.\n\n## Test plan\n\nI wrote a test of the logic for which UUIDs are on the log.\n\nThe rest is in CI's hands.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/test/distributed/test_log_failover.py\n@@ -65,4 +65,6 @@ def test_log_failover(\n \n     for i in range(200):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n         assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -26,7 +26,7 @@ log:\n     connect_timeout_ms: 5000\n     request_timeout_ms: 60000 # 1 minute\n     alt_host: \"rust-log-service.chroma\"\n-    use_alt_host_for_everything: true\n+    alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n \n executor:\n   distributed:\n---\nrust/log/src/config.rs\n@@ -14,19 +14,20 @@ pub struct GrpcLogConfig {\n     pub max_encoding_message_size: usize,\n     #[serde(default = \"GrpcLogConfig::default_max_decoding_message_size\")]\n     pub max_decoding_message_size: usize,\n-    // NOTE(rescrv):  This is a hack to allow us to test two log services in parallel without\n-    // breaking the old service.  If alt host is specified, then the \"use_alt_host_for_everything\"\n-    // and \"use_alt_for_collections\" config parameters are consulted.  If\n-    // \"use_alt_host_for_everything\" is set (CI) or the collection being written is in the alt\n-    // collections vec (staging), then we can use the alt host.\n+    // NOTE(rescrv):  This is a hack to allow us to test migrate between two log services without\n+    // breaking things or having a hard cut-over.  If alt_host_threshold is specified, it will be\n+    // interpreted as a u128 (UUID == u128) and if the collection in question is <=\n+    // alt_host_threshold, it go to the alt-host first.\n+    //\n+    // alt tenants/collections will always initialize a new log\n     #[serde(default = \"Option::default\")]\n     pub alt_host: Option<String>,\n     #[serde(default)]\n-    pub use_alt_host_for_everything: bool,\n-    #[serde(default)]\n     pub use_alt_for_tenants: Vec<String>,\n     #[serde(default)]\n     pub use_alt_for_collections: Vec<String>,\n+    #[serde(default = \"Option::default\")]\n+    pub alt_host_threshold: Option<String>,\n }\n \n impl GrpcLogConfig {\n@@ -65,9 +66,9 @@ impl Default for GrpcLogConfig {\n             max_encoding_message_size: GrpcLogConfig::default_max_encoding_message_size(),\n             max_decoding_message_size: GrpcLogConfig::default_max_decoding_message_size(),\n             alt_host: None,\n-            use_alt_host_for_everything: false,\n             use_alt_for_tenants: vec![],\n             use_alt_for_collections: vec![],\n+            alt_host_threshold: None,\n         }\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -244,21 +244,41 @@ impl GrpcLog {\n         client_for_conn_str(connection_string)\n     }\n \n+    fn client_is_on_alt_log(to_evaluate: CollectionUuid, alt_host_threshold: Option<&str>) -> bool {\n+        if let Some(alt_host_threshold) = alt_host_threshold {\n+            let Ok(alt_host_threshold) = Uuid::parse_str(alt_host_threshold) else {\n+                tracing::error!(\"alt_host_threshold must be a valid UUID\");\n+                return false;\n+            };\n+            let to_evaluate = to_evaluate.0.as_u64_pair().0;\n+            let alt_host_threshold = alt_host_threshold.as_u64_pair().0;\n+            to_evaluate <= alt_host_threshold\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn client_for(\n         &mut self,\n         tenant: &str,\n         collection_id: CollectionUuid,\n     ) -> &mut LogServiceClient<chroma_tracing::GrpcTraceService<tonic::transport::Channel>> {\n-        let collection_id = collection_id.to_string();\n         if let Some(alt) = self.alt_client.as_mut() {\n-            if self.config.use_alt_host_for_everything\n-                || self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n-                || self.config.use_alt_for_collections.contains(&collection_id)\n+            if self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n+                || self\n+                    .config\n+                    .use_alt_for_collections\n+                    .contains(&collection_id.to_string())\n+                || Self::client_is_on_alt_log(\n+                    collection_id,\n+                    self.config.alt_host_threshold.as_deref(),\n+                )\n             {\n                 tracing::info!(\"using alt client for {collection_id}\");\n                 return alt;\n             }\n         }\n+        tracing::info!(\"using standard client for {collection_id}\");\n         &mut self.client\n     }\n \n@@ -413,7 +433,8 @@ impl GrpcLog {\n         let mut norm = self\n             ._get_collections_with_new_data(false, min_compaction_size)\n             .await?;\n-        if self.config.use_alt_host_for_everything\n+        if self.config.alt_host_threshold.is_some()\n+            || !self.config.use_alt_for_tenants.is_empty()\n             || !self.config.use_alt_for_collections.is_empty()\n         {\n             let alt = self\n@@ -524,3 +545,32 @@ impl GrpcLog {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn client_is_on_alt_log() {\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            None\n+        ));\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"00088272-cfc4-419d-997a-baebfb25034a\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"00088272-cfc4-419d-997a-baebfb25034a\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"ffffffff-ffff-ffff-ffff-ffffffffffff\"),\n+        ));\n+    }\n+}\n---\nrust/worker/tilt_config.yaml\n@@ -42,7 +42,7 @@ query_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -122,7 +122,7 @@ compaction_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -197,4 +197,4 @@ log_service:\n         connect_timeout_ms: 5000\n         request_timeout_ms: 60000 # 1 minute\n         alt_host: \"rust-log-service.chroma\"\n-        use_alt_host_for_everything: true\n+        alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n---\n\n\n---\n\nChoice B:\nchromadb/test/property/test_fork.py\n@@ -21,6 +21,10 @@\n from overrides import overrides\n from typing import Dict, cast, Union, Tuple, Set\n \n+import grpc\n+from chromadb.proto.logservice_pb2 import SealLogRequest\n+from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n collection_st = hyst.shared(strategies.collections(with_hnsw_params=True), key=\"source\")\n \n \n@@ -38,6 +42,10 @@ def __init__(self, client: chromadb.api.ClientAPI):\n         self.client = client\n         self.collection_names = set()\n \n+        # Create go log service client\n+        channel = grpc.insecure_channel(\"localhost:50052\")\n+        self.go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n     @initialize(collection=collection_st, target=updated_collections)\n     def initialize(\n         self, collection: strategies.Collection\n@@ -77,12 +85,14 @@ def fork(\n     @rule(\n         cursor=consumes(forked_collections),\n         delta=strategies.recordsets(collection_st),\n+        seal=hyst.booleans(),\n         target=updated_collections,\n     )\n     def upsert(\n         self,\n         cursor: Tuple[Collection, strategies.StateMachineRecordSet],\n         delta: strategies.RecordSet,\n+        seal: bool,\n     ) -> Tuple[Collection, strategies.StateMachineRecordSet]:\n         collection, record_set_state = cursor\n         normalized_delta: strategies.NormalizedRecordSet = invariants.wrap_all(delta)\n@@ -148,6 +158,8 @@ def upsert(\n                     )\n                 else:\n                     record_set_state[\"documents\"].append(None)\n+        if seal:\n+            self.go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n         return collection, record_set_state\n \n     @rule(\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -364,6 +364,10 @@ pub enum DirtyMarker {\n     },\n     #[serde(rename = \"purge\")]\n     Purge { collection_id: CollectionUuid },\n+    // A Cleared marker is a no-op.  It exists so that a log consisting of mark-dirty markers that\n+    // map onto purge markers will be cleared and can be erased.\n+    #[serde(rename = \"clear\")]\n+    Cleared,\n }\n \n impl DirtyMarker {\n@@ -372,6 +376,7 @@ impl DirtyMarker {\n         match self {\n             DirtyMarker::MarkDirty { collection_id, .. } => *collection_id,\n             DirtyMarker::Purge { collection_id } => *collection_id,\n+            DirtyMarker::Cleared => CollectionUuid::default(),\n         }\n     }\n \n@@ -416,6 +421,7 @@ impl DirtyMarker {\n                 DirtyMarker::Purge { collection_id } => {\n                     forget.push(*collection_id);\n                 }\n+                DirtyMarker::Cleared => {}\n             }\n         }\n         for collection_id in forget {\n@@ -865,22 +871,23 @@ impl LogServer {\n                 backpressure.push(*collection_id);\n             }\n         }\n-        if !markers.is_empty() {\n-            let mut new_cursor = cursor.clone();\n-            new_cursor.position = self.dirty_log.append_many(markers).await?;\n-            let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n-                return Err(Error::CouldNotGetDirtyLogCursors);\n-            };\n-            tracing::info!(\n-                \"Advancing dirty log cursor {:?} -> {:?}\",\n-                cursor.position,\n-                new_cursor.position\n-            );\n-            if let Some(witness) = witness {\n-                cursors.save(&STABLE_PREFIX, &new_cursor, &witness).await?;\n-            } else {\n-                cursors.init(&STABLE_PREFIX, new_cursor).await?;\n-            }\n+        if markers.is_empty() {\n+            markers.push(serde_json::to_string(&DirtyMarker::Cleared).map(Vec::from)?);\n+        }\n+        let mut new_cursor = cursor.clone();\n+        new_cursor.position = self.dirty_log.append_many(markers).await?;\n+        let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n+            return Err(Error::CouldNotGetDirtyLogCursors);\n+        };\n+        tracing::info!(\n+            \"Advancing dirty log cursor {:?} -> {:?}\",\n+            cursor.position,\n+            new_cursor.position\n+        );\n+        if let Some(witness) = witness {\n+            cursors.save(&STABLE_PREFIX, &new_cursor, &witness).await?;\n+        } else {\n+            cursors.init(&STABLE_PREFIX, new_cursor).await?;\n         }\n         self.metrics\n             .log_total_uncompacted_records_count\n---\n\n\n---\n\nChoice D:\ngo/pkg/log/repository/log.go\n@@ -168,6 +168,13 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\t}\n \t}()\n \n+\t// NOTE(rescrv):  Only sourceInfo.IsSealed should be used on this struct.\n+\tvar sourceInfo log.Collection\n+\tsourceInfo, err = queriesWithTx.GetCollection(ctx, sourceCollectionID)\n+\tif err != nil {\n+\t\tsourceInfo.IsSealed = false\n+\t}\n+\n \tvar sourceBounds log.GetBoundsForCollectionRow\n \tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n@@ -207,6 +214,7 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\tID:                              targetCollectionID,\n \t\tRecordCompactionOffsetPosition:  int64(compactionOffset),\n \t\tRecordEnumerationOffsetPosition: int64(enumerationOffset),\n+\t\tIsSealed:                        sourceInfo.IsSealed,\n \t})\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n---\ngo/pkg/log/repository/log_test.go\n@@ -116,17 +116,17 @@ func (suite *LogTestSuite) TestUniqueConstraintPushLogs() {\n func (suite *LogTestSuite) TestSealedLogWontPush() {\n \tctx := context.Background()\n \tcollectionId := types.NewUniqueID()\n-\tparams := log.InsertCollectionParams {\n-\t\tID: collectionId.String(),\n+\tparams := log.InsertCollectionParams{\n+\t\tID:                              collectionId.String(),\n \t\tRecordEnumerationOffsetPosition: 1,\n-\t\tRecordCompactionOffsetPosition: 0,\n+\t\tRecordCompactionOffsetPosition:  0,\n \t}\n \t_, err := suite.lr.queries.InsertCollection(ctx, params)\n \tassert.NoError(suite.t, err, \"Initializing log should not fail.\")\n \t_, err = suite.lr.queries.SealLog(ctx, collectionId.String())\n \tassert.NoError(suite.t, err, \"Sealing log should not fail.\")\n \tvar isSealed bool\n-\t_, isSealed, err = suite.lr.InsertRecords(ctx, collectionId.String(), [][]byte{{1,2,3}})\n+\t_, isSealed, err = suite.lr.InsertRecords(ctx, collectionId.String(), [][]byte{{1, 2, 3}})\n \tassert.NoError(suite.t, err, \"Failed to push logs\")\n \tassert.True(suite.t, isSealed, \"Did not report was sealed\")\n }\n---\ngo/pkg/log/store/db/queries.sql.go\n@@ -138,6 +138,24 @@ func (q *Queries) GetBoundsForCollection(ctx context.Context, id string) (GetBou\n \treturn i, err\n }\n \n+const getCollection = `-- name: GetCollection :one\n+SELECT id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+FROM collection\n+WHERE id = $1\n+`\n+\n+func (q *Queries) GetCollection(ctx context.Context, id string) (Collection, error) {\n+\trow := q.db.QueryRow(ctx, getCollection, id)\n+\tvar i Collection\n+\terr := row.Scan(\n+\t\t&i.ID,\n+\t\t&i.RecordCompactionOffsetPosition,\n+\t\t&i.RecordEnumerationOffsetPosition,\n+\t\t&i.IsSealed,\n+\t)\n+\treturn i, err\n+}\n+\n const getCollectionForUpdate = `-- name: GetCollectionForUpdate :one\n SELECT id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n FROM collection\n@@ -239,17 +257,23 @@ func (q *Queries) GetTotalUncompactedRecordsCount(ctx context.Context) (int64, e\n }\n \n const insertCollection = `-- name: InsertCollection :one\n-INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position, is_sealed) values($1, $2, $3, $4) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n `\n \n type InsertCollectionParams struct {\n \tID                              string\n \tRecordEnumerationOffsetPosition int64\n \tRecordCompactionOffsetPosition  int64\n+\tIsSealed                        bool\n }\n \n func (q *Queries) InsertCollection(ctx context.Context, arg InsertCollectionParams) (Collection, error) {\n-\trow := q.db.QueryRow(ctx, insertCollection, arg.ID, arg.RecordEnumerationOffsetPosition, arg.RecordCompactionOffsetPosition)\n+\trow := q.db.QueryRow(ctx, insertCollection,\n+\t\targ.ID,\n+\t\targ.RecordEnumerationOffsetPosition,\n+\t\targ.RecordCompactionOffsetPosition,\n+\t\targ.IsSealed,\n+\t)\n \tvar i Collection\n \terr := row.Scan(\n \t\t&i.ID,\n---\ngo/pkg/log/store/queries/queries.sql\n@@ -4,6 +4,11 @@ FROM collection\n WHERE id = $1\n FOR UPDATE;\n \n+-- name: GetCollection :one\n+SELECT *\n+FROM collection\n+WHERE id = $1;\n+\n -- name: InsertRecord :copyfrom\n INSERT INTO record_log (collection_id, \"offset\", record, timestamp) values($1, $2, $3, $4);\n \n@@ -30,7 +35,7 @@ UPDATE collection set record_compaction_offset_position = $2 where id = $1;\n UPDATE collection set record_enumeration_offset_position = $2 where id = $1;\n \n -- name: InsertCollection :one\n-INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning *;\n+INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position, is_sealed) values($1, $2, $3, $4) returning *;\n \n -- name: PurgeRecords :exec\n DELETE FROM record_log r using collection c where r.collection_id = c.id and r.offset <= c.record_compaction_offset_position;\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nRelease Python chromadb 1.0.10\n\n---\n\nChoice A:\nclients/new-js/packages/chromadb/src/chroma-client.ts\n@@ -411,7 +411,7 @@ export class ChromaClient {\n    * @param options.embeddingFunction - Optional embedding function to use\n    * @returns A CollectionAPI instance for the specified collection\n    */\n-  public collection({\n+  public getCollectionById({\n     id,\n     embeddingFunction,\n   }: {\n@@ -431,7 +431,7 @@ export class ChromaClient {\n    * @param items - Array of collection IDs or objects with ID and optional embedding function\n    * @returns Array of CollectionAPI instances\n    */\n-  public collections(\n+  public getCollectionsById(\n     items: string[] | { id: string; embeddingFunction?: EmbeddingFunction }[],\n   ) {\n     if (items.length === 0) return [];\n---\ndocs/docs.trychroma.com/markdoc/content/docs/collections/create-get-delete.md\n@@ -109,10 +109,10 @@ const [col1, col2] = client.getCollections([\n ])\n ```\n \n-The `getCollection` and `getCollections` methods issue an API call to a Chroma server to get collections with all their fields. If you only need access to collection actions on records and want to save the API call, you can get a \"thin\" collection object using the `collection` method. It takes in a collection **ID** and an embedding function.\n+The `getCollection` and `getCollections` methods issue an API call to a Chroma server to get collections with all their fields. If you only need access to collection actions on records, and want to save the API call, you can get a \"thin\" collection object using the `getCollectionById` method (and `getCollectionsById`). It takes in a collection **ID** and an embedding function.\n \n ```typescript\n-const collection = client.collection({ id: 'abc', embeddingFunction: openaiEF })\n+const collection = client.getCollectionById({ id: 'abc', embeddingFunction: openaiEF })\n ```\n \n You can also delete collections by name using `deleteCollection`:\n---\n\n\n---\n\nChoice B:\n.github/workflows/_go-tests.yml\n@@ -23,6 +23,9 @@ jobs:\n       - name: Start Tilt services\n         uses: ./.github/actions/tilt\n       - run: bin/cluster-test.sh bash -c 'cd go && make test'\n+        env:\n+          # Ryuk cleans up containers and is enabled by default. In CI it causes tests to occasionally flake.\n+          TESTCONTAINERS_RYUK_DISABLED: \"true\"\n       - name: Save service logs to artifact\n         if: always()\n         uses: ./.github/actions/export-tilt-logs\n---\ngo/Makefile\n@@ -27,8 +27,12 @@ build: proto\n \tgo build -v -o bin/coordinator ./cmd/coordinator/\n \tgo build -v -o bin/logservice ./cmd/logservice/\n \n+# -p 1 runs tests sequentially. If run in parallel tests are pretty flaky in CI.\n+# I believe this is caused by go/script/migrate_up_test.sh, which creates the possibility (observed during CI runs) of running multiple `atlas schema apply --dev-url \"docker://postgres/15/dev\" ...` in parallel.\n+# This command spins up a new Docker container, so my theory is that there's a race condition inside atlas when used this way.\n+# Instead of specifying -p 1, it might be possible to add a cross-process lock to guarantee that only one instance of atlas is running at a time.\n test: build\n-\tgo test -race -cover ./...\n+\tgo test -p 1 -race -cover ./...\n \n \n lint:\n---\ngo/pkg/sysdb/metastore/db/dbcore/core.go\n@@ -224,7 +224,7 @@ func GetDBConfigForTesting() DBConfig {\n \tdbName := \"chroma\"\n \tdbUsername := \"chroma\"\n \tdbPassword := \"chroma\"\n-\tcontainer, _ = postgres2.RunContainer(context.Background(),\n+\tcontainer, err := postgres2.RunContainer(context.Background(),\n \t\ttestcontainers.WithImage(\"docker.io/postgres:15.2-alpine\"),\n \t\tpostgres2.WithDatabase(dbName),\n \t\tpostgres2.WithUsername(dbUsername),\n@@ -235,6 +235,10 @@ func GetDBConfigForTesting() DBConfig {\n \t\t\t\tWithStartupTimeout(5*time.Second)),\n \t)\n \n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n \tvar ports nat.PortMap\n \tports, _ = container.Ports(context.Background())\n \n---\n\n\n---\n\nChoice C:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.9\"\n+__version__ = \"1.0.10\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.8\"\n+      \"Default\": \"1.0.10\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.8\"\n+chroma_version                  = \"1.0.10\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.8\"\n+  default     = \"1.0.10\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.8\"\n+chroma_version                  = \"1.0.10\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.8\"\n+  default     = \"1.0.10\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice D:\nrust/load/src/bit_difference.rs\n@@ -266,19 +266,17 @@ impl SyntheticDataSet {\n         let mut embeddings = vec![];\n         let mut docs = vec![];\n         let mut seen: HashSet<String> = HashSet::default();\n-        for _ in 0..uq.batch_size {\n-            let cluster = self.cluster_by_skew(skew, guac);\n-            let num_this_cluster = (cluster.docs.len() as f64 * uq.associativity).ceil() as usize;\n-            for _ in 0..num_this_cluster {\n-                let doc_idx = (any::<u32>(guac) as u64 * cluster.docs.len() as u64) >> 32;\n-                if seen.contains(&cluster.docs[doc_idx as usize].id()) {\n-                    continue;\n-                }\n-                seen.insert(cluster.docs[doc_idx as usize].id());\n-                ids.push(cluster.docs[doc_idx as usize].id());\n-                embeddings.push(cluster.docs[doc_idx as usize].embedding());\n-                docs.push(cluster.docs[doc_idx as usize].content.clone());\n+        let cluster = self.cluster_by_skew(skew, guac);\n+        let num_this_cluster = (cluster.docs.len() as f64 * uq.associativity).ceil() as usize;\n+        for _ in 0..num_this_cluster {\n+            let doc_idx = (any::<u32>(guac) as u64 * cluster.docs.len() as u64) >> 32;\n+            if seen.contains(&cluster.docs[doc_idx as usize].id()) {\n+                continue;\n             }\n+            seen.insert(cluster.docs[doc_idx as usize].id());\n+            ids.push(cluster.docs[doc_idx as usize].id());\n+            embeddings.push(cluster.docs[doc_idx as usize].embedding());\n+            docs.push(cluster.docs[doc_idx as usize].content.clone());\n         }\n         let ids = ids.iter().map(String::as_str).collect();\n         let docs = docs.iter().map(String::as_str).collect();\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nRetry kind setup. DNS appears to occasionally flake: https://github.com/chroma-core/chroma/actions/runs/15145093152/job/42578809842\n\n---\n\nChoice A:\n.github/actions/tilt/action.yaml\n@@ -10,13 +10,16 @@ runs:\n         curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v$TILT_VERSION/tilt.$TILT_VERSION.linux.x86_64.tar.gz | \\\n           tar -xzv -C /usr/local/bin tilt\n     - name: Set up kind\n-      id: kind\n-      uses: helm/kind-action@v1\n+      uses: Wandalen/wretry.action@v3.7.0\n       with:\n-        registry: true\n-        registry_name: my-registry\n-        registry_port: 5001\n-        registry_enable_delete: true\n+        action: helm/kind-action@v1\n+        attempt_limit: 3\n+        attempt_delay: 2000\n+        with: |\n+          registry: true\n+          registry_name: my-registry\n+          registry_port: 5001\n+          registry_enable_delete: true\n     - name: Add blacksmith registry mirror\n       shell: bash\n       run: |\n---\n\n\n---\n\nChoice B:\ngo/cmd/logservice/main.go\n@@ -25,6 +25,11 @@ import (\n \thealthgrpc \"google.golang.org/grpc/health/grpc_health_v1\"\n )\n \n+// hard-coding this here despite it also being in pkg/grpcutils/service.go because\n+// using the methods from grpcutils results in breaking our metrics collection for\n+// some reason. This service is being deprecated soon, so this is just a quick fix.\n+const maxGrpcFrameSize = 256 * 1024 * 1024\n+\n func main() {\n \tctx := context.Background()\n \n@@ -55,7 +60,10 @@ func main() {\n \tif err != nil {\n \t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n \t}\n-\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n+\ts := grpc.NewServer(\n+\t\tgrpc.MaxRecvMsgSize(maxGrpcFrameSize),\n+\t\tgrpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor),\n+\t)\n \thealthcheck := health.NewServer()\n \thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n---\n\n\n---\n\nChoice C:\nCargo.lock\n@@ -1813,8 +1813,10 @@ dependencies = [\n  \"bytes\",\n  \"chroma-config\",\n  \"chroma-error\",\n+ \"chroma-tracing\",\n  \"futures\",\n  \"object_store\",\n+ \"opentelemetry\",\n  \"parking_lot\",\n  \"rand 0.8.5\",\n  \"rand_xorshift\",\n---\nrust/storage/Cargo.toml\n@@ -23,9 +23,11 @@ thiserror.workspace = true\n tokio = { workspace = true }\n tokio-util = { workspace = true }\n tracing = { workspace = true }\n+opentelemetry = { workspace = true }\n \n chroma-config = { workspace = true }\n chroma-error = { workspace = true }\n+chroma-tracing = { workspace = true }\n \n [dev-dependencies]\n rand_xorshift = { workspace = true }\n---\nrust/storage/src/admissioncontrolleds3.rs\n@@ -10,6 +10,7 @@ use bytes::Bytes;\n use chroma_config::registry::Registry;\n use chroma_config::Configurable;\n use chroma_error::ChromaError;\n+use chroma_tracing::util::Stopwatch;\n use futures::future::BoxFuture;\n use futures::{future::Shared, stream, FutureExt, StreamExt};\n use std::{\n@@ -524,9 +525,30 @@ impl RateLimitPolicy {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct CountBasedPolicyMetrics {\n+    // The delay in milliseconds before a request is allowed to proceed.\n+    pub nac_delay_ms: opentelemetry::metrics::Histogram<u64>,\n+}\n+\n+impl Default for CountBasedPolicyMetrics {\n+    fn default() -> Self {\n+        Self {\n+            nac_delay_ms: opentelemetry::global::meter(\"chroma.storage.admission_control\")\n+                .u64_histogram(\"nac_delay_ms\")\n+                .with_description(\n+                    \"The delay in milliseconds before a request is allowed to proceed.\",\n+                )\n+                .with_unit(\"ms\")\n+                .build(),\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct CountBasedPolicy {\n     remaining_tokens: Vec<Semaphore>,\n+    metrics: CountBasedPolicyMetrics,\n }\n \n impl CountBasedPolicy {\n@@ -537,14 +559,18 @@ impl CountBasedPolicy {\n                 (max_allowed_outstanding as f32 * allocation).ceil() as usize,\n             ));\n         }\n-        Self { remaining_tokens }\n+        Self {\n+            remaining_tokens,\n+            metrics: CountBasedPolicyMetrics::default(),\n+        }\n     }\n \n     async fn acquire(\n         &self,\n         priority: Arc<AtomicUsize>,\n         mut channel_receiver: Option<tokio::sync::mpsc::Receiver<()>>,\n     ) -> SemaphorePermit<'_> {\n+        let _stopwatch = Stopwatch::new(&self.metrics.nac_delay_ms, &[]);\n         loop {\n             let current_priority = priority.load(Ordering::SeqCst);\n             let current_priority: StorageRequestPriority = current_priority.into();\n---\n\n\n---\n\nChoice D:\nrust/log/src/log.rs\n@@ -30,7 +30,7 @@ pub enum Log {\n }\n \n impl Log {\n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn read(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -54,7 +54,7 @@ impl Log {\n     }\n \n     // ScoutLogs returns the offset of the next record to be inserted into the log.\n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn scout_logs(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -76,7 +76,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self, records))]\n+    #[tracing::instrument(skip(self, records), err(Display))]\n     pub async fn push_logs(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -95,7 +95,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn fork_logs(\n         &mut self,\n         source_collection_id: CollectionUuid,\n@@ -111,7 +111,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn get_collections_with_new_data(\n         &mut self,\n         min_compaction_size: u64,\n@@ -129,7 +129,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn update_collection_log_offset(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -153,7 +153,7 @@ impl Log {\n     }\n \n     /// Only supported in distributed. Sqlite has a different workflow.\n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn purge_dirty_for_collection(\n         &mut self,\n         collection_id: CollectionUuid,\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nReduces Python setup time by >10x from 1-2m to 10s by replacing pip with uv (in pip compatibility mode) and removing an unnecessary apt step.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\nWorkflows pass.\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\n.github/actions/python/action.yaml\n@@ -8,27 +8,26 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n-\n+    - name: Install uv\n+      uses: astral-sh/setup-uv@v6\n+      with:\n+        enable-cache: true\n     - name: Set up Python 3.9 for protos\n       uses: useblacksmith/setup-python@v6\n       # NOTE(hammadb) Blacksmith does not support windows, so we use the official action for windows and\n       # skip it on other platforms\n       if: runner.os != 'Windows'\n       with:\n         python-version: \"3.9\"\n-        cache: \"pip\"\n-        cache-dependency-path: \"requirements*.txt\"\n     - name: Set up Python 3.9 for protos (Windows)\n       if: runner.os == 'Windows'\n       uses: actions/setup-python@v5\n       with:\n         python-version: \"3.9\"\n-        cache: \"pip\"\n-        cache-dependency-path: \"requirements*.txt\"\n \n     - name: Install proto dependencies\n       run: |\n-        python -m pip install grpcio==1.58.0 grpcio-tools==1.58.0\n+        uv pip install --system grpcio==1.58.0 grpcio-tools==1.58.0\n       shell: bash\n     - name: Generate Proto Files\n       if: runner.os != 'Windows'\n@@ -40,30 +39,24 @@ runs:\n       shell: cmd\n     - name: Uninstall proto dependencies\n       run: |\n-        python -m pip uninstall -y grpcio grpcio-tools\n+        uv pip uninstall --system grpcio grpcio-tools\n       shell: bash\n     - name: Set up Python ${{ inputs.python-version }}\n       uses: useblacksmith/setup-python@v6\n       with:\n         python-version: ${{ inputs.python-version }}\n-        cache: \"pip\"\n-        cache-dependency-path: \"requirements*.txt\"\n     - name: Set up Python ${{ inputs.python-version }} (Windows)\n       if: runner.os == 'Windows'\n       uses: actions/setup-python@v5\n       with:\n         python-version: ${{ inputs.python-version }}\n-        cache: \"pip\"\n-        cache-dependency-path: \"requirements*.txt\"\n     - name: Install dependencies\n       run: |\n-        python -m pip install -r requirements.txt && python -m pip install -r requirements_dev.txt\n+        uv pip install --system -r requirements.txt -r requirements_dev.txt\n       shell: bash\n     - name: Install protobuf compiler (protoc) - Linux\n       if: runner.os != 'Windows'\n       run: |\n-        sudo apt-get update\n-        sudo apt-get install -y wget unzip\n         wget https://github.com/protocolbuffers/protobuf/releases/download/v28.2/protoc-28.2-linux-x86_64.zip\n         sudo unzip protoc-28.2-linux-x86_64.zip -d /usr/local/\n         sudo rm protoc-28.2-linux-x86_64.zip\n---\n\n\n---\n\nChoice B:\nrust/load/src/lib.rs\n@@ -1271,13 +1271,11 @@ impl LoadService {\n             for declared in declared {\n                 if let Entry::Vacant(entry) = running.entry(declared.uuid) {\n                     tracing::info!(\"spawning workload {}\", declared.uuid);\n-                    let root = tracing::info_span!(parent: None, \"workload\");\n                     let this = Arc::clone(self);\n                     let done = Arc::new(AtomicBool::new(false));\n                     let done_p = Arc::clone(&done);\n                     let inhibit = Arc::clone(&self.inhibit);\n                     let task = tokio::task::spawn(async move {\n-                        let _enter = root.enter();\n                         this.run_one_workload(done, inhibit, declared).await\n                     });\n                     entry.insert((done_p, task));\n@@ -1295,36 +1293,6 @@ impl LoadService {\n         let client = Arc::new(client(spec.connection.clone()).await);\n         let mut guac = Guacamole::new(spec.expires.timestamp_millis() as u64);\n         let mut next_op = Instant::now();\n-        let (tx, mut rx) = tokio::sync::mpsc::channel(1000);\n-        let _ = tx\n-            .send(tokio::spawn(async move { Ok::<(), Error>(()) }))\n-            .await;\n-        let this = Arc::clone(&self);\n-        let data_set = Arc::clone(&spec.data_set);\n-        let reaper = tokio::spawn(async move {\n-            while let Some(task) = rx.recv().await {\n-                if let Err(err) = task.await.unwrap() {\n-                    if !format!(\"{err:?}\").contains(\"429\") {\n-                        this.metrics.failed.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                        tracing::error!(\"workload task failed: {err:?}\");\n-                    } else {\n-                        this.metrics.limited.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                    }\n-                }\n-            }\n-        });\n \n         // Initialize the data set.\n         let data_set = Arc::clone(&spec.data_set);\n@@ -1408,30 +1376,44 @@ impl LoadService {\n                         .await\n                         .map_err(|err| Error::FailWorkload(err.to_string()))\n                     {\n-                        Ok(()) => Ok(()),\n+                        Ok(()) => (),\n                         Err(err) => {\n-                            if err.to_string().contains(\"invalid request: No results\") {\n+                            if format!(\"{err:?}\").contains(\"invalid request: No results\") {\n                                 this.metrics.no_results.add(\n                                     1,\n                                     &[KeyValue::new(\n                                         Key::from_static_str(\"data_set\"),\n                                         Value::from(data_set.name()),\n                                     )],\n                                 );\n-                                Ok(())\n+                                tracing::warn!(\"workload step no results: {err:?}\");\n+                            } else if !format!(\"{err:?}\").contains(\"429\") {\n+                                this.metrics.failed.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::error!(\"workload step failed: {err:?}\");\n                             } else {\n-                                Err(err)\n+                                this.metrics.limited.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::warn!(\"workload step rate limited: {err:?}\");\n                             }\n                         }\n-                    }\n+                    };\n                 };\n-                tx.send(tokio::spawn(fut)).await.unwrap();\n+                let span = tracing::info_span!(parent: None, \"step\", workload_uuid = %spec.uuid);\n+                tokio::spawn(fut.instrument(span));\n             }\n         }\n-        // Not an error, just needs to show up in stdout.\n-        tracing::error!(\"workload done: {}/{}\", spec.name, spec.description());\n-        drop(tx);\n-        reaper.await.unwrap();\n+        tracing::info!(\"workload done: {}/{}\", spec.name, spec.description());\n     }\n \n     fn load_persistent(&self) -> Result<(), Error> {\n---\n\n\n---\n\nChoice C:\n.github/workflows/_python-tests.yml\n@@ -291,7 +291,7 @@ jobs:\n         api_key: ${{ secrets.DD_API_KEY }}\n         site: ${{ vars.DD_SITE }}\n     - name: Integration Test\n-      run: bin/python-integration-test ${{ matrix.test-globs }}\n+      run: python -m pytest ${{ matrix.test-globs }}\n       shell: bash\n       env:\n         ENV_FILE: ${{ matrix.env-file }}\n---\nchromadb/test/test_cli.py\n@@ -1,6 +1,5 @@\n import multiprocessing\n import multiprocessing.context\n-import os\n import sys\n import time\n from multiprocessing.synchronize import Event\n@@ -10,7 +9,6 @@\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,6 +17,36 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+        host: str, port: int,\n+    max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            client = chromadb.HttpClient(host=host, port=port)\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            print(\"Heartbeat failed, trying again...\")\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n@@ -32,14 +60,10 @@ def test_app() -> None:\n     server_process.start()\n     time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    assert wait_for_server(host=\"localhost\", port=8001), \"Server failed to start within maximum retry attempts\"\n \n-    client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -124,7 +148,7 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\", \"--timeout\", \"10\"]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\nrust/cli/src/commands/vacuum.rs\n@@ -20,8 +20,10 @@ use sqlx::Row;\n use std::error::Error;\n use std::path::Path;\n use std::str::FromStr;\n+use std::time::Duration;\n use std::{fs, io};\n use thiserror::Error;\n+use tokio::time::timeout;\n \n #[derive(Debug, Error)]\n pub enum VacuumError {\n@@ -43,6 +45,8 @@ pub struct VacuumArgs {\n     path: Option<String>,\n     #[clap(long, default_value_t = false, help = \"Skip vacuum confirmation\")]\n     force: bool,\n+    #[clap(long, help = \"Maximum time (in seconds) to wait for vacuum\")]\n+    timeout: Option<u64>,\n }\n \n fn sizeof_fmt(num: u64, suffix: Option<&str>) -> String {\n@@ -195,10 +199,6 @@ pub async fn vacuum_chroma(config: FrontendConfig) -> Result<(), Box<dyn Error>>\n \n     println!(\"Vacuuming (this may take a while)...\\n\");\n \n-    sqlx::query(&format!(\"PRAGMA busy_timeout = {}\", 5000))\n-        .execute(sqlite.get_conn())\n-        .await?;\n-\n     sqlx::query(\"VACUUM\").execute(sqlite.get_conn()).await?;\n \n     sqlx::query(\n@@ -264,9 +264,19 @@ pub fn vacuum(args: VacuumArgs) -> Result<(), CliError> {\n     };\n \n     let runtime = tokio::runtime::Runtime::new().expect(\"Failed to start Chroma\");\n-    runtime\n-        .block_on(vacuum_chroma(config.frontend))\n-        .map_err(|_| VacuumError::VacuumFailed)?;\n+\n+    let res = if let Some(secs) = args.timeout {\n+        runtime.block_on(async {\n+            timeout(Duration::from_secs(secs), vacuum_chroma(config.frontend))\n+                .await\n+                .unwrap_or_else(|_elapsed| {\n+                    Err(Box::new(VacuumError::VacuumFailed) as Box<dyn std::error::Error>)\n+                })\n+        })\n+    } else {\n+        runtime.block_on(vacuum_chroma(config.frontend))\n+    };\n+    res.map_err(|_| VacuumError::VacuumFailed)?;\n \n     let post_vacuum_size =\n         get_dir_size(Path::new(&persistent_path)).map_err(|_| VacuumError::DirSizeFailed)?;\n---\n\n\n---\n\nChoice D:\nrust/segment/src/sqlite_metadata.rs\n@@ -482,8 +482,9 @@ impl IntoSqliteExpr for DocumentExpression {\n             EmbeddingFulltextSearch::StringValue,\n         ));\n         let doc_contains = doc_col\n+            .clone()\n             .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .is(true);\n+            .and(doc_col.is_not_null());\n         match self.operator {\n             DocumentOperator::Contains => doc_contains,\n             DocumentOperator::NotContains => doc_contains.not(),\n@@ -495,9 +496,11 @@ impl IntoSqliteExpr for DocumentExpression {\n \n impl IntoSqliteExpr for MetadataExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let key_cond = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key))\n+        let key_col = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key));\n+        let key_cond = key_col\n+            .clone()\n             .eq(self.key.to_string())\n-            .is(true);\n+            .and(key_col.is_not_null());\n         match &self.comparison {\n             MetadataComparison::Primitive(op, val) => {\n                 let (col, sval) = match val {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nPrior to this change, v0 could not be deleted from a version file. This also correctly propagates errors for the `DeleteCollectionVersion` method.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\nrust/frontend/src/impls/utils.rs\n@@ -8,6 +8,8 @@ use chroma_types::{\n pub(crate) enum ToRecordsError {\n     #[error(\"Inconsistent number of IDs, embeddings, documents, URIs and metadatas\")]\n     InconsistentLength,\n+    #[error(\"Empty ID, ID must have at least one character\")]\n+    EmptyId,\n }\n \n impl ChromaError for ToRecordsError {\n@@ -47,6 +49,9 @@ pub(crate) fn to_records<\n     let mut records = Vec::with_capacity(len);\n \n     for id in ids {\n+        if id.is_empty() {\n+            return Err(ToRecordsError::EmptyId);\n+        }\n         let embedding = embeddings_iter.next().flatten();\n         let document = documents_iter.next().flatten();\n         let uri = uris_iter.next().flatten();\n@@ -87,3 +92,59 @@ pub(crate) fn to_records<\n \n     Ok((records, total_bytes))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use chroma_types::Operation;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_to_records_empty_id() {\n+        let ids = vec![String::from(\"\")];\n+        let embeddings = vec![Some(vec![1.0, 2.0, 3.0])];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(ids, Some(embeddings), None, None, None, Operation::Add);\n+        assert!(matches!(result, Err(ToRecordsError::EmptyId)));\n+    }\n+\n+    #[test]\n+    fn test_normal_ids() {\n+        let ids = vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\")];\n+        let embeddings = vec![\n+            Some(vec![1.0, 2.0, 3.0]),\n+            Some(vec![4.0, 5.0, 6.0]),\n+            Some(vec![7.0, 8.0, 9.0]),\n+        ];\n+        let documents = vec![\n+            Some(String::from(\"document 1\")),\n+            Some(String::from(\"document 2\")),\n+            Some(String::from(\"document 3\")),\n+        ];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(\n+            ids,\n+            Some(embeddings),\n+            Some(documents),\n+            None,\n+            None,\n+            Operation::Add,\n+        );\n+        assert!(result.is_ok());\n+        let records = result.unwrap().0;\n+        assert_eq!(records.len(), 3);\n+        assert_eq!(records[0].id, \"1\");\n+        assert_eq!(records[1].id, \"2\");\n+        assert_eq!(records[2].id, \"3\");\n+        assert_eq!(records[0].embedding, Some(vec![1.0, 2.0, 3.0]));\n+        assert_eq!(records[1].embedding, Some(vec![4.0, 5.0, 6.0]));\n+        assert_eq!(records[2].embedding, Some(vec![7.0, 8.0, 9.0]));\n+        assert_eq!(records[0].document, Some(String::from(\"document 1\")));\n+        assert_eq!(records[1].document, Some(String::from(\"document 2\")));\n+        assert_eq!(records[2].document, Some(String::from(\"document 3\")));\n+    }\n+}\n---\n\n\n---\n\nChoice B:\nk8s/test/load-service.yaml\n@@ -1,25 +1,16 @@\n----\n-\n-apiVersion: v1\n-kind: Namespace\n-metadata:\n-  name: chroma-load\n-\n----\n-\n apiVersion: apps/v1\n kind: Deployment\n metadata:\n   name: load-service\n-  namespace: chroma-load\n+  namespace: chroma\n spec:\n   replicas: 1\n   selector:\n     matchLabels:\n       app: load-service\n   template:\n     metadata:\n-      namespace: chroma-load\n+      namespace: chroma\n       labels:\n         app: load-service\n     spec:\n@@ -55,7 +46,7 @@ apiVersion: v1\n kind: ConfigMap\n metadata:\n   name: load-service-config\n-  namespace: chroma-load\n+  namespace: chroma\n data:\n   config.yaml: |\n     load_service:\n@@ -70,7 +61,7 @@ apiVersion: v1\n kind: Service\n metadata:\n   name: load-service\n-  namespace: chroma-load\n+  namespace: chroma\n spec:\n   ports:\n     - name: http\n---\n\n\n---\n\nChoice C:\nclients/js/packages/chromadb-core/src/ChromaFetch.ts\n@@ -9,6 +9,7 @@ import {\n   ChromaError,\n   createErrorByType,\n   ChromaUniqueError,\n+  ChromaQuotaExceededError,\n } from \"./Errors\";\n import { FetchAPI } from \"./generated\";\n \n@@ -74,6 +75,14 @@ export const chromaFetch: FetchAPI = async (\n           );\n         case 409:\n           throw new ChromaUniqueError(\"The resource already exists\");\n+        case 422:\n+          if (\n+            respBody?.message &&\n+            respBody?.message.startsWith(\"Quota exceeded\")\n+          ) {\n+            throw new ChromaQuotaExceededError(respBody?.message);\n+          }\n+          break;\n         case 500:\n           throw parseServerError(respBody?.error);\n         case 502:\n---\nclients/js/packages/chromadb-core/src/Errors.ts\n@@ -85,6 +85,13 @@ export class ChromaUniqueError extends Error {\n   }\n }\n \n+export class ChromaQuotaExceededError extends Error {\n+  name = \"ChromaQuotaExceededError\";\n+  constructor(message: string, public readonly cause?: unknown) {\n+    super(message);\n+  }\n+}\n+\n export function createErrorByType(type: string, message: string) {\n   switch (type) {\n     case \"InvalidCollection\":\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1138,6 +1138,7 @@ func (tc *Catalog) createSegmentImpl(txCtx context.Context, createSegment *model\n \t\tType:         createSegment.Type,\n \t\tScope:        createSegment.Scope,\n \t\tTs:           ts,\n+\t\tFilePaths:    createSegment.FilePaths,\n \t}\n \terr := tc.metaDomain.SegmentDb(txCtx).Insert(dbSegment)\n \tif err != nil {\n@@ -2000,11 +2001,11 @@ func (tc *Catalog) getNumberOfActiveVersions(versionFilePb *coordinatorpb.Collec\n }\n \n func (tc *Catalog) getOldestVersionTs(versionFilePb *coordinatorpb.CollectionVersionFile) time.Time {\n-\tif versionFilePb.GetVersionHistory() == nil || len(versionFilePb.GetVersionHistory().Versions) <= 1 {\n+\tif versionFilePb.GetVersionHistory() == nil || len(versionFilePb.GetVersionHistory().Versions) == 0 {\n \t\t// Returning a zero timestamp that represents an unset value.\n \t\treturn time.Time{}\n \t}\n-\toldestVersionTs := versionFilePb.GetVersionHistory().Versions[1].CreatedAtSecs\n+\toldestVersionTs := versionFilePb.GetVersionHistory().Versions[0].CreatedAtSecs\n \n \treturn time.Unix(oldestVersionTs, 0)\n }\n@@ -2041,7 +2042,7 @@ func (tc *Catalog) DeleteVersionEntriesForCollection(ctx context.Context, tenant\n \t\t}\n \n \t\tnumActiveVersions := tc.getNumberOfActiveVersions(versionFilePb)\n-\t\tif numActiveVersions <= 1 {\n+\t\tif numActiveVersions < 1 {\n \t\t\t// No remaining valid versions after GC.\n \t\t\treturn errors.New(\"no valid versions after gc\")\n \t\t}\n@@ -2091,11 +2092,15 @@ func (tc *Catalog) DeleteCollectionVersion(ctx context.Context, req *coordinator\n \tresult := coordinatorpb.DeleteCollectionVersionResponse{\n \t\tCollectionIdToSuccess: make(map[string]bool),\n \t}\n+\tvar firstErr error\n \tfor _, collectionVersionList := range req.Versions {\n \t\terr := tc.DeleteVersionEntriesForCollection(ctx, collectionVersionList.TenantId, collectionVersionList.CollectionId, collectionVersionList.Versions)\n \t\tresult.CollectionIdToSuccess[collectionVersionList.CollectionId] = err == nil\n+\t\tif firstErr == nil && err != nil {\n+\t\t\tfirstErr = err\n+\t\t}\n \t}\n-\treturn &result, nil\n+\treturn &result, firstErr\n }\n \n func (tc *Catalog) BatchGetCollectionVersionFilePaths(ctx context.Context, collectionIds []string) (*coordinatorpb.BatchGetCollectionVersionFilePathsResponse, error) {\n---\ngo/pkg/sysdb/coordinator/table_catalog_test.go\n@@ -759,7 +759,7 @@ func TestCatalog_DeleteCollectionVersion_CollectionNotFound(t *testing.T) {\n \tresp, err := catalog.DeleteCollectionVersion(context.Background(), req)\n \n \t// Verify results\n-\tassert.NoError(t, err)\n+\tassert.Error(t, err)\n \tassert.NotNil(t, resp)\n \tassert.False(t, resp.CollectionIdToSuccess[collectionID])\n \n---\ngo/pkg/sysdb/grpc/proto_model_convert.go\n@@ -1,6 +1,8 @@\n package grpc\n \n import (\n+\t\"time\"\n+\n \t\"github.com/chroma-core/chroma/go/pkg/common\"\n \t\"github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb\"\n \t\"github.com/chroma-core/chroma/go/pkg/sysdb/coordinator/model\"\n@@ -131,6 +133,7 @@ func convertToCreateCollectionModel(req *coordinatorpb.CreateCollectionRequest)\n \t\tGetOrCreate:          req.GetGetOrCreate(),\n \t\tTenantID:             req.GetTenant(),\n \t\tDatabaseName:         req.GetDatabase(),\n+\t\tTs:                   time.Now().Unix(),\n \t}, nil\n }\n \n---\nrust/garbage_collector/src/operators/delete_versions_at_sysdb.rs\n@@ -38,6 +38,8 @@ pub struct DeleteVersionsAtSysDbOutput {\n \n #[derive(Error, Debug)]\n pub enum DeleteVersionsAtSysDbError {\n+    #[error(\"Unknown error occurred when deleting versions at sysdb\")]\n+    UnknownError,\n     #[error(\"Error deleting versions in sysdb: {0}\")]\n     SysDBError(String),\n     #[error(\"Error deleting version file {path}: {message}\")]\n@@ -157,7 +159,13 @@ impl Operator<DeleteVersionsAtSysDbInput, DeleteVersionsAtSysDbOutput>\n                 .delete_collection_version(vec![input.versions_to_delete.clone()])\n                 .await\n             {\n-                Ok(_) => {\n+                Ok(results) => {\n+                    for (_, was_successful) in results {\n+                        if !was_successful {\n+                            return Err(DeleteVersionsAtSysDbError::UnknownError);\n+                        }\n+                    }\n+\n                     tracing::info!(\n                         versions = ?input.versions_to_delete.versions,\n                         \"Successfully deleted versions from SysDB\"\n---\nrust/sysdb/src/sysdb.rs\n@@ -1331,14 +1331,14 @@ impl ChromaError for MarkVersionForDeletionError {\n \n #[derive(Error, Debug)]\n pub enum DeleteCollectionVersionError {\n-    #[error(\"Failed to delete version\")]\n+    #[error(\"Failed to delete version: {0}\")]\n     FailedToDeleteVersion(#[from] tonic::Status),\n }\n \n impl ChromaError for DeleteCollectionVersionError {\n     fn code(&self) -> ErrorCodes {\n         match self {\n-            DeleteCollectionVersionError::FailedToDeleteVersion(_) => ErrorCodes::Internal,\n+            DeleteCollectionVersionError::FailedToDeleteVersion(e) => e.code().into(),\n         }\n     }\n }\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nIncludes : https://github.com/chroma-core/chroma/pull/4569\n\n---\n\nChoice A:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\n\n\n---\n\nChoice B:\nDockerfile\n@@ -69,4 +69,3 @@ EXPOSE 8000\n \n ENTRYPOINT [\"/docker_entrypoint.sh\"]\n CMD [ \"--workers ${CHROMA_WORKERS} --host ${CHROMA_HOST_ADDR} --port ${CHROMA_HOST_PORT} --proxy-headers --reload --log-config ${CHROMA_LOG_CONFIG} --timeout-keep-alive ${CHROMA_TIMEOUT_KEEP_ALIVE}\"]\n-\n---\nDockerfile.windows\n@@ -1,14 +1,15 @@\n FROM python:3.11.9\n ARG REBUILD_HNSWLIB\n-\n SHELL [\"powershell\", \"-Command\", \"$ErrorActionPreference = 'Stop'; $ProgressPreference = 'SilentlyContinue';\"]\n RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; `Invoke-WebRequest \"https://aka.ms/vs/17/release/vc_redist.x64.exe\" -OutFile \"vc_redist.x64.exe\"; `Start-Process -filepath C:\\vc_redist.x64.exe -ArgumentList \"/install\", \"/passive\", \"/norestart\" -Passthru | Wait-Process; `Remove-Item -Force vc_redist.x64.exe;\n \n WORKDIR C:\\\\chroma\n \n COPY ./requirements.txt requirements.txt\n+COPY ./requirements_dev.txt requirements_dev.txt\n \n RUN pip install --no-cache-dir --upgrade -r requirements.txt\n+RUN pip install --no-cache-dir --upgrade -r requirements_dev.txt\n RUN if ($env:REBUILD_HNSWLIB -eq 'true') { pip install --no-binary :all: --force-reinstall --no-cache-dir chroma-hnswlib }\n \n COPY ./bin/docker_entrypoint.ps1 C:\\\\docker_entrypoint.ps1\n@@ -19,7 +20,6 @@ ENV CHROMA_HOST_PORT 8000\n ENV CHROMA_WORKERS 1\n ENV CHROMA_LOG_CONFIG \"chromadb/log_config.yml\"\n ENV CHROMA_TIMEOUT_KEEP_ALIVE 30\n-\n EXPOSE 8000\n \n ENTRYPOINT [\"powershell\", \"C:\\\\\\\\docker_entrypoint.ps1\"]\n---\nchromadb/test/utils/cross_version.py\n@@ -55,7 +55,10 @@ def install(pkg: str, path: str, dep_overrides: Dict[str, str]) -> int:\n     for dep, operator_version in dep_overrides.items():\n         command.append(f\"{dep}{operator_version}\")\n \n-    command.append(\"--no-binary=chroma-hnswlib\")\n+    # Only add --no-binary=chroma-hnswlib if it's in the dependencies\n+    if \"chroma-hnswlib\" in pkg or any(\"chroma-hnswlib\" in dep for dep in dep_overrides):\n+        command.append(\"--no-binary=chroma-hnswlib\")\n+\n     command.append(f\"--target={path}\")\n \n     print(f\"Installing chromadb version {pkg} to {path}\")\n---\npyproject.toml\n@@ -7,7 +7,10 @@ description = \"Chroma.\"\n readme = \"README.md\"\n requires-python = \">=3.9\"\n classifiers = [\"Programming Language :: Python :: 3\", \"License :: OSI Approved :: Apache Software License\", \"Operating System :: OS Independent\"]\n-dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'chroma-hnswlib==0.7.6', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+\n+[project.optional-dependencies]\n+dev = ['chroma-hnswlib==0.7.6']\n \n [tool.black]\n line-length = 88\n---\nrequirements.txt\n@@ -1,5 +1,4 @@\n bcrypt>=4.0.1\n-chroma-hnswlib==0.7.6\n fastapi==0.115.9\n graphlib_backport==1.0.3; python_version < '3.9'\n grpcio>=1.58.0\n---\nrequirements_dev.txt\n@@ -1,5 +1,6 @@\n black==23.3.0 # match what's in pyproject.toml\n build\n+chroma-hnswlib==0.7.6\n grpcio-tools==1.67.1 # Later version not compatible with protobuf 4.25.5\n httpx\n hypothesis==6.112.2 # TODO: Resolve breaking changes and bump version\n---\n\n\n---\n\nChoice C:\ngo/cmd/logservice/main.go\n@@ -25,6 +25,11 @@ import (\n \thealthgrpc \"google.golang.org/grpc/health/grpc_health_v1\"\n )\n \n+// hard-coding this here despite it also being in pkg/grpcutils/service.go because\n+// using the methods from grpcutils results in breaking our metrics collection for\n+// some reason. This service is being deprecated soon, so this is just a quick fix.\n+const maxGrpcFrameSize = 256 * 1024 * 1024\n+\n func main() {\n \tctx := context.Background()\n \n@@ -55,7 +60,10 @@ func main() {\n \tif err != nil {\n \t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n \t}\n-\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n+\ts := grpc.NewServer(\n+\t\tgrpc.MaxRecvMsgSize(maxGrpcFrameSize),\n+\t\tgrpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor),\n+\t)\n \thealthcheck := health.NewServer()\n \thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n---\n\n\n---\n\nChoice D:\nchromadb/test/distributed/test_log_failover.py\n@@ -23,6 +23,50 @@\n \n RECORDS = 100\n \n+@skip_if_not_cluster()\n+def test_log_immediate_failover(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n+\n @skip_if_not_cluster()\n def test_log_failover(\n     client: ClientAPI,\n---\ngo/pkg/log/repository/log.go\n@@ -4,6 +4,7 @@ import (\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"strings\"\n \t\"time\"\n \n \tlog \"github.com/chroma-core/chroma/go/pkg/log/store/db\"\n@@ -215,6 +216,9 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \n func (r *LogRepository) SealCollection(ctx context.Context, collectionID string) (err error) {\n \t_, err = r.queries.SealLog(ctx, collectionID)\n+\tif err != nil && strings.Contains(err.Error(), \"no rows in result set\") {\n+\t\t_, err = r.queries.SealLogInsert(ctx, collectionID)\n+\t}\n \treturn\n }\n \n---\ngo/pkg/log/store/db/queries.sql.go\n@@ -292,6 +292,22 @@ func (q *Queries) SealLog(ctx context.Context, id string) (Collection, error) {\n \treturn i, err\n }\n \n+const sealLogInsert = `-- name: SealLogInsert :one\n+INSERT INTO collection(id, is_sealed, record_compaction_offset_position, record_enumeration_offset_position) VALUES ($1, true, 0, 0) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+`\n+\n+func (q *Queries) SealLogInsert(ctx context.Context, id string) (Collection, error) {\n+\trow := q.db.QueryRow(ctx, sealLogInsert, id)\n+\tvar i Collection\n+\terr := row.Scan(\n+\t\t&i.ID,\n+\t\t&i.RecordCompactionOffsetPosition,\n+\t\t&i.RecordEnumerationOffsetPosition,\n+\t\t&i.IsSealed,\n+\t)\n+\treturn i, err\n+}\n+\n const updateCollectionCompactionOffsetPosition = `-- name: UpdateCollectionCompactionOffsetPosition :exec\n UPDATE collection set record_compaction_offset_position = $2 where id = $1\n `\n---\ngo/pkg/log/store/queries/queries.sql\n@@ -68,3 +68,6 @@ INSERT INTO record_log (\"offset\", collection_id, timestamp, record)\n \n -- name: SealLog :one\n UPDATE collection SET is_sealed = true WHERE id = $1 returning *;\n+\n+-- name: SealLogInsert :one\n+INSERT INTO collection(id, is_sealed, record_compaction_offset_position, record_enumeration_offset_position) VALUES ($1, true, 0, 0) returning *;\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - ...\r\n- New functionality\r\n  - ...\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nrust/cache/src/foyer.rs\n@@ -94,8 +94,17 @@ const fn default_trace_fetch_us() -> usize {\n     1000 * 100\n }\n \n+fn default_name() -> String {\n+    String::from(\"foyer\")\n+}\n+\n #[derive(Deserialize, Debug, Clone, Serialize, Parser)]\n pub struct FoyerCacheConfig {\n+    /// Name of the cache. All metrics for the cache are prefixed with name_.\n+    #[arg(long, default_value = \"foyer\")]\n+    #[serde(default = \"default_name\")]\n+    pub name: String,\n+\n     /// Directory for disk cache data.\n     #[arg(short, long)]\n     pub dir: Option<String>,\n@@ -262,6 +271,7 @@ impl FoyerCacheConfig {\n impl Default for FoyerCacheConfig {\n     fn default() -> Self {\n         FoyerCacheConfig {\n+            name: default_name(),\n             dir: None,\n             capacity: default_capacity(),\n             mem: default_mem(),\n@@ -352,6 +362,7 @@ where\n             ),\n         );\n         let builder = HybridCacheBuilder::<K, V>::new()\n+            .with_name(config.name.clone())\n             .with_metrics_registry(otel_0_27_metrics)\n             .with_tracing_options(tracing_options.clone())\n             .with_policy(foyer::HybridCachePolicy::WriteOnInsertion)\n@@ -537,6 +548,7 @@ where\n         config: &FoyerCacheConfig,\n     ) -> Result<FoyerPlainCache<K, V>, Box<dyn ChromaError>> {\n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .build();\n@@ -590,6 +602,7 @@ where\n         let evl = TokioEventListener(tx);\n \n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .with_event_listener(Arc::new(evl))\n---\nrust/frontend/sample_configs/distributed.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/worker/chroma_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     disk:\n+                        name: \"block_cache\"\n                         dir: \"/cache/chroma/query-service/block-cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n@@ -72,11 +73,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n \n@@ -138,15 +141,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\nrust/worker/tilt_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 block_cache_config:\n                     disk:\n                         dir: \"/cache/chroma/query-service/block-cache\"\n+                        name: \"block_cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n                         mem: 8000 # 8GiB\n@@ -71,11 +72,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n     fetch_log_batch_size: 1000\n@@ -141,15 +144,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\n\n\n---\n\nChoice B:\nrust/index/src/fulltext/types.rs\n@@ -106,6 +106,11 @@ impl FullTextIndexWriter {\n                     old_document,\n                     new_document,\n                 } => {\n+                    if old_document == new_document {\n+                        // Don't need to do anything if document is identical\n+                        continue;\n+                    }\n+\n                     // Remove old version\n                     let mut trigrams_to_delete = HashSet::new(); // (need to filter out duplicates, each trigram may appear multiple times in a document)\n                     self.tokenizer\n@@ -1067,7 +1072,7 @@ mod tests {\n         let flusher = index_writer.commit().await.unwrap();\n         flusher.flush().await.unwrap();\n \n-        // Update document 3\n+        // Update document document 1 with same content, update document 3 with new content\n         let pl_blockfile_writer = provider\n             .write::<u32, Vec<u32>>(\n                 BlockfileWriterOptions::new()\n@@ -1079,11 +1084,18 @@ mod tests {\n         let pl_blockfile_id = pl_blockfile_writer.id();\n         let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer);\n         index_writer\n-            .handle_batch([DocumentMutation::Update {\n-                offset_id: 3,\n-                old_document: \"world\",\n-                new_document: \"hello\",\n-            }])\n+            .handle_batch([\n+                DocumentMutation::Update {\n+                    offset_id: 1,\n+                    old_document: \"hello world\",\n+                    new_document: \"hello world\",\n+                },\n+                DocumentMutation::Update {\n+                    offset_id: 3,\n+                    old_document: \"world\",\n+                    new_document: \"hello\",\n+                },\n+            ])\n             .unwrap();\n \n         index_writer.write_to_blockfiles().await.unwrap();\n@@ -1102,6 +1114,89 @@ mod tests {\n \n         let res = index_reader.search(\"world\").await.unwrap();\n         assert_eq!(res, RoaringBitmap::from([1]));\n+\n+        let res = index_reader.search(\"hello world\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([1]));\n+    }\n+\n+    #[tokio::test]\n+    async fn test_update_document_noop() {\n+        let tmp_dir = tempdir().unwrap();\n+        let storage = Storage::Local(LocalStorage::new(tmp_dir.path().to_str().unwrap()));\n+        let block_cache = new_cache_for_test();\n+        let root_cache = new_cache_for_test();\n+        let provider = BlockfileProvider::new_arrow(storage, 1024 * 1024, block_cache, root_cache);\n+        let pl_blockfile_writer = provider\n+            .write::<u32, Vec<u32>>(BlockfileWriterOptions::default().ordered_mutations())\n+            .await\n+            .unwrap();\n+        let pl_blockfile_id = pl_blockfile_writer.id();\n+\n+        let tokenizer = NgramTokenizer::new(1, 1, false).unwrap();\n+\n+        // Create empty index\n+        let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer.clone());\n+\n+        index_writer.handle_batch([]).unwrap();\n+\n+        index_writer.write_to_blockfiles().await.unwrap();\n+        let flusher = index_writer.commit().await.unwrap();\n+        flusher.flush().await.unwrap();\n+\n+        // Add document to index\n+        let pl_blockfile_writer = provider\n+            .write::<u32, Vec<u32>>(\n+                BlockfileWriterOptions::new()\n+                    .ordered_mutations()\n+                    .fork(pl_blockfile_id),\n+            )\n+            .await\n+            .unwrap();\n+        let pl_blockfile_id = pl_blockfile_writer.id();\n+        let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer.clone());\n+        index_writer\n+            .handle_batch([DocumentMutation::Create {\n+                offset_id: 1,\n+                new_document: \"hello world\",\n+            }])\n+            .unwrap();\n+\n+        index_writer.write_to_blockfiles().await.unwrap();\n+        let flusher = index_writer.commit().await.unwrap();\n+        flusher.flush().await.unwrap();\n+\n+        // Update document with same content, should be a noop\n+        let pl_blockfile_writer = provider\n+            .write::<u32, Vec<u32>>(\n+                BlockfileWriterOptions::new()\n+                    .ordered_mutations()\n+                    .fork(pl_blockfile_id),\n+            )\n+            .await\n+            .unwrap();\n+        let pl_blockfile_id = pl_blockfile_writer.id();\n+        let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer);\n+        index_writer\n+            .handle_batch([DocumentMutation::Update {\n+                offset_id: 1,\n+                old_document: \"hello world\",\n+                new_document: \"hello world\",\n+            }])\n+            .unwrap();\n+\n+        index_writer.write_to_blockfiles().await.unwrap();\n+        let flusher = index_writer.commit().await.unwrap();\n+        flusher.flush().await.unwrap();\n+\n+        let pl_blockfile_reader = provider\n+            .read::<u32, &[u32]>(&pl_blockfile_id)\n+            .await\n+            .unwrap();\n+        let tokenizer = NgramTokenizer::new(1, 1, false).unwrap();\n+        let index_reader = FullTextIndexReader::new(pl_blockfile_reader, tokenizer);\n+\n+        let res = index_reader.search(\"hello world\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([1]));\n     }\n \n     #[tokio::test]\n---\n\n\n---\n\nChoice C:\nrust/tracing/src/init_tracer.rs\n@@ -33,6 +33,7 @@ pub fn init_global_filter_layer() -> Box<dyn Layer<Registry> + Send + Sync> {\n                 \"distance_metrics\",\n                 \"full_text\",\n                 \"hosted-frontend\",\n+                \"billing_service\",\n                 \"metadata_filtering\",\n                 \"query_service\",\n                 \"wal3\",\n@@ -146,7 +147,7 @@ pub fn init_stdout_layer() -> Box<dyn Layer<Registry> + Send + Sync> {\n                 || metadata\n                     .module_path()\n                     .unwrap_or(\"\")\n-                    .starts_with(\"hosted-frontend\")\n+                    .starts_with(\"billing_service\")\n         }))\n         .with_filter(tracing_subscriber::filter::LevelFilter::INFO)\n         .boxed()\n---\n\n\n---\n\nChoice D:\nrust/tracing/src/init_tracer.rs\n@@ -143,6 +143,10 @@ pub fn init_stdout_layer() -> Box<dyn Layer<Registry> + Send + Sync> {\n                     .module_path()\n                     .unwrap_or(\"\")\n                     .starts_with(\"opentelemetry_sdk\")\n+                || metadata\n+                    .module_path()\n+                    .unwrap_or(\"\")\n+                    .starts_with(\"hosted-frontend\")\n         }))\n         .with_filter(tracing_subscriber::filter::LevelFilter::INFO)\n         .boxed()\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nRelease Chroma CLI 1.1.2\n\n---\n\nChoice A:\nrust/cli/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"chroma-cli\"\n-version = \"1.1.1\"\n+version = \"1.1.2\"\n edition = \"2021\"\n \n [dependencies]\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.1.1\"\n+$release = \"cli-1.1.2\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.1.1\"\n+RELEASE=\"cli-1.1.2\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\n\n\n---\n\nChoice B:\nrust/frontend/src/quota/mod.rs\n@@ -7,6 +7,7 @@ use std::{\n use chroma_error::ChromaError;\n use chroma_types::{CollectionUuid, Metadata, UpdateMetadata, Where};\n use thiserror::Error;\n+use validator::Validate;\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash)]\n pub enum Action {\n@@ -334,12 +335,14 @@ lazy_static::lazy_static! {\n     };\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Validate)]\n pub struct QuotaExceededError {\n     pub usage_type: UsageType,\n     pub action: Action,\n     pub usage: usize,\n     pub limit: usize,\n+    #[validate(length(min = 1))]\n+    pub message: Option<String>,\n }\n \n impl fmt::Display for QuotaExceededError {\n@@ -348,7 +351,11 @@ impl fmt::Display for QuotaExceededError {\n             f,\n             \"'{}' exceeded quota limit for action '{}': current usage of {} exceeds limit of {}\",\n             self.usage_type, self.action, self.usage, self.limit\n-        )\n+        )?;\n+        if let Some(msg) = self.message.as_ref() {\n+            write!(f, \". {}\", msg)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -393,3 +400,63 @@ impl QuotaEnforcer for () {\n         Box::pin(ready(Ok(())))\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{Action, QuotaExceededError, UsageType};\n+    use validator::Validate;\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_none() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: None,\n+        };\n+        assert!(error.validate().is_ok());\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_empty() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: Some(\"\".to_string()),\n+        };\n+        assert!(error.validate().is_err());\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_valid() {\n+        let custom_message = \"This is a valid message.\";\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: Some(custom_message.to_string()),\n+        };\n+        assert!(error.validate().is_ok());\n+        let error_string = format!(\"{}\", error);\n+        let expected_error_string = \"'Number of records' exceeded quota limit for action 'Add': current usage of 100 exceeds limit of 50. This is a valid message.\";\n+        assert_eq!(error_string, expected_error_string);\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_display_no_message() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: None,\n+        };\n+        assert!(error.validate().is_ok());\n+        let error_string = format!(\"{}\", error);\n+        assert_eq!(error_string, \"'Number of records' exceeded quota limit for action 'Add': current usage of 100 exceeds limit of 50\");\n+    }\n+}\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -497,11 +497,6 @@ impl DirtyMarker {\n                         None\n                     }\n                     Ordering::Greater => {\n-                        tracing::info!(\n-                            \"{collection_id} has range ({}, {}]\",\n-                            record_compaction_position,\n-                            record_enumeration_position,\n-                        );\n                         uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_backpressure {\n                             backpressure.push(*collection_id);\n---\n\n\n---\n\nChoice D:\n.github/actions/tilt/action.yaml\n@@ -10,13 +10,16 @@ runs:\n         curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v$TILT_VERSION/tilt.$TILT_VERSION.linux.x86_64.tar.gz | \\\n           tar -xzv -C /usr/local/bin tilt\n     - name: Set up kind\n-      id: kind\n-      uses: helm/kind-action@v1\n+      uses: Wandalen/wretry.action@v3.7.0\n       with:\n-        registry: true\n-        registry_name: my-registry\n-        registry_port: 5001\n-        registry_enable_delete: true\n+        action: helm/kind-action@v1\n+        attempt_limit: 3\n+        attempt_delay: 2000\n+        with: |\n+          registry: true\n+          registry_name: my-registry\n+          registry_port: 5001\n+          registry_enable_delete: true\n     - name: Add blacksmith registry mirror\n       shell: bash\n       run: |\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nSome embedding functions allow the user to pass a path for their embedding function. We should not be validating that the user is trying to update the model path, as that could be too restrictive.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nchromadb/utils/embedding_functions/instructor_embedding_function.py\n@@ -39,7 +39,7 @@ def __init__(\n         self.device = device\n         self.instruction = instruction\n \n-        self._model = INSTRUCTOR(model_name, device=device)\n+        self._model = INSTRUCTOR(model_name_or_path=model_name, device=device)\n \n     def __call__(self, input: Documents) -> Embeddings:\n         \"\"\"\n@@ -99,10 +99,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\nchromadb/utils/embedding_functions/sentence_transformer_embedding_function.py\n@@ -42,7 +42,7 @@ def __init__(\n \n         if model_name not in self.models:\n             self.models[model_name] = SentenceTransformer(\n-                model_name, device=device, **kwargs\n+                model_name_or_path=model_name, device=device, **kwargs\n             )\n         self._model = self.models[model_name]\n \n@@ -102,10 +102,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\nchromadb/utils/embedding_functions/text2vec_embedding_function.py\n@@ -71,10 +71,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\n\n\n---\n\nChoice B:\nrust/blockstore/src/arrow/provider.rs\n@@ -469,6 +469,15 @@ pub struct RootManager {\n     prefetched_roots: Arc<parking_lot::Mutex<HashMap<Uuid, Duration>>>,\n }\n \n+impl std::fmt::Debug for RootManager {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"RootManager\")\n+            .field(\"cache\", &self.cache)\n+            .field(\"storage\", &self.storage)\n+            .finish()\n+    }\n+}\n+\n impl RootManager {\n     pub fn new(storage: Storage, cache: Box<dyn PersistentCache<Uuid, RootReader>>) -> Self {\n         let cache: Arc<dyn PersistentCache<Uuid, RootReader>> = cache.into();\n---\nrust/garbage_collector/src/operators/list_files_at_version.rs\n@@ -0,0 +1,160 @@\n+use async_trait::async_trait;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n+use chroma_system::{Operator, OperatorType};\n+use chroma_types::{chroma_proto::CollectionVersionFile, CollectionUuid, HNSW_PATH};\n+use std::{collections::HashSet, str::FromStr};\n+use thiserror::Error;\n+use tokio::task::{JoinError, JoinSet};\n+use uuid::Uuid;\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionInput {\n+    root_manager: RootManager,\n+    version_file: CollectionVersionFile,\n+    version: i64,\n+}\n+\n+impl ListFilesAtVersionInput {\n+    pub fn new(\n+        root_manager: RootManager,\n+        version_file: CollectionVersionFile,\n+        version: i64,\n+    ) -> Self {\n+        Self {\n+            root_manager,\n+            version_file,\n+            version,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionOutput {\n+    pub collection_id: CollectionUuid,\n+    pub version: i64,\n+    pub file_paths: HashSet<String>,\n+}\n+\n+#[derive(Debug, Error)]\n+pub enum ListFilesAtVersionError {\n+    #[error(\"Version history field missing\")]\n+    VersionHistoryMissing,\n+    #[error(\"Version {0} not found\")]\n+    VersionNotFound(i64),\n+    #[error(\"Invalid UUID: {0}\")]\n+    InvalidUuid(uuid::Error),\n+    #[error(\"Sparse index fetch task failed: {0}\")]\n+    SparseIndexTaskFailed(JoinError),\n+    #[error(\"Error fetching block IDs for sparse index: {0}\")]\n+    FetchBlockIdsError(#[from] RootManagerError),\n+    #[error(\"Version file missing collection ID\")]\n+    VersionFileMissingCollectionId,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ListFilesAtVersionsOperator {}\n+\n+#[async_trait]\n+impl Operator<ListFilesAtVersionInput, ListFilesAtVersionOutput> for ListFilesAtVersionsOperator {\n+    type Error = ListFilesAtVersionError;\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n+\n+    async fn run(\n+        &self,\n+        input: &ListFilesAtVersionInput,\n+    ) -> Result<ListFilesAtVersionOutput, Self::Error> {\n+        let collection_id = CollectionUuid::from_str(\n+            &input\n+                .version_file\n+                .collection_info_immutable\n+                .as_ref()\n+                .ok_or_else(|| ListFilesAtVersionError::VersionFileMissingCollectionId)?\n+                .collection_id,\n+        )\n+        .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+        let version_history = input\n+            .version_file\n+            .version_history\n+            .as_ref()\n+            .ok_or_else(|| ListFilesAtVersionError::VersionHistoryMissing)?;\n+\n+        let mut file_paths = HashSet::new();\n+        let mut sparse_index_ids = HashSet::new();\n+\n+        let version = version_history\n+            .versions\n+            .iter()\n+            .find(|v| v.version == input.version)\n+            .ok_or_else(|| ListFilesAtVersionError::VersionNotFound(input.version))?;\n+\n+        tracing::debug!(\n+            \"Listing files at version {} for collection {}.\",\n+            version.version,\n+            collection_id,\n+        );\n+        tracing::trace!(\n+            \"Processing version {:#?} for collection {}\",\n+            version,\n+            collection_id\n+        );\n+\n+        if let Some(segment_info) = &version.segment_info {\n+            for segment in &segment_info.segment_compaction_info {\n+                for (file_type, segment_paths) in &segment.file_paths {\n+                    if file_type == \"hnsw_index\" || file_type == HNSW_PATH {\n+                        for path in &segment_paths.paths {\n+                            for hnsw_file in [\n+                                \"header.bin\",\n+                                \"data_level0.bin\",\n+                                \"length.bin\",\n+                                \"link_lists.bin\",\n+                            ] {\n+                                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                                file_paths.insert(format!(\"hnsw/{}/{}\", path, hnsw_file));\n+                            }\n+                        }\n+                    } else {\n+                        // Must be a sparse index\n+                        for path in &segment_paths.paths {\n+                            // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                            file_paths.insert(format!(\"sparse_index/{}\", path));\n+\n+                            let sparse_index_id = Uuid::parse_str(path)\n+                                .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+                            sparse_index_ids.insert(sparse_index_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut block_id_tasks = JoinSet::new();\n+        for sparse_index_id in sparse_index_ids {\n+            let root_manager = input.root_manager.clone();\n+            block_id_tasks\n+                .spawn(async move { root_manager.get_all_block_ids(&sparse_index_id).await });\n+        }\n+\n+        while let Some(res) = block_id_tasks.join_next().await {\n+            let block_ids = res\n+                .map_err(ListFilesAtVersionError::SparseIndexTaskFailed)?\n+                .map_err(ListFilesAtVersionError::FetchBlockIdsError)?;\n+\n+            for block_id in block_ids {\n+                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                file_paths.insert(format!(\"block/{}\", block_id));\n+            }\n+        }\n+\n+        Ok(ListFilesAtVersionOutput {\n+            collection_id,\n+            version: input.version,\n+            file_paths,\n+        })\n+    }\n+}\n---\nrust/garbage_collector/src/operators/mod.rs\n@@ -8,4 +8,5 @@ pub mod fetch_lineage_file;\n pub mod fetch_sparse_index_files;\n pub mod fetch_version_file;\n pub mod get_version_file_paths;\n+pub mod list_files_at_version;\n pub mod mark_versions_at_sysdb;\n---\n\n\n---\n\nChoice C:\nchromadb/test/utils/cross_version.py\n@@ -5,7 +5,11 @@\n from types import ModuleType\n from typing import Dict, List\n \n-base_install_dir = tempfile.gettempdir() + \"/persistence_test_chromadb_versions\"\n+base_install_dir = (\n+    tempfile.gettempdir()\n+    + f\"/worker-{os.environ.get('PYTEST_XDIST_WORKER', 'unknown')}\"\n+    + \"/persistence_test_chromadb_versions\"\n+)\n \n \n def get_path_to_version_install(version: str) -> str:\n@@ -48,6 +52,8 @@ def install_version(version: str, dep_overrides: Dict[str, str]) -> None:\n \n \n def install(pkg: str, path: str, dep_overrides: Dict[str, str]) -> int:\n+    os.makedirs(path, exist_ok=True)\n+\n     # -q -q to suppress pip output to ERROR level\n     # https://pip.pypa.io/en/stable/cli/pip/#quiet\n     command = [sys.executable, \"-m\", \"pip\", \"-q\", \"-q\", \"install\", pkg]\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/server.rs\n@@ -915,57 +915,67 @@ async fn create_collection(\n     let payload_clone = payload.clone();\n \n     let configuration = if !server.config.enable_set_index_params {\n-        let mut new_configuration = payload.configuration.clone().unwrap();\n-        let hnsw_config = new_configuration.hnsw.clone();\n-        let spann_config = new_configuration.spann.clone();\n-\n-        if let Some(hnsw) = &hnsw_config {\n-            let space = hnsw.space.clone();\n-            if hnsw.ef_construction.is_some()\n-                || hnsw.ef_search.is_some()\n-                || hnsw.max_neighbors.is_some()\n-                || hnsw.num_threads.is_some()\n-                || hnsw.resize_factor.is_some()\n-                || hnsw.sync_threshold.is_some()\n-                || hnsw.batch_size.is_some()\n-            {\n-                return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n-                    \"HNSW\".to_string(),\n-                )\n-                .into());\n+        if let Some(mut new_configuration) = payload.configuration.clone() {\n+            let hnsw_config = new_configuration.hnsw.clone();\n+            let spann_config = new_configuration.spann.clone();\n+\n+            if let Some(hnsw) = &hnsw_config {\n+                let space = hnsw.space.clone();\n+                if hnsw.ef_construction.is_some()\n+                    || hnsw.ef_search.is_some()\n+                    || hnsw.max_neighbors.is_some()\n+                    || hnsw.num_threads.is_some()\n+                    || hnsw.resize_factor.is_some()\n+                    || hnsw.sync_threshold.is_some()\n+                    || hnsw.batch_size.is_some()\n+                {\n+                    return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n+                        \"HNSW\".to_string(),\n+                    )\n+                    .into());\n+                }\n+                let new_hnsw = HnswConfiguration {\n+                    space,\n+                    ..Default::default()\n+                };\n+                new_configuration.hnsw = Some(new_hnsw);\n+            } else if let Some(spann) = &spann_config {\n+                let space = spann.space.clone();\n+                if spann.search_nprobe.is_some()\n+                    || spann.write_nprobe.is_some()\n+                    || spann.ef_construction.is_some()\n+                    || spann.ef_search.is_some()\n+                    || spann.max_neighbors.is_some()\n+                    || spann.reassign_neighbor_count.is_some()\n+                    || spann.split_threshold.is_some()\n+                    || spann.merge_threshold.is_some()\n+                {\n+                    return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n+                        \"SPANN\".to_string(),\n+                    )\n+                    .into());\n+                }\n+                let new_spann = SpannConfiguration {\n+                    space,\n+                    ..Default::default()\n+                };\n+                new_configuration.spann = Some(new_spann);\n             }\n-            let new_hnsw = HnswConfiguration {\n-                space,\n-                ..Default::default()\n-            };\n-            new_configuration.hnsw = Some(new_hnsw);\n-        } else if let Some(spann) = &spann_config {\n-            let space = spann.space.clone();\n-            if spann.search_nprobe.is_some()\n-                || spann.write_nprobe.is_some()\n-                || spann.ef_construction.is_some()\n-                || spann.ef_search.is_some()\n-                || spann.max_neighbors.is_some()\n-                || spann.reassign_neighbor_count.is_some()\n-                || spann.split_threshold.is_some()\n-                || spann.merge_threshold.is_some()\n-            {\n-                return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n-                    \"SPANN\".to_string(),\n-                )\n-                .into());\n-            }\n-            let new_spann = SpannConfiguration {\n-                space,\n-                ..Default::default()\n-            };\n-            new_configuration.spann = Some(new_spann);\n-        }\n \n-        Some(InternalCollectionConfiguration::try_from_config(\n-            new_configuration,\n-            server.config.frontend.default_knn_index,\n-        )?)\n+            Some(InternalCollectionConfiguration::try_from_config(\n+                new_configuration,\n+                server.config.frontend.default_knn_index,\n+            )?)\n+        } else {\n+            Some(InternalCollectionConfiguration::try_from_config(\n+                CollectionConfiguration {\n+                    hnsw: None,\n+                    spann: None,\n+                    embedding_function: None,\n+                },\n+                server.config.frontend.default_knn_index,\n+            )?)\n+        }\n     } else {\n         match payload_clone.configuration {\n             Some(c) => Some(InternalCollectionConfiguration::try_from_config(\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - Handles the new quota errors (422 code and message starts with `Quota exceeded`) and returns a `ChromaQuotaExceededError`. The new error type includes the quota message where before this threw a generic Error without any quota specific messaging.\r\n- New functionality\r\n  - None\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\nNone\r\n\n\n---\n\nChoice A:\nclients/js/packages/chromadb-core/src/ChromaFetch.ts\n@@ -9,6 +9,7 @@ import {\n   ChromaError,\n   createErrorByType,\n   ChromaUniqueError,\n+  ChromaQuotaExceededError,\n } from \"./Errors\";\n import { FetchAPI } from \"./generated\";\n \n@@ -74,6 +75,14 @@ export const chromaFetch: FetchAPI = async (\n           );\n         case 409:\n           throw new ChromaUniqueError(\"The resource already exists\");\n+        case 422:\n+          if (\n+            respBody?.message &&\n+            respBody?.message.startsWith(\"Quota exceeded\")\n+          ) {\n+            throw new ChromaQuotaExceededError(respBody?.message);\n+          }\n+          break;\n         case 500:\n           throw parseServerError(respBody?.error);\n         case 502:\n---\nclients/js/packages/chromadb-core/src/Errors.ts\n@@ -85,6 +85,13 @@ export class ChromaUniqueError extends Error {\n   }\n }\n \n+export class ChromaQuotaExceededError extends Error {\n+  name = \"ChromaQuotaExceededError\";\n+  constructor(message: string, public readonly cause?: unknown) {\n+    super(message);\n+  }\n+}\n+\n export function createErrorByType(type: string, message: string) {\n   switch (type) {\n     case \"InvalidCollection\":\n---\n\n\n---\n\nChoice B:\nrust/storage/src/admissioncontrolleds3.rs\n@@ -548,9 +548,19 @@ impl CountBasedPolicy {\n             match &mut channel_receiver {\n                 Some(rx) => {\n                     select! {\n-                        _ = rx.recv() => {\n+                        did_recv = rx.recv() => {\n                             // Reevaluate priority if we got a notification.\n-                            continue;\n+                            match did_recv {\n+                                Some(_) => {\n+                                    // If we got a notification, continue to acquire.\n+                                    continue;\n+                                }\n+                                None => {\n+                                    // If the channel was closed, break out of the loop.\n+                                    channel_receiver = None;\n+                                    continue;\n+                                }\n+                            }\n                         }\n                         token = self.remaining_tokens[current_priority.as_usize()].acquire() => {\n                             match token {\n---\nrust/worker/src/execution/operators/prefetch_record.rs\n@@ -6,7 +6,7 @@ use chroma_segment::{\n     blockfile_record::{RecordSegmentReader, RecordSegmentReaderCreationError},\n     types::{materialize_logs, LogMaterializerError},\n };\n-use chroma_system::Operator;\n+use chroma_system::{Operator, OperatorType};\n use thiserror::Error;\n use tracing::{trace, Instrument, Span};\n \n@@ -94,4 +94,8 @@ impl Operator<PrefetchRecordInput, PrefetchRecordOutput> for PrefetchRecordOpera\n     fn errors_when_sender_dropped(&self) -> bool {\n         false\n     }\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n }\n---\n\n\n---\n\nChoice C:\n.github/actions/docker/action.yaml\n@@ -17,11 +17,6 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n-    # https://github.com/docker/setup-qemu-action - for multiplatform builds\n-    - name: Set up QEMU\n-      uses: docker/setup-qemu-action@v2\n-    - name: Set up Docker Buildx\n-      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n.github/workflows/_build_release_container.yml\n@@ -33,43 +33,106 @@ permissions:\n env:\n   GHCR_IMAGE_NAME: \"ghcr.io/chroma-core/chroma\"\n   DOCKERHUB_IMAGE_NAME: \"chromadb/chroma\"\n-  PLATFORMS: linux/amd64,linux/arm64 #linux/riscv64, linux/arm/v7\n \n jobs:\n   build:\n-    name: Build and publish container image\n+    name: Build image for ${{ matrix.platform }}\n     runs-on: blacksmith-16vcpu-ubuntu-2204\n+    strategy:\n+      matrix:\n+        platform: [amd64, arm64]\n+        include:\n+          - platform: amd64\n+            runner: blacksmith-16vcpu-ubuntu-2204\n+            docker_platform: linux/amd64\n+          - platform: arm64\n+            runner: blacksmith-16vcpu-ubuntu-2204-arm\n+            docker_platform: linux/arm64\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n         with:\n           fetch-depth: 0\n+\n       - name: Set up Docker\n         uses: ./.github/actions/docker\n         with:\n           ghcr-username: ${{ github.actor }}\n           ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n           dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-      - name: Compute tags\n+\n+      - name: Compute arch-specific tags\n+        id: tags\n         shell: bash\n-        id: compute_tags\n         run: |\n-          tags=\"${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }},${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\"\n-          if [ \"${{ inputs.tag_as_latest }}\" = \"true\" ]; then\n-            tags=\"${tags},${{ env.GHCR_IMAGE_NAME }}:latest,${{ env.DOCKERHUB_IMAGE_NAME }}:latest\"\n-          fi\n+          arch_tag=\"${{ inputs.tag }}-${{ matrix.platform }}\"\n+          ghcr=\"${{ env.GHCR_IMAGE_NAME }}:${arch_tag}\"\n+          dhub=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${arch_tag}\"\n+          echo \"arch_tag=$arch_tag\"      >> $GITHUB_OUTPUT\n \n-          echo \"tags=${tags}\" >> $GITHUB_OUTPUT\n+          # expose *matrix-unique* step outputs\n+          echo \"ghcr_tag_${{ matrix.platform }}=$ghcr\"         >> $GITHUB_OUTPUT\n+          echo \"dockerhub_tag_${{ matrix.platform }}=$dhub\"    >> $GITHUB_OUTPUT\n+\n+          # these two tags are what the build-push action will publish for *this* arch\n+          echo \"tags=$ghcr,$dhub\" >> $GITHUB_OUTPUT\n \n       - name: Build and push image\n         uses: useblacksmith/build-push-action@v1.1\n         with:\n           context: .\n           file: rust/Dockerfile\n           target: cli\n-          platforms: ${{ env.PLATFORMS }}\n+          platforms: ${{ matrix.docker_platform }}\n           push: true\n           build-args: |\n             RELEASE_MODE=1\n-          tags: ${{ steps.compute_tags.outputs.tags }}\n+          tags: ${{ steps.tags.outputs.tags }}\n+    outputs:\n+      ghcr_tag_amd64:      ${{ steps.tags.outputs.ghcr_tag_amd64 }}\n+      ghcr_tag_arm64:      ${{ steps.tags.outputs.ghcr_tag_arm64 }}\n+      dockerhub_tag_amd64: ${{ steps.tags.outputs.dockerhub_tag_amd64 }}\n+      dockerhub_tag_arm64: ${{ steps.tags.outputs.dockerhub_tag_arm64 }}\n+\n+  merge:\n+    name: Merge platform manifests\n+    runs-on: blacksmith-4vcpu-ubuntu-2204\n+    needs:\n+      - build\n+    steps:\n+      - name: Set up Docker\n+        uses: ./.github/actions/docker\n+        with:\n+          ghcr-username: ${{ github.actor }}\n+          ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n+          dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n+          dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n+\n+      - name: Create and push manifest\n+        shell: bash\n+        run: |\n+          set -euo pipefail\n+\n+          # Pull the per-arch tags from job-level outputs\n+          ghcr_amd64='${{ needs.build.outputs.ghcr_tag_amd64 }}'\n+          ghcr_arm64='${{ needs.build.outputs.ghcr_tag_arm64 }}'\n+          dhub_amd64='${{ needs.build.outputs.dockerhub_tag_amd64 }}'\n+          dhub_arm64='${{ needs.build.outputs.dockerhub_tag_arm64 }}'\n+\n+          base_tag='${{ inputs.tag }}'\n+          ghcr_base=\"${{ env.GHCR_IMAGE_NAME }}:${base_tag}\"\n+          dhub_base=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${base_tag}\"\n+\n+          docker buildx imagetools create --tag \"$ghcr_base\" $ghcr_amd64 $ghcr_arm64\n+          docker buildx imagetools create --tag \"$dhub_base\"  $dhub_amd64 $dhub_arm64\n+\n+          if [[ \"${{ inputs.tag_as_latest }}\" == \"true\" ]]; then\n+            docker buildx imagetools create --tag \"${{ env.GHCR_IMAGE_NAME }}:latest\"  $ghcr_amd64 $ghcr_arm64\n+            docker buildx imagetools create --tag \"${{ env.DOCKERHUB_IMAGE_NAME }}:latest\" $dhub_amd64 $dhub_arm64\n+          fi\n+\n+      - name: Inspect image\n+        run: |\n+          docker buildx imagetools inspect ${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }}\n+          docker buildx imagetools inspect ${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\n---\n\n\n---\n\nChoice D:\nCargo.lock\n@@ -4508,7 +4508,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34\"\n dependencies = [\n  \"cfg-if\",\n- \"windows-targets 0.48.5\",\n+ \"windows-targets 0.52.6\",\n ]\n \n [[package]]\n@@ -5147,16 +5147,17 @@ checksum = \"830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3\"\n \n [[package]]\n name = \"numpy\"\n-version = \"0.23.0\"\n+version = \"0.24.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b94caae805f998a07d33af06e6a3891e38556051b8045c615470a71590e13e78\"\n+checksum = \"a7cfbf3f0feededcaa4d289fe3079b03659e85c5b5a177f4ba6fb01ab4fb3e39\"\n dependencies = [\n  \"libc\",\n  \"ndarray\",\n  \"num-complex\",\n  \"num-integer\",\n  \"num-traits\",\n  \"pyo3\",\n+ \"pyo3-build-config\",\n  \"rustc-hash 2.0.0\",\n ]\n \n@@ -6035,9 +6036,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7778bffd85cf38175ac1f545509665d0b9b92a198ca7941f131f85f7a4f9a872\"\n+checksum = \"e5203598f366b11a02b13aa20cab591229ff0a89fd121a308a5df751d5fc9219\"\n dependencies = [\n  \"cfg-if\",\n  \"indoc\",\n@@ -6053,29 +6054,29 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-build-config\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94f6cbe86ef3bf18998d9df6e0f3fc1050a8c5efa409bf712e661a4366e010fb\"\n+checksum = \"99636d423fa2ca130fa5acde3059308006d46f98caac629418e53f7ebb1e9999\"\n dependencies = [\n  \"once_cell\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"pyo3-ffi\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e9f1b4c431c0bb1c8fb0a338709859eed0d030ff6daa34368d3b152a63dfdd8d\"\n+checksum = \"78f9cf92ba9c409279bc3305b5409d90db2d2c22392d443a87df3a1adad59e33\"\n dependencies = [\n  \"libc\",\n  \"pyo3-build-config\",\n ]\n \n [[package]]\n name = \"pyo3-macros\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbc2201328f63c4710f68abdf653c89d8dbc2858b88c5d88b0ff38a75288a9da\"\n+checksum = \"0b999cb1a6ce21f9a6b147dcf1be9ffedf02e0043aec74dc390f3007047cecd9\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"pyo3-macros-backend\",\n@@ -6085,9 +6086,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-macros-backend\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fca6726ad0f3da9c9de093d6f116a93c1a38e417ed73bf138472cf4064f72028\"\n+checksum = \"822ece1c7e1012745607d5cf0bcb2874769f0f7cb34c4cde03b9358eb9ef911a\"\n dependencies = [\n  \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n@@ -7308,7 +7309,7 @@ version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"03c3c6b7927ffe7ecaa769ee0e3994da3b8cafc8f444578982c83ecb161af917\"\n dependencies = [\n- \"heck 0.4.1\",\n+ \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n  \"syn 2.0.101\",\n@@ -7866,9 +7867,9 @@ checksum = \"55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.16\"\n+version = \"0.13.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61c41af27dd6d1e27b1b16b489db798443478cef1f06a660c96db617ba5de3b1\"\n+checksum = \"e502f78cdbb8ba4718f566c418c52bc729126ffd16baee5baa718cf25dd5a69a\"\n \n [[package]]\n name = \"tempfile\"\n---\nCargo.toml\n@@ -44,6 +44,7 @@ flatbuffers = \"24.3.25\"\n futures = \"0.3\"\n futures-core = \"0.3\"\n lazy_static = { version = \"1.4\" }\n+lexical-core = \"1.0\"\n num_cpus = \"1.16.0\"\n opentelemetry = { version = \"0.27.0\", default-features = false, features = [\"trace\", \"metrics\"] }\n opentelemetry-otlp = { version = \"0.27\", features = [\"http-proto\"] }\n@@ -78,7 +79,7 @@ utoipa = { version = \"5.0.0\", features = [\"macros\", \"axum_extras\", \"debug\", \"uui\n sqlx = { version = \"0.8.3\", features = [\"runtime-tokio\", \"sqlite\"] }\n sha2 = \"0.10.8\"\n md5 = \"0.7.0\"\n-pyo3 = { version = \"0.23.3\", features = [\"abi3-py39\"] }\n+pyo3 = { version = \"0.24.1\", features = [\"abi3-py39\"] }\n http = \"1.1.0\"\n tower-http = { version = \"0.6.2\", features = [\"trace\", \"cors\"] }\n bytemuck = \"1.21.0\"\n@@ -125,6 +126,7 @@ shuttle = \"0.7.1\"\n tempfile = \"3.14.0\"\n itertools = \"0.13.0\"\n serial_test = \"3.2.0\"\n+zip = \"2.3.0\"\n \n [profile.dev]\n # Significantly reduces compile times\n---\nrust/python_bindings/Cargo.toml\n@@ -13,7 +13,7 @@ async-trait = { workspace = true }\n pyo3 = { workspace = true }\n tokio = { workspace = true }\n uuid = { workspace = true }\n-numpy = \"0.23.0\"\n+numpy = \"0.24.0\"\n serde = { workspace = true }\n serde_json = { workspace = true }\n thiserror = { workspace = true }\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis allows one scout-logs request to know everything that's on the log.\nIt's necessary for the range to be everything pull-logs can access.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/test/utils/wait_for_version_increase.py\n@@ -23,7 +23,8 @@ def wait_for_version_increase(\n     while curr_version == initial_version:\n         time.sleep(TIMEOUT_INTERVAL)\n         if time.time() - initial_time > timeout:\n-            raise TimeoutError(\"Model was not updated in time\")\n+            collection_id = client.get_collection(collection_name).id\n+            raise TimeoutError(f\"Model was not updated in time for {collection_id}\")\n         curr_version = get_collection_version(client, collection_name)\n \n     return curr_version\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -56,3 +56,5 @@ circuit_breaker:\n   requests: 1000\n enable_span_indexing: true\n default_knn_index: \"spann\"\n+tenants_to_migrate_immediately:\n+- \"default_tenant\"\n---\nrust/log-service/src/lib.rs\n@@ -896,6 +896,14 @@ impl LogServer {\n         self.metrics\n             .dirty_log_records_read\n             .add(dirty_markers.len() as u64, &[]);\n+        let Some((last_record_inserted, _)) = dirty_markers.last() else {\n+            let backpressure = vec![];\n+            self.set_backpressure(&backpressure);\n+            let mut need_to_compact = self.need_to_compact.lock();\n+            let mut rollups = HashMap::new();\n+            std::mem::swap(&mut *need_to_compact, &mut rollups);\n+            return Ok(());\n+        };\n         let mut rollups = DirtyMarker::coalesce_markers(&dirty_markers)?;\n         self.enrich_dirty_log(&mut rollups).await?;\n         let mut markers = vec![];\n@@ -919,7 +927,8 @@ impl LogServer {\n             markers.push(serde_json::to_string(&DirtyMarker::Cleared).map(Vec::from)?);\n         }\n         let mut new_cursor = cursor.clone();\n-        new_cursor.position = self.dirty_log.append_many(markers).await?;\n+        self.dirty_log.append_many(markers).await?;\n+        new_cursor.position = *last_record_inserted + 1u64;\n         let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n             return Err(Error::CouldNotGetDirtyLogCursors);\n         };\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/server/server.go\n@@ -54,16 +54,18 @@ func (s *logServer) ScoutLogs(ctx context.Context, req *logservicepb.ScoutLogsRe\n \tif err != nil {\n \t\treturn\n \t}\n+\tvar start int64\n \tvar limit int64\n-\t_, limit, err = s.lr.GetBoundsForCollection(ctx, collectionID.String())\n+\tstart, limit, err = s.lr.GetBoundsForCollection(ctx, collectionID.String())\n \tif err != nil {\n \t\treturn\n \t}\n \t// +1 to convert from the (] bound to a [) bound.\n \tres = &logservicepb.ScoutLogsResponse{\n+\t\tFirstUncompactedRecordOffset: int64(start + 1),\n \t\tFirstUninsertedRecordOffset: int64(limit + 1),\n \t}\n-\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n+\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"start\", int64(start + 1)), zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n \treturn\n }\n \n---\nidl/chromadb/proto/logservice.proto\n@@ -24,6 +24,8 @@ message ScoutLogsResponse {\n   reserved 1;\n   // The next record to insert will have this offset.\n   int64 first_uninserted_record_offset = 2;\n+  // The oldest record on the log will have this offset.\n+  int64 first_uncompacted_record_offset = 3;\n }\n \n message PullLogsRequest {\n---\nrust/log-service/src/lib.rs\n@@ -745,18 +745,24 @@ impl LogService for LogServer {\n                 Arc::clone(&self.storage),\n                 prefix,\n             );\n-            let limit_position = match log_reader.maximum_log_position().await {\n-                Ok(limit_position) => limit_position,\n+            let (start_position, limit_position) = match log_reader.manifest().await {\n+                Ok(Some(manifest)) => (\n+                    manifest.minimum_log_position(),\n+                    manifest.maximum_log_position(),\n+                ),\n+                Ok(None) => (LogPosition::from_offset(0), LogPosition::from_offset(1)),\n                 Err(err) => {\n                     if err.code() == chroma_error::ErrorCodes::FailedPrecondition {\n-                        LogPosition::from_offset(1)\n+                        (LogPosition::from_offset(1), LogPosition::from_offset(1))\n                     } else {\n                         return Err(Status::new(err.code().into(), err.to_string()));\n                     }\n                 }\n             };\n+            let start_offset = start_position.offset() as i64;\n             let limit_offset = limit_position.offset() as i64;\n             Ok(Response::new(ScoutLogsResponse {\n+                first_uncompacted_record_offset: start_offset,\n                 first_uninserted_record_offset: limit_offset,\n             }))\n         }\n---\nrust/wal3/src/manifest.rs\n@@ -276,7 +276,7 @@ impl Snapshot {\n             },\n             (Some(f), None) => f,\n             (None, Some(s)) => s,\n-            (None, None) => LogPosition::default(),\n+            (None, None) => LogPosition::from_offset(1),\n         }\n     }\n \n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -497,11 +497,6 @@ impl DirtyMarker {\n                         None\n                     }\n                     Ordering::Greater => {\n-                        tracing::info!(\n-                            \"{collection_id} has range ({}, {}]\",\n-                            record_compaction_position,\n-                            record_enumeration_position,\n-                        );\n                         uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_backpressure {\n                             backpressure.push(*collection_id);\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis updates the IDL for the log service to have two new methods:\nSealLog and MigrateLog.  They each take a collection ID and trigger the\ntwo phase transitions for the go-to-rust migration that's coming.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nIDL includes comments.\n\n\n---\n\nChoice A:\ngo/pkg/log/server/server.go\n@@ -162,6 +162,15 @@ func (s *logServer) InspectDirtyLog(ctx context.Context, req *logservicepb.Inspe\n \treturn\n }\n \n+func (s *logServer) SealLog(ctx context.Context, req *logservicepb.SealLogRequest) (res *logservicepb.SealLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n+\n+func (s *logServer) MigrateLog(ctx context.Context, req *logservicepb.MigrateLogRequest) (res *logservicepb.MigrateLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n \n func NewLogServer(lr *repository.LogRepository) logservicepb.LogServiceServer {\n \treturn &logServer{\n---\nidl/chromadb/proto/logservice.proto\n@@ -96,6 +96,22 @@ message InspectDirtyLogResponse {\n   repeated string markers = 1;\n }\n \n+message SealLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message SealLogResponse {\n+  // Empty\n+}\n+\n+message MigrateLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message MigrateLogResponse {\n+  // Empty\n+}\n+\n service LogService {\n   rpc PushLogs(PushLogsRequest) returns (PushLogsResponse) {}\n   rpc ScoutLogs(ScoutLogsRequest) returns (ScoutLogsResponse) {}\n@@ -104,5 +120,11 @@ service LogService {\n   rpc GetAllCollectionInfoToCompact(GetAllCollectionInfoToCompactRequest) returns (GetAllCollectionInfoToCompactResponse) {}\n   rpc UpdateCollectionLogOffset(UpdateCollectionLogOffsetRequest) returns (UpdateCollectionLogOffsetResponse) {}\n   rpc PurgeDirtyForCollection(PurgeDirtyForCollectionRequest) returns (PurgeDirtyForCollectionResponse) {}\n+  // RPC endpoints to expose for operator debuggability.\n+  // This endpoint must route to the rust log service.\n   rpc InspectDirtyLog(InspectDirtyLogRequest) returns (InspectDirtyLogResponse) {}\n+  // This endpoint must route to the go log service.\n+  rpc SealLog(SealLogRequest) returns (SealLogResponse) {}\n+  // This endpoint must route to the rust log service.\n+  rpc MigrateLog(MigrateLogRequest) returns (MigrateLogResponse) {}\n }\n---\nrust/log-service/src/lib.rs\n@@ -16,9 +16,10 @@ use chroma_storage::Storage;\n use chroma_types::chroma_proto::{\n     log_service_server::LogService, CollectionInfo, GetAllCollectionInfoToCompactRequest,\n     GetAllCollectionInfoToCompactResponse, InspectDirtyLogRequest, InspectDirtyLogResponse,\n-    LogRecord, OperationRecord, PullLogsRequest, PullLogsResponse, PurgeDirtyForCollectionRequest,\n-    PurgeDirtyForCollectionResponse, PushLogsRequest, PushLogsResponse, ScoutLogsRequest,\n-    ScoutLogsResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n+    LogRecord, MigrateLogRequest, MigrateLogResponse, OperationRecord, PullLogsRequest,\n+    PullLogsResponse, PurgeDirtyForCollectionRequest, PurgeDirtyForCollectionResponse,\n+    PushLogsRequest, PushLogsResponse, ScoutLogsRequest, ScoutLogsResponse, SealLogRequest,\n+    SealLogResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n };\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n@@ -1230,6 +1231,24 @@ impl LogService for LogServer {\n         }\n         Ok(Response::new(InspectDirtyLogResponse { markers }))\n     }\n+\n+    async fn seal_log(\n+        &self,\n+        _request: Request<SealLogRequest>,\n+    ) -> Result<Response<SealLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do sealing\",\n+        ))\n+    }\n+\n+    async fn migrate_log(\n+        &self,\n+        _request: Request<MigrateLogRequest>,\n+    ) -> Result<Response<MigrateLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do migrating yet\",\n+        ))\n+    }\n }\n \n fn parquet_to_records(parquet: Arc<Vec<u8>>) -> Result<Vec<(LogPosition, Vec<u8>)>, Status> {\n---\n\n\n---\n\nChoice B:\nrust/garbage_collector/src/operators/compute_unused_files.rs\n@@ -1,5 +1,5 @@\n use async_trait::async_trait;\n-use chroma_blockstore::RootManager;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n use chroma_cache::nop::NopCache;\n use chroma_error::{ChromaError, ErrorCodes};\n use chroma_storage::Storage;\n@@ -145,14 +145,14 @@ impl ComputeUnusedFilesOperator {\n         for si_id in si_ids {\n             let uuid = Uuid::parse_str(&si_id).map_err(|e| {\n                 tracing::error!(error = %e, \"Failed to parse UUID\");\n-                ComputeUnusedFilesError::ParseError(si_id.clone(), e.to_string())\n+                ComputeUnusedFilesError::InvalidUuid(e, si_id.clone())\n             })?;\n \n             let block_ids = match self.root_manager.get_all_block_ids(&uuid).await {\n                 Ok(ids) => ids,\n                 Err(e) => {\n                     tracing::error!(error = %e, \"Failed to get block IDs\");\n-                    return Err(ComputeUnusedFilesError::ParseError(si_id, e.to_string()));\n+                    return Err(ComputeUnusedFilesError::FailedToFetchBlockIDs(e));\n                 }\n             };\n             tracing::debug!(\n@@ -193,8 +193,10 @@ pub struct ComputeUnusedFilesOutput {\n \n #[derive(Error, Debug)]\n pub enum ComputeUnusedFilesError {\n-    #[error(\"Error parsing sparse index file: {0}\")]\n-    ParseError(String, String),\n+    #[error(\"Error parsing UUID: {0} from {1}\")]\n+    InvalidUuid(uuid::Error, String),\n+    #[error(\"Failed to fetch block IDs: {0}\")]\n+    FailedToFetchBlockIDs(RootManagerError),\n     #[error(\"Version file has missing content\")]\n     VersionFileMissingContent(i64),\n     #[error(\"Version history is missing\")]\n---\n\n\n---\n\nChoice C:\nchromadb/test/utils/wait_for_version_increase.py\n@@ -23,7 +23,8 @@ def wait_for_version_increase(\n     while curr_version == initial_version:\n         time.sleep(TIMEOUT_INTERVAL)\n         if time.time() - initial_time > timeout:\n-            raise TimeoutError(\"Model was not updated in time\")\n+            collection_id = client.get_collection(collection_name).id\n+            raise TimeoutError(f\"Model was not updated in time for {collection_id}\")\n         curr_version = get_collection_version(client, collection_name)\n \n     return curr_version\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -56,3 +56,5 @@ circuit_breaker:\n   requests: 1000\n enable_span_indexing: true\n default_knn_index: \"spann\"\n+tenants_to_migrate_immediately:\n+- \"default_tenant\"\n---\nrust/log-service/src/lib.rs\n@@ -896,6 +896,14 @@ impl LogServer {\n         self.metrics\n             .dirty_log_records_read\n             .add(dirty_markers.len() as u64, &[]);\n+        let Some((last_record_inserted, _)) = dirty_markers.last() else {\n+            let backpressure = vec![];\n+            self.set_backpressure(&backpressure);\n+            let mut need_to_compact = self.need_to_compact.lock();\n+            let mut rollups = HashMap::new();\n+            std::mem::swap(&mut *need_to_compact, &mut rollups);\n+            return Ok(());\n+        };\n         let mut rollups = DirtyMarker::coalesce_markers(&dirty_markers)?;\n         self.enrich_dirty_log(&mut rollups).await?;\n         let mut markers = vec![];\n@@ -919,7 +927,8 @@ impl LogServer {\n             markers.push(serde_json::to_string(&DirtyMarker::Cleared).map(Vec::from)?);\n         }\n         let mut new_cursor = cursor.clone();\n-        new_cursor.position = self.dirty_log.append_many(markers).await?;\n+        self.dirty_log.append_many(markers).await?;\n+        new_cursor.position = *last_record_inserted + 1u64;\n         let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n             return Err(Error::CouldNotGetDirtyLogCursors);\n         };\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -967,11 +967,7 @@ func (tc *Catalog) ForkCollection(ctx context.Context, forkCollection *model.For\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\t// NOTE: This is a temporary hardcoded limit for the size of the lineage file\n-\t\t// TODO: Load the limit value from quota / scorecard, and/or improve the lineage file design to avoid large lineage file\n-\t\tif len(lineageFile.Dependencies) > 1000000 {\n-\t\t\treturn common.ErrCollectionTooManyFork\n-\t\t}\n+\n \t\tlineageFile.Dependencies = append(lineageFile.Dependencies, &coordinatorpb.CollectionVersionDependency{\n \t\t\tSourceCollectionId:      sourceCollectionIDStr,\n \t\t\tSourceCollectionVersion: uint64(sourceCollection.Version),\n---\nrust/frontend/src/quota/mod.rs\n@@ -336,7 +336,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n         m.insert(UsageType::RegexPatternLength, 0);\n-        m.insert(UsageType::NumForks, 1_000_000);\n+        m.insert(UsageType::NumForks, 10000);\n         m\n     };\n }\n---\nrust/frontend/src/server.rs\n@@ -1175,6 +1175,7 @@ async fn fork_collection(\n         CollectionUuid::from_str(&collection_id).map_err(|_| ValidationError::CollectionId)?;\n     let mut quota_payload = QuotaPayload::new(Action::ForkCollection, tenant.clone(), api_token);\n     quota_payload = quota_payload.with_collection_uuid(collection_id);\n+    quota_payload = quota_payload.with_collection_name(&payload.new_name);\n     server.quota_enforcer.enforce(&quota_payload).await?;\n \n     let _guard =\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Adds `hosted-frontend` to stdout layer in tracing\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\n.github/workflows/pr.yml\n@@ -200,7 +200,7 @@ jobs:\n         - name: Check PR Title\n           uses: Slashgear/action-check-pr-title@v4.3.0\n           with:\n-            regexp: '\\[(ENH|BUG|DOC|TST|BLD|PERF|TYP|CLN|CHORE|RELEASE|HOTFIX)\\].*'\n+            regexp: '\\[(ENH|BUG|DOC|TST|BLD|PERF|TYP|CLN|CHORE|RELEASE|HOTFIX|INST)\\].*'\n             helpMessage: \"Please tag your PR title. See https://docs.trychroma.com/contributing#contributing-code-and-ideas. You must push new code to this PR for this check to run again.\"\n         - name: Comment explaining failure\n           if: failure()\n---\n\n\n---\n\nChoice B:\nrust/tracing/src/init_tracer.rs\n@@ -143,6 +143,10 @@ pub fn init_stdout_layer() -> Box<dyn Layer<Registry> + Send + Sync> {\n                     .module_path()\n                     .unwrap_or(\"\")\n                     .starts_with(\"opentelemetry_sdk\")\n+                || metadata\n+                    .module_path()\n+                    .unwrap_or(\"\")\n+                    .starts_with(\"hosted-frontend\")\n         }))\n         .with_filter(tracing_subscriber::filter::LevelFilter::INFO)\n         .boxed()\n---\n\n\n---\n\nChoice C:\nrust/segment/src/sqlite_metadata.rs\n@@ -482,8 +482,9 @@ impl IntoSqliteExpr for DocumentExpression {\n             EmbeddingFulltextSearch::StringValue,\n         ));\n         let doc_contains = doc_col\n+            .clone()\n             .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .is(true);\n+            .and(doc_col.is_not_null());\n         match self.operator {\n             DocumentOperator::Contains => doc_contains,\n             DocumentOperator::NotContains => doc_contains.not(),\n@@ -495,9 +496,11 @@ impl IntoSqliteExpr for DocumentExpression {\n \n impl IntoSqliteExpr for MetadataExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let key_cond = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key))\n+        let key_col = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key));\n+        let key_cond = key_col\n+            .clone()\n             .eq(self.key.to_string())\n-            .is(true);\n+            .and(key_col.is_not_null());\n         match &self.comparison {\n             MetadataComparison::Primitive(op, val) => {\n                 let (col, sval) = match val {\n@@ -668,21 +671,28 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            filter_limit_query\n-                .left_join(\n-                    EmbeddingMetadata::Table,\n-                    Expr::col((Embeddings::Table, Embeddings::Id))\n-                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n-                )\n-                .left_join(\n+            let (has_document_expr, has_metadata_expr) = match whr {\n+                Where::Composite(expr) => expr.has_document_and_metadata(),\n+                Where::Document(_) => (true, false),\n+                Where::Metadata(_) => (false, true),\n+            };\n+            if has_document_expr {\n+                filter_limit_query.left_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n-                )\n-                .distinct()\n-                .cond_where(whr.eval());\n+                );\n+            }\n+            if has_metadata_expr {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            };\n+            filter_limit_query.distinct().cond_where(whr.eval());\n         }\n \n         filter_limit_query\n---\nrust/types/src/metadata.rs\n@@ -560,6 +560,24 @@ impl Where {\n             },\n         }\n     }\n+\n+    // expression_check is a helper function to identify whether a given Where clause contains\n+    // a document or metadata predicate. It recursively checks the children of a composite expression.\n+    fn expression_check(&self, has_document_expr: &mut bool, has_metadata_expr: &mut bool) {\n+        match self {\n+            Where::Composite(composite) => {\n+                for child in composite.children.iter() {\n+                    child.expression_check(has_document_expr, has_metadata_expr);\n+\n+                    if *has_document_expr && *has_metadata_expr {\n+                        return;\n+                    }\n+                }\n+            }\n+            Where::Document(_) => *has_document_expr = true,\n+            Where::Metadata(_) => *has_metadata_expr = true,\n+        }\n+    }\n }\n \n impl TryFrom<chroma_proto::Where> for Where {\n@@ -611,6 +629,26 @@ pub struct CompositeExpression {\n     pub children: Vec<Where>,\n }\n \n+impl CompositeExpression {\n+    pub fn has_document_and_metadata(&self) -> (bool, bool) {\n+        let mut has_document_expr = false;\n+        let mut has_metadata_expr = false;\n+        self.expression_check(&mut has_document_expr, &mut has_metadata_expr);\n+        (has_document_expr, has_metadata_expr)\n+    }\n+\n+    // expression_check is an extension of the Where expression_check function, just for\n+    // CompositeExpression\n+    fn expression_check(&self, has_document_expr: &mut bool, has_metadata_expr: &mut bool) {\n+        for child in self.children.iter() {\n+            child.expression_check(has_document_expr, has_metadata_expr);\n+            if *has_document_expr && *has_metadata_expr {\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n impl TryFrom<chroma_proto::WhereChildren> for CompositeExpression {\n     type Error = WhereConversionError;\n \n---\n\n\n---\n\nChoice D:\nchromadb/test/property/test_fork.py\n@@ -21,6 +21,10 @@\n from overrides import overrides\n from typing import Dict, cast, Union, Tuple, Set\n \n+import grpc\n+from chromadb.proto.logservice_pb2 import SealLogRequest\n+from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n collection_st = hyst.shared(strategies.collections(with_hnsw_params=True), key=\"source\")\n \n \n@@ -38,6 +42,10 @@ def __init__(self, client: chromadb.api.ClientAPI):\n         self.client = client\n         self.collection_names = set()\n \n+        # Create go log service client\n+        channel = grpc.insecure_channel(\"localhost:50052\")\n+        self.go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n     @initialize(collection=collection_st, target=updated_collections)\n     def initialize(\n         self, collection: strategies.Collection\n@@ -77,12 +85,14 @@ def fork(\n     @rule(\n         cursor=consumes(forked_collections),\n         delta=strategies.recordsets(collection_st),\n+        seal=hyst.booleans(),\n         target=updated_collections,\n     )\n     def upsert(\n         self,\n         cursor: Tuple[Collection, strategies.StateMachineRecordSet],\n         delta: strategies.RecordSet,\n+        seal: bool,\n     ) -> Tuple[Collection, strategies.StateMachineRecordSet]:\n         collection, record_set_state = cursor\n         normalized_delta: strategies.NormalizedRecordSet = invariants.wrap_all(delta)\n@@ -148,6 +158,8 @@ def upsert(\n                     )\n                 else:\n                     record_set_state[\"documents\"].append(None)\n+        if seal:\n+            self.go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n         return collection, record_set_state\n \n     @rule(\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThis removes the `release/**` trigger from the `trigger-deploy` workflow so that deploys aren't created when hotfixes are merged to release branches. We want this to be a manual step for the time being to prevent unintentional deploys of the control plane when we are hotfixing the data plane.\r\n\r\n- Improvements & Bug fixes\r\n  - Prevents hotfix merges from triggering a deploy of code that is potentially behind what is deployed.\r\n- New functionality\r\n  - N/A - removes automation\r\n\r\n## Test plan\r\n\r\nManual testing -- we will have to manually deploy changes after merging hotfixes to release branches.\n\n---\n\nChoice A:\nCargo.lock\n@@ -1314,9 +1314,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.2.1\"\n+version = \"1.2.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fd9de9f2205d5ef3fd67e685b0df337994ddd4495e2a28d185500d0e1edfea47\"\n+checksum = \"8691782945451c1c383942c4874dbe63814f61cb57ef773cda2972682b7bb3c0\"\n dependencies = [\n  \"jobserver\",\n  \"libc\",\n@@ -2319,9 +2319,9 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.5.12\"\n+version = \"0.5.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab3db02a9c5b5121e1e42fbdb1aeb65f5e02624cc58c43f2884c6ccac0b82f95\"\n+checksum = \"82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2\"\n dependencies = [\n  \"crossbeam-utils\",\n ]\n@@ -4502,7 +4502,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34\"\n dependencies = [\n  \"cfg-if\",\n- \"windows-targets 0.52.6\",\n+ \"windows-targets 0.48.5\",\n ]\n \n [[package]]\n@@ -5315,9 +5315,9 @@ checksum = \"0ab1bc2a289d34bd04a330323ac98a1b4bc82c9d9fcb1e66b63caa84da26b575\"\n \n [[package]]\n name = \"openssl\"\n-version = \"0.10.66\"\n+version = \"0.10.72\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9529f4786b70a3e8c61e11179af17ab6188ad8d0ded78c5529441ed39d4bd9c1\"\n+checksum = \"fedfea7d58a1f73118430a55da6a286e7b044961736ce96a16a17068ea25e5da\"\n dependencies = [\n  \"bitflags 2.9.0\",\n  \"cfg-if\",\n@@ -5347,9 +5347,9 @@ checksum = \"ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf\"\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.103\"\n+version = \"0.9.108\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7f9e8deee91df40a943c71b917e5874b951d32a802526c85721ce3b776c929d6\"\n+checksum = \"e145e1651e858e820e4860f7b9c5e169bc1d8ce1c86043be79fa7b7634821847\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -6029,9 +6029,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"57fe09249128b3173d092de9523eaa75136bf7ba85e0d69eca241c7939c933cc\"\n+checksum = \"7778bffd85cf38175ac1f545509665d0b9b92a198ca7941f131f85f7a4f9a872\"\n dependencies = [\n  \"cfg-if\",\n  \"indoc\",\n@@ -6047,29 +6047,29 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-build-config\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cd3927b5a78757a0d71aa9dff669f903b1eb64b54142a9bd9f757f8fde65fd7\"\n+checksum = \"94f6cbe86ef3bf18998d9df6e0f3fc1050a8c5efa409bf712e661a4366e010fb\"\n dependencies = [\n  \"once_cell\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"pyo3-ffi\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dab6bb2102bd8f991e7749f130a70d05dd557613e39ed2deeee8e9ca0c4d548d\"\n+checksum = \"e9f1b4c431c0bb1c8fb0a338709859eed0d030ff6daa34368d3b152a63dfdd8d\"\n dependencies = [\n  \"libc\",\n  \"pyo3-build-config\",\n ]\n \n [[package]]\n name = \"pyo3-macros\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"91871864b353fd5ffcb3f91f2f703a22a9797c91b9ab497b1acac7b07ae509c7\"\n+checksum = \"fbc2201328f63c4710f68abdf653c89d8dbc2858b88c5d88b0ff38a75288a9da\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"pyo3-macros-backend\",\n@@ -6079,9 +6079,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-macros-backend\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"43abc3b80bc20f3facd86cd3c60beed58c3e2aa26213f3cda368de39c60a27e4\"\n+checksum = \"fca6726ad0f3da9c9de093d6f116a93c1a38e417ed73bf138472cf4064f72028\"\n dependencies = [\n  \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n@@ -6517,15 +6517,14 @@ dependencies = [\n \n [[package]]\n name = \"ring\"\n-version = \"0.17.8\"\n+version = \"0.17.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c17fa4cb658e3583423e915b9f3acc01cceaee1860e33d59ebae66adc3a2dc0d\"\n+checksum = \"a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7\"\n dependencies = [\n  \"cc\",\n  \"cfg-if\",\n  \"getrandom 0.2.15\",\n  \"libc\",\n- \"spin\",\n  \"untrusted\",\n  \"windows-sys 0.52.0\",\n ]\n@@ -7303,7 +7302,7 @@ version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"03c3c6b7927ffe7ecaa769ee0e3994da3b8cafc8f444578982c83ecb161af917\"\n dependencies = [\n- \"heck 0.5.0\",\n+ \"heck 0.4.1\",\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n  \"syn 2.0.101\",\n@@ -8058,9 +8057,9 @@ checksum = \"1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20\"\n \n [[package]]\n name = \"tokio\"\n-version = \"1.41.1\"\n+version = \"1.45.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22cfb5bee7a6a52939ca9224d6ac897bb669134078daa8735560897f69de4d33\"\n+checksum = \"2513ca694ef9ede0fb23fe71a4ee4107cb102b9dc1930f6d0fd77aae068ae165\"\n dependencies = [\n  \"backtrace\",\n  \"bytes\",\n@@ -8086,9 +8085,9 @@ dependencies = [\n \n [[package]]\n name = \"tokio-macros\"\n-version = \"2.4.0\"\n+version = \"2.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752\"\n+checksum = \"6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n---\n\n\n---\n\nChoice B:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.7\"\n+__version__ = \"1.0.8\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.7\"\n+      \"Default\": \"1.0.8\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -497,11 +497,6 @@ impl DirtyMarker {\n                         None\n                     }\n                     Ordering::Greater => {\n-                        tracing::info!(\n-                            \"{collection_id} has range ({}, {}]\",\n-                            record_compaction_position,\n-                            record_enumeration_position,\n-                        );\n                         uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_backpressure {\n                             backpressure.push(*collection_id);\n---\n\n\n---\n\nChoice D:\n.github/workflows/release-chromadb.yml\n@@ -220,7 +220,7 @@ jobs:\n                 // - This workflow finishes for A and deploys A to Chroma Cloud\n                 // Chroma Cloud is now running A, but the last commit was B.\n                 \"environment\": \"staging\",\n-                \"planes\": \"data,control\"\n+                \"planes\": \"control,data\"\n               }\n             })\n \n---\n.github/workflows/trigger-deploy.yaml\n@@ -5,8 +5,9 @@ on:\n   push:\n     branches:\n       # main is not included here because it is handled by the release-chromadb.yaml workflow\n+      # production deploys (release branches) are also not here because they are currently\n+      # meant to be handled manually.\n       - rc/**-**-**\n-      - release/**-**-**\n \n jobs:\n   deploy:\n@@ -25,7 +26,7 @@ jobs:\n               ref: 'main',\n               inputs: {\n                 'planes': 'control,data',\n-                 environment: '${{ contains(github.ref, 'release/') && 'production' || 'staging' }}',\n+                 environment: 'staging',\n                 'ignore-lock': true,\n                 'oss-ref': '${{ github.ref_name }}',\n                 'hosted-ref': '${{ github.ref_name }}'\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThe space of cases I have to handle:\n\npanic(BenignRace, AlreadyInitialized, Uninitialized) -> cannot double-initialize manifest\npanic(BenignRace, AlreadyInitialized, Failure) -> cannot double-initialize manifest\npanic(BenignRace, AlreadyInitialized, Success) -> cannot double-initialize manifest\npanic(Success, AlreadyInitialized, Uninitialized) -> cannot double-initialize manifest\npanic(Success, AlreadyInitialized, Failure) -> cannot double-initialize manifest\npanic(Success, AlreadyInitialized, Success) -> cannot double-initialize manifest\n\npanic(BenignRace, Uninitialized, Failure) -> failed to install recovered manifest\npanic(BenignRace, Success, Failure) -> failed to install recovered manifest\npanic(Success, Uninitialized, Failure) -> failed to install recovered manifest\npanic(Success, Success, Failure) -> failed to install recovered manifest\n\npanic(BenignRace, Uninitialized, Uninitialized) -> cannot have manifest become uninitialized\npanic(BenignRace, Success, Uninitialized) -> cannot have manifest become uninitialized\npanic(Success, Uninitialized, Uninitialized) -> cannot have manifest become uninitialized\npanic(Success, Success, Uninitialized) -> cannot have manifest become uninitialized\n\nCommitting so I don't lose it.\n\n## Test plan\n\nThis is a planning tool.  It doesn't need testing as it's part of a testing effort.\n\n## Documentation Changes\n\nNo docs here.\n\n\n---\n\nChoice A:\n.github/workflows/_python-tests.yml\n@@ -24,11 +24,12 @@ jobs:\n         test-globs:\n           - \"--ignore-glob 'chromadb/test/property/*' --ignore-glob 'chromadb/test/stress/*' --ignore-glob 'chromadb/test/distributed/*'\"\n           - \"chromadb/test/property --ignore-glob chromadb/test/property/test_cross_version_persist.py\"\n-          # TODO(@codetheweb): this test should be parallelized, but it frequently flakes in CI when parallelized. We have not been able to reproduce the failure locally. See https://github.com/chroma-core/chroma/issues/4263.\n           - \"chromadb/test/property/test_cross_version_persist.py\"\n         include:\n           - test-globs: \"chromadb/test/property --ignore-glob chromadb/test/property/test_cross_version_persist.py\"\n             parallelized: true\n+          - test-globs: \"chromadb/test/property/test_cross_version_persist.py\"\n+            parallelized: true\n \n     runs-on: ${{ matrix.platform }}\n     steps:\n---\n\n\n---\n\nChoice B:\nrust/wal3/examples/wal3-bootstrap-reasoner.rs\n@@ -0,0 +1,182 @@\n+//! This file is not intended for public consumption, but is kept for completeness.\n+//!\n+//! In this file you will find that we reason about the bootstrap process by completely exploring\n+//! the state space and pruning known good states.  The goal is to prune every state or print a\n+//! list of states that are bad.\n+//!\n+//! This is ad-hoc machine-assisted proving without an environment or theorem prover.\n+\n+#[derive(Clone, Copy, Debug)]\n+enum FragmentState {\n+    BenignRace,\n+    Conflict,\n+    Success,\n+}\n+\n+impl FragmentState {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            FragmentState::BenignRace,\n+            FragmentState::Conflict,\n+            FragmentState::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum InitializeManifest {\n+    Uninitialized,\n+    AlreadyInitialized,\n+    Success,\n+}\n+\n+impl InitializeManifest {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            InitializeManifest::Uninitialized,\n+            InitializeManifest::AlreadyInitialized,\n+            InitializeManifest::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum RecoverManifest {\n+    Uninitialized,\n+    Failure,\n+    Success,\n+}\n+\n+impl RecoverManifest {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            RecoverManifest::Uninitialized,\n+            RecoverManifest::Failure,\n+            RecoverManifest::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+enum Disposition {\n+    /// The combination of states is considered a good case.\n+    Good,\n+    /// The combination of states is not considered by the rule.\n+    Pass,\n+    /// The case can be dropped with good conscience for not mattering.  The string is the reason.\n+    Drop(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+    /// The case must lead to an error at runtime.\n+    Panic(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+    /// The case must be raised to the user for inspection.\n+    Raise(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+}\n+\n+fn happy_paths(fs: FragmentState, im: InitializeManifest, rm: RecoverManifest) -> Disposition {\n+    match (fs, im, rm) {\n+        (\n+            FragmentState::Success | FragmentState::BenignRace,\n+            InitializeManifest::Uninitialized | InitializeManifest::Success,\n+            RecoverManifest::Success,\n+        ) => Disposition::Good,\n+        _ => Disposition::Pass,\n+    }\n+}\n+\n+fn error_paths(fs: FragmentState, im: InitializeManifest, rm: RecoverManifest) -> Disposition {\n+    match (fs, im, rm) {\n+        (_, InitializeManifest::AlreadyInitialized, _) => {\n+            Disposition::Panic(\"cannot double-initialize manifest\", fs, im, rm)\n+        }\n+        (_, _, RecoverManifest::Uninitialized) => {\n+            Disposition::Panic(\"cannot have manifest become uninitialized\", fs, im, rm)\n+        }\n+        (_, _, RecoverManifest::Failure) => {\n+            Disposition::Panic(\"failed to install recovered manifest\", fs, im, rm)\n+        }\n+        _ => Disposition::Pass,\n+    }\n+}\n+\n+fn conflict_on_fragment(\n+    fs: FragmentState,\n+    im: InitializeManifest,\n+    rm: RecoverManifest,\n+) -> Disposition {\n+    if matches!(fs, FragmentState::Conflict) {\n+        Disposition::Drop(\n+            \"no need to touch manifest if fragment conflicts\",\n+            fs,\n+            im,\n+            rm,\n+        )\n+    } else {\n+        Disposition::Pass\n+    }\n+}\n+\n+fn unconditionally_raise(\n+    fs: FragmentState,\n+    im: InitializeManifest,\n+    rm: RecoverManifest,\n+) -> Disposition {\n+    Disposition::Raise(\"unconditional raise\", fs, im, rm)\n+}\n+\n+pub fn main() {\n+    let mut states = vec![];\n+    for fs in FragmentState::all_states() {\n+        for im in InitializeManifest::all_states() {\n+            for rm in RecoverManifest::all_states() {\n+                states.push((fs, im, rm));\n+            }\n+        }\n+    }\n+    let rules = vec![\n+        happy_paths,\n+        conflict_on_fragment,\n+        error_paths,\n+        unconditionally_raise,\n+    ];\n+    for state in states.iter() {\n+        for rule in &rules {\n+            match (rule)(state.0, state.1, state.2) {\n+                Disposition::Pass => {}\n+                Disposition::Good => {\n+                    break;\n+                }\n+                Disposition::Panic(reason, fs, im, rm) => {\n+                    println!(\"panic({fs:?}, {im:?}, {rm:?}) -> {reason}\");\n+                    break;\n+                }\n+                Disposition::Drop(reason, fs, im, rm) => {\n+                    _ = reason;\n+                    _ = fs;\n+                    _ = im;\n+                    _ = rm;\n+                    break;\n+                }\n+                Disposition::Raise(reason, fs, im, rm) => {\n+                    println!(\"raise({fs:?}, {im:?}, {rm:?}) -> {reason}\");\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n---\n\n\n---\n\nChoice C:\nrust/types/src/api_types.rs\n@@ -82,7 +82,7 @@ impl ChromaError for GetCollectionWithSegmentsError {\n             GetCollectionWithSegmentsError::CollectionConversionError(\n                 collection_conversion_error,\n             ) => collection_conversion_error.code(),\n-            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::Internal,\n             GetCollectionWithSegmentsError::Field(_) => ErrorCodes::FailedPrecondition,\n             GetCollectionWithSegmentsError::SegmentConversionError(segment_conversion_error) => {\n                 segment_conversion_error.code()\n@@ -832,7 +832,7 @@ impl ChromaError for ForkCollectionError {\n             ForkCollectionError::CollectionConversionError(collection_conversion_error) => {\n                 collection_conversion_error.code()\n             }\n-            ForkCollectionError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            ForkCollectionError::DuplicateSegment => ErrorCodes::Internal,\n             ForkCollectionError::Field(_) => ErrorCodes::FailedPrecondition,\n             ForkCollectionError::Local => ErrorCodes::Unimplemented,\n             ForkCollectionError::Internal(chroma_error) => chroma_error.code(),\n---\n\n\n---\n\nChoice D:\nCargo.toml\n@@ -126,6 +126,10 @@ tempfile = \"3.14.0\"\n itertools = \"0.13.0\"\n serial_test = \"3.2.0\"\n \n+[profile.dev]\n+# Significantly reduces compile times\n+split-debuginfo = \"unpacked\"\n+\n [profile.release]\n debug = 2\n lto = \"thin\"\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis PR cherry-picks the commit 1880120afbdb791dbc70d6d41b58c840b452e853 onto release/2025-05-09. If there are unresolved conflicts, please resolve them manually.\n\n---\n\nChoice A:\nrust/worker/src/execution/operators/filter.rs\n@@ -498,6 +498,11 @@ impl Operator<FilterInput, FilterOutput> for FilterOperator {\n     async fn run(&self, input: &FilterInput) -> Result<FilterOutput, FilterError> {\n         tracing::debug!(\"[{}]: {:?}\", self.get_name(), input);\n \n+        // NOTE: This is temporary traces to capture filter arguments\n+        //       We suspect certain filters break the FTS algorithm\n+        // TODO: Remove this after the bug is found\n+        tracing::debug!(\"[DEBUG FILTER OPERATOR]: {:?}\", self);\n+\n         let record_segment_reader = match RecordSegmentReader::from_segment(\n             &input.record_segment,\n             &input.blockfile_provider,\n---\nrust/worker/src/execution/operators/projection.rs\n@@ -71,6 +71,8 @@ pub enum ProjectionError {\n     RecordSegment(#[from] Box<dyn ChromaError>),\n     #[error(\"Error reading unitialized record segment\")]\n     RecordSegmentUninitialized,\n+    #[error(\"Error reading phantom record: {0}\")]\n+    RecordSegmentPhantomRecord(u32),\n }\n \n impl ChromaError for ProjectionError {\n@@ -80,6 +82,7 @@ impl ChromaError for ProjectionError {\n             ProjectionError::RecordReader(e) => e.code(),\n             ProjectionError::RecordSegment(e) => e.code(),\n             ProjectionError::RecordSegmentUninitialized => ErrorCodes::Internal,\n+            ProjectionError::RecordSegmentPhantomRecord(_) => ErrorCodes::Internal,\n         }\n     }\n }\n@@ -153,7 +156,7 @@ impl Operator<ProjectionInput, ProjectionOutput> for ProjectionOperator {\n                         let record = reader\n                             .get_data_for_offset_id(*offset_id)\n                             .await?\n-                            .ok_or(ProjectionError::RecordSegmentUninitialized)?;\n+                            .ok_or(ProjectionError::RecordSegmentPhantomRecord(*offset_id))?;\n                         ProjectionRecord {\n                             id: record.id.to_string(),\n                             document: record\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/repository/log.go\n@@ -168,7 +168,8 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\t}\n \t}()\n \n-\tsourceBounds, err := queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n+\tvar sourceBounds log.GetBoundsForCollectionRow\n+\tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in getting compaction and enumeration offset for source collection\", zap.Error(err), zap.String(\"collectionId\", sourceCollectionID))\n \t\treturn\n---\n\n\n---\n\nChoice C:\nchromadb/test/property/test_fork.py\n@@ -21,6 +21,10 @@\n from overrides import overrides\n from typing import Dict, cast, Union, Tuple, Set\n \n+import grpc\n+from chromadb.proto.logservice_pb2 import SealLogRequest\n+from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n collection_st = hyst.shared(strategies.collections(with_hnsw_params=True), key=\"source\")\n \n \n@@ -38,6 +42,10 @@ def __init__(self, client: chromadb.api.ClientAPI):\n         self.client = client\n         self.collection_names = set()\n \n+        # Create go log service client\n+        channel = grpc.insecure_channel(\"localhost:50052\")\n+        self.go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n     @initialize(collection=collection_st, target=updated_collections)\n     def initialize(\n         self, collection: strategies.Collection\n@@ -77,12 +85,14 @@ def fork(\n     @rule(\n         cursor=consumes(forked_collections),\n         delta=strategies.recordsets(collection_st),\n+        seal=hyst.booleans(),\n         target=updated_collections,\n     )\n     def upsert(\n         self,\n         cursor: Tuple[Collection, strategies.StateMachineRecordSet],\n         delta: strategies.RecordSet,\n+        seal: bool,\n     ) -> Tuple[Collection, strategies.StateMachineRecordSet]:\n         collection, record_set_state = cursor\n         normalized_delta: strategies.NormalizedRecordSet = invariants.wrap_all(delta)\n@@ -148,6 +158,8 @@ def upsert(\n                     )\n                 else:\n                     record_set_state[\"documents\"].append(None)\n+        if seal:\n+            self.go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n         return collection, record_set_state\n \n     @rule(\n---\n\n\n---\n\nChoice D:\nrust/load/src/bin/chroma-load-start.rs\n@@ -1,7 +1,10 @@\n //! Start a workload on the chroma-load server.\n \n+use std::sync::Arc;\n+\n use clap::Parser;\n \n+use chroma_load::data_sets::{all_data_sets, References};\n use chroma_load::rest::StartRequest;\n use chroma_load::{humanize_expires, Connection, Throughput, Workload};\n \n@@ -18,7 +21,13 @@ struct Args {\n     #[arg(long)]\n     workload: String,\n     #[arg(long)]\n-    data_set: String,\n+    data_set: Option<String>,\n+    #[arg(long)]\n+    references_data_set: Option<String>,\n+    #[arg(long)]\n+    operates_on_data_set: Option<String>,\n+    #[arg(long)]\n+    operates_on_cardinality: Option<usize>,\n     #[arg(long)]\n     url: String,\n     #[arg(long)]\n@@ -103,11 +112,47 @@ async fn main() {\n             wrap: Box::new(workload),\n         };\n     }\n+    let (data_set, custom_data_set) = match (\n+        args.data_set,\n+        args.references_data_set,\n+        args.operates_on_data_set,\n+        args.operates_on_cardinality,\n+    ) {\n+        (Some(data_set), None, None, None) => (Some(data_set.clone()), None),\n+        (None, Some(references), Some(operates_on), Some(cardinality)) => {\n+            let Some(referred_to) = all_data_sets()\n+                .iter()\n+                .find(|ds| ds.name() == references)\n+                .map(Arc::clone)\n+            else {\n+                eprintln!(\"Could not find a data set to reference named {references}\");\n+                std::process::exit(13);\n+            };\n+            let to_start = References {\n+                references: referred_to.json(),\n+                operates_on,\n+                cardinality,\n+            };\n+            let to_start = match serde_json::to_value(&to_start) {\n+                Ok(to_start) => to_start,\n+                Err(err) => {\n+                    eprintln!(\"could not serialize referencing data set: {err:?}\");\n+                    std::process::exit(13);\n+                }\n+            };\n+            (None, Some(to_start))\n+        }\n+        _ => {\n+            eprintln!(\"must provide data_set XOR (references_data_set, operates_on_data_set, operates_on_cardinality)\");\n+            std::process::exit(13);\n+        }\n+    };\n     let req = StartRequest {\n         name: args.name,\n         expires: humanize_expires(&args.expires).unwrap_or(args.expires),\n         workload,\n-        data_set: args.data_set,\n+        data_set,\n+        custom_data_set,\n         connection: Connection {\n             url: args.url,\n             api_key,\n---\nrust/load/src/data_sets.rs\n@@ -1496,9 +1496,9 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n \n #[derive(Clone, Debug, Default, serde::Deserialize, serde::Serialize)]\n pub struct References {\n-    references: serde_json::Value,\n-    operates_on: String,\n-    cardinality: usize,\n+    pub references: serde_json::Value,\n+    pub operates_on: String,\n+    pub cardinality: usize,\n }\n \n /// Get a data set from a particular JSON value.\n---\nrust/load/src/lib.rs\n@@ -1190,7 +1190,7 @@ impl LoadService {\n     pub fn start(\n         &self,\n         name: String,\n-        mut workload: Workload,\n+        workload: Workload,\n         data_set: String,\n         connection: Connection,\n         expires: chrono::DateTime<chrono::FixedOffset>,\n@@ -1199,14 +1199,28 @@ impl LoadService {\n         let Some(data_set) = self.data_sets().iter().find(|ds| ds.name() == data_set) else {\n             return Err(Error::NotFound(\"data set not found\".to_string()));\n         };\n+        let data_set = Arc::clone(data_set);\n+        self.start_struct(name, workload, data_set, connection, expires, throughput)\n+    }\n+\n+    /// Start a workload on the load service using structs rather than resolving strings.\n+    pub fn start_struct(\n+        &self,\n+        name: String,\n+        mut workload: Workload,\n+        data_set: Arc<dyn DataSet>,\n+        connection: Connection,\n+        expires: chrono::DateTime<chrono::FixedOffset>,\n+        throughput: Throughput,\n+    ) -> Result<Uuid, Error> {\n         workload.resolve_by_name(self.workloads())?;\n         let res = {\n             // SAFETY(rescrv):  Mutex poisoning.\n             let mut harness = self.harness.lock().unwrap();\n             Ok(harness.start(\n                 name,\n                 workload.clone(),\n-                data_set,\n+                &data_set,\n                 connection,\n                 expires,\n                 throughput,\n@@ -1625,15 +1639,41 @@ async fn start(\n ) -> Result<String, Error> {\n     let expires = chrono::DateTime::parse_from_rfc3339(&req.expires)\n         .map_err(|err| Error::InvalidRequest(format!(\"could not parse rfc3339: {err:?}\")))?;\n-    let uuid = state.load.start(\n-        req.name,\n-        req.workload,\n-        req.data_set,\n-        req.connection,\n-        expires,\n-        req.throughput,\n-    )?;\n-    Ok(uuid.to_string() + \"\\n\")\n+    match (req.data_set, req.custom_data_set) {\n+        (Some(_), Some(_)) => Err(Error::InvalidRequest(\n+            \"provide at most one of data_set and custom_data_set\".to_string(),\n+        )),\n+        (None, None) => Err(Error::InvalidRequest(\n+            \"provide at least one of data_set and custom_data_set\".to_string(),\n+        )),\n+        (Some(data_set), None) => {\n+            let uuid = state.load.start(\n+                req.name,\n+                req.workload,\n+                data_set,\n+                req.connection,\n+                expires,\n+                req.throughput,\n+            )?;\n+            Ok(uuid.to_string() + \"\\n\")\n+        }\n+        (None, Some(custom_data_set)) => {\n+            let Some(data_set) = data_sets::from_json(&custom_data_set) else {\n+                return Err(Error::InvalidRequest(\n+                    \"custom data set returned nothing\".to_string(),\n+                ));\n+            };\n+            let uuid = state.load.start_struct(\n+                req.name,\n+                req.workload,\n+                data_set,\n+                req.connection,\n+                expires,\n+                req.throughput,\n+            )?;\n+            Ok(uuid.to_string() + \"\\n\")\n+        }\n+    }\n }\n \n async fn stop(\n---\nrust/load/src/rest.rs\n@@ -43,8 +43,10 @@ pub struct StartRequest {\n     pub name: String,\n     /// The workload to run.\n     pub workload: Workload,\n-    /// The data set to use.\n-    pub data_set: String,\n+    /// The data set to use, referred to by name.\n+    pub data_set: Option<String>,\n+    /// The custom data set to use.\n+    pub custom_data_set: Option<serde_json::Value>,\n     /// The connection to use.\n     pub connection: Connection,\n     /// When the workload should expire.\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Add temporary traces to log filter arguments. We suspect certain filters are not handled properly.\n  - Add projection error variant for clarity\n- New functionality\n  - N/A\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/cache/src/foyer.rs\n@@ -492,6 +492,10 @@ where\n         }\n         Ok(res)\n     }\n+\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.cache.contains(key)\n+    }\n }\n \n impl<K, V> super::PersistentCache<K, V> for FoyerHybridCache<K, V>\n@@ -820,4 +824,26 @@ mod test {\n             .expect(\"Value should not be None\");\n         assert_eq!(value, \"foo\");\n     }\n+\n+    #[tokio::test]\n+    async fn test_may_contain() {\n+        let dir = tempfile::tempdir()\n+            .expect(\"To be able to create temp path\")\n+            .path()\n+            .to_str()\n+            .expect(\"To be able to parse path\")\n+            .to_string();\n+        let cache = FoyerCacheConfig {\n+            dir: Some(dir.clone()),\n+            flush: true,\n+            ..Default::default()\n+        }\n+        .build_hybrid_test::<String, String>()\n+        .await\n+        .unwrap();\n+\n+        cache.insert(\"key1\".to_string(), \"foo\".to_string()).await;\n+        assert!(cache.may_contain(&\"key1\".to_string()).await);\n+        assert!(!cache.may_contain(&\"key2\".to_string()).await);\n+    }\n }\n---\nrust/cache/src/lib.rs\n@@ -69,6 +69,11 @@ where\n {\n     async fn insert(&self, key: K, value: V);\n     async fn get(&self, key: &K) -> Result<Option<V>, CacheError>;\n+    // Returns true if the cache contains the key. This method may return a\n+    // false-positive.\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.get(key).await.map(|v| v.is_some()).unwrap_or(false)\n+    }\n     async fn remove(&self, key: &K);\n     async fn clear(&self) -> Result<(), CacheError>;\n     async fn obtain(&self, key: K) -> Result<Option<V>, CacheError>;\n---\n\n\n---\n\nChoice B:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.4\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.4\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.4\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.4\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.4\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\n\n\n---\n\nChoice C:\nrust/worker/src/execution/operators/filter.rs\n@@ -498,6 +498,11 @@ impl Operator<FilterInput, FilterOutput> for FilterOperator {\n     async fn run(&self, input: &FilterInput) -> Result<FilterOutput, FilterError> {\n         tracing::debug!(\"[{}]: {:?}\", self.get_name(), input);\n \n+        // NOTE: This is temporary traces to capture filter arguments\n+        //       We suspect certain filters break the FTS algorithm\n+        // TODO: Remove this after the bug is found\n+        tracing::debug!(\"[DEBUG FILTER OPERATOR]: {:?}\", self);\n+\n         let record_segment_reader = match RecordSegmentReader::from_segment(\n             &input.record_segment,\n             &input.blockfile_provider,\n---\nrust/worker/src/execution/operators/projection.rs\n@@ -71,6 +71,8 @@ pub enum ProjectionError {\n     RecordSegment(#[from] Box<dyn ChromaError>),\n     #[error(\"Error reading unitialized record segment\")]\n     RecordSegmentUninitialized,\n+    #[error(\"Error reading phantom record: {0}\")]\n+    RecordSegmentPhantomRecord(u32),\n }\n \n impl ChromaError for ProjectionError {\n@@ -80,6 +82,7 @@ impl ChromaError for ProjectionError {\n             ProjectionError::RecordReader(e) => e.code(),\n             ProjectionError::RecordSegment(e) => e.code(),\n             ProjectionError::RecordSegmentUninitialized => ErrorCodes::Internal,\n+            ProjectionError::RecordSegmentPhantomRecord(_) => ErrorCodes::Internal,\n         }\n     }\n }\n@@ -153,7 +156,7 @@ impl Operator<ProjectionInput, ProjectionOutput> for ProjectionOperator {\n                         let record = reader\n                             .get_data_for_offset_id(*offset_id)\n                             .await?\n-                            .ok_or(ProjectionError::RecordSegmentUninitialized)?;\n+                            .ok_or(ProjectionError::RecordSegmentPhantomRecord(*offset_id))?;\n                         ProjectionRecord {\n                             id: record.id.to_string(),\n                             document: record\n---\n\n\n---\n\nChoice D:\nTiltfile\n@@ -140,6 +140,21 @@ else:\n     target='garbage_collector'\n   )\n \n+if config.tilt_subcommand == \"ci\":\n+  custom_build(\n+    'load-service',\n+    'docker buildx build --load -t $EXPECTED_REF --target load_service -f ./rust/load/Dockerfile .',\n+    ['./rust/', './idl/', './Cargo.toml', './Cargo.lock']\n+  )\n+else:\n+  docker_build(\n+    'load-service',\n+    '.',\n+    only=[\"rust/\", \"idl/\", \"Cargo.toml\", \"Cargo.lock\"],\n+    dockerfile='./rust/load/Dockerfile',\n+    target='load_service'\n+  )\n+\n \n # First install the CRD\n k8s_yaml(\n@@ -169,6 +184,7 @@ k8s_yaml([\n   'k8s/test/grafana.yaml',\n   'k8s/test/jaeger-service.yaml',\n   'k8s/test/jaeger.yaml',\n+  'k8s/test/load-service.yaml',\n   'k8s/test/minio.yaml',\n   'k8s/test/prometheus.yaml',\n   'k8s/test/test-memberlist-cr.yaml',\n@@ -226,6 +242,7 @@ k8s_resource('sysdb', resource_deps=['sysdb-migration-latest'], labels=[\"chroma\"\n k8s_resource('rust-frontend-service', resource_deps=['sysdb', 'logservice', 'rust-log-service'], labels=[\"chroma\"], port_forwards='3000:8000')\n k8s_resource('query-service', resource_deps=['sysdb'], labels=[\"chroma\"], port_forwards='50053:50051')\n k8s_resource('compaction-service', resource_deps=['sysdb'], labels=[\"chroma\"])\n+k8s_resource('load-service', resource_deps=['k8s_setup'], labels=[\"infrastructure\"], port_forwards='3001:3001')\n k8s_resource('jaeger', resource_deps=['k8s_setup'], labels=[\"observability\"])\n k8s_resource('grafana', resource_deps=['k8s_setup'], labels=[\"observability\"])\n k8s_resource('prometheus', resource_deps=['k8s_setup'], labels=[\"observability\"])\n---\nk8s/test/load-service.yaml\n@@ -0,0 +1,81 @@\n+---\n+\n+apiVersion: v1\n+kind: Namespace\n+metadata:\n+  name: chroma-load\n+\n+---\n+\n+apiVersion: apps/v1\n+kind: Deployment\n+metadata:\n+  name: load-service\n+  namespace: chroma-load\n+spec:\n+  replicas: 1\n+  selector:\n+    matchLabels:\n+      app: load-service\n+  template:\n+    metadata:\n+      namespace: chroma-load\n+      labels:\n+        app: load-service\n+    spec:\n+      containers:\n+        - name: load-service\n+          image: load-service\n+          imagePullPolicy: IfNotPresent\n+          ports:\n+            - containerPort: 3001\n+              name: http\n+          env:\n+            - name: CONFIG_PATH\n+              value: /config/config.yaml\n+            - name: RUST_LOG\n+              value: \"info\"\n+          volumeMounts:\n+            - name: load-service-config\n+              mountPath: /config/\n+            - name: load-service-persistent-state\n+              mountPath: /state/\n+      volumes:\n+        - name: load-service-config\n+          configMap:\n+            name: load-service-config\n+        - name: load-service-persistent-state\n+          hostPath:\n+            path: /tmp/chroma/load-service\n+            type: DirectoryOrCreate\n+\n+---\n+\n+apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: load-service-config\n+  namespace: chroma-load\n+data:\n+  config.yaml: |\n+    load_service:\n+      service_name: \"chroma-load\"\n+      otel_endpoint: \"http://otel-collector.chroma:4317\"\n+      port: 3001\n+      persistent_state_path: \"/state/load-service.json\"\n+\n+---\n+\n+apiVersion: v1\n+kind: Service\n+metadata:\n+  name: load-service\n+  namespace: chroma-load\n+spec:\n+  ports:\n+    - name: http\n+      port: 3001\n+      targetPort: 3001\n+  selector:\n+    app: load-service\n+  type: ClusterIP\n---\nrust/load/src/opentelemetry_config.rs\n@@ -57,7 +57,7 @@ pub(crate) fn init_otel_tracing(service_name: &String, otel_endpoint: &String) {\n     // Layer for adding our configured tracer.\n     // Export everything at this layer. The backend i.e. honeycomb or jaeger will filter at its end.\n     let exporter_layer = tracing_opentelemetry::OpenTelemetryLayer::new(tracer)\n-        .with_filter(tracing_subscriber::filter::LevelFilter::ERROR);\n+        .with_filter(tracing_subscriber::filter::LevelFilter::INFO);\n     // Layer for printing spans to stdout. Only print INFO logs by default.\n     let stdout_layer =\n         BunyanFormattingLayer::new(service_name.clone().to_string(), std::io::stdout)\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis exposes the already-existing ability to shove a data set into\nchroma-load.  The `/start` endpoint now takes a json blob xor a data set\nname.  If the `/start` endpoint is given just the name, it resorts to\nthe old behavior so as not to break anything.\n\nIf given a JSON blob, it will interpret that as the data set and try to\nrun it.  Right now the only supported workloads would be to pass a blob\nthat's pre-configured, or to pass a `References` struct serialized to a\ndata set.  The chroma-load-start command has been updated to facilitate\nthis.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n- [X] --help for chroma-load-start has been updated\n\n\n---\n\nChoice A:\nrust/load/src/bin/chroma-load-start.rs\n@@ -1,7 +1,10 @@\n //! Start a workload on the chroma-load server.\n \n+use std::sync::Arc;\n+\n use clap::Parser;\n \n+use chroma_load::data_sets::{all_data_sets, References};\n use chroma_load::rest::StartRequest;\n use chroma_load::{humanize_expires, Connection, Throughput, Workload};\n \n@@ -18,7 +21,13 @@ struct Args {\n     #[arg(long)]\n     workload: String,\n     #[arg(long)]\n-    data_set: String,\n+    data_set: Option<String>,\n+    #[arg(long)]\n+    references_data_set: Option<String>,\n+    #[arg(long)]\n+    operates_on_data_set: Option<String>,\n+    #[arg(long)]\n+    operates_on_cardinality: Option<usize>,\n     #[arg(long)]\n     url: String,\n     #[arg(long)]\n@@ -103,11 +112,47 @@ async fn main() {\n             wrap: Box::new(workload),\n         };\n     }\n+    let (data_set, custom_data_set) = match (\n+        args.data_set,\n+        args.references_data_set,\n+        args.operates_on_data_set,\n+        args.operates_on_cardinality,\n+    ) {\n+        (Some(data_set), None, None, None) => (Some(data_set.clone()), None),\n+        (None, Some(references), Some(operates_on), Some(cardinality)) => {\n+            let Some(referred_to) = all_data_sets()\n+                .iter()\n+                .find(|ds| ds.name() == references)\n+                .map(Arc::clone)\n+            else {\n+                eprintln!(\"Could not find a data set to reference named {references}\");\n+                std::process::exit(13);\n+            };\n+            let to_start = References {\n+                references: referred_to.json(),\n+                operates_on,\n+                cardinality,\n+            };\n+            let to_start = match serde_json::to_value(&to_start) {\n+                Ok(to_start) => to_start,\n+                Err(err) => {\n+                    eprintln!(\"could not serialize referencing data set: {err:?}\");\n+                    std::process::exit(13);\n+                }\n+            };\n+            (None, Some(to_start))\n+        }\n+        _ => {\n+            eprintln!(\"must provide data_set XOR (references_data_set, operates_on_data_set, operates_on_cardinality)\");\n+            std::process::exit(13);\n+        }\n+    };\n     let req = StartRequest {\n         name: args.name,\n         expires: humanize_expires(&args.expires).unwrap_or(args.expires),\n         workload,\n-        data_set: args.data_set,\n+        data_set,\n+        custom_data_set,\n         connection: Connection {\n             url: args.url,\n             api_key,\n---\nrust/load/src/data_sets.rs\n@@ -1496,9 +1496,9 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n \n #[derive(Clone, Debug, Default, serde::Deserialize, serde::Serialize)]\n pub struct References {\n-    references: serde_json::Value,\n-    operates_on: String,\n-    cardinality: usize,\n+    pub references: serde_json::Value,\n+    pub operates_on: String,\n+    pub cardinality: usize,\n }\n \n /// Get a data set from a particular JSON value.\n---\nrust/load/src/lib.rs\n@@ -1190,7 +1190,7 @@ impl LoadService {\n     pub fn start(\n         &self,\n         name: String,\n-        mut workload: Workload,\n+        workload: Workload,\n         data_set: String,\n         connection: Connection,\n         expires: chrono::DateTime<chrono::FixedOffset>,\n@@ -1199,14 +1199,28 @@ impl LoadService {\n         let Some(data_set) = self.data_sets().iter().find(|ds| ds.name() == data_set) else {\n             return Err(Error::NotFound(\"data set not found\".to_string()));\n         };\n+        let data_set = Arc::clone(data_set);\n+        self.start_struct(name, workload, data_set, connection, expires, throughput)\n+    }\n+\n+    /// Start a workload on the load service using structs rather than resolving strings.\n+    pub fn start_struct(\n+        &self,\n+        name: String,\n+        mut workload: Workload,\n+        data_set: Arc<dyn DataSet>,\n+        connection: Connection,\n+        expires: chrono::DateTime<chrono::FixedOffset>,\n+        throughput: Throughput,\n+    ) -> Result<Uuid, Error> {\n         workload.resolve_by_name(self.workloads())?;\n         let res = {\n             // SAFETY(rescrv):  Mutex poisoning.\n             let mut harness = self.harness.lock().unwrap();\n             Ok(harness.start(\n                 name,\n                 workload.clone(),\n-                data_set,\n+                &data_set,\n                 connection,\n                 expires,\n                 throughput,\n@@ -1625,15 +1639,41 @@ async fn start(\n ) -> Result<String, Error> {\n     let expires = chrono::DateTime::parse_from_rfc3339(&req.expires)\n         .map_err(|err| Error::InvalidRequest(format!(\"could not parse rfc3339: {err:?}\")))?;\n-    let uuid = state.load.start(\n-        req.name,\n-        req.workload,\n-        req.data_set,\n-        req.connection,\n-        expires,\n-        req.throughput,\n-    )?;\n-    Ok(uuid.to_string() + \"\\n\")\n+    match (req.data_set, req.custom_data_set) {\n+        (Some(_), Some(_)) => Err(Error::InvalidRequest(\n+            \"provide at most one of data_set and custom_data_set\".to_string(),\n+        )),\n+        (None, None) => Err(Error::InvalidRequest(\n+            \"provide at least one of data_set and custom_data_set\".to_string(),\n+        )),\n+        (Some(data_set), None) => {\n+            let uuid = state.load.start(\n+                req.name,\n+                req.workload,\n+                data_set,\n+                req.connection,\n+                expires,\n+                req.throughput,\n+            )?;\n+            Ok(uuid.to_string() + \"\\n\")\n+        }\n+        (None, Some(custom_data_set)) => {\n+            let Some(data_set) = data_sets::from_json(&custom_data_set) else {\n+                return Err(Error::InvalidRequest(\n+                    \"custom data set returned nothing\".to_string(),\n+                ));\n+            };\n+            let uuid = state.load.start_struct(\n+                req.name,\n+                req.workload,\n+                data_set,\n+                req.connection,\n+                expires,\n+                req.throughput,\n+            )?;\n+            Ok(uuid.to_string() + \"\\n\")\n+        }\n+    }\n }\n \n async fn stop(\n---\nrust/load/src/rest.rs\n@@ -43,8 +43,10 @@ pub struct StartRequest {\n     pub name: String,\n     /// The workload to run.\n     pub workload: Workload,\n-    /// The data set to use.\n-    pub data_set: String,\n+    /// The data set to use, referred to by name.\n+    pub data_set: Option<String>,\n+    /// The custom data set to use.\n+    pub custom_data_set: Option<serde_json::Value>,\n     /// The connection to use.\n     pub connection: Connection,\n     /// When the workload should expire.\n---\n\n\n---\n\nChoice B:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -374,7 +374,7 @@ func (tc *Catalog) createCollectionImpl(txCtx context.Context, createCollection\n \t\treturn nil, false, common.ErrConcurrentDeleteCollection\n \t}\n \tresult := convertCollectionToModel(collectionList)[0]\n-\treturn result, true, nil\n+\treturn result, created, nil\n }\n \n func (tc *Catalog) CreateCollection(ctx context.Context, createCollection *model.CreateCollection, ts types.Timestamp) (*model.Collection, bool, error) {\n@@ -1249,7 +1249,6 @@ func (tc *Catalog) CreateCollectionAndSegments(ctx context.Context, createCollec\n \t\t}\n \n \t\t// If collection already exists, then do not create segments.\n-\t\t// TODO: Should we check to see if segments does not exist? and create them?\n \t\tif !created {\n \t\t\treturn nil\n \t\t}\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -549,6 +549,8 @@ impl ServiceBasedFrontend {\n     pub async fn retryable_fork(\n         &mut self,\n         ForkCollectionRequest {\n+            tenant_id,\n+            database_name,\n             source_collection_id,\n             target_collection_name,\n             ..\n@@ -570,12 +572,25 @@ impl ServiceBasedFrontend {\n             )\n             .await?;\n         let collection = collection_and_segments.collection.clone();\n+        let latest_collection_logical_size_bytes = collection_and_segments\n+            .collection\n+            .size_bytes_post_compaction;\n \n         // Update the cache.\n         self.collections_with_segments_provider\n             .set_collection_with_segments(collection_and_segments)\n             .await;\n \n+        // TODO: Submit event after the response is sent\n+        MeterEvent::CollectionFork {\n+            tenant: tenant_id,\n+            database: database_name,\n+            collection_id: source_collection_id.0,\n+            latest_collection_logical_size_bytes,\n+        }\n+        .submit()\n+        .await;\n+\n         Ok(collection)\n     }\n \n---\nrust/tracing/src/meter_event.rs\n@@ -26,6 +26,12 @@ pub enum WriteAction {\n #[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]\n #[serde(rename_all = \"snake_case\", tag = \"event_name\")]\n pub enum MeterEvent {\n+    CollectionFork {\n+        tenant: String,\n+        database: String,\n+        collection_id: Uuid,\n+        latest_collection_logical_size_bytes: u64,\n+    },\n     CollectionRead {\n         tenant: String,\n         database: String,\n---\n\n\n---\n\nChoice D:\nrust/worker/src/execution/orchestration/compact.rs\n@@ -794,10 +794,14 @@ impl Handler<TaskResult<FetchLogOutput, FetchLogError>> for CompactOrchestrator\n                 tracing::info!(\"Pulled Logs Up To Offset: {:?}\", self.pulled_log_offset);\n             }\n             None => {\n+                tracing::warn!(\"No logs were pulled from the log service, this can happen when the log compaction offset is behing the sysdb.\");\n+                // TODO(hammadb): We can repair the log service's understanding of the offset here, as this only happens\n+                // when the log service is not up to date on the latest compacted offset, which leads it to schedule an already\n+                // compacted collection.\n                 self.terminate_with_result(\n-                    Err(CompactionError::InvariantViolation(\n-                        \"Logs should be present for compaction\",\n-                    )),\n+                    Ok(CompactionResponse {\n+                        collection_id: self.collection_id,\n+                    }),\n                     ctx,\n                 )\n                 .await;\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThis restores the core functionality we were hoping to add in #4534 which is increasing the gRPC payload size. Instead of using the methods from the `grpcutils` package, this just sets the option in the existing setup so that we hopefully don't break whatever voodoo is keeping metrics collection working.\r\n\r\n- Improvements & Bug fixes\r\n  - See #4534\r\n- New functionality\r\n  - See #4534\r\n\r\n## Test plan\r\n\r\nI ran `make test` locally, the build succeeds, but our local tests are broken for some reason. Relying on CI so that I don't have to debug yet another orthogonal issue.\n\n---\n\nChoice A:\ngo/cmd/logservice/main.go\n@@ -25,6 +25,11 @@ import (\n \thealthgrpc \"google.golang.org/grpc/health/grpc_health_v1\"\n )\n \n+// hard-coding this here despite it also being in pkg/grpcutils/service.go because\n+// using the methods from grpcutils results in breaking our metrics collection for\n+// some reason. This service is being deprecated soon, so this is just a quick fix.\n+const maxGrpcFrameSize = 256 * 1024 * 1024\n+\n func main() {\n \tctx := context.Background()\n \n@@ -55,7 +60,10 @@ func main() {\n \tif err != nil {\n \t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n \t}\n-\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n+\ts := grpc.NewServer(\n+\t\tgrpc.MaxRecvMsgSize(maxGrpcFrameSize),\n+\t\tgrpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor),\n+\t)\n \thealthcheck := health.NewServer()\n \thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n---\n\n\n---\n\nChoice B:\nrust/blockstore/src/arrow/provider.rs\n@@ -469,6 +469,15 @@ pub struct RootManager {\n     prefetched_roots: Arc<parking_lot::Mutex<HashMap<Uuid, Duration>>>,\n }\n \n+impl std::fmt::Debug for RootManager {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"RootManager\")\n+            .field(\"cache\", &self.cache)\n+            .field(\"storage\", &self.storage)\n+            .finish()\n+    }\n+}\n+\n impl RootManager {\n     pub fn new(storage: Storage, cache: Box<dyn PersistentCache<Uuid, RootReader>>) -> Self {\n         let cache: Arc<dyn PersistentCache<Uuid, RootReader>> = cache.into();\n---\nrust/garbage_collector/src/operators/list_files_at_version.rs\n@@ -0,0 +1,160 @@\n+use async_trait::async_trait;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n+use chroma_system::{Operator, OperatorType};\n+use chroma_types::{chroma_proto::CollectionVersionFile, CollectionUuid, HNSW_PATH};\n+use std::{collections::HashSet, str::FromStr};\n+use thiserror::Error;\n+use tokio::task::{JoinError, JoinSet};\n+use uuid::Uuid;\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionInput {\n+    root_manager: RootManager,\n+    version_file: CollectionVersionFile,\n+    version: i64,\n+}\n+\n+impl ListFilesAtVersionInput {\n+    pub fn new(\n+        root_manager: RootManager,\n+        version_file: CollectionVersionFile,\n+        version: i64,\n+    ) -> Self {\n+        Self {\n+            root_manager,\n+            version_file,\n+            version,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionOutput {\n+    pub collection_id: CollectionUuid,\n+    pub version: i64,\n+    pub file_paths: HashSet<String>,\n+}\n+\n+#[derive(Debug, Error)]\n+pub enum ListFilesAtVersionError {\n+    #[error(\"Version history field missing\")]\n+    VersionHistoryMissing,\n+    #[error(\"Version {0} not found\")]\n+    VersionNotFound(i64),\n+    #[error(\"Invalid UUID: {0}\")]\n+    InvalidUuid(uuid::Error),\n+    #[error(\"Sparse index fetch task failed: {0}\")]\n+    SparseIndexTaskFailed(JoinError),\n+    #[error(\"Error fetching block IDs for sparse index: {0}\")]\n+    FetchBlockIdsError(#[from] RootManagerError),\n+    #[error(\"Version file missing collection ID\")]\n+    VersionFileMissingCollectionId,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ListFilesAtVersionsOperator {}\n+\n+#[async_trait]\n+impl Operator<ListFilesAtVersionInput, ListFilesAtVersionOutput> for ListFilesAtVersionsOperator {\n+    type Error = ListFilesAtVersionError;\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n+\n+    async fn run(\n+        &self,\n+        input: &ListFilesAtVersionInput,\n+    ) -> Result<ListFilesAtVersionOutput, Self::Error> {\n+        let collection_id = CollectionUuid::from_str(\n+            &input\n+                .version_file\n+                .collection_info_immutable\n+                .as_ref()\n+                .ok_or_else(|| ListFilesAtVersionError::VersionFileMissingCollectionId)?\n+                .collection_id,\n+        )\n+        .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+        let version_history = input\n+            .version_file\n+            .version_history\n+            .as_ref()\n+            .ok_or_else(|| ListFilesAtVersionError::VersionHistoryMissing)?;\n+\n+        let mut file_paths = HashSet::new();\n+        let mut sparse_index_ids = HashSet::new();\n+\n+        let version = version_history\n+            .versions\n+            .iter()\n+            .find(|v| v.version == input.version)\n+            .ok_or_else(|| ListFilesAtVersionError::VersionNotFound(input.version))?;\n+\n+        tracing::debug!(\n+            \"Listing files at version {} for collection {}.\",\n+            version.version,\n+            collection_id,\n+        );\n+        tracing::trace!(\n+            \"Processing version {:#?} for collection {}\",\n+            version,\n+            collection_id\n+        );\n+\n+        if let Some(segment_info) = &version.segment_info {\n+            for segment in &segment_info.segment_compaction_info {\n+                for (file_type, segment_paths) in &segment.file_paths {\n+                    if file_type == \"hnsw_index\" || file_type == HNSW_PATH {\n+                        for path in &segment_paths.paths {\n+                            for hnsw_file in [\n+                                \"header.bin\",\n+                                \"data_level0.bin\",\n+                                \"length.bin\",\n+                                \"link_lists.bin\",\n+                            ] {\n+                                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                                file_paths.insert(format!(\"hnsw/{}/{}\", path, hnsw_file));\n+                            }\n+                        }\n+                    } else {\n+                        // Must be a sparse index\n+                        for path in &segment_paths.paths {\n+                            // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                            file_paths.insert(format!(\"sparse_index/{}\", path));\n+\n+                            let sparse_index_id = Uuid::parse_str(path)\n+                                .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+                            sparse_index_ids.insert(sparse_index_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut block_id_tasks = JoinSet::new();\n+        for sparse_index_id in sparse_index_ids {\n+            let root_manager = input.root_manager.clone();\n+            block_id_tasks\n+                .spawn(async move { root_manager.get_all_block_ids(&sparse_index_id).await });\n+        }\n+\n+        while let Some(res) = block_id_tasks.join_next().await {\n+            let block_ids = res\n+                .map_err(ListFilesAtVersionError::SparseIndexTaskFailed)?\n+                .map_err(ListFilesAtVersionError::FetchBlockIdsError)?;\n+\n+            for block_id in block_ids {\n+                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                file_paths.insert(format!(\"block/{}\", block_id));\n+            }\n+        }\n+\n+        Ok(ListFilesAtVersionOutput {\n+            collection_id,\n+            version: input.version,\n+            file_paths,\n+        })\n+    }\n+}\n---\nrust/garbage_collector/src/operators/mod.rs\n@@ -8,4 +8,5 @@ pub mod fetch_lineage_file;\n pub mod fetch_sparse_index_files;\n pub mod fetch_version_file;\n pub mod get_version_file_paths;\n+pub mod list_files_at_version;\n pub mod mark_versions_at_sysdb;\n---\n\n\n---\n\nChoice C:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.11\"\n+__version__ = \"1.0.12\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.11\"\n+      \"Default\": \"1.0.12\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice D:\nchromadb/test/distributed/test_log_failover.py\n@@ -19,6 +19,9 @@\n     skip_if_not_cluster,\n )\n from chromadb.test.property import invariants\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n+\n+RECORDS = 100\n \n @skip_if_not_cluster()\n def test_log_failover(\n@@ -39,32 +42,106 @@ def test_log_failover(\n     channel = grpc.insecure_channel('localhost:50052')\n     log_service_stub = LogServiceStub(channel)\n \n-    # Add 100 records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n+    # and 1\n+    for i in range(RECORDS, RECORDS + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_compaction(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n     ids = []\n     embeddings = []\n-    for i in range(100):\n+    for i in range(RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n+        if i == RECORDS / 2:\n+            # NOTE(rescrv):  This compaction tests a very particular race when migrating logs.\n+            # Imagine this sequence:\n+            # 1. Write 51 records to the go log.\n+            # 2. Compact all 51 records.\n+            # 3. Write 49 more records to the go log.\n+            # 4. Seal the go log.\n+            # 5. Log migration moves the remaining 49 records to the rust service.\n+            # 6. Cached frontend tries to read from a timestamp that includes all 100 records, using\n+            #    the initial compaction, but from a log that only has 49 records.\n+            # The fix is to make sure the log returns not found when a prefix of the log is\n+            # compacted.  This forces a fallback to repopulate the cache of the sysdb.\n+            wait_for_version_increase(client, collection.name, 0)\n \n     request = SealLogRequest(collection_id=str(collection.id))\n     response = log_service_stub.SealLog(request, timeout=60)\n \n-    # Add another 100 records, where each embedding has 3 dimensions randomly generated between 0\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n     # and 1\n-    for i in range(100, 200):\n+    for i in range(RECORDS, RECORDS + RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n \n-    for i in range(200):\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n         if len(result[\"embeddings\"]) == 0:\n             print(\"missing result\", i)\n-        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n---\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1545,14 +1545,15 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \tif tc.versionFileEnabled {\n \t\treturn tc.FlushCollectionCompactionForVersionedCollection(ctx, flushCollectionCompaction)\n \t}\n+\tcollectionID := types.FromUniqueID(flushCollectionCompaction.ID)\n \n \tflushCollectionInfo := &model.FlushCollectionInfo{\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n \terr := tc.txImpl.Transaction(ctx, func(txCtx context.Context) error {\n \t\t// Check if collection exists.\n-\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(types.FromUniqueID(flushCollectionCompaction.ID), nil, nil)\n+\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(collectionID, nil, nil)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1589,6 +1590,7 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \t\t// return nil will commit the transaction\n \t\treturn nil\n \t})\n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", *collectionID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1641,6 +1643,8 @@ func (tc *Catalog) FlushCollectionCompactionForVersionedCollection(ctx context.C\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", flushCollectionInfo.ID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n+\n \t// Do the operation in a loop until the CollectionEntry is updated,\n \t// \t\tOR FAIL the operation if the version is stale\n \t//      OR other DB error.\n---\nrust/log-service/src/lib.rs\n@@ -1080,6 +1080,9 @@ impl LogService for LogServer {\n                     });\n                 }\n             }\n+            if !records.is_empty() && records[0].log_offset != pull_logs.start_from_offset {\n+                return Err(Status::not_found(\"Some entries have been purged\"));\n+            }\n             tracing::info!(\"pulled {} records\", records.len());\n             Ok(Response::new(PullLogsResponse { records }))\n         }\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - ...\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/frontend/src/quota/mod.rs\n@@ -337,7 +337,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n         m.insert(UsageType::RegexPatternLength, 0);\n-        m.insert(UsageType::NumForks, 10000);\n+        m.insert(UsageType::NumForks, 256);\n         m\n     };\n }\n---\n\n\n---\n\nChoice B:\nk8s/distributed-chroma/values.dev.yaml\n@@ -33,3 +33,6 @@ compactionService:\n       value: 'value: \"1\"'\n     - name: CONFIG_PATH\n       value: 'value: \"/tilt_config.yaml\"'\n+\n+rustLogService:\n+  replicaCount: 2\n---\n\n\n---\n\nChoice C:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.11\"\n+__version__ = \"1.0.12\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.11\"\n+      \"Default\": \"1.0.12\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice D:\nchromadb/api/types.py\n@@ -790,9 +790,10 @@ def validate_where(where: Where) -> None:\n                     \"$eq\",\n                     \"$in\",\n                     \"$nin\",\n+                    \"$distinct\",\n                 ]:\n                     raise ValueError(\n-                        f\"Expected where operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, \"\n+                        f\"Expected where operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, $distinct, \"\n                         f\"got {operator}\"\n                     )\n \n---\nchromadb/base_types.py\n@@ -17,6 +17,7 @@\n     Literal[\"$lte\"],\n     Literal[\"$ne\"],\n     Literal[\"$eq\"],\n+    Literal[\"$distinct\"],\n ]\n InclusionExclusionOperator = Union[Literal[\"$in\"], Literal[\"$nin\"]]\n OperatorExpression = Union[\n---\nrust/segment/src/sqlite_metadata.rs\n@@ -675,6 +675,12 @@ impl IntoSqliteExpr for MetadataExpression {\n                         }\n                         Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n+                    PrimitiveOperator::Distinct => {\n+                        subq.and_where(scol.eq(sval));\n+                        subq.order_by((Embeddings::Table, Embeddings::Id), sea_query::Order::Asc);\n+                        subq.limit(1);\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n+                    }\n                 }\n             }\n             MetadataComparison::Set(op, vals) => {\n---\nrust/segment/src/test.rs\n@@ -541,6 +541,9 @@ impl CheckRecord for MetadataExpression {\n                     PrimitiveOperator::LessThanOrEqual => {\n                         match_type && stored.is_some_and(|v| *v <= metadata_value)\n                     }\n+                    PrimitiveOperator::Distinct => {\n+                        match_type && stored.is_some_and(|v| *v == metadata_value)\n+                    }\n                 }\n             }\n             MetadataComparison::Set(set_operator, metadata_set_value) => {\n---\nrust/types/src/metadata.rs\n@@ -901,6 +901,7 @@ pub enum PrimitiveOperator {\n     GreaterThanOrEqual,\n     LessThan,\n     LessThanOrEqual,\n+    Distinct,\n }\n \n impl From<chroma_proto::GenericComparator> for PrimitiveOperator {\n---\nrust/types/src/where_parsing.rs\n@@ -320,6 +320,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::Equal;\n             } else if operator == \"$ne\" {\n                 operator_type = PrimitiveOperator::NotEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n@@ -338,6 +340,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::Equal;\n             } else if operator == \"$ne\" {\n                 operator_type = PrimitiveOperator::NotEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n@@ -364,6 +368,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::GreaterThan;\n             } else if operator == \"$gte\" {\n                 operator_type = PrimitiveOperator::GreaterThanOrEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n@@ -390,6 +396,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::GreaterThan;\n             } else if operator == \"$gte\" {\n                 operator_type = PrimitiveOperator::GreaterThanOrEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n---\nrust/worker/src/execution/operators/filter.rs\n@@ -80,6 +80,8 @@ pub enum FilterError {\n     RecordReader(#[from] RecordSegmentReaderCreationError),\n     #[error(\"Error parsing regular expression: {0}\")]\n     Regex(#[from] ChromaRegexError),\n+    #[error(\"Distinct filter is not supported\")]\n+    Distinct,\n }\n \n impl ChromaError for FilterError {\n@@ -91,6 +93,7 @@ impl ChromaError for FilterError {\n             FilterError::Record(e) => e.code(),\n             FilterError::RecordReader(e) => e.code(),\n             FilterError::Regex(_) => ErrorCodes::InvalidArgument,\n+            FilterError::Distinct => ErrorCodes::InvalidArgument,\n         }\n     }\n }\n@@ -170,6 +173,7 @@ impl<'me> MetadataLogReader<'me> {\n                 PrimitiveOperator::NotEqual => unreachable!(\n                     \"Inequality filter should be handled above the metadata provider level\"\n                 ),\n+                PrimitiveOperator::Distinct => return Err(FilterError::Distinct),\n             };\n             Ok(metadata_value_to_offset_ids\n                 .range(bounds)\n@@ -334,6 +338,7 @@ impl<'me> MetadataProvider<'me> {\n                         PrimitiveOperator::NotEqual => unreachable!(\n                             \"Inequality filter should be handled above the metadata provider level\"\n                         ),\n+                        PrimitiveOperator::Distinct => return Err(FilterError::Distinct),\n                     }\n                 } else {\n                     Ok(RoaringBitmap::new())\n@@ -391,7 +396,8 @@ impl<'me> RoaringMetadataFilter<'me> for MetadataExpression {\n                     | PrimitiveOperator::GreaterThan\n                     | PrimitiveOperator::GreaterThanOrEqual\n                     | PrimitiveOperator::LessThan\n-                    | PrimitiveOperator::LessThanOrEqual => SignedRoaringBitmap::Include(\n+                    | PrimitiveOperator::LessThanOrEqual\n+                    | PrimitiveOperator::Distinct => SignedRoaringBitmap::Include(\n                         metadata_provider\n                             .filter_by_metadata(&self.key, metadata_value, primitive_operator)\n                             .await?,\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nWe have been frequently seeing image pulls fail when starting Tilt in CI due to rate limiting/network issues. This configures the kind cluster to use blacksmith's provided pull-through image cache which should resolve these issues.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\nI changed the cache mirror port to be incorrect and observed that workflows immediately failed.\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\n.github/actions/tilt/action.yaml\n@@ -6,18 +6,31 @@ runs:\n     - name: Install Tilt\n       shell: bash\n       run: |\n-        TILT_VERSION=\"0.33.3\"\n+        TILT_VERSION=\"0.34.2\"\n         curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v$TILT_VERSION/tilt.$TILT_VERSION.linux.x86_64.tar.gz | \\\n           tar -xzv -C /usr/local/bin tilt\n-    - name: Install ctlptlc\n-      shell: bash\n-      run: |\n-        CTLPTL_VERSION=\"0.8.20\"\n-        curl -fsSL https://github.com/tilt-dev/ctlptl/releases/download/v$CTLPTL_VERSION/ctlptl.$CTLPTL_VERSION.linux.x86_64.tar.gz | \\\n-          tar -xzv -C /usr/local/bin ctlptl\n     - name: Set up kind\n+      id: kind\n+      uses: helm/kind-action@v1\n+      with:\n+        registry: true\n+        registry_name: my-registry\n+        registry_port: 5001\n+        registry_enable_delete: true\n+    - name: Add blacksmith registry mirror\n       shell: bash\n-      run: ctlptl create cluster kind --registry=ctlptl-registry\n+      run: |\n+        REGISTRY_DIR=\"/etc/containerd/certs.d/docker.io\"\n+        for node in $(kind get nodes -n chart-testing); do\n+          docker exec \"${node}\" mkdir -p \"${REGISTRY_DIR}\"\n+          cat <<EOF | docker exec -i \"${node}\" cp /dev/stdin \"${REGISTRY_DIR}/hosts.toml\"\n+        server = \"http://192.168.127.1:5000\"\n+        [host.\"http://192.168.127.1:5000\"]\n+          capabilities = [\"pull\", \"resolve\"]\n+        EOF\n+          echo \"Added registry mirror to ${node}:\"\n+          docker exec \"${node}\" cat \"${REGISTRY_DIR}/hosts.toml\"\n+        done\n     - name: Start Tilt\n       shell: bash\n       run: tilt ci\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/server/server.go\n@@ -54,16 +54,18 @@ func (s *logServer) ScoutLogs(ctx context.Context, req *logservicepb.ScoutLogsRe\n \tif err != nil {\n \t\treturn\n \t}\n+\tvar start int64\n \tvar limit int64\n-\t_, limit, err = s.lr.GetBoundsForCollection(ctx, collectionID.String())\n+\tstart, limit, err = s.lr.GetBoundsForCollection(ctx, collectionID.String())\n \tif err != nil {\n \t\treturn\n \t}\n \t// +1 to convert from the (] bound to a [) bound.\n \tres = &logservicepb.ScoutLogsResponse{\n+\t\tFirstUncompactedRecordOffset: int64(start + 1),\n \t\tFirstUninsertedRecordOffset: int64(limit + 1),\n \t}\n-\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n+\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"start\", int64(start + 1)), zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n \treturn\n }\n \n---\nidl/chromadb/proto/logservice.proto\n@@ -24,6 +24,8 @@ message ScoutLogsResponse {\n   reserved 1;\n   // The next record to insert will have this offset.\n   int64 first_uninserted_record_offset = 2;\n+  // The oldest record on the log will have this offset.\n+  int64 first_uncompacted_record_offset = 3;\n }\n \n message PullLogsRequest {\n---\nrust/log-service/src/lib.rs\n@@ -745,18 +745,24 @@ impl LogService for LogServer {\n                 Arc::clone(&self.storage),\n                 prefix,\n             );\n-            let limit_position = match log_reader.maximum_log_position().await {\n-                Ok(limit_position) => limit_position,\n+            let (start_position, limit_position) = match log_reader.manifest().await {\n+                Ok(Some(manifest)) => (\n+                    manifest.minimum_log_position(),\n+                    manifest.maximum_log_position(),\n+                ),\n+                Ok(None) => (LogPosition::from_offset(0), LogPosition::from_offset(1)),\n                 Err(err) => {\n                     if err.code() == chroma_error::ErrorCodes::FailedPrecondition {\n-                        LogPosition::from_offset(1)\n+                        (LogPosition::from_offset(1), LogPosition::from_offset(1))\n                     } else {\n                         return Err(Status::new(err.code().into(), err.to_string()));\n                     }\n                 }\n             };\n+            let start_offset = start_position.offset() as i64;\n             let limit_offset = limit_position.offset() as i64;\n             Ok(Response::new(ScoutLogsResponse {\n+                first_uncompacted_record_offset: start_offset,\n                 first_uninserted_record_offset: limit_offset,\n             }))\n         }\n---\nrust/wal3/src/manifest.rs\n@@ -276,7 +276,7 @@ impl Snapshot {\n             },\n             (Some(f), None) => f,\n             (None, Some(s)) => s,\n-            (None, None) => LogPosition::default(),\n+            (None, None) => LogPosition::from_offset(1),\n         }\n     }\n \n---\n\n\n---\n\nChoice C:\ngo/cmd/logservice/main.go\n@@ -25,6 +25,11 @@ import (\n \thealthgrpc \"google.golang.org/grpc/health/grpc_health_v1\"\n )\n \n+// hard-coding this here despite it also being in pkg/grpcutils/service.go because\n+// using the methods from grpcutils results in breaking our metrics collection for\n+// some reason. This service is being deprecated soon, so this is just a quick fix.\n+const maxGrpcFrameSize = 256 * 1024 * 1024\n+\n func main() {\n \tctx := context.Background()\n \n@@ -55,7 +60,10 @@ func main() {\n \tif err != nil {\n \t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n \t}\n-\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n+\ts := grpc.NewServer(\n+\t\tgrpc.MaxRecvMsgSize(maxGrpcFrameSize),\n+\t\tgrpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor),\n+\t)\n \thealthcheck := health.NewServer()\n \thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -1219,17 +1219,16 @@ impl LogService for LogServer {\n             let witness = cursors.load(cursor_name).await.map_err(|err| {\n                 Status::new(err.code().into(), format!(\"Failed to load cursor: {}\", err))\n             })?;\n-            // This is the existing compaction_offset, which is the last record that was compacted.\n+            // This is the existing compaction_offset, which is the next record to compact.\n             let offset = witness\n                 .map(|x| x.1.position)\n-                .unwrap_or(LogPosition::from_offset(0));\n+                .unwrap_or(LogPosition::from_offset(1));\n             tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n                 &log_reader,\n-                // + 1 to get to the first uncompacted record.\n-                offset + 1u64,\n+                offset,\n                 target_prefix.clone(),\n             )\n             .await\n@@ -1253,7 +1252,9 @@ impl LogService for LogServer {\n             }\n             tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n-                compaction_offset: offset.offset(),\n+                // NOTE: The upstream service expects the last compacted offset as compaction offset\n+                compaction_offset: (offset - 1u64).offset(),\n+                // NOTE: The upstream service expects the last uncompacted offset as enumeration offset\n                 enumeration_offset: (max_offset - 1u64).offset(),\n             }))\n         }\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nQuestions for review:\n- Should we name this metric differently?\n- How/if should we tag it to differentiate from go?\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.42\n+version: 0.1.43\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/rust-log-service.yaml\n@@ -82,7 +82,7 @@ spec:\n           env:\n             - name: CONFIG_PATH\n               value: \"/config/config.yaml\"\n-            - name: CHROMA_QUERY_SERVICE__MY_MEMBER_ID\n+            - name: CHROMA_LOG_SERVICE__MY_MEMBER_ID\n               valueFrom:\n                 fieldRef:\n                   fieldPath: metadata.name\n---\n\n\n---\n\nChoice B:\nrust/blockstore/src/arrow/provider.rs\n@@ -469,6 +469,15 @@ pub struct RootManager {\n     prefetched_roots: Arc<parking_lot::Mutex<HashMap<Uuid, Duration>>>,\n }\n \n+impl std::fmt::Debug for RootManager {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"RootManager\")\n+            .field(\"cache\", &self.cache)\n+            .field(\"storage\", &self.storage)\n+            .finish()\n+    }\n+}\n+\n impl RootManager {\n     pub fn new(storage: Storage, cache: Box<dyn PersistentCache<Uuid, RootReader>>) -> Self {\n         let cache: Arc<dyn PersistentCache<Uuid, RootReader>> = cache.into();\n---\nrust/garbage_collector/src/operators/list_files_at_version.rs\n@@ -0,0 +1,160 @@\n+use async_trait::async_trait;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n+use chroma_system::{Operator, OperatorType};\n+use chroma_types::{chroma_proto::CollectionVersionFile, CollectionUuid, HNSW_PATH};\n+use std::{collections::HashSet, str::FromStr};\n+use thiserror::Error;\n+use tokio::task::{JoinError, JoinSet};\n+use uuid::Uuid;\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionInput {\n+    root_manager: RootManager,\n+    version_file: CollectionVersionFile,\n+    version: i64,\n+}\n+\n+impl ListFilesAtVersionInput {\n+    pub fn new(\n+        root_manager: RootManager,\n+        version_file: CollectionVersionFile,\n+        version: i64,\n+    ) -> Self {\n+        Self {\n+            root_manager,\n+            version_file,\n+            version,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionOutput {\n+    pub collection_id: CollectionUuid,\n+    pub version: i64,\n+    pub file_paths: HashSet<String>,\n+}\n+\n+#[derive(Debug, Error)]\n+pub enum ListFilesAtVersionError {\n+    #[error(\"Version history field missing\")]\n+    VersionHistoryMissing,\n+    #[error(\"Version {0} not found\")]\n+    VersionNotFound(i64),\n+    #[error(\"Invalid UUID: {0}\")]\n+    InvalidUuid(uuid::Error),\n+    #[error(\"Sparse index fetch task failed: {0}\")]\n+    SparseIndexTaskFailed(JoinError),\n+    #[error(\"Error fetching block IDs for sparse index: {0}\")]\n+    FetchBlockIdsError(#[from] RootManagerError),\n+    #[error(\"Version file missing collection ID\")]\n+    VersionFileMissingCollectionId,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ListFilesAtVersionsOperator {}\n+\n+#[async_trait]\n+impl Operator<ListFilesAtVersionInput, ListFilesAtVersionOutput> for ListFilesAtVersionsOperator {\n+    type Error = ListFilesAtVersionError;\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n+\n+    async fn run(\n+        &self,\n+        input: &ListFilesAtVersionInput,\n+    ) -> Result<ListFilesAtVersionOutput, Self::Error> {\n+        let collection_id = CollectionUuid::from_str(\n+            &input\n+                .version_file\n+                .collection_info_immutable\n+                .as_ref()\n+                .ok_or_else(|| ListFilesAtVersionError::VersionFileMissingCollectionId)?\n+                .collection_id,\n+        )\n+        .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+        let version_history = input\n+            .version_file\n+            .version_history\n+            .as_ref()\n+            .ok_or_else(|| ListFilesAtVersionError::VersionHistoryMissing)?;\n+\n+        let mut file_paths = HashSet::new();\n+        let mut sparse_index_ids = HashSet::new();\n+\n+        let version = version_history\n+            .versions\n+            .iter()\n+            .find(|v| v.version == input.version)\n+            .ok_or_else(|| ListFilesAtVersionError::VersionNotFound(input.version))?;\n+\n+        tracing::debug!(\n+            \"Listing files at version {} for collection {}.\",\n+            version.version,\n+            collection_id,\n+        );\n+        tracing::trace!(\n+            \"Processing version {:#?} for collection {}\",\n+            version,\n+            collection_id\n+        );\n+\n+        if let Some(segment_info) = &version.segment_info {\n+            for segment in &segment_info.segment_compaction_info {\n+                for (file_type, segment_paths) in &segment.file_paths {\n+                    if file_type == \"hnsw_index\" || file_type == HNSW_PATH {\n+                        for path in &segment_paths.paths {\n+                            for hnsw_file in [\n+                                \"header.bin\",\n+                                \"data_level0.bin\",\n+                                \"length.bin\",\n+                                \"link_lists.bin\",\n+                            ] {\n+                                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                                file_paths.insert(format!(\"hnsw/{}/{}\", path, hnsw_file));\n+                            }\n+                        }\n+                    } else {\n+                        // Must be a sparse index\n+                        for path in &segment_paths.paths {\n+                            // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                            file_paths.insert(format!(\"sparse_index/{}\", path));\n+\n+                            let sparse_index_id = Uuid::parse_str(path)\n+                                .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+                            sparse_index_ids.insert(sparse_index_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut block_id_tasks = JoinSet::new();\n+        for sparse_index_id in sparse_index_ids {\n+            let root_manager = input.root_manager.clone();\n+            block_id_tasks\n+                .spawn(async move { root_manager.get_all_block_ids(&sparse_index_id).await });\n+        }\n+\n+        while let Some(res) = block_id_tasks.join_next().await {\n+            let block_ids = res\n+                .map_err(ListFilesAtVersionError::SparseIndexTaskFailed)?\n+                .map_err(ListFilesAtVersionError::FetchBlockIdsError)?;\n+\n+            for block_id in block_ids {\n+                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                file_paths.insert(format!(\"block/{}\", block_id));\n+            }\n+        }\n+\n+        Ok(ListFilesAtVersionOutput {\n+            collection_id,\n+            version: input.version,\n+            file_paths,\n+        })\n+    }\n+}\n---\nrust/garbage_collector/src/operators/mod.rs\n@@ -8,4 +8,5 @@ pub mod fetch_lineage_file;\n pub mod fetch_sparse_index_files;\n pub mod fetch_version_file;\n pub mod get_version_file_paths;\n+pub mod list_files_at_version;\n pub mod mark_versions_at_sysdb;\n---\n\n\n---\n\nChoice C:\nrust/garbage_collector/src/operators/compute_unused_files.rs\n@@ -1,5 +1,5 @@\n use async_trait::async_trait;\n-use chroma_blockstore::RootManager;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n use chroma_cache::nop::NopCache;\n use chroma_error::{ChromaError, ErrorCodes};\n use chroma_storage::Storage;\n@@ -145,14 +145,14 @@ impl ComputeUnusedFilesOperator {\n         for si_id in si_ids {\n             let uuid = Uuid::parse_str(&si_id).map_err(|e| {\n                 tracing::error!(error = %e, \"Failed to parse UUID\");\n-                ComputeUnusedFilesError::ParseError(si_id.clone(), e.to_string())\n+                ComputeUnusedFilesError::InvalidUuid(e, si_id.clone())\n             })?;\n \n             let block_ids = match self.root_manager.get_all_block_ids(&uuid).await {\n                 Ok(ids) => ids,\n                 Err(e) => {\n                     tracing::error!(error = %e, \"Failed to get block IDs\");\n-                    return Err(ComputeUnusedFilesError::ParseError(si_id, e.to_string()));\n+                    return Err(ComputeUnusedFilesError::FailedToFetchBlockIDs(e));\n                 }\n             };\n             tracing::debug!(\n@@ -193,8 +193,10 @@ pub struct ComputeUnusedFilesOutput {\n \n #[derive(Error, Debug)]\n pub enum ComputeUnusedFilesError {\n-    #[error(\"Error parsing sparse index file: {0}\")]\n-    ParseError(String, String),\n+    #[error(\"Error parsing UUID: {0} from {1}\")]\n+    InvalidUuid(uuid::Error, String),\n+    #[error(\"Failed to fetch block IDs: {0}\")]\n+    FailedToFetchBlockIDs(RootManagerError),\n     #[error(\"Version file has missing content\")]\n     VersionFileMissingContent(i64),\n     #[error(\"Version history is missing\")]\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -22,6 +22,7 @@ use chroma_types::chroma_proto::{\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n use figment::providers::{Env, Format, Yaml};\n+use opentelemetry::metrics::Meter;\n use parquet::arrow::arrow_reader::ParquetRecordBatchReaderBuilder;\n use prost::Message;\n use serde::{Deserialize, Serialize};\n@@ -48,6 +49,22 @@ const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n static STABLE_PREFIX: CursorName = unsafe { CursorName::from_string_unchecked(\"stable_prefix\") };\n static COMPACTION: CursorName = unsafe { CursorName::from_string_unchecked(\"compaction\") };\n \n+////////////////////////////////////////////// Metrics /////////////////////////////////////////////\n+\n+pub struct Metrics {\n+    log_total_uncompacted_records_count: opentelemetry::metrics::Gauge<f64>,\n+}\n+\n+impl Metrics {\n+    pub fn new(meter: Meter) -> Self {\n+        Self {\n+            log_total_uncompacted_records_count: meter\n+                .f64_gauge(\"log_total_uncompacted_records_count\")\n+                .build(),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////// state maintenance ////////////////////////////////////////\n \n // NOTE(rescrv):  This code dynamically opens and closes logs.  An opened log will stay open until\n@@ -334,6 +351,7 @@ impl DirtyMarker {\n \n     /// Given a contiguous prefix of markers, process the log into a rollup.  That is, a set of\n     /// markers to reinsert, a set of collections to compact, and an advance_to log position.\n+    #[allow(clippy::too_many_arguments)]\n     pub async fn rollup<\n         F1: Future<Output = Result<Option<Manifest>, wal3::Error>>,\n         F2: Future<Output = Result<Option<Witness>, wal3::Error>>,\n@@ -345,6 +363,7 @@ impl DirtyMarker {\n         record_count_threshold: u64,\n         reinsert_threshold: u64,\n         timeout_us: u64,\n+        metrics: &Metrics,\n     ) -> Result<Option<Rollup>, wal3::Error> {\n         // NOTE(rescrv);  This is complicated code because it's a hard problem to do efficiently.\n         // To cut complexity, I've chosen to do it in a way that is not the most efficient but is\n@@ -434,6 +453,7 @@ impl DirtyMarker {\n             .into_iter()\n             .flat_map(Result::ok)\n             .collect::<HashMap<_, _>>();\n+        let mut uncompacted = 0u64;\n         let compactable = compactable\n             .into_iter()\n             .filter_map(|collection_id| {\n@@ -473,6 +493,7 @@ impl DirtyMarker {\n                             cursor.position,\n                             manifest.maximum_log_position(),\n                         );\n+                        uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_threshold {\n                             Some(CollectionInfo {\n                                 collection_id: collection_id.to_string(),\n@@ -514,6 +535,9 @@ impl DirtyMarker {\n                 }\n             }\n         }\n+        metrics\n+            .log_total_uncompacted_records_count\n+            .record(uncompacted as f64, &[]);\n         Ok(Some(Rollup {\n             advance_to,\n             reinsert,\n@@ -608,6 +632,7 @@ pub struct LogServer {\n     dirty_log: Arc<LogWriter>,\n     compacting: tokio::sync::Mutex<()>,\n     cache: Option<Box<dyn chroma_cache::PersistentCache<String, CachedParquetFragment>>>,\n+    metrics: Metrics,\n }\n \n #[async_trait::async_trait]\n@@ -977,6 +1002,7 @@ impl LogService for LogServer {\n             ),\n             self.config.reinsert_threshold,\n             self.config.timeout_us,\n+            &self.metrics,\n         )\n         .await\n         .map_err(|err| Status::unavailable(err.to_string()))?;\n@@ -1456,13 +1482,15 @@ impl Configurable<LogServerConfig> for LogServer {\n         .map_err(|err| -> Box<dyn ChromaError> { Box::new(err) as _ })?;\n         let dirty_log = Arc::new(dirty_log);\n         let compacting = tokio::sync::Mutex::new(());\n+        let metrics = Metrics::new(opentelemetry::global::meter(\"chroma\"));\n         Ok(Self {\n             config: config.clone(),\n             open_logs: Arc::new(StateHashTable::default()),\n             storage,\n             dirty_log,\n             compacting,\n             cache,\n+            metrics,\n         })\n     }\n }\n@@ -1565,6 +1593,7 @@ mod tests {\n             1,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1626,6 +1655,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1709,6 +1739,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1822,6 +1853,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis reverts commit 3028a39384589393489ac7ece9dedf38a0eea663.\r\n\r\nAfter we deployed this commit, we lost metrics for log-service, so we suspect it has something to do with it. I will re-enable the payload size fix one way or the other, but want to get back to working observability for the time being.\n\n---\n\nChoice A:\ngo/cmd/logservice/main.go\n@@ -2,8 +2,8 @@ package main\n \n import (\n \t\"context\"\n+\t\"net\"\n \n-\t\"github.com/chroma-core/chroma/go/pkg/grpcutils\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/configuration\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/leader\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/metrics\"\n@@ -15,6 +15,7 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/utils\"\n \tlibs \"github.com/chroma-core/chroma/go/shared/libs\"\n \t\"github.com/chroma-core/chroma/go/shared/otel\"\n+\tsharedOtel \"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"github.com/pingcap/log\"\n \t\"github.com/rs/zerolog\"\n \t\"go.uber.org/automaxprocs/maxprocs\"\n@@ -49,21 +50,22 @@ func main() {\n \tsysDb := sysdb.NewSysDB(config.SYSDB_CONN)\n \tlr := repository.NewLogRepository(conn, sysDb)\n \tserver := server.NewLogServer(lr)\n-\n-\t_, err = grpcutils.Default.StartGrpcServer(\"log-service\", &grpcutils.GrpcConfig{\n-\t\tBindAddress: \":\" + config.PORT,\n-\t}, func(registrar grpc.ServiceRegistrar) {\n-\t\thealthcheck := health.NewServer()\n-\t\thealthgrpc.RegisterHealthServer(registrar, healthcheck)\n-\t\tlogservicepb.RegisterLogServiceServer(registrar, server)\n-\t})\n+\tvar listener net.Listener\n+\tlistener, err = net.Listen(\"tcp\", \":\"+config.PORT)\n \tif err != nil {\n-\t\tlog.Fatal(\"failed to create grpc server\", zap.Error(err))\n+\t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n \t}\n+\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n+\thealthcheck := health.NewServer()\n+\thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n-\tlog.Info(\"log service started\")\n+\tlogservicepb.RegisterLogServiceServer(s, server)\n+\tlog.Info(\"log service started\", zap.String(\"address\", listener.Addr().String()))\n \tgo leader.AcquireLeaderLock(ctx, func(ctx context.Context) {\n \t\tgo purging.PerformPurgingLoop(ctx, lr)\n \t\tgo metrics.PerformMetricsLoop(ctx, lr)\n \t})\n+\tif err := s.Serve(listener); err != nil {\n+\t\tlog.Fatal(\"failed to serve\", zap.Error(err))\n+\t}\n }\n---\ngo/pkg/grpcutils/service.go\n@@ -4,12 +4,11 @@ import (\n \t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n+\t\"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"io\"\n \t\"net\"\n \t\"os\"\n \n-\t\"github.com/chroma-core/chroma/go/shared/otel\"\n-\n \t\"github.com/pingcap/log\"\n \t\"go.uber.org/zap\"\n \t\"google.golang.org/grpc\"\n@@ -83,7 +82,7 @@ func newDefaultGrpcProvider(name string, grpcConfig *GrpcConfig, registerFunc fu\n \tOPTL_TRACING_ENDPOINT := os.Getenv(\"OPTL_TRACING_ENDPOINT\")\n \tif OPTL_TRACING_ENDPOINT != \"\" {\n \t\totel.InitTracing(context.Background(), &otel.TracingConfig{\n-\t\t\tService:  name,\n+\t\t\tService:  \"sysdb-service\",\n \t\t\tEndpoint: OPTL_TRACING_ENDPOINT,\n \t\t})\n \t}\n---\ngo/pkg/sysdb/grpc/server.go\n@@ -158,7 +158,7 @@ func NewWithGrpcProvider(config Config, provider grpcutils.GrpcProvider) (*Serve\n \t\ts.softDeleteCleaner.Start()\n \n \t\tlog.Info(\"Starting GRPC server\")\n-\t\ts.grpcServer, err = provider.StartGrpcServer(\"sysdb-service\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n+\t\ts.grpcServer, err = provider.StartGrpcServer(\"coordinator\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n \t\t\tcoordinatorpb.RegisterSysDBServer(registrar, s)\n \t\t\thealthgrpc.RegisterHealthServer(registrar, s.healthServer)\n \t\t})\n---\n\n\n---\n\nChoice B:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionWithoutMetadata(collectionID *string, databaseName *string, softDeletedFlag *bool) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, NULLIF(collections.root_collection_id, '') AS root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\nChoice C:\nrust/types/src/api_types.rs\n@@ -82,7 +82,7 @@ impl ChromaError for GetCollectionWithSegmentsError {\n             GetCollectionWithSegmentsError::CollectionConversionError(\n                 collection_conversion_error,\n             ) => collection_conversion_error.code(),\n-            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::Internal,\n             GetCollectionWithSegmentsError::Field(_) => ErrorCodes::FailedPrecondition,\n             GetCollectionWithSegmentsError::SegmentConversionError(segment_conversion_error) => {\n                 segment_conversion_error.code()\n@@ -832,7 +832,7 @@ impl ChromaError for ForkCollectionError {\n             ForkCollectionError::CollectionConversionError(collection_conversion_error) => {\n                 collection_conversion_error.code()\n             }\n-            ForkCollectionError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            ForkCollectionError::DuplicateSegment => ErrorCodes::Internal,\n             ForkCollectionError::Field(_) => ErrorCodes::FailedPrecondition,\n             ForkCollectionError::Local => ErrorCodes::Unimplemented,\n             ForkCollectionError::Internal(chroma_error) => chroma_error.code(),\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -398,9 +398,10 @@ impl DirtyMarker {\n             let num_records = rollup_pc.limit_log_position - rollup_pc.start_log_position;\n             let reinsert_count = rollup_pc.reinsert_count;\n             let initial_insertion_epoch_us = rollup_pc.initial_insertion_epoch_us;\n-            let to_compact = num_records >= record_count_threshold\n+            let to_compact = true/*\n+                || num_records >= record_count_threshold\n                 || now_us - initial_insertion_epoch_us >= timeout_us\n-                || reinsert_count >= reinsert_threshold;\n+                || reinsert_count >= reinsert_threshold*/;\n             if to_compact {\n                 compactable.push(collection_id);\n             }\n@@ -2063,6 +2064,7 @@ mod tests {\n                 },\n             ),\n         ];\n+        /*\n         assert!(DirtyMarker::rollup(\n             Arc::new(storage),\n             |storage, collection_id| async move {\n@@ -2084,6 +2086,7 @@ mod tests {\n         .await\n         .unwrap()\n         .is_none());\n+        */\n     }\n \n     #[tokio::test]\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThe Default EF in javascript incorrectly sets the config name to model_name, when the schema requires model. This PR fixes that.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nchromadb/test/property/test_fork.py\n@@ -189,3 +189,31 @@ def verify(\n def test_fork(caplog: pytest.LogCaptureFixture, client: chromadb.api.ClientAPI) -> None:\n     caplog.set_level(logging.ERROR)\n     run_state_machine_as_test(lambda: ForkStateMachine(client))  # type: ignore\n+\n+\n+@skip_if_not_cluster()\n+def test_fork_with_log_migration(\n+    caplog: pytest.LogCaptureFixture, client: chromadb.api.ClientAPI\n+) -> None:\n+    import grpc\n+    from chromadb.proto.logservice_pb2 import SealLogRequest\n+    from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n+    caplog.set_level(logging.ERROR)\n+    client.reset()\n+    channel = grpc.insecure_channel(\"localhost:50052\")\n+    go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n+    collection = client.create_collection(\"legacy-go-collection-0\")\n+    ids = [f\"id_{i}\" for i in range(6)]\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n+    fork_collection = collection.fork(\"fork-legacy-go-collection-0\")\n+    assert sorted(fork_collection.get()[\"ids\"]) == ids\n+\n+    collection = client.create_collection(\"legacy-go-collection-1\")\n+    go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n+    ids = [f\"id_{i}\" for i in range(6)]\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    fork_collection = collection.fork(\"fork-legacy-go-collection-1\")\n+    assert sorted(fork_collection.get()[\"ids\"]) == ids\n---\n\n\n---\n\nChoice B:\nrust/wal3/tests/test_k8s_integration_99_ping_pong_contention.rs\n@@ -115,9 +115,9 @@ async fn test_k8s_integration_ping_pong_contention() {\n         .unwrap(),\n     );\n \n-    // Set a timer to make sure the test only runs for 2 minutes.\n+    // Set a timer to make sure the test only runs for 3 minutes.\n     let fail = tokio::spawn(async move {\n-        tokio::time::sleep(Duration::from_secs(120)).await;\n+        tokio::time::sleep(Duration::from_secs(180)).await;\n         eprintln!(\"Taking down the test\");\n         std::process::exit(13);\n     });\n@@ -130,15 +130,15 @@ async fn test_k8s_integration_ping_pong_contention() {\n         Arc::clone(&mutex),\n         Arc::clone(&running),\n         1,\n-        30,\n+        20,\n     ));\n \n     let handle2 = tokio::spawn(writer_thread(\n         Arc::clone(&writer2),\n         Arc::clone(&mutex),\n         Arc::clone(&running),\n         2,\n-        30,\n+        20,\n     ));\n \n     // Wait for both threads to complete\n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb-core/src/embeddings/DefaultEmbeddingFunction.ts\n@@ -6,7 +6,7 @@ import { IEmbeddingFunction } from \"./IEmbeddingFunction\";\n let TransformersApi: Promise<any>;\n \n interface StoredConfig {\n-  model_name: string;\n+  model: string;\n   revision: string;\n   quantized: boolean;\n }\n@@ -77,24 +77,24 @@ export class DefaultEmbeddingFunction implements IEmbeddingFunction {\n \n   getConfig(): StoredConfig {\n     return {\n-      model_name: this.model,\n+      model: this.model,\n       revision: this.revision,\n       quantized: this.quantized,\n     };\n   }\n \n   buildFromConfig(config: StoredConfig): DefaultEmbeddingFunction {\n     return new DefaultEmbeddingFunction({\n-      model: config.model_name,\n+      model: config.model,\n       revision: config.revision,\n       quantized: config.quantized,\n     });\n   }\n \n   validateConfigUpdate(oldConfig: StoredConfig, newConfig: StoredConfig): void {\n-    if (oldConfig.model_name !== newConfig.model_name) {\n+    if (oldConfig.model !== newConfig.model) {\n       throw new Error(\n-        \"DefaultEmbeddingFunction model_name cannot be changed after initialization.\",\n+        \"DefaultEmbeddingFunction model cannot be changed after initialization.\",\n       );\n     }\n   }\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.3\",\n+  \"version\": \"2.4.4\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\nChoice D:\nrust/log/src/grpc_log.rs\n@@ -554,6 +554,7 @@ impl GrpcLog {\n         min_compaction_size: u64,\n     ) -> Result<Vec<CollectionInfo>, GrpcGetCollectionsWithNewDataError> {\n         let mut combined_response = Vec::new();\n+        let mut error = None;\n \n         if use_alt_log {\n             // Iterate over all alt clients and gather collections\n@@ -567,14 +568,25 @@ impl GrpcLog {\n                 }\n                 for mut alt_client in all_alt_clients.drain(..) {\n                     // We error if any subrequest errors\n-                    let response = alt_client\n+                    match alt_client\n                         .get_all_collection_info_to_compact(\n                             chroma_proto::GetAllCollectionInfoToCompactRequest {\n                                 min_compaction_size,\n                             },\n                         )\n-                        .await?;\n-                    combined_response.push(response.into_inner());\n+                        .await\n+                    {\n+                        Ok(response) => {\n+                            combined_response.push(response.into_inner());\n+                        }\n+                        Err(err) => {\n+                            tracing::error!(\"could not get all collection info to compact: {err}\");\n+                            if error.is_none() {\n+                                error = Some(err);\n+                            }\n+                            continue;\n+                        }\n+                    };\n                 }\n             } else {\n                 tracing::warn!(\n@@ -583,17 +595,33 @@ impl GrpcLog {\n                 return Ok(vec![]);\n             }\n         } else {\n-            let response = self\n+            match self\n                 .client\n                 .get_all_collection_info_to_compact(\n                     chroma_proto::GetAllCollectionInfoToCompactRequest {\n                         min_compaction_size,\n                     },\n                 )\n-                .await?;\n-            combined_response.push(response.into_inner());\n+                .await\n+            {\n+                Ok(response) => {\n+                    combined_response.push(response.into_inner());\n+                }\n+                Err(err) => {\n+                    tracing::error!(\"could not get all collection info to compact: {err}\");\n+                    if error.is_none() {\n+                        error = Some(err);\n+                    }\n+                }\n+            };\n         };\n \n+        if let Some(status) = error {\n+            if combined_response.is_empty() {\n+                return Err(status.into());\n+            }\n+        }\n+\n         let mut all_collections = Vec::new();\n         for response in combined_response {\n             let collections = response.all_collection_info;\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nAdds a helper to turn an orchestrator into an operator. This makes it possible to represent complex orchestrator flows (e.x. waiting for fan-out tasks) in a more straightforward and simple way.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\nAdded a test.\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.38\n+version: 0.1.39\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/values.yaml\n@@ -51,6 +51,9 @@ rustLogService:\n   image:\n     repository: 'rust-log-service'\n     tag: 'latest'\n+  cache:\n+    hostPath: '/local/cache/chroma-log-service'\n+    mountPath: '/cache/'\n \n queryService:\n   image:\n---\n\n\n---\n\nChoice B:\nrust/worker/src/execution/operators/filter.rs\n@@ -498,6 +498,11 @@ impl Operator<FilterInput, FilterOutput> for FilterOperator {\n     async fn run(&self, input: &FilterInput) -> Result<FilterOutput, FilterError> {\n         tracing::debug!(\"[{}]: {:?}\", self.get_name(), input);\n \n+        // NOTE: This is temporary traces to capture filter arguments\n+        //       We suspect certain filters break the FTS algorithm\n+        // TODO: Remove this after the bug is found\n+        tracing::debug!(\"[DEBUG FILTER OPERATOR]: {:?}\", self);\n+\n         let record_segment_reader = match RecordSegmentReader::from_segment(\n             &input.record_segment,\n             &input.blockfile_provider,\n---\nrust/worker/src/execution/operators/projection.rs\n@@ -71,6 +71,8 @@ pub enum ProjectionError {\n     RecordSegment(#[from] Box<dyn ChromaError>),\n     #[error(\"Error reading unitialized record segment\")]\n     RecordSegmentUninitialized,\n+    #[error(\"Error reading phantom record: {0}\")]\n+    RecordSegmentPhantomRecord(u32),\n }\n \n impl ChromaError for ProjectionError {\n@@ -80,6 +82,7 @@ impl ChromaError for ProjectionError {\n             ProjectionError::RecordReader(e) => e.code(),\n             ProjectionError::RecordSegment(e) => e.code(),\n             ProjectionError::RecordSegmentUninitialized => ErrorCodes::Internal,\n+            ProjectionError::RecordSegmentPhantomRecord(_) => ErrorCodes::Internal,\n         }\n     }\n }\n@@ -153,7 +156,7 @@ impl Operator<ProjectionInput, ProjectionOutput> for ProjectionOperator {\n                         let record = reader\n                             .get_data_for_offset_id(*offset_id)\n                             .await?\n-                            .ok_or(ProjectionError::RecordSegmentUninitialized)?;\n+                            .ok_or(ProjectionError::RecordSegmentPhantomRecord(*offset_id))?;\n                         ProjectionRecord {\n                             id: record.id.to_string(),\n                             document: record\n---\n\n\n---\n\nChoice C:\nrust/system/src/execution/orchestrator.rs\n@@ -1,12 +1,54 @@\n+use super::Operator;\n use crate::{ChannelError, Component, ComponentContext, ComponentHandle, PanicError, System};\n+use crate::{Dispatcher, TaskMessage};\n use async_trait::async_trait;\n use chroma_error::ChromaError;\n use core::fmt::Debug;\n+use parking_lot::Mutex;\n use std::any::type_name;\n+use thiserror::Error;\n use tokio::sync::oneshot::{self, error::RecvError, Sender};\n+use tracing::Instrument;\n use tracing::Span;\n \n-use crate::{Dispatcher, TaskMessage};\n+#[derive(Debug)]\n+struct WrappedOrchestratorOperator<O: Orchestrator>(Mutex<Option<O>>, System, Span);\n+\n+#[derive(Debug, Error)]\n+#[error(\"Orchestrator was already consumed\")]\n+pub struct WrappedOrchestratorOperatorError {}\n+\n+#[async_trait]\n+impl<O: Orchestrator> Operator<(), O::Output> for WrappedOrchestratorOperator<O>\n+where\n+    O: Sync,\n+    O::Output: Sync,\n+    O::Error: From<WrappedOrchestratorOperatorError>,\n+{\n+    type Error = O::Error;\n+\n+    fn get_type(&self) -> crate::OperatorType {\n+        crate::OperatorType::IO\n+    }\n+\n+    fn get_name(&self) -> &'static str {\n+        O::name()\n+    }\n+\n+    async fn run(&self, _: &()) -> Result<O::Output, Self::Error> {\n+        let orchestrator = {\n+            let mut orchestrator = self.0.lock();\n+            orchestrator\n+                .take()\n+                .ok_or(WrappedOrchestratorOperatorError {})?\n+        };\n+\n+        orchestrator\n+            .run(self.1.clone())\n+            .instrument(self.2.clone())\n+            .await\n+    }\n+}\n \n #[async_trait]\n pub trait Orchestrator: Debug + Send + Sized + 'static {\n@@ -115,6 +157,19 @@ pub trait Orchestrator: Debug + Send + Sized + 'static {\n             }\n         }\n     }\n+\n+    fn to_operator(self, system: System) -> Box<dyn Operator<(), Self::Output, Error = Self::Error>>\n+    where\n+        Self: Sync,\n+        <Self as Orchestrator>::Output: Sync,\n+        <Self as Orchestrator>::Error: From<WrappedOrchestratorOperatorError>,\n+    {\n+        Box::new(WrappedOrchestratorOperator(\n+            Mutex::new(Some(self)),\n+            system,\n+            Span::current(),\n+        ))\n+    }\n }\n \n #[async_trait]\n@@ -144,3 +199,128 @@ impl<O: Orchestrator> Component for O {\n         };\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::wrap;\n+    use crate::ChannelError;\n+    use crate::ComponentContext;\n+    use crate::Handler;\n+    use crate::System;\n+    use crate::TaskResult;\n+    use async_trait::async_trait;\n+    use thiserror::Error;\n+\n+    #[derive(Debug, Error)]\n+    enum TestOrchestratorError {\n+        #[error(\"Receive error: {0}\")]\n+        Receive(#[from] RecvError),\n+        #[error(\"Channel error: {0}\")]\n+        Channel(#[from] ChannelError),\n+        #[error(\"Panic error: {0}\")]\n+        Panic(#[from] PanicError),\n+        #[error(\"Wrapped orchestrator error: {0}\")]\n+        OrchestratorWrapper(#[from] WrappedOrchestratorOperatorError),\n+    }\n+    impl ChromaError for TestOrchestratorError {\n+        fn code(&self) -> chroma_error::ErrorCodes {\n+            chroma_error::ErrorCodes::Internal\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    struct TestOrchestrator {\n+        result_channel: Option<Sender<Result<usize, TestOrchestratorError>>>,\n+        dispatcher: ComponentHandle<Dispatcher>,\n+        system: System,\n+        spawn_self: bool,\n+    }\n+\n+    impl TestOrchestrator {\n+        fn new(dispatcher: ComponentHandle<Dispatcher>, system: System, spawn_self: bool) -> Self {\n+            Self {\n+                result_channel: None,\n+                dispatcher,\n+                system,\n+                spawn_self,\n+            }\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    struct TestMessageRequest;\n+\n+    #[async_trait]\n+    impl Orchestrator for TestOrchestrator {\n+        type Output = usize;\n+        type Error = TestOrchestratorError;\n+\n+        fn dispatcher(&self) -> ComponentHandle<Dispatcher> {\n+            self.dispatcher.clone()\n+        }\n+        async fn initial_tasks(&mut self, ctx: &ComponentContext<Self>) -> Vec<TaskMessage> {\n+            if self.spawn_self {\n+                let task = wrap(\n+                    TestOrchestrator::new(self.dispatcher.clone(), self.system.clone(), false)\n+                        .to_operator(self.system.clone()),\n+                    (),\n+                    ctx.receiver(),\n+                );\n+\n+                return vec![task];\n+            }\n+\n+            ctx.receiver()\n+                .send(TestMessageRequest {}, None)\n+                .await\n+                .unwrap();\n+\n+            vec![]\n+        }\n+        fn set_result_channel(&mut self, sender: Sender<Result<Self::Output, Self::Error>>) {\n+            self.result_channel = Some(sender);\n+        }\n+        fn take_result_channel(&mut self) -> Sender<Result<Self::Output, Self::Error>> {\n+            self.result_channel.take().unwrap()\n+        }\n+    }\n+\n+    #[async_trait]\n+    impl Handler<TestMessageRequest> for TestOrchestrator {\n+        type Result = ();\n+\n+        async fn handle(\n+            &mut self,\n+            _: TestMessageRequest,\n+            ctx: &ComponentContext<TestOrchestrator>,\n+        ) {\n+            self.default_terminate_with_result(Ok(42), ctx).await;\n+        }\n+    }\n+\n+    #[async_trait]\n+    impl Handler<TaskResult<usize, TestOrchestratorError>> for TestOrchestrator {\n+        type Result = ();\n+\n+        async fn handle(\n+            &mut self,\n+            result: TaskResult<usize, TestOrchestratorError>,\n+            ctx: &ComponentContext<TestOrchestrator>,\n+        ) {\n+            self.default_terminate_with_result(Ok(result.into_inner().unwrap()), ctx)\n+                .await;\n+        }\n+    }\n+\n+    #[tokio::test]\n+    async fn test_wrapped_orchestrator() {\n+        let system = System::new();\n+        let dispatcher = Dispatcher::new(Default::default());\n+        let dispatcher_handle = system.start_component(dispatcher);\n+        let orchestrator = TestOrchestrator::new(dispatcher_handle, system.clone(), true);\n+\n+        let result = orchestrator.run(system).await.unwrap();\n+        assert_eq!(result, 42);\n+    }\n+}\n---\n\n\n---\n\nChoice D:\nDockerfile\n@@ -69,4 +69,3 @@ EXPOSE 8000\n \n ENTRYPOINT [\"/docker_entrypoint.sh\"]\n CMD [ \"--workers ${CHROMA_WORKERS} --host ${CHROMA_HOST_ADDR} --port ${CHROMA_HOST_PORT} --proxy-headers --reload --log-config ${CHROMA_LOG_CONFIG} --timeout-keep-alive ${CHROMA_TIMEOUT_KEEP_ALIVE}\"]\n-\n---\nDockerfile.windows\n@@ -1,14 +1,15 @@\n FROM python:3.11.9\n ARG REBUILD_HNSWLIB\n-\n SHELL [\"powershell\", \"-Command\", \"$ErrorActionPreference = 'Stop'; $ProgressPreference = 'SilentlyContinue';\"]\n RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; `Invoke-WebRequest \"https://aka.ms/vs/17/release/vc_redist.x64.exe\" -OutFile \"vc_redist.x64.exe\"; `Start-Process -filepath C:\\vc_redist.x64.exe -ArgumentList \"/install\", \"/passive\", \"/norestart\" -Passthru | Wait-Process; `Remove-Item -Force vc_redist.x64.exe;\n \n WORKDIR C:\\\\chroma\n \n COPY ./requirements.txt requirements.txt\n+COPY ./requirements_dev.txt requirements_dev.txt\n \n RUN pip install --no-cache-dir --upgrade -r requirements.txt\n+RUN pip install --no-cache-dir --upgrade -r requirements_dev.txt\n RUN if ($env:REBUILD_HNSWLIB -eq 'true') { pip install --no-binary :all: --force-reinstall --no-cache-dir chroma-hnswlib }\n \n COPY ./bin/docker_entrypoint.ps1 C:\\\\docker_entrypoint.ps1\n@@ -19,7 +20,6 @@ ENV CHROMA_HOST_PORT 8000\n ENV CHROMA_WORKERS 1\n ENV CHROMA_LOG_CONFIG \"chromadb/log_config.yml\"\n ENV CHROMA_TIMEOUT_KEEP_ALIVE 30\n-\n EXPOSE 8000\n \n ENTRYPOINT [\"powershell\", \"C:\\\\\\\\docker_entrypoint.ps1\"]\n---\nchromadb/test/utils/cross_version.py\n@@ -55,7 +55,10 @@ def install(pkg: str, path: str, dep_overrides: Dict[str, str]) -> int:\n     for dep, operator_version in dep_overrides.items():\n         command.append(f\"{dep}{operator_version}\")\n \n-    command.append(\"--no-binary=chroma-hnswlib\")\n+    # Only add --no-binary=chroma-hnswlib if it's in the dependencies\n+    if \"chroma-hnswlib\" in pkg or any(\"chroma-hnswlib\" in dep for dep in dep_overrides):\n+        command.append(\"--no-binary=chroma-hnswlib\")\n+\n     command.append(f\"--target={path}\")\n \n     print(f\"Installing chromadb version {pkg} to {path}\")\n---\npyproject.toml\n@@ -7,7 +7,10 @@ description = \"Chroma.\"\n readme = \"README.md\"\n requires-python = \">=3.9\"\n classifiers = [\"Programming Language :: Python :: 3\", \"License :: OSI Approved :: Apache Software License\", \"Operating System :: OS Independent\"]\n-dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'chroma-hnswlib==0.7.6', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+\n+[project.optional-dependencies]\n+dev = ['chroma-hnswlib==0.7.6']\n \n [tool.black]\n line-length = 88\n---\nrequirements.txt\n@@ -1,5 +1,4 @@\n bcrypt>=4.0.1\n-chroma-hnswlib==0.7.6\n fastapi==0.115.9\n graphlib_backport==1.0.3; python_version < '3.9'\n grpcio>=1.58.0\n---\nrequirements_dev.txt\n@@ -1,5 +1,6 @@\n black==23.3.0 # match what's in pyproject.toml\n build\n+chroma-hnswlib==0.7.6\n grpcio-tools==1.67.1 # Later version not compatible with protobuf 4.25.5\n httpx\n hypothesis==6.112.2 # TODO: Resolve breaking changes and bump version\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nIf the bit-difference workload is used for pure-upsert workloads it will\nviolate quota.  This PR shrinks the batch size to just one cluster at a\ntime.  By construction clusters fit a batch.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\n.github/actions/docker/action.yaml\n@@ -20,6 +20,8 @@ runs:\n     # https://github.com/docker/setup-qemu-action - for multiplatform builds\n     - name: Set up QEMU\n       uses: docker/setup-qemu-action@v2\n+    - name: Set up Docker Buildx\n+      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -215,7 +215,18 @@ async fn get_log_from_handle<'a>(\n     prefix: &str,\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n-    let mut active = handle.active.lock().await;\n+    let active = handle.active.lock().await;\n+    get_log_from_handle_with_mutex_held(handle, active, options, storage, prefix, mark_dirty).await\n+}\n+\n+async fn get_log_from_handle_with_mutex_held<'a>(\n+    handle: &'a crate::state_hash_table::Handle<LogKey, LogStub>,\n+    mut active: tokio::sync::MutexGuard<'_, ActiveLog>,\n+    options: &LogWriterOptions,\n+    storage: &Arc<Storage>,\n+    prefix: &str,\n+    mark_dirty: MarkDirty,\n+) -> Result<LogRef<'a>, wal3::Error> {\n     if active.log.is_some() {\n         active.keep_alive(Duration::from_secs(60));\n     }\n@@ -519,7 +530,12 @@ impl LogServer {\n         // Grab a lock on the state for this key, so that a racing initialize won't do anything.\n         let key = LogKey { collection_id };\n         let handle = self.open_logs.get_or_create_state(key);\n-        let mut _active = handle.active.lock().await;\n+        let active = handle.active.lock().await;\n+\n+        // Someone already initialized the log on a prior call.\n+        if active.log.is_some() {\n+            return Ok(());\n+        }\n \n         tracing::info!(\"log transfer to {collection_id}\");\n         let scout_request = Request::new(ScoutLogsRequest {\n@@ -641,6 +657,23 @@ impl LogServer {\n             log_offset: start as i64 - 1,\n         }))\n         .await?;\n+        // Set it up so that once we release the mutex, the next person won't do I/O and will\n+        // immediately be able to push logs.\n+        let storage_prefix = storage_prefix_for_log(collection_id);\n+        let mark_dirty = MarkDirty {\n+            collection_id,\n+            dirty_log: Arc::clone(&self.dirty_log),\n+        };\n+        // If this fails, the next writer will load manifest and continue unimpeded.\n+        let _ = get_log_from_handle_with_mutex_held(\n+            &handle,\n+            active,\n+            &self.config.writer,\n+            &self.storage,\n+            &storage_prefix,\n+            mark_dirty,\n+        )\n+        .await;\n         Ok(())\n     }\n \n---\n\n\n---\n\nChoice C:\n.github/workflows/release-chromadb.yml\n@@ -61,6 +61,7 @@ jobs:\n   go-tests:\n     name: Go tests\n     uses: ./.github/workflows/_go-tests.yml\n+    secrets: inherit\n \n   release-docker:\n     name: Publish to DockerHub and GHCR\n---\n\n\n---\n\nChoice D:\nrust/load/src/bit_difference.rs\n@@ -266,19 +266,17 @@ impl SyntheticDataSet {\n         let mut embeddings = vec![];\n         let mut docs = vec![];\n         let mut seen: HashSet<String> = HashSet::default();\n-        for _ in 0..uq.batch_size {\n-            let cluster = self.cluster_by_skew(skew, guac);\n-            let num_this_cluster = (cluster.docs.len() as f64 * uq.associativity).ceil() as usize;\n-            for _ in 0..num_this_cluster {\n-                let doc_idx = (any::<u32>(guac) as u64 * cluster.docs.len() as u64) >> 32;\n-                if seen.contains(&cluster.docs[doc_idx as usize].id()) {\n-                    continue;\n-                }\n-                seen.insert(cluster.docs[doc_idx as usize].id());\n-                ids.push(cluster.docs[doc_idx as usize].id());\n-                embeddings.push(cluster.docs[doc_idx as usize].embedding());\n-                docs.push(cluster.docs[doc_idx as usize].content.clone());\n+        let cluster = self.cluster_by_skew(skew, guac);\n+        let num_this_cluster = (cluster.docs.len() as f64 * uq.associativity).ceil() as usize;\n+        for _ in 0..num_this_cluster {\n+            let doc_idx = (any::<u32>(guac) as u64 * cluster.docs.len() as u64) >> 32;\n+            if seen.contains(&cluster.docs[doc_idx as usize].id()) {\n+                continue;\n             }\n+            seen.insert(cluster.docs[doc_idx as usize].id());\n+            ids.push(cluster.docs[doc_idx as usize].id());\n+            embeddings.push(cluster.docs[doc_idx as usize].embedding());\n+            docs.push(cluster.docs[doc_idx as usize].content.clone());\n         }\n         let ids = ids.iter().map(String::as_str).collect();\n         let docs = docs.iter().map(String::as_str).collect();\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\npreviously on FTS operations, the left join + filter meant all rows were accumulated before applying the where clause to limit the results. Now, we introduced a subquery approach, similar to metadata so that the subquery can resolve first, and removed the left join. Since we are now using in on the subquery, and embedding<>metadata are 1:1 (unlike embedding<>metadata which is 1:many meaning we must do the left join). the left join on the fts table gets optimized away by sqlite anyways, so this is a code clarity update to remove the lj.\r\nbefore:\r\n![image](https://github.com/user-attachments/assets/8862776f-2b60-4544-b31c-981f77070c69)\r\nafter:\r\n![image](https://github.com/user-attachments/assets/7c8ff5c9-5424-4c68-ae85-d2387c6a27c1)\r\n\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nrust/worker/src/execution/operators/filter.rs\n@@ -498,6 +498,11 @@ impl Operator<FilterInput, FilterOutput> for FilterOperator {\n     async fn run(&self, input: &FilterInput) -> Result<FilterOutput, FilterError> {\n         tracing::debug!(\"[{}]: {:?}\", self.get_name(), input);\n \n+        // NOTE: This is temporary traces to capture filter arguments\n+        //       We suspect certain filters break the FTS algorithm\n+        // TODO: Remove this after the bug is found\n+        tracing::debug!(\"[DEBUG FILTER OPERATOR]: {:?}\", self);\n+\n         let record_segment_reader = match RecordSegmentReader::from_segment(\n             &input.record_segment,\n             &input.blockfile_provider,\n---\nrust/worker/src/execution/operators/projection.rs\n@@ -71,6 +71,8 @@ pub enum ProjectionError {\n     RecordSegment(#[from] Box<dyn ChromaError>),\n     #[error(\"Error reading unitialized record segment\")]\n     RecordSegmentUninitialized,\n+    #[error(\"Error reading phantom record: {0}\")]\n+    RecordSegmentPhantomRecord(u32),\n }\n \n impl ChromaError for ProjectionError {\n@@ -80,6 +82,7 @@ impl ChromaError for ProjectionError {\n             ProjectionError::RecordReader(e) => e.code(),\n             ProjectionError::RecordSegment(e) => e.code(),\n             ProjectionError::RecordSegmentUninitialized => ErrorCodes::Internal,\n+            ProjectionError::RecordSegmentPhantomRecord(_) => ErrorCodes::Internal,\n         }\n     }\n }\n@@ -153,7 +156,7 @@ impl Operator<ProjectionInput, ProjectionOutput> for ProjectionOperator {\n                         let record = reader\n                             .get_data_for_offset_id(*offset_id)\n                             .await?\n-                            .ok_or(ProjectionError::RecordSegmentUninitialized)?;\n+                            .ok_or(ProjectionError::RecordSegmentPhantomRecord(*offset_id))?;\n                         ProjectionRecord {\n                             id: record.id.to_string(),\n                             document: record\n---\n\n\n---\n\nChoice B:\n.github/actions/docker/action.yaml\n@@ -20,6 +20,8 @@ runs:\n     # https://github.com/docker/setup-qemu-action - for multiplatform builds\n     - name: Set up QEMU\n       uses: docker/setup-qemu-action@v2\n+    - name: Set up Docker Buildx\n+      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.4\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.0.4\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.4\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.4\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.4\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.1.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.1\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\n\n\n---\n\nChoice D:\nrust/segment/src/sqlite_metadata.rs\n@@ -579,17 +579,17 @@ impl IntoSqliteExpr for CompositeExpression {\n \n impl IntoSqliteExpr for DocumentExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let doc_col = Expr::col((\n-            EmbeddingFulltextSearch::Table,\n-            EmbeddingFulltextSearch::StringValue,\n-        ));\n-        let doc_contains = doc_col\n-            .clone()\n-            .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .and(doc_col.is_not_null());\n+        let subq = Query::select()\n+            .column(EmbeddingFulltextSearch::Rowid)\n+            .from(EmbeddingFulltextSearch::Table)\n+            .and_where(\n+                Expr::col(EmbeddingFulltextSearch::StringValue)\n+                    .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\"))),\n+            )\n+            .to_owned();\n         match self.operator {\n-            DocumentOperator::Contains => doc_contains,\n-            DocumentOperator::NotContains => doc_contains.not(),\n+            DocumentOperator::Contains => Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq),\n+            DocumentOperator::NotContains => Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq),\n             DocumentOperator::Regex => todo!(\"Implement Regex matching. The result must be a not-nullable boolean (use `<expr>.is(true)`)\"),\n             DocumentOperator::NotRegex => todo!(\"Implement negated Regex matching. This must be exact opposite of Regex matching (use `<expr>.not()`)\"),\n         }\n@@ -805,20 +805,11 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            let (has_document_expr, has_metadata_expr) = match whr {\n+            let (_, has_metadata_expr) = match whr {\n                 Where::Composite(expr) => expr.has_document_and_metadata(),\n                 Where::Document(_) => (true, false),\n                 Where::Metadata(_) => (false, true),\n             };\n-            if has_document_expr {\n-                filter_limit_query.left_join(\n-                    EmbeddingFulltextSearch::Table,\n-                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n-                        EmbeddingFulltextSearch::Table,\n-                        EmbeddingFulltextSearch::Rowid,\n-                    )),\n-                );\n-            }\n             if has_metadata_expr {\n                 filter_limit_query.left_join(\n                     EmbeddingMetadata::Table,\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThe max gRPC payload/response sizes were updated for the Rust log client, but were never updated for the log service. So the `PushLogs` method was still failing when the request was > 4MB.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\ngo/cmd/logservice/main.go\n@@ -2,8 +2,8 @@ package main\n \n import (\n \t\"context\"\n-\t\"net\"\n \n+\t\"github.com/chroma-core/chroma/go/pkg/grpcutils\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/configuration\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/leader\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/metrics\"\n@@ -15,7 +15,6 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/utils\"\n \tlibs \"github.com/chroma-core/chroma/go/shared/libs\"\n \t\"github.com/chroma-core/chroma/go/shared/otel\"\n-\tsharedOtel \"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"github.com/pingcap/log\"\n \t\"github.com/rs/zerolog\"\n \t\"go.uber.org/automaxprocs/maxprocs\"\n@@ -50,22 +49,21 @@ func main() {\n \tsysDb := sysdb.NewSysDB(config.SYSDB_CONN)\n \tlr := repository.NewLogRepository(conn, sysDb)\n \tserver := server.NewLogServer(lr)\n-\tvar listener net.Listener\n-\tlistener, err = net.Listen(\"tcp\", \":\"+config.PORT)\n+\n+\t_, err = grpcutils.Default.StartGrpcServer(\"log-service\", &grpcutils.GrpcConfig{\n+\t\tBindAddress: \":\" + config.PORT,\n+\t}, func(registrar grpc.ServiceRegistrar) {\n+\t\thealthcheck := health.NewServer()\n+\t\thealthgrpc.RegisterHealthServer(registrar, healthcheck)\n+\t\tlogservicepb.RegisterLogServiceServer(registrar, server)\n+\t})\n \tif err != nil {\n-\t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n+\t\tlog.Fatal(\"failed to create grpc server\", zap.Error(err))\n \t}\n-\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n-\thealthcheck := health.NewServer()\n-\thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n-\tlogservicepb.RegisterLogServiceServer(s, server)\n-\tlog.Info(\"log service started\", zap.String(\"address\", listener.Addr().String()))\n+\tlog.Info(\"log service started\")\n \tgo leader.AcquireLeaderLock(ctx, func(ctx context.Context) {\n \t\tgo purging.PerformPurgingLoop(ctx, lr)\n \t\tgo metrics.PerformMetricsLoop(ctx, lr)\n \t})\n-\tif err := s.Serve(listener); err != nil {\n-\t\tlog.Fatal(\"failed to serve\", zap.Error(err))\n-\t}\n }\n---\ngo/pkg/grpcutils/service.go\n@@ -4,11 +4,12 @@ import (\n \t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n-\t\"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"io\"\n \t\"net\"\n \t\"os\"\n \n+\t\"github.com/chroma-core/chroma/go/shared/otel\"\n+\n \t\"github.com/pingcap/log\"\n \t\"go.uber.org/zap\"\n \t\"google.golang.org/grpc\"\n@@ -82,7 +83,7 @@ func newDefaultGrpcProvider(name string, grpcConfig *GrpcConfig, registerFunc fu\n \tOPTL_TRACING_ENDPOINT := os.Getenv(\"OPTL_TRACING_ENDPOINT\")\n \tif OPTL_TRACING_ENDPOINT != \"\" {\n \t\totel.InitTracing(context.Background(), &otel.TracingConfig{\n-\t\t\tService:  \"sysdb-service\",\n+\t\t\tService:  name,\n \t\t\tEndpoint: OPTL_TRACING_ENDPOINT,\n \t\t})\n \t}\n---\ngo/pkg/sysdb/grpc/server.go\n@@ -158,7 +158,7 @@ func NewWithGrpcProvider(config Config, provider grpcutils.GrpcProvider) (*Serve\n \t\ts.softDeleteCleaner.Start()\n \n \t\tlog.Info(\"Starting GRPC server\")\n-\t\ts.grpcServer, err = provider.StartGrpcServer(\"coordinator\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n+\t\ts.grpcServer, err = provider.StartGrpcServer(\"sysdb-service\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n \t\t\tcoordinatorpb.RegisterSysDBServer(registrar, s)\n \t\t\thealthgrpc.RegisterHealthServer(registrar, s.healthServer)\n \t\t})\n---\n\n\n---\n\nChoice B:\n.github/workflows/_python-tests.yml\n@@ -291,7 +291,7 @@ jobs:\n         api_key: ${{ secrets.DD_API_KEY }}\n         site: ${{ vars.DD_SITE }}\n     - name: Integration Test\n-      run: bin/python-integration-test ${{ matrix.test-globs }}\n+      run: python -m pytest ${{ matrix.test-globs }}\n       shell: bash\n       env:\n         ENV_FILE: ${{ matrix.env-file }}\n---\nchromadb/test/test_cli.py\n@@ -1,6 +1,5 @@\n import multiprocessing\n import multiprocessing.context\n-import os\n import sys\n import time\n from multiprocessing.synchronize import Event\n@@ -10,7 +9,6 @@\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,6 +17,36 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+        host: str, port: int,\n+    max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            client = chromadb.HttpClient(host=host, port=port)\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            print(\"Heartbeat failed, trying again...\")\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n@@ -32,14 +60,10 @@ def test_app() -> None:\n     server_process.start()\n     time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    assert wait_for_server(host=\"localhost\", port=8001), \"Server failed to start within maximum retry attempts\"\n \n-    client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -124,7 +148,7 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\", \"--timeout\", \"10\"]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\nrust/cli/src/commands/vacuum.rs\n@@ -20,8 +20,10 @@ use sqlx::Row;\n use std::error::Error;\n use std::path::Path;\n use std::str::FromStr;\n+use std::time::Duration;\n use std::{fs, io};\n use thiserror::Error;\n+use tokio::time::timeout;\n \n #[derive(Debug, Error)]\n pub enum VacuumError {\n@@ -43,6 +45,8 @@ pub struct VacuumArgs {\n     path: Option<String>,\n     #[clap(long, default_value_t = false, help = \"Skip vacuum confirmation\")]\n     force: bool,\n+    #[clap(long, help = \"Maximum time (in seconds) to wait for vacuum\")]\n+    timeout: Option<u64>,\n }\n \n fn sizeof_fmt(num: u64, suffix: Option<&str>) -> String {\n@@ -195,10 +199,6 @@ pub async fn vacuum_chroma(config: FrontendConfig) -> Result<(), Box<dyn Error>>\n \n     println!(\"Vacuuming (this may take a while)...\\n\");\n \n-    sqlx::query(&format!(\"PRAGMA busy_timeout = {}\", 5000))\n-        .execute(sqlite.get_conn())\n-        .await?;\n-\n     sqlx::query(\"VACUUM\").execute(sqlite.get_conn()).await?;\n \n     sqlx::query(\n@@ -264,9 +264,19 @@ pub fn vacuum(args: VacuumArgs) -> Result<(), CliError> {\n     };\n \n     let runtime = tokio::runtime::Runtime::new().expect(\"Failed to start Chroma\");\n-    runtime\n-        .block_on(vacuum_chroma(config.frontend))\n-        .map_err(|_| VacuumError::VacuumFailed)?;\n+\n+    let res = if let Some(secs) = args.timeout {\n+        runtime.block_on(async {\n+            timeout(Duration::from_secs(secs), vacuum_chroma(config.frontend))\n+                .await\n+                .unwrap_or_else(|_elapsed| {\n+                    Err(Box::new(VacuumError::VacuumFailed) as Box<dyn std::error::Error>)\n+                })\n+        })\n+    } else {\n+        runtime.block_on(vacuum_chroma(config.frontend))\n+    };\n+    res.map_err(|_| VacuumError::VacuumFailed)?;\n \n     let post_vacuum_size =\n         get_dir_size(Path::new(&persistent_path)).map_err(|_| VacuumError::DirSizeFailed)?;\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/config.rs\n@@ -64,6 +64,8 @@ pub struct FrontendConfig {\n     pub executor: ExecutorConfig,\n     #[serde(default = \"default_default_knn_index\")]\n     pub default_knn_index: KnnIndex,\n+    #[serde(default = \"Default::default\")]\n+    pub tenants_to_migrate_immediately: Vec<String>,\n }\n \n impl FrontendConfig {\n@@ -80,6 +82,7 @@ impl FrontendConfig {\n             log: default_log_config(),\n             executor: default_executor_config(),\n             default_knn_index: default_default_knn_index(),\n+            tenants_to_migrate_immediately: vec![],\n         }\n     }\n }\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -66,9 +66,11 @@ pub struct ServiceBasedFrontend {\n     metrics: Arc<Metrics>,\n     default_knn_index: KnnIndex,\n     retries_builder: ExponentialBuilder,\n+    tenants_to_migrate_immediately: HashSet<String>,\n }\n \n impl ServiceBasedFrontend {\n+    #[allow(clippy::too_many_arguments)]\n     pub fn new(\n         allow_reset: bool,\n         sysdb_client: SysDb,\n@@ -77,6 +79,7 @@ impl ServiceBasedFrontend {\n         executor: Executor,\n         max_batch_size: u32,\n         default_knn_index: KnnIndex,\n+        tenants_to_migrate_immediately: HashSet<String>,\n     ) -> Self {\n         let meter = global::meter(\"chroma\");\n         let fork_retries_counter = meter.u64_counter(\"fork_retries\").build();\n@@ -119,6 +122,7 @@ impl ServiceBasedFrontend {\n             metrics,\n             default_knn_index,\n             retries_builder,\n+            tenants_to_migrate_immediately,\n         }\n     }\n \n@@ -489,7 +493,7 @@ impl ServiceBasedFrontend {\n         let collection = self\n             .sysdb_client\n             .create_collection(\n-                tenant_id,\n+                tenant_id.clone(),\n                 database_name,\n                 collection_id,\n                 name,\n@@ -505,10 +509,18 @@ impl ServiceBasedFrontend {\n             .collections_with_segments_cache\n             .remove(&collection_id)\n             .await;\n-\n+        if self.tenant_is_on_new_log_by_default(&tenant_id) {\n+            if let Err(err) = self.log_client.seal_log(&tenant_id, collection_id).await {\n+                tracing::error!(\"could not seal collection right away: {err}\");\n+            }\n+        }\n         Ok(collection)\n     }\n \n+    fn tenant_is_on_new_log_by_default(&self, tenant_id: &str) -> bool {\n+        self.tenants_to_migrate_immediately.contains(tenant_id)\n+    }\n+\n     pub async fn update_collection(\n         &mut self,\n         UpdateCollectionRequest {\n@@ -1471,6 +1483,11 @@ impl Configurable<(FrontendConfig, System)> for ServiceBasedFrontend {\n         let executor =\n             Executor::try_from_config(&(config.executor.clone(), system.clone()), registry).await?;\n \n+        let tenants_to_migrate_immediately = config\n+            .tenants_to_migrate_immediately\n+            .iter()\n+            .cloned()\n+            .collect::<HashSet<String>>();\n         Ok(ServiceBasedFrontend::new(\n             config.allow_reset,\n             sysdb,\n@@ -1479,6 +1496,7 @@ impl Configurable<(FrontendConfig, System)> for ServiceBasedFrontend {\n             executor,\n             max_batch_size,\n             config.default_knn_index,\n+            tenants_to_migrate_immediately,\n         ))\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -125,6 +125,20 @@ impl ChromaError for GrpcPurgeDirtyForCollectionError {\n     }\n }\n \n+#[derive(Error, Debug)]\n+pub enum GrpcSealLogError {\n+    #[error(\"Failed to seal collection: {0}\")]\n+    FailedToSeal(#[from] tonic::Status),\n+}\n+\n+impl ChromaError for GrpcSealLogError {\n+    fn code(&self) -> ErrorCodes {\n+        match self {\n+            GrpcSealLogError::FailedToSeal(_) => ErrorCodes::Internal,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct GrpcLog {\n     config: GrpcLogConfig,\n@@ -544,6 +558,20 @@ impl GrpcLog {\n             Ok(())\n         }\n     }\n+\n+    pub(super) async fn seal_log(\n+        &mut self,\n+        tenant: &str,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcSealLogError> {\n+        let _response = self\n+            .client_for(tenant, collection_id)\n+            .seal_log(chroma_proto::SealLogRequest {\n+                collection_id: collection_id.to_string(),\n+            })\n+            .await?;\n+        Ok(())\n+    }\n }\n \n #[cfg(test)]\n---\nrust/log/src/log.rs\n@@ -1,4 +1,4 @@\n-use crate::grpc_log::GrpcLog;\n+use crate::grpc_log::{GrpcLog, GrpcSealLogError};\n use crate::in_memory_log::InMemoryLog;\n use crate::sqlite_log::SqliteLog;\n use crate::types::CollectionInfo;\n@@ -210,4 +210,16 @@ impl Log {\n             Log::InMemory(_) => Ok(ResetResponse {}),\n         }\n     }\n+\n+    pub async fn seal_log(\n+        &mut self,\n+        tenant: &str,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcSealLogError> {\n+        match self {\n+            Log::Grpc(log) => log.seal_log(tenant, collection_id).await,\n+            Log::Sqlite(_) => unimplemented!(),\n+            Log::InMemory(_) => unimplemented!(),\n+        }\n+    }\n }\n---\nrust/python_bindings/src/bindings.rs\n@@ -122,6 +122,7 @@ impl Bindings {\n             log: log_config,\n             executor: executor_config,\n             default_knn_index: knn_index,\n+            tenants_to_migrate_immediately: vec![],\n         };\n \n         let frontend = runtime.block_on(async {\n---\n\n\n---\n\nChoice D:\nrust/load/src/bin/chroma-load-start.rs\n@@ -1,7 +1,10 @@\n //! Start a workload on the chroma-load server.\n \n+use std::sync::Arc;\n+\n use clap::Parser;\n \n+use chroma_load::data_sets::{all_data_sets, References};\n use chroma_load::rest::StartRequest;\n use chroma_load::{humanize_expires, Connection, Throughput, Workload};\n \n@@ -18,7 +21,13 @@ struct Args {\n     #[arg(long)]\n     workload: String,\n     #[arg(long)]\n-    data_set: String,\n+    data_set: Option<String>,\n+    #[arg(long)]\n+    references_data_set: Option<String>,\n+    #[arg(long)]\n+    operates_on_data_set: Option<String>,\n+    #[arg(long)]\n+    operates_on_cardinality: Option<usize>,\n     #[arg(long)]\n     url: String,\n     #[arg(long)]\n@@ -103,11 +112,47 @@ async fn main() {\n             wrap: Box::new(workload),\n         };\n     }\n+    let (data_set, custom_data_set) = match (\n+        args.data_set,\n+        args.references_data_set,\n+        args.operates_on_data_set,\n+        args.operates_on_cardinality,\n+    ) {\n+        (Some(data_set), None, None, None) => (Some(data_set.clone()), None),\n+        (None, Some(references), Some(operates_on), Some(cardinality)) => {\n+            let Some(referred_to) = all_data_sets()\n+                .iter()\n+                .find(|ds| ds.name() == references)\n+                .map(Arc::clone)\n+            else {\n+                eprintln!(\"Could not find a data set to reference named {references}\");\n+                std::process::exit(13);\n+            };\n+            let to_start = References {\n+                references: referred_to.json(),\n+                operates_on,\n+                cardinality,\n+            };\n+            let to_start = match serde_json::to_value(&to_start) {\n+                Ok(to_start) => to_start,\n+                Err(err) => {\n+                    eprintln!(\"could not serialize referencing data set: {err:?}\");\n+                    std::process::exit(13);\n+                }\n+            };\n+            (None, Some(to_start))\n+        }\n+        _ => {\n+            eprintln!(\"must provide data_set XOR (references_data_set, operates_on_data_set, operates_on_cardinality)\");\n+            std::process::exit(13);\n+        }\n+    };\n     let req = StartRequest {\n         name: args.name,\n         expires: humanize_expires(&args.expires).unwrap_or(args.expires),\n         workload,\n-        data_set: args.data_set,\n+        data_set,\n+        custom_data_set,\n         connection: Connection {\n             url: args.url,\n             api_key,\n---\nrust/load/src/data_sets.rs\n@@ -1496,9 +1496,9 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n \n #[derive(Clone, Debug, Default, serde::Deserialize, serde::Serialize)]\n pub struct References {\n-    references: serde_json::Value,\n-    operates_on: String,\n-    cardinality: usize,\n+    pub references: serde_json::Value,\n+    pub operates_on: String,\n+    pub cardinality: usize,\n }\n \n /// Get a data set from a particular JSON value.\n---\nrust/load/src/lib.rs\n@@ -1190,7 +1190,7 @@ impl LoadService {\n     pub fn start(\n         &self,\n         name: String,\n-        mut workload: Workload,\n+        workload: Workload,\n         data_set: String,\n         connection: Connection,\n         expires: chrono::DateTime<chrono::FixedOffset>,\n@@ -1199,14 +1199,28 @@ impl LoadService {\n         let Some(data_set) = self.data_sets().iter().find(|ds| ds.name() == data_set) else {\n             return Err(Error::NotFound(\"data set not found\".to_string()));\n         };\n+        let data_set = Arc::clone(data_set);\n+        self.start_struct(name, workload, data_set, connection, expires, throughput)\n+    }\n+\n+    /// Start a workload on the load service using structs rather than resolving strings.\n+    pub fn start_struct(\n+        &self,\n+        name: String,\n+        mut workload: Workload,\n+        data_set: Arc<dyn DataSet>,\n+        connection: Connection,\n+        expires: chrono::DateTime<chrono::FixedOffset>,\n+        throughput: Throughput,\n+    ) -> Result<Uuid, Error> {\n         workload.resolve_by_name(self.workloads())?;\n         let res = {\n             // SAFETY(rescrv):  Mutex poisoning.\n             let mut harness = self.harness.lock().unwrap();\n             Ok(harness.start(\n                 name,\n                 workload.clone(),\n-                data_set,\n+                &data_set,\n                 connection,\n                 expires,\n                 throughput,\n@@ -1625,15 +1639,41 @@ async fn start(\n ) -> Result<String, Error> {\n     let expires = chrono::DateTime::parse_from_rfc3339(&req.expires)\n         .map_err(|err| Error::InvalidRequest(format!(\"could not parse rfc3339: {err:?}\")))?;\n-    let uuid = state.load.start(\n-        req.name,\n-        req.workload,\n-        req.data_set,\n-        req.connection,\n-        expires,\n-        req.throughput,\n-    )?;\n-    Ok(uuid.to_string() + \"\\n\")\n+    match (req.data_set, req.custom_data_set) {\n+        (Some(_), Some(_)) => Err(Error::InvalidRequest(\n+            \"provide at most one of data_set and custom_data_set\".to_string(),\n+        )),\n+        (None, None) => Err(Error::InvalidRequest(\n+            \"provide at least one of data_set and custom_data_set\".to_string(),\n+        )),\n+        (Some(data_set), None) => {\n+            let uuid = state.load.start(\n+                req.name,\n+                req.workload,\n+                data_set,\n+                req.connection,\n+                expires,\n+                req.throughput,\n+            )?;\n+            Ok(uuid.to_string() + \"\\n\")\n+        }\n+        (None, Some(custom_data_set)) => {\n+            let Some(data_set) = data_sets::from_json(&custom_data_set) else {\n+                return Err(Error::InvalidRequest(\n+                    \"custom data set returned nothing\".to_string(),\n+                ));\n+            };\n+            let uuid = state.load.start_struct(\n+                req.name,\n+                req.workload,\n+                data_set,\n+                req.connection,\n+                expires,\n+                req.throughput,\n+            )?;\n+            Ok(uuid.to_string() + \"\\n\")\n+        }\n+    }\n }\n \n async fn stop(\n---\nrust/load/src/rest.rs\n@@ -43,8 +43,10 @@ pub struct StartRequest {\n     pub name: String,\n     /// The workload to run.\n     pub workload: Workload,\n-    /// The data set to use.\n-    pub data_set: String,\n+    /// The data set to use, referred to by name.\n+    pub data_set: Option<String>,\n+    /// The custom data set to use.\n+    pub custom_data_set: Option<serde_json::Value>,\n     /// The connection to use.\n     pub connection: Connection,\n     /// When the workload should expire.\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - This is taking very long, use larger machine\r\n- New functionality\r\n  - /\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nNone\n\n---\n\nChoice A:\n.github/workflows/_build_release_container.yml\n@@ -38,7 +38,7 @@ env:\n jobs:\n   build:\n     name: Build and publish container image\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n+    runs-on: blacksmith-16vcpu-ubuntu-2204\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n---\n\n\n---\n\nChoice B:\nchromadb/test/distributed/test_log_failover.py\n@@ -189,3 +189,99 @@ def test_log_failover_with_compaction(\n             assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n         else:\n             assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_query_operations(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    # Add initial RECORDS records with known embeddings for querying\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Perform baseline similarity queries before failover\n+    query_embeddings = [embeddings[0], embeddings[RECORDS//2], embeddings[-1]]\n+    baseline_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        baseline_results.append(result)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Trigger log failover\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Re-run the same queries after failover and verify results consistency\n+    post_failover_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        post_failover_results.append(result)\n+\n+    # Verify that query results are consistent before and after failover\n+    for i, (baseline, post_failover) in enumerate(zip(baseline_results, post_failover_results)):\n+        assert len(baseline[\"ids\"][0]) == len(post_failover[\"ids\"][0]), f\"Query {i} returned different number of results\"\n+        assert baseline[\"ids\"][0] == post_failover[\"ids\"][0], f\"Query {i} returned different IDs\"\n+        # Verify embeddings match (allowing for small floating point differences)\n+        for j, (base_emb, post_emb) in enumerate(zip(baseline[\"embeddings\"][0], post_failover[\"embeddings\"][0])):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(base_emb, post_emb)]), f\"Query {i} result {j} embeddings differ\"\n+\n+    # Add more data post-failover\n+    post_failover_start = RECORDS\n+    for i in range(post_failover_start, post_failover_start + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Query for both old and new data to ensure full functionality\n+    # Test that we can find old data\n+    old_data_query = collection.query(\n+        query_embeddings=[embeddings[0]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(old_data_query[\"ids\"][0]) == 3, \"Failed to query old data after failover\"\n+\n+    # Test that we can find new data\n+    new_data_query = collection.query(\n+        query_embeddings=[embeddings[-1]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(new_data_query[\"ids\"][0]) == 3, \"Failed to query new data after failover\"\n+\n+    # Verify all data is still accessible by ID\n+    for i in range(len(ids)):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        assert len(result[\"embeddings\"]) > 0, f\"Missing result for ID {i} after failover with new data\"\n+        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])]), f\"Embedding mismatch for ID {i}\"\n---\n\n\n---\n\nChoice C:\n.github/workflows/_build_js_bindings.yml\n@@ -231,11 +231,17 @@ jobs:\n       - name: Download all artifacts\n         uses: actions/download-artifact@v4\n         with:\n-          path: artifacts\n+          path: rust/js_bindings/artifacts\n+      - name: List downloads\n+        run: ls -R .\n+      - name: Flatten artifact directory\n+        run: find artifacts -type f -name '*.node' -exec mv {} ./artifacts/ \\;\n+      - name: List downloads\n+        run: ls -R .\n       - name: Move artifacts\n         run: pnpm artifacts\n       - name: List packages\n-        run: ls -R ./npm\n+        run: ls -R .\n         shell: bash\n       - name: Publish\n         run: |\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\nChoice D:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.2\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.1.2\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.2\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.2\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.2\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.3\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.1.3\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.3\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.3\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.3\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - All the foyer caches are named as \"foyer\" currently. This clobbers the metrics since each metric is prefixed with \"<name>_.*\". Introduces name in the config and passes it down to the cache builder\n- New functionality\n  - ...\n\n## Test plan\n_How are these changes tested?_\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\nNone\n\n\n---\n\nChoice A:\nrust/load/src/opentelemetry_config.rs\n@@ -5,114 +5,41 @@\n \n use opentelemetry::global;\n use opentelemetry::trace::TracerProvider;\n-use opentelemetry_otlp::{WithExportConfig, WithHttpConfig};\n+use opentelemetry_otlp::WithExportConfig;\n use opentelemetry_sdk::propagation::TraceContextPropagator;\n use tracing_bunyan_formatter::BunyanFormattingLayer;\n use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Layer};\n \n-#[derive(Clone, Debug, Default)]\n-struct ChromaShouldSample;\n-\n-const BUSY_NS: opentelemetry::Key = opentelemetry::Key::from_static_str(\"busy_ns\");\n-const IDLE_NS: opentelemetry::Key = opentelemetry::Key::from_static_str(\"idle_ns\");\n-\n-fn is_slow(attributes: &[opentelemetry::KeyValue]) -> bool {\n-    let mut nanos = 0i64;\n-    for attr in attributes {\n-        if attr.key == BUSY_NS || attr.key == IDLE_NS {\n-            if let opentelemetry::Value::I64(ns) = attr.value {\n-                nanos += ns;\n-            }\n-        }\n-    }\n-    nanos > 20_000_000\n-}\n-\n-impl opentelemetry_sdk::trace::ShouldSample for ChromaShouldSample {\n-    fn should_sample(\n-        &self,\n-        _: Option<&opentelemetry::Context>,\n-        _: opentelemetry::trace::TraceId,\n-        name: &str,\n-        _: &opentelemetry::trace::SpanKind,\n-        attributes: &[opentelemetry::KeyValue],\n-        _: &[opentelemetry::trace::Link],\n-    ) -> opentelemetry::trace::SamplingResult {\n-        // NOTE(rescrv):  THIS IS A HACK!  If you find yourself seriously extending it, it's time\n-        // to investigate honeycomb's sampling capabilities.\n-\n-        // If the name is not get and not insert, or the request is slow, sample it.\n-        // Otherwise, drop.\n-        // This filters filters foyer calls in-process so they won't be overwhelming the tracing.\n-        if (name != \"get\" && name != \"insert\") || is_slow(attributes) {\n-            opentelemetry::trace::SamplingResult {\n-                decision: opentelemetry::trace::SamplingDecision::RecordAndSample,\n-                attributes: vec![],\n-                trace_state: opentelemetry::trace::TraceState::default(),\n-            }\n-        } else {\n-            opentelemetry::trace::SamplingResult {\n-                decision: opentelemetry::trace::SamplingDecision::Drop,\n-                attributes: vec![],\n-                trace_state: opentelemetry::trace::TraceState::default(),\n-            }\n-        }\n-    }\n-}\n-\n pub(crate) fn init_otel_tracing(service_name: &String, otel_endpoint: &String) {\n-    println!(\n+    tracing::info!(\n         \"Registering jaeger subscriber for {} at endpoint {}\",\n-        service_name, otel_endpoint\n+        service_name,\n+        otel_endpoint\n     );\n     let resource = opentelemetry_sdk::Resource::new(vec![opentelemetry::KeyValue::new(\n         \"service.name\",\n         service_name.clone(),\n     )]);\n \n     // Prepare tracer.\n-    let client = reqwest::Client::new();\n-    let span_exporter = opentelemetry_otlp::SpanExporter::builder()\n-        .with_http()\n-        .with_http_client(client)\n+    let tracing_span_exporter = opentelemetry_otlp::SpanExporter::builder()\n+        .with_tonic()\n         .with_endpoint(otel_endpoint)\n         .build()\n-        .expect(\"could not build span exporter\");\n-    let trace_config = opentelemetry_sdk::trace::Config::default()\n-        .with_sampler(ChromaShouldSample)\n-        .with_resource(resource.clone());\n+        .expect(\"could not build span exporter for tracing\");\n+    let trace_config = opentelemetry_sdk::trace::Config::default().with_resource(resource.clone());\n     let tracer_provider = opentelemetry_sdk::trace::TracerProvider::builder()\n-        .with_batch_exporter(span_exporter, opentelemetry_sdk::runtime::Tokio)\n+        .with_batch_exporter(tracing_span_exporter, opentelemetry_sdk::runtime::Tokio)\n         .with_config(trace_config)\n         .build();\n     let tracer = tracer_provider.tracer(service_name.clone());\n-    // TODO(MrCroxx): Should we the tracer provider as global?\n-    // global::set_tracer_provider(tracer_provider);\n \n     // Prepare meter.\n-    let mut headers = reqwest::header::HeaderMap::new();\n-    headers.insert(\n-        \"x-honeycomb-dataset\",\n-        reqwest::header::HeaderValue::from_static(\"chroma-load\"),\n-    );\n-    if let Ok(api_key) = std::env::var(\"OTEL_EXPORTER_OTLP_HEADERS\") {\n-        if let Some((header, value)) = api_key.split_once(\"=\") {\n-            if header == \"x-honeycomb-team\" {\n-                headers.insert(\n-                    reqwest::header::HeaderName::from_static(\"x-honeycomb-team\"),\n-                    reqwest::header::HeaderValue::from_bytes(value.trim().as_bytes()).unwrap(),\n-                );\n-            }\n-        }\n-    }\n-    let client = reqwest::ClientBuilder::new()\n-        .default_headers(headers)\n-        .build()\n-        .unwrap();\n     let metric_exporter = opentelemetry_otlp::MetricExporter::builder()\n-        .with_http()\n-        .with_http_client(client)\n-        .with_endpoint(otel_endpoint)\n+        .with_tonic()\n+        .with_endpoint(\n+            std::env::var(\"OTEL_EXPORTER_OTLP_METRICS_ENDPOINT\").unwrap_or(otel_endpoint.clone()),\n+        )\n         .build()\n         .expect(\"could not build metric exporter\");\n \n---\n\n\n---\n\nChoice B:\nk8s/distributed-chroma/values.dev.yaml\n@@ -33,3 +33,6 @@ compactionService:\n       value: 'value: \"1\"'\n     - name: CONFIG_PATH\n       value: 'value: \"/tilt_config.yaml\"'\n+\n+rustLogService:\n+  replicaCount: 2\n---\n\n\n---\n\nChoice C:\nrust/cache/src/foyer.rs\n@@ -94,8 +94,17 @@ const fn default_trace_fetch_us() -> usize {\n     1000 * 100\n }\n \n+fn default_name() -> String {\n+    String::from(\"foyer\")\n+}\n+\n #[derive(Deserialize, Debug, Clone, Serialize, Parser)]\n pub struct FoyerCacheConfig {\n+    /// Name of the cache. All metrics for the cache are prefixed with name_.\n+    #[arg(long, default_value = \"foyer\")]\n+    #[serde(default = \"default_name\")]\n+    pub name: String,\n+\n     /// Directory for disk cache data.\n     #[arg(short, long)]\n     pub dir: Option<String>,\n@@ -262,6 +271,7 @@ impl FoyerCacheConfig {\n impl Default for FoyerCacheConfig {\n     fn default() -> Self {\n         FoyerCacheConfig {\n+            name: default_name(),\n             dir: None,\n             capacity: default_capacity(),\n             mem: default_mem(),\n@@ -352,6 +362,7 @@ where\n             ),\n         );\n         let builder = HybridCacheBuilder::<K, V>::new()\n+            .with_name(config.name.clone())\n             .with_metrics_registry(otel_0_27_metrics)\n             .with_tracing_options(tracing_options.clone())\n             .with_policy(foyer::HybridCachePolicy::WriteOnInsertion)\n@@ -537,6 +548,7 @@ where\n         config: &FoyerCacheConfig,\n     ) -> Result<FoyerPlainCache<K, V>, Box<dyn ChromaError>> {\n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .build();\n@@ -590,6 +602,7 @@ where\n         let evl = TokioEventListener(tx);\n \n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .with_event_listener(Arc::new(evl))\n---\nrust/frontend/sample_configs/distributed.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/worker/chroma_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     disk:\n+                        name: \"block_cache\"\n                         dir: \"/cache/chroma/query-service/block-cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n@@ -72,11 +73,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n \n@@ -138,15 +141,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\nrust/worker/tilt_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 block_cache_config:\n                     disk:\n                         dir: \"/cache/chroma/query-service/block-cache\"\n+                        name: \"block_cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n                         mem: 8000 # 8GiB\n@@ -71,11 +72,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n     fetch_log_batch_size: 1000\n@@ -141,15 +144,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\n\n\n---\n\nChoice D:\nchromadb/test/property/test_fork.py\n@@ -189,3 +189,31 @@ def verify(\n def test_fork(caplog: pytest.LogCaptureFixture, client: chromadb.api.ClientAPI) -> None:\n     caplog.set_level(logging.ERROR)\n     run_state_machine_as_test(lambda: ForkStateMachine(client))  # type: ignore\n+\n+\n+@skip_if_not_cluster()\n+def test_fork_with_log_migration(\n+    caplog: pytest.LogCaptureFixture, client: chromadb.api.ClientAPI\n+) -> None:\n+    import grpc\n+    from chromadb.proto.logservice_pb2 import SealLogRequest\n+    from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n+    caplog.set_level(logging.ERROR)\n+    client.reset()\n+    channel = grpc.insecure_channel(\"localhost:50052\")\n+    go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n+    collection = client.create_collection(\"legacy-go-collection-0\")\n+    ids = [f\"id_{i}\" for i in range(6)]\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n+    fork_collection = collection.fork(\"fork-legacy-go-collection-0\")\n+    assert sorted(fork_collection.get()[\"ids\"]) == ids\n+\n+    collection = client.create_collection(\"legacy-go-collection-1\")\n+    go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n+    ids = [f\"id_{i}\" for i in range(6)]\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    fork_collection = collection.fork(\"fork-legacy-go-collection-1\")\n+    assert sorted(fork_collection.get()[\"ids\"]) == ids\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThe full-text reader had a bug where it used the positions of tokens to determine whether the tokens appeared sequentially, rather than using the byte offset of tokens. This was problematic because the index stores byte offsets. Since Unicode characters can be many bytes wide, we cannot guarantee that the stored byte offsets are strictly consecutive.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\nAdded a test that fails on main.\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\nrust/index/src/fulltext/types.rs\n@@ -313,7 +313,7 @@ impl<'me> FullTextIndexReader<'me> {\n         }\n \n         // Retrieve posting lists for each token.\n-        let posting_lists = futures::stream::iter(tokens)\n+        let posting_lists = futures::stream::iter(&tokens)\n             .then(|token| async move {\n                 let positional_posting_list = self\n                     .posting_lists_blockfile_reader\n@@ -355,39 +355,37 @@ impl<'me> FullTextIndexReader<'me> {\n \n             if min_doc_id == max_doc_id {\n                 // All tokens appear in the same document, so check positional alignment.\n-                let mut positions_per_posting_list = Vec::with_capacity(num_tokens);\n-                for (i, posting_list) in posting_lists.iter().enumerate() {\n-                    let (_, _, positions) = posting_list[pointers[i]];\n-                    positions_per_posting_list.push(positions);\n-                }\n-\n-                // Adjust positions and check for sequential alignment.\n                 // Imagine you're searching for \"brown fox\" over the document \"the quick brown fox\".\n                 // The positions for \"brown\" are {2} and for \"fox\" are {3}. The adjusted positions after subtracting the token's position in the query are {2} for \"brown\" and 3 - 1 = {2} for \"fox\".\n                 // The intersection of these two sets is non-empty, so we know that the two tokens are adjacent.\n+                // In practice, we must adjust the positions by using the byte offset of the token rather than the token's position in the query, because Unicode characters can be variable-length and the posting lists are stored as byte offsets.\n+                // E.x. imagine we're using a 1-gram tokenizer and processing the string \"\u00e9m\". The token positions are {0, 1}, but the byte offsets are {0, 2} (because \u00e9 is two bytes long).\n \n                 // Seed with the positions of the first token.\n-                let mut adjusted_positions = positions_per_posting_list[0]\n+                let mut adjusted = posting_lists[0][pointers[0]]\n+                    .2\n                     .iter()\n                     .copied()\n                     .collect::<HashSet<_>>();\n \n-                for (offset, positions_set) in positions_per_posting_list.iter().enumerate().skip(1)\n-                {\n-                    let positions_set = positions_set\n+                for i in 1..num_tokens {\n+                    let byte_delta_from_first_token =\n+                        tokens[i].offset_from as u32 - tokens[0].offset_from as u32;\n+                    let positions = &posting_lists[i][pointers[i]].2;\n+\n+                    let shifted = positions\n                         .iter()\n-                        // (We can discard any positions that the token appears at before the current offset)\n-                        .filter_map(|&p| p.checked_sub(offset as u32))\n+                        .filter_map(|&p| p.checked_sub(byte_delta_from_first_token))\n                         .collect::<HashSet<_>>();\n-                    adjusted_positions = &adjusted_positions & &positions_set;\n \n-                    if adjusted_positions.is_empty() {\n+                    adjusted = &adjusted & &shifted;\n+                    if adjusted.is_empty() {\n                         break;\n                     }\n                 }\n \n                 // All tokens are sequential\n-                if !adjusted_positions.is_empty() {\n+                if !adjusted.is_empty() {\n                     results.insert(min_doc_id);\n                 }\n \n@@ -991,6 +989,47 @@ mod tests {\n         assert_eq!(res, RoaringBitmap::from([1]));\n     }\n \n+    #[tokio::test]\n+    async fn test_document_with_multibyte_characters() {\n+        let tmp_dir = tempdir().unwrap();\n+        let storage = Storage::Local(LocalStorage::new(tmp_dir.path().to_str().unwrap()));\n+        let block_cache = new_cache_for_test();\n+        let root_cache = new_cache_for_test();\n+        let provider = BlockfileProvider::new_arrow(storage, 1024 * 1024, block_cache, root_cache);\n+        let pl_blockfile_writer = provider\n+            .write::<u32, Vec<u32>>(BlockfileWriterOptions::default().ordered_mutations())\n+            .await\n+            .unwrap();\n+        let pl_blockfile_id = pl_blockfile_writer.id();\n+\n+        let tokenizer = NgramTokenizer::new(3, 3, false).unwrap();\n+        let mut index_writer = FullTextIndexWriter::new(pl_blockfile_writer, tokenizer.clone());\n+\n+        index_writer\n+            .handle_batch([DocumentMutation::Create {\n+                offset_id: 1,\n+                new_document: \"pret\u00e9rito\",\n+            }])\n+            .unwrap();\n+\n+        index_writer.write_to_blockfiles().await.unwrap();\n+        let flusher = index_writer.commit().await.unwrap();\n+        flusher.flush().await.unwrap();\n+\n+        let pl_blockfile_reader = provider\n+            .read::<u32, &[u32]>(&pl_blockfile_id)\n+            .await\n+            .unwrap();\n+        let tokenizer = NgramTokenizer::new(3, 3, false).unwrap();\n+        let index_reader = FullTextIndexReader::new(pl_blockfile_reader, tokenizer);\n+\n+        let res = index_reader.search(\"pret\u00e9rito\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([1]));\n+\n+        let res = index_reader.search(\"bret\u00e9rito\").await.unwrap();\n+        assert_eq!(res, RoaringBitmap::from([]));\n+    }\n+\n     #[tokio::test]\n     async fn test_update_document() {\n         let tmp_dir = tempdir().unwrap();\n---\n\n\n---\n\nChoice B:\nchromadb/api/types.py\n@@ -687,9 +687,11 @@ def validate_metadata(metadata: Metadata) -> Metadata:\n                 f\"Expected metadata key to be a str, got {key} which is a {type(key).__name__}\"\n             )\n         # isinstance(True, int) evaluates to True, so we need to check for bools separately\n-        if not isinstance(value, bool) and not isinstance(value, (str, int, float)):\n+        if not isinstance(value, bool) and not isinstance(\n+            value, (str, int, float, type(None))\n+        ):\n             raise ValueError(\n-                f\"Expected metadata value to be a str, int, float or bool, got {value} which is a {type(value).__name__}\"\n+                f\"Expected metadata value to be a str, int, float, bool, or None, got {value} which is a {type(value).__name__}\"\n             )\n     return metadata\n \n---\nchromadb/base_types.py\n@@ -1,9 +1,9 @@\n-from typing import Dict, List, Mapping, Sequence, Union\n+from typing import Dict, List, Mapping, Optional, Sequence, Union\n from typing_extensions import Literal\n import numpy as np\n from numpy.typing import NDArray\n \n-Metadata = Mapping[str, Union[str, int, float, bool]]\n+Metadata = Mapping[str, Optional[Union[str, int, float, bool]]]\n UpdateMetadata = Mapping[str, Union[int, float, str, bool, None]]\n PyVector = Union[Sequence[float], Sequence[int]]\n Vector = NDArray[Union[np.int32, np.float32]]  # TODO: Specify that the vector is 1D\n---\n\n\n---\n\nChoice C:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.38\n+version: 0.1.39\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/values.yaml\n@@ -51,6 +51,9 @@ rustLogService:\n   image:\n     repository: 'rust-log-service'\n     tag: 'latest'\n+  cache:\n+    hostPath: '/local/cache/chroma-log-service'\n+    mountPath: '/cache/'\n \n queryService:\n   image:\n---\n\n\n---\n\nChoice D:\nrust/load/src/data_sets.rs\n@@ -836,12 +836,12 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            let key = uq.key.select_from_reference(self, offset);\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n             if !keys.contains(&key) {\n                 keys.push(key);\n             }\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - /\r\n- New functionality\r\n  - `contains` in foyer is an approximate contains operation (for the disk cache) and has better performance. Additionally, it does not affect lru bookeeping. Prefetching currently uses `get()` for its `cached()` check. This change introduces `may_contain` which is a potentially false-positive check on if a cache contains a key. \r\n\r\n## Test plan\r\nBasic unit test of proxied functionality. \r\n_How are these changes tested?_\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nNone\n\n---\n\nChoice A:\nrust/cache/src/foyer.rs\n@@ -492,6 +492,10 @@ where\n         }\n         Ok(res)\n     }\n+\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.cache.contains(key)\n+    }\n }\n \n impl<K, V> super::PersistentCache<K, V> for FoyerHybridCache<K, V>\n@@ -820,4 +824,26 @@ mod test {\n             .expect(\"Value should not be None\");\n         assert_eq!(value, \"foo\");\n     }\n+\n+    #[tokio::test]\n+    async fn test_may_contain() {\n+        let dir = tempfile::tempdir()\n+            .expect(\"To be able to create temp path\")\n+            .path()\n+            .to_str()\n+            .expect(\"To be able to parse path\")\n+            .to_string();\n+        let cache = FoyerCacheConfig {\n+            dir: Some(dir.clone()),\n+            flush: true,\n+            ..Default::default()\n+        }\n+        .build_hybrid_test::<String, String>()\n+        .await\n+        .unwrap();\n+\n+        cache.insert(\"key1\".to_string(), \"foo\".to_string()).await;\n+        assert!(cache.may_contain(&\"key1\".to_string()).await);\n+        assert!(!cache.may_contain(&\"key2\".to_string()).await);\n+    }\n }\n---\nrust/cache/src/lib.rs\n@@ -69,6 +69,11 @@ where\n {\n     async fn insert(&self, key: K, value: V);\n     async fn get(&self, key: &K) -> Result<Option<V>, CacheError>;\n+    // Returns true if the cache contains the key. This method may return a\n+    // false-positive.\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.get(key).await.map(|v| v.is_some()).unwrap_or(false)\n+    }\n     async fn remove(&self, key: &K);\n     async fn clear(&self) -> Result<(), CacheError>;\n     async fn obtain(&self, key: K) -> Result<Option<V>, CacheError>;\n---\n\n\n---\n\nChoice B:\nrust/frontend/src/quota/mod.rs\n@@ -337,7 +337,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n         m.insert(UsageType::RegexPatternLength, 0);\n-        m.insert(UsageType::NumForks, 10000);\n+        m.insert(UsageType::NumForks, 256);\n         m\n     };\n }\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -1219,17 +1219,16 @@ impl LogService for LogServer {\n             let witness = cursors.load(cursor_name).await.map_err(|err| {\n                 Status::new(err.code().into(), format!(\"Failed to load cursor: {}\", err))\n             })?;\n-            // This is the existing compaction_offset, which is the last record that was compacted.\n+            // This is the existing compaction_offset, which is the next record to compact.\n             let offset = witness\n                 .map(|x| x.1.position)\n-                .unwrap_or(LogPosition::from_offset(0));\n+                .unwrap_or(LogPosition::from_offset(1));\n             tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n                 &log_reader,\n-                // + 1 to get to the first uncompacted record.\n-                offset + 1u64,\n+                offset,\n                 target_prefix.clone(),\n             )\n             .await\n@@ -1253,7 +1252,9 @@ impl LogService for LogServer {\n             }\n             tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n-                compaction_offset: offset.offset(),\n+                // NOTE: The upstream service expects the last compacted offset as compaction offset\n+                compaction_offset: (offset - 1u64).offset(),\n+                // NOTE: The upstream service expects the last uncompacted offset as enumeration offset\n                 enumeration_offset: (max_offset - 1u64).offset(),\n             }))\n         }\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/auth/mod.rs\n@@ -70,12 +70,40 @@ pub struct AuthzResource {\n }\n \n #[derive(thiserror::Error, Debug)]\n-#[error(\"Permission denied.\")]\n-pub struct AuthError(pub StatusCode);\n+pub struct AuthError {\n+    pub status_code: StatusCode,\n+    pub message: Option<String>,\n+}\n+\n+impl Display for AuthError {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(\n+            f,\n+            \"{}\",\n+            self.message.as_deref().unwrap_or(\"Permission denied.\")\n+        )\n+    }\n+}\n+\n+impl AuthError {\n+    pub fn new(status_code: StatusCode) -> Self {\n+        Self {\n+            status_code,\n+            message: None,\n+        }\n+    }\n+\n+    pub fn with_message(status_code: StatusCode, message: impl Into<String>) -> Self {\n+        Self {\n+            status_code,\n+            message: Some(message.into()),\n+        }\n+    }\n+}\n \n impl chroma_error::ChromaError for AuthError {\n     fn code(&self) -> chroma_error::ErrorCodes {\n-        match self.0 {\n+        match self.status_code {\n             StatusCode::UNAUTHORIZED => chroma_error::ErrorCodes::Unauthenticated,\n             StatusCode::FORBIDDEN => chroma_error::ErrorCodes::PermissionDenied,\n             _ => chroma_error::ErrorCodes::Internal,\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -235,6 +235,22 @@ impl ServiceBasedFrontend {\n         }\n     }\n \n+    fn _parse_universal_collection_identifier(input: String) -> Option<(String, String, String)> {\n+        let parts: Vec<&str> = input.split('/').collect();\n+        match parts.as_slice() {\n+            [tenant, database, collection]\n+                if !tenant.is_empty() && !database.is_empty() && !collection.is_empty() =>\n+            {\n+                Some((\n+                    tenant.to_string(),\n+                    database.to_string(),\n+                    collection.to_string(),\n+                ))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub async fn reset(&mut self) -> Result<ResetResponse, ResetError> {\n         if !self.allow_reset {\n             return Err(ResetError::NotAllowed);\n@@ -362,12 +378,19 @@ impl ServiceBasedFrontend {\n             ..\n         }: GetCollectionRequest,\n     ) -> Result<GetCollectionResponse, GetCollectionError> {\n+        let (resolved_tenant_id, resolved_database_name, resolved_collection_name) =\n+            Self::_parse_universal_collection_identifier(collection_name.clone()).unwrap_or((\n+                tenant_id.clone(),\n+                database_name.clone(),\n+                collection_name.clone(),\n+            ));\n+\n         let mut collections = self\n             .sysdb_client\n             .get_collections(GetCollectionsOptions {\n-                name: Some(collection_name.clone()),\n-                tenant: Some(tenant_id.clone()),\n-                database: Some(database_name.clone()),\n+                name: Some(resolved_collection_name.clone()),\n+                tenant: Some(resolved_tenant_id.clone()),\n+                database: Some(resolved_database_name.clone()),\n                 limit: Some(1),\n                 ..Default::default()\n             })\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nIt passes -1, but 0 is the first valid log enumeration offset, making 1 the first valid log record.\n\n## Test plan\n\nI'm sending it through CI and will add a test if it passes with the obo corrected.\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.11\"\n+__version__ = \"1.0.12\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.11\"\n+      \"Default\": \"1.0.12\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice B:\nrust/cache/src/foyer.rs\n@@ -492,6 +492,10 @@ where\n         }\n         Ok(res)\n     }\n+\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.cache.contains(key)\n+    }\n }\n \n impl<K, V> super::PersistentCache<K, V> for FoyerHybridCache<K, V>\n@@ -820,4 +824,26 @@ mod test {\n             .expect(\"Value should not be None\");\n         assert_eq!(value, \"foo\");\n     }\n+\n+    #[tokio::test]\n+    async fn test_may_contain() {\n+        let dir = tempfile::tempdir()\n+            .expect(\"To be able to create temp path\")\n+            .path()\n+            .to_str()\n+            .expect(\"To be able to parse path\")\n+            .to_string();\n+        let cache = FoyerCacheConfig {\n+            dir: Some(dir.clone()),\n+            flush: true,\n+            ..Default::default()\n+        }\n+        .build_hybrid_test::<String, String>()\n+        .await\n+        .unwrap();\n+\n+        cache.insert(\"key1\".to_string(), \"foo\".to_string()).await;\n+        assert!(cache.may_contain(&\"key1\".to_string()).await);\n+        assert!(!cache.may_contain(&\"key2\".to_string()).await);\n+    }\n }\n---\nrust/cache/src/lib.rs\n@@ -69,6 +69,11 @@ where\n {\n     async fn insert(&self, key: K, value: V);\n     async fn get(&self, key: &K) -> Result<Option<V>, CacheError>;\n+    // Returns true if the cache contains the key. This method may return a\n+    // false-positive.\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.get(key).await.map(|v| v.is_some()).unwrap_or(false)\n+    }\n     async fn remove(&self, key: &K);\n     async fn clear(&self) -> Result<(), CacheError>;\n     async fn obtain(&self, key: K) -> Result<Option<V>, CacheError>;\n---\n\n\n---\n\nChoice C:\nclients/js/packages/chromadb/package.json\n@@ -50,6 +50,13 @@\n     \"tsup\": \"^7.2.0\",\n     \"typescript\": \"^5.0.4\"\n   },\n+  \"optionalDependencies\": {\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+  },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n   },\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.0.0\"\n+$release = \"cli-1.1.0\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.0.0\"\n+RELEASE=\"cli-1.1.0\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\nrust/cli/src/client/collection.rs\n@@ -130,13 +130,7 @@ impl Collection {\n             self.chroma_client.tenant_id, self.chroma_client.db, self.collection_id\n         );\n \n-        let payload = AddCollectionRecordsPayload {\n-            ids,\n-            embeddings,\n-            documents,\n-            uris,\n-            metadatas,\n-        };\n+        let payload = AddCollectionRecordsPayload::new(ids, embeddings, documents, uris, metadatas);\n \n         let _response = send_request::<AddCollectionRecordsPayload, AddCollectionRecordsResponse>(\n             &self.chroma_client.host,\n---\nrust/cli/src/commands/copy.rs\n@@ -277,7 +277,7 @@ pub fn copy(args: CopyArgs) -> Result<(), CliError> {\n         if !args.all && args.collections.is_empty() {\n             return Err(CopyError::NoCollections.into());\n         }\n-        \n+\n         let (_, profile) = get_current_profile()?;\n         let (source, target) = get_target_and_destination(&args)?;\n         let (source_client, target_client, _handle) =\n---\nrust/frontend/src/server.rs\n@@ -1252,11 +1252,29 @@ async fn fork_collection(\n \n #[derive(Serialize, Deserialize, ToSchema, Debug, Clone)]\n pub struct AddCollectionRecordsPayload {\n-    pub ids: Vec<String>,\n-    pub embeddings: Option<Vec<Vec<f32>>>,\n-    pub documents: Option<Vec<Option<String>>>,\n-    pub uris: Option<Vec<Option<String>>>,\n-    pub metadatas: Option<Vec<Option<Metadata>>>,\n+    ids: Vec<String>,\n+    embeddings: Option<Vec<Vec<f32>>>,\n+    documents: Option<Vec<Option<String>>>,\n+    uris: Option<Vec<Option<String>>>,\n+    metadatas: Option<Vec<Option<Metadata>>>,\n+}\n+\n+impl AddCollectionRecordsPayload {\n+    pub fn new(\n+        ids: Vec<String>,\n+        embeddings: Option<Vec<Vec<f32>>>,\n+        documents: Option<Vec<Option<String>>>,\n+        uris: Option<Vec<Option<String>>>,\n+        metadatas: Option<Vec<Option<Metadata>>>,\n+    ) -> Self {\n+        Self {\n+            ids,\n+            embeddings,\n+            documents,\n+            uris,\n+            metadatas,\n+        }\n+    }\n }\n \n /// Adds records to a collection.\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\nChoice D:\nrust/log/src/local_compaction_manager.rs\n@@ -171,7 +171,7 @@ impl Handler<BackfillMessage> for LocalCompactionManager {\n                 &collection_and_segments.collection.tenant,\n                 collection_and_segments.collection.collection_id,\n                 mt_max_seq_id.min(hnsw_max_seq_id) as i64,\n-                -1,\n+                0,\n                 None,\n             )\n             .await\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - N/A\n- New functionality\n  - Support regex filtering for local chroma\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -1219,17 +1219,16 @@ impl LogService for LogServer {\n             let witness = cursors.load(cursor_name).await.map_err(|err| {\n                 Status::new(err.code().into(), format!(\"Failed to load cursor: {}\", err))\n             })?;\n-            // This is the existing compaction_offset, which is the last record that was compacted.\n+            // This is the existing compaction_offset, which is the next record to compact.\n             let offset = witness\n                 .map(|x| x.1.position)\n-                .unwrap_or(LogPosition::from_offset(0));\n+                .unwrap_or(LogPosition::from_offset(1));\n             tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n                 &log_reader,\n-                // + 1 to get to the first uncompacted record.\n-                offset + 1u64,\n+                offset,\n                 target_prefix.clone(),\n             )\n             .await\n@@ -1253,7 +1252,9 @@ impl LogService for LogServer {\n             }\n             tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n-                compaction_offset: offset.offset(),\n+                // NOTE: The upstream service expects the last compacted offset as compaction offset\n+                compaction_offset: (offset - 1u64).offset(),\n+                // NOTE: The upstream service expects the last uncompacted offset as enumeration offset\n                 enumeration_offset: (max_offset - 1u64).offset(),\n             }))\n         }\n---\n\n\n---\n\nChoice B:\nCargo.lock\n@@ -7563,6 +7563,7 @@ dependencies = [\n  \"libsqlite3-sys\",\n  \"log\",\n  \"percent-encoding\",\n+ \"regex\",\n  \"serde\",\n  \"serde_urlencoded\",\n  \"sqlx-core\",\n---\nchromadb/test/property/test_filtering.py\n@@ -6,6 +6,7 @@\n from chromadb.test.property import invariants\n from chromadb.api.types import (\n     Document,\n+    Documents,\n     Embedding,\n     Embeddings,\n     GetResult,\n@@ -566,3 +567,33 @@ def test_query_ids_filter_property(\n     # Also check that the number of results is reasonable\n     assert len(result_ids) <= n_results\n     assert len(result_ids) <= len(filter_ids_set)\n+\n+\n+def test_regex(client: ClientAPI) -> None:\n+    \"\"\"Tests that regex works\"\"\"\n+\n+    reset(client)\n+    coll = client.create_collection(name=\"test\")\n+\n+    test_ids: IDs = [\"1\", \"2\", \"3\"]\n+    test_documents: Documents = [\"cat\", \"Cat\", \"CAT\"]\n+    test_embeddings: Embeddings = [np.array([1, 1]), np.array([2, 2]), np.array([3, 3])]\n+    test_metadatas: Metadatas = [{\"test\": 10}, {\"test\": 20}, {\"test\": 30}]\n+\n+    coll.add(\n+        ids=test_ids,\n+        documents=test_documents,\n+        embeddings=test_embeddings,\n+        metadatas=test_metadatas,\n+    )\n+\n+    res = coll.get(where_document={\"$regex\": \"cat\"})\n+    assert res[\"ids\"] == [\"1\"]\n+\n+    res = coll.get(where_document={\"$regex\": \"(?i)cat\"})\n+    assert sorted(res[\"ids\"]) == [\"1\", \"2\", \"3\"]\n+\n+    res = coll.get(\n+        where={\"test\": {\"$ne\": 10}}, where_document={\"$regex\": \"(?i)c(?-i)at\"}  # type: ignore[dict-item]\n+    )\n+    assert res[\"ids\"] == [\"2\"]\n---\nrust/segment/src/sqlite_metadata.rs\n@@ -523,16 +523,27 @@ impl IntoSqliteExpr for DocumentExpression {\n         let subq = Query::select()\n             .column(EmbeddingFulltextSearch::Rowid)\n             .from(EmbeddingFulltextSearch::Table)\n-            .and_where(\n-                Expr::col(EmbeddingFulltextSearch::StringValue)\n-                    .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\"))),\n-            )\n+            .and_where(match self.operator {\n+                DocumentOperator::Contains | DocumentOperator::NotContains => {\n+                    Expr::col(EmbeddingFulltextSearch::StringValue)\n+                        .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n+                }\n+                DocumentOperator::Regex | DocumentOperator::NotRegex => Expr::cust_with_exprs(\n+                    \"? REGEXP ?\",\n+                    [\n+                        Expr::col(EmbeddingFulltextSearch::StringValue).into(),\n+                        Expr::value(&self.pattern),\n+                    ],\n+                ),\n+            })\n             .to_owned();\n         match self.operator {\n-            DocumentOperator::Contains => Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq),\n-            DocumentOperator::NotContains => Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq),\n-            DocumentOperator::Regex => todo!(\"Implement Regex matching. The result must be a not-nullable boolean (use `<expr>.is(true)`)\"),\n-            DocumentOperator::NotRegex => todo!(\"Implement negated Regex matching. This must be exact opposite of Regex matching (use `<expr>.not()`)\"),\n+            DocumentOperator::Contains | DocumentOperator::Regex => {\n+                Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n+            }\n+            DocumentOperator::NotContains | DocumentOperator::NotRegex => {\n+                Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq)\n+            }\n         }\n     }\n }\n---\nrust/sqlite/Cargo.toml\n@@ -9,7 +9,7 @@ regex = { workspace = true }\n sea-query = { workspace = true, features = [\"derive\"] }\n sea-query-binder = { workspace = true, features = [\"sqlx-sqlite\"] }\n sha2 = { workspace = true }\n-sqlx = { workspace = true }\n+sqlx = { workspace = true, features = [\"regexp\"] }\n tempfile = { workspace = true }\n pyo3 = { workspace = true, optional = true }\n thiserror = { workspace = true }\n@@ -22,4 +22,3 @@ rust-embed = { workspace = true }\n chroma-error = { workspace = true, features = [\"sqlx\"] }\n chroma-types = { workspace = true }\n chroma-config = { workspace = true }\n-\n---\nrust/sqlite/src/config.rs\n@@ -104,7 +104,8 @@ impl Configurable<SqliteDBConfig, SqliteCreationError> for SqliteDb {\n             // we turn it off\n             .pragma(\"foreign_keys\", \"OFF\")\n             .pragma(\"case_sensitive_like\", \"ON\")\n-            .busy_timeout(Duration::from_secs(1000));\n+            .busy_timeout(Duration::from_secs(1000))\n+            .with_regexp();\n         let conn = if let Some(url) = &config.url {\n             let path = Path::new(url);\n             if let Some(parent) = path.parent() {\n---\n\n\n---\n\nChoice C:\n.github/workflows/_rust-tests.yml\n@@ -7,7 +7,7 @@ jobs:\n   test:\n     strategy:\n       matrix:\n-        platform: [blacksmith-4vcpu-ubuntu-2204]\n+        platform: [blacksmith-8vcpu-ubuntu-2204]\n     runs-on: ${{ matrix.platform }}\n     env:\n       CARGO_TERM_COLOR: always\n@@ -22,9 +22,9 @@ jobs:\n       - name: Build CLI\n         run: cargo build --bin chroma\n       - name: Test\n-        run: cargo nextest run --no-capture --profile ci\n+        run: cargo nextest run --profile ci\n   test-long:\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n+    runs-on: blacksmith-8vcpu-ubuntu-2204\n     env:\n       CARGO_TERM_COLOR: always\n       RUST_BACKTRACE: 1\n@@ -35,10 +35,8 @@ jobs:\n         uses: ./.github/actions/rust\n         with:\n           github-token: ${{ github.token }}\n-      - name: Build CLI\n-        run: cargo build --bin chroma\n       - name: Test\n-        run: cargo nextest run --no-capture --profile ci_long_running\n+        run: cargo nextest run --profile ci_long_running\n \n   test-integration:\n     strategy:\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.10\"\n+__version__ = \"1.0.11\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.10\"\n+      \"Default\": \"1.0.11\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nIt would add and delete items in such a way that it's theoretically\npossible to have a version increase before checking the current version.\nWaiting for \"current\", then, actually begs the question and waits for\nitself.\n\n## Test plan\n\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nTiltfile\n@@ -92,7 +92,7 @@ else:\n   docker_build(\n     'frontend-service',\n     '.',\n-    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/'],\n+    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/', 'Cargo.toml', 'Cargo.lock', 'rust/', 'pyproject.toml', 'README.md'],\n     dockerfile='./Dockerfile',\n     ignore=['**/*.pyc', 'chromadb/test/'],\n   )\n---\n\n\n---\n\nChoice B:\nrust/storage/src/admissioncontrolleds3.rs\n@@ -548,9 +548,19 @@ impl CountBasedPolicy {\n             match &mut channel_receiver {\n                 Some(rx) => {\n                     select! {\n-                        _ = rx.recv() => {\n+                        did_recv = rx.recv() => {\n                             // Reevaluate priority if we got a notification.\n-                            continue;\n+                            match did_recv {\n+                                Some(_) => {\n+                                    // If we got a notification, continue to acquire.\n+                                    continue;\n+                                }\n+                                None => {\n+                                    // If the channel was closed, break out of the loop.\n+                                    channel_receiver = None;\n+                                    continue;\n+                                }\n+                            }\n                         }\n                         token = self.remaining_tokens[current_priority.as_usize()].acquire() => {\n                             match token {\n---\nrust/worker/src/execution/operators/prefetch_record.rs\n@@ -6,7 +6,7 @@ use chroma_segment::{\n     blockfile_record::{RecordSegmentReader, RecordSegmentReaderCreationError},\n     types::{materialize_logs, LogMaterializerError},\n };\n-use chroma_system::Operator;\n+use chroma_system::{Operator, OperatorType};\n use thiserror::Error;\n use tracing::{trace, Instrument, Span};\n \n@@ -94,4 +94,8 @@ impl Operator<PrefetchRecordInput, PrefetchRecordOutput> for PrefetchRecordOpera\n     fn errors_when_sender_dropped(&self) -> bool {\n         false\n     }\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n }\n---\n\n\n---\n\nChoice C:\nchromadb/test/distributed/test_sanity.py\n@@ -67,6 +67,7 @@ def test_add_include_all_with_compaction_delay(client: ClientAPI) -> None:\n         name=\"test_add_include_all_with_compaction_delay\",\n         metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n     )\n+    initial_version = get_collection_version(client, collection.name)\n \n     ids = []\n     embeddings = []\n@@ -81,7 +82,7 @@ def test_add_include_all_with_compaction_delay(client: ClientAPI) -> None:\n             documents=[documents[-1]],\n         )\n \n-    wait_for_version_increase(client, collection.name, get_collection_version(client, collection.name), 120)\n+    wait_for_version_increase(client, collection.name, initial_version, 120)\n \n     random_query_1 = np.random.rand(1, 3)[0]\n     random_query_2 = np.random.rand(1, 3)[0]\n---\nchromadb/test/property/test_embeddings.py\n@@ -1420,11 +1420,12 @@ def test_0dim_embedding_validation() -> None:\n def test_no_op_compaction(client: ClientAPI) -> None:\n     reset(client)\n     coll = client.create_collection(name=\"noop\")\n+    initial_version = get_collection_version(client, coll.name)\n     for batch in range(0, 5000, 100):\n         coll.delete(ids=[str(i) for i in range(batch, batch + 100)])\n     if not NOT_CLUSTER_ONLY:\n         wait_for_version_increase(\n-            client, coll.name, get_collection_version(client, coll.name), VERSION_INCREASE_WAIT_TIME\n+            client, coll.name, initial_version, VERSION_INCREASE_WAIT_TIME\n         )\n \n \n@@ -1433,6 +1434,7 @@ def test_add_then_purge(client: ClientAPI) -> None:\n     record_count = 5000\n     batch_count = 100\n     coll = client.create_collection(name=\"add_then_purge\")\n+    witness_version = get_collection_version(client, coll.name)\n \n     # Add records and wait for compaction\n     for batch in range(0, record_count, batch_count):\n@@ -1443,17 +1445,18 @@ def test_add_then_purge(client: ClientAPI) -> None:\n         )\n     if not NOT_CLUSTER_ONLY:\n         wait_for_version_increase(\n-            client, coll.name, get_collection_version(client, coll.name), VERSION_INCREASE_WAIT_TIME\n+            client, coll.name, witness_version, VERSION_INCREASE_WAIT_TIME\n         )\n \n     # Purge records and wait for compaction\n+    witness_version = get_collection_version(client, coll.name)\n     for batch in range(0, record_count, batch_count):\n         record_id_vals = [i for i in range(batch, batch + batch_count)]\n         record_ids = [str(i) for i in record_id_vals]\n         coll.delete(ids=record_ids)\n     if not NOT_CLUSTER_ONLY:\n         wait_for_version_increase(\n-            client, coll.name, get_collection_version(client, coll.name), VERSION_INCREASE_WAIT_TIME\n+            client, coll.name, witness_version, VERSION_INCREASE_WAIT_TIME\n         )\n \n     # There should be no records left\n@@ -1464,6 +1467,7 @@ def test_encompassing_delete(client: ClientAPI) -> None:\n     reset(client)\n \n     col = client.create_collection(\"encompassing_delete\")\n+    initial_version = get_collection_version(client, col.name)\n \n     id_start = 0\n     # Add and then Delete 6 records\n@@ -1476,8 +1480,9 @@ def test_encompassing_delete(client: ClientAPI) -> None:\n \n     if not NOT_CLUSTER_ONLY:\n         wait_for_version_increase(\n-            client, col.name, get_collection_version(client, col.name), VERSION_INCREASE_WAIT_TIME\n+            client, col.name, initial_version, VERSION_INCREASE_WAIT_TIME\n         )\n+    initial_version = get_collection_version(client, col.name)\n \n     # Add and then delete and then add 16\n     len_to_add = 16\n@@ -1490,7 +1495,7 @@ def test_encompassing_delete(client: ClientAPI) -> None:\n \n     if not NOT_CLUSTER_ONLY:\n         wait_for_version_increase(\n-            client, col.name, get_collection_version(client, col.name), VERSION_INCREASE_WAIT_TIME\n+            client, col.name, initial_version, VERSION_INCREASE_WAIT_TIME\n         )\n \n     # Ensure we can get all\n---\n\n\n---\n\nChoice D:\nrust/tracing/src/init_tracer.rs\n@@ -33,6 +33,7 @@ pub fn init_global_filter_layer() -> Box<dyn Layer<Registry> + Send + Sync> {\n                 \"distance_metrics\",\n                 \"full_text\",\n                 \"hosted-frontend\",\n+                \"billing_service\",\n                 \"metadata_filtering\",\n                 \"query_service\",\n                 \"wal3\",\n@@ -146,7 +147,7 @@ pub fn init_stdout_layer() -> Box<dyn Layer<Registry> + Send + Sync> {\n                 || metadata\n                     .module_path()\n                     .unwrap_or(\"\")\n-                    .starts_with(\"hosted-frontend\")\n+                    .starts_with(\"billing_service\")\n         }))\n         .with_filter(tracing_subscriber::filter::LevelFilter::INFO)\n         .boxed()\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Reduce default NUM_FORKS quota from 10000 to 256\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/frontend/src/server.rs\n@@ -915,57 +915,67 @@ async fn create_collection(\n     let payload_clone = payload.clone();\n \n     let configuration = if !server.config.enable_set_index_params {\n-        let mut new_configuration = payload.configuration.clone().unwrap();\n-        let hnsw_config = new_configuration.hnsw.clone();\n-        let spann_config = new_configuration.spann.clone();\n-\n-        if let Some(hnsw) = &hnsw_config {\n-            let space = hnsw.space.clone();\n-            if hnsw.ef_construction.is_some()\n-                || hnsw.ef_search.is_some()\n-                || hnsw.max_neighbors.is_some()\n-                || hnsw.num_threads.is_some()\n-                || hnsw.resize_factor.is_some()\n-                || hnsw.sync_threshold.is_some()\n-                || hnsw.batch_size.is_some()\n-            {\n-                return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n-                    \"HNSW\".to_string(),\n-                )\n-                .into());\n+        if let Some(mut new_configuration) = payload.configuration.clone() {\n+            let hnsw_config = new_configuration.hnsw.clone();\n+            let spann_config = new_configuration.spann.clone();\n+\n+            if let Some(hnsw) = &hnsw_config {\n+                let space = hnsw.space.clone();\n+                if hnsw.ef_construction.is_some()\n+                    || hnsw.ef_search.is_some()\n+                    || hnsw.max_neighbors.is_some()\n+                    || hnsw.num_threads.is_some()\n+                    || hnsw.resize_factor.is_some()\n+                    || hnsw.sync_threshold.is_some()\n+                    || hnsw.batch_size.is_some()\n+                {\n+                    return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n+                        \"HNSW\".to_string(),\n+                    )\n+                    .into());\n+                }\n+                let new_hnsw = HnswConfiguration {\n+                    space,\n+                    ..Default::default()\n+                };\n+                new_configuration.hnsw = Some(new_hnsw);\n+            } else if let Some(spann) = &spann_config {\n+                let space = spann.space.clone();\n+                if spann.search_nprobe.is_some()\n+                    || spann.write_nprobe.is_some()\n+                    || spann.ef_construction.is_some()\n+                    || spann.ef_search.is_some()\n+                    || spann.max_neighbors.is_some()\n+                    || spann.reassign_neighbor_count.is_some()\n+                    || spann.split_threshold.is_some()\n+                    || spann.merge_threshold.is_some()\n+                {\n+                    return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n+                        \"SPANN\".to_string(),\n+                    )\n+                    .into());\n+                }\n+                let new_spann = SpannConfiguration {\n+                    space,\n+                    ..Default::default()\n+                };\n+                new_configuration.spann = Some(new_spann);\n             }\n-            let new_hnsw = HnswConfiguration {\n-                space,\n-                ..Default::default()\n-            };\n-            new_configuration.hnsw = Some(new_hnsw);\n-        } else if let Some(spann) = &spann_config {\n-            let space = spann.space.clone();\n-            if spann.search_nprobe.is_some()\n-                || spann.write_nprobe.is_some()\n-                || spann.ef_construction.is_some()\n-                || spann.ef_search.is_some()\n-                || spann.max_neighbors.is_some()\n-                || spann.reassign_neighbor_count.is_some()\n-                || spann.split_threshold.is_some()\n-                || spann.merge_threshold.is_some()\n-            {\n-                return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n-                    \"SPANN\".to_string(),\n-                )\n-                .into());\n-            }\n-            let new_spann = SpannConfiguration {\n-                space,\n-                ..Default::default()\n-            };\n-            new_configuration.spann = Some(new_spann);\n-        }\n \n-        Some(InternalCollectionConfiguration::try_from_config(\n-            new_configuration,\n-            server.config.frontend.default_knn_index,\n-        )?)\n+            Some(InternalCollectionConfiguration::try_from_config(\n+                new_configuration,\n+                server.config.frontend.default_knn_index,\n+            )?)\n+        } else {\n+            Some(InternalCollectionConfiguration::try_from_config(\n+                CollectionConfiguration {\n+                    hnsw: None,\n+                    spann: None,\n+                    embedding_function: None,\n+                },\n+                server.config.frontend.default_knn_index,\n+            )?)\n+        }\n     } else {\n         match payload_clone.configuration {\n             Some(c) => Some(InternalCollectionConfiguration::try_from_config(\n---\n\n\n---\n\nChoice B:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionWithoutMetadata(collectionID *string, databaseName *string, softDeletedFlag *bool) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, NULLIF(collections.root_collection_id, '') AS root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\nChoice C:\nrust/frontend/src/quota/mod.rs\n@@ -337,7 +337,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n         m.insert(UsageType::RegexPatternLength, 0);\n-        m.insert(UsageType::NumForks, 10000);\n+        m.insert(UsageType::NumForks, 256);\n         m\n     };\n }\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.7\"\n+__version__ = \"1.0.8\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.7\"\n+      \"Default\": \"1.0.8\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n[RELEASE] 1.0.9\n\n---\n\nChoice A:\n.github/workflows/release-chromadb.yml\n@@ -220,7 +220,7 @@ jobs:\n                 // - This workflow finishes for A and deploys A to Chroma Cloud\n                 // Chroma Cloud is now running A, but the last commit was B.\n                 \"environment\": \"staging\",\n-                \"planes\": \"data,control\"\n+                \"planes\": \"control,data\"\n               }\n             })\n \n---\n.github/workflows/trigger-deploy.yaml\n@@ -5,8 +5,9 @@ on:\n   push:\n     branches:\n       # main is not included here because it is handled by the release-chromadb.yaml workflow\n+      # production deploys (release branches) are also not here because they are currently\n+      # meant to be handled manually.\n       - rc/**-**-**\n-      - release/**-**-**\n \n jobs:\n   deploy:\n@@ -25,7 +26,7 @@ jobs:\n               ref: 'main',\n               inputs: {\n                 'planes': 'control,data',\n-                 environment: '${{ contains(github.ref, 'release/') && 'production' || 'staging' }}',\n+                 environment: 'staging',\n                 'ignore-lock': true,\n                 'oss-ref': '${{ github.ref_name }}',\n                 'hosted-ref': '${{ github.ref_name }}'\n---\n\n\n---\n\nChoice B:\nrust/segment/src/sqlite_metadata.rs\n@@ -482,8 +482,9 @@ impl IntoSqliteExpr for DocumentExpression {\n             EmbeddingFulltextSearch::StringValue,\n         ));\n         let doc_contains = doc_col\n+            .clone()\n             .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .is(true);\n+            .and(doc_col.is_not_null());\n         match self.operator {\n             DocumentOperator::Contains => doc_contains,\n             DocumentOperator::NotContains => doc_contains.not(),\n@@ -495,9 +496,11 @@ impl IntoSqliteExpr for DocumentExpression {\n \n impl IntoSqliteExpr for MetadataExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let key_cond = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key))\n+        let key_col = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key));\n+        let key_cond = key_col\n+            .clone()\n             .eq(self.key.to_string())\n-            .is(true);\n+            .and(key_col.is_not_null());\n         match &self.comparison {\n             MetadataComparison::Primitive(op, val) => {\n                 let (col, sval) = match val {\n@@ -668,21 +671,28 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            filter_limit_query\n-                .left_join(\n-                    EmbeddingMetadata::Table,\n-                    Expr::col((Embeddings::Table, Embeddings::Id))\n-                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n-                )\n-                .left_join(\n+            let (has_document_expr, has_metadata_expr) = match whr {\n+                Where::Composite(expr) => expr.has_document_and_metadata(),\n+                Where::Document(_) => (true, false),\n+                Where::Metadata(_) => (false, true),\n+            };\n+            if has_document_expr {\n+                filter_limit_query.left_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n-                )\n-                .distinct()\n-                .cond_where(whr.eval());\n+                );\n+            }\n+            if has_metadata_expr {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            };\n+            filter_limit_query.distinct().cond_where(whr.eval());\n         }\n \n         filter_limit_query\n---\nrust/types/src/metadata.rs\n@@ -560,6 +560,24 @@ impl Where {\n             },\n         }\n     }\n+\n+    // expression_check is a helper function to identify whether a given Where clause contains\n+    // a document or metadata predicate. It recursively checks the children of a composite expression.\n+    fn expression_check(&self, has_document_expr: &mut bool, has_metadata_expr: &mut bool) {\n+        match self {\n+            Where::Composite(composite) => {\n+                for child in composite.children.iter() {\n+                    child.expression_check(has_document_expr, has_metadata_expr);\n+\n+                    if *has_document_expr && *has_metadata_expr {\n+                        return;\n+                    }\n+                }\n+            }\n+            Where::Document(_) => *has_document_expr = true,\n+            Where::Metadata(_) => *has_metadata_expr = true,\n+        }\n+    }\n }\n \n impl TryFrom<chroma_proto::Where> for Where {\n@@ -611,6 +629,26 @@ pub struct CompositeExpression {\n     pub children: Vec<Where>,\n }\n \n+impl CompositeExpression {\n+    pub fn has_document_and_metadata(&self) -> (bool, bool) {\n+        let mut has_document_expr = false;\n+        let mut has_metadata_expr = false;\n+        self.expression_check(&mut has_document_expr, &mut has_metadata_expr);\n+        (has_document_expr, has_metadata_expr)\n+    }\n+\n+    // expression_check is an extension of the Where expression_check function, just for\n+    // CompositeExpression\n+    fn expression_check(&self, has_document_expr: &mut bool, has_metadata_expr: &mut bool) {\n+        for child in self.children.iter() {\n+            child.expression_check(has_document_expr, has_metadata_expr);\n+            if *has_document_expr && *has_metadata_expr {\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n impl TryFrom<chroma_proto::WhereChildren> for CompositeExpression {\n     type Error = WhereConversionError;\n \n---\n\n\n---\n\nChoice C:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.8\"\n+__version__ = \"1.0.9\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\n\n\n---\n\nChoice D:\nrust/js_bindings/Cargo.toml\n@@ -14,7 +14,3 @@ chroma-cli = { workspace = true }\n \n [build-dependencies]\n napi-build = \"2.0.1\"\n-\n-[profile.release]\n-lto = true\n-strip = \"symbols\"\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nCherry-pick of https://github.com/chroma-core/chroma/pull/4518 onto the rc branch.\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -830,12 +836,15 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice B:\nrust/segment/src/sqlite_metadata.rs\n@@ -579,17 +579,17 @@ impl IntoSqliteExpr for CompositeExpression {\n \n impl IntoSqliteExpr for DocumentExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let doc_col = Expr::col((\n-            EmbeddingFulltextSearch::Table,\n-            EmbeddingFulltextSearch::StringValue,\n-        ));\n-        let doc_contains = doc_col\n-            .clone()\n-            .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .and(doc_col.is_not_null());\n+        let subq = Query::select()\n+            .column(EmbeddingFulltextSearch::Rowid)\n+            .from(EmbeddingFulltextSearch::Table)\n+            .and_where(\n+                Expr::col(EmbeddingFulltextSearch::StringValue)\n+                    .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\"))),\n+            )\n+            .to_owned();\n         match self.operator {\n-            DocumentOperator::Contains => doc_contains,\n-            DocumentOperator::NotContains => doc_contains.not(),\n+            DocumentOperator::Contains => Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq),\n+            DocumentOperator::NotContains => Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq),\n             DocumentOperator::Regex => todo!(\"Implement Regex matching. The result must be a not-nullable boolean (use `<expr>.is(true)`)\"),\n             DocumentOperator::NotRegex => todo!(\"Implement negated Regex matching. This must be exact opposite of Regex matching (use `<expr>.not()`)\"),\n         }\n@@ -805,20 +805,11 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            let (has_document_expr, has_metadata_expr) = match whr {\n+            let (_, has_metadata_expr) = match whr {\n                 Where::Composite(expr) => expr.has_document_and_metadata(),\n                 Where::Document(_) => (true, false),\n                 Where::Metadata(_) => (false, true),\n             };\n-            if has_document_expr {\n-                filter_limit_query.left_join(\n-                    EmbeddingFulltextSearch::Table,\n-                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n-                        EmbeddingFulltextSearch::Table,\n-                        EmbeddingFulltextSearch::Rowid,\n-                    )),\n-                );\n-            }\n             if has_metadata_expr {\n                 filter_limit_query.left_join(\n                     EmbeddingMetadata::Table,\n---\n\n\n---\n\nChoice C:\nclients/new-js/packages/chromadb/src/utils.ts\n@@ -350,7 +350,8 @@ export const validateWhere = (where: Where) => {\n         );\n       }\n \n-      Object.values(where).forEach((w: Where) => validateWhere(w));\n+      value.forEach((w: Where) => validateWhere(w));\n+      return;\n     }\n \n     if (typeof value === \"object\") {\n---\n\n\n---\n\nChoice D:\nrust/load/src/lib.rs\n@@ -1271,13 +1271,11 @@ impl LoadService {\n             for declared in declared {\n                 if let Entry::Vacant(entry) = running.entry(declared.uuid) {\n                     tracing::info!(\"spawning workload {}\", declared.uuid);\n-                    let root = tracing::info_span!(parent: None, \"workload\");\n                     let this = Arc::clone(self);\n                     let done = Arc::new(AtomicBool::new(false));\n                     let done_p = Arc::clone(&done);\n                     let inhibit = Arc::clone(&self.inhibit);\n                     let task = tokio::task::spawn(async move {\n-                        let _enter = root.enter();\n                         this.run_one_workload(done, inhibit, declared).await\n                     });\n                     entry.insert((done_p, task));\n@@ -1295,36 +1293,6 @@ impl LoadService {\n         let client = Arc::new(client(spec.connection.clone()).await);\n         let mut guac = Guacamole::new(spec.expires.timestamp_millis() as u64);\n         let mut next_op = Instant::now();\n-        let (tx, mut rx) = tokio::sync::mpsc::channel(1000);\n-        let _ = tx\n-            .send(tokio::spawn(async move { Ok::<(), Error>(()) }))\n-            .await;\n-        let this = Arc::clone(&self);\n-        let data_set = Arc::clone(&spec.data_set);\n-        let reaper = tokio::spawn(async move {\n-            while let Some(task) = rx.recv().await {\n-                if let Err(err) = task.await.unwrap() {\n-                    if !format!(\"{err:?}\").contains(\"429\") {\n-                        this.metrics.failed.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                        tracing::error!(\"workload task failed: {err:?}\");\n-                    } else {\n-                        this.metrics.limited.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                    }\n-                }\n-            }\n-        });\n \n         // Initialize the data set.\n         let data_set = Arc::clone(&spec.data_set);\n@@ -1408,30 +1376,45 @@ impl LoadService {\n                         .await\n                         .map_err(|err| Error::FailWorkload(err.to_string()))\n                     {\n-                        Ok(()) => Ok(()),\n+                        Ok(()) => (),\n                         Err(err) => {\n-                            if err.to_string().contains(\"invalid request: No results\") {\n+                            if format!(\"{err:?}\").contains(\"invalid request: No results\") {\n                                 this.metrics.no_results.add(\n                                     1,\n                                     &[KeyValue::new(\n                                         Key::from_static_str(\"data_set\"),\n                                         Value::from(data_set.name()),\n                                     )],\n                                 );\n-                                Ok(())\n+                                tracing::warn!(\"workload step no results: {err:?}\");\n+                            } else if !format!(\"{err:?}\").contains(\"429\") {\n+                                this.metrics.failed.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::error!(\"workload step failed: {err:?}\");\n                             } else {\n-                                Err(err)\n+                                this.metrics.limited.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::warn!(\"workload step rate limited: {err:?}\");\n                             }\n                         }\n-                    }\n+                    };\n                 };\n-                tx.send(tokio::spawn(fut)).await.unwrap();\n+                let span = tracing::info_span!(parent: None, \"step\", workload_uuid = %spec.uuid);\n+                tokio::spawn(fut.instrument(span));\n             }\n         }\n         // Not an error, just needs to show up in stdout.\n         tracing::error!(\"workload done: {}/{}\", spec.name, spec.description());\n-        drop(tx);\n-        reaper.await.unwrap();\n     }\n \n     fn load_persistent(&self) -> Result<(), Error> {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n\r\n\r\n## Description of changes\r\n\r\nRemove the parent \"workload\" trace for the entire workload. It's too long-lasting, and contains too many sub-spans. Instead, generate a \"step\" root trace for each workload step. Events for each workload step will be associated with the step's root trace.\r\n\r\nThis will make spans easier to read, and debug.\r\n\r\n## Test plan\r\n\r\nTested locally via tilt and jaeger.\r\n\r\n## Documentation Changes\r\n\r\nN/A\r\n\n\n---\n\nChoice A:\nrust/wal3/src/writer.rs\n@@ -518,9 +518,7 @@ impl OnceLogWriter {\n             log_position,\n             messages,\n         );\n-        let fut2 = self\n-            .mark_dirty\n-            .mark_dirty(log_position + messages_len, messages_len);\n+        let fut2 = self.mark_dirty.mark_dirty(log_position, messages_len);\n         let (res1, res2) = futures::future::join(fut1, fut2).await;\n         res2?;\n         let (path, setsum, num_bytes) = res1?;\n---\n\n\n---\n\nChoice B:\nk8s/test/minio.yaml\n@@ -16,7 +16,9 @@ spec:\n     spec:\n       volumes:\n         - name: minio\n-          emptyDir: {}\n+          emptyDir:\n+            medium: Memory\n+            sizeLimit: 2Gi\n       containers:\n         - name: minio\n           image: minio/minio:latest\n@@ -46,7 +48,7 @@ metadata:\n spec:\n   ports:\n     - name: http\n-    # Put the lb on a different port so we can run minio locally since the port is already in use\n+      # Put the lb on a different port so we can run minio locally since the port is already in use\n       port: 9001\n       targetPort: 9000\n   selector:\n---\nrust/garbage_collector/src/operators/delete_unused_files.rs\n@@ -147,27 +147,30 @@ impl Operator<DeleteUnusedFilesInput, DeleteUnusedFilesOutput> for DeleteUnusedF\n             CleanupMode::Delete | CleanupMode::DeleteV2 => {\n                 // Hard delete - remove the file\n                 if !all_files.is_empty() {\n-                    let mut delete_stream = futures::stream::iter(all_files.clone())\n-                        .map(move |file_path| self.delete_with_path(file_path))\n-                        .buffer_unordered(100);\n-\n-                    // Process any errors that occurred\n-                    while let Some(result) = delete_stream.next().await {\n-                        if let Err(e) = result {\n-                            match e {\n-                                StorageError::NotFound { path, source } => {\n-                                    tracing::info!(\"Rename file {path} not found: {source}\")\n-                                }\n-                                err => tracing::error!(\"Failed to delete: {err}\"),\n-                            }\n-                        }\n-                    }\n+                    // let mut delete_stream = futures::stream::iter(all_files.clone())\n+                    //     .map(move |file_path| self.delete_with_path(file_path))\n+                    //     .buffer_unordered(100);\n+\n+                    // // Process any errors that occurred\n+                    // while let Some(result) = delete_stream.next().await {\n+                    //     if let Err(e) = result {\n+                    //         match e {\n+                    //             StorageError::NotFound { path, source } => {\n+                    //                 tracing::info!(\"Rename file {path} not found: {source}\")\n+                    //             }\n+                    //             err => tracing::error!(\"Failed to delete: {err}\"),\n+                    //         }\n+                    //     }\n+                    // }\n+\n+                    self.storage.delete_many(all_files).await.unwrap();\n                 }\n             }\n         }\n \n         Ok(DeleteUnusedFilesOutput {\n-            deleted_files: all_files.into_iter().collect(),\n+            // deleted_files: all_files.into_iter().collect(),\n+            deleted_files: HashSet::new(),\n         })\n     }\n }\n---\nrust/storage/src/lib.rs\n@@ -302,6 +302,15 @@ impl Storage {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        match self {\n+            Storage::ObjectStore(object_store) => object_store.delete_many(keys).await,\n+            Storage::S3(s3) => s3.delete_many(keys).await,\n+            Storage::Local(_) => unimplemented!(),\n+            Storage::AdmissionControlledS3(_) => unimplemented!(),\n+        }\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         match self {\n             Storage::ObjectStore(object_store) => object_store.rename(src_key, dst_key).await,\n---\nrust/storage/src/object_store.rs\n@@ -284,6 +284,30 @@ impl ObjectStore {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        let mut locations = Vec::new();\n+        for key in keys {\n+            locations.push(Ok(Path::from(key)));\n+        }\n+\n+        let mut stream = self\n+            .object_store\n+            .delete_stream(futures::stream::iter(locations).boxed());\n+\n+        while let Some(result) = stream.next().await {\n+            match result {\n+                Ok(_) => {\n+                    tracing::info!(\"Successfully deleted object\");\n+                }\n+                Err(e) => {\n+                    tracing::error!(error = %e, \"Failed to delete object\");\n+                    return Err(e.into());\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         tracing::info!(src = %src_key, dst = %dst_key, \"Renaming object\");\n \n---\nrust/storage/src/s3.rs\n@@ -647,6 +647,49 @@ impl S3Storage {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        tracing::debug!(keys = ?keys, \"Deleting multiple objects from S3\");\n+\n+        // batch by 1000 keys as per S3 limits\n+        let mut futures = Vec::new();\n+        for chunk in keys.chunks(1000) {\n+            let delete_req = self.client.delete_objects().bucket(&self.bucket).delete(\n+                aws_sdk_s3::types::Delete::builder()\n+                    .set_objects(Some(\n+                        chunk\n+                            .iter()\n+                            .map(|key| {\n+                                aws_sdk_s3::types::ObjectIdentifier::builder()\n+                                    .key(key)\n+                                    .build()\n+                                    .unwrap()\n+                            })\n+                            .collect::<Vec<_>>(),\n+                    ))\n+                    .build()\n+                    .unwrap(),\n+            );\n+\n+            futures.push(delete_req.send());\n+        }\n+        let results = futures::future::join_all(futures).await;\n+        for res in results {\n+            match res {\n+                Ok(_) => {\n+                    tracing::debug!(\"Successfully deleted objects from S3\");\n+                }\n+                Err(e) => {\n+                    tracing::error!(error = %e, \"Failed to delete objects from S3\");\n+                    return Err(StorageError::Generic {\n+                        source: Arc::new(e.into_service_error()),\n+                    });\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         tracing::info!(src = %src_key, dst = %dst_key, \"Renaming object in S3\");\n \n---\n\n\n---\n\nChoice C:\nrust/load/src/lib.rs\n@@ -1271,13 +1271,11 @@ impl LoadService {\n             for declared in declared {\n                 if let Entry::Vacant(entry) = running.entry(declared.uuid) {\n                     tracing::info!(\"spawning workload {}\", declared.uuid);\n-                    let root = tracing::info_span!(parent: None, \"workload\");\n                     let this = Arc::clone(self);\n                     let done = Arc::new(AtomicBool::new(false));\n                     let done_p = Arc::clone(&done);\n                     let inhibit = Arc::clone(&self.inhibit);\n                     let task = tokio::task::spawn(async move {\n-                        let _enter = root.enter();\n                         this.run_one_workload(done, inhibit, declared).await\n                     });\n                     entry.insert((done_p, task));\n@@ -1295,36 +1293,6 @@ impl LoadService {\n         let client = Arc::new(client(spec.connection.clone()).await);\n         let mut guac = Guacamole::new(spec.expires.timestamp_millis() as u64);\n         let mut next_op = Instant::now();\n-        let (tx, mut rx) = tokio::sync::mpsc::channel(1000);\n-        let _ = tx\n-            .send(tokio::spawn(async move { Ok::<(), Error>(()) }))\n-            .await;\n-        let this = Arc::clone(&self);\n-        let data_set = Arc::clone(&spec.data_set);\n-        let reaper = tokio::spawn(async move {\n-            while let Some(task) = rx.recv().await {\n-                if let Err(err) = task.await.unwrap() {\n-                    if !format!(\"{err:?}\").contains(\"429\") {\n-                        this.metrics.failed.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                        tracing::error!(\"workload task failed: {err:?}\");\n-                    } else {\n-                        this.metrics.limited.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                    }\n-                }\n-            }\n-        });\n \n         // Initialize the data set.\n         let data_set = Arc::clone(&spec.data_set);\n@@ -1408,30 +1376,44 @@ impl LoadService {\n                         .await\n                         .map_err(|err| Error::FailWorkload(err.to_string()))\n                     {\n-                        Ok(()) => Ok(()),\n+                        Ok(()) => (),\n                         Err(err) => {\n-                            if err.to_string().contains(\"invalid request: No results\") {\n+                            if format!(\"{err:?}\").contains(\"invalid request: No results\") {\n                                 this.metrics.no_results.add(\n                                     1,\n                                     &[KeyValue::new(\n                                         Key::from_static_str(\"data_set\"),\n                                         Value::from(data_set.name()),\n                                     )],\n                                 );\n-                                Ok(())\n+                                tracing::warn!(\"workload step no results: {err:?}\");\n+                            } else if !format!(\"{err:?}\").contains(\"429\") {\n+                                this.metrics.failed.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::error!(\"workload step failed: {err:?}\");\n                             } else {\n-                                Err(err)\n+                                this.metrics.limited.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::warn!(\"workload step rate limited: {err:?}\");\n                             }\n                         }\n-                    }\n+                    };\n                 };\n-                tx.send(tokio::spawn(fut)).await.unwrap();\n+                let span = tracing::info_span!(parent: None, \"step\", workload_uuid = %spec.uuid);\n+                tokio::spawn(fut.instrument(span));\n             }\n         }\n-        // Not an error, just needs to show up in stdout.\n-        tracing::error!(\"workload done: {}/{}\", spec.name, spec.description());\n-        drop(tx);\n-        reaper.await.unwrap();\n+        tracing::info!(\"workload done: {}/{}\", spec.name, spec.description());\n     }\n \n     fn load_persistent(&self) -> Result<(), Error> {\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.7\"\n+__version__ = \"1.0.8\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.7\"\n+      \"Default\": \"1.0.8\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nAdds a log line.\n\n## Test plan\n\nCompiles locally.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js,\n`cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/test/distributed/test_log_failover.py\n@@ -23,6 +23,50 @@\n \n RECORDS = 100\n \n+@skip_if_not_cluster()\n+def test_log_immediate_failover(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n+\n @skip_if_not_cluster()\n def test_log_failover(\n     client: ClientAPI,\n---\ngo/pkg/log/repository/log.go\n@@ -4,6 +4,7 @@ import (\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"strings\"\n \t\"time\"\n \n \tlog \"github.com/chroma-core/chroma/go/pkg/log/store/db\"\n@@ -215,6 +216,9 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \n func (r *LogRepository) SealCollection(ctx context.Context, collectionID string) (err error) {\n \t_, err = r.queries.SealLog(ctx, collectionID)\n+\tif err != nil && strings.Contains(err.Error(), \"no rows in result set\") {\n+\t\t_, err = r.queries.SealLogInsert(ctx, collectionID)\n+\t}\n \treturn\n }\n \n---\ngo/pkg/log/store/db/queries.sql.go\n@@ -292,6 +292,22 @@ func (q *Queries) SealLog(ctx context.Context, id string) (Collection, error) {\n \treturn i, err\n }\n \n+const sealLogInsert = `-- name: SealLogInsert :one\n+INSERT INTO collection(id, is_sealed, record_compaction_offset_position, record_enumeration_offset_position) VALUES ($1, true, 0, 0) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+`\n+\n+func (q *Queries) SealLogInsert(ctx context.Context, id string) (Collection, error) {\n+\trow := q.db.QueryRow(ctx, sealLogInsert, id)\n+\tvar i Collection\n+\terr := row.Scan(\n+\t\t&i.ID,\n+\t\t&i.RecordCompactionOffsetPosition,\n+\t\t&i.RecordEnumerationOffsetPosition,\n+\t\t&i.IsSealed,\n+\t)\n+\treturn i, err\n+}\n+\n const updateCollectionCompactionOffsetPosition = `-- name: UpdateCollectionCompactionOffsetPosition :exec\n UPDATE collection set record_compaction_offset_position = $2 where id = $1\n `\n---\ngo/pkg/log/store/queries/queries.sql\n@@ -68,3 +68,6 @@ INSERT INTO record_log (\"offset\", collection_id, timestamp, record)\n \n -- name: SealLog :one\n UPDATE collection SET is_sealed = true WHERE id = $1 returning *;\n+\n+-- name: SealLogInsert :one\n+INSERT INTO collection(id, is_sealed, record_compaction_offset_position, record_enumeration_offset_position) VALUES ($1, true, 0, 0) returning *;\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/server/server.go\n@@ -8,7 +8,9 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb\"\n \t\"github.com/chroma-core/chroma/go/pkg/proto/logservicepb\"\n \t\"github.com/chroma-core/chroma/go/pkg/types\"\n+\ttrace_log \"github.com/pingcap/log\"\n \t\"google.golang.org/protobuf/proto\"\n+\t\"go.uber.org/zap\"\n )\n \n type logServer struct {\n@@ -59,6 +61,7 @@ func (s *logServer) ScoutLogs(ctx context.Context, req *logservicepb.ScoutLogsRe\n \tres = &logservicepb.ScoutLogsResponse{\n \t\tFirstUninsertedRecordOffset: int64(limit + 1),\n \t}\n+\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n \treturn\n }\n \n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -1219,17 +1219,16 @@ impl LogService for LogServer {\n             let witness = cursors.load(cursor_name).await.map_err(|err| {\n                 Status::new(err.code().into(), format!(\"Failed to load cursor: {}\", err))\n             })?;\n-            // This is the existing compaction_offset, which is the last record that was compacted.\n+            // This is the existing compaction_offset, which is the next record to compact.\n             let offset = witness\n                 .map(|x| x.1.position)\n-                .unwrap_or(LogPosition::from_offset(0));\n+                .unwrap_or(LogPosition::from_offset(1));\n             tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n                 &log_reader,\n-                // + 1 to get to the first uncompacted record.\n-                offset + 1u64,\n+                offset,\n                 target_prefix.clone(),\n             )\n             .await\n@@ -1253,7 +1252,9 @@ impl LogService for LogServer {\n             }\n             tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n-                compaction_offset: offset.offset(),\n+                // NOTE: The upstream service expects the last compacted offset as compaction offset\n+                compaction_offset: (offset - 1u64).offset(),\n+                // NOTE: The upstream service expects the last uncompacted offset as enumeration offset\n                 enumeration_offset: (max_offset - 1u64).offset(),\n             }))\n         }\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nAdds a log line.\n\n## Test plan\n\nCompiles locally.\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\ngo/pkg/log/server/server.go\n@@ -8,7 +8,9 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb\"\n \t\"github.com/chroma-core/chroma/go/pkg/proto/logservicepb\"\n \t\"github.com/chroma-core/chroma/go/pkg/types\"\n+\ttrace_log \"github.com/pingcap/log\"\n \t\"google.golang.org/protobuf/proto\"\n+\t\"go.uber.org/zap\"\n )\n \n type logServer struct {\n@@ -59,6 +61,7 @@ func (s *logServer) ScoutLogs(ctx context.Context, req *logservicepb.ScoutLogsRe\n \tres = &logservicepb.ScoutLogsResponse{\n \t\tFirstUninsertedRecordOffset: int64(limit + 1),\n \t}\n+\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n \treturn\n }\n \n---\n\n\n---\n\nChoice B:\nrust/cli/src/commands/mod.rs\n@@ -7,3 +7,4 @@ pub mod profile;\n pub mod run;\n pub mod update;\n pub mod vacuum;\n+pub mod webpage;\n---\nrust/cli/src/commands/webpage.rs\n@@ -0,0 +1,29 @@\n+use crate::utils::CliError;\n+use thiserror::Error;\n+\n+#[derive(Debug, Error)]\n+pub enum WebPageError {\n+    #[error(\"Failed to open browser. {0}\")]\n+    BrowserOpenFailed(String),\n+}\n+\n+pub enum WebPageCommand {\n+    Discord,\n+    Docs,\n+}\n+\n+impl WebPageCommand {\n+    fn url(&self) -> &'static str {\n+        match self {\n+            WebPageCommand::Discord => \"https://discord.gg/MMeYNTmh3x\",\n+            WebPageCommand::Docs => \"https://docs.trychroma.com\",\n+        }\n+    }\n+}\n+\n+pub fn open_browser(command: WebPageCommand) -> Result<(), CliError> {\n+    let url = command.url();\n+    let error_message = format!(\"Visit {}\", url);\n+    webbrowser::open(url).map_err(|_| WebPageError::BrowserOpenFailed(error_message))?;\n+    Ok(())\n+}\n---\nrust/cli/src/lib.rs\n@@ -13,10 +13,9 @@ use crate::commands::profile::{profile_command, ProfileCommand};\n use crate::commands::run::{run, RunArgs};\n use crate::commands::update::update;\n use crate::commands::vacuum::{vacuum, VacuumArgs};\n+use crate::commands::webpage::{open_browser, WebPageCommand};\n use clap::{Parser, Subcommand};\n use colored::Colorize;\n-use utils::CliError;\n-use utils::UtilsError;\n \n #[derive(Subcommand, Debug)]\n enum Command {\n@@ -44,12 +43,6 @@ struct Cli {\n     command: Command,\n }\n \n-fn open_browser(url: &str) -> Result<(), CliError> {\n-    let error_message = format!(\"Visit {}\", url);\n-    webbrowser::open(url).map_err(|_| UtilsError::BrowserOpenFailed(error_message))?;\n-    Ok(())\n-}\n-\n pub fn chroma_cli(args: Vec<String>) {\n     let cli = Cli::parse_from(args);\n \n@@ -59,18 +52,12 @@ pub fn chroma_cli(args: Vec<String>) {\n         Command::Browse(args) => browse(args),\n         Command::Copy(args) => copy(args),\n         Command::Db(db_subcommand) => db_command(db_subcommand),\n-        Command::Docs => {\n-            let url = \"https://docs.trychroma.com\";\n-            open_browser(url)\n-        }\n+        Command::Docs => open_browser(WebPageCommand::Docs),\n         Command::Install(args) => install(args),\n         Command::Login(args) => login(args),\n         Command::Profile(profile_subcommand) => profile_command(profile_subcommand),\n         Command::Run(args) => run(args),\n-        Command::Support => {\n-            let url = \"https://discord.gg/MMeYNTmh3x\";\n-            open_browser(url)\n-        }\n+        Command::Support => open_browser(WebPageCommand::Discord),\n         Command::Update => update(),\n         Command::Vacuum(args) => vacuum(args),\n     };\n---\nrust/cli/src/utils.rs\n@@ -11,6 +11,7 @@ use crate::commands::profile::ProfileError;\n use crate::commands::run::RunError;\n use crate::commands::update::UpdateError;\n use crate::commands::vacuum::VacuumError;\n+use crate::commands::webpage::WebPageError;\n use crate::ui_utils::Theme;\n use chroma_frontend::config::FrontendServerConfig;\n use chroma_frontend::frontend_service_entrypoint_with_config;\n@@ -64,6 +65,8 @@ pub enum CliError {\n     Copy(#[from] CopyError),\n     #[error(\"{0}\")]\n     Collection(#[from] CollectionAPIError),\n+    #[error(\"{0}\")]\n+    WebPage(#[from] WebPageError),\n }\n \n #[derive(Debug, Error)]\n@@ -90,8 +93,6 @@ pub enum UtilsError {\n     ConfigFileWriteFailed,\n     #[error(\"Failed to get user input\")]\n     UserInputFailed,\n-    #[error(\"Failed to open browser. {0}\")]\n-    BrowserOpenFailed(String),\n     #[error(\"Failed to copy to clipboard\")]\n     CopyToClipboardFailed,\n     #[error(\"Input validation failed\")]\n---\n\n\n---\n\nChoice C:\nchromadb/test/property/test_fork.py\n@@ -21,6 +21,10 @@\n from overrides import overrides\n from typing import Dict, cast, Union, Tuple, Set\n \n+import grpc\n+from chromadb.proto.logservice_pb2 import SealLogRequest\n+from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n collection_st = hyst.shared(strategies.collections(with_hnsw_params=True), key=\"source\")\n \n \n@@ -38,6 +42,10 @@ def __init__(self, client: chromadb.api.ClientAPI):\n         self.client = client\n         self.collection_names = set()\n \n+        # Create go log service client\n+        channel = grpc.insecure_channel(\"localhost:50052\")\n+        self.go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n     @initialize(collection=collection_st, target=updated_collections)\n     def initialize(\n         self, collection: strategies.Collection\n@@ -77,12 +85,14 @@ def fork(\n     @rule(\n         cursor=consumes(forked_collections),\n         delta=strategies.recordsets(collection_st),\n+        seal=hyst.booleans(),\n         target=updated_collections,\n     )\n     def upsert(\n         self,\n         cursor: Tuple[Collection, strategies.StateMachineRecordSet],\n         delta: strategies.RecordSet,\n+        seal: bool,\n     ) -> Tuple[Collection, strategies.StateMachineRecordSet]:\n         collection, record_set_state = cursor\n         normalized_delta: strategies.NormalizedRecordSet = invariants.wrap_all(delta)\n@@ -148,6 +158,8 @@ def upsert(\n                     )\n                 else:\n                     record_set_state[\"documents\"].append(None)\n+        if seal:\n+            self.go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n         return collection, record_set_state\n \n     @rule(\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1052,9 +1052,11 @@ func (tc *Catalog) ForkCollection(ctx context.Context, forkCollection *model.For\n \t\t// t2: Fork source collection in sysdb, the latest source collection compaction offset is 400. If we add new logs, it will start after offset 300, and the data is lost after compaction.\n \t\tlatestSourceCompactionOffset := uint64(sourceCollection.LogPosition)\n \t\tif forkCollection.SourceCollectionLogEnumerationOffset < latestSourceCompactionOffset {\n+\t\t\tlog.Error(\"CollectionLogPositionStale\", zap.Uint64(\"latestSourceCompactionOffset\", latestSourceCompactionOffset), zap.Uint64(\"forkCollection.SourceCollectionLogEnumerationOffset \", forkCollection.SourceCollectionLogEnumerationOffset))\n \t\t\treturn common.ErrCollectionLogPositionStale\n \t\t}\n \t\tif latestSourceCompactionOffset < forkCollection.SourceCollectionLogCompactionOffset {\n+\t\t\tlog.Error(\"CompactionOffsetSomehowAhead\", zap.Uint64(\"latestSourceCompactionOffset\", latestSourceCompactionOffset), zap.Uint64(\"forkCollection.SourceCollectionLogCompactionOffset\", forkCollection.SourceCollectionLogCompactionOffset))\n \t\t\treturn common.ErrCompactionOffsetSomehowAhead\n \t\t}\n \n---\nrust/log-service/src/lib.rs\n@@ -34,7 +34,7 @@ use prost::Message;\n use serde::{Deserialize, Serialize};\n use tokio::signal::unix::{signal, SignalKind};\n use tonic::{transport::Server, Code, Request, Response, Status};\n-use tracing::Instrument;\n+use tracing::{Instrument, Level};\n use uuid::Uuid;\n use wal3::{\n     Cursor, CursorName, CursorStore, CursorStoreOptions, Limits, LogPosition, LogReader,\n@@ -1223,6 +1223,7 @@ impl LogService for LogServer {\n             let offset = witness\n                 .map(|x| x.1.position)\n                 .unwrap_or(LogPosition::from_offset(0));\n+            tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n@@ -1250,6 +1251,7 @@ impl LogService for LogServer {\n                     format!(\"max_offset={:?} < offset={:?}\", max_offset, offset),\n                 ));\n             }\n+            tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n                 compaction_offset: offset.offset(),\n                 enumeration_offset: (max_offset - 1u64).offset(),\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - ...\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -199,7 +199,9 @@ async fn get_log_from_handle<'a>(\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n     let mut active = handle.active.lock().await;\n-    active.keep_alive(Duration::from_secs(60));\n+    if active.log.is_some() {\n+        active.keep_alive(Duration::from_secs(60));\n+    }\n     if let Some(log) = active.log.as_ref() {\n         return Ok(LogRef {\n             log: Arc::clone(log),\n@@ -215,6 +217,7 @@ async fn get_log_from_handle<'a>(\n         mark_dirty.clone(),\n     )\n     .await?;\n+    active.keep_alive(Duration::from_secs(60));\n     tracing::info!(\"Opened log at {}\", prefix);\n     let opened = Arc::new(opened);\n     active.log = Some(Arc::clone(&opened));\n---\n\n\n---\n\nChoice B:\nrust/segment/src/sqlite_metadata.rs\n@@ -482,8 +482,9 @@ impl IntoSqliteExpr for DocumentExpression {\n             EmbeddingFulltextSearch::StringValue,\n         ));\n         let doc_contains = doc_col\n+            .clone()\n             .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .is(true);\n+            .and(doc_col.is_not_null());\n         match self.operator {\n             DocumentOperator::Contains => doc_contains,\n             DocumentOperator::NotContains => doc_contains.not(),\n@@ -495,9 +496,11 @@ impl IntoSqliteExpr for DocumentExpression {\n \n impl IntoSqliteExpr for MetadataExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let key_cond = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key))\n+        let key_col = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key));\n+        let key_cond = key_col\n+            .clone()\n             .eq(self.key.to_string())\n-            .is(true);\n+            .and(key_col.is_not_null());\n         match &self.comparison {\n             MetadataComparison::Primitive(op, val) => {\n                 let (col, sval) = match val {\n---\n\n\n---\n\nChoice C:\nrust/load/src/data_sets.rs\n@@ -836,12 +836,12 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            let key = uq.key.select_from_reference(self, offset);\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n             if !keys.contains(&key) {\n                 keys.push(key);\n             }\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionWithoutMetadata(collectionID *string, databaseName *string, softDeletedFlag *bool) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, NULLIF(collections.root_collection_id, '') AS root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - ...\n- New functionality\n  - Reimplements a backstop to prevent too many forks on a collection\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nk8s/distributed-chroma/values.dev.yaml\n@@ -33,3 +33,6 @@ compactionService:\n       value: 'value: \"1\"'\n     - name: CONFIG_PATH\n       value: 'value: \"/tilt_config.yaml\"'\n+\n+rustLogService:\n+  replicaCount: 2\n---\n\n\n---\n\nChoice B:\nchromadb/test/test_cli.py\n@@ -7,10 +7,10 @@\n \n import chromadb\n from chromadb.api.client import Client\n+from chromadb.api.client import ClientAPI\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,27 +19,59 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+    client: ClientAPI, max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n \n+\n def test_app() -> None:\n     kwargs = {\"path\": \"chroma_test_data\", \"port\": 8001}\n     args = [\"chroma\", \"run\"]\n     args.extend(build_cli_args(**kwargs))\n     print(args)\n     server_process = multiprocessing.Process(target=start_app, args=(args,))\n     server_process.start()\n-    time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    host = kwargs.get(\"host\", \"localhost\")\n+    port = int(kwargs.get(\"port\", 8001))\n \n     client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n+    assert wait_for_server(\n+        client\n+    ), \"Server failed to start within maximum retry attempts\"\n+\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -72,7 +104,13 @@ def add_records(collection: Collection, num: int) -> None:\n         cur.execute(sql, params)\n         assert cur.fetchall() == []\n \n-    sys.argv = [\"chroma\", \"vacuum\", \"--path\", system.settings.persist_directory, \"--force\"]\n+    sys.argv = [\n+        \"chroma\",\n+        \"vacuum\",\n+        \"--path\",\n+        system.settings.persist_directory,\n+        \"--force\",\n+    ]\n     cli.app()\n \n     # Maintenance log should have a vacuum entry\n@@ -124,7 +162,13 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\n+            \"chroma\",\n+            \"vacuum\",\n+            \"--path\",\n+            sqlite_persistent.settings.persist_directory,\n+            \"--force\",\n+        ]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -967,7 +967,10 @@ func (tc *Catalog) ForkCollection(ctx context.Context, forkCollection *model.For\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\n+\t\t// Defensive backstop to prevent too many forks\n+\t\tif len(lineageFile.Dependencies) > 1000000 {\n+\t\t\treturn common.ErrCollectionTooManyFork\n+\t\t}\n \t\tlineageFile.Dependencies = append(lineageFile.Dependencies, &coordinatorpb.CollectionVersionDependency{\n \t\t\tSourceCollectionId:      sourceCollectionIDStr,\n \t\t\tSourceCollectionVersion: uint64(sourceCollection.Version),\n---\n\n\n---\n\nChoice D:\nrust/load/src/opentelemetry_config.rs\n@@ -5,114 +5,41 @@\n \n use opentelemetry::global;\n use opentelemetry::trace::TracerProvider;\n-use opentelemetry_otlp::{WithExportConfig, WithHttpConfig};\n+use opentelemetry_otlp::WithExportConfig;\n use opentelemetry_sdk::propagation::TraceContextPropagator;\n use tracing_bunyan_formatter::BunyanFormattingLayer;\n use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Layer};\n \n-#[derive(Clone, Debug, Default)]\n-struct ChromaShouldSample;\n-\n-const BUSY_NS: opentelemetry::Key = opentelemetry::Key::from_static_str(\"busy_ns\");\n-const IDLE_NS: opentelemetry::Key = opentelemetry::Key::from_static_str(\"idle_ns\");\n-\n-fn is_slow(attributes: &[opentelemetry::KeyValue]) -> bool {\n-    let mut nanos = 0i64;\n-    for attr in attributes {\n-        if attr.key == BUSY_NS || attr.key == IDLE_NS {\n-            if let opentelemetry::Value::I64(ns) = attr.value {\n-                nanos += ns;\n-            }\n-        }\n-    }\n-    nanos > 20_000_000\n-}\n-\n-impl opentelemetry_sdk::trace::ShouldSample for ChromaShouldSample {\n-    fn should_sample(\n-        &self,\n-        _: Option<&opentelemetry::Context>,\n-        _: opentelemetry::trace::TraceId,\n-        name: &str,\n-        _: &opentelemetry::trace::SpanKind,\n-        attributes: &[opentelemetry::KeyValue],\n-        _: &[opentelemetry::trace::Link],\n-    ) -> opentelemetry::trace::SamplingResult {\n-        // NOTE(rescrv):  THIS IS A HACK!  If you find yourself seriously extending it, it's time\n-        // to investigate honeycomb's sampling capabilities.\n-\n-        // If the name is not get and not insert, or the request is slow, sample it.\n-        // Otherwise, drop.\n-        // This filters filters foyer calls in-process so they won't be overwhelming the tracing.\n-        if (name != \"get\" && name != \"insert\") || is_slow(attributes) {\n-            opentelemetry::trace::SamplingResult {\n-                decision: opentelemetry::trace::SamplingDecision::RecordAndSample,\n-                attributes: vec![],\n-                trace_state: opentelemetry::trace::TraceState::default(),\n-            }\n-        } else {\n-            opentelemetry::trace::SamplingResult {\n-                decision: opentelemetry::trace::SamplingDecision::Drop,\n-                attributes: vec![],\n-                trace_state: opentelemetry::trace::TraceState::default(),\n-            }\n-        }\n-    }\n-}\n-\n pub(crate) fn init_otel_tracing(service_name: &String, otel_endpoint: &String) {\n-    println!(\n+    tracing::info!(\n         \"Registering jaeger subscriber for {} at endpoint {}\",\n-        service_name, otel_endpoint\n+        service_name,\n+        otel_endpoint\n     );\n     let resource = opentelemetry_sdk::Resource::new(vec![opentelemetry::KeyValue::new(\n         \"service.name\",\n         service_name.clone(),\n     )]);\n \n     // Prepare tracer.\n-    let client = reqwest::Client::new();\n-    let span_exporter = opentelemetry_otlp::SpanExporter::builder()\n-        .with_http()\n-        .with_http_client(client)\n+    let tracing_span_exporter = opentelemetry_otlp::SpanExporter::builder()\n+        .with_tonic()\n         .with_endpoint(otel_endpoint)\n         .build()\n-        .expect(\"could not build span exporter\");\n-    let trace_config = opentelemetry_sdk::trace::Config::default()\n-        .with_sampler(ChromaShouldSample)\n-        .with_resource(resource.clone());\n+        .expect(\"could not build span exporter for tracing\");\n+    let trace_config = opentelemetry_sdk::trace::Config::default().with_resource(resource.clone());\n     let tracer_provider = opentelemetry_sdk::trace::TracerProvider::builder()\n-        .with_batch_exporter(span_exporter, opentelemetry_sdk::runtime::Tokio)\n+        .with_batch_exporter(tracing_span_exporter, opentelemetry_sdk::runtime::Tokio)\n         .with_config(trace_config)\n         .build();\n     let tracer = tracer_provider.tracer(service_name.clone());\n-    // TODO(MrCroxx): Should we the tracer provider as global?\n-    // global::set_tracer_provider(tracer_provider);\n \n     // Prepare meter.\n-    let mut headers = reqwest::header::HeaderMap::new();\n-    headers.insert(\n-        \"x-honeycomb-dataset\",\n-        reqwest::header::HeaderValue::from_static(\"chroma-load\"),\n-    );\n-    if let Ok(api_key) = std::env::var(\"OTEL_EXPORTER_OTLP_HEADERS\") {\n-        if let Some((header, value)) = api_key.split_once(\"=\") {\n-            if header == \"x-honeycomb-team\" {\n-                headers.insert(\n-                    reqwest::header::HeaderName::from_static(\"x-honeycomb-team\"),\n-                    reqwest::header::HeaderValue::from_bytes(value.trim().as_bytes()).unwrap(),\n-                );\n-            }\n-        }\n-    }\n-    let client = reqwest::ClientBuilder::new()\n-        .default_headers(headers)\n-        .build()\n-        .unwrap();\n     let metric_exporter = opentelemetry_otlp::MetricExporter::builder()\n-        .with_http()\n-        .with_http_client(client)\n-        .with_endpoint(otel_endpoint)\n+        .with_tonic()\n+        .with_endpoint(\n+            std::env::var(\"OTEL_EXPORTER_OTLP_METRICS_ENDPOINT\").unwrap_or(otel_endpoint.clone()),\n+        )\n         .build()\n         .expect(\"could not build metric exporter\");\n \n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nhttps://github.com/chroma-core/chroma/pull/4479 added auth against DockerHub for higher rate limits when pulling, but I forgot to update the release workflow to properly propogate the secrets down.\n\n\n---\n\nChoice A:\nclients/js/packages/chromadb/package.json\n@@ -50,6 +50,13 @@\n     \"tsup\": \"^7.2.0\",\n     \"typescript\": \"^5.0.4\"\n   },\n+  \"optionalDependencies\": {\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+  },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n   },\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.0.0\"\n+$release = \"cli-1.1.0\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.0.0\"\n+RELEASE=\"cli-1.1.0\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\nrust/cli/src/client/collection.rs\n@@ -130,13 +130,7 @@ impl Collection {\n             self.chroma_client.tenant_id, self.chroma_client.db, self.collection_id\n         );\n \n-        let payload = AddCollectionRecordsPayload {\n-            ids,\n-            embeddings,\n-            documents,\n-            uris,\n-            metadatas,\n-        };\n+        let payload = AddCollectionRecordsPayload::new(ids, embeddings, documents, uris, metadatas);\n \n         let _response = send_request::<AddCollectionRecordsPayload, AddCollectionRecordsResponse>(\n             &self.chroma_client.host,\n---\nrust/cli/src/commands/copy.rs\n@@ -277,7 +277,7 @@ pub fn copy(args: CopyArgs) -> Result<(), CliError> {\n         if !args.all && args.collections.is_empty() {\n             return Err(CopyError::NoCollections.into());\n         }\n-        \n+\n         let (_, profile) = get_current_profile()?;\n         let (source, target) = get_target_and_destination(&args)?;\n         let (source_client, target_client, _handle) =\n---\nrust/frontend/src/server.rs\n@@ -1252,11 +1252,29 @@ async fn fork_collection(\n \n #[derive(Serialize, Deserialize, ToSchema, Debug, Clone)]\n pub struct AddCollectionRecordsPayload {\n-    pub ids: Vec<String>,\n-    pub embeddings: Option<Vec<Vec<f32>>>,\n-    pub documents: Option<Vec<Option<String>>>,\n-    pub uris: Option<Vec<Option<String>>>,\n-    pub metadatas: Option<Vec<Option<Metadata>>>,\n+    ids: Vec<String>,\n+    embeddings: Option<Vec<Vec<f32>>>,\n+    documents: Option<Vec<Option<String>>>,\n+    uris: Option<Vec<Option<String>>>,\n+    metadatas: Option<Vec<Option<Metadata>>>,\n+}\n+\n+impl AddCollectionRecordsPayload {\n+    pub fn new(\n+        ids: Vec<String>,\n+        embeddings: Option<Vec<Vec<f32>>>,\n+        documents: Option<Vec<Option<String>>>,\n+        uris: Option<Vec<Option<String>>>,\n+        metadatas: Option<Vec<Option<Metadata>>>,\n+    ) -> Self {\n+        Self {\n+            ids,\n+            embeddings,\n+            documents,\n+            uris,\n+            metadatas,\n+        }\n+    }\n }\n \n /// Adds records to a collection.\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\nChoice B:\nchromadb/api/models/AsyncCollection.py\n@@ -256,6 +256,8 @@ async def modify(\n             new_name=name,\n             new_metadata=metadata,\n             new_configuration=configuration,\n+            tenant=self.tenant,\n+            database=self.database,\n         )\n \n         self._update_model_after_modify_success(name, metadata, configuration)\n---\n\n\n---\n\nChoice C:\n.github/workflows/release-chromadb.yml\n@@ -61,6 +61,7 @@ jobs:\n   go-tests:\n     name: Go tests\n     uses: ./.github/workflows/_go-tests.yml\n+    secrets: inherit\n \n   release-docker:\n     name: Publish to DockerHub and GHCR\n---\n\n\n---\n\nChoice D:\nrust/cli/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"chroma-cli\"\n-version = \"1.1.1\"\n+version = \"1.1.2\"\n edition = \"2021\"\n \n [dependencies]\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.1.1\"\n+$release = \"cli-1.1.2\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.1.1\"\n+RELEASE=\"cli-1.1.2\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nReleasing CLI 1.1.1\r\n* Fix Github release fetch bug affecting `install` and `update\n\n---\n\nChoice A:\nDockerfile\n@@ -69,4 +69,3 @@ EXPOSE 8000\n \n ENTRYPOINT [\"/docker_entrypoint.sh\"]\n CMD [ \"--workers ${CHROMA_WORKERS} --host ${CHROMA_HOST_ADDR} --port ${CHROMA_HOST_PORT} --proxy-headers --reload --log-config ${CHROMA_LOG_CONFIG} --timeout-keep-alive ${CHROMA_TIMEOUT_KEEP_ALIVE}\"]\n-\n---\nDockerfile.windows\n@@ -1,14 +1,15 @@\n FROM python:3.11.9\n ARG REBUILD_HNSWLIB\n-\n SHELL [\"powershell\", \"-Command\", \"$ErrorActionPreference = 'Stop'; $ProgressPreference = 'SilentlyContinue';\"]\n RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; `Invoke-WebRequest \"https://aka.ms/vs/17/release/vc_redist.x64.exe\" -OutFile \"vc_redist.x64.exe\"; `Start-Process -filepath C:\\vc_redist.x64.exe -ArgumentList \"/install\", \"/passive\", \"/norestart\" -Passthru | Wait-Process; `Remove-Item -Force vc_redist.x64.exe;\n \n WORKDIR C:\\\\chroma\n \n COPY ./requirements.txt requirements.txt\n+COPY ./requirements_dev.txt requirements_dev.txt\n \n RUN pip install --no-cache-dir --upgrade -r requirements.txt\n+RUN pip install --no-cache-dir --upgrade -r requirements_dev.txt\n RUN if ($env:REBUILD_HNSWLIB -eq 'true') { pip install --no-binary :all: --force-reinstall --no-cache-dir chroma-hnswlib }\n \n COPY ./bin/docker_entrypoint.ps1 C:\\\\docker_entrypoint.ps1\n@@ -19,7 +20,6 @@ ENV CHROMA_HOST_PORT 8000\n ENV CHROMA_WORKERS 1\n ENV CHROMA_LOG_CONFIG \"chromadb/log_config.yml\"\n ENV CHROMA_TIMEOUT_KEEP_ALIVE 30\n-\n EXPOSE 8000\n \n ENTRYPOINT [\"powershell\", \"C:\\\\\\\\docker_entrypoint.ps1\"]\n---\nchromadb/test/utils/cross_version.py\n@@ -55,7 +55,10 @@ def install(pkg: str, path: str, dep_overrides: Dict[str, str]) -> int:\n     for dep, operator_version in dep_overrides.items():\n         command.append(f\"{dep}{operator_version}\")\n \n-    command.append(\"--no-binary=chroma-hnswlib\")\n+    # Only add --no-binary=chroma-hnswlib if it's in the dependencies\n+    if \"chroma-hnswlib\" in pkg or any(\"chroma-hnswlib\" in dep for dep in dep_overrides):\n+        command.append(\"--no-binary=chroma-hnswlib\")\n+\n     command.append(f\"--target={path}\")\n \n     print(f\"Installing chromadb version {pkg} to {path}\")\n---\npyproject.toml\n@@ -7,7 +7,10 @@ description = \"Chroma.\"\n readme = \"README.md\"\n requires-python = \">=3.9\"\n classifiers = [\"Programming Language :: Python :: 3\", \"License :: OSI Approved :: Apache Software License\", \"Operating System :: OS Independent\"]\n-dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'chroma-hnswlib==0.7.6', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+\n+[project.optional-dependencies]\n+dev = ['chroma-hnswlib==0.7.6']\n \n [tool.black]\n line-length = 88\n---\nrequirements.txt\n@@ -1,5 +1,4 @@\n bcrypt>=4.0.1\n-chroma-hnswlib==0.7.6\n fastapi==0.115.9\n graphlib_backport==1.0.3; python_version < '3.9'\n grpcio>=1.58.0\n---\nrequirements_dev.txt\n@@ -1,5 +1,6 @@\n black==23.3.0 # match what's in pyproject.toml\n build\n+chroma-hnswlib==0.7.6\n grpcio-tools==1.67.1 # Later version not compatible with protobuf 4.25.5\n httpx\n hypothesis==6.112.2 # TODO: Resolve breaking changes and bump version\n---\n\n\n---\n\nChoice B:\nCargo.lock\n@@ -1442,7 +1442,7 @@ dependencies = [\n \n [[package]]\n name = \"chroma-cli\"\n-version = \"1.1.0\"\n+version = \"1.1.1\"\n dependencies = [\n  \"arboard\",\n  \"axum 0.8.1\",\n---\nclients/js/packages/chromadb/package.json\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.1\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.1.1\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.1\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.1\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.1\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.2\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.1.2\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.2\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.2\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.2\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\nrust/cli/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"chroma-cli\"\n-version = \"1.1.0\"\n+version = \"1.1.1\"\n edition = \"2021\"\n \n [dependencies]\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.1.0\"\n+$release = \"cli-1.1.1\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.1.0\"\n+RELEASE=\"cli-1.1.1\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.1.1\",\n+  \"version\": \"0.1.2\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.1.1\",\n+  \"version\": \"0.1.2\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.1.1\",\n+  \"version\": \"0.1.2\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.1.1\",\n+  \"version\": \"0.1.2\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.1.1\",\n+  \"version\": \"0.1.2\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.1.1\",\n+  \"version\": \"0.1.2\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\nChoice C:\nrust/log/src/test.rs\n@@ -124,7 +124,7 @@ pub trait LoadFromGenerator<L: LogGenerator> {\n impl<L: LogGenerator + Send + 'static> LoadFromGenerator<L> for TestDistributedSegment {\n     async fn populate_with_generator(&mut self, log_count: usize, generator: L) {\n         let ids: Vec<_> = (1..=log_count).collect();\n-        for chunk in ids.chunks(100) {\n+        for chunk in ids.chunks(10_000) {\n             self.compact_log(\n                 generator.generate_chunk(chunk.iter().copied()),\n                 chunk\n---\n\n\n---\n\nChoice D:\nrust/types/src/api_types.rs\n@@ -82,7 +82,7 @@ impl ChromaError for GetCollectionWithSegmentsError {\n             GetCollectionWithSegmentsError::CollectionConversionError(\n                 collection_conversion_error,\n             ) => collection_conversion_error.code(),\n-            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::Internal,\n             GetCollectionWithSegmentsError::Field(_) => ErrorCodes::FailedPrecondition,\n             GetCollectionWithSegmentsError::SegmentConversionError(segment_conversion_error) => {\n                 segment_conversion_error.code()\n@@ -849,7 +849,7 @@ impl ChromaError for ForkCollectionError {\n             ForkCollectionError::CollectionConversionError(collection_conversion_error) => {\n                 collection_conversion_error.code()\n             }\n-            ForkCollectionError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            ForkCollectionError::DuplicateSegment => ErrorCodes::Internal,\n             ForkCollectionError::Field(_) => ErrorCodes::FailedPrecondition,\n             ForkCollectionError::Local => ErrorCodes::Unimplemented,\n             ForkCollectionError::Internal(chroma_error) => chroma_error.code(),\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Default hardcoded `NUM_FORKS` value 1000000 --> 10000\n  - Send fork collection name to quota enforcer\n  - Remove hardcoded fork tree check in SysDB\n- New functionality\n  - N/A\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -1212,13 +1212,6 @@ impl DataSet for VerifyingDataSet {\n             }\n         };\n \n-        event!(\n-            Level::INFO,\n-            \"Upserting {} keys, new cardinality: {}\",\n-            uq.batch_size,\n-            key_start_index + uq.batch_size\n-        );\n-\n         for offset in 0..uq.batch_size {\n             let key = uq.key.select_from_reference(self, offset);\n             if !keys.contains(&key) {\n---\n\n\n---\n\nChoice B:\n.github/workflows/_build_js_bindings.yml\n@@ -231,11 +231,17 @@ jobs:\n       - name: Download all artifacts\n         uses: actions/download-artifact@v4\n         with:\n-          path: artifacts\n+          path: rust/js_bindings/artifacts\n+      - name: List downloads\n+        run: ls -R .\n+      - name: Flatten artifact directory\n+        run: find artifacts -type f -name '*.node' -exec mv {} ./artifacts/ \\;\n+      - name: List downloads\n+        run: ls -R .\n       - name: Move artifacts\n         run: pnpm artifacts\n       - name: List packages\n-        run: ls -R ./npm\n+        run: ls -R .\n         shell: bash\n       - name: Publish\n         run: |\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -967,11 +967,7 @@ func (tc *Catalog) ForkCollection(ctx context.Context, forkCollection *model.For\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\t// NOTE: This is a temporary hardcoded limit for the size of the lineage file\n-\t\t// TODO: Load the limit value from quota / scorecard, and/or improve the lineage file design to avoid large lineage file\n-\t\tif len(lineageFile.Dependencies) > 1000000 {\n-\t\t\treturn common.ErrCollectionTooManyFork\n-\t\t}\n+\n \t\tlineageFile.Dependencies = append(lineageFile.Dependencies, &coordinatorpb.CollectionVersionDependency{\n \t\t\tSourceCollectionId:      sourceCollectionIDStr,\n \t\t\tSourceCollectionVersion: uint64(sourceCollection.Version),\n---\nrust/frontend/src/quota/mod.rs\n@@ -336,7 +336,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n         m.insert(UsageType::RegexPatternLength, 0);\n-        m.insert(UsageType::NumForks, 1_000_000);\n+        m.insert(UsageType::NumForks, 10000);\n         m\n     };\n }\n---\nrust/frontend/src/server.rs\n@@ -1175,6 +1175,7 @@ async fn fork_collection(\n         CollectionUuid::from_str(&collection_id).map_err(|_| ValidationError::CollectionId)?;\n     let mut quota_payload = QuotaPayload::new(Action::ForkCollection, tenant.clone(), api_token);\n     quota_payload = quota_payload.with_collection_uuid(collection_id);\n+    quota_payload = quota_payload.with_collection_name(&payload.new_name);\n     server.quota_enforcer.enforce(&quota_payload).await?;\n \n     let _guard =\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionWithoutMetadata(collectionID *string, databaseName *string, softDeletedFlag *bool) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, NULLIF(collections.root_collection_id, '') AS root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nI ran `cargo update PACKAGE` for each package in dependabot that's rust.\n\nLockfile changes only.\n\n## Test plan\n\nCI\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\ndocs/docs.trychroma.com/markdoc/content/integrations/frameworks/llamaindex.md\n@@ -6,5 +6,5 @@ name: LlamaIndex\n # LlamaIndex\n \n - `LlamaIndex` [Vector Store page](https://docs.llamaindex.ai/en/stable/examples/vector_stores/ChromaIndexDemo.html)\n-- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n-- [Chroma Loader on Llamahub](https://llamahub.ai/l/chroma)\n+- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n+- [Chroma Loader on Llamahub](https://llamahub.ai/l/vector_stores/llama-index-vector-stores-chroma)\n---\n\n\n---\n\nChoice B:\ndocs/docs.trychroma.com/markdoc/content/reference/python/client.md\n@@ -272,7 +272,7 @@ List all collections.\n \n **Returns**:\n \n-- `Sequence[CollectionName]` - A list of collection names. `CollectionName` is a string.\n+- `Sequence[Collection]` - A list of collection objects.\n \n \n **Examples**:\n---\ndocs/docs.trychroma.com/markdoc/content/updates/migration.md\n@@ -26,6 +26,8 @@ In this release, we've rewritten much of Chroma in Rust. Performance has signifi\n \n Chroma no longer provides built-in authentication implementations.\n \n+`list_collections` now reverts back to returning `Collection` objects.\n+\n **Chroma in-process changes**\n \n This section is applicable to you if you use Chroma via\n---\n\n\n---\n\nChoice C:\nchromadb/api/types.py\n@@ -790,9 +790,10 @@ def validate_where(where: Where) -> None:\n                     \"$eq\",\n                     \"$in\",\n                     \"$nin\",\n+                    \"$distinct\",\n                 ]:\n                     raise ValueError(\n-                        f\"Expected where operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, \"\n+                        f\"Expected where operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, $distinct, \"\n                         f\"got {operator}\"\n                     )\n \n---\nchromadb/base_types.py\n@@ -17,6 +17,7 @@\n     Literal[\"$lte\"],\n     Literal[\"$ne\"],\n     Literal[\"$eq\"],\n+    Literal[\"$distinct\"],\n ]\n InclusionExclusionOperator = Union[Literal[\"$in\"], Literal[\"$nin\"]]\n OperatorExpression = Union[\n---\nrust/segment/src/sqlite_metadata.rs\n@@ -675,6 +675,12 @@ impl IntoSqliteExpr for MetadataExpression {\n                         }\n                         Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n+                    PrimitiveOperator::Distinct => {\n+                        subq.and_where(scol.eq(sval));\n+                        subq.order_by((Embeddings::Table, Embeddings::Id), sea_query::Order::Asc);\n+                        subq.limit(1);\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n+                    }\n                 }\n             }\n             MetadataComparison::Set(op, vals) => {\n---\nrust/segment/src/test.rs\n@@ -541,6 +541,9 @@ impl CheckRecord for MetadataExpression {\n                     PrimitiveOperator::LessThanOrEqual => {\n                         match_type && stored.is_some_and(|v| *v <= metadata_value)\n                     }\n+                    PrimitiveOperator::Distinct => {\n+                        match_type && stored.is_some_and(|v| *v == metadata_value)\n+                    }\n                 }\n             }\n             MetadataComparison::Set(set_operator, metadata_set_value) => {\n---\nrust/types/src/metadata.rs\n@@ -901,6 +901,7 @@ pub enum PrimitiveOperator {\n     GreaterThanOrEqual,\n     LessThan,\n     LessThanOrEqual,\n+    Distinct,\n }\n \n impl From<chroma_proto::GenericComparator> for PrimitiveOperator {\n---\nrust/types/src/where_parsing.rs\n@@ -320,6 +320,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::Equal;\n             } else if operator == \"$ne\" {\n                 operator_type = PrimitiveOperator::NotEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n@@ -338,6 +340,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::Equal;\n             } else if operator == \"$ne\" {\n                 operator_type = PrimitiveOperator::NotEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n@@ -364,6 +368,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::GreaterThan;\n             } else if operator == \"$gte\" {\n                 operator_type = PrimitiveOperator::GreaterThanOrEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n@@ -390,6 +396,8 @@ pub fn parse_where(json_payload: &Value) -> Result<Where, WhereValidationError>\n                 operator_type = PrimitiveOperator::GreaterThan;\n             } else if operator == \"$gte\" {\n                 operator_type = PrimitiveOperator::GreaterThanOrEqual;\n+            } else if operator == \"$distinct\" {\n+                operator_type = PrimitiveOperator::Distinct;\n             } else {\n                 return Err(WhereValidationError::WhereClause);\n             }\n---\nrust/worker/src/execution/operators/filter.rs\n@@ -80,6 +80,8 @@ pub enum FilterError {\n     RecordReader(#[from] RecordSegmentReaderCreationError),\n     #[error(\"Error parsing regular expression: {0}\")]\n     Regex(#[from] ChromaRegexError),\n+    #[error(\"Distinct filter is not supported\")]\n+    Distinct,\n }\n \n impl ChromaError for FilterError {\n@@ -91,6 +93,7 @@ impl ChromaError for FilterError {\n             FilterError::Record(e) => e.code(),\n             FilterError::RecordReader(e) => e.code(),\n             FilterError::Regex(_) => ErrorCodes::InvalidArgument,\n+            FilterError::Distinct => ErrorCodes::InvalidArgument,\n         }\n     }\n }\n@@ -170,6 +173,7 @@ impl<'me> MetadataLogReader<'me> {\n                 PrimitiveOperator::NotEqual => unreachable!(\n                     \"Inequality filter should be handled above the metadata provider level\"\n                 ),\n+                PrimitiveOperator::Distinct => return Err(FilterError::Distinct),\n             };\n             Ok(metadata_value_to_offset_ids\n                 .range(bounds)\n@@ -334,6 +338,7 @@ impl<'me> MetadataProvider<'me> {\n                         PrimitiveOperator::NotEqual => unreachable!(\n                             \"Inequality filter should be handled above the metadata provider level\"\n                         ),\n+                        PrimitiveOperator::Distinct => return Err(FilterError::Distinct),\n                     }\n                 } else {\n                     Ok(RoaringBitmap::new())\n@@ -391,7 +396,8 @@ impl<'me> RoaringMetadataFilter<'me> for MetadataExpression {\n                     | PrimitiveOperator::GreaterThan\n                     | PrimitiveOperator::GreaterThanOrEqual\n                     | PrimitiveOperator::LessThan\n-                    | PrimitiveOperator::LessThanOrEqual => SignedRoaringBitmap::Include(\n+                    | PrimitiveOperator::LessThanOrEqual\n+                    | PrimitiveOperator::Distinct => SignedRoaringBitmap::Include(\n                         metadata_provider\n                             .filter_by_metadata(&self.key, metadata_value, primitive_operator)\n                             .await?,\n---\n\n\n---\n\nChoice D:\nCargo.lock\n@@ -1314,9 +1314,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.2.1\"\n+version = \"1.2.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fd9de9f2205d5ef3fd67e685b0df337994ddd4495e2a28d185500d0e1edfea47\"\n+checksum = \"8691782945451c1c383942c4874dbe63814f61cb57ef773cda2972682b7bb3c0\"\n dependencies = [\n  \"jobserver\",\n  \"libc\",\n@@ -2319,9 +2319,9 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.5.12\"\n+version = \"0.5.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab3db02a9c5b5121e1e42fbdb1aeb65f5e02624cc58c43f2884c6ccac0b82f95\"\n+checksum = \"82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2\"\n dependencies = [\n  \"crossbeam-utils\",\n ]\n@@ -4502,7 +4502,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34\"\n dependencies = [\n  \"cfg-if\",\n- \"windows-targets 0.52.6\",\n+ \"windows-targets 0.48.5\",\n ]\n \n [[package]]\n@@ -5315,9 +5315,9 @@ checksum = \"0ab1bc2a289d34bd04a330323ac98a1b4bc82c9d9fcb1e66b63caa84da26b575\"\n \n [[package]]\n name = \"openssl\"\n-version = \"0.10.66\"\n+version = \"0.10.72\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9529f4786b70a3e8c61e11179af17ab6188ad8d0ded78c5529441ed39d4bd9c1\"\n+checksum = \"fedfea7d58a1f73118430a55da6a286e7b044961736ce96a16a17068ea25e5da\"\n dependencies = [\n  \"bitflags 2.9.0\",\n  \"cfg-if\",\n@@ -5347,9 +5347,9 @@ checksum = \"ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf\"\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.103\"\n+version = \"0.9.108\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7f9e8deee91df40a943c71b917e5874b951d32a802526c85721ce3b776c929d6\"\n+checksum = \"e145e1651e858e820e4860f7b9c5e169bc1d8ce1c86043be79fa7b7634821847\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -6029,9 +6029,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"57fe09249128b3173d092de9523eaa75136bf7ba85e0d69eca241c7939c933cc\"\n+checksum = \"7778bffd85cf38175ac1f545509665d0b9b92a198ca7941f131f85f7a4f9a872\"\n dependencies = [\n  \"cfg-if\",\n  \"indoc\",\n@@ -6047,29 +6047,29 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-build-config\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cd3927b5a78757a0d71aa9dff669f903b1eb64b54142a9bd9f757f8fde65fd7\"\n+checksum = \"94f6cbe86ef3bf18998d9df6e0f3fc1050a8c5efa409bf712e661a4366e010fb\"\n dependencies = [\n  \"once_cell\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"pyo3-ffi\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dab6bb2102bd8f991e7749f130a70d05dd557613e39ed2deeee8e9ca0c4d548d\"\n+checksum = \"e9f1b4c431c0bb1c8fb0a338709859eed0d030ff6daa34368d3b152a63dfdd8d\"\n dependencies = [\n  \"libc\",\n  \"pyo3-build-config\",\n ]\n \n [[package]]\n name = \"pyo3-macros\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"91871864b353fd5ffcb3f91f2f703a22a9797c91b9ab497b1acac7b07ae509c7\"\n+checksum = \"fbc2201328f63c4710f68abdf653c89d8dbc2858b88c5d88b0ff38a75288a9da\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"pyo3-macros-backend\",\n@@ -6079,9 +6079,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-macros-backend\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"43abc3b80bc20f3facd86cd3c60beed58c3e2aa26213f3cda368de39c60a27e4\"\n+checksum = \"fca6726ad0f3da9c9de093d6f116a93c1a38e417ed73bf138472cf4064f72028\"\n dependencies = [\n  \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n@@ -6517,15 +6517,14 @@ dependencies = [\n \n [[package]]\n name = \"ring\"\n-version = \"0.17.8\"\n+version = \"0.17.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c17fa4cb658e3583423e915b9f3acc01cceaee1860e33d59ebae66adc3a2dc0d\"\n+checksum = \"a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7\"\n dependencies = [\n  \"cc\",\n  \"cfg-if\",\n  \"getrandom 0.2.15\",\n  \"libc\",\n- \"spin\",\n  \"untrusted\",\n  \"windows-sys 0.52.0\",\n ]\n@@ -7303,7 +7302,7 @@ version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"03c3c6b7927ffe7ecaa769ee0e3994da3b8cafc8f444578982c83ecb161af917\"\n dependencies = [\n- \"heck 0.5.0\",\n+ \"heck 0.4.1\",\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n  \"syn 2.0.101\",\n@@ -8058,9 +8057,9 @@ checksum = \"1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20\"\n \n [[package]]\n name = \"tokio\"\n-version = \"1.41.1\"\n+version = \"1.45.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22cfb5bee7a6a52939ca9224d6ac897bb669134078daa8735560897f69de4d33\"\n+checksum = \"2513ca694ef9ede0fb23fe71a4ee4107cb102b9dc1930f6d0fd77aae068ae165\"\n dependencies = [\n  \"backtrace\",\n  \"bytes\",\n@@ -8086,9 +8085,9 @@ dependencies = [\n \n [[package]]\n name = \"tokio-macros\"\n-version = \"2.4.0\"\n+version = \"2.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752\"\n+checksum = \"6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis will trace the return value of every log call when it takes an Err(_) variant.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -140,21 +140,20 @@ impl GarbageCollector {\n             .as_ref()\n             .ok_or(GarbageCollectCollectionError::Uninitialized)?;\n \n-        let use_v1_orchestrator = match cleanup_mode {\n-            CleanupMode::DryRun | CleanupMode::Rename | CleanupMode::Delete => true,\n-            CleanupMode::DryRunV2 | CleanupMode::DeleteV2 => false,\n-        };\n-\n-        if use_v1_orchestrator {\n+        if cleanup_mode.is_v2() {\n             let orchestrator =\n-                crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+                crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n                     collection.id,\n                     collection.version_file_path,\n+                    collection.lineage_file_path,\n                     absolute_cutoff_time,\n                     self.sysdb_client.clone(),\n                     dispatcher.clone(),\n+                    system.clone(),\n                     self.storage.clone(),\n+                    self.root_manager.clone(),\n                     cleanup_mode,\n+                    2,\n                 );\n \n             let started_at = SystemTime::now();\n@@ -178,23 +177,19 @@ impl GarbageCollector {\n                     format!(\"{:?}\", cleanup_mode),\n                 )],\n             );\n+\n             return Ok(result);\n         }\n \n-        let orchestrator =\n-            crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n-                collection.id,\n-                collection.version_file_path,\n-                collection.lineage_file_path,\n-                absolute_cutoff_time,\n-                self.sysdb_client.clone(),\n-                dispatcher.clone(),\n-                system.clone(),\n-                self.storage.clone(),\n-                self.root_manager.clone(),\n-                cleanup_mode,\n-                2,\n-            );\n+        let orchestrator = crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+            collection.id,\n+            collection.version_file_path,\n+            absolute_cutoff_time,\n+            self.sysdb_client.clone(),\n+            dispatcher.clone(),\n+            self.storage.clone(),\n+            cleanup_mode,\n+        );\n \n         let started_at = SystemTime::now();\n         let result = orchestrator.run(system.clone()).await?;\n@@ -217,7 +212,6 @@ impl GarbageCollector {\n                 format!(\"{:?}\", cleanup_mode),\n             )],\n         );\n-\n         Ok(result)\n     }\n }\n@@ -360,9 +354,18 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 continue;\n             }\n \n-            if collection.lineage_file_path.is_some() {\n+            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n+                tenant_mode_overrides\n+                    .get(&collection.tenant)\n+                    .cloned()\n+                    .unwrap_or(self.default_cleanup_mode)\n+            } else {\n+                self.default_cleanup_mode\n+            };\n+\n+            if collection.lineage_file_path.is_some() && !cleanup_mode.is_v2() {\n                 tracing::debug!(\n-                    \"Skipping garbage collection for root of fork tree: {}\",\n+                    \"Skipping garbage collection for root of fork tree because GC v1 cannot handle fork trees: {}\",\n                     collection.id\n                 );\n                 num_skipped_jobs += 1;\n@@ -376,17 +379,6 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 collection.version_file_path\n             );\n \n-            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n-                tenant_mode_overrides\n-                    .get(&collection.tenant)\n-                    .cloned()\n-                    .unwrap_or(self.default_cleanup_mode)\n-            } else {\n-                self.default_cleanup_mode\n-            };\n-\n-            tracing::info!(\"Creating gc orchestrator for collection: {}\", collection.id);\n-\n             let instrumented_span = span!(parent: None, tracing::Level::INFO, \"Garbage collection job\", collection_id = ?collection.id, tenant_id = %collection.tenant, cleanup_mode = ?cleanup_mode);\n             instrumented_span.follows_from(Span::current());\n \n@@ -1011,6 +1003,26 @@ mod tests {\n         let (collection_in_delete_mode, database_name_in_delete_mode) =\n             collection_in_delete_mode_handle.await.unwrap();\n \n+        // Fork collection in delete mode to give it a lineage file (only GC v2 can handle fork trees)\n+        {\n+            let source_collection = sysdb\n+                .get_collections(Some(collection_in_delete_mode), None, None, None, None, 0)\n+                .await\n+                .unwrap();\n+            let source_collection = source_collection.first().unwrap();\n+\n+            sysdb\n+                .fork_collection(\n+                    collection_in_delete_mode,\n+                    source_collection.total_records_post_compaction,\n+                    source_collection.total_records_post_compaction,\n+                    CollectionUuid::new(),\n+                    \"test-fork\".to_string(),\n+                )\n+                .await\n+                .unwrap();\n+        }\n+\n         // Wait 1 second for cutoff time\n         tokio::time::sleep(Duration::from_secs(1)).await;\n \n---\nrust/garbage_collector/src/types.rs\n@@ -19,6 +19,12 @@ pub enum CleanupMode {\n     DeleteV2,\n }\n \n+impl CleanupMode {\n+    pub fn is_v2(&self) -> bool {\n+        matches!(self, CleanupMode::DryRunV2 | CleanupMode::DeleteV2)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub enum VersionStatus {\n     #[allow(dead_code)]\n---\n\n\n---\n\nChoice B:\nrust/log/src/log.rs\n@@ -30,7 +30,7 @@ pub enum Log {\n }\n \n impl Log {\n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn read(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -54,7 +54,7 @@ impl Log {\n     }\n \n     // ScoutLogs returns the offset of the next record to be inserted into the log.\n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn scout_logs(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -76,7 +76,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self, records))]\n+    #[tracing::instrument(skip(self, records), err(Display))]\n     pub async fn push_logs(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -95,7 +95,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn fork_logs(\n         &mut self,\n         source_collection_id: CollectionUuid,\n@@ -111,7 +111,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn get_collections_with_new_data(\n         &mut self,\n         min_compaction_size: u64,\n@@ -129,7 +129,7 @@ impl Log {\n         }\n     }\n \n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn update_collection_log_offset(\n         &mut self,\n         collection_id: CollectionUuid,\n@@ -153,7 +153,7 @@ impl Log {\n     }\n \n     /// Only supported in distributed. Sqlite has a different workflow.\n-    #[tracing::instrument(skip(self))]\n+    #[tracing::instrument(skip(self), err(Display))]\n     pub async fn purge_dirty_for_collection(\n         &mut self,\n         collection_id: CollectionUuid,\n---\n\n\n---\n\nChoice C:\nchromadb/test/utils/wait_for_version_increase.py\n@@ -23,7 +23,8 @@ def wait_for_version_increase(\n     while curr_version == initial_version:\n         time.sleep(TIMEOUT_INTERVAL)\n         if time.time() - initial_time > timeout:\n-            raise TimeoutError(\"Model was not updated in time\")\n+            collection_id = client.get_collection(collection_name).id\n+            raise TimeoutError(f\"Model was not updated in time for {collection_id}\")\n         curr_version = get_collection_version(client, collection_name)\n \n     return curr_version\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -56,3 +56,5 @@ circuit_breaker:\n   requests: 1000\n enable_span_indexing: true\n default_knn_index: \"spann\"\n+tenants_to_migrate_immediately:\n+- \"default_tenant\"\n---\nrust/log-service/src/lib.rs\n@@ -896,6 +896,14 @@ impl LogServer {\n         self.metrics\n             .dirty_log_records_read\n             .add(dirty_markers.len() as u64, &[]);\n+        let Some((last_record_inserted, _)) = dirty_markers.last() else {\n+            let backpressure = vec![];\n+            self.set_backpressure(&backpressure);\n+            let mut need_to_compact = self.need_to_compact.lock();\n+            let mut rollups = HashMap::new();\n+            std::mem::swap(&mut *need_to_compact, &mut rollups);\n+            return Ok(());\n+        };\n         let mut rollups = DirtyMarker::coalesce_markers(&dirty_markers)?;\n         self.enrich_dirty_log(&mut rollups).await?;\n         let mut markers = vec![];\n@@ -919,7 +927,8 @@ impl LogServer {\n             markers.push(serde_json::to_string(&DirtyMarker::Cleared).map(Vec::from)?);\n         }\n         let mut new_cursor = cursor.clone();\n-        new_cursor.position = self.dirty_log.append_many(markers).await?;\n+        self.dirty_log.append_many(markers).await?;\n+        new_cursor.position = *last_record_inserted + 1u64;\n         let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n             return Err(Error::CouldNotGetDirtyLogCursors);\n         };\n---\n\n\n---\n\nChoice D:\n.github/actions/docker/action.yaml\n@@ -17,11 +17,6 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n-    # https://github.com/docker/setup-qemu-action - for multiplatform builds\n-    - name: Set up QEMU\n-      uses: docker/setup-qemu-action@v2\n-    - name: Set up Docker Buildx\n-      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n.github/workflows/_build_release_container.yml\n@@ -33,43 +33,106 @@ permissions:\n env:\n   GHCR_IMAGE_NAME: \"ghcr.io/chroma-core/chroma\"\n   DOCKERHUB_IMAGE_NAME: \"chromadb/chroma\"\n-  PLATFORMS: linux/amd64,linux/arm64 #linux/riscv64, linux/arm/v7\n \n jobs:\n   build:\n-    name: Build and publish container image\n+    name: Build image for ${{ matrix.platform }}\n     runs-on: blacksmith-16vcpu-ubuntu-2204\n+    strategy:\n+      matrix:\n+        platform: [amd64, arm64]\n+        include:\n+          - platform: amd64\n+            runner: blacksmith-16vcpu-ubuntu-2204\n+            docker_platform: linux/amd64\n+          - platform: arm64\n+            runner: blacksmith-16vcpu-ubuntu-2204-arm\n+            docker_platform: linux/arm64\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n         with:\n           fetch-depth: 0\n+\n       - name: Set up Docker\n         uses: ./.github/actions/docker\n         with:\n           ghcr-username: ${{ github.actor }}\n           ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n           dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-      - name: Compute tags\n+\n+      - name: Compute arch-specific tags\n+        id: tags\n         shell: bash\n-        id: compute_tags\n         run: |\n-          tags=\"${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }},${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\"\n-          if [ \"${{ inputs.tag_as_latest }}\" = \"true\" ]; then\n-            tags=\"${tags},${{ env.GHCR_IMAGE_NAME }}:latest,${{ env.DOCKERHUB_IMAGE_NAME }}:latest\"\n-          fi\n+          arch_tag=\"${{ inputs.tag }}-${{ matrix.platform }}\"\n+          ghcr=\"${{ env.GHCR_IMAGE_NAME }}:${arch_tag}\"\n+          dhub=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${arch_tag}\"\n+          echo \"arch_tag=$arch_tag\"      >> $GITHUB_OUTPUT\n \n-          echo \"tags=${tags}\" >> $GITHUB_OUTPUT\n+          # expose *matrix-unique* step outputs\n+          echo \"ghcr_tag_${{ matrix.platform }}=$ghcr\"         >> $GITHUB_OUTPUT\n+          echo \"dockerhub_tag_${{ matrix.platform }}=$dhub\"    >> $GITHUB_OUTPUT\n+\n+          # these two tags are what the build-push action will publish for *this* arch\n+          echo \"tags=$ghcr,$dhub\" >> $GITHUB_OUTPUT\n \n       - name: Build and push image\n         uses: useblacksmith/build-push-action@v1.1\n         with:\n           context: .\n           file: rust/Dockerfile\n           target: cli\n-          platforms: ${{ env.PLATFORMS }}\n+          platforms: ${{ matrix.docker_platform }}\n           push: true\n           build-args: |\n             RELEASE_MODE=1\n-          tags: ${{ steps.compute_tags.outputs.tags }}\n+          tags: ${{ steps.tags.outputs.tags }}\n+    outputs:\n+      ghcr_tag_amd64:      ${{ steps.tags.outputs.ghcr_tag_amd64 }}\n+      ghcr_tag_arm64:      ${{ steps.tags.outputs.ghcr_tag_arm64 }}\n+      dockerhub_tag_amd64: ${{ steps.tags.outputs.dockerhub_tag_amd64 }}\n+      dockerhub_tag_arm64: ${{ steps.tags.outputs.dockerhub_tag_arm64 }}\n+\n+  merge:\n+    name: Merge platform manifests\n+    runs-on: blacksmith-4vcpu-ubuntu-2204\n+    needs:\n+      - build\n+    steps:\n+      - name: Set up Docker\n+        uses: ./.github/actions/docker\n+        with:\n+          ghcr-username: ${{ github.actor }}\n+          ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n+          dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n+          dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n+\n+      - name: Create and push manifest\n+        shell: bash\n+        run: |\n+          set -euo pipefail\n+\n+          # Pull the per-arch tags from job-level outputs\n+          ghcr_amd64='${{ needs.build.outputs.ghcr_tag_amd64 }}'\n+          ghcr_arm64='${{ needs.build.outputs.ghcr_tag_arm64 }}'\n+          dhub_amd64='${{ needs.build.outputs.dockerhub_tag_amd64 }}'\n+          dhub_arm64='${{ needs.build.outputs.dockerhub_tag_arm64 }}'\n+\n+          base_tag='${{ inputs.tag }}'\n+          ghcr_base=\"${{ env.GHCR_IMAGE_NAME }}:${base_tag}\"\n+          dhub_base=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${base_tag}\"\n+\n+          docker buildx imagetools create --tag \"$ghcr_base\" $ghcr_amd64 $ghcr_arm64\n+          docker buildx imagetools create --tag \"$dhub_base\"  $dhub_amd64 $dhub_arm64\n+\n+          if [[ \"${{ inputs.tag_as_latest }}\" == \"true\" ]]; then\n+            docker buildx imagetools create --tag \"${{ env.GHCR_IMAGE_NAME }}:latest\"  $ghcr_amd64 $ghcr_arm64\n+            docker buildx imagetools create --tag \"${{ env.DOCKERHUB_IMAGE_NAME }}:latest\" $dhub_amd64 $dhub_arm64\n+          fi\n+\n+      - name: Inspect image\n+        run: |\n+          docker buildx imagetools inspect ${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }}\n+          docker buildx imagetools inspect ${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Removed the num regex predicates\n  - Added the regex pattern length with a default of 0\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\nNone\n\n\n---\n\nChoice A:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -374,7 +374,7 @@ func (tc *Catalog) createCollectionImpl(txCtx context.Context, createCollection\n \t\treturn nil, false, common.ErrConcurrentDeleteCollection\n \t}\n \tresult := convertCollectionToModel(collectionList)[0]\n-\treturn result, true, nil\n+\treturn result, created, nil\n }\n \n func (tc *Catalog) CreateCollection(ctx context.Context, createCollection *model.CreateCollection, ts types.Timestamp) (*model.Collection, bool, error) {\n@@ -1251,7 +1251,6 @@ func (tc *Catalog) CreateCollectionAndSegments(ctx context.Context, createCollec\n \t\t}\n \n \t\t// If collection already exists, then do not create segments.\n-\t\t// TODO: Should we check to see if segments does not exist? and create them?\n \t\tif !created {\n \t\t\treturn nil\n \t\t}\n---\n\n\n---\n\nChoice B:\nrust/frontend/src/quota/mod.rs\n@@ -243,7 +243,7 @@ pub enum UsageType {\n     NumCollections,        // Total number of collections for a tenant\n     NumDatabases,          // Total number of databases for a tenant\n     NumQueryIDs,           // Number of IDs to filter by in a query\n-    NumRegexPredicates,    // Number of regex predicates in the where_document\n+    RegexPatternLength,    // Length of regex pattern specified in filter\n     NumForks,              // Number of forks a root collection may have\n }\n \n@@ -274,7 +274,7 @@ impl fmt::Display for UsageType {\n             UsageType::NumCollections => write!(f, \"Number of collections\"),\n             UsageType::NumDatabases => write!(f, \"Number of databases\"),\n             UsageType::NumQueryIDs => write!(f, \"Number of IDs to filter by in a query\"),\n-            UsageType::NumRegexPredicates => write!(f, \"Number of regex predicates\"),\n+            UsageType::RegexPatternLength => write!(f, \"Length of regex pattern\"),\n             UsageType::NumForks => write!(f, \"Number of forks\"),\n         }\n     }\n@@ -305,7 +305,7 @@ impl TryFrom<&str> for UsageType {\n             \"num_collections\" => Ok(UsageType::NumCollections),\n             \"num_databases\" => Ok(UsageType::NumDatabases),\n             \"num_query_ids\" => Ok(UsageType::NumQueryIDs),\n-            \"num_regex_predicates\" => Ok(UsageType::NumRegexPredicates),\n+            \"regex_pattern_length\" => Ok(UsageType::RegexPatternLength),\n             \"num_forks\" => Ok(UsageType::NumForks),\n             _ => Err(format!(\"Invalid UsageType: {}\", value)),\n         }\n@@ -335,7 +335,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumCollections, 1_000_000);\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n-        m.insert(UsageType::NumRegexPredicates, 0);\n+        m.insert(UsageType::RegexPatternLength, 0);\n         m.insert(UsageType::NumForks, 1_000_000);\n         m\n     };\n---\n\n\n---\n\nChoice C:\nTiltfile\n@@ -140,6 +140,21 @@ else:\n     target='garbage_collector'\n   )\n \n+if config.tilt_subcommand == \"ci\":\n+  custom_build(\n+    'load-service',\n+    'docker buildx build --load -t $EXPECTED_REF --target load_service -f ./rust/load/Dockerfile .',\n+    ['./rust/', './idl/', './Cargo.toml', './Cargo.lock']\n+  )\n+else:\n+  docker_build(\n+    'load-service',\n+    '.',\n+    only=[\"rust/\", \"idl/\", \"Cargo.toml\", \"Cargo.lock\"],\n+    dockerfile='./rust/load/Dockerfile',\n+    target='load_service'\n+  )\n+\n \n # First install the CRD\n k8s_yaml(\n@@ -169,6 +184,7 @@ k8s_yaml([\n   'k8s/test/grafana.yaml',\n   'k8s/test/jaeger-service.yaml',\n   'k8s/test/jaeger.yaml',\n+  'k8s/test/load-service.yaml',\n   'k8s/test/minio.yaml',\n   'k8s/test/prometheus.yaml',\n   'k8s/test/test-memberlist-cr.yaml',\n@@ -226,6 +242,7 @@ k8s_resource('sysdb', resource_deps=['sysdb-migration-latest'], labels=[\"chroma\"\n k8s_resource('rust-frontend-service', resource_deps=['sysdb', 'logservice', 'rust-log-service'], labels=[\"chroma\"], port_forwards='3000:8000')\n k8s_resource('query-service', resource_deps=['sysdb'], labels=[\"chroma\"], port_forwards='50053:50051')\n k8s_resource('compaction-service', resource_deps=['sysdb'], labels=[\"chroma\"])\n+k8s_resource('load-service', resource_deps=['k8s_setup'], labels=[\"infrastructure\"], port_forwards='3001:3001')\n k8s_resource('jaeger', resource_deps=['k8s_setup'], labels=[\"observability\"])\n k8s_resource('grafana', resource_deps=['k8s_setup'], labels=[\"observability\"])\n k8s_resource('prometheus', resource_deps=['k8s_setup'], labels=[\"observability\"])\n---\nk8s/test/load-service.yaml\n@@ -0,0 +1,81 @@\n+---\n+\n+apiVersion: v1\n+kind: Namespace\n+metadata:\n+  name: chroma-load\n+\n+---\n+\n+apiVersion: apps/v1\n+kind: Deployment\n+metadata:\n+  name: load-service\n+  namespace: chroma-load\n+spec:\n+  replicas: 1\n+  selector:\n+    matchLabels:\n+      app: load-service\n+  template:\n+    metadata:\n+      namespace: chroma-load\n+      labels:\n+        app: load-service\n+    spec:\n+      containers:\n+        - name: load-service\n+          image: load-service\n+          imagePullPolicy: IfNotPresent\n+          ports:\n+            - containerPort: 3001\n+              name: http\n+          env:\n+            - name: CONFIG_PATH\n+              value: /config/config.yaml\n+            - name: RUST_LOG\n+              value: \"info\"\n+          volumeMounts:\n+            - name: load-service-config\n+              mountPath: /config/\n+            - name: load-service-persistent-state\n+              mountPath: /state/\n+      volumes:\n+        - name: load-service-config\n+          configMap:\n+            name: load-service-config\n+        - name: load-service-persistent-state\n+          hostPath:\n+            path: /tmp/chroma/load-service\n+            type: DirectoryOrCreate\n+\n+---\n+\n+apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: load-service-config\n+  namespace: chroma-load\n+data:\n+  config.yaml: |\n+    load_service:\n+      service_name: \"chroma-load\"\n+      otel_endpoint: \"http://otel-collector.chroma:4317\"\n+      port: 3001\n+      persistent_state_path: \"/state/load-service.json\"\n+\n+---\n+\n+apiVersion: v1\n+kind: Service\n+metadata:\n+  name: load-service\n+  namespace: chroma-load\n+spec:\n+  ports:\n+    - name: http\n+      port: 3001\n+      targetPort: 3001\n+  selector:\n+    app: load-service\n+  type: ClusterIP\n---\nrust/load/src/opentelemetry_config.rs\n@@ -57,7 +57,7 @@ pub(crate) fn init_otel_tracing(service_name: &String, otel_endpoint: &String) {\n     // Layer for adding our configured tracer.\n     // Export everything at this layer. The backend i.e. honeycomb or jaeger will filter at its end.\n     let exporter_layer = tracing_opentelemetry::OpenTelemetryLayer::new(tracer)\n-        .with_filter(tracing_subscriber::filter::LevelFilter::ERROR);\n+        .with_filter(tracing_subscriber::filter::LevelFilter::INFO);\n     // Layer for printing spans to stdout. Only print INFO logs by default.\n     let stdout_layer =\n         BunyanFormattingLayer::new(service_name.clone().to_string(), std::io::stdout)\n---\n\n\n---\n\nChoice D:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - ...\r\n- New functionality\r\n  - Implements the `count_forks` method on `TestSysDb`\r\n  - Updates quotas to support a `UsageType::NumForks` `Action::ForkCollection`\r\n  - Updates `fork_collection` API to enforce quotas on `Action::ForkCollection`\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n<!-- Summary by @propel-code-bot -->\r\n\r\n---\r\n\r\nThis PR implements the `count_forks` method in the `TestSysDb` class and adds fork collection support to the quota system. The implementation returns a fixed value of 10 for testing purposes, and changes the return type from `u64` to `usize` for consistency.\r\n\r\n*This summary was automatically generated by @propel-code-bot*\n\n---\n\nChoice A:\n.github/workflows/_build_js_bindings.yml\n@@ -231,11 +231,17 @@ jobs:\n       - name: Download all artifacts\n         uses: actions/download-artifact@v4\n         with:\n-          path: artifacts\n+          path: rust/js_bindings/artifacts\n+      - name: List downloads\n+        run: ls -R .\n+      - name: Flatten artifact directory\n+        run: find artifacts -type f -name '*.node' -exec mv {} ./artifacts/ \\;\n+      - name: List downloads\n+        run: ls -R .\n       - name: Move artifacts\n         run: pnpm artifacts\n       - name: List packages\n-        run: ls -R ./npm\n+        run: ls -R .\n         shell: bash\n       - name: Publish\n         run: |\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\nChoice B:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.7\"\n+__version__ = \"1.0.8\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.7\"\n+      \"Default\": \"1.0.8\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice C:\n.github/workflows/_rust-tests.yml\n@@ -42,7 +42,9 @@ jobs:\n     strategy:\n       matrix:\n         platform: [blacksmith-16vcpu-ubuntu-2204]\n+        partition: [1, 2]\n     runs-on: ${{ matrix.platform }}\n+    name: Integration test ${{ matrix.partition }}/2\n     # OIDC token auth for AWS\n     permissions:\n       contents: read\n@@ -66,12 +68,12 @@ jobs:\n       - name: Build CLI\n         run: cargo build --bin chroma\n       - name: Run tests\n-        run: cargo nextest run --profile ci_k8s_integration\n+        run: cargo nextest run --profile ci_k8s_integration --partition hash:${{ matrix.partition }}/2\n       - name: Save service logs to artifact\n         if: always()\n         uses: ./.github/actions/export-tilt-logs\n         with:\n-          artifact-name: \"rust-integration-test\"\n+          artifact-name: \"rust-integration-test-${{ matrix.partition }}\"\n   test-benches:\n     strategy:\n       matrix:\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/quota/mod.rs\n@@ -20,6 +20,7 @@ pub enum Action {\n     Update,\n     Upsert,\n     Query,\n+    ForkCollection,\n }\n \n impl fmt::Display for Action {\n@@ -35,6 +36,7 @@ impl fmt::Display for Action {\n             Action::Update => write!(f, \"Update\"),\n             Action::Upsert => write!(f, \"Upsert\"),\n             Action::Query => write!(f, \"Query\"),\n+            Action::ForkCollection => write!(f, \"Fork Collection\"),\n         }\n     }\n }\n@@ -54,6 +56,7 @@ impl TryFrom<&str> for Action {\n             \"update\" => Ok(Action::Update),\n             \"upsert\" => Ok(Action::Upsert),\n             \"query\" => Ok(Action::Query),\n+            \"fork_collection\" => Ok(Action::ForkCollection),\n             _ => Err(format!(\"Invalid Action: {}\", value)),\n         }\n     }\n@@ -241,6 +244,7 @@ pub enum UsageType {\n     NumDatabases,          // Total number of databases for a tenant\n     NumQueryIDs,           // Number of IDs to filter by in a query\n     NumRegexPredicates,    // Number of regex predicates in the where_document\n+    NumForks,              // Number of forks a root collection may have\n }\n \n impl fmt::Display for UsageType {\n@@ -271,6 +275,7 @@ impl fmt::Display for UsageType {\n             UsageType::NumDatabases => write!(f, \"Number of databases\"),\n             UsageType::NumQueryIDs => write!(f, \"Number of IDs to filter by in a query\"),\n             UsageType::NumRegexPredicates => write!(f, \"Number of regex predicates\"),\n+            UsageType::NumForks => write!(f, \"Number of forks\"),\n         }\n     }\n }\n@@ -301,6 +306,7 @@ impl TryFrom<&str> for UsageType {\n             \"num_databases\" => Ok(UsageType::NumDatabases),\n             \"num_query_ids\" => Ok(UsageType::NumQueryIDs),\n             \"num_regex_predicates\" => Ok(UsageType::NumRegexPredicates),\n+            \"num_forks\" => Ok(UsageType::NumForks),\n             _ => Err(format!(\"Invalid UsageType: {}\", value)),\n         }\n     }\n@@ -330,6 +336,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n         m.insert(UsageType::NumRegexPredicates, 0);\n+        m.insert(UsageType::NumForks, 1_000_000);\n         m\n     };\n }\n---\nrust/frontend/src/server.rs\n@@ -1166,10 +1166,19 @@ async fn fork_collection(\n             },\n         )\n         .await?;\n-    let _guard =\n-        server.scorecard_request(&[\"op:fork_collection\", format!(\"tenant:{}\", tenant).as_str()])?;\n+\n+    let api_token = headers\n+        .get(\"x-chroma-token\")\n+        .map(|val| val.to_str().unwrap_or_default())\n+        .map(|val| val.to_string());\n     let collection_id =\n         CollectionUuid::from_str(&collection_id).map_err(|_| ValidationError::CollectionId)?;\n+    let mut quota_payload = QuotaPayload::new(Action::ForkCollection, tenant.clone(), api_token);\n+    quota_payload = quota_payload.with_collection_uuid(collection_id);\n+    server.quota_enforcer.enforce(&quota_payload).await?;\n+\n+    let _guard =\n+        server.scorecard_request(&[\"op:fork_collection\", format!(\"tenant:{}\", tenant).as_str()])?;\n \n     let request = chroma_types::ForkCollectionRequest::try_new(\n         tenant,\n---\nrust/sysdb/src/sysdb.rs\n@@ -343,11 +343,11 @@ impl SysDb {\n     pub async fn count_forks(\n         &mut self,\n         source_collection_id: CollectionUuid,\n-    ) -> Result<u64, CountForksError> {\n+    ) -> Result<usize, CountForksError> {\n         match self {\n             SysDb::Grpc(grpc) => grpc.count_forks(source_collection_id).await,\n             SysDb::Sqlite(_) => Err(CountForksError::Local),\n-            SysDb::Test(_) => Err(CountForksError::Local),\n+            SysDb::Test(test) => test.count_forks(source_collection_id).await,\n         }\n     }\n \n@@ -989,7 +989,7 @@ impl GrpcSysDb {\n     pub async fn count_forks(\n         &mut self,\n         source_collection_id: CollectionUuid,\n-    ) -> Result<u64, CountForksError> {\n+    ) -> Result<usize, CountForksError> {\n         let res = self\n             .client\n             .count_forks(chroma_proto::CountForksRequest {\n@@ -1002,7 +1002,7 @@ impl GrpcSysDb {\n             })?\n             .into_inner();\n \n-        Ok(res.count)\n+        Ok(res.count as usize)\n     }\n \n     pub async fn get_collections_to_gc(\n---\nrust/sysdb/src/test_sysdb.rs\n@@ -1,7 +1,8 @@\n use chroma_types::{\n-    Collection, CollectionAndSegments, CollectionUuid, Database, FlushCompactionResponse,\n-    GetCollectionSizeError, GetCollectionWithSegmentsError, GetSegmentsError, ListDatabasesError,\n-    ListDatabasesResponse, Segment, SegmentFlushInfo, SegmentScope, SegmentType, Tenant,\n+    Collection, CollectionAndSegments, CollectionUuid, CountForksError, Database,\n+    FlushCompactionResponse, GetCollectionSizeError, GetCollectionWithSegmentsError,\n+    GetSegmentsError, ListDatabasesError, ListDatabasesResponse, Segment, SegmentFlushInfo,\n+    SegmentScope, SegmentType, Tenant,\n };\n use chroma_types::{GetCollectionsError, SegmentUuid};\n use parking_lot::Mutex;\n@@ -541,4 +542,11 @@ impl TestSysDb {\n             vector_segment,\n         })\n     }\n+\n+    pub(crate) async fn count_forks(\n+        &mut self,\n+        _source_collection_id: CollectionUuid,\n+    ) -> Result<usize, CountForksError> {\n+        Ok(10)\n+    }\n }\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nWe had previously decided that providing embedding functions would now be done via the config. This PR makes it so that embedding functions, even if provided via the existing embedding function parameter, would still be routed to the config in the case where the user does not specify an EF in the config. So priority would be\r\n1. config provided EF\r\n2. parameter level EF\r\n\r\n- Improvements & Bug fixes\r\n  - ...\r\n- New functionality\r\n  - ...\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nchromadb/api/async_client.py\n@@ -184,8 +184,11 @@ async def create_collection(\n     ) -> AsyncCollection:\n         if configuration is None:\n             configuration = {}\n-            if embedding_function is not None:\n-                configuration[\"embedding_function\"] = embedding_function\n+        if (\n+            embedding_function is not None\n+            and configuration.get(\"embedding_function\") is None\n+        ):\n+            configuration[\"embedding_function\"] = embedding_function\n         model = await self._server.create_collection(\n             name=name,\n             configuration=configuration,\n@@ -235,8 +238,11 @@ async def get_or_create_collection(\n     ) -> AsyncCollection:\n         if configuration is None:\n             configuration = {}\n-            if embedding_function is not None:\n-                configuration[\"embedding_function\"] = embedding_function\n+        if (\n+            embedding_function is not None\n+            and configuration.get(\"embedding_function\") is None\n+        ):\n+            configuration[\"embedding_function\"] = embedding_function\n         model = await self._server.get_or_create_collection(\n             name=name,\n             configuration=configuration,\n---\nchromadb/api/client.py\n@@ -151,8 +151,11 @@ def create_collection(\n     ) -> Collection:\n         if configuration is None:\n             configuration = {}\n-            if embedding_function is not None:\n-                configuration[\"embedding_function\"] = embedding_function\n+        if (\n+            embedding_function is not None\n+            and configuration.get(\"embedding_function\") is None\n+        ):\n+            configuration[\"embedding_function\"] = embedding_function\n         model = self._server.create_collection(\n             name=name,\n             metadata=metadata,\n@@ -202,8 +205,11 @@ def get_or_create_collection(\n     ) -> Collection:\n         if configuration is None:\n             configuration = {}\n-            if embedding_function is not None:\n-                configuration[\"embedding_function\"] = embedding_function\n+        if (\n+            embedding_function is not None\n+            and configuration.get(\"embedding_function\") is None\n+        ):\n+            configuration[\"embedding_function\"] = embedding_function\n         model = self._server.get_or_create_collection(\n             name=name,\n             metadata=metadata,\n---\nchromadb/test/configurations/test_collection_configuration.py\n@@ -543,6 +543,10 @@ def test_spann_default_parameters(client: ClientAPI) -> None:\n             assert hnsw_config_loaded.get(\"ef_construction\") == 100\n             assert hnsw_config_loaded.get(\"ef_search\") == 100\n             assert hnsw_config_loaded.get(\"max_neighbors\") == 16\n+\n+            ef = loaded_config.get(\"embedding_function\")\n+            assert ef is not None\n+            assert ef.name() == \"default\"\n     else:\n         coll = client.create_collection(\n             name=\"test_spann_defaults\",\n@@ -558,11 +562,15 @@ def test_spann_default_parameters(client: ClientAPI) -> None:\n                 CreateSpannConfiguration, loaded_config.get(\"spann\", {})\n             )\n             assert spann_config_loaded.get(\"space\") == \"cosine\"\n-            assert spann_config_loaded.get(\"ef_construction\") == 200  # default\n-            assert spann_config_loaded.get(\"max_neighbors\") == 16  # default\n-            assert spann_config_loaded.get(\"ef_search\") == 200  # default\n-            assert spann_config_loaded.get(\"search_nprobe\") == 128  # default\n-            assert spann_config_loaded.get(\"write_nprobe\") == 128  # default\n+            assert spann_config_loaded.get(\"ef_construction\") == 200\n+            assert spann_config_loaded.get(\"max_neighbors\") == 16\n+            assert spann_config_loaded.get(\"ef_search\") == 200\n+            assert spann_config_loaded.get(\"search_nprobe\") == 128\n+            assert spann_config_loaded.get(\"write_nprobe\") == 128\n+\n+            ef = loaded_config.get(\"embedding_function\")\n+            assert ef is not None\n+            assert ef.name() == \"default\"\n \n \n def test_spann_json_serialization(client: ClientAPI) -> None:\n---\nclients/js/packages/chromadb-core/src/ChromaClient.ts\n@@ -228,6 +228,12 @@ export class ChromaClient {\n     configuration,\n   }: CreateCollectionParams): Promise<Collection> {\n     await this.init();\n+    if (!configuration) {\n+      configuration = {};\n+    }\n+    if (embeddingFunction && !configuration.embedding_function) {\n+      configuration.embedding_function = embeddingFunction;\n+    }\n     let collectionConfiguration: Api.CollectionConfiguration | undefined =\n       undefined;\n     if (configuration) {\n@@ -293,10 +299,14 @@ export class ChromaClient {\n     configuration,\n   }: GetOrCreateCollectionParams): Promise<Collection> {\n     await this.init();\n-\n+    if (!configuration) {\n+      configuration = {};\n+    }\n+    if (embeddingFunction && !configuration.embedding_function) {\n+      configuration.embedding_function = embeddingFunction;\n+    }\n     let collectionConfiguration: Api.CollectionConfiguration | undefined =\n       undefined;\n-\n     if (configuration) {\n       collectionConfiguration =\n         loadApiCollectionConfigurationFromCreateCollectionConfiguration(\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/repository/log.go\n@@ -168,6 +168,13 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\t}\n \t}()\n \n+\t// NOTE(rescrv):  Only sourceInfo.IsSealed should be used on this struct.\n+\tvar sourceInfo log.Collection\n+\tsourceInfo, err = queriesWithTx.GetCollection(ctx, sourceCollectionID)\n+\tif err != nil {\n+\t\tsourceInfo.IsSealed = false\n+\t}\n+\n \tvar sourceBounds log.GetBoundsForCollectionRow\n \tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n@@ -207,6 +214,7 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\tID:                              targetCollectionID,\n \t\tRecordCompactionOffsetPosition:  int64(compactionOffset),\n \t\tRecordEnumerationOffsetPosition: int64(enumerationOffset),\n+\t\tIsSealed:                        sourceInfo.IsSealed,\n \t})\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n---\ngo/pkg/log/repository/log_test.go\n@@ -116,17 +116,17 @@ func (suite *LogTestSuite) TestUniqueConstraintPushLogs() {\n func (suite *LogTestSuite) TestSealedLogWontPush() {\n \tctx := context.Background()\n \tcollectionId := types.NewUniqueID()\n-\tparams := log.InsertCollectionParams {\n-\t\tID: collectionId.String(),\n+\tparams := log.InsertCollectionParams{\n+\t\tID:                              collectionId.String(),\n \t\tRecordEnumerationOffsetPosition: 1,\n-\t\tRecordCompactionOffsetPosition: 0,\n+\t\tRecordCompactionOffsetPosition:  0,\n \t}\n \t_, err := suite.lr.queries.InsertCollection(ctx, params)\n \tassert.NoError(suite.t, err, \"Initializing log should not fail.\")\n \t_, err = suite.lr.queries.SealLog(ctx, collectionId.String())\n \tassert.NoError(suite.t, err, \"Sealing log should not fail.\")\n \tvar isSealed bool\n-\t_, isSealed, err = suite.lr.InsertRecords(ctx, collectionId.String(), [][]byte{{1,2,3}})\n+\t_, isSealed, err = suite.lr.InsertRecords(ctx, collectionId.String(), [][]byte{{1, 2, 3}})\n \tassert.NoError(suite.t, err, \"Failed to push logs\")\n \tassert.True(suite.t, isSealed, \"Did not report was sealed\")\n }\n---\ngo/pkg/log/store/db/queries.sql.go\n@@ -138,6 +138,24 @@ func (q *Queries) GetBoundsForCollection(ctx context.Context, id string) (GetBou\n \treturn i, err\n }\n \n+const getCollection = `-- name: GetCollection :one\n+SELECT id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+FROM collection\n+WHERE id = $1\n+`\n+\n+func (q *Queries) GetCollection(ctx context.Context, id string) (Collection, error) {\n+\trow := q.db.QueryRow(ctx, getCollection, id)\n+\tvar i Collection\n+\terr := row.Scan(\n+\t\t&i.ID,\n+\t\t&i.RecordCompactionOffsetPosition,\n+\t\t&i.RecordEnumerationOffsetPosition,\n+\t\t&i.IsSealed,\n+\t)\n+\treturn i, err\n+}\n+\n const getCollectionForUpdate = `-- name: GetCollectionForUpdate :one\n SELECT id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n FROM collection\n@@ -239,17 +257,23 @@ func (q *Queries) GetTotalUncompactedRecordsCount(ctx context.Context) (int64, e\n }\n \n const insertCollection = `-- name: InsertCollection :one\n-INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position, is_sealed) values($1, $2, $3, $4) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n `\n \n type InsertCollectionParams struct {\n \tID                              string\n \tRecordEnumerationOffsetPosition int64\n \tRecordCompactionOffsetPosition  int64\n+\tIsSealed                        bool\n }\n \n func (q *Queries) InsertCollection(ctx context.Context, arg InsertCollectionParams) (Collection, error) {\n-\trow := q.db.QueryRow(ctx, insertCollection, arg.ID, arg.RecordEnumerationOffsetPosition, arg.RecordCompactionOffsetPosition)\n+\trow := q.db.QueryRow(ctx, insertCollection,\n+\t\targ.ID,\n+\t\targ.RecordEnumerationOffsetPosition,\n+\t\targ.RecordCompactionOffsetPosition,\n+\t\targ.IsSealed,\n+\t)\n \tvar i Collection\n \terr := row.Scan(\n \t\t&i.ID,\n---\ngo/pkg/log/store/queries/queries.sql\n@@ -4,6 +4,11 @@ FROM collection\n WHERE id = $1\n FOR UPDATE;\n \n+-- name: GetCollection :one\n+SELECT *\n+FROM collection\n+WHERE id = $1;\n+\n -- name: InsertRecord :copyfrom\n INSERT INTO record_log (collection_id, \"offset\", record, timestamp) values($1, $2, $3, $4);\n \n@@ -30,7 +35,7 @@ UPDATE collection set record_compaction_offset_position = $2 where id = $1;\n UPDATE collection set record_enumeration_offset_position = $2 where id = $1;\n \n -- name: InsertCollection :one\n-INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning *;\n+INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position, is_sealed) values($1, $2, $3, $4) returning *;\n \n -- name: PurgeRecords :exec\n DELETE FROM record_log r using collection c where r.collection_id = c.id and r.offset <= c.record_compaction_offset_position;\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -497,11 +497,6 @@ impl DirtyMarker {\n                         None\n                     }\n                     Ordering::Greater => {\n-                        tracing::info!(\n-                            \"{collection_id} has range ({}, {}]\",\n-                            record_compaction_position,\n-                            record_enumeration_position,\n-                        );\n                         uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_backpressure {\n                             backpressure.push(*collection_id);\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/tower_tracing.rs\n@@ -6,6 +6,7 @@ use opentelemetry::trace::TraceContextExt;\n use std::time::Duration;\n use tower::Service;\n use tower_http::trace::{MakeSpan, OnResponse, TraceLayer};\n+use tracing::Instrument;\n \n use tracing_opentelemetry::OpenTelemetrySpanExt;\n \n@@ -16,8 +17,7 @@ impl<B> MakeSpan<B> for RequestTracing {\n         let http_route = request\n             .extensions()\n             .get::<MatchedPath>()\n-            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str())\n-            .to_owned();\n+            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str());\n \n         let host = request\n             .headers()\n@@ -56,15 +56,18 @@ impl<B> OnResponse<B> for RequestTracing {\n     }\n }\n \n+/// TracingMiddleware adds trace ID to the response headers\n+/// and wraps the inner handler with a span.\n #[derive(Clone)]\n-pub struct TraceIdMiddleware<S> {\n+pub struct TracingMiddleware<S> {\n     inner: S,\n }\n \n-impl<S, Request, Rs> Service<Request> for TraceIdMiddleware<S>\n+impl<S, B, Rs> Service<Request<B>> for TracingMiddleware<S>\n where\n-    S: Service<Request, Response = Response<Rs>> + Send + 'static,\n+    S: Service<Request<B>, Response = Response<Rs>> + Send + 'static,\n     S::Future: Send + 'static,\n+    B: Send + 'static,\n {\n     type Response = S::Response;\n     type Error = S::Error;\n@@ -77,10 +80,23 @@ where\n         self.inner.poll_ready(cx)\n     }\n \n-    fn call(&mut self, req: Request) -> Self::Future {\n+    fn call(&mut self, req: Request<B>) -> Self::Future {\n+        let http_route = req\n+            .extensions()\n+            .get::<MatchedPath>()\n+            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str());\n+\n+        let handler_span = tracing::span!(\n+            tracing::Level::DEBUG,\n+            \"HTTP request handler\",\n+            http.route = http_route,\n+            otel.name = format!(\"Handler {} {}\", req.method(), http_route),\n+        );\n+\n         let future = self.inner.call(req);\n+\n         Box::pin(async move {\n-            let mut response: Response<Rs> = future.await?;\n+            let mut response: Response<Rs> = future.instrument(handler_span).await?;\n             if response.status().is_client_error() || response.status().is_server_error() {\n                 let trace_id = tracing::Span::current()\n                     .context()\n@@ -109,10 +125,10 @@ impl SetTraceIdLayer {\n }\n \n impl<S> tower::layer::Layer<S> for SetTraceIdLayer {\n-    type Service = TraceIdMiddleware<S>;\n+    type Service = TracingMiddleware<S>;\n \n     fn layer(&self, inner: S) -> Self::Service {\n-        TraceIdMiddleware { inner }\n+        TracingMiddleware { inner }\n     }\n }\n \n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis should make it impervious to flakes.  What I saw was 26 in 2 min.\nChanging to 20 in 3 min as the failure.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\n.github/workflows/_python-tests.yml\n@@ -155,7 +155,7 @@ jobs:\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n       - uses: ./.github/actions/tilt\n       - name: Test\n-        run: bin/cluster-test.sh bash -c 'python -m pytest \"${{ matrix.test-globs }}\"' --durations 10\n+        run: bin/cluster-test.sh bash -c 'python -m pytest \"${{ matrix.test-globs }}\" --durations 10'\n         shell: bash\n         env:\n           PROPERTY_TESTING_PRESET: ${{ inputs.property_testing_preset }}\n---\n\n\n---\n\nChoice B:\nrust/wal3/tests/test_k8s_integration_99_ping_pong_contention.rs\n@@ -115,9 +115,9 @@ async fn test_k8s_integration_ping_pong_contention() {\n         .unwrap(),\n     );\n \n-    // Set a timer to make sure the test only runs for 2 minutes.\n+    // Set a timer to make sure the test only runs for 3 minutes.\n     let fail = tokio::spawn(async move {\n-        tokio::time::sleep(Duration::from_secs(120)).await;\n+        tokio::time::sleep(Duration::from_secs(180)).await;\n         eprintln!(\"Taking down the test\");\n         std::process::exit(13);\n     });\n@@ -130,15 +130,15 @@ async fn test_k8s_integration_ping_pong_contention() {\n         Arc::clone(&mutex),\n         Arc::clone(&running),\n         1,\n-        30,\n+        20,\n     ));\n \n     let handle2 = tokio::spawn(writer_thread(\n         Arc::clone(&writer2),\n         Arc::clone(&mutex),\n         Arc::clone(&running),\n         2,\n-        30,\n+        20,\n     ));\n \n     // Wait for both threads to complete\n---\n\n\n---\n\nChoice C:\nchromadb/test/distributed/test_log_failover.py\n@@ -65,4 +65,6 @@ def test_log_failover(\n \n     for i in range(200):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n         assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -26,7 +26,7 @@ log:\n     connect_timeout_ms: 5000\n     request_timeout_ms: 60000 # 1 minute\n     alt_host: \"rust-log-service.chroma\"\n-    use_alt_host_for_everything: true\n+    alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n \n executor:\n   distributed:\n---\nrust/log/src/config.rs\n@@ -14,19 +14,20 @@ pub struct GrpcLogConfig {\n     pub max_encoding_message_size: usize,\n     #[serde(default = \"GrpcLogConfig::default_max_decoding_message_size\")]\n     pub max_decoding_message_size: usize,\n-    // NOTE(rescrv):  This is a hack to allow us to test two log services in parallel without\n-    // breaking the old service.  If alt host is specified, then the \"use_alt_host_for_everything\"\n-    // and \"use_alt_for_collections\" config parameters are consulted.  If\n-    // \"use_alt_host_for_everything\" is set (CI) or the collection being written is in the alt\n-    // collections vec (staging), then we can use the alt host.\n+    // NOTE(rescrv):  This is a hack to allow us to test migrate between two log services without\n+    // breaking things or having a hard cut-over.  If alt_host_threshold is specified, it will be\n+    // interpreted as a u128 (UUID == u128) and if the collection in question is <=\n+    // alt_host_threshold, it go to the alt-host first.\n+    //\n+    // alt tenants/collections will always initialize a new log\n     #[serde(default = \"Option::default\")]\n     pub alt_host: Option<String>,\n     #[serde(default)]\n-    pub use_alt_host_for_everything: bool,\n-    #[serde(default)]\n     pub use_alt_for_tenants: Vec<String>,\n     #[serde(default)]\n     pub use_alt_for_collections: Vec<String>,\n+    #[serde(default = \"Option::default\")]\n+    pub alt_host_threshold: Option<String>,\n }\n \n impl GrpcLogConfig {\n@@ -65,9 +66,9 @@ impl Default for GrpcLogConfig {\n             max_encoding_message_size: GrpcLogConfig::default_max_encoding_message_size(),\n             max_decoding_message_size: GrpcLogConfig::default_max_decoding_message_size(),\n             alt_host: None,\n-            use_alt_host_for_everything: false,\n             use_alt_for_tenants: vec![],\n             use_alt_for_collections: vec![],\n+            alt_host_threshold: None,\n         }\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -244,21 +244,41 @@ impl GrpcLog {\n         client_for_conn_str(connection_string)\n     }\n \n+    fn client_is_on_alt_log(to_evaluate: CollectionUuid, alt_host_threshold: Option<&str>) -> bool {\n+        if let Some(alt_host_threshold) = alt_host_threshold {\n+            let Ok(alt_host_threshold) = Uuid::parse_str(alt_host_threshold) else {\n+                tracing::error!(\"alt_host_threshold must be a valid UUID\");\n+                return false;\n+            };\n+            let to_evaluate = to_evaluate.0.as_u64_pair().0;\n+            let alt_host_threshold = alt_host_threshold.as_u64_pair().0;\n+            to_evaluate <= alt_host_threshold\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn client_for(\n         &mut self,\n         tenant: &str,\n         collection_id: CollectionUuid,\n     ) -> &mut LogServiceClient<chroma_tracing::GrpcTraceService<tonic::transport::Channel>> {\n-        let collection_id = collection_id.to_string();\n         if let Some(alt) = self.alt_client.as_mut() {\n-            if self.config.use_alt_host_for_everything\n-                || self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n-                || self.config.use_alt_for_collections.contains(&collection_id)\n+            if self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n+                || self\n+                    .config\n+                    .use_alt_for_collections\n+                    .contains(&collection_id.to_string())\n+                || Self::client_is_on_alt_log(\n+                    collection_id,\n+                    self.config.alt_host_threshold.as_deref(),\n+                )\n             {\n                 tracing::info!(\"using alt client for {collection_id}\");\n                 return alt;\n             }\n         }\n+        tracing::info!(\"using standard client for {collection_id}\");\n         &mut self.client\n     }\n \n@@ -413,7 +433,8 @@ impl GrpcLog {\n         let mut norm = self\n             ._get_collections_with_new_data(false, min_compaction_size)\n             .await?;\n-        if self.config.use_alt_host_for_everything\n+        if self.config.alt_host_threshold.is_some()\n+            || !self.config.use_alt_for_tenants.is_empty()\n             || !self.config.use_alt_for_collections.is_empty()\n         {\n             let alt = self\n@@ -524,3 +545,32 @@ impl GrpcLog {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn client_is_on_alt_log() {\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            None\n+        ));\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"00088272-cfc4-419d-997a-baebfb25034a\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"00088272-cfc4-419d-997a-baebfb25034a\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"ffffffff-ffff-ffff-ffff-ffffffffffff\"),\n+        ));\n+    }\n+}\n---\nrust/worker/tilt_config.yaml\n@@ -42,7 +42,7 @@ query_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -122,7 +122,7 @@ compaction_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -197,4 +197,4 @@ log_service:\n         connect_timeout_ms: 5000\n         request_timeout_ms: 60000 # 1 minute\n         alt_host: \"rust-log-service.chroma\"\n-        use_alt_host_for_everything: true\n+        alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n---\n\n\n---\n\nChoice D:\n.github/actions/tilt-setup-prebuild/action.yaml\n@@ -17,3 +17,4 @@ runs:\n           \"bash -c 'curl -fsSL https://github.com/tilt-dev/tilt/releases/download/v${TILT_VERSION}/tilt.${TILT_VERSION}.linux.x86_64.tar.gz | tar -xzv -C /usr/local/bin tilt'\" \\\n           \"docker buildx bake -f ${{ github.action_path }}/docker-bake.hcl --load\" \\\n           \"bash ${{ github.action_path }}/pull_external_images.sh\"\n+      working-directory: ${{ github.action_path }}/../../../ # this allows other repos to reuse this workflow when this repo may not be the current working directory\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - Can get unique constraint violation even when two writes contend to collection table. Return AlreadyExists so that FE can retry\r\n- New functionality\r\n  - ...\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nNone\r\n\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -199,7 +199,9 @@ async fn get_log_from_handle<'a>(\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n     let mut active = handle.active.lock().await;\n-    active.keep_alive(Duration::from_secs(60));\n+    if active.log.is_some() {\n+        active.keep_alive(Duration::from_secs(60));\n+    }\n     if let Some(log) = active.log.as_ref() {\n         return Ok(LogRef {\n             log: Arc::clone(log),\n@@ -215,6 +217,7 @@ async fn get_log_from_handle<'a>(\n         mark_dirty.clone(),\n     )\n     .await?;\n+    active.keep_alive(Duration::from_secs(60));\n     tracing::info!(\"Opened log at {}\", prefix);\n     let opened = Arc::new(opened);\n     active.log = Some(Arc::clone(&opened));\n---\n\n\n---\n\nChoice B:\nchromadb/api/async_fastapi.py\n@@ -123,10 +123,12 @@ def _get_client(self) -> httpx.AsyncClient:\n                 + \" (https://github.com/chroma-core/chroma)\"\n             )\n \n+            limits = httpx.Limits(max_keepalive_connections=self.keepalive_secs)\n             self._clients[loop_hash] = httpx.AsyncClient(\n                 timeout=None,\n                 headers=headers,\n                 verify=self._settings.chroma_server_ssl_verify or False,\n+                limits=limits,\n             )\n \n         return self._clients[loop_hash]\n---\nchromadb/api/base_http_client.py\n@@ -13,6 +13,7 @@\n class BaseHTTPClient:\n     _settings: Settings\n     _max_batch_size: int = -1\n+    keepalive_secs: int = 40\n \n     @staticmethod\n     def _validate_host(host: str) -> None:\n---\nchromadb/api/fastapi.py\n@@ -69,7 +69,8 @@ def __init__(self, system: System):\n             default_api_path=system.settings.chroma_server_api_default_path,\n         )\n \n-        self._session = httpx.Client(timeout=None)\n+        limits = httpx.Limits(max_keepalive_connections=self.keepalive_secs)\n+        self._session = httpx.Client(timeout=None, limits=limits)\n \n         self._header = system.settings.chroma_server_headers or {}\n         self._header[\"Content-Type\"] = \"application/json\"\n---\n\n\n---\n\nChoice C:\ngo/pkg/log/repository/log.go\n@@ -51,6 +51,14 @@ func (r *LogRepository) InsertRecords(ctx context.Context, collectionId string,\n \t\t\t\tRecordCompactionOffsetPosition:  0,\n \t\t\t})\n \t\t\tif err != nil {\n+\t\t\t\tvar pgErr *pgconn.PgError\n+\t\t\t\t// This is a retryable error and should be retried by upstream. It happens\n+\t\t\t\t// when two concurrent adds to the same collection happen.\n+\t\t\t\tif errors.As(err, &pgErr) && pgErr.Code == \"23505\" {\n+\t\t\t\t\ttrace_log.Error(\"Duplicate key error while inserting into collection table\", zap.String(\"collectionId\", collectionId), zap.String(\"detail\", pgErr.Detail))\n+\t\t\t\t\terr = status.Error(codes.AlreadyExists, fmt.Sprintf(\"Duplicate key error while inserting into collection table: %s\", pgErr.Detail))\n+\t\t\t\t\treturn\n+\t\t\t\t}\n \t\t\t\ttrace_log.Error(\"Error in creating a new entry in collection table\", zap.Error(err), zap.String(\"collectionId\", collectionId))\n \t\t\t\treturn\n \t\t\t}\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1052,9 +1052,11 @@ func (tc *Catalog) ForkCollection(ctx context.Context, forkCollection *model.For\n \t\t// t2: Fork source collection in sysdb, the latest source collection compaction offset is 400. If we add new logs, it will start after offset 300, and the data is lost after compaction.\n \t\tlatestSourceCompactionOffset := uint64(sourceCollection.LogPosition)\n \t\tif forkCollection.SourceCollectionLogEnumerationOffset < latestSourceCompactionOffset {\n+\t\t\tlog.Error(\"CollectionLogPositionStale\", zap.Uint64(\"latestSourceCompactionOffset\", latestSourceCompactionOffset), zap.Uint64(\"forkCollection.SourceCollectionLogEnumerationOffset \", forkCollection.SourceCollectionLogEnumerationOffset))\n \t\t\treturn common.ErrCollectionLogPositionStale\n \t\t}\n \t\tif latestSourceCompactionOffset < forkCollection.SourceCollectionLogCompactionOffset {\n+\t\t\tlog.Error(\"CompactionOffsetSomehowAhead\", zap.Uint64(\"latestSourceCompactionOffset\", latestSourceCompactionOffset), zap.Uint64(\"forkCollection.SourceCollectionLogCompactionOffset\", forkCollection.SourceCollectionLogCompactionOffset))\n \t\t\treturn common.ErrCompactionOffsetSomehowAhead\n \t\t}\n \n---\nrust/log-service/src/lib.rs\n@@ -34,7 +34,7 @@ use prost::Message;\n use serde::{Deserialize, Serialize};\n use tokio::signal::unix::{signal, SignalKind};\n use tonic::{transport::Server, Code, Request, Response, Status};\n-use tracing::Instrument;\n+use tracing::{Instrument, Level};\n use uuid::Uuid;\n use wal3::{\n     Cursor, CursorName, CursorStore, CursorStoreOptions, Limits, LogPosition, LogReader,\n@@ -1223,6 +1223,7 @@ impl LogService for LogServer {\n             let offset = witness\n                 .map(|x| x.1.position)\n                 .unwrap_or(LogPosition::from_offset(0));\n+            tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n@@ -1250,6 +1251,7 @@ impl LogService for LogServer {\n                     format!(\"max_offset={:?} < offset={:?}\", max_offset, offset),\n                 ));\n             }\n+            tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n                 compaction_offset: offset.offset(),\n                 enumeration_offset: (max_offset - 1u64).offset(),\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThis PRs allows setting metadata to None in the python client to allow deleting metadatas after creation.\r\n\r\n- Improvements & Bug fixes\r\n  - ...\r\n- New functionality\r\n  - ...\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n<!-- Summary by @propel-code-bot -->\n\n---\n\nThis PR enhances the Python client by allowing metadata values to be set to None, which enables users to delete metadata after creation. The change modifies the metadata type definition and validation logic to accept None as a valid value type.\n\n*This summary was automatically generated by @propel-code-bot*\n\n---\n\nChoice A:\nrust/system/src/execution/orchestrator.rs\n@@ -1,12 +1,54 @@\n+use super::Operator;\n use crate::{ChannelError, Component, ComponentContext, ComponentHandle, PanicError, System};\n+use crate::{Dispatcher, TaskMessage};\n use async_trait::async_trait;\n use chroma_error::ChromaError;\n use core::fmt::Debug;\n+use parking_lot::Mutex;\n use std::any::type_name;\n+use thiserror::Error;\n use tokio::sync::oneshot::{self, error::RecvError, Sender};\n+use tracing::Instrument;\n use tracing::Span;\n \n-use crate::{Dispatcher, TaskMessage};\n+#[derive(Debug)]\n+struct WrappedOrchestratorOperator<O: Orchestrator>(Mutex<Option<O>>, System, Span);\n+\n+#[derive(Debug, Error)]\n+#[error(\"Orchestrator was already consumed\")]\n+pub struct WrappedOrchestratorOperatorError {}\n+\n+#[async_trait]\n+impl<O: Orchestrator> Operator<(), O::Output> for WrappedOrchestratorOperator<O>\n+where\n+    O: Sync,\n+    O::Output: Sync,\n+    O::Error: From<WrappedOrchestratorOperatorError>,\n+{\n+    type Error = O::Error;\n+\n+    fn get_type(&self) -> crate::OperatorType {\n+        crate::OperatorType::IO\n+    }\n+\n+    fn get_name(&self) -> &'static str {\n+        O::name()\n+    }\n+\n+    async fn run(&self, _: &()) -> Result<O::Output, Self::Error> {\n+        let orchestrator = {\n+            let mut orchestrator = self.0.lock();\n+            orchestrator\n+                .take()\n+                .ok_or(WrappedOrchestratorOperatorError {})?\n+        };\n+\n+        orchestrator\n+            .run(self.1.clone())\n+            .instrument(self.2.clone())\n+            .await\n+    }\n+}\n \n #[async_trait]\n pub trait Orchestrator: Debug + Send + Sized + 'static {\n@@ -115,6 +157,19 @@ pub trait Orchestrator: Debug + Send + Sized + 'static {\n             }\n         }\n     }\n+\n+    fn to_operator(self, system: System) -> Box<dyn Operator<(), Self::Output, Error = Self::Error>>\n+    where\n+        Self: Sync,\n+        <Self as Orchestrator>::Output: Sync,\n+        <Self as Orchestrator>::Error: From<WrappedOrchestratorOperatorError>,\n+    {\n+        Box::new(WrappedOrchestratorOperator(\n+            Mutex::new(Some(self)),\n+            system,\n+            Span::current(),\n+        ))\n+    }\n }\n \n #[async_trait]\n@@ -144,3 +199,128 @@ impl<O: Orchestrator> Component for O {\n         };\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::wrap;\n+    use crate::ChannelError;\n+    use crate::ComponentContext;\n+    use crate::Handler;\n+    use crate::System;\n+    use crate::TaskResult;\n+    use async_trait::async_trait;\n+    use thiserror::Error;\n+\n+    #[derive(Debug, Error)]\n+    enum TestOrchestratorError {\n+        #[error(\"Receive error: {0}\")]\n+        Receive(#[from] RecvError),\n+        #[error(\"Channel error: {0}\")]\n+        Channel(#[from] ChannelError),\n+        #[error(\"Panic error: {0}\")]\n+        Panic(#[from] PanicError),\n+        #[error(\"Wrapped orchestrator error: {0}\")]\n+        OrchestratorWrapper(#[from] WrappedOrchestratorOperatorError),\n+    }\n+    impl ChromaError for TestOrchestratorError {\n+        fn code(&self) -> chroma_error::ErrorCodes {\n+            chroma_error::ErrorCodes::Internal\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    struct TestOrchestrator {\n+        result_channel: Option<Sender<Result<usize, TestOrchestratorError>>>,\n+        dispatcher: ComponentHandle<Dispatcher>,\n+        system: System,\n+        spawn_self: bool,\n+    }\n+\n+    impl TestOrchestrator {\n+        fn new(dispatcher: ComponentHandle<Dispatcher>, system: System, spawn_self: bool) -> Self {\n+            Self {\n+                result_channel: None,\n+                dispatcher,\n+                system,\n+                spawn_self,\n+            }\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    struct TestMessageRequest;\n+\n+    #[async_trait]\n+    impl Orchestrator for TestOrchestrator {\n+        type Output = usize;\n+        type Error = TestOrchestratorError;\n+\n+        fn dispatcher(&self) -> ComponentHandle<Dispatcher> {\n+            self.dispatcher.clone()\n+        }\n+        async fn initial_tasks(&mut self, ctx: &ComponentContext<Self>) -> Vec<TaskMessage> {\n+            if self.spawn_self {\n+                let task = wrap(\n+                    TestOrchestrator::new(self.dispatcher.clone(), self.system.clone(), false)\n+                        .to_operator(self.system.clone()),\n+                    (),\n+                    ctx.receiver(),\n+                );\n+\n+                return vec![task];\n+            }\n+\n+            ctx.receiver()\n+                .send(TestMessageRequest {}, None)\n+                .await\n+                .unwrap();\n+\n+            vec![]\n+        }\n+        fn set_result_channel(&mut self, sender: Sender<Result<Self::Output, Self::Error>>) {\n+            self.result_channel = Some(sender);\n+        }\n+        fn take_result_channel(&mut self) -> Sender<Result<Self::Output, Self::Error>> {\n+            self.result_channel.take().unwrap()\n+        }\n+    }\n+\n+    #[async_trait]\n+    impl Handler<TestMessageRequest> for TestOrchestrator {\n+        type Result = ();\n+\n+        async fn handle(\n+            &mut self,\n+            _: TestMessageRequest,\n+            ctx: &ComponentContext<TestOrchestrator>,\n+        ) {\n+            self.default_terminate_with_result(Ok(42), ctx).await;\n+        }\n+    }\n+\n+    #[async_trait]\n+    impl Handler<TaskResult<usize, TestOrchestratorError>> for TestOrchestrator {\n+        type Result = ();\n+\n+        async fn handle(\n+            &mut self,\n+            result: TaskResult<usize, TestOrchestratorError>,\n+            ctx: &ComponentContext<TestOrchestrator>,\n+        ) {\n+            self.default_terminate_with_result(Ok(result.into_inner().unwrap()), ctx)\n+                .await;\n+        }\n+    }\n+\n+    #[tokio::test]\n+    async fn test_wrapped_orchestrator() {\n+        let system = System::new();\n+        let dispatcher = Dispatcher::new(Default::default());\n+        let dispatcher_handle = system.start_component(dispatcher);\n+        let orchestrator = TestOrchestrator::new(dispatcher_handle, system.clone(), true);\n+\n+        let result = orchestrator.run(system).await.unwrap();\n+        assert_eq!(result, 42);\n+    }\n+}\n---\n\n\n---\n\nChoice B:\nrust/load/src/lib.rs\n@@ -1271,13 +1271,11 @@ impl LoadService {\n             for declared in declared {\n                 if let Entry::Vacant(entry) = running.entry(declared.uuid) {\n                     tracing::info!(\"spawning workload {}\", declared.uuid);\n-                    let root = tracing::info_span!(parent: None, \"workload\");\n                     let this = Arc::clone(self);\n                     let done = Arc::new(AtomicBool::new(false));\n                     let done_p = Arc::clone(&done);\n                     let inhibit = Arc::clone(&self.inhibit);\n                     let task = tokio::task::spawn(async move {\n-                        let _enter = root.enter();\n                         this.run_one_workload(done, inhibit, declared).await\n                     });\n                     entry.insert((done_p, task));\n@@ -1295,36 +1293,6 @@ impl LoadService {\n         let client = Arc::new(client(spec.connection.clone()).await);\n         let mut guac = Guacamole::new(spec.expires.timestamp_millis() as u64);\n         let mut next_op = Instant::now();\n-        let (tx, mut rx) = tokio::sync::mpsc::channel(1000);\n-        let _ = tx\n-            .send(tokio::spawn(async move { Ok::<(), Error>(()) }))\n-            .await;\n-        let this = Arc::clone(&self);\n-        let data_set = Arc::clone(&spec.data_set);\n-        let reaper = tokio::spawn(async move {\n-            while let Some(task) = rx.recv().await {\n-                if let Err(err) = task.await.unwrap() {\n-                    if !format!(\"{err:?}\").contains(\"429\") {\n-                        this.metrics.failed.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                        tracing::error!(\"workload task failed: {err:?}\");\n-                    } else {\n-                        this.metrics.limited.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                    }\n-                }\n-            }\n-        });\n \n         // Initialize the data set.\n         let data_set = Arc::clone(&spec.data_set);\n@@ -1408,30 +1376,45 @@ impl LoadService {\n                         .await\n                         .map_err(|err| Error::FailWorkload(err.to_string()))\n                     {\n-                        Ok(()) => Ok(()),\n+                        Ok(()) => (),\n                         Err(err) => {\n-                            if err.to_string().contains(\"invalid request: No results\") {\n+                            if format!(\"{err:?}\").contains(\"invalid request: No results\") {\n                                 this.metrics.no_results.add(\n                                     1,\n                                     &[KeyValue::new(\n                                         Key::from_static_str(\"data_set\"),\n                                         Value::from(data_set.name()),\n                                     )],\n                                 );\n-                                Ok(())\n+                                tracing::warn!(\"workload step no results: {err:?}\");\n+                            } else if !format!(\"{err:?}\").contains(\"429\") {\n+                                this.metrics.failed.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::error!(\"workload step failed: {err:?}\");\n                             } else {\n-                                Err(err)\n+                                this.metrics.limited.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::warn!(\"workload step rate limited: {err:?}\");\n                             }\n                         }\n-                    }\n+                    };\n                 };\n-                tx.send(tokio::spawn(fut)).await.unwrap();\n+                let span = tracing::info_span!(parent: None, \"step\", workload_uuid = %spec.uuid);\n+                tokio::spawn(fut.instrument(span));\n             }\n         }\n         // Not an error, just needs to show up in stdout.\n         tracing::error!(\"workload done: {}/{}\", spec.name, spec.description());\n-        drop(tx);\n-        reaper.await.unwrap();\n     }\n \n     fn load_persistent(&self) -> Result<(), Error> {\n---\n\n\n---\n\nChoice C:\n.github/actions/docker/action.yaml\n@@ -17,6 +17,11 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n+    # https://github.com/docker/setup-qemu-action - for multiplatform builds\n+    - name: Set up QEMU\n+      uses: docker/setup-qemu-action@v2\n+    - name: Set up Docker Buildx\n+      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n.github/workflows/_build_release_container.yml\n@@ -33,106 +33,43 @@ permissions:\n env:\n   GHCR_IMAGE_NAME: \"ghcr.io/chroma-core/chroma\"\n   DOCKERHUB_IMAGE_NAME: \"chromadb/chroma\"\n+  PLATFORMS: linux/amd64,linux/arm64 #linux/riscv64, linux/arm/v7\n \n jobs:\n   build:\n-    name: Build image for ${{ matrix.platform }}\n+    name: Build and publish container image\n     runs-on: blacksmith-16vcpu-ubuntu-2204\n-    strategy:\n-      matrix:\n-        platform: [amd64, arm64]\n-        include:\n-          - platform: amd64\n-            runner: blacksmith-16vcpu-ubuntu-2204\n-            docker_platform: linux/amd64\n-          - platform: arm64\n-            runner: blacksmith-16vcpu-ubuntu-2204-arm\n-            docker_platform: linux/arm64\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n         with:\n           fetch-depth: 0\n-\n       - name: Set up Docker\n         uses: ./.github/actions/docker\n         with:\n           ghcr-username: ${{ github.actor }}\n           ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n           dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-\n-      - name: Compute arch-specific tags\n-        id: tags\n+      - name: Compute tags\n         shell: bash\n+        id: compute_tags\n         run: |\n-          arch_tag=\"${{ inputs.tag }}-${{ matrix.platform }}\"\n-          ghcr=\"${{ env.GHCR_IMAGE_NAME }}:${arch_tag}\"\n-          dhub=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${arch_tag}\"\n-          echo \"arch_tag=$arch_tag\"      >> $GITHUB_OUTPUT\n-\n-          # expose *matrix-unique* step outputs\n-          echo \"ghcr_tag_${{ matrix.platform }}=$ghcr\"         >> $GITHUB_OUTPUT\n-          echo \"dockerhub_tag_${{ matrix.platform }}=$dhub\"    >> $GITHUB_OUTPUT\n+          tags=\"${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }},${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\"\n+          if [ \"${{ inputs.tag_as_latest }}\" = \"true\" ]; then\n+            tags=\"${tags},${{ env.GHCR_IMAGE_NAME }}:latest,${{ env.DOCKERHUB_IMAGE_NAME }}:latest\"\n+          fi\n \n-          # these two tags are what the build-push action will publish for *this* arch\n-          echo \"tags=$ghcr,$dhub\" >> $GITHUB_OUTPUT\n+          echo \"tags=${tags}\" >> $GITHUB_OUTPUT\n \n       - name: Build and push image\n         uses: useblacksmith/build-push-action@v1.1\n         with:\n           context: .\n           file: rust/Dockerfile\n           target: cli\n-          platforms: ${{ matrix.docker_platform }}\n+          platforms: ${{ env.PLATFORMS }}\n           push: true\n           build-args: |\n             RELEASE_MODE=1\n-          tags: ${{ steps.tags.outputs.tags }}\n-    outputs:\n-      ghcr_tag_amd64:      ${{ steps.tags.outputs.ghcr_tag_amd64 }}\n-      ghcr_tag_arm64:      ${{ steps.tags.outputs.ghcr_tag_arm64 }}\n-      dockerhub_tag_amd64: ${{ steps.tags.outputs.dockerhub_tag_amd64 }}\n-      dockerhub_tag_arm64: ${{ steps.tags.outputs.dockerhub_tag_arm64 }}\n-\n-  merge:\n-    name: Merge platform manifests\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n-    needs:\n-      - build\n-    steps:\n-      - name: Set up Docker\n-        uses: ./.github/actions/docker\n-        with:\n-          ghcr-username: ${{ github.actor }}\n-          ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n-          dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n-          dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-\n-      - name: Create and push manifest\n-        shell: bash\n-        run: |\n-          set -euo pipefail\n-\n-          # Pull the per-arch tags from job-level outputs\n-          ghcr_amd64='${{ needs.build.outputs.ghcr_tag_amd64 }}'\n-          ghcr_arm64='${{ needs.build.outputs.ghcr_tag_arm64 }}'\n-          dhub_amd64='${{ needs.build.outputs.dockerhub_tag_amd64 }}'\n-          dhub_arm64='${{ needs.build.outputs.dockerhub_tag_arm64 }}'\n-\n-          base_tag='${{ inputs.tag }}'\n-          ghcr_base=\"${{ env.GHCR_IMAGE_NAME }}:${base_tag}\"\n-          dhub_base=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${base_tag}\"\n-\n-          docker buildx imagetools create --tag \"$ghcr_base\" $ghcr_amd64 $ghcr_arm64\n-          docker buildx imagetools create --tag \"$dhub_base\"  $dhub_amd64 $dhub_arm64\n-\n-          if [[ \"${{ inputs.tag_as_latest }}\" == \"true\" ]]; then\n-            docker buildx imagetools create --tag \"${{ env.GHCR_IMAGE_NAME }}:latest\"  $ghcr_amd64 $ghcr_arm64\n-            docker buildx imagetools create --tag \"${{ env.DOCKERHUB_IMAGE_NAME }}:latest\" $dhub_amd64 $dhub_arm64\n-          fi\n-\n-      - name: Inspect image\n-        run: |\n-          docker buildx imagetools inspect ${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }}\n-          docker buildx imagetools inspect ${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\n+          tags: ${{ steps.compute_tags.outputs.tags }}\n---\n\n\n---\n\nChoice D:\nchromadb/api/types.py\n@@ -687,9 +687,11 @@ def validate_metadata(metadata: Metadata) -> Metadata:\n                 f\"Expected metadata key to be a str, got {key} which is a {type(key).__name__}\"\n             )\n         # isinstance(True, int) evaluates to True, so we need to check for bools separately\n-        if not isinstance(value, bool) and not isinstance(value, (str, int, float)):\n+        if not isinstance(value, bool) and not isinstance(\n+            value, (str, int, float, type(None))\n+        ):\n             raise ValueError(\n-                f\"Expected metadata value to be a str, int, float or bool, got {value} which is a {type(value).__name__}\"\n+                f\"Expected metadata value to be a str, int, float, bool, or None, got {value} which is a {type(value).__name__}\"\n             )\n     return metadata\n \n---\nchromadb/base_types.py\n@@ -1,9 +1,9 @@\n-from typing import Dict, List, Mapping, Sequence, Union\n+from typing import Dict, List, Mapping, Optional, Sequence, Union\n from typing_extensions import Literal\n import numpy as np\n from numpy.typing import NDArray\n \n-Metadata = Mapping[str, Union[str, int, float, bool]]\n+Metadata = Mapping[str, Optional[Union[str, int, float, bool]]]\n UpdateMetadata = Mapping[str, Union[int, float, str, bool, None]]\n PyVector = Union[Sequence[float], Sequence[int]]\n Vector = NDArray[Union[np.int32, np.float32]]  # TODO: Specify that the vector is 1D\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nAdds an optional `message` to `QuotaExceededError`. This feature allows the quota system to give clients more info about an error.\r\n\r\n<!-- Summary by @propel-code-bot -->\n\n---\n\nThis PR enhances the QuotaExceededError struct by adding an optional 'message' field, allowing the quota system to provide more detailed information to clients when quota limits are exceeded. The implementation uses the Validate trait to ensure non-empty message strings and includes comprehensive test coverage.\n\n**Key Changes:**\n\u2022 Added an optional `message` field to QuotaExceededError struct\n\u2022 Updated the Display implementation to include the message when present\n\u2022 Added validation to ensure non-empty message strings\n\u2022 Added comprehensive tests for the new functionality\n\n**Affected Areas:**\n\u2022 rust/frontend/src/quota/mod.rs\n\n*This summary was automatically generated by @propel-code-bot*\n\n---\n\nChoice A:\ngo/pkg/log/server/server.go\n@@ -162,6 +162,15 @@ func (s *logServer) InspectDirtyLog(ctx context.Context, req *logservicepb.Inspe\n \treturn\n }\n \n+func (s *logServer) SealLog(ctx context.Context, req *logservicepb.SealLogRequest) (res *logservicepb.SealLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n+\n+func (s *logServer) MigrateLog(ctx context.Context, req *logservicepb.MigrateLogRequest) (res *logservicepb.MigrateLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n \n func NewLogServer(lr *repository.LogRepository) logservicepb.LogServiceServer {\n \treturn &logServer{\n---\nidl/chromadb/proto/logservice.proto\n@@ -96,6 +96,22 @@ message InspectDirtyLogResponse {\n   repeated string markers = 1;\n }\n \n+message SealLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message SealLogResponse {\n+  // Empty\n+}\n+\n+message MigrateLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message MigrateLogResponse {\n+  // Empty\n+}\n+\n service LogService {\n   rpc PushLogs(PushLogsRequest) returns (PushLogsResponse) {}\n   rpc ScoutLogs(ScoutLogsRequest) returns (ScoutLogsResponse) {}\n@@ -104,5 +120,11 @@ service LogService {\n   rpc GetAllCollectionInfoToCompact(GetAllCollectionInfoToCompactRequest) returns (GetAllCollectionInfoToCompactResponse) {}\n   rpc UpdateCollectionLogOffset(UpdateCollectionLogOffsetRequest) returns (UpdateCollectionLogOffsetResponse) {}\n   rpc PurgeDirtyForCollection(PurgeDirtyForCollectionRequest) returns (PurgeDirtyForCollectionResponse) {}\n+  // RPC endpoints to expose for operator debuggability.\n+  // This endpoint must route to the rust log service.\n   rpc InspectDirtyLog(InspectDirtyLogRequest) returns (InspectDirtyLogResponse) {}\n+  // This endpoint must route to the go log service.\n+  rpc SealLog(SealLogRequest) returns (SealLogResponse) {}\n+  // This endpoint must route to the rust log service.\n+  rpc MigrateLog(MigrateLogRequest) returns (MigrateLogResponse) {}\n }\n---\nrust/log-service/src/lib.rs\n@@ -16,9 +16,10 @@ use chroma_storage::Storage;\n use chroma_types::chroma_proto::{\n     log_service_server::LogService, CollectionInfo, GetAllCollectionInfoToCompactRequest,\n     GetAllCollectionInfoToCompactResponse, InspectDirtyLogRequest, InspectDirtyLogResponse,\n-    LogRecord, OperationRecord, PullLogsRequest, PullLogsResponse, PurgeDirtyForCollectionRequest,\n-    PurgeDirtyForCollectionResponse, PushLogsRequest, PushLogsResponse, ScoutLogsRequest,\n-    ScoutLogsResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n+    LogRecord, MigrateLogRequest, MigrateLogResponse, OperationRecord, PullLogsRequest,\n+    PullLogsResponse, PurgeDirtyForCollectionRequest, PurgeDirtyForCollectionResponse,\n+    PushLogsRequest, PushLogsResponse, ScoutLogsRequest, ScoutLogsResponse, SealLogRequest,\n+    SealLogResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n };\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n@@ -1230,6 +1231,24 @@ impl LogService for LogServer {\n         }\n         Ok(Response::new(InspectDirtyLogResponse { markers }))\n     }\n+\n+    async fn seal_log(\n+        &self,\n+        _request: Request<SealLogRequest>,\n+    ) -> Result<Response<SealLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do sealing\",\n+        ))\n+    }\n+\n+    async fn migrate_log(\n+        &self,\n+        _request: Request<MigrateLogRequest>,\n+    ) -> Result<Response<MigrateLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do migrating yet\",\n+        ))\n+    }\n }\n \n fn parquet_to_records(parquet: Arc<Vec<u8>>) -> Result<Vec<(LogPosition, Vec<u8>)>, Status> {\n---\n\n\n---\n\nChoice B:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionWithoutMetadata(collectionID *string, databaseName *string, softDeletedFlag *bool) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, NULLIF(collections.root_collection_id, '') AS root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\nChoice C:\nCargo.toml\n@@ -126,6 +126,10 @@ tempfile = \"3.14.0\"\n itertools = \"0.13.0\"\n serial_test = \"3.2.0\"\n \n+[profile.dev]\n+# Significantly reduces compile times\n+split-debuginfo = \"unpacked\"\n+\n [profile.release]\n debug = 2\n lto = \"thin\"\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/quota/mod.rs\n@@ -7,6 +7,7 @@ use std::{\n use chroma_error::ChromaError;\n use chroma_types::{CollectionUuid, Metadata, UpdateMetadata, Where};\n use thiserror::Error;\n+use validator::Validate;\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash)]\n pub enum Action {\n@@ -334,12 +335,14 @@ lazy_static::lazy_static! {\n     };\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Validate)]\n pub struct QuotaExceededError {\n     pub usage_type: UsageType,\n     pub action: Action,\n     pub usage: usize,\n     pub limit: usize,\n+    #[validate(length(min = 1))]\n+    pub message: Option<String>,\n }\n \n impl fmt::Display for QuotaExceededError {\n@@ -348,7 +351,11 @@ impl fmt::Display for QuotaExceededError {\n             f,\n             \"'{}' exceeded quota limit for action '{}': current usage of {} exceeds limit of {}\",\n             self.usage_type, self.action, self.usage, self.limit\n-        )\n+        )?;\n+        if let Some(msg) = self.message.as_ref() {\n+            write!(f, \". {}\", msg)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -393,3 +400,63 @@ impl QuotaEnforcer for () {\n         Box::pin(ready(Ok(())))\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{Action, QuotaExceededError, UsageType};\n+    use validator::Validate;\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_none() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: None,\n+        };\n+        assert!(error.validate().is_ok());\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_empty() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: Some(\"\".to_string()),\n+        };\n+        assert!(error.validate().is_err());\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_valid() {\n+        let custom_message = \"This is a valid message.\";\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: Some(custom_message.to_string()),\n+        };\n+        assert!(error.validate().is_ok());\n+        let error_string = format!(\"{}\", error);\n+        let expected_error_string = \"'Number of records' exceeded quota limit for action 'Add': current usage of 100 exceeds limit of 50. This is a valid message.\";\n+        assert_eq!(error_string, expected_error_string);\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_display_no_message() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: None,\n+        };\n+        assert!(error.validate().is_ok());\n+        let error_string = format!(\"{}\", error);\n+        assert_eq!(error_string, \"'Number of records' exceeded quota limit for action 'Add': current usage of 100 exceeds limit of 50\");\n+    }\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThis PR disallows setting an empty string for an ID\r\nhttps://github.com/chroma-core/chroma/issues/4346\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n<!-- Summary by @propel-code-bot -->\n\n---\n\nThis PR adds validation to prevent empty string IDs during the record addition process. It modifies the Rust codebase to reject IDs with zero characters by adding a new error type and appropriate validation check, addressing issue #4346.\n\n**Key Changes:**\n\u2022 Added a new `EmptyId` error type to the `ToRecordsError` enum\n\u2022 Added validation to check for empty IDs in the `to_records` function\n\u2022 Added comprehensive test cases to verify the validation behavior\n\n\n**Affected Areas:**\n\u2022 rust/frontend/src/impls/utils.rs\n\n\n*This summary was automatically generated by @propel-code-bot*\n\n---\n\nChoice A:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.4\",\n+  \"version\": \"2.4.5\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\n\n\n---\n\nChoice B:\nclients/new-js/packages/chromadb/src/utils.ts\n@@ -350,7 +350,8 @@ export const validateWhere = (where: Where) => {\n         );\n       }\n \n-      Object.values(where).forEach((w: Where) => validateWhere(w));\n+      value.forEach((w: Where) => validateWhere(w));\n+      return;\n     }\n \n     if (typeof value === \"object\") {\n---\n\n\n---\n\nChoice C:\nrust/segment/src/sqlite_metadata.rs\n@@ -381,10 +381,6 @@ trait IntoSqliteExpr {\n     /// We need to use `Min` and `Max` as a workaround\n     /// In SQLite, boolean can be implicitly treated as binary integer\n     fn eval(&self) -> SimpleExpr;\n-\n-    fn one() -> SimpleExpr {\n-        Expr::value(1)\n-    }\n }\n \n impl IntoSqliteExpr for Where {\n@@ -460,16 +456,21 @@ impl IntoSqliteExpr for Where {\n \n impl IntoSqliteExpr for CompositeExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let mut expr = Self::one();\n-        for child in &self.children {\n-            expr = expr.mul(match self.operator {\n-                BooleanOperator::And => child.eval(),\n-                BooleanOperator::Or => Self::one().sub(child.eval()),\n-            })\n-        }\n         match self.operator {\n-            BooleanOperator::And => expr,\n-            BooleanOperator::Or => Self::one().sub(expr),\n+            BooleanOperator::And => {\n+                let mut expr = SimpleExpr::Value(sea_query::Value::Bool(Some(true)));\n+                for child in &self.children {\n+                    expr = Expr::expr(expr).and(child.eval());\n+                }\n+                expr\n+            }\n+            BooleanOperator::Or => {\n+                let mut expr = SimpleExpr::Value(sea_query::Value::Bool(Some(false)));\n+                for child in &self.children {\n+                    expr = Expr::expr(expr).or(child.eval());\n+                }\n+                expr\n+            }\n         }\n     }\n }\n@@ -506,24 +507,36 @@ impl IntoSqliteExpr for MetadataExpression {\n                     MetadataValue::Str(s) => (EmbeddingMetadata::StringValue, Expr::val(s)),\n                 };\n                 let scol = Expr::col((EmbeddingMetadata::Table, col));\n+                let mut subq = Query::select()\n+                    .column(EmbeddingMetadata::Id)\n+                    .from(EmbeddingMetadata::Table)\n+                    .and_where(key_cond.clone())\n+                    .to_owned();\n+\n                 match op {\n                     PrimitiveOperator::Equal => {\n-                        Expr::expr(key_cond.and(scol.eq(sval).is(true))).max()\n+                        subq.and_where(scol.eq(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::NotEqual => {\n-                        Expr::expr(key_cond.and(scol.eq(sval).is(true)).not()).min()\n+                        subq.and_where(scol.eq(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq)\n                     }\n                     PrimitiveOperator::GreaterThan => {\n-                        Expr::expr(key_cond.and(scol.gt(sval).is(true))).max()\n+                        subq.and_where(scol.gt(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::GreaterThanOrEqual => {\n-                        Expr::expr(key_cond.and(scol.gte(sval).is(true))).max()\n+                        subq.and_where(scol.gte(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::LessThan => {\n-                        Expr::expr(key_cond.and(scol.lt(sval).is(true))).max()\n+                        subq.and_where(scol.lt(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::LessThanOrEqual => {\n-                        Expr::expr(key_cond.and(scol.lte(sval).is(true))).max()\n+                        subq.and_where(scol.lte(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                 }\n             }\n@@ -547,10 +560,20 @@ impl IntoSqliteExpr for MetadataExpression {\n                     ),\n                 };\n                 let scol = Expr::col((EmbeddingMetadata::Table, col));\n-                let val_in = key_cond.and(scol.is_in(svals).is(true));\n+                let subq = Query::select()\n+                    .column(EmbeddingMetadata::Id)\n+                    .from(EmbeddingMetadata::Table)\n+                    .and_where(key_cond.clone())\n+                    .and_where(scol.is_in(svals))\n+                    .to_owned();\n+\n                 match op {\n-                    SetOperator::In => Expr::expr(val_in).max(),\n-                    SetOperator::NotIn => Expr::expr(val_in.not()).min(),\n+                    SetOperator::In => {\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n+                    }\n+                    SetOperator::NotIn => {\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq)\n+                    }\n                 }\n             }\n         }\n@@ -658,15 +681,8 @@ impl SqliteMetadataReader {\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n                 )\n-                .add_group_by([\n-                    Expr::col((Embeddings::Table, Embeddings::Id)).into(),\n-                    Expr::col((\n-                        EmbeddingFulltextSearch::Table,\n-                        EmbeddingFulltextSearch::StringValue,\n-                    ))\n-                    .into(),\n-                ])\n-                .cond_having(whr.eval());\n+                .distinct()\n+                .cond_where(whr.eval());\n         }\n \n         filter_limit_query\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/impls/utils.rs\n@@ -8,6 +8,8 @@ use chroma_types::{\n pub(crate) enum ToRecordsError {\n     #[error(\"Inconsistent number of IDs, embeddings, documents, URIs and metadatas\")]\n     InconsistentLength,\n+    #[error(\"Empty ID, ID must have at least one character\")]\n+    EmptyId,\n }\n \n impl ChromaError for ToRecordsError {\n@@ -47,6 +49,9 @@ pub(crate) fn to_records<\n     let mut records = Vec::with_capacity(len);\n \n     for id in ids {\n+        if id.is_empty() {\n+            return Err(ToRecordsError::EmptyId);\n+        }\n         let embedding = embeddings_iter.next().flatten();\n         let document = documents_iter.next().flatten();\n         let uri = uris_iter.next().flatten();\n@@ -87,3 +92,59 @@ pub(crate) fn to_records<\n \n     Ok((records, total_bytes))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use chroma_types::Operation;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_to_records_empty_id() {\n+        let ids = vec![String::from(\"\")];\n+        let embeddings = vec![Some(vec![1.0, 2.0, 3.0])];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(ids, Some(embeddings), None, None, None, Operation::Add);\n+        assert!(matches!(result, Err(ToRecordsError::EmptyId)));\n+    }\n+\n+    #[test]\n+    fn test_normal_ids() {\n+        let ids = vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\")];\n+        let embeddings = vec![\n+            Some(vec![1.0, 2.0, 3.0]),\n+            Some(vec![4.0, 5.0, 6.0]),\n+            Some(vec![7.0, 8.0, 9.0]),\n+        ];\n+        let documents = vec![\n+            Some(String::from(\"document 1\")),\n+            Some(String::from(\"document 2\")),\n+            Some(String::from(\"document 3\")),\n+        ];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(\n+            ids,\n+            Some(embeddings),\n+            Some(documents),\n+            None,\n+            None,\n+            Operation::Add,\n+        );\n+        assert!(result.is_ok());\n+        let records = result.unwrap().0;\n+        assert_eq!(records.len(), 3);\n+        assert_eq!(records[0].id, \"1\");\n+        assert_eq!(records[1].id, \"2\");\n+        assert_eq!(records[2].id, \"3\");\n+        assert_eq!(records[0].embedding, Some(vec![1.0, 2.0, 3.0]));\n+        assert_eq!(records[1].embedding, Some(vec![4.0, 5.0, 6.0]));\n+        assert_eq!(records[2].embedding, Some(vec![7.0, 8.0, 9.0]));\n+        assert_eq!(records[0].document, Some(String::from(\"document 1\")));\n+        assert_eq!(records[1].document, Some(String::from(\"document 2\")));\n+        assert_eq!(records[2].document, Some(String::from(\"document 3\")));\n+    }\n+}\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis makes it so it can talk to rust-frontend-service.chroma.\n\n## Test plan\n\nchroma-load running against tilt.\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\n.github/workflows/_rust-tests.yml\n@@ -42,7 +42,9 @@ jobs:\n     strategy:\n       matrix:\n         platform: [blacksmith-16vcpu-ubuntu-2204]\n+        partition: [1, 2]\n     runs-on: ${{ matrix.platform }}\n+    name: Integration test ${{ matrix.partition }}/2\n     # OIDC token auth for AWS\n     permissions:\n       contents: read\n@@ -66,12 +68,12 @@ jobs:\n       - name: Build CLI\n         run: cargo build --bin chroma\n       - name: Run tests\n-        run: cargo nextest run --profile ci_k8s_integration\n+        run: cargo nextest run --profile ci_k8s_integration --partition hash:${{ matrix.partition }}/2\n       - name: Save service logs to artifact\n         if: always()\n         uses: ./.github/actions/export-tilt-logs\n         with:\n-          artifact-name: \"rust-integration-test\"\n+          artifact-name: \"rust-integration-test-${{ matrix.partition }}\"\n   test-benches:\n     strategy:\n       matrix:\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/repository/log.go\n@@ -51,6 +51,14 @@ func (r *LogRepository) InsertRecords(ctx context.Context, collectionId string,\n \t\t\t\tRecordCompactionOffsetPosition:  0,\n \t\t\t})\n \t\t\tif err != nil {\n+\t\t\t\tvar pgErr *pgconn.PgError\n+\t\t\t\t// This is a retryable error and should be retried by upstream. It happens\n+\t\t\t\t// when two concurrent adds to the same collection happen.\n+\t\t\t\tif errors.As(err, &pgErr) && pgErr.Code == \"23505\" {\n+\t\t\t\t\ttrace_log.Error(\"Duplicate key error while inserting into collection table\", zap.String(\"collectionId\", collectionId), zap.String(\"detail\", pgErr.Detail))\n+\t\t\t\t\terr = status.Error(codes.AlreadyExists, fmt.Sprintf(\"Duplicate key error while inserting into collection table: %s\", pgErr.Detail))\n+\t\t\t\t\treturn\n+\t\t\t\t}\n \t\t\t\ttrace_log.Error(\"Error in creating a new entry in collection table\", zap.Error(err), zap.String(\"collectionId\", collectionId))\n \t\t\t\treturn\n \t\t\t}\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -364,6 +364,10 @@ pub enum DirtyMarker {\n     },\n     #[serde(rename = \"purge\")]\n     Purge { collection_id: CollectionUuid },\n+    // A Cleared marker is a no-op.  It exists so that a log consisting of mark-dirty markers that\n+    // map onto purge markers will be cleared and can be erased.\n+    #[serde(rename = \"clear\")]\n+    Cleared,\n }\n \n impl DirtyMarker {\n@@ -372,6 +376,7 @@ impl DirtyMarker {\n         match self {\n             DirtyMarker::MarkDirty { collection_id, .. } => *collection_id,\n             DirtyMarker::Purge { collection_id } => *collection_id,\n+            DirtyMarker::Cleared => CollectionUuid::default(),\n         }\n     }\n \n@@ -416,6 +421,7 @@ impl DirtyMarker {\n                 DirtyMarker::Purge { collection_id } => {\n                     forget.push(*collection_id);\n                 }\n+                DirtyMarker::Cleared => {}\n             }\n         }\n         for collection_id in forget {\n@@ -865,22 +871,23 @@ impl LogServer {\n                 backpressure.push(*collection_id);\n             }\n         }\n-        if !markers.is_empty() {\n-            let mut new_cursor = cursor.clone();\n-            new_cursor.position = self.dirty_log.append_many(markers).await?;\n-            let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n-                return Err(Error::CouldNotGetDirtyLogCursors);\n-            };\n-            tracing::info!(\n-                \"Advancing dirty log cursor {:?} -> {:?}\",\n-                cursor.position,\n-                new_cursor.position\n-            );\n-            if let Some(witness) = witness {\n-                cursors.save(&STABLE_PREFIX, &new_cursor, &witness).await?;\n-            } else {\n-                cursors.init(&STABLE_PREFIX, new_cursor).await?;\n-            }\n+        if markers.is_empty() {\n+            markers.push(serde_json::to_string(&DirtyMarker::Cleared).map(Vec::from)?);\n+        }\n+        let mut new_cursor = cursor.clone();\n+        new_cursor.position = self.dirty_log.append_many(markers).await?;\n+        let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n+            return Err(Error::CouldNotGetDirtyLogCursors);\n+        };\n+        tracing::info!(\n+            \"Advancing dirty log cursor {:?} -> {:?}\",\n+            cursor.position,\n+            new_cursor.position\n+        );\n+        if let Some(witness) = witness {\n+            cursors.save(&STABLE_PREFIX, &new_cursor, &witness).await?;\n+        } else {\n+            cursors.init(&STABLE_PREFIX, new_cursor).await?;\n         }\n         self.metrics\n             .log_total_uncompacted_records_count\n---\n\n\n---\n\nChoice D:\nk8s/test/load-service.yaml\n@@ -1,25 +1,16 @@\n----\n-\n-apiVersion: v1\n-kind: Namespace\n-metadata:\n-  name: chroma-load\n-\n----\n-\n apiVersion: apps/v1\n kind: Deployment\n metadata:\n   name: load-service\n-  namespace: chroma-load\n+  namespace: chroma\n spec:\n   replicas: 1\n   selector:\n     matchLabels:\n       app: load-service\n   template:\n     metadata:\n-      namespace: chroma-load\n+      namespace: chroma\n       labels:\n         app: load-service\n     spec:\n@@ -55,7 +46,7 @@ apiVersion: v1\n kind: ConfigMap\n metadata:\n   name: load-service-config\n-  namespace: chroma-load\n+  namespace: chroma\n data:\n   config.yaml: |\n     load_service:\n@@ -70,7 +61,7 @@ apiVersion: v1\n kind: Service\n metadata:\n   name: load-service\n-  namespace: chroma-load\n+  namespace: chroma\n spec:\n   ports:\n     - name: http\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nchroma-load-start checks the environment for an auth key.  Make it optional and push the optionality down.\n\n## Test plan\n\nCI\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/load/src/bin/chroma-load-start.rs\n@@ -90,7 +90,7 @@ async fn main() {\n     let args = Args::parse();\n \n     // Read API key from environment variable.\n-    let api_key = std::env::var(\"CHROMA_API_KEY\").expect(\"CHROMA_API_KEY is not set\");\n+    let api_key = std::env::var(\"CHROMA_API_KEY\").ok();\n \n     let client = reqwest::Client::new();\n     let throughput = args.throughput();\n---\nrust/load/src/lib.rs\n@@ -180,20 +180,25 @@ impl ZipfCache {\n #[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]\n pub struct Connection {\n     pub url: String,\n-    pub api_key: String,\n+    pub api_key: Option<String>,\n     pub database: String,\n }\n \n ////////////////////////////////////////////// client //////////////////////////////////////////////\n \n /// Instantiate a new Chroma client.\n pub async fn client(connection: Connection) -> ChromaClient {\n+    let auth = if let Some(api_key) = connection.api_key.clone() {\n+        ChromaAuthMethod::TokenAuth {\n+            token: api_key,\n+            header: ChromaTokenHeader::XChromaToken,\n+        }\n+    } else {\n+        ChromaAuthMethod::None\n+    };\n     ChromaClient::new(ChromaClientOptions {\n         url: Some(connection.url.clone()),\n-        auth: ChromaAuthMethod::TokenAuth {\n-            token: connection.api_key.clone(),\n-            header: ChromaTokenHeader::XChromaToken,\n-        },\n+        auth,\n         database: connection.database.clone(),\n     })\n     .await\n@@ -1032,7 +1037,7 @@ impl LoadHarness {\n             .iter()\n             .map(|w| {\n                 let mut w = w.clone();\n-                w.connection.api_key = \"REDACTED\".to_string();\n+                w.connection.api_key = Some(\"REDACTED\".to_string());\n                 w\n             })\n             .collect()\n@@ -1744,7 +1749,7 @@ mod tests {\n             \"nop\".to_string(),\n             Connection {\n                 url: \"http://localhost:8000\".to_string(),\n-                api_key: \"\".to_string(),\n+                api_key: None,\n                 database: \"\".to_string(),\n             },\n             (chrono::Utc::now() + chrono::Duration::seconds(10)).into(),\n@@ -1856,7 +1861,7 @@ mod tests {\n             \"nop\".to_string(),\n             Connection {\n                 url: \"http://localhost:8000\".to_string(),\n-                api_key: \"\".to_string(),\n+                api_key: None,\n                 database: \"\".to_string(),\n             },\n             (chrono::Utc::now() + chrono::Duration::seconds(10)).into(),\n---\n\n\n---\n\nChoice B:\nchromadb/api/types.py\n@@ -687,9 +687,11 @@ def validate_metadata(metadata: Metadata) -> Metadata:\n                 f\"Expected metadata key to be a str, got {key} which is a {type(key).__name__}\"\n             )\n         # isinstance(True, int) evaluates to True, so we need to check for bools separately\n-        if not isinstance(value, bool) and not isinstance(value, (str, int, float)):\n+        if not isinstance(value, bool) and not isinstance(\n+            value, (str, int, float, type(None))\n+        ):\n             raise ValueError(\n-                f\"Expected metadata value to be a str, int, float or bool, got {value} which is a {type(value).__name__}\"\n+                f\"Expected metadata value to be a str, int, float, bool, or None, got {value} which is a {type(value).__name__}\"\n             )\n     return metadata\n \n---\nchromadb/base_types.py\n@@ -1,9 +1,9 @@\n-from typing import Dict, List, Mapping, Sequence, Union\n+from typing import Dict, List, Mapping, Optional, Sequence, Union\n from typing_extensions import Literal\n import numpy as np\n from numpy.typing import NDArray\n \n-Metadata = Mapping[str, Union[str, int, float, bool]]\n+Metadata = Mapping[str, Optional[Union[str, int, float, bool]]]\n UpdateMetadata = Mapping[str, Union[int, float, str, bool, None]]\n PyVector = Union[Sequence[float], Sequence[int]]\n Vector = NDArray[Union[np.int32, np.float32]]  # TODO: Specify that the vector is 1D\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/impls/utils.rs\n@@ -8,6 +8,8 @@ use chroma_types::{\n pub(crate) enum ToRecordsError {\n     #[error(\"Inconsistent number of IDs, embeddings, documents, URIs and metadatas\")]\n     InconsistentLength,\n+    #[error(\"Empty ID, ID must have at least one character\")]\n+    EmptyId,\n }\n \n impl ChromaError for ToRecordsError {\n@@ -47,6 +49,9 @@ pub(crate) fn to_records<\n     let mut records = Vec::with_capacity(len);\n \n     for id in ids {\n+        if id.is_empty() {\n+            return Err(ToRecordsError::EmptyId);\n+        }\n         let embedding = embeddings_iter.next().flatten();\n         let document = documents_iter.next().flatten();\n         let uri = uris_iter.next().flatten();\n@@ -87,3 +92,59 @@ pub(crate) fn to_records<\n \n     Ok((records, total_bytes))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use chroma_types::Operation;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_to_records_empty_id() {\n+        let ids = vec![String::from(\"\")];\n+        let embeddings = vec![Some(vec![1.0, 2.0, 3.0])];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(ids, Some(embeddings), None, None, None, Operation::Add);\n+        assert!(matches!(result, Err(ToRecordsError::EmptyId)));\n+    }\n+\n+    #[test]\n+    fn test_normal_ids() {\n+        let ids = vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\")];\n+        let embeddings = vec![\n+            Some(vec![1.0, 2.0, 3.0]),\n+            Some(vec![4.0, 5.0, 6.0]),\n+            Some(vec![7.0, 8.0, 9.0]),\n+        ];\n+        let documents = vec![\n+            Some(String::from(\"document 1\")),\n+            Some(String::from(\"document 2\")),\n+            Some(String::from(\"document 3\")),\n+        ];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(\n+            ids,\n+            Some(embeddings),\n+            Some(documents),\n+            None,\n+            None,\n+            Operation::Add,\n+        );\n+        assert!(result.is_ok());\n+        let records = result.unwrap().0;\n+        assert_eq!(records.len(), 3);\n+        assert_eq!(records[0].id, \"1\");\n+        assert_eq!(records[1].id, \"2\");\n+        assert_eq!(records[2].id, \"3\");\n+        assert_eq!(records[0].embedding, Some(vec![1.0, 2.0, 3.0]));\n+        assert_eq!(records[1].embedding, Some(vec![4.0, 5.0, 6.0]));\n+        assert_eq!(records[2].embedding, Some(vec![7.0, 8.0, 9.0]));\n+        assert_eq!(records[0].document, Some(String::from(\"document 1\")));\n+        assert_eq!(records[1].document, Some(String::from(\"document 2\")));\n+        assert_eq!(records[2].document, Some(String::from(\"document 3\")));\n+    }\n+}\n---\n\n\n---\n\nChoice D:\nclients/js/packages/chromadb-core/src/ChromaFetch.ts\n@@ -9,6 +9,7 @@ import {\n   ChromaError,\n   createErrorByType,\n   ChromaUniqueError,\n+  ChromaQuotaExceededError,\n } from \"./Errors\";\n import { FetchAPI } from \"./generated\";\n \n@@ -74,6 +75,14 @@ export const chromaFetch: FetchAPI = async (\n           );\n         case 409:\n           throw new ChromaUniqueError(\"The resource already exists\");\n+        case 422:\n+          if (\n+            respBody?.message &&\n+            respBody?.message.startsWith(\"Quota exceeded\")\n+          ) {\n+            throw new ChromaQuotaExceededError(respBody?.message);\n+          }\n+          break;\n         case 500:\n           throw parseServerError(respBody?.error);\n         case 502:\n---\nclients/js/packages/chromadb-core/src/Errors.ts\n@@ -85,6 +85,13 @@ export class ChromaUniqueError extends Error {\n   }\n }\n \n+export class ChromaQuotaExceededError extends Error {\n+  name = \"ChromaQuotaExceededError\";\n+  constructor(message: string, public readonly cause?: unknown) {\n+    super(message);\n+  }\n+}\n+\n export function createErrorByType(type: string, message: string) {\n   switch (type) {\n     case \"InvalidCollection\":\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nWhen the upsert operations are rate-limited, the \"block\" of 100 records in the operation is never inserted. Therefore, the cardinality of the test data set can never grow beyond the point of the failed (rate limited) upsert.\r\n\r\nAlso, when starting a new workload, we need to reset the cardinality and heap for the data set, so that it starts again from cardinality of 0.\r\n\r\n## Test plan\r\n\r\nTested locally in tilt. Verified that the cardinality of the test data set continues to grow, even after hitting rate limit errors on previous upsert attempts. Also verified that the cardinality is reset to 0 when initializing a new workload.\r\n\n\n---\n\nChoice A:\nCargo.lock\n@@ -1618,6 +1618,7 @@ dependencies = [\n  \"opentelemetry-http\",\n  \"opentelemetry-otlp\",\n  \"opentelemetry_sdk\",\n+ \"rand 0.8.5\",\n  \"reqwest 0.12.9\",\n  \"serde\",\n  \"serde_json\",\n---\nrust/load/Cargo.toml\n@@ -8,6 +8,7 @@ async-trait = { workspace = true }\n chrono = { workspace = true }\n clap = { workspace = true }\n figment = { workspace = true }\n+rand = { workspace = true }\n serde = { workspace = true }\n serde_json = { workspace = true }\n tokio = { workspace = true }\n---\nrust/load/src/data_sets.rs\n@@ -986,6 +986,11 @@ impl DataSet for VerifyingDataSet {\n         &self,\n         client: &ChromaClient,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n+        // Reset the cardinality and cardinality heap.\n+        self.cardinality\n+            .store(0, std::sync::atomic::Ordering::Relaxed);\n+        self.cardinality_heap.lock().await.clear();\n+\n         // Attempt to delete the collection. If it doesn't exist, ignore the error.\n         match client.delete_collection(&self.test_data_set).await {\n             Ok(_) => (),\n@@ -1255,13 +1260,50 @@ impl DataSet for VerifyingDataSet {\n             } else {\n                 return Err(Box::new(Error::InvalidRequest(\"No documents\".into())));\n             }\n-            let entries = CollectionEntries {\n-                ids: keys,\n-                metadatas: res.metadatas,\n-                documents: Some(documents),\n-                embeddings: Some(embeddings),\n-            };\n-            collection.upsert(entries, None).await?;\n+\n+            let max_retries = 10;\n+            let base_delay = std::time::Duration::from_millis(10);\n+            let max_delay = std::time::Duration::from_secs(10);\n+            let mut retry_count = 0;\n+            let mut delay = base_delay;\n+\n+            loop {\n+                let entries = CollectionEntries {\n+                    ids: keys.clone(),\n+                    metadatas: res.metadatas.clone(),\n+                    documents: Some(documents.clone()),\n+                    embeddings: Some(embeddings.clone()),\n+                };\n+                let result = collection.upsert(entries, None).await;\n+                if let Err(err) = result {\n+                    if format!(\"{err:?}\").contains(\"429\") {\n+                        if retry_count >= max_retries {\n+                            return Err(Box::new(Error::InvalidRequest(format!(\n+                                \"UPSERT for {} failed after {} retries: RATE LIMITED {err:?}\",\n+                                key_start_index, max_retries\n+                            ))));\n+                        }\n+\n+                        tracing::warn!(\n+                            \"UPSERT for {} failed: RATE LIMITED {err:?}, retry {}/{}, sleeping for {:?}\",\n+                            key_start_index, retry_count + 1, max_retries, delay\n+                        );\n+\n+                        tokio::time::sleep(delay).await;\n+\n+                        // Exponential backoff with max delay\n+                        delay = std::cmp::min(delay * 2, max_delay);\n+                        retry_count += 1;\n+                        continue;\n+                    } else {\n+                        return Err(Box::new(Error::InvalidRequest(format!(\n+                            \"UPSERT failed: {err:?}\"\n+                        ))));\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n             self.record_load(key_start_index, uq.batch_size).await;\n         } else {\n             return Err(Box::new(Error::InvalidRequest(\"No results\".into())));\n---\n\n\n---\n\nChoice B:\nrust/frontend/src/server.rs\n@@ -1209,7 +1209,7 @@ pub struct ForkCollectionPayload {\n     )\n )]\n async fn fork_collection(\n-    _headers: HeaderMap,\n+    headers: HeaderMap,\n     Path((tenant, database, collection_id)): Path<(String, String, String)>,\n     State(mut server): State<FrontendServer>,\n     Json(payload): Json<ForkCollectionPayload>,\n@@ -1224,19 +1224,17 @@ async fn fork_collection(\n     tracing::info!(\n         \"Forking collection [{collection_id}] in database [{database}] for tenant [{tenant}]\"\n     );\n-    // NOTE: The quota check if skipped for fork collection for now, and we rely on the scorecard to limit access to certain tenents\n-    // TODO: Unify the quota and scorecard\n-    // server\n-    //     .authenticate_and_authorize(\n-    //         &headers,\n-    //         AuthzAction::ForkCollection,\n-    //         AuthzResource {\n-    //             tenant: Some(tenant.clone()),\n-    //             database: Some(database.clone()),\n-    //             collection: Some(collection_id.clone()),\n-    //         },\n-    //     )\n-    //     .await?;\n+    server\n+        .authenticate_and_authorize(\n+            &headers,\n+            AuthzAction::ForkCollection,\n+            AuthzResource {\n+                tenant: Some(tenant.clone()),\n+                database: Some(database.clone()),\n+                collection: Some(collection_id.clone()),\n+            },\n+        )\n+        .await?;\n     let _guard =\n         server.scorecard_request(&[\"op:fork_collection\", format!(\"tenant:{}\", tenant).as_str()])?;\n     let collection_id =\n---\n\n\n---\n\nChoice C:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.10\"\n+__version__ = \"1.0.11\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.10\"\n+      \"Default\": \"1.0.11\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice D:\nrust/log/src/test.rs\n@@ -124,7 +124,7 @@ pub trait LoadFromGenerator<L: LogGenerator> {\n impl<L: LogGenerator + Send + 'static> LoadFromGenerator<L> for TestDistributedSegment {\n     async fn populate_with_generator(&mut self, log_count: usize, generator: L) {\n         let ids: Vec<_> = (1..=log_count).collect();\n-        for chunk in ids.chunks(100) {\n+        for chunk in ids.chunks(10_000) {\n             self.compact_log(\n                 generator.generate_chunk(chunk.iter().copied()),\n                 chunk\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis adds defaults to values.yaml that make k8s instantiate the log with a cache dir mounted.\n\n## Test plan\n\nCI + eyes.\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/utils/embedding_functions/instructor_embedding_function.py\n@@ -39,7 +39,7 @@ def __init__(\n         self.device = device\n         self.instruction = instruction\n \n-        self._model = INSTRUCTOR(model_name, device=device)\n+        self._model = INSTRUCTOR(model_name_or_path=model_name, device=device)\n \n     def __call__(self, input: Documents) -> Embeddings:\n         \"\"\"\n@@ -99,10 +99,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\nchromadb/utils/embedding_functions/sentence_transformer_embedding_function.py\n@@ -42,7 +42,7 @@ def __init__(\n \n         if model_name not in self.models:\n             self.models[model_name] = SentenceTransformer(\n-                model_name, device=device, **kwargs\n+                model_name_or_path=model_name, device=device, **kwargs\n             )\n         self._model = self.models[model_name]\n \n@@ -102,10 +102,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\nchromadb/utils/embedding_functions/text2vec_embedding_function.py\n@@ -71,10 +71,10 @@ def get_config(self) -> Dict[str, Any]:\n     def validate_config_update(\n         self, old_config: Dict[str, Any], new_config: Dict[str, Any]\n     ) -> None:\n-        if \"model_name\" in new_config:\n-            raise ValueError(\n-                \"The model name cannot be changed after the embedding function has been initialized.\"\n-            )\n+        # model_name is also used as the identifier for model path if stored locally.\n+        # Users should be able to change the path if needed, so we should not validate that.\n+        # e.g. moving file path from /v1/my-model.bin to /v2/my-model.bin\n+        return\n \n     @staticmethod\n     def validate_config(config: Dict[str, Any]) -> None:\n---\n\n\n---\n\nChoice B:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.38\n+version: 0.1.39\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/values.yaml\n@@ -51,6 +51,9 @@ rustLogService:\n   image:\n     repository: 'rust-log-service'\n     tag: 'latest'\n+  cache:\n+    hostPath: '/local/cache/chroma-log-service'\n+    mountPath: '/cache/'\n \n queryService:\n   image:\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -339,11 +339,16 @@ impl RollupPerCollection {\n             std::cmp::max(self.initial_insertion_epoch_us, initial_insertion_epoch_us);\n     }\n \n-    fn witness_manifest_and_cursor(&mut self, manifest: &Manifest, witness: Option<&Witness>) {\n+    fn witness_cursor(&mut self, witness: Option<&Witness>) {\n+        // NOTE(rescrv):  There's an easy dance here to justify this as correct.  For the start log\n+        // position to advance, there must have been at least one GC cycle with a cursor that was\n+        // something other than 1.  That cursor should never get deleted, therefore we have a\n+        // witness and the unwrap_or call 0x90s.\n+        //\n+        // The consequence of this breaking is that the offset in the log will be behind sysdb.\n         self.start_log_position = witness\n             .map(|x| x.1.position)\n-            .unwrap_or(manifest.minimum_log_position());\n-        self.limit_log_position = manifest.maximum_log_position();\n+            .unwrap_or(LogPosition::from_offset(1));\n     }\n \n     fn is_empty(&self) -> bool {\n@@ -999,15 +1004,6 @@ impl LogServer {\n         &self,\n         rollups: &mut HashMap<CollectionUuid, RollupPerCollection>,\n     ) -> Result<(), Error> {\n-        let load_manifest = |storage, collection_id| async move {\n-            let reader = LogReader::new(\n-                LogReaderOptions::default(),\n-                Arc::clone(storage),\n-                storage_prefix_for_log(collection_id),\n-            );\n-            let span = tracing::info_span!(\"manifest load\", collection_id = ?collection_id);\n-            reader.manifest().instrument(span).await\n-        };\n         let load_cursor = |storage, collection_id| async move {\n             let cursor = &COMPACTION;\n             let cursor_store = CursorStore::new(\n@@ -1020,18 +1016,12 @@ impl LogServer {\n             cursor_store.load(cursor).instrument(span).await\n         };\n         for (collection_id, mut rollup) in std::mem::take(rollups) {\n-            // TODO(rescrv):  We can avoid loading the manifest and cursor by checking an\n-            // in-memory lookaside structure.\n-            let Some(manifest) = load_manifest(&self.storage, collection_id).await? else {\n-                tracing::warn!(\"{collection_id} has no manifest; this may mean it was deleted\");\n-                continue;\n-            };\n             let cursor = load_cursor(&self.storage, collection_id).await?;\n             // NOTE(rescrv):  There are two spreads that we have.\n             // `rollup` tracks the minimum and maximum offsets of a record on the dirty log.\n             // The spread between cursor (if it exists) and manifest.maximum_log_offset tracks the\n             // data that needs to be compacted.\n-            rollup.witness_manifest_and_cursor(&manifest, cursor.as_ref());\n+            rollup.witness_cursor(cursor.as_ref());\n             if !rollup.is_empty() {\n                 rollups.insert(collection_id, rollup);\n             }\n---\n\n\n---\n\nChoice D:\nchromadb/test/property/test_fork.py\n@@ -8,6 +8,7 @@\n \n from chromadb.api.models.Collection import Collection\n from chromadb.test.conftest import reset, skip_if_not_cluster\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n from hypothesis.stateful import (\n     Bundle,\n     RuleBasedStateMachine,\n@@ -198,22 +199,29 @@ def test_fork_with_log_migration(\n     import grpc\n     from chromadb.proto.logservice_pb2 import SealLogRequest\n     from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+    from chromadb.proto.coordinator_pb2_grpc import SysDBStub\n \n     caplog.set_level(logging.ERROR)\n     client.reset()\n     channel = grpc.insecure_channel(\"localhost:50052\")\n     go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n \n+    channel = grpc.insecure_channel(\"localhost:50051\")\n+    sysdb_service = SysDBStub(channel)  # type: ignore[no-untyped-call]\n+\n+    NUMBER = 100\n+\n     collection = client.create_collection(\"legacy-go-collection-0\")\n-    ids = [f\"id_{i}\" for i in range(6)]\n-    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    ids = sorted([f\"id_{i}\" for i in range(NUMBER)])\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(NUMBER)])  # type: ignore[arg-type]\n     go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n     fork_collection = collection.fork(\"fork-legacy-go-collection-0\")\n     assert sorted(fork_collection.get()[\"ids\"]) == ids\n \n     collection = client.create_collection(\"legacy-go-collection-1\")\n     go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n-    ids = [f\"id_{i}\" for i in range(6)]\n-    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    ids = sorted([f\"id_{i}\" for i in range(NUMBER)])\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(NUMBER)])  # type: ignore[arg-type]\n     fork_collection = collection.fork(\"fork-legacy-go-collection-1\")\n+    wait_for_version_increase(client, fork_collection.name, 0)\n     assert sorted(fork_collection.get()[\"ids\"]) == ids\n---\nrust/log-service/src/lib.rs\n@@ -38,7 +38,7 @@ use tracing::{Instrument, Level};\n use uuid::Uuid;\n use wal3::{\n     Cursor, CursorName, CursorStore, CursorStoreOptions, Fragment, Limits, LogPosition, LogReader,\n-    LogReaderOptions, LogWriter, LogWriterOptions, Manifest, Witness,\n+    LogReaderOptions, LogWriter, LogWriterOptions, Manifest, MarkDirty as MarkDirtyTrait, Witness,\n };\n \n pub mod state_hash_table;\n@@ -1427,15 +1427,22 @@ impl LogServer {\n             );\n             // This is the next record to insert, so we'll have to adjust downwards.\n             let max_offset = log_reader.maximum_log_position().await.map_err(|err| {\n-                Status::new(err.code().into(), format!(\"Failed to copy log: {}\", err))\n+                Status::new(err.code().into(), format!(\"Failed to read copied log: {}\", err))\n             })?;\n             if max_offset < offset {\n                 return Err(Status::new(\n                     chroma_error::ErrorCodes::Internal.into(),\n                     format!(\"max_offset={:?} < offset={:?}\", max_offset, offset),\n                 ));\n             }\n-            tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n+            if offset != max_offset{\n+                let mark_dirty = MarkDirty {\n+                    collection_id: target_collection_id,\n+                    dirty_log: Arc::clone(&self.dirty_log),\n+                };\n+                let _ = mark_dirty.mark_dirty(offset, (max_offset - offset) as usize).await;\n+            }\n+            tracing::event!(Level::INFO, compaction_offset =? offset.offset() - 1, enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n                 // NOTE: The upstream service expects the last compacted offset as compaction offset\n                 compaction_offset: (offset - 1u64).offset(),\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n* Add struct to properly parse Github endpoint API\r\n* Fix wrong version check for installing sample apps\r\n\r\n## Test plan\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nN/A\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -497,11 +497,6 @@ impl DirtyMarker {\n                         None\n                     }\n                     Ordering::Greater => {\n-                        tracing::info!(\n-                            \"{collection_id} has range ({}, {}]\",\n-                            record_compaction_position,\n-                            record_enumeration_position,\n-                        );\n                         uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_backpressure {\n                             backpressure.push(*collection_id);\n---\n\n\n---\n\nChoice B:\n.github/workflows/_build_release_container.yml\n@@ -38,7 +38,7 @@ env:\n jobs:\n   build:\n     name: Build and publish container image\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n+    runs-on: blacksmith-16vcpu-ubuntu-2204\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n---\n\n\n---\n\nChoice C:\nchromadb/test/distributed/test_log_failover.py\n@@ -23,6 +23,50 @@\n \n RECORDS = 100\n \n+@skip_if_not_cluster()\n+def test_log_immediate_failover(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n+\n @skip_if_not_cluster()\n def test_log_failover(\n     client: ClientAPI,\n---\ngo/pkg/log/repository/log.go\n@@ -4,6 +4,7 @@ import (\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"strings\"\n \t\"time\"\n \n \tlog \"github.com/chroma-core/chroma/go/pkg/log/store/db\"\n@@ -215,6 +216,9 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \n func (r *LogRepository) SealCollection(ctx context.Context, collectionID string) (err error) {\n \t_, err = r.queries.SealLog(ctx, collectionID)\n+\tif err != nil && strings.Contains(err.Error(), \"no rows in result set\") {\n+\t\t_, err = r.queries.SealLogInsert(ctx, collectionID)\n+\t}\n \treturn\n }\n \n---\ngo/pkg/log/store/db/queries.sql.go\n@@ -292,6 +292,22 @@ func (q *Queries) SealLog(ctx context.Context, id string) (Collection, error) {\n \treturn i, err\n }\n \n+const sealLogInsert = `-- name: SealLogInsert :one\n+INSERT INTO collection(id, is_sealed, record_compaction_offset_position, record_enumeration_offset_position) VALUES ($1, true, 0, 0) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+`\n+\n+func (q *Queries) SealLogInsert(ctx context.Context, id string) (Collection, error) {\n+\trow := q.db.QueryRow(ctx, sealLogInsert, id)\n+\tvar i Collection\n+\terr := row.Scan(\n+\t\t&i.ID,\n+\t\t&i.RecordCompactionOffsetPosition,\n+\t\t&i.RecordEnumerationOffsetPosition,\n+\t\t&i.IsSealed,\n+\t)\n+\treturn i, err\n+}\n+\n const updateCollectionCompactionOffsetPosition = `-- name: UpdateCollectionCompactionOffsetPosition :exec\n UPDATE collection set record_compaction_offset_position = $2 where id = $1\n `\n---\ngo/pkg/log/store/queries/queries.sql\n@@ -68,3 +68,6 @@ INSERT INTO record_log (\"offset\", collection_id, timestamp, record)\n \n -- name: SealLog :one\n UPDATE collection SET is_sealed = true WHERE id = $1 returning *;\n+\n+-- name: SealLogInsert :one\n+INSERT INTO collection(id, is_sealed, record_compaction_offset_position, record_enumeration_offset_position) VALUES ($1, true, 0, 0) returning *;\n---\n\n\n---\n\nChoice D:\nCargo.lock\n@@ -1442,7 +1442,7 @@ dependencies = [\n \n [[package]]\n name = \"chroma-cli\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n dependencies = [\n  \"arboard\",\n  \"axum 0.8.1\",\n---\nclients/js/packages/chromadb/src/cli.ts\n@@ -23,7 +23,7 @@ const update = async (): Promise<void> => {\n     const installedVersion = process.env.CHROMADB_VERSION || \"0.0.0\";\n     const latestVersion = await getLatestVersion(\"chromadb\");\n \n-    if (semver.lte(installedVersion, latestVersion)) {\n+    if (semver.lt(installedVersion, latestVersion)) {\n       console.log(`\\nA new chromadb version (${latestVersion}) is available!`);\n       console.log(\"\\n\\x1b[4mUpdat with npm\\x1b[0m\");\n       console.log(\"npm install chromadb@latest\");\n---\nrust/cli/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"chroma-cli\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n edition = \"2021\"\n \n [dependencies]\n---\nrust/cli/src/commands/install.rs\n@@ -390,7 +390,7 @@ async fn get_app(\n         Version::parse(&app.cli_version).map_err(|_| InstallError::ListingFailed)?;\n     let cli_version =\n         Version::parse(env!(\"CARGO_PKG_VERSION\")).map_err(|_| InstallError::ListingFailed)?;\n-    if app_cli_version < cli_version {\n+    if app_cli_version > cli_version {\n         return Err(\n             InstallError::VersionMismatch(app_name.clone(), app_cli_version.to_string()).into(),\n         );\n---\nrust/cli/src/commands/update.rs\n@@ -2,6 +2,7 @@ use crate::utils::CliError;\n use colored::Colorize;\n use regex::Regex;\n use semver::Version;\n+use serde::Deserialize;\n use std::error::Error;\n use thiserror::Error;\n \n@@ -19,25 +20,26 @@ pub enum UpdateError {\n     UpdateFailed,\n }\n \n+#[derive(Debug, Deserialize)]\n+struct Release {\n+    tag_name: String,\n+}\n+\n async fn version_check(current_version: Version) -> Result<(), Box<dyn Error>> {\n     let client = reqwest::Client::new();\n-    let response = client\n+    let releases = client\n         .get(GITHUB_RELEASES_URL)\n         .header(\"User-Agent\", \"reqwest\")\n         .send()\n+        .await?\n+        .json::<Vec<Release>>()\n         .await?;\n \n-    if !response.status().is_success() {\n-        return Err(UpdateError::FailedVersionFetch.into());\n-    }\n-\n-    let releases: Vec<String> = response.json().await?;\n-\n     let cli_version_pattern = Regex::new(r\"^cli-(\\d+\\.\\d+\\.\\d+)$\")?;\n     let mut cli_versions = Vec::new();\n \n     for release in releases {\n-        if let Some(caps) = cli_version_pattern.captures(&release) {\n+        if let Some(caps) = cli_version_pattern.captures(&release.tag_name) {\n             if let Some(ver_match) = caps.get(1) {\n                 let ver_str = ver_match.as_str();\n                 if let Ok(ver) = Version::parse(ver_str) {\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nIt is a NOP block that's removed.\n\n## Test plan\n\nC/I.\n\n## Documentation Changes\n\nN/A.\n\n\n---\n\nChoice A:\nrust/mdac/src/scorecard.rs\n@@ -622,4 +622,56 @@ mod tests {\n         assert_eq!(metrics.successful_untrack.load(Ordering::SeqCst), 0);\n         assert_eq!(metrics.failed_track.load(Ordering::SeqCst), 1);\n     }\n+\n+    #[test]\n+    fn three_patterns() {\n+        // Test an exact pattern-based override.\n+        let metrics = TestMetrics::default();\n+        let sc = Scorecard::new(\n+            &metrics,\n+            vec![\n+                Rule::new(\n+                    vec![\n+                        Pattern::must(\"op:*\"),\n+                        Pattern::must(\"tenant:me\"),\n+                        Pattern::must(\"collection:*\"),\n+                    ],\n+                    20,\n+                ),\n+                Rule::new(\n+                    vec![\n+                        Pattern::must(\"op:*\"),\n+                        Pattern::must(\"tenant:*\"),\n+                        Pattern::must(\"collection:*\"),\n+                    ],\n+                    10,\n+                ),\n+            ],\n+            1.try_into().unwrap(),\n+        );\n+        let mut saved_tickets = vec![];\n+        // Fill to the limit specified in the first rule.\n+        for _ in 0..20 {\n+            let t = sc.track(&[\"op:read\", \"tenant:me\", \"collection:foo\"]);\n+            assert!(t.is_some());\n+            saved_tickets.push(t);\n+        }\n+        // Reject\n+        let t = sc.track(&[\"op:read\", \"tenant:me\", \"collection:foo\"]);\n+        assert!(t.is_none());\n+        // Fill to the limit specified in the second rule.\n+        for _ in 0..10 {\n+            let t = sc.track(&[\"op:read\", \"tenant:you\", \"collection:foo\"]);\n+            assert!(t.is_some());\n+            saved_tickets.push(t);\n+        }\n+        // Reject\n+        let t = sc.track(&[\"op:read\", \"tenant:you\", \"collection:foo\"]);\n+        assert!(t.is_none());\n+\n+        assert_eq!(metrics.new_scorecard.load(Ordering::SeqCst), 1);\n+        assert_eq!(metrics.successful_track.load(Ordering::SeqCst), 30);\n+        assert_eq!(metrics.successful_untrack.load(Ordering::SeqCst), 0);\n+        assert_eq!(metrics.failed_track.load(Ordering::SeqCst), 2);\n+    }\n }\n---\n\n\n---\n\nChoice B:\n.github/workflows/_go-tests.yml\n@@ -23,6 +23,9 @@ jobs:\n       - name: Start Tilt services\n         uses: ./.github/actions/tilt\n       - run: bin/cluster-test.sh bash -c 'cd go && make test'\n+        env:\n+          # Ryuk cleans up containers and is enabled by default. In CI it causes tests to occasionally flake.\n+          TESTCONTAINERS_RYUK_DISABLED: \"true\"\n       - name: Save service logs to artifact\n         if: always()\n         uses: ./.github/actions/export-tilt-logs\n---\ngo/Makefile\n@@ -27,8 +27,12 @@ build: proto\n \tgo build -v -o bin/coordinator ./cmd/coordinator/\n \tgo build -v -o bin/logservice ./cmd/logservice/\n \n+# -p 1 runs tests sequentially. If run in parallel tests are pretty flaky in CI.\n+# I believe this is caused by go/script/migrate_up_test.sh, which creates the possibility (observed during CI runs) of running multiple `atlas schema apply --dev-url \"docker://postgres/15/dev\" ...` in parallel.\n+# This command spins up a new Docker container, so my theory is that there's a race condition inside atlas when used this way.\n+# Instead of specifying -p 1, it might be possible to add a cross-process lock to guarantee that only one instance of atlas is running at a time.\n test: build\n-\tgo test -race -cover ./...\n+\tgo test -p 1 -race -cover ./...\n \n \n lint:\n---\ngo/pkg/sysdb/metastore/db/dbcore/core.go\n@@ -224,7 +224,7 @@ func GetDBConfigForTesting() DBConfig {\n \tdbName := \"chroma\"\n \tdbUsername := \"chroma\"\n \tdbPassword := \"chroma\"\n-\tcontainer, _ = postgres2.RunContainer(context.Background(),\n+\tcontainer, err := postgres2.RunContainer(context.Background(),\n \t\ttestcontainers.WithImage(\"docker.io/postgres:15.2-alpine\"),\n \t\tpostgres2.WithDatabase(dbName),\n \t\tpostgres2.WithUsername(dbUsername),\n@@ -235,6 +235,10 @@ func GetDBConfigForTesting() DBConfig {\n \t\t\t\tWithStartupTimeout(5*time.Second)),\n \t)\n \n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n \tvar ports nat.PortMap\n \tports, _ = container.Ports(context.Background())\n \n---\n\n\n---\n\nChoice C:\nrust/js_bindings/Cargo.toml\n@@ -14,7 +14,3 @@ chroma-cli = { workspace = true }\n \n [build-dependencies]\n napi-build = \"2.0.1\"\n-\n-[profile.release]\n-lto = true\n-strip = \"symbols\"\n---\n\n\n---\n\nChoice D:\ngo/pkg/log/repository/log.go\n@@ -168,7 +168,8 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\t}\n \t}()\n \n-\tsourceBounds, err := queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n+\tvar sourceBounds log.GetBoundsForCollectionRow\n+\tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in getting compaction and enumeration offset for source collection\", zap.Error(err), zap.String(\"collectionId\", sourceCollectionID))\n \t\treturn\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThis change removes a misleading / incorrect event log message.\r\n\r\nThe cardinality value is actually computed by record_load, based on the largest contiguous chunk of records that have been loaded so far. We cannot assume the cardinality will increase by 100, just by loading in another chunk of size 100.\r\n\r\n## Test plan\r\n\r\nUntested\r\n\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -1212,13 +1212,6 @@ impl DataSet for VerifyingDataSet {\n             }\n         };\n \n-        event!(\n-            Level::INFO,\n-            \"Upserting {} keys, new cardinality: {}\",\n-            uq.batch_size,\n-            key_start_index + uq.batch_size\n-        );\n-\n         for offset in 0..uq.batch_size {\n             let key = uq.key.select_from_reference(self, offset);\n             if !keys.contains(&key) {\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -22,6 +22,7 @@ use chroma_types::chroma_proto::{\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n use figment::providers::{Env, Format, Yaml};\n+use opentelemetry::metrics::Meter;\n use parquet::arrow::arrow_reader::ParquetRecordBatchReaderBuilder;\n use prost::Message;\n use serde::{Deserialize, Serialize};\n@@ -48,6 +49,22 @@ const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n static STABLE_PREFIX: CursorName = unsafe { CursorName::from_string_unchecked(\"stable_prefix\") };\n static COMPACTION: CursorName = unsafe { CursorName::from_string_unchecked(\"compaction\") };\n \n+////////////////////////////////////////////// Metrics /////////////////////////////////////////////\n+\n+pub struct Metrics {\n+    log_total_uncompacted_records_count: opentelemetry::metrics::Gauge<f64>,\n+}\n+\n+impl Metrics {\n+    pub fn new(meter: Meter) -> Self {\n+        Self {\n+            log_total_uncompacted_records_count: meter\n+                .f64_gauge(\"log_total_uncompacted_records_count\")\n+                .build(),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////// state maintenance ////////////////////////////////////////\n \n // NOTE(rescrv):  This code dynamically opens and closes logs.  An opened log will stay open until\n@@ -334,6 +351,7 @@ impl DirtyMarker {\n \n     /// Given a contiguous prefix of markers, process the log into a rollup.  That is, a set of\n     /// markers to reinsert, a set of collections to compact, and an advance_to log position.\n+    #[allow(clippy::too_many_arguments)]\n     pub async fn rollup<\n         F1: Future<Output = Result<Option<Manifest>, wal3::Error>>,\n         F2: Future<Output = Result<Option<Witness>, wal3::Error>>,\n@@ -345,6 +363,7 @@ impl DirtyMarker {\n         record_count_threshold: u64,\n         reinsert_threshold: u64,\n         timeout_us: u64,\n+        metrics: &Metrics,\n     ) -> Result<Option<Rollup>, wal3::Error> {\n         // NOTE(rescrv);  This is complicated code because it's a hard problem to do efficiently.\n         // To cut complexity, I've chosen to do it in a way that is not the most efficient but is\n@@ -434,6 +453,7 @@ impl DirtyMarker {\n             .into_iter()\n             .flat_map(Result::ok)\n             .collect::<HashMap<_, _>>();\n+        let mut uncompacted = 0u64;\n         let compactable = compactable\n             .into_iter()\n             .filter_map(|collection_id| {\n@@ -473,6 +493,7 @@ impl DirtyMarker {\n                             cursor.position,\n                             manifest.maximum_log_position(),\n                         );\n+                        uncompacted += maximum_log_position - cursor.position;\n                         if maximum_log_position - cursor.position >= record_count_threshold {\n                             Some(CollectionInfo {\n                                 collection_id: collection_id.to_string(),\n@@ -514,6 +535,9 @@ impl DirtyMarker {\n                 }\n             }\n         }\n+        metrics\n+            .log_total_uncompacted_records_count\n+            .record(uncompacted as f64, &[]);\n         Ok(Some(Rollup {\n             advance_to,\n             reinsert,\n@@ -608,6 +632,7 @@ pub struct LogServer {\n     dirty_log: Arc<LogWriter>,\n     compacting: tokio::sync::Mutex<()>,\n     cache: Option<Box<dyn chroma_cache::PersistentCache<String, CachedParquetFragment>>>,\n+    metrics: Metrics,\n }\n \n #[async_trait::async_trait]\n@@ -977,6 +1002,7 @@ impl LogService for LogServer {\n             ),\n             self.config.reinsert_threshold,\n             self.config.timeout_us,\n+            &self.metrics,\n         )\n         .await\n         .map_err(|err| Status::unavailable(err.to_string()))?;\n@@ -1456,13 +1482,15 @@ impl Configurable<LogServerConfig> for LogServer {\n         .map_err(|err| -> Box<dyn ChromaError> { Box::new(err) as _ })?;\n         let dirty_log = Arc::new(dirty_log);\n         let compacting = tokio::sync::Mutex::new(());\n+        let metrics = Metrics::new(opentelemetry::global::meter(\"chroma\"));\n         Ok(Self {\n             config: config.clone(),\n             open_logs: Arc::new(StateHashTable::default()),\n             storage,\n             dirty_log,\n             compacting,\n             cache,\n+            metrics,\n         })\n     }\n }\n@@ -1565,6 +1593,7 @@ mod tests {\n             1,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1626,6 +1655,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1709,6 +1739,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n@@ -1822,6 +1853,7 @@ mod tests {\n             3,\n             1,\n             86_400_000_000,\n+            &Metrics::new(opentelemetry::global::meter(\"chroma\")),\n         )\n         .await\n         .unwrap()\n---\n\n\n---\n\nChoice C:\nrust/garbage_collector/src/operators/compute_unused_files.rs\n@@ -1,5 +1,5 @@\n use async_trait::async_trait;\n-use chroma_blockstore::RootManager;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n use chroma_cache::nop::NopCache;\n use chroma_error::{ChromaError, ErrorCodes};\n use chroma_storage::Storage;\n@@ -145,14 +145,14 @@ impl ComputeUnusedFilesOperator {\n         for si_id in si_ids {\n             let uuid = Uuid::parse_str(&si_id).map_err(|e| {\n                 tracing::error!(error = %e, \"Failed to parse UUID\");\n-                ComputeUnusedFilesError::ParseError(si_id.clone(), e.to_string())\n+                ComputeUnusedFilesError::InvalidUuid(e, si_id.clone())\n             })?;\n \n             let block_ids = match self.root_manager.get_all_block_ids(&uuid).await {\n                 Ok(ids) => ids,\n                 Err(e) => {\n                     tracing::error!(error = %e, \"Failed to get block IDs\");\n-                    return Err(ComputeUnusedFilesError::ParseError(si_id, e.to_string()));\n+                    return Err(ComputeUnusedFilesError::FailedToFetchBlockIDs(e));\n                 }\n             };\n             tracing::debug!(\n@@ -193,8 +193,10 @@ pub struct ComputeUnusedFilesOutput {\n \n #[derive(Error, Debug)]\n pub enum ComputeUnusedFilesError {\n-    #[error(\"Error parsing sparse index file: {0}\")]\n-    ParseError(String, String),\n+    #[error(\"Error parsing UUID: {0} from {1}\")]\n+    InvalidUuid(uuid::Error, String),\n+    #[error(\"Failed to fetch block IDs: {0}\")]\n+    FailedToFetchBlockIDs(RootManagerError),\n     #[error(\"Version file has missing content\")]\n     VersionFileMissingContent(i64),\n     #[error(\"Version history is missing\")]\n---\n\n\n---\n\nChoice D:\nrust/load/src/lib.rs\n@@ -1271,13 +1271,11 @@ impl LoadService {\n             for declared in declared {\n                 if let Entry::Vacant(entry) = running.entry(declared.uuid) {\n                     tracing::info!(\"spawning workload {}\", declared.uuid);\n-                    let root = tracing::info_span!(parent: None, \"workload\");\n                     let this = Arc::clone(self);\n                     let done = Arc::new(AtomicBool::new(false));\n                     let done_p = Arc::clone(&done);\n                     let inhibit = Arc::clone(&self.inhibit);\n                     let task = tokio::task::spawn(async move {\n-                        let _enter = root.enter();\n                         this.run_one_workload(done, inhibit, declared).await\n                     });\n                     entry.insert((done_p, task));\n@@ -1295,36 +1293,6 @@ impl LoadService {\n         let client = Arc::new(client(spec.connection.clone()).await);\n         let mut guac = Guacamole::new(spec.expires.timestamp_millis() as u64);\n         let mut next_op = Instant::now();\n-        let (tx, mut rx) = tokio::sync::mpsc::channel(1000);\n-        let _ = tx\n-            .send(tokio::spawn(async move { Ok::<(), Error>(()) }))\n-            .await;\n-        let this = Arc::clone(&self);\n-        let data_set = Arc::clone(&spec.data_set);\n-        let reaper = tokio::spawn(async move {\n-            while let Some(task) = rx.recv().await {\n-                if let Err(err) = task.await.unwrap() {\n-                    if !format!(\"{err:?}\").contains(\"429\") {\n-                        this.metrics.failed.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                        tracing::error!(\"workload task failed: {err:?}\");\n-                    } else {\n-                        this.metrics.limited.add(\n-                            1,\n-                            &[KeyValue::new(\n-                                Key::from_static_str(\"data_set\"),\n-                                Value::from(data_set.name()),\n-                            )],\n-                        );\n-                    }\n-                }\n-            }\n-        });\n \n         // Initialize the data set.\n         let data_set = Arc::clone(&spec.data_set);\n@@ -1408,30 +1376,45 @@ impl LoadService {\n                         .await\n                         .map_err(|err| Error::FailWorkload(err.to_string()))\n                     {\n-                        Ok(()) => Ok(()),\n+                        Ok(()) => (),\n                         Err(err) => {\n-                            if err.to_string().contains(\"invalid request: No results\") {\n+                            if format!(\"{err:?}\").contains(\"invalid request: No results\") {\n                                 this.metrics.no_results.add(\n                                     1,\n                                     &[KeyValue::new(\n                                         Key::from_static_str(\"data_set\"),\n                                         Value::from(data_set.name()),\n                                     )],\n                                 );\n-                                Ok(())\n+                                tracing::warn!(\"workload step no results: {err:?}\");\n+                            } else if !format!(\"{err:?}\").contains(\"429\") {\n+                                this.metrics.failed.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::error!(\"workload step failed: {err:?}\");\n                             } else {\n-                                Err(err)\n+                                this.metrics.limited.add(\n+                                    1,\n+                                    &[KeyValue::new(\n+                                        Key::from_static_str(\"data_set\"),\n+                                        Value::from(data_set.name()),\n+                                    )],\n+                                );\n+                                tracing::warn!(\"workload step rate limited: {err:?}\");\n                             }\n                         }\n-                    }\n+                    };\n                 };\n-                tx.send(tokio::spawn(fut)).await.unwrap();\n+                let span = tracing::info_span!(parent: None, \"step\", workload_uuid = %spec.uuid);\n+                tokio::spawn(fut.instrument(span));\n             }\n         }\n         // Not an error, just needs to show up in stdout.\n         tracing::error!(\"workload done: {}/{}\", spec.name, spec.description());\n-        drop(tx);\n-        reaper.await.unwrap();\n     }\n \n     fn load_persistent(&self) -> Result<(), Error> {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nThis PR changes the rust log service from a deployment to a stateful set\nso that we can use the standard memberlist techniques with it.\n\n## Test plan\n\ntilt up works + CI\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/storage/src/admissioncontrolleds3.rs\n@@ -548,9 +548,19 @@ impl CountBasedPolicy {\n             match &mut channel_receiver {\n                 Some(rx) => {\n                     select! {\n-                        _ = rx.recv() => {\n+                        did_recv = rx.recv() => {\n                             // Reevaluate priority if we got a notification.\n-                            continue;\n+                            match did_recv {\n+                                Some(_) => {\n+                                    // If we got a notification, continue to acquire.\n+                                    continue;\n+                                }\n+                                None => {\n+                                    // If the channel was closed, break out of the loop.\n+                                    channel_receiver = None;\n+                                    continue;\n+                                }\n+                            }\n                         }\n                         token = self.remaining_tokens[current_priority.as_usize()].acquire() => {\n                             match token {\n---\nrust/worker/src/execution/operators/prefetch_record.rs\n@@ -6,7 +6,7 @@ use chroma_segment::{\n     blockfile_record::{RecordSegmentReader, RecordSegmentReaderCreationError},\n     types::{materialize_logs, LogMaterializerError},\n };\n-use chroma_system::Operator;\n+use chroma_system::{Operator, OperatorType};\n use thiserror::Error;\n use tracing::{trace, Instrument, Span};\n \n@@ -94,4 +94,8 @@ impl Operator<PrefetchRecordInput, PrefetchRecordOutput> for PrefetchRecordOpera\n     fn errors_when_sender_dropped(&self) -> bool {\n         false\n     }\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n }\n---\n\n\n---\n\nChoice B:\nrust/frontend/src/server.rs\n@@ -915,57 +915,67 @@ async fn create_collection(\n     let payload_clone = payload.clone();\n \n     let configuration = if !server.config.enable_set_index_params {\n-        let mut new_configuration = payload.configuration.clone().unwrap();\n-        let hnsw_config = new_configuration.hnsw.clone();\n-        let spann_config = new_configuration.spann.clone();\n-\n-        if let Some(hnsw) = &hnsw_config {\n-            let space = hnsw.space.clone();\n-            if hnsw.ef_construction.is_some()\n-                || hnsw.ef_search.is_some()\n-                || hnsw.max_neighbors.is_some()\n-                || hnsw.num_threads.is_some()\n-                || hnsw.resize_factor.is_some()\n-                || hnsw.sync_threshold.is_some()\n-                || hnsw.batch_size.is_some()\n-            {\n-                return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n-                    \"HNSW\".to_string(),\n-                )\n-                .into());\n+        if let Some(mut new_configuration) = payload.configuration.clone() {\n+            let hnsw_config = new_configuration.hnsw.clone();\n+            let spann_config = new_configuration.spann.clone();\n+\n+            if let Some(hnsw) = &hnsw_config {\n+                let space = hnsw.space.clone();\n+                if hnsw.ef_construction.is_some()\n+                    || hnsw.ef_search.is_some()\n+                    || hnsw.max_neighbors.is_some()\n+                    || hnsw.num_threads.is_some()\n+                    || hnsw.resize_factor.is_some()\n+                    || hnsw.sync_threshold.is_some()\n+                    || hnsw.batch_size.is_some()\n+                {\n+                    return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n+                        \"HNSW\".to_string(),\n+                    )\n+                    .into());\n+                }\n+                let new_hnsw = HnswConfiguration {\n+                    space,\n+                    ..Default::default()\n+                };\n+                new_configuration.hnsw = Some(new_hnsw);\n+            } else if let Some(spann) = &spann_config {\n+                let space = spann.space.clone();\n+                if spann.search_nprobe.is_some()\n+                    || spann.write_nprobe.is_some()\n+                    || spann.ef_construction.is_some()\n+                    || spann.ef_search.is_some()\n+                    || spann.max_neighbors.is_some()\n+                    || spann.reassign_neighbor_count.is_some()\n+                    || spann.split_threshold.is_some()\n+                    || spann.merge_threshold.is_some()\n+                {\n+                    return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n+                        \"SPANN\".to_string(),\n+                    )\n+                    .into());\n+                }\n+                let new_spann = SpannConfiguration {\n+                    space,\n+                    ..Default::default()\n+                };\n+                new_configuration.spann = Some(new_spann);\n             }\n-            let new_hnsw = HnswConfiguration {\n-                space,\n-                ..Default::default()\n-            };\n-            new_configuration.hnsw = Some(new_hnsw);\n-        } else if let Some(spann) = &spann_config {\n-            let space = spann.space.clone();\n-            if spann.search_nprobe.is_some()\n-                || spann.write_nprobe.is_some()\n-                || spann.ef_construction.is_some()\n-                || spann.ef_search.is_some()\n-                || spann.max_neighbors.is_some()\n-                || spann.reassign_neighbor_count.is_some()\n-                || spann.split_threshold.is_some()\n-                || spann.merge_threshold.is_some()\n-            {\n-                return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n-                    \"SPANN\".to_string(),\n-                )\n-                .into());\n-            }\n-            let new_spann = SpannConfiguration {\n-                space,\n-                ..Default::default()\n-            };\n-            new_configuration.spann = Some(new_spann);\n-        }\n \n-        Some(InternalCollectionConfiguration::try_from_config(\n-            new_configuration,\n-            server.config.frontend.default_knn_index,\n-        )?)\n+            Some(InternalCollectionConfiguration::try_from_config(\n+                new_configuration,\n+                server.config.frontend.default_knn_index,\n+            )?)\n+        } else {\n+            Some(InternalCollectionConfiguration::try_from_config(\n+                CollectionConfiguration {\n+                    hnsw: None,\n+                    spann: None,\n+                    embedding_function: None,\n+                },\n+                server.config.frontend.default_knn_index,\n+            )?)\n+        }\n     } else {\n         match payload_clone.configuration {\n             Some(c) => Some(InternalCollectionConfiguration::try_from_config(\n---\n\n\n---\n\nChoice C:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.37\n+version: 0.1.38\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/rust-log-service.yaml\n@@ -11,12 +11,30 @@ data:\n \n ---\n \n+apiVersion: v1\n+kind: Service\n+metadata:\n+  name: rust-log-service\n+  namespace: {{ .Values.namespace }}\n+spec:\n+  ports:\n+    - name: server-port\n+      port: 50051\n+      targetPort: 50051\n+  clusterIP: None\n+  selector:\n+    app: rust-log-service\n+  type: ClusterIP\n+\n+---\n+\n apiVersion: apps/v1\n-kind: Deployment\n+kind: StatefulSet\n metadata:\n   name: rust-log-service\n   namespace: {{ .Values.namespace }}\n spec:\n+  serviceName: rust-log-service\n   replicas: {{ .Values.rustLogService.replicaCount }}\n   selector:\n     matchLabels:\n@@ -25,20 +43,48 @@ spec:\n     metadata:\n       labels:\n         app: rust-log-service\n+        member-type: rust-log-service\n     spec:\n       serviceAccountName: rust-log-service-serviceaccount\n+      volumes:\n+        {{if .Values.rustLogService.configuration}}\n+        - name: rust-log-service-config\n+          configMap:\n+            name: rust-log-service-config\n+        {{ end }}\n+        {{if .Values.rustLogService.cache}}\n+        - name: rust-log-service-cache\n+          hostPath:\n+            path: {{ .Values.rustLogService.cache.hostPath }}\n+            type: DirectoryOrCreate\n+        {{ end }}\n       containers:\n         - name: rust-log-service\n           {{ if .Values.rustLogService.command }}\n           command: {{ .Values.rustLogService.command }}\n           {{ end }}\n           image: \"{{ .Values.rustLogService.image.repository }}:{{ .Values.rustLogService.image.tag }}\"\n           imagePullPolicy: IfNotPresent\n-          ports:\n-            - containerPort: 50051\n           readinessProbe:\n             grpc:\n               port: 50051\n+          volumeMounts:\n+            {{if .Values.rustLogService.configuration}}\n+            - name: rust-log-service-config\n+              mountPath: /config/\n+            {{ end }}\n+            {{if .Values.rustLogService.cache}}\n+            - name: rust-log-service-cache\n+              mountPath: {{ .Values.rustLogService.cache.mountPath }}\n+            {{ end }}\n+          ports:\n+            - containerPort: 50051\n+          env:\n+            - name: CONFIG_PATH\n+              value: \"/config/config.yaml\"\n+            {{ if .Values.rustLogService.otherEnvConfig }}\n+              {{ .Values.rustLogService.otherEnvConfig | nindent 12 }}\n+            {{ end }}\n           {{ if .Values.rustLogService.resources }}\n           resources:\n             limits:\n@@ -48,18 +94,6 @@ spec:\n               cpu: {{ .Values.rustLogService.resources.requests.cpu }}\n               memory: {{ .Values.rustLogService.resources.requests.memory }}\n           {{ end }}\n-          env:\n-            - name: CONFIG_PATH\n-              value: \"/config/config.yaml\"\n-            {{ if .Values.rustLogService.otherEnvConfig }}\n-              {{ .Values.rustLogService.otherEnvConfig | nindent 12 }}\n-            {{ end }}\n-          {{if .Values.rustLogService.configuration}}\n-          volumeMounts:\n-            - name: rust-log-service-config\n-              mountPath: /config/\n-          {{ end }}\n-\n       {{if .Values.rustLogService.tolerations}}\n       tolerations:\n         {{ toYaml .Values.rustLogService.tolerations | nindent 8 }}\n@@ -68,29 +102,13 @@ spec:\n       nodeSelector:\n         {{ toYaml .Values.rustLogService.nodeSelector | nindent 8 }}\n       {{ end }}\n-      {{if .Values.rustLogService.configuration}}\n-      volumes:\n-        - name: rust-log-service-config\n-          configMap:\n-            name: rust-log-service-config\n-      {{ end }}\n-\n----\n-\n-apiVersion: v1\n-kind: Service\n-metadata:\n-  name: rust-log-service\n-  namespace: {{ .Values.namespace }}\n-spec:\n-  ports:\n-    - name: server-port\n-      port: 50051\n-      targetPort: 50051\n-  selector:\n-    app: rust-log-service\n-  type: ClusterIP\n-\n+      topologySpreadConstraints:\n+        - maxSkew: 1\n+          topologyKey: \"kubernetes.io/hostname\"\n+          whenUnsatisfiable: ScheduleAnyway\n+          labelSelector:\n+            matchLabels:\n+              member-type: rust-log-service\n \n ---\n \n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -215,7 +215,18 @@ async fn get_log_from_handle<'a>(\n     prefix: &str,\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n-    let mut active = handle.active.lock().await;\n+    let active = handle.active.lock().await;\n+    get_log_from_handle_with_mutex_held(handle, active, options, storage, prefix, mark_dirty).await\n+}\n+\n+async fn get_log_from_handle_with_mutex_held<'a>(\n+    handle: &'a crate::state_hash_table::Handle<LogKey, LogStub>,\n+    mut active: tokio::sync::MutexGuard<'_, ActiveLog>,\n+    options: &LogWriterOptions,\n+    storage: &Arc<Storage>,\n+    prefix: &str,\n+    mark_dirty: MarkDirty,\n+) -> Result<LogRef<'a>, wal3::Error> {\n     if active.log.is_some() {\n         active.keep_alive(Duration::from_secs(60));\n     }\n@@ -519,7 +530,12 @@ impl LogServer {\n         // Grab a lock on the state for this key, so that a racing initialize won't do anything.\n         let key = LogKey { collection_id };\n         let handle = self.open_logs.get_or_create_state(key);\n-        let mut _active = handle.active.lock().await;\n+        let active = handle.active.lock().await;\n+\n+        // Someone already initialized the log on a prior call.\n+        if active.log.is_some() {\n+            return Ok(());\n+        }\n \n         tracing::info!(\"log transfer to {collection_id}\");\n         let scout_request = Request::new(ScoutLogsRequest {\n@@ -641,6 +657,23 @@ impl LogServer {\n             log_offset: start as i64 - 1,\n         }))\n         .await?;\n+        // Set it up so that once we release the mutex, the next person won't do I/O and will\n+        // immediately be able to push logs.\n+        let storage_prefix = storage_prefix_for_log(collection_id);\n+        let mark_dirty = MarkDirty {\n+            collection_id,\n+            dirty_log: Arc::clone(&self.dirty_log),\n+        };\n+        // If this fails, the next writer will load manifest and continue unimpeded.\n+        let _ = get_log_from_handle_with_mutex_held(\n+            &handle,\n+            active,\n+            &self.config.writer,\n+            &self.storage,\n+            &storage_prefix,\n+            mark_dirty,\n+        )\n+        .await;\n         Ok(())\n     }\n \n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThis change updates chroma-load-start to read the APi key from the environment. It is a bit more secure than passing the API key via the process arguments, which is potentially readable by other processes on the system.\r\n\r\n## Test plan\r\n\r\nTested locally via tilt.\r\n\n\n---\n\nChoice A:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.9\"\n+__version__ = \"1.0.10\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.8\"\n+      \"Default\": \"1.0.10\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.8\"\n+chroma_version                  = \"1.0.10\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.8\"\n+  default     = \"1.0.10\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.8\"\n+chroma_version                  = \"1.0.10\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.8\"\n+  default     = \"1.0.10\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice B:\nrust/load/src/bin/chroma-load-start.rs\n@@ -24,8 +24,6 @@ struct Args {\n     #[arg(long)]\n     database: String,\n     #[arg(long)]\n-    api_key: String,\n-    #[arg(long)]\n     constant_throughput: Option<f64>,\n     #[arg(long)]\n     sinusoid_throughput: Option<String>,\n@@ -90,6 +88,10 @@ impl Args {\n #[tokio::main]\n async fn main() {\n     let args = Args::parse();\n+\n+    // Read API key from environment variable.\n+    let api_key = std::env::var(\"CHROMA_API_KEY\").expect(\"CHROMA_API_KEY is not set\");\n+\n     let client = reqwest::Client::new();\n     let throughput = args.throughput();\n     let mut workload = Workload::ByName(args.workload);\n@@ -108,7 +110,7 @@ async fn main() {\n         data_set: args.data_set,\n         connection: Connection {\n             url: args.url,\n-            api_key: args.api_key,\n+            api_key,\n             database: args.database,\n         },\n         throughput,\n---\nrust/load/src/lib.rs\n@@ -1026,8 +1026,16 @@ pub struct LoadHarness {\n \n impl LoadHarness {\n     /// The status of the load harness.\n+    /// This returns the list of running workloads with secrets redacted.\n     pub fn status(&self) -> Vec<RunningWorkload> {\n-        self.running.clone()\n+        self.running\n+            .iter()\n+            .map(|w| {\n+                let mut w = w.clone();\n+                w.connection.api_key = \"REDACTED\".to_string();\n+                w\n+            })\n+            .collect()\n     }\n \n     /// Start a workload on the load harness.\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1138,6 +1138,7 @@ func (tc *Catalog) createSegmentImpl(txCtx context.Context, createSegment *model\n \t\tType:         createSegment.Type,\n \t\tScope:        createSegment.Scope,\n \t\tTs:           ts,\n+\t\tFilePaths:    createSegment.FilePaths,\n \t}\n \terr := tc.metaDomain.SegmentDb(txCtx).Insert(dbSegment)\n \tif err != nil {\n@@ -2000,11 +2001,11 @@ func (tc *Catalog) getNumberOfActiveVersions(versionFilePb *coordinatorpb.Collec\n }\n \n func (tc *Catalog) getOldestVersionTs(versionFilePb *coordinatorpb.CollectionVersionFile) time.Time {\n-\tif versionFilePb.GetVersionHistory() == nil || len(versionFilePb.GetVersionHistory().Versions) <= 1 {\n+\tif versionFilePb.GetVersionHistory() == nil || len(versionFilePb.GetVersionHistory().Versions) == 0 {\n \t\t// Returning a zero timestamp that represents an unset value.\n \t\treturn time.Time{}\n \t}\n-\toldestVersionTs := versionFilePb.GetVersionHistory().Versions[1].CreatedAtSecs\n+\toldestVersionTs := versionFilePb.GetVersionHistory().Versions[0].CreatedAtSecs\n \n \treturn time.Unix(oldestVersionTs, 0)\n }\n@@ -2041,7 +2042,7 @@ func (tc *Catalog) DeleteVersionEntriesForCollection(ctx context.Context, tenant\n \t\t}\n \n \t\tnumActiveVersions := tc.getNumberOfActiveVersions(versionFilePb)\n-\t\tif numActiveVersions <= 1 {\n+\t\tif numActiveVersions < 1 {\n \t\t\t// No remaining valid versions after GC.\n \t\t\treturn errors.New(\"no valid versions after gc\")\n \t\t}\n@@ -2091,11 +2092,15 @@ func (tc *Catalog) DeleteCollectionVersion(ctx context.Context, req *coordinator\n \tresult := coordinatorpb.DeleteCollectionVersionResponse{\n \t\tCollectionIdToSuccess: make(map[string]bool),\n \t}\n+\tvar firstErr error\n \tfor _, collectionVersionList := range req.Versions {\n \t\terr := tc.DeleteVersionEntriesForCollection(ctx, collectionVersionList.TenantId, collectionVersionList.CollectionId, collectionVersionList.Versions)\n \t\tresult.CollectionIdToSuccess[collectionVersionList.CollectionId] = err == nil\n+\t\tif firstErr == nil && err != nil {\n+\t\t\tfirstErr = err\n+\t\t}\n \t}\n-\treturn &result, nil\n+\treturn &result, firstErr\n }\n \n func (tc *Catalog) BatchGetCollectionVersionFilePaths(ctx context.Context, collectionIds []string) (*coordinatorpb.BatchGetCollectionVersionFilePathsResponse, error) {\n---\ngo/pkg/sysdb/coordinator/table_catalog_test.go\n@@ -759,7 +759,7 @@ func TestCatalog_DeleteCollectionVersion_CollectionNotFound(t *testing.T) {\n \tresp, err := catalog.DeleteCollectionVersion(context.Background(), req)\n \n \t// Verify results\n-\tassert.NoError(t, err)\n+\tassert.Error(t, err)\n \tassert.NotNil(t, resp)\n \tassert.False(t, resp.CollectionIdToSuccess[collectionID])\n \n---\ngo/pkg/sysdb/grpc/proto_model_convert.go\n@@ -1,6 +1,8 @@\n package grpc\n \n import (\n+\t\"time\"\n+\n \t\"github.com/chroma-core/chroma/go/pkg/common\"\n \t\"github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb\"\n \t\"github.com/chroma-core/chroma/go/pkg/sysdb/coordinator/model\"\n@@ -131,6 +133,7 @@ func convertToCreateCollectionModel(req *coordinatorpb.CreateCollectionRequest)\n \t\tGetOrCreate:          req.GetGetOrCreate(),\n \t\tTenantID:             req.GetTenant(),\n \t\tDatabaseName:         req.GetDatabase(),\n+\t\tTs:                   time.Now().Unix(),\n \t}, nil\n }\n \n---\nrust/garbage_collector/src/operators/delete_versions_at_sysdb.rs\n@@ -38,6 +38,8 @@ pub struct DeleteVersionsAtSysDbOutput {\n \n #[derive(Error, Debug)]\n pub enum DeleteVersionsAtSysDbError {\n+    #[error(\"Unknown error occurred when deleting versions at sysdb\")]\n+    UnknownError,\n     #[error(\"Error deleting versions in sysdb: {0}\")]\n     SysDBError(String),\n     #[error(\"Error deleting version file {path}: {message}\")]\n@@ -157,7 +159,13 @@ impl Operator<DeleteVersionsAtSysDbInput, DeleteVersionsAtSysDbOutput>\n                 .delete_collection_version(vec![input.versions_to_delete.clone()])\n                 .await\n             {\n-                Ok(_) => {\n+                Ok(results) => {\n+                    for (_, was_successful) in results {\n+                        if !was_successful {\n+                            return Err(DeleteVersionsAtSysDbError::UnknownError);\n+                        }\n+                    }\n+\n                     tracing::info!(\n                         versions = ?input.versions_to_delete.versions,\n                         \"Successfully deleted versions from SysDB\"\n---\nrust/sysdb/src/sysdb.rs\n@@ -1331,14 +1331,14 @@ impl ChromaError for MarkVersionForDeletionError {\n \n #[derive(Error, Debug)]\n pub enum DeleteCollectionVersionError {\n-    #[error(\"Failed to delete version\")]\n+    #[error(\"Failed to delete version: {0}\")]\n     FailedToDeleteVersion(#[from] tonic::Status),\n }\n \n impl ChromaError for DeleteCollectionVersionError {\n     fn code(&self) -> ErrorCodes {\n         match self {\n-            DeleteCollectionVersionError::FailedToDeleteVersion(_) => ErrorCodes::Internal,\n+            DeleteCollectionVersionError::FailedToDeleteVersion(e) => e.code().into(),\n         }\n     }\n }\n---\n\n\n---\n\nChoice D:\ndocs/docs.trychroma.com/markdoc/content/integrations/frameworks/llamaindex.md\n@@ -6,5 +6,5 @@ name: LlamaIndex\n # LlamaIndex\n \n - `LlamaIndex` [Vector Store page](https://docs.llamaindex.ai/en/stable/examples/vector_stores/ChromaIndexDemo.html)\n-- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n-- [Chroma Loader on Llamahub](https://llamahub.ai/l/chroma)\n+- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n+- [Chroma Loader on Llamahub](https://llamahub.ai/l/vector_stores/llama-index-vector-stores-chroma)\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nDoes what the title says. Given a version file and a version, the operator constructs a complete list of files used by the collection version (including block files by traversing all sparse indices).\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\nTested in the next PR.\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\nrust/blockstore/src/arrow/provider.rs\n@@ -469,6 +469,15 @@ pub struct RootManager {\n     prefetched_roots: Arc<parking_lot::Mutex<HashMap<Uuid, Duration>>>,\n }\n \n+impl std::fmt::Debug for RootManager {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"RootManager\")\n+            .field(\"cache\", &self.cache)\n+            .field(\"storage\", &self.storage)\n+            .finish()\n+    }\n+}\n+\n impl RootManager {\n     pub fn new(storage: Storage, cache: Box<dyn PersistentCache<Uuid, RootReader>>) -> Self {\n         let cache: Arc<dyn PersistentCache<Uuid, RootReader>> = cache.into();\n---\nrust/garbage_collector/src/operators/list_files_at_version.rs\n@@ -0,0 +1,160 @@\n+use async_trait::async_trait;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n+use chroma_system::{Operator, OperatorType};\n+use chroma_types::{chroma_proto::CollectionVersionFile, CollectionUuid, HNSW_PATH};\n+use std::{collections::HashSet, str::FromStr};\n+use thiserror::Error;\n+use tokio::task::{JoinError, JoinSet};\n+use uuid::Uuid;\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionInput {\n+    root_manager: RootManager,\n+    version_file: CollectionVersionFile,\n+    version: i64,\n+}\n+\n+impl ListFilesAtVersionInput {\n+    pub fn new(\n+        root_manager: RootManager,\n+        version_file: CollectionVersionFile,\n+        version: i64,\n+    ) -> Self {\n+        Self {\n+            root_manager,\n+            version_file,\n+            version,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionOutput {\n+    pub collection_id: CollectionUuid,\n+    pub version: i64,\n+    pub file_paths: HashSet<String>,\n+}\n+\n+#[derive(Debug, Error)]\n+pub enum ListFilesAtVersionError {\n+    #[error(\"Version history field missing\")]\n+    VersionHistoryMissing,\n+    #[error(\"Version {0} not found\")]\n+    VersionNotFound(i64),\n+    #[error(\"Invalid UUID: {0}\")]\n+    InvalidUuid(uuid::Error),\n+    #[error(\"Sparse index fetch task failed: {0}\")]\n+    SparseIndexTaskFailed(JoinError),\n+    #[error(\"Error fetching block IDs for sparse index: {0}\")]\n+    FetchBlockIdsError(#[from] RootManagerError),\n+    #[error(\"Version file missing collection ID\")]\n+    VersionFileMissingCollectionId,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ListFilesAtVersionsOperator {}\n+\n+#[async_trait]\n+impl Operator<ListFilesAtVersionInput, ListFilesAtVersionOutput> for ListFilesAtVersionsOperator {\n+    type Error = ListFilesAtVersionError;\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n+\n+    async fn run(\n+        &self,\n+        input: &ListFilesAtVersionInput,\n+    ) -> Result<ListFilesAtVersionOutput, Self::Error> {\n+        let collection_id = CollectionUuid::from_str(\n+            &input\n+                .version_file\n+                .collection_info_immutable\n+                .as_ref()\n+                .ok_or_else(|| ListFilesAtVersionError::VersionFileMissingCollectionId)?\n+                .collection_id,\n+        )\n+        .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+        let version_history = input\n+            .version_file\n+            .version_history\n+            .as_ref()\n+            .ok_or_else(|| ListFilesAtVersionError::VersionHistoryMissing)?;\n+\n+        let mut file_paths = HashSet::new();\n+        let mut sparse_index_ids = HashSet::new();\n+\n+        let version = version_history\n+            .versions\n+            .iter()\n+            .find(|v| v.version == input.version)\n+            .ok_or_else(|| ListFilesAtVersionError::VersionNotFound(input.version))?;\n+\n+        tracing::debug!(\n+            \"Listing files at version {} for collection {}.\",\n+            version.version,\n+            collection_id,\n+        );\n+        tracing::trace!(\n+            \"Processing version {:#?} for collection {}\",\n+            version,\n+            collection_id\n+        );\n+\n+        if let Some(segment_info) = &version.segment_info {\n+            for segment in &segment_info.segment_compaction_info {\n+                for (file_type, segment_paths) in &segment.file_paths {\n+                    if file_type == \"hnsw_index\" || file_type == HNSW_PATH {\n+                        for path in &segment_paths.paths {\n+                            for hnsw_file in [\n+                                \"header.bin\",\n+                                \"data_level0.bin\",\n+                                \"length.bin\",\n+                                \"link_lists.bin\",\n+                            ] {\n+                                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                                file_paths.insert(format!(\"hnsw/{}/{}\", path, hnsw_file));\n+                            }\n+                        }\n+                    } else {\n+                        // Must be a sparse index\n+                        for path in &segment_paths.paths {\n+                            // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                            file_paths.insert(format!(\"sparse_index/{}\", path));\n+\n+                            let sparse_index_id = Uuid::parse_str(path)\n+                                .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+                            sparse_index_ids.insert(sparse_index_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut block_id_tasks = JoinSet::new();\n+        for sparse_index_id in sparse_index_ids {\n+            let root_manager = input.root_manager.clone();\n+            block_id_tasks\n+                .spawn(async move { root_manager.get_all_block_ids(&sparse_index_id).await });\n+        }\n+\n+        while let Some(res) = block_id_tasks.join_next().await {\n+            let block_ids = res\n+                .map_err(ListFilesAtVersionError::SparseIndexTaskFailed)?\n+                .map_err(ListFilesAtVersionError::FetchBlockIdsError)?;\n+\n+            for block_id in block_ids {\n+                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                file_paths.insert(format!(\"block/{}\", block_id));\n+            }\n+        }\n+\n+        Ok(ListFilesAtVersionOutput {\n+            collection_id,\n+            version: input.version,\n+            file_paths,\n+        })\n+    }\n+}\n---\nrust/garbage_collector/src/operators/mod.rs\n@@ -8,4 +8,5 @@ pub mod fetch_lineage_file;\n pub mod fetch_sparse_index_files;\n pub mod fetch_version_file;\n pub mod get_version_file_paths;\n+pub mod list_files_at_version;\n pub mod mark_versions_at_sysdb;\n---\n\n\n---\n\nChoice B:\nrust/segment/src/sqlite_metadata.rs\n@@ -482,8 +482,9 @@ impl IntoSqliteExpr for DocumentExpression {\n             EmbeddingFulltextSearch::StringValue,\n         ));\n         let doc_contains = doc_col\n+            .clone()\n             .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .is(true);\n+            .and(doc_col.is_not_null());\n         match self.operator {\n             DocumentOperator::Contains => doc_contains,\n             DocumentOperator::NotContains => doc_contains.not(),\n@@ -495,9 +496,11 @@ impl IntoSqliteExpr for DocumentExpression {\n \n impl IntoSqliteExpr for MetadataExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let key_cond = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key))\n+        let key_col = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key));\n+        let key_cond = key_col\n+            .clone()\n             .eq(self.key.to_string())\n-            .is(true);\n+            .and(key_col.is_not_null());\n         match &self.comparison {\n             MetadataComparison::Primitive(op, val) => {\n                 let (col, sval) = match val {\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/server.rs\n@@ -290,14 +290,23 @@ impl FrontendServer {\n         if let Some(cors_allow_origins) = cors_allow_origins {\n             let origins = cors_allow_origins\n                 .into_iter()\n-                .map(|origin| origin.parse().unwrap())\n+                .map(|origin| {\n+                    origin\n+                        .parse()\n+                        .unwrap_or_else(|_| panic!(\"Invalid origin: {}\", origin))\n+                })\n                 .collect::<Vec<_>>();\n \n-            let cors = CorsLayer::new()\n-                .allow_origin(origins)\n+            let mut cors_builder = CorsLayer::new()\n                 .allow_headers(tower_http::cors::Any)\n                 .allow_methods(tower_http::cors::Any);\n-            app = app.layer(cors);\n+            if origins.len() == 1 && origins[0] == \"*\" {\n+                cors_builder = cors_builder.allow_origin(tower_http::cors::Any);\n+            } else {\n+                cors_builder = cors_builder.allow_origin(origins);\n+            }\n+\n+            app = app.layer(cors_builder);\n         }\n \n         // TODO: tracing\n@@ -1972,6 +1981,54 @@ mod tests {\n         assert_eq!(allow_headers.unwrap(), \"*\");\n     }\n \n+    #[tokio::test]\n+    async fn test_cors_wildcard() {\n+        let registry = Registry::new();\n+        let system = System::new();\n+\n+        let port = random_port::PortPicker::new().pick().unwrap();\n+\n+        let mut config = FrontendServerConfig::single_node_default();\n+        config.port = port;\n+        config.cors_allow_origins = Some(vec![\"*\".to_string()]);\n+\n+        let frontend = Frontend::try_from_config(&(config.clone().frontend, system), &registry)\n+            .await\n+            .unwrap();\n+        let app = FrontendServer::new(\n+            config,\n+            frontend,\n+            vec![],\n+            Arc::new(()),\n+            Arc::new(()),\n+            System::new(),\n+        );\n+        tokio::task::spawn(async move {\n+            app.run().await;\n+        });\n+\n+        let client = reqwest::Client::new();\n+        let res = client\n+            .request(\n+                reqwest::Method::OPTIONS,\n+                format!(\"http://localhost:{}/api/v2/heartbeat\", port),\n+            )\n+            .header(\"Origin\", \"http://localhost:3000\")\n+            .send()\n+            .await\n+            .unwrap();\n+        assert_eq!(res.status(), 200);\n+\n+        let allow_origin = res.headers().get(\"Access-Control-Allow-Origin\");\n+        assert_eq!(allow_origin.unwrap(), \"*\");\n+\n+        let allow_methods = res.headers().get(\"Access-Control-Allow-Methods\");\n+        assert_eq!(allow_methods.unwrap(), \"*\");\n+\n+        let allow_headers = res.headers().get(\"Access-Control-Allow-Headers\");\n+        assert_eq!(allow_headers.unwrap(), \"*\");\n+    }\n+\n     #[tokio::test]\n     async fn test_defaults_to_json_content_type() {\n         let port = test_server().await;\n---\n\n\n---\n\nChoice D:\nCargo.lock\n@@ -1813,8 +1813,10 @@ dependencies = [\n  \"bytes\",\n  \"chroma-config\",\n  \"chroma-error\",\n+ \"chroma-tracing\",\n  \"futures\",\n  \"object_store\",\n+ \"opentelemetry\",\n  \"parking_lot\",\n  \"rand 0.8.5\",\n  \"rand_xorshift\",\n---\nrust/storage/Cargo.toml\n@@ -23,9 +23,11 @@ thiserror.workspace = true\n tokio = { workspace = true }\n tokio-util = { workspace = true }\n tracing = { workspace = true }\n+opentelemetry = { workspace = true }\n \n chroma-config = { workspace = true }\n chroma-error = { workspace = true }\n+chroma-tracing = { workspace = true }\n \n [dev-dependencies]\n rand_xorshift = { workspace = true }\n---\nrust/storage/src/admissioncontrolleds3.rs\n@@ -10,6 +10,7 @@ use bytes::Bytes;\n use chroma_config::registry::Registry;\n use chroma_config::Configurable;\n use chroma_error::ChromaError;\n+use chroma_tracing::util::Stopwatch;\n use futures::future::BoxFuture;\n use futures::{future::Shared, stream, FutureExt, StreamExt};\n use std::{\n@@ -524,9 +525,30 @@ impl RateLimitPolicy {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct CountBasedPolicyMetrics {\n+    // The delay in milliseconds before a request is allowed to proceed.\n+    pub nac_delay_ms: opentelemetry::metrics::Histogram<u64>,\n+}\n+\n+impl Default for CountBasedPolicyMetrics {\n+    fn default() -> Self {\n+        Self {\n+            nac_delay_ms: opentelemetry::global::meter(\"chroma.storage.admission_control\")\n+                .u64_histogram(\"nac_delay_ms\")\n+                .with_description(\n+                    \"The delay in milliseconds before a request is allowed to proceed.\",\n+                )\n+                .with_unit(\"ms\")\n+                .build(),\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct CountBasedPolicy {\n     remaining_tokens: Vec<Semaphore>,\n+    metrics: CountBasedPolicyMetrics,\n }\n \n impl CountBasedPolicy {\n@@ -537,14 +559,18 @@ impl CountBasedPolicy {\n                 (max_allowed_outstanding as f32 * allocation).ceil() as usize,\n             ));\n         }\n-        Self { remaining_tokens }\n+        Self {\n+            remaining_tokens,\n+            metrics: CountBasedPolicyMetrics::default(),\n+        }\n     }\n \n     async fn acquire(\n         &self,\n         priority: Arc<AtomicUsize>,\n         mut channel_receiver: Option<tokio::sync::mpsc::Receiver<()>>,\n     ) -> SemaphorePermit<'_> {\n+        let _stopwatch = Stopwatch::new(&self.metrics.nac_delay_ms, &[]);\n         loop {\n             let current_priority = priority.load(Ordering::SeqCst);\n             let current_priority: StorageRequestPriority = current_priority.into();\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nTo get ground truth on the dirty log, add a tool that can print it as it\ngets interpreted in the 'get all to compact' call.\n\n## Test plan\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/api/types.py\n@@ -687,9 +687,11 @@ def validate_metadata(metadata: Metadata) -> Metadata:\n                 f\"Expected metadata key to be a str, got {key} which is a {type(key).__name__}\"\n             )\n         # isinstance(True, int) evaluates to True, so we need to check for bools separately\n-        if not isinstance(value, bool) and not isinstance(value, (str, int, float)):\n+        if not isinstance(value, bool) and not isinstance(\n+            value, (str, int, float, type(None))\n+        ):\n             raise ValueError(\n-                f\"Expected metadata value to be a str, int, float or bool, got {value} which is a {type(value).__name__}\"\n+                f\"Expected metadata value to be a str, int, float, bool, or None, got {value} which is a {type(value).__name__}\"\n             )\n     return metadata\n \n---\nchromadb/base_types.py\n@@ -1,9 +1,9 @@\n-from typing import Dict, List, Mapping, Sequence, Union\n+from typing import Dict, List, Mapping, Optional, Sequence, Union\n from typing_extensions import Literal\n import numpy as np\n from numpy.typing import NDArray\n \n-Metadata = Mapping[str, Union[str, int, float, bool]]\n+Metadata = Mapping[str, Optional[Union[str, int, float, bool]]]\n UpdateMetadata = Mapping[str, Union[int, float, str, bool, None]]\n PyVector = Union[Sequence[float], Sequence[int]]\n Vector = NDArray[Union[np.int32, np.float32]]  # TODO: Specify that the vector is 1D\n---\n\n\n---\n\nChoice B:\ngo/pkg/log/server/server.go\n@@ -152,6 +152,12 @@ func (s *logServer) PurgeDirtyForCollection(ctx context.Context, req *logservice\n \treturn\n }\n \n+func (s *logServer) InspectDirtyLog(ctx context.Context, req *logservicepb.InspectDirtyLogRequest) (res *logservicepb.InspectDirtyLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n+\n+\n func NewLogServer(lr *repository.LogRepository) logservicepb.LogServiceServer {\n \treturn &logServer{\n \t\tlr: lr,\n---\nidl/chromadb/proto/logservice.proto\n@@ -87,6 +87,14 @@ message PurgeDirtyForCollectionResponse {\n   // Empty\n }\n \n+message InspectDirtyLogRequest {\n+  // Empty\n+}\n+\n+message InspectDirtyLogResponse {\n+  repeated string markers = 1;\n+}\n+\n service LogService {\n   rpc PushLogs(PushLogsRequest) returns (PushLogsResponse) {}\n   rpc ScoutLogs(ScoutLogsRequest) returns (ScoutLogsResponse) {}\n@@ -95,4 +103,5 @@ service LogService {\n   rpc GetAllCollectionInfoToCompact(GetAllCollectionInfoToCompactRequest) returns (GetAllCollectionInfoToCompactResponse) {}\n   rpc UpdateCollectionLogOffset(UpdateCollectionLogOffsetRequest) returns (UpdateCollectionLogOffsetResponse) {}\n   rpc PurgeDirtyForCollection(PurgeDirtyForCollectionRequest) returns (PurgeDirtyForCollectionResponse) {}\n+  rpc InspectDirtyLog(InspectDirtyLogRequest) returns (InspectDirtyLogResponse) {}\n }\n---\nrust/log-service/src/bin/chroma-inspect-dirty-log.rs\n@@ -0,0 +1,27 @@\n+use tonic::transport::Channel;\n+\n+use chroma_types::chroma_proto::log_service_client::LogServiceClient;\n+use chroma_types::chroma_proto::InspectDirtyLogRequest;\n+\n+#[tokio::main]\n+async fn main() {\n+    let args = std::env::args().skip(1).collect::<Vec<_>>();\n+    if args.len() != 1 {\n+        eprintln!(\"USAGE: chroma-inspect-dirty-log [HOST]\");\n+        std::process::exit(13);\n+    }\n+    let logservice = Channel::from_shared(args[0].clone())\n+        .expect(\"could not create channel\")\n+        .connect()\n+        .await\n+        .expect(\"could not connect to log service\");\n+    let mut client = LogServiceClient::new(logservice);\n+    let dirty = client\n+        .inspect_dirty_log(InspectDirtyLogRequest {})\n+        .await\n+        .expect(\"could not inspect dirty log\");\n+    let dirty = dirty.into_inner();\n+    for line in dirty.markers {\n+        println!(\"{line}\");\n+    }\n+}\n---\nrust/log-service/src/lib.rs\n@@ -13,10 +13,10 @@ use chroma_storage::config::StorageConfig;\n use chroma_storage::Storage;\n use chroma_types::chroma_proto::{\n     log_service_server::LogService, CollectionInfo, GetAllCollectionInfoToCompactRequest,\n-    GetAllCollectionInfoToCompactResponse, LogRecord, OperationRecord, PullLogsRequest,\n-    PullLogsResponse, PurgeDirtyForCollectionRequest, PurgeDirtyForCollectionResponse,\n-    PushLogsRequest, PushLogsResponse, ScoutLogsRequest, ScoutLogsResponse,\n-    UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n+    GetAllCollectionInfoToCompactResponse, InspectDirtyLogRequest, InspectDirtyLogResponse,\n+    LogRecord, OperationRecord, PullLogsRequest, PullLogsResponse, PurgeDirtyForCollectionRequest,\n+    PurgeDirtyForCollectionResponse, PushLogsRequest, PushLogsResponse, ScoutLogsRequest,\n+    ScoutLogsResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n };\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n@@ -1080,6 +1080,65 @@ impl LogService for LogServer {\n             .map_err(|err| Status::new(err.code().into(), err.to_string()))?;\n         Ok(Response::new(PurgeDirtyForCollectionResponse {}))\n     }\n+\n+    #[tracing::instrument(skip(self, _request))]\n+    async fn inspect_dirty_log(\n+        &self,\n+        _request: Request<InspectDirtyLogRequest>,\n+    ) -> Result<Response<InspectDirtyLogResponse>, Status> {\n+        let Some(reader) = self.dirty_log.reader(LogReaderOptions::default()) else {\n+            return Err(Status::unavailable(\"Failed to get dirty log reader\"));\n+        };\n+        let Some(cursors) = self.dirty_log.cursors(CursorStoreOptions::default()) else {\n+            return Err(Status::unavailable(\"Failed to get dirty log cursors\"));\n+        };\n+        let witness = match cursors.load(&STABLE_PREFIX).await {\n+            Ok(witness) => witness,\n+            Err(err) => {\n+                return Err(Status::new(err.code().into(), err.to_string()));\n+            }\n+        };\n+        let default = Cursor::default();\n+        let cursor = witness.as_ref().map(|w| w.cursor()).unwrap_or(&default);\n+        tracing::info!(\"cursoring from {cursor:?}\");\n+        let dirty_fragments = reader\n+            .scan(\n+                cursor.position,\n+                Limits {\n+                    max_files: Some(1_000_000),\n+                    max_bytes: Some(1_000_000_000),\n+                },\n+            )\n+            .await\n+            .map_err(|err| Status::new(err.code().into(), err.to_string()))?;\n+        let dirty_futures = dirty_fragments\n+            .iter()\n+            .map(|fragment| reader.read_parquet(fragment))\n+            .collect::<Vec<_>>();\n+        let dirty_raw = futures::future::try_join_all(dirty_futures)\n+            .await\n+            .map_err(|err| {\n+                Status::new(\n+                    err.code().into(),\n+                    format!(\"Failed to fetch dirty parquet: {}\", err),\n+                )\n+            })?;\n+        let mut markers = vec![];\n+        for (_, records, _) in dirty_raw {\n+            let records = records\n+                .into_iter()\n+                .map(|x| String::from_utf8(x.1))\n+                .collect::<Result<Vec<_>, _>>()\n+                .map_err(|err| {\n+                    Status::new(\n+                        chroma_error::ErrorCodes::DataLoss.into(),\n+                        format!(\"Failed to extract records: {}\", err),\n+                    )\n+                })?;\n+            markers.extend(records);\n+        }\n+        Ok(Response::new(InspectDirtyLogResponse { markers }))\n+    }\n }\n \n fn parquet_to_records(parquet: Arc<Vec<u8>>) -> Result<Vec<(LogPosition, Vec<u8>)>, Status> {\n---\n\n\n---\n\nChoice C:\nrust/worker/src/execution/orchestration/compact.rs\n@@ -794,10 +794,14 @@ impl Handler<TaskResult<FetchLogOutput, FetchLogError>> for CompactOrchestrator\n                 tracing::info!(\"Pulled Logs Up To Offset: {:?}\", self.pulled_log_offset);\n             }\n             None => {\n+                tracing::warn!(\"No logs were pulled from the log service, this can happen when the log compaction offset is behing the sysdb.\");\n+                // TODO(hammadb): We can repair the log service's understanding of the offset here, as this only happens\n+                // when the log service is not up to date on the latest compacted offset, which leads it to schedule an already\n+                // compacted collection.\n                 self.terminate_with_result(\n-                    Err(CompactionError::InvariantViolation(\n-                        \"Logs should be present for compaction\",\n-                    )),\n+                    Ok(CompactionResponse {\n+                        collection_id: self.collection_id,\n+                    }),\n                     ctx,\n                 )\n                 .await;\n---\n\n\n---\n\nChoice D:\n.github/workflows/_rust-tests.yml\n@@ -42,7 +42,9 @@ jobs:\n     strategy:\n       matrix:\n         platform: [blacksmith-16vcpu-ubuntu-2204]\n+        partition: [1, 2]\n     runs-on: ${{ matrix.platform }}\n+    name: Integration test ${{ matrix.partition }}/2\n     # OIDC token auth for AWS\n     permissions:\n       contents: read\n@@ -66,12 +68,12 @@ jobs:\n       - name: Build CLI\n         run: cargo build --bin chroma\n       - name: Run tests\n-        run: cargo nextest run --profile ci_k8s_integration\n+        run: cargo nextest run --profile ci_k8s_integration --partition hash:${{ matrix.partition }}/2\n       - name: Save service logs to artifact\n         if: always()\n         uses: ./.github/actions/export-tilt-logs\n         with:\n-          artifact-name: \"rust-integration-test\"\n+          artifact-name: \"rust-integration-test-${{ matrix.partition }}\"\n   test-benches:\n     strategy:\n       matrix:\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\nPreviously, sqlite ran both joins for fts and metadata. this PR adds support to conditionally join based on whether the table is being used or not. for composite queries it recursively iterates through child clauses to determine which ones have been used (metadata/fts or both) and joins accordingly. This also removes the IS TRUE check on metadata and documents, replacing them with a IS NOT NULL check. Using IS NULL causes the query to run a full scan rather than a search\r\nBefore:\r\n![image](https://github.com/user-attachments/assets/05ab49e5-2abb-43ae-a4a4-7a889dd11b9a)\r\nAfter:\r\n![image](https://github.com/user-attachments/assets/d87445c0-cf66-47ab-a44c-c17ae9a6b262)\r\n\r\n\r\nNotes: $gt still far underperforms\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -1484,6 +1484,7 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n         ALL_MINILM_L6_V2,\n         1_000_000,\n     )));\n+    data_sets.push(Arc::clone(&reference_data_set) as _);\n     data_sets.push(Arc::new(VerifyingDataSet {\n         reference_data_set,\n         test_data_set: \"test-all-MiniLM-L6-v2\".to_string(),\n---\n\n\n---\n\nChoice B:\nk8s/distributed-chroma/values.dev.yaml\n@@ -33,3 +33,6 @@ compactionService:\n       value: 'value: \"1\"'\n     - name: CONFIG_PATH\n       value: 'value: \"/tilt_config.yaml\"'\n+\n+rustLogService:\n+  replicaCount: 2\n---\n\n\n---\n\nChoice C:\nrust/segment/src/sqlite_metadata.rs\n@@ -482,8 +482,9 @@ impl IntoSqliteExpr for DocumentExpression {\n             EmbeddingFulltextSearch::StringValue,\n         ));\n         let doc_contains = doc_col\n+            .clone()\n             .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .is(true);\n+            .and(doc_col.is_not_null());\n         match self.operator {\n             DocumentOperator::Contains => doc_contains,\n             DocumentOperator::NotContains => doc_contains.not(),\n@@ -495,9 +496,11 @@ impl IntoSqliteExpr for DocumentExpression {\n \n impl IntoSqliteExpr for MetadataExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let key_cond = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key))\n+        let key_col = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key));\n+        let key_cond = key_col\n+            .clone()\n             .eq(self.key.to_string())\n-            .is(true);\n+            .and(key_col.is_not_null());\n         match &self.comparison {\n             MetadataComparison::Primitive(op, val) => {\n                 let (col, sval) = match val {\n@@ -668,21 +671,28 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            filter_limit_query\n-                .left_join(\n-                    EmbeddingMetadata::Table,\n-                    Expr::col((Embeddings::Table, Embeddings::Id))\n-                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n-                )\n-                .left_join(\n+            let (has_document_expr, has_metadata_expr) = match whr {\n+                Where::Composite(expr) => expr.has_document_and_metadata(),\n+                Where::Document(_) => (true, false),\n+                Where::Metadata(_) => (false, true),\n+            };\n+            if has_document_expr {\n+                filter_limit_query.left_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n-                )\n-                .distinct()\n-                .cond_where(whr.eval());\n+                );\n+            }\n+            if has_metadata_expr {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            };\n+            filter_limit_query.distinct().cond_where(whr.eval());\n         }\n \n         filter_limit_query\n---\nrust/types/src/metadata.rs\n@@ -560,6 +560,24 @@ impl Where {\n             },\n         }\n     }\n+\n+    // expression_check is a helper function to identify whether a given Where clause contains\n+    // a document or metadata predicate. It recursively checks the children of a composite expression.\n+    fn expression_check(&self, has_document_expr: &mut bool, has_metadata_expr: &mut bool) {\n+        match self {\n+            Where::Composite(composite) => {\n+                for child in composite.children.iter() {\n+                    child.expression_check(has_document_expr, has_metadata_expr);\n+\n+                    if *has_document_expr && *has_metadata_expr {\n+                        return;\n+                    }\n+                }\n+            }\n+            Where::Document(_) => *has_document_expr = true,\n+            Where::Metadata(_) => *has_metadata_expr = true,\n+        }\n+    }\n }\n \n impl TryFrom<chroma_proto::Where> for Where {\n@@ -611,6 +629,26 @@ pub struct CompositeExpression {\n     pub children: Vec<Where>,\n }\n \n+impl CompositeExpression {\n+    pub fn has_document_and_metadata(&self) -> (bool, bool) {\n+        let mut has_document_expr = false;\n+        let mut has_metadata_expr = false;\n+        self.expression_check(&mut has_document_expr, &mut has_metadata_expr);\n+        (has_document_expr, has_metadata_expr)\n+    }\n+\n+    // expression_check is an extension of the Where expression_check function, just for\n+    // CompositeExpression\n+    fn expression_check(&self, has_document_expr: &mut bool, has_metadata_expr: &mut bool) {\n+        for child in self.children.iter() {\n+            child.expression_check(has_document_expr, has_metadata_expr);\n+            if *has_document_expr && *has_metadata_expr {\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n impl TryFrom<chroma_proto::WhereChildren> for CompositeExpression {\n     type Error = WhereConversionError;\n \n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -339,11 +339,16 @@ impl RollupPerCollection {\n             std::cmp::max(self.initial_insertion_epoch_us, initial_insertion_epoch_us);\n     }\n \n-    fn witness_manifest_and_cursor(&mut self, manifest: &Manifest, witness: Option<&Witness>) {\n+    fn witness_cursor(&mut self, witness: Option<&Witness>) {\n+        // NOTE(rescrv):  There's an easy dance here to justify this as correct.  For the start log\n+        // position to advance, there must have been at least one GC cycle with a cursor that was\n+        // something other than 1.  That cursor should never get deleted, therefore we have a\n+        // witness and the unwrap_or call 0x90s.\n+        //\n+        // The consequence of this breaking is that the offset in the log will be behind sysdb.\n         self.start_log_position = witness\n             .map(|x| x.1.position)\n-            .unwrap_or(manifest.minimum_log_position());\n-        self.limit_log_position = manifest.maximum_log_position();\n+            .unwrap_or(LogPosition::from_offset(1));\n     }\n \n     fn is_empty(&self) -> bool {\n@@ -999,15 +1004,6 @@ impl LogServer {\n         &self,\n         rollups: &mut HashMap<CollectionUuid, RollupPerCollection>,\n     ) -> Result<(), Error> {\n-        let load_manifest = |storage, collection_id| async move {\n-            let reader = LogReader::new(\n-                LogReaderOptions::default(),\n-                Arc::clone(storage),\n-                storage_prefix_for_log(collection_id),\n-            );\n-            let span = tracing::info_span!(\"manifest load\", collection_id = ?collection_id);\n-            reader.manifest().instrument(span).await\n-        };\n         let load_cursor = |storage, collection_id| async move {\n             let cursor = &COMPACTION;\n             let cursor_store = CursorStore::new(\n@@ -1020,18 +1016,12 @@ impl LogServer {\n             cursor_store.load(cursor).instrument(span).await\n         };\n         for (collection_id, mut rollup) in std::mem::take(rollups) {\n-            // TODO(rescrv):  We can avoid loading the manifest and cursor by checking an\n-            // in-memory lookaside structure.\n-            let Some(manifest) = load_manifest(&self.storage, collection_id).await? else {\n-                tracing::warn!(\"{collection_id} has no manifest; this may mean it was deleted\");\n-                continue;\n-            };\n             let cursor = load_cursor(&self.storage, collection_id).await?;\n             // NOTE(rescrv):  There are two spreads that we have.\n             // `rollup` tracks the minimum and maximum offsets of a record on the dirty log.\n             // The spread between cursor (if it exists) and manifest.maximum_log_offset tracks the\n             // data that needs to be compacted.\n-            rollup.witness_manifest_and_cursor(&manifest, cursor.as_ref());\n+            rollup.witness_cursor(cursor.as_ref());\n             if !rollup.is_empty() {\n                 rollups.insert(collection_id, rollup);\n             }\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nRefactor web browser commands (open docs and discord) to their own module.\r\n\r\n## Test plan\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nN/A\n\n---\n\nChoice A:\nrust/cli/src/commands/mod.rs\n@@ -7,3 +7,4 @@ pub mod profile;\n pub mod run;\n pub mod update;\n pub mod vacuum;\n+pub mod webpage;\n---\nrust/cli/src/commands/webpage.rs\n@@ -0,0 +1,29 @@\n+use crate::utils::CliError;\n+use thiserror::Error;\n+\n+#[derive(Debug, Error)]\n+pub enum WebPageError {\n+    #[error(\"Failed to open browser. {0}\")]\n+    BrowserOpenFailed(String),\n+}\n+\n+pub enum WebPageCommand {\n+    Discord,\n+    Docs,\n+}\n+\n+impl WebPageCommand {\n+    fn url(&self) -> &'static str {\n+        match self {\n+            WebPageCommand::Discord => \"https://discord.gg/MMeYNTmh3x\",\n+            WebPageCommand::Docs => \"https://docs.trychroma.com\",\n+        }\n+    }\n+}\n+\n+pub fn open_browser(command: WebPageCommand) -> Result<(), CliError> {\n+    let url = command.url();\n+    let error_message = format!(\"Visit {}\", url);\n+    webbrowser::open(url).map_err(|_| WebPageError::BrowserOpenFailed(error_message))?;\n+    Ok(())\n+}\n---\nrust/cli/src/lib.rs\n@@ -13,10 +13,9 @@ use crate::commands::profile::{profile_command, ProfileCommand};\n use crate::commands::run::{run, RunArgs};\n use crate::commands::update::update;\n use crate::commands::vacuum::{vacuum, VacuumArgs};\n+use crate::commands::webpage::{open_browser, WebPageCommand};\n use clap::{Parser, Subcommand};\n use colored::Colorize;\n-use utils::CliError;\n-use utils::UtilsError;\n \n #[derive(Subcommand, Debug)]\n enum Command {\n@@ -44,12 +43,6 @@ struct Cli {\n     command: Command,\n }\n \n-fn open_browser(url: &str) -> Result<(), CliError> {\n-    let error_message = format!(\"Visit {}\", url);\n-    webbrowser::open(url).map_err(|_| UtilsError::BrowserOpenFailed(error_message))?;\n-    Ok(())\n-}\n-\n pub fn chroma_cli(args: Vec<String>) {\n     let cli = Cli::parse_from(args);\n \n@@ -59,18 +52,12 @@ pub fn chroma_cli(args: Vec<String>) {\n         Command::Browse(args) => browse(args),\n         Command::Copy(args) => copy(args),\n         Command::Db(db_subcommand) => db_command(db_subcommand),\n-        Command::Docs => {\n-            let url = \"https://docs.trychroma.com\";\n-            open_browser(url)\n-        }\n+        Command::Docs => open_browser(WebPageCommand::Docs),\n         Command::Install(args) => install(args),\n         Command::Login(args) => login(args),\n         Command::Profile(profile_subcommand) => profile_command(profile_subcommand),\n         Command::Run(args) => run(args),\n-        Command::Support => {\n-            let url = \"https://discord.gg/MMeYNTmh3x\";\n-            open_browser(url)\n-        }\n+        Command::Support => open_browser(WebPageCommand::Discord),\n         Command::Update => update(),\n         Command::Vacuum(args) => vacuum(args),\n     };\n---\nrust/cli/src/utils.rs\n@@ -11,6 +11,7 @@ use crate::commands::profile::ProfileError;\n use crate::commands::run::RunError;\n use crate::commands::update::UpdateError;\n use crate::commands::vacuum::VacuumError;\n+use crate::commands::webpage::WebPageError;\n use crate::ui_utils::Theme;\n use chroma_frontend::config::FrontendServerConfig;\n use chroma_frontend::frontend_service_entrypoint_with_config;\n@@ -64,6 +65,8 @@ pub enum CliError {\n     Copy(#[from] CopyError),\n     #[error(\"{0}\")]\n     Collection(#[from] CollectionAPIError),\n+    #[error(\"{0}\")]\n+    WebPage(#[from] WebPageError),\n }\n \n #[derive(Debug, Error)]\n@@ -90,8 +93,6 @@ pub enum UtilsError {\n     ConfigFileWriteFailed,\n     #[error(\"Failed to get user input\")]\n     UserInputFailed,\n-    #[error(\"Failed to open browser. {0}\")]\n-    BrowserOpenFailed(String),\n     #[error(\"Failed to copy to clipboard\")]\n     CopyToClipboardFailed,\n     #[error(\"Input validation failed\")]\n---\n\n\n---\n\nChoice B:\n.github/workflows/release-javascript-client.yml\n@@ -64,7 +64,7 @@ jobs:\n         cache: 'pnpm'\n         cache-dependency-path: 'clients/js/pnpm-lock.yaml'\n     - name: Install dependencies\n-      run: pnpm install --frozen-lockfile\n+      run: pnpm install --no-frozen-lockfile\n       working-directory: ./clients/js/\n     - name: Build packages\n       run: pnpm build\n---\n\n\n---\n\nChoice C:\n.github/workflows/_rust-tests.yml\n@@ -7,7 +7,7 @@ jobs:\n   test:\n     strategy:\n       matrix:\n-        platform: [blacksmith-4vcpu-ubuntu-2204]\n+        platform: [blacksmith-8vcpu-ubuntu-2204]\n     runs-on: ${{ matrix.platform }}\n     env:\n       CARGO_TERM_COLOR: always\n@@ -22,9 +22,9 @@ jobs:\n       - name: Build CLI\n         run: cargo build --bin chroma\n       - name: Test\n-        run: cargo nextest run --no-capture --profile ci\n+        run: cargo nextest run --profile ci\n   test-long:\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n+    runs-on: blacksmith-8vcpu-ubuntu-2204\n     env:\n       CARGO_TERM_COLOR: always\n       RUST_BACKTRACE: 1\n@@ -35,10 +35,8 @@ jobs:\n         uses: ./.github/actions/rust\n         with:\n           github-token: ${{ github.token }}\n-      - name: Build CLI\n-        run: cargo build --bin chroma\n       - name: Test\n-        run: cargo nextest run --no-capture --profile ci_long_running\n+        run: cargo nextest run --profile ci_long_running\n \n   test-integration:\n     strategy:\n---\n\n\n---\n\nChoice D:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.41\n+version: 0.1.42\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -35,4 +35,4 @@ compactionService:\n       value: 'value: \"/tilt_config.yaml\"'\n \n rustLogService:\n-  replicaCount: 2\n+  replicaCount: 1\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis PR cherry-picks the commit 4e8df93a0bd0aa6f9c2ecd4b0f86e5c3ff6a38ac onto rc/2025-05-02. If there are unresolved conflicts, please resolve them manually.\n\n---\n\nChoice A:\nCargo.lock\n@@ -4508,7 +4508,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34\"\n dependencies = [\n  \"cfg-if\",\n- \"windows-targets 0.48.5\",\n+ \"windows-targets 0.52.6\",\n ]\n \n [[package]]\n@@ -5147,16 +5147,17 @@ checksum = \"830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3\"\n \n [[package]]\n name = \"numpy\"\n-version = \"0.23.0\"\n+version = \"0.24.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b94caae805f998a07d33af06e6a3891e38556051b8045c615470a71590e13e78\"\n+checksum = \"a7cfbf3f0feededcaa4d289fe3079b03659e85c5b5a177f4ba6fb01ab4fb3e39\"\n dependencies = [\n  \"libc\",\n  \"ndarray\",\n  \"num-complex\",\n  \"num-integer\",\n  \"num-traits\",\n  \"pyo3\",\n+ \"pyo3-build-config\",\n  \"rustc-hash 2.0.0\",\n ]\n \n@@ -6035,9 +6036,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7778bffd85cf38175ac1f545509665d0b9b92a198ca7941f131f85f7a4f9a872\"\n+checksum = \"e5203598f366b11a02b13aa20cab591229ff0a89fd121a308a5df751d5fc9219\"\n dependencies = [\n  \"cfg-if\",\n  \"indoc\",\n@@ -6053,29 +6054,29 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-build-config\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94f6cbe86ef3bf18998d9df6e0f3fc1050a8c5efa409bf712e661a4366e010fb\"\n+checksum = \"99636d423fa2ca130fa5acde3059308006d46f98caac629418e53f7ebb1e9999\"\n dependencies = [\n  \"once_cell\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"pyo3-ffi\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e9f1b4c431c0bb1c8fb0a338709859eed0d030ff6daa34368d3b152a63dfdd8d\"\n+checksum = \"78f9cf92ba9c409279bc3305b5409d90db2d2c22392d443a87df3a1adad59e33\"\n dependencies = [\n  \"libc\",\n  \"pyo3-build-config\",\n ]\n \n [[package]]\n name = \"pyo3-macros\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbc2201328f63c4710f68abdf653c89d8dbc2858b88c5d88b0ff38a75288a9da\"\n+checksum = \"0b999cb1a6ce21f9a6b147dcf1be9ffedf02e0043aec74dc390f3007047cecd9\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"pyo3-macros-backend\",\n@@ -6085,9 +6086,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-macros-backend\"\n-version = \"0.23.5\"\n+version = \"0.24.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fca6726ad0f3da9c9de093d6f116a93c1a38e417ed73bf138472cf4064f72028\"\n+checksum = \"822ece1c7e1012745607d5cf0bcb2874769f0f7cb34c4cde03b9358eb9ef911a\"\n dependencies = [\n  \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n@@ -7308,7 +7309,7 @@ version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"03c3c6b7927ffe7ecaa769ee0e3994da3b8cafc8f444578982c83ecb161af917\"\n dependencies = [\n- \"heck 0.4.1\",\n+ \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n  \"syn 2.0.101\",\n@@ -7866,9 +7867,9 @@ checksum = \"55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.16\"\n+version = \"0.13.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61c41af27dd6d1e27b1b16b489db798443478cef1f06a660c96db617ba5de3b1\"\n+checksum = \"e502f78cdbb8ba4718f566c418c52bc729126ffd16baee5baa718cf25dd5a69a\"\n \n [[package]]\n name = \"tempfile\"\n---\nCargo.toml\n@@ -44,6 +44,7 @@ flatbuffers = \"24.3.25\"\n futures = \"0.3\"\n futures-core = \"0.3\"\n lazy_static = { version = \"1.4\" }\n+lexical-core = \"1.0\"\n num_cpus = \"1.16.0\"\n opentelemetry = { version = \"0.27.0\", default-features = false, features = [\"trace\", \"metrics\"] }\n opentelemetry-otlp = { version = \"0.27\", features = [\"http-proto\"] }\n@@ -78,7 +79,7 @@ utoipa = { version = \"5.0.0\", features = [\"macros\", \"axum_extras\", \"debug\", \"uui\n sqlx = { version = \"0.8.3\", features = [\"runtime-tokio\", \"sqlite\"] }\n sha2 = \"0.10.8\"\n md5 = \"0.7.0\"\n-pyo3 = { version = \"0.23.3\", features = [\"abi3-py39\"] }\n+pyo3 = { version = \"0.24.1\", features = [\"abi3-py39\"] }\n http = \"1.1.0\"\n tower-http = { version = \"0.6.2\", features = [\"trace\", \"cors\"] }\n bytemuck = \"1.21.0\"\n@@ -125,6 +126,7 @@ shuttle = \"0.7.1\"\n tempfile = \"3.14.0\"\n itertools = \"0.13.0\"\n serial_test = \"3.2.0\"\n+zip = \"2.3.0\"\n \n [profile.dev]\n # Significantly reduces compile times\n---\nrust/python_bindings/Cargo.toml\n@@ -13,7 +13,7 @@ async-trait = { workspace = true }\n pyo3 = { workspace = true }\n tokio = { workspace = true }\n uuid = { workspace = true }\n-numpy = \"0.23.0\"\n+numpy = \"0.24.0\"\n serde = { workspace = true }\n serde_json = { workspace = true }\n thiserror = { workspace = true }\n---\n\n\n---\n\nChoice B:\nchromadb/test/distributed/test_sanity.py\n@@ -67,6 +67,7 @@ def test_add_include_all_with_compaction_delay(client: ClientAPI) -> None:\n         name=\"test_add_include_all_with_compaction_delay\",\n         metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n     )\n+    initial_version = get_collection_version(client, collection.name)\n \n     ids = []\n     embeddings = []\n@@ -81,7 +82,7 @@ def test_add_include_all_with_compaction_delay(client: ClientAPI) -> None:\n             documents=[documents[-1]],\n         )\n \n-    wait_for_version_increase(client, collection.name, get_collection_version(client, collection.name), 120)\n+    wait_for_version_increase(client, collection.name, initial_version, 120)\n \n     random_query_1 = np.random.rand(1, 3)[0]\n     random_query_2 = np.random.rand(1, 3)[0]\n---\nchromadb/test/property/test_embeddings.py\n@@ -1420,11 +1420,12 @@ def test_0dim_embedding_validation() -> None:\n def test_no_op_compaction(client: ClientAPI) -> None:\n     reset(client)\n     coll = client.create_collection(name=\"noop\")\n+    initial_version = get_collection_version(client, coll.name)\n     for batch in range(0, 5000, 100):\n         coll.delete(ids=[str(i) for i in range(batch, batch + 100)])\n     if not NOT_CLUSTER_ONLY:\n         wait_for_version_increase(\n-            client, coll.name, get_collection_version(client, coll.name), VERSION_INCREASE_WAIT_TIME\n+            client, coll.name, initial_version, VERSION_INCREASE_WAIT_TIME\n         )\n \n \n@@ -1433,6 +1434,7 @@ def test_add_then_purge(client: ClientAPI) -> None:\n     record_count = 5000\n     batch_count = 100\n     coll = client.create_collection(name=\"add_then_purge\")\n+    witness_version = get_collection_version(client, coll.name)\n \n     # Add records and wait for compaction\n     for batch in range(0, record_count, batch_count):\n@@ -1443,17 +1445,18 @@ def test_add_then_purge(client: ClientAPI) -> None:\n         )\n     if not NOT_CLUSTER_ONLY:\n         wait_for_version_increase(\n-            client, coll.name, get_collection_version(client, coll.name), VERSION_INCREASE_WAIT_TIME\n+            client, coll.name, witness_version, VERSION_INCREASE_WAIT_TIME\n         )\n \n     # Purge records and wait for compaction\n+    witness_version = get_collection_version(client, coll.name)\n     for batch in range(0, record_count, batch_count):\n         record_id_vals = [i for i in range(batch, batch + batch_count)]\n         record_ids = [str(i) for i in record_id_vals]\n         coll.delete(ids=record_ids)\n     if not NOT_CLUSTER_ONLY:\n         wait_for_version_increase(\n-            client, coll.name, get_collection_version(client, coll.name), VERSION_INCREASE_WAIT_TIME\n+            client, coll.name, witness_version, VERSION_INCREASE_WAIT_TIME\n         )\n \n     # There should be no records left\n@@ -1464,6 +1467,7 @@ def test_encompassing_delete(client: ClientAPI) -> None:\n     reset(client)\n \n     col = client.create_collection(\"encompassing_delete\")\n+    initial_version = get_collection_version(client, col.name)\n \n     id_start = 0\n     # Add and then Delete 6 records\n@@ -1476,8 +1480,9 @@ def test_encompassing_delete(client: ClientAPI) -> None:\n \n     if not NOT_CLUSTER_ONLY:\n         wait_for_version_increase(\n-            client, col.name, get_collection_version(client, col.name), VERSION_INCREASE_WAIT_TIME\n+            client, col.name, initial_version, VERSION_INCREASE_WAIT_TIME\n         )\n+    initial_version = get_collection_version(client, col.name)\n \n     # Add and then delete and then add 16\n     len_to_add = 16\n@@ -1490,7 +1495,7 @@ def test_encompassing_delete(client: ClientAPI) -> None:\n \n     if not NOT_CLUSTER_ONLY:\n         wait_for_version_increase(\n-            client, col.name, get_collection_version(client, col.name), VERSION_INCREASE_WAIT_TIME\n+            client, col.name, initial_version, VERSION_INCREASE_WAIT_TIME\n         )\n \n     # Ensure we can get all\n---\n\n\n---\n\nChoice C:\n.github/workflows/_python-tests.yml\n@@ -291,7 +291,7 @@ jobs:\n         api_key: ${{ secrets.DD_API_KEY }}\n         site: ${{ vars.DD_SITE }}\n     - name: Integration Test\n-      run: bin/python-integration-test ${{ matrix.test-globs }}\n+      run: python -m pytest ${{ matrix.test-globs }}\n       shell: bash\n       env:\n         ENV_FILE: ${{ matrix.env-file }}\n---\nchromadb/test/test_cli.py\n@@ -1,6 +1,5 @@\n import multiprocessing\n import multiprocessing.context\n-import os\n import sys\n import time\n from multiprocessing.synchronize import Event\n@@ -10,7 +9,6 @@\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,6 +17,36 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+        host: str, port: int,\n+    max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            client = chromadb.HttpClient(host=host, port=port)\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            print(\"Heartbeat failed, trying again...\")\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n@@ -32,14 +60,10 @@ def test_app() -> None:\n     server_process.start()\n     time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    assert wait_for_server(host=\"localhost\", port=8001), \"Server failed to start within maximum retry attempts\"\n \n-    client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -124,7 +148,7 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\", \"--timeout\", \"10\"]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\nrust/cli/src/commands/vacuum.rs\n@@ -20,8 +20,10 @@ use sqlx::Row;\n use std::error::Error;\n use std::path::Path;\n use std::str::FromStr;\n+use std::time::Duration;\n use std::{fs, io};\n use thiserror::Error;\n+use tokio::time::timeout;\n \n #[derive(Debug, Error)]\n pub enum VacuumError {\n@@ -43,6 +45,8 @@ pub struct VacuumArgs {\n     path: Option<String>,\n     #[clap(long, default_value_t = false, help = \"Skip vacuum confirmation\")]\n     force: bool,\n+    #[clap(long, help = \"Maximum time (in seconds) to wait for vacuum\")]\n+    timeout: Option<u64>,\n }\n \n fn sizeof_fmt(num: u64, suffix: Option<&str>) -> String {\n@@ -195,10 +199,6 @@ pub async fn vacuum_chroma(config: FrontendConfig) -> Result<(), Box<dyn Error>>\n \n     println!(\"Vacuuming (this may take a while)...\\n\");\n \n-    sqlx::query(&format!(\"PRAGMA busy_timeout = {}\", 5000))\n-        .execute(sqlite.get_conn())\n-        .await?;\n-\n     sqlx::query(\"VACUUM\").execute(sqlite.get_conn()).await?;\n \n     sqlx::query(\n@@ -264,9 +264,19 @@ pub fn vacuum(args: VacuumArgs) -> Result<(), CliError> {\n     };\n \n     let runtime = tokio::runtime::Runtime::new().expect(\"Failed to start Chroma\");\n-    runtime\n-        .block_on(vacuum_chroma(config.frontend))\n-        .map_err(|_| VacuumError::VacuumFailed)?;\n+\n+    let res = if let Some(secs) = args.timeout {\n+        runtime.block_on(async {\n+            timeout(Duration::from_secs(secs), vacuum_chroma(config.frontend))\n+                .await\n+                .unwrap_or_else(|_elapsed| {\n+                    Err(Box::new(VacuumError::VacuumFailed) as Box<dyn std::error::Error>)\n+                })\n+        })\n+    } else {\n+        runtime.block_on(vacuum_chroma(config.frontend))\n+    };\n+    res.map_err(|_| VacuumError::VacuumFailed)?;\n \n     let post_vacuum_size =\n         get_dir_size(Path::new(&persistent_path)).map_err(|_| VacuumError::DirSizeFailed)?;\n---\n\n\n---\n\nChoice D:\n.github/workflows/_python-tests.yml\n@@ -291,7 +291,7 @@ jobs:\n         api_key: ${{ secrets.DD_API_KEY }}\n         site: ${{ vars.DD_SITE }}\n     - name: Integration Test\n-      run: bin/python-integration-test ${{ matrix.test-globs }}\n+      run: python -m pytest ${{ matrix.test-globs }}\n       shell: bash\n       env:\n         ENV_FILE: ${{ matrix.env-file }}\n---\nchromadb/test/test_cli.py\n@@ -1,6 +1,5 @@\n import multiprocessing\n import multiprocessing.context\n-import os\n import sys\n import time\n from multiprocessing.synchronize import Event\n@@ -10,7 +9,6 @@\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,6 +17,36 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+        host: str, port: int,\n+    max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            client = chromadb.HttpClient(host=host, port=port)\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            print(\"Heartbeat failed, trying again...\")\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n@@ -32,14 +60,10 @@ def test_app() -> None:\n     server_process.start()\n     time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    assert wait_for_server(host=\"localhost\", port=8001), \"Server failed to start within maximum retry attempts\"\n \n-    client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -124,7 +148,7 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\", \"--timeout\", \"10\"]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\nrust/cli/src/commands/vacuum.rs\n@@ -20,8 +20,10 @@ use sqlx::Row;\n use std::error::Error;\n use std::path::Path;\n use std::str::FromStr;\n+use std::time::Duration;\n use std::{fs, io};\n use thiserror::Error;\n+use tokio::time::timeout;\n \n #[derive(Debug, Error)]\n pub enum VacuumError {\n@@ -43,6 +45,8 @@ pub struct VacuumArgs {\n     path: Option<String>,\n     #[clap(long, default_value_t = false, help = \"Skip vacuum confirmation\")]\n     force: bool,\n+    #[clap(long, help = \"Maximum time (in seconds) to wait for vacuum\")]\n+    timeout: Option<u64>,\n }\n \n fn sizeof_fmt(num: u64, suffix: Option<&str>) -> String {\n@@ -195,10 +199,6 @@ pub async fn vacuum_chroma(config: FrontendConfig) -> Result<(), Box<dyn Error>>\n \n     println!(\"Vacuuming (this may take a while)...\\n\");\n \n-    sqlx::query(&format!(\"PRAGMA busy_timeout = {}\", 5000))\n-        .execute(sqlite.get_conn())\n-        .await?;\n-\n     sqlx::query(\"VACUUM\").execute(sqlite.get_conn()).await?;\n \n     sqlx::query(\n@@ -264,9 +264,19 @@ pub fn vacuum(args: VacuumArgs) -> Result<(), CliError> {\n     };\n \n     let runtime = tokio::runtime::Runtime::new().expect(\"Failed to start Chroma\");\n-    runtime\n-        .block_on(vacuum_chroma(config.frontend))\n-        .map_err(|_| VacuumError::VacuumFailed)?;\n+\n+    let res = if let Some(secs) = args.timeout {\n+        runtime.block_on(async {\n+            timeout(Duration::from_secs(secs), vacuum_chroma(config.frontend))\n+                .await\n+                .unwrap_or_else(|_elapsed| {\n+                    Err(Box::new(VacuumError::VacuumFailed) as Box<dyn std::error::Error>)\n+                })\n+        })\n+    } else {\n+        runtime.block_on(vacuum_chroma(config.frontend))\n+    };\n+    res.map_err(|_| VacuumError::VacuumFailed)?;\n \n     let post_vacuum_size =\n         get_dir_size(Path::new(&persistent_path)).map_err(|_| VacuumError::DirSizeFailed)?;\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nSpeed up python CLI wrapper tests:\r\n* Run tests directly instead of setting up the integration test environment.\r\n* Previously, vacuum set its own timeout for SQLite connections, however now we have a default timeout of 1000 seconds (~17 minutes) on all connections. The last test in `test_cli` checks that we abort long standing vacuum operations (when the DB file is locked). To work around the 1000 timeout, added a `timeout` argument to the CLI command to override the default long timeout. The DB set up by the test would have been vacuumed in a matter of seconds.\r\n\r\n## Test plan\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nN/A\r\n\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -1104,6 +1104,7 @@ impl LogServer {\n                     manifest.maximum_log_position(),\n                 ),\n                 Ok(None) | Err(wal3::Error::UninitializedLog) => {\n+                    tracing::info!(\"Log is uninitialized on rust log service. Forwarding ScoutLog request to legacy log service\");\n                     return self.forward_scout_logs(Request::new(scout_logs)).await;\n                 }\n                 Err(err) => {\n@@ -1113,6 +1114,13 @@ impl LogServer {\n                     ));\n                 }\n             };\n+\n+            // NOTE(sicheng): This is temporary trace added for analyzing number of frags between the offsets\n+            match log_reader.scan(start_position, Default::default()).await {\n+                Ok(frags) => tracing::info!(name: \"Counting live fragments\", frag_count = frags.len()),\n+                Err(e) => tracing::error!(name: \"Unable to scout number of live fragments\", error = e.to_string()),\n+            }\n+\n             let start_offset = start_position.offset() as i64;\n             let limit_offset = limit_position.offset() as i64;\n             Ok(Response::new(ScoutLogsResponse {\n---\n\n\n---\n\nChoice B:\n.github/workflows/_python-tests.yml\n@@ -291,7 +291,7 @@ jobs:\n         api_key: ${{ secrets.DD_API_KEY }}\n         site: ${{ vars.DD_SITE }}\n     - name: Integration Test\n-      run: bin/python-integration-test ${{ matrix.test-globs }}\n+      run: python -m pytest ${{ matrix.test-globs }}\n       shell: bash\n       env:\n         ENV_FILE: ${{ matrix.env-file }}\n---\nchromadb/test/test_cli.py\n@@ -1,6 +1,5 @@\n import multiprocessing\n import multiprocessing.context\n-import os\n import sys\n import time\n from multiprocessing.synchronize import Event\n@@ -10,7 +9,6 @@\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,6 +17,36 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+        host: str, port: int,\n+    max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            client = chromadb.HttpClient(host=host, port=port)\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            print(\"Heartbeat failed, trying again...\")\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n@@ -32,14 +60,10 @@ def test_app() -> None:\n     server_process.start()\n     time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    assert wait_for_server(host=\"localhost\", port=8001), \"Server failed to start within maximum retry attempts\"\n \n-    client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -124,7 +148,7 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\", \"--timeout\", \"10\"]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\nrust/cli/src/commands/vacuum.rs\n@@ -20,8 +20,10 @@ use sqlx::Row;\n use std::error::Error;\n use std::path::Path;\n use std::str::FromStr;\n+use std::time::Duration;\n use std::{fs, io};\n use thiserror::Error;\n+use tokio::time::timeout;\n \n #[derive(Debug, Error)]\n pub enum VacuumError {\n@@ -43,6 +45,8 @@ pub struct VacuumArgs {\n     path: Option<String>,\n     #[clap(long, default_value_t = false, help = \"Skip vacuum confirmation\")]\n     force: bool,\n+    #[clap(long, help = \"Maximum time (in seconds) to wait for vacuum\")]\n+    timeout: Option<u64>,\n }\n \n fn sizeof_fmt(num: u64, suffix: Option<&str>) -> String {\n@@ -195,10 +199,6 @@ pub async fn vacuum_chroma(config: FrontendConfig) -> Result<(), Box<dyn Error>>\n \n     println!(\"Vacuuming (this may take a while)...\\n\");\n \n-    sqlx::query(&format!(\"PRAGMA busy_timeout = {}\", 5000))\n-        .execute(sqlite.get_conn())\n-        .await?;\n-\n     sqlx::query(\"VACUUM\").execute(sqlite.get_conn()).await?;\n \n     sqlx::query(\n@@ -264,9 +264,19 @@ pub fn vacuum(args: VacuumArgs) -> Result<(), CliError> {\n     };\n \n     let runtime = tokio::runtime::Runtime::new().expect(\"Failed to start Chroma\");\n-    runtime\n-        .block_on(vacuum_chroma(config.frontend))\n-        .map_err(|_| VacuumError::VacuumFailed)?;\n+\n+    let res = if let Some(secs) = args.timeout {\n+        runtime.block_on(async {\n+            timeout(Duration::from_secs(secs), vacuum_chroma(config.frontend))\n+                .await\n+                .unwrap_or_else(|_elapsed| {\n+                    Err(Box::new(VacuumError::VacuumFailed) as Box<dyn std::error::Error>)\n+                })\n+        })\n+    } else {\n+        runtime.block_on(vacuum_chroma(config.frontend))\n+    };\n+    res.map_err(|_| VacuumError::VacuumFailed)?;\n \n     let post_vacuum_size =\n         get_dir_size(Path::new(&persistent_path)).map_err(|_| VacuumError::DirSizeFailed)?;\n---\n\n\n---\n\nChoice C:\nrust/wal3/src/manifest.rs\n@@ -599,7 +599,10 @@ impl Manifest {\n         let path = manifest_path(prefix);\n         loop {\n             match storage\n-                .get_with_e_tag(&path, GetOptions::new(StorageRequestPriority::P0))\n+                .get_with_e_tag(\n+                    &path,\n+                    GetOptions::new(StorageRequestPriority::P0).with_strong_consistency(),\n+                )\n                 .await\n                 .map_err(Arc::new)\n             {\n---\n\n\n---\n\nChoice D:\nrust/load/src/data_sets.rs\n@@ -1484,6 +1484,7 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n         ALL_MINILM_L6_V2,\n         1_000_000,\n     )));\n+    data_sets.push(Arc::clone(&reference_data_set) as _);\n     data_sets.push(Arc::new(VerifyingDataSet {\n         reference_data_set,\n         test_data_set: \"test-all-MiniLM-L6-v2\".to_string(),\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - ...\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nk8s/test/load-service.yaml\n@@ -1,25 +1,16 @@\n----\n-\n-apiVersion: v1\n-kind: Namespace\n-metadata:\n-  name: chroma-load\n-\n----\n-\n apiVersion: apps/v1\n kind: Deployment\n metadata:\n   name: load-service\n-  namespace: chroma-load\n+  namespace: chroma\n spec:\n   replicas: 1\n   selector:\n     matchLabels:\n       app: load-service\n   template:\n     metadata:\n-      namespace: chroma-load\n+      namespace: chroma\n       labels:\n         app: load-service\n     spec:\n@@ -55,7 +46,7 @@ apiVersion: v1\n kind: ConfigMap\n metadata:\n   name: load-service-config\n-  namespace: chroma-load\n+  namespace: chroma\n data:\n   config.yaml: |\n     load_service:\n@@ -70,7 +61,7 @@ apiVersion: v1\n kind: Service\n metadata:\n   name: load-service\n-  namespace: chroma-load\n+  namespace: chroma\n spec:\n   ports:\n     - name: http\n---\n\n\n---\n\nChoice B:\nchromadb/test/test_cli.py\n@@ -7,10 +7,10 @@\n \n import chromadb\n from chromadb.api.client import Client\n+from chromadb.api.client import ClientAPI\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,27 +19,59 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+    client: ClientAPI, max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n \n+\n def test_app() -> None:\n     kwargs = {\"path\": \"chroma_test_data\", \"port\": 8001}\n     args = [\"chroma\", \"run\"]\n     args.extend(build_cli_args(**kwargs))\n     print(args)\n     server_process = multiprocessing.Process(target=start_app, args=(args,))\n     server_process.start()\n-    time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    host = kwargs.get(\"host\", \"localhost\")\n+    port = int(kwargs.get(\"port\", 8001))\n \n     client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n+    assert wait_for_server(\n+        client\n+    ), \"Server failed to start within maximum retry attempts\"\n+\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -72,7 +104,13 @@ def add_records(collection: Collection, num: int) -> None:\n         cur.execute(sql, params)\n         assert cur.fetchall() == []\n \n-    sys.argv = [\"chroma\", \"vacuum\", \"--path\", system.settings.persist_directory, \"--force\"]\n+    sys.argv = [\n+        \"chroma\",\n+        \"vacuum\",\n+        \"--path\",\n+        system.settings.persist_directory,\n+        \"--force\",\n+    ]\n     cli.app()\n \n     # Maintenance log should have a vacuum entry\n@@ -124,7 +162,13 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\n+            \"chroma\",\n+            \"vacuum\",\n+            \"--path\",\n+            sqlite_persistent.settings.persist_directory,\n+            \"--force\",\n+        ]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\n\n\n---\n\nChoice C:\ndocs/docs.trychroma.com/components/header/header-nav.tsx\n@@ -1,17 +1,8 @@\n 'use client'\n \n import React from \"react\";\n-import Logo from \"@/components/header/logo\";\n-import ThemeToggle from \"@/components/header/theme-toggle\";\n-import GithubLink from \"@/components/header/github-link\";\n-import XLink from \"@/components/header/x-link\";\n-import DiscordLink from \"@/components/header/discord-link\";\n-import Link from \"next/link\";\n-import SearchBox from \"@/components/header/search-box\";\n-import UpdatesLink from \"@/components/header/updates-link\";\n import sidebarConfig from \"@/markdoc/content/sidebar-config\";\n import MenuItem from \"../sidebar/menu-item\";\n-import { useRouter } from \"next/router\";\n import { useParams } from \"next/navigation\";\n \n const HeaderNav: React.FC = () => {\n@@ -22,7 +13,7 @@ const HeaderNav: React.FC = () => {\n   );\n \n   return (\n-    <div className=\"flex items-center flex-shrink-0 px-5 border-b-[1px] dark:border-gray-700 \">\n+    <div className=\"flex items-center flex-shrink-0 px-5 border-b-[1px] dark:border-gray-700 w-full overflow-x-auto\">\n       {sidebarConfig.map((section) => (\n       <MenuItem\n       key={section.id}\n---\ndocs/docs.trychroma.com/components/markdoc/table.tsx\n@@ -13,7 +13,7 @@ export const Table = React.forwardRef<\n   React.HTMLAttributes<HTMLTableElement>\n >(({ ...props }, ref) => {\n   return (\n-    <div className=\"relative w-full overflow-auto rounded-md my-5 border-[0.5px] border-gray-300\">\n+    <div className=\"relative w-full overflow-auto rounded-md my-5 border-[0.5px] border-gray-300 dark:border-gray-700\">\n       <UITable ref={ref} className=\"m-0\" {...props} />\n     </div>\n   );\n---\ndocs/docs.trychroma.com/components/sidebar/menu-item.tsx\n@@ -10,7 +10,7 @@ const MenuItem: React.FC<{ section: AppSection; active: boolean }> = ({\n \n   return (\n     <Link\n-     className={`border-b-4 h-12 px-3 pt-3 pr-5 text-gray-700/80 ${active ? \"border-chroma-orange \" : \"border-transparent hover:border-gray-100\"} ${!section.disable && \"hover:text-gray-800\"} dark:text-gray-400/80 dark:hover:text-gray-300`}\n+     className={`border-b-4 h-12 px-3 pt-3 pr-5 text-gray-700/80 ${active ? \"border-chroma-orange \" : \"border-transparent hover:border-gray-100 dark:hover:border-gray-300\"} ${!section.disable && \"hover:text-gray-800\"} dark:text-gray-400/80 dark:hover:text-gray-300 text-nowrap`}\n       href={\n         section.disable\n           ? \"\"\n---\ndocs/docs.trychroma.com/components/ui/table.tsx\n@@ -58,7 +58,7 @@ const TableRow = React.forwardRef<\n   <tr\n     ref={ref}\n     className={cn(\n-      \"border-b transition-colors data-[state=selected]:bg-zinc-100 dark:data-[state=selected]:bg-zinc-800\",\n+      \"border-b transition-colors data-[state=selected]:bg-zinc-100 dark:data-[state=selected]:bg-zinc-800 dark:border-gray-700\",\n       className,\n     )}\n     {...props}\n---\n\n\n---\n\nChoice D:\nrust/load/src/bin/chroma-load-start.rs\n@@ -24,8 +24,6 @@ struct Args {\n     #[arg(long)]\n     database: String,\n     #[arg(long)]\n-    api_key: String,\n-    #[arg(long)]\n     constant_throughput: Option<f64>,\n     #[arg(long)]\n     sinusoid_throughput: Option<String>,\n@@ -90,6 +88,10 @@ impl Args {\n #[tokio::main]\n async fn main() {\n     let args = Args::parse();\n+\n+    // Read API key from environment variable.\n+    let api_key = std::env::var(\"CHROMA_API_KEY\").expect(\"CHROMA_API_KEY is not set\");\n+\n     let client = reqwest::Client::new();\n     let throughput = args.throughput();\n     let mut workload = Workload::ByName(args.workload);\n@@ -108,7 +110,7 @@ async fn main() {\n         data_set: args.data_set,\n         connection: Connection {\n             url: args.url,\n-            api_key: args.api_key,\n+            api_key,\n             database: args.database,\n         },\n         throughput,\n---\nrust/load/src/lib.rs\n@@ -1026,8 +1026,16 @@ pub struct LoadHarness {\n \n impl LoadHarness {\n     /// The status of the load harness.\n+    /// This returns the list of running workloads with secrets redacted.\n     pub fn status(&self) -> Vec<RunningWorkload> {\n-        self.running.clone()\n+        self.running\n+            .iter()\n+            .map(|w| {\n+                let mut w = w.clone();\n+                w.connection.api_key = \"REDACTED\".to_string();\n+                w\n+            })\n+            .collect()\n     }\n \n     /// Start a workload on the load harness.\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nThis PR cherry-picks the commit dd6d1768237e9be8b1d0916657a8008e5530a05d onto rc/2025-05-02. If there are unresolved conflicts, please resolve them manually.\n\n---\n\nChoice A:\nrust/cache/src/foyer.rs\n@@ -94,8 +94,17 @@ const fn default_trace_fetch_us() -> usize {\n     1000 * 100\n }\n \n+fn default_name() -> String {\n+    String::from(\"foyer\")\n+}\n+\n #[derive(Deserialize, Debug, Clone, Serialize, Parser)]\n pub struct FoyerCacheConfig {\n+    /// Name of the cache. All metrics for the cache are prefixed with name_.\n+    #[arg(long, default_value = \"foyer\")]\n+    #[serde(default = \"default_name\")]\n+    pub name: String,\n+\n     /// Directory for disk cache data.\n     #[arg(short, long)]\n     pub dir: Option<String>,\n@@ -262,6 +271,7 @@ impl FoyerCacheConfig {\n impl Default for FoyerCacheConfig {\n     fn default() -> Self {\n         FoyerCacheConfig {\n+            name: default_name(),\n             dir: None,\n             capacity: default_capacity(),\n             mem: default_mem(),\n@@ -352,6 +362,7 @@ where\n             ),\n         );\n         let builder = HybridCacheBuilder::<K, V>::new()\n+            .with_name(config.name.clone())\n             .with_metrics_registry(otel_0_27_metrics)\n             .with_tracing_options(tracing_options.clone())\n             .with_policy(foyer::HybridCachePolicy::WriteOnInsertion)\n@@ -537,6 +548,7 @@ where\n         config: &FoyerCacheConfig,\n     ) -> Result<FoyerPlainCache<K, V>, Box<dyn ChromaError>> {\n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .build();\n@@ -590,6 +602,7 @@ where\n         let evl = TokioEventListener(tx);\n \n         let cache = CacheBuilder::new(config.capacity)\n+            .with_name(config.name.clone())\n             .with_shards(config.shards)\n             .with_weighter(|_: &_, v: &V| v.weight())\n             .with_event_listener(Arc::new(evl))\n---\nrust/frontend/sample_configs/distributed.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -12,6 +12,7 @@ sysdb:\n collections_with_segments_provider:\n   cache:\n     lru:\n+      name: \"collections_with_segments_cache\"\n       capacity: 1000\n   cache_ttl_secs: 60\n   permitted_parallelism: 180\n---\nrust/worker/chroma_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     disk:\n+                        name: \"block_cache\"\n                         dir: \"/cache/chroma/query-service/block-cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n@@ -72,11 +73,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n \n@@ -138,15 +141,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\nrust/worker/tilt_config.yaml\n@@ -56,6 +56,7 @@ query_service:\n                 block_cache_config:\n                     disk:\n                         dir: \"/cache/chroma/query-service/block-cache\"\n+                        name: \"block_cache\"\n                         # 1k blocks * 8MiB = 8GiB, this is actually ignored in the disk cache config. Leaving it set to 1k for consistency.\n                         capacity: 1000\n                         mem: 8000 # 8GiB\n@@ -71,11 +72,13 @@ query_service:\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8589934592 # 8GB\n         permitted_parallelism: 180\n     fetch_log_batch_size: 1000\n@@ -141,15 +144,18 @@ compaction_service:\n                 max_block_size_bytes: 8388608 # 8MB\n                 block_cache_config:\n                     lru:\n+                        name: \"block_cache\"\n                         capacity: 1000\n             sparse_index_manager_config:\n                 sparse_index_cache_config:\n                     lru:\n+                        name: \"sparse_index_cache\"\n                         capacity: 1000\n     hnsw_provider:\n         hnsw_temporary_path: \"~/tmp\"\n         hnsw_cache_config:\n             weighted_lru:\n+                name: \"hnsw_cache\"\n                 capacity: 8192 # 8192 MiB = 8GB\n         permitted_parallelism: 180\n     spann_provider:\n---\n\n\n---\n\nChoice B:\nTiltfile\n@@ -81,22 +81,6 @@ else:\n     target='sysdb-migration'\n   )\n \n-\n-if config.tilt_subcommand == \"ci\":\n-  custom_build(\n-    'frontend-service',\n-    'docker buildx build --load -t $EXPECTED_REF -f ./Dockerfile . ',\n-    ['chromadb/', 'idl/', 'requirements.txt', 'bin/']\n-  )\n-else:\n-  docker_build(\n-    'frontend-service',\n-    '.',\n-    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/'],\n-    dockerfile='./Dockerfile',\n-    ignore=['**/*.pyc', 'chromadb/test/'],\n-  )\n-\n if config.tilt_subcommand == \"ci\":\n   custom_build(\n     'rust-frontend-service',\n@@ -239,7 +223,6 @@ k8s_resource('logservice-migration-latest', resource_deps=['postgres'], labels=[\n k8s_resource('logservice', resource_deps=['sysdb-migration-latest'], labels=[\"chroma\"], port_forwards='50052:50051')\n k8s_resource('rust-log-service', labels=[\"chroma\"], port_forwards='50054:50051')\n k8s_resource('sysdb', resource_deps=['sysdb-migration-latest'], labels=[\"chroma\"], port_forwards='50051:50051')\n-k8s_resource('frontend-service', resource_deps=['sysdb', 'logservice'],labels=[\"chroma\"], port_forwards='8000:8000')\n k8s_resource('rust-frontend-service', resource_deps=['sysdb', 'logservice', 'rust-log-service'], labels=[\"chroma\"], port_forwards='3000:8000')\n k8s_resource('query-service', resource_deps=['sysdb'], labels=[\"chroma\"], port_forwards='50053:50051')\n k8s_resource('compaction-service', resource_deps=['sysdb'], labels=[\"chroma\"])\n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.36\n+version: 0.1.37\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/frontend-service.yaml\n@@ -1,92 +0,0 @@\n-apiVersion: apps/v1\n-kind: Deployment\n-metadata:\n-  name: frontend-service\n-  namespace: {{ .Values.namespace }}\n-spec:\n-  replicas: {{ .Values.frontendService.replicaCount }}\n-  selector:\n-    matchLabels:\n-      app: frontend-service\n-  template:\n-    metadata:\n-      labels:\n-        app: frontend-service\n-    spec:\n-      containers:\n-        - name: frontend-service\n-          image: \"{{ .Values.frontendService.image.repository }}:{{ .Values.frontendService.image.tag }}\"\n-          imagePullPolicy: IfNotPresent\n-          ports:\n-            - containerPort: 8000\n-          {{ if .Values.frontendService.resources }}\n-          resources:\n-            limits:\n-              cpu: {{ .Values.frontendService.resources.limits.cpu }}\n-              memory: {{ .Values.frontendService.resources.limits.memory }}\n-            requests:\n-              cpu: {{ .Values.frontendService.resources.requests.cpu }}\n-              memory: {{ .Values.frontendService.resources.requests.memory }}\n-          {{ end }}\n-          volumeMounts:\n-            - name: chroma\n-              mountPath: /test\n-          env:\n-            - name: CHROMA_API_IMPL\n-              value: \"chromadb.api.segment.SegmentAPI\"\n-            - name: IS_PERSISTENT\n-              {{ .Values.frontendService.isPersistent }}\n-            - name: CHROMA_PRODUCER_IMPL\n-              {{ .Values.frontendService.producerImpl }}\n-            - name: CHROMA_CONSUMER_IMPL\n-              {{ .Values.frontendService.consumerImpl }}\n-            - name: CHROMA_SEGMENT_MANAGER_IMPL\n-              {{ .Values.frontendService.segmentManagerImpl }}\n-            - name: CHROMA_EXECUTOR_IMPL\n-              {{ .Values.frontendService.executorImpl }}\n-            - name: ALLOW_RESET\n-              {{ .Values.frontendService.allowReset }}\n-            - name: CHROMA_SYSDB_IMPL\n-              {{ .Values.frontendService.sysdbImpl }}\n-            - name: CHROMA_SERVER_GRPC_PORT\n-              {{ .Values.frontendService.serverGrpcPort }}\n-            - name: CHROMA_COORDINATOR_HOST\n-              {{ .Values.frontendService.coordinatorHost }}\n-            - name: CHROMA_SERVER_AUTHN_PROVIDER\n-              {{ .Values.frontendService.authnProvider }}\n-            - name: CHROMA_SERVER_AUTHZ_PROVIDER\n-              {{ .Values.frontendService.authzProvider }}\n-            - name: CHROMA_MEMBERLIST_PROVIDER_IMPL\n-              {{ .Values.frontendService.memberlistProviderImpl }}\n-            - name: CHROMA_LOGSERVICE_HOST\n-              {{ .Values.frontendService.logServiceHost }}\n-            - name: CHROMA_LOGSERVICE_PORT\n-              {{ .Values.frontendService.logServicePort }}\n-{{ .Values.frontendService.otherEnvConfig | nindent 12 }}\n-      {{if .Values.frontendService.tolerations}}\n-      tolerations:\n-        {{ toYaml .Values.frontendService.tolerations | nindent 8 }}\n-      {{ end }}\n-      {{if .Values.frontendService.nodeSelector}}\n-      nodeSelector:\n-        {{ toYaml .Values.frontendService.nodeSelector | nindent 8 }}\n-      {{ end }}\n-      volumes:\n-        - name: chroma\n-          emptyDir: {}\n-\n----\n-\n-apiVersion: v1\n-kind: Service\n-metadata:\n-  name: frontend-service\n-  namespace: {{ .Values.namespace }}\n-spec:\n-  ports:\n-    - name: server-port\n-      port: 8000\n-      targetPort: 8000\n-  selector:\n-    app: frontend-service\n-  type: ClusterIP\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -20,11 +20,6 @@ rustFrontendService:\n     - name: CONFIG_PATH\n       value: \"tilt_config.yaml\"\n \n-frontendService:\n-  otherEnvConfig: |\n-    - name: CHROMA_ALLOW_RESET\n-      value: \"true\"\n-\n queryService:\n   env:\n     - name: RUST_BACKTRACE\n---\nk8s/distributed-chroma/values.yaml\n@@ -3,39 +3,6 @@\n \n namespace: 'chroma'\n \n-frontendService:\n-  image:\n-    repository: 'frontend-service'\n-    tag: 'latest'\n-\n-  # Sometimes users (and us) want to pass values directly as flags. Sometimes, these are\n-  # populated from secrets or configMaps. So we let consumers fill these directly.\n-  # TODO we could maybe have mutually exclusive pieces of config, e.g. isPersistentValue\n-  # and isPersistentFromConfigMap or something.\n-  isPersistent: 'value: \"TRUE\"'\n-  producerImpl: 'value: \"chromadb.logservice.logservice.LogService\"'\n-  consumerImpl: 'value: \"chromadb.logservice.logservice.LogService\"'\n-  segmentManagerImpl: 'value: \"chromadb.segment.impl.manager.distributed.DistributedSegmentManager\"'\n-  executorImpl: 'value: \"chromadb.execution.executor.distributed.DistributedExecutor\"'\n-  allowReset: 'value: \"TRUE\"'\n-  sysdbImpl: 'value: \"chromadb.db.impl.grpc.client.GrpcSysDB\"'\n-  serverGrpcPort: 'value: \"50051\"'\n-  coordinatorHost: 'value: \"sysdb.chroma\"'\n-  authProvider: 'value: \"\"'\n-  authCredentialsProvider: 'value: \"\"'\n-  authzProvider: 'value: \"\"'\n-  authzConfigProvider: 'value: \"\"'\n-  memberlistProviderImpl: 'value: \"chromadb.segment.impl.distributed.segment_directory.CustomResourceMemberlistProvider\"'\n-  logServiceHost: 'value: \"logservice.chroma\"'\n-  logServicePort: 'value: \"50051\"'\n-  otherEnvConfig: |\n-    - name: CHROMA_OTEL_COLLECTION_ENDPOINT\n-      value: \"http://jaeger:4317\"\n-    - name: CHROMA_OTEL_GRANULARITY\n-      value: all\n-  replicaCount: 2\n-\n-\n rustFrontendService:\n   image:\n     repository: 'rust-frontend-service'\n---\n\n\n---\n\nChoice C:\nrust/worker/src/execution/orchestration/compact.rs\n@@ -794,10 +794,14 @@ impl Handler<TaskResult<FetchLogOutput, FetchLogError>> for CompactOrchestrator\n                 tracing::info!(\"Pulled Logs Up To Offset: {:?}\", self.pulled_log_offset);\n             }\n             None => {\n+                tracing::warn!(\"No logs were pulled from the log service, this can happen when the log compaction offset is behing the sysdb.\");\n+                // TODO(hammadb): We can repair the log service's understanding of the offset here, as this only happens\n+                // when the log service is not up to date on the latest compacted offset, which leads it to schedule an already\n+                // compacted collection.\n                 self.terminate_with_result(\n-                    Err(CompactionError::InvariantViolation(\n-                        \"Logs should be present for compaction\",\n-                    )),\n+                    Ok(CompactionResponse {\n+                        collection_id: self.collection_id,\n+                    }),\n                     ctx,\n                 )\n                 .await;\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/quota/mod.rs\n@@ -240,6 +240,7 @@ pub enum UsageType {\n     NumCollections,        // Total number of collections for a tenant\n     NumDatabases,          // Total number of databases for a tenant\n     NumQueryIDs,           // Number of IDs to filter by in a query\n+    NumRegexPredicates,    // Number of regex predicates in the where_document\n }\n \n impl fmt::Display for UsageType {\n@@ -269,6 +270,7 @@ impl fmt::Display for UsageType {\n             UsageType::NumCollections => write!(f, \"Number of collections\"),\n             UsageType::NumDatabases => write!(f, \"Number of databases\"),\n             UsageType::NumQueryIDs => write!(f, \"Number of IDs to filter by in a query\"),\n+            UsageType::NumRegexPredicates => write!(f, \"Number of regex predicates\"),\n         }\n     }\n }\n@@ -298,6 +300,7 @@ impl TryFrom<&str> for UsageType {\n             \"num_collections\" => Ok(UsageType::NumCollections),\n             \"num_databases\" => Ok(UsageType::NumDatabases),\n             \"num_query_ids\" => Ok(UsageType::NumQueryIDs),\n+            \"num_regex_predicates\" => Ok(UsageType::NumRegexPredicates),\n             _ => Err(format!(\"Invalid UsageType: {}\", value)),\n         }\n     }\n@@ -326,6 +329,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumCollections, 1_000_000);\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n+        m.insert(UsageType::NumRegexPredicates, 0);\n         m\n     };\n }\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nRelease JS client 2.4.3\n\n---\n\nChoice A:\n.github/workflows/_python-tests.yml\n@@ -24,11 +24,12 @@ jobs:\n         test-globs:\n           - \"--ignore-glob 'chromadb/test/property/*' --ignore-glob 'chromadb/test/stress/*' --ignore-glob 'chromadb/test/distributed/*'\"\n           - \"chromadb/test/property --ignore-glob chromadb/test/property/test_cross_version_persist.py\"\n-          # TODO(@codetheweb): this test should be parallelized, but it frequently flakes in CI when parallelized. We have not been able to reproduce the failure locally. See https://github.com/chroma-core/chroma/issues/4263.\n           - \"chromadb/test/property/test_cross_version_persist.py\"\n         include:\n           - test-globs: \"chromadb/test/property --ignore-glob chromadb/test/property/test_cross_version_persist.py\"\n             parallelized: true\n+          - test-globs: \"chromadb/test/property/test_cross_version_persist.py\"\n+            parallelized: true\n \n     runs-on: ${{ matrix.platform }}\n     steps:\n---\n\n\n---\n\nChoice B:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.2\",\n+  \"version\": \"2.4.3\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.4\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.0.4\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.4\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.4\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.4\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.1.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.1\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -374,7 +374,7 @@ func (tc *Catalog) createCollectionImpl(txCtx context.Context, createCollection\n \t\treturn nil, false, common.ErrConcurrentDeleteCollection\n \t}\n \tresult := convertCollectionToModel(collectionList)[0]\n-\treturn result, true, nil\n+\treturn result, created, nil\n }\n \n func (tc *Catalog) CreateCollection(ctx context.Context, createCollection *model.CreateCollection, ts types.Timestamp) (*model.Collection, bool, error) {\n@@ -1251,7 +1251,6 @@ func (tc *Catalog) CreateCollectionAndSegments(ctx context.Context, createCollec\n \t\t}\n \n \t\t// If collection already exists, then do not create segments.\n-\t\t// TODO: Should we check to see if segments does not exist? and create them?\n \t\tif !created {\n \t\t\treturn nil\n \t\t}\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.10\"\n+__version__ = \"1.0.11\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.10\"\n+      \"Default\": \"1.0.11\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nUpdate JS bindings CI with more debugging\n\n---\n\nChoice A:\nCargo.lock\n@@ -3340,6 +3340,7 @@ dependencies = [\n  \"tokio\",\n  \"tokio-test\",\n  \"tonic\",\n+ \"tonic-health\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-test\",\n---\nidl/chromadb/proto/garbage_collector.proto\n@@ -0,0 +1,6 @@\n+syntax = \"proto3\";\n+\n+package chroma;\n+\n+// This is a placeholder service. The garbage collector currently only exposes a health service.\n+service GarbageCollector {}\n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.43\n+version: 0.1.44\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/garbage-collector.yaml\n@@ -40,6 +40,9 @@ spec:\n       - name: garbage-collector\n         image: \"{{ .Values.garbageCollector.image.repository }}:{{ .Values.garbageCollector.image.tag }}\"\n         imagePullPolicy: IfNotPresent\n+        readinessProbe:\n+          grpc:\n+            port: 50055\n         {{ if .Values.garbageCollector.resources }}\n         resources:\n           limits:\n---\nrust/garbage_collector/Cargo.toml\n@@ -27,6 +27,7 @@ tokio = { workspace = true }\n uuid = { workspace = true }\n futures = { workspace = true }\n tonic = { workspace = true }\n+tonic-health = { workspace = true }\n tempfile = { workspace = true }\n tracing = { workspace = true }\n thiserror = { workspace = true }\n---\nrust/garbage_collector/src/config.rs\n@@ -38,6 +38,8 @@ pub(super) struct GarbageCollectorConfig {\n     pub(super) assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig,\n     pub(super) memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig,\n     pub my_member_id: String,\n+    #[serde(default = \"GarbageCollectorConfig::default_port\")]\n+    pub port: u16,\n }\n \n impl GarbageCollectorConfig {\n@@ -61,6 +63,10 @@ impl GarbageCollectorConfig {\n             Err(e) => panic!(\"Error loading config: {}\", e),\n         }\n     }\n+\n+    fn default_port() -> u16 {\n+        50055\n+    }\n }\n \n #[cfg(test)]\n---\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -633,6 +633,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n@@ -753,6 +754,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n---\nrust/garbage_collector/src/lib.rs\n@@ -6,9 +6,11 @@ use chroma_tracing::{\n     init_global_filter_layer, init_otel_layer, init_panic_tracing_hook, init_stdout_layer,\n     init_tracing,\n };\n+use chroma_types::chroma_proto::garbage_collector_server::GarbageCollectorServer;\n use config::GarbageCollectorConfig;\n use garbage_collector_component::GarbageCollector;\n use tokio::signal::unix::{signal, SignalKind};\n+use tonic::transport::Server;\n use tracing::{debug, error, info};\n \n mod config;\n@@ -24,7 +26,20 @@ pub mod types;\n \n const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n \n+// This is a placeholder service so that we can expose a health service\n+struct GarbageCollectorService {}\n+\n+impl chroma_types::chroma_proto::garbage_collector_server::GarbageCollector\n+    for GarbageCollectorService\n+{\n+}\n+\n pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::error::Error>> {\n+    let (mut health_reporter, health_service) = tonic_health::server::health_reporter();\n+    health_reporter\n+        .set_not_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     debug!(\"Loading configuration from environment\");\n     // Parse configuration. Configuration includes sysdb connection details, and\n     // gc run details amongst others.\n@@ -49,6 +64,27 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n \n     info!(\"Loaded configuration successfully: {:#?}\", config);\n \n+    let addr = format!(\"[::]:{}\", config.port)\n+        .parse()\n+        .expect(\"Invalid address format\");\n+    let server_join_handle = tokio::spawn(async move {\n+        let server = Server::builder().add_service(health_service);\n+        server\n+            .serve_with_shutdown(addr, async {\n+                match signal(SignalKind::terminate()) {\n+                    Ok(mut sigterm) => {\n+                        sigterm.recv().await;\n+                        tracing::info!(\"Received SIGTERM, shutting down gRPC server\");\n+                    }\n+                    Err(err) => {\n+                        tracing::error!(\"Failed to create SIGTERM handler: {err}\")\n+                    }\n+                }\n+            })\n+            .await\n+            .expect(\"Failed to start gRPC server\");\n+    });\n+\n     let registry = chroma_config::registry::Registry::new();\n     let system = System::new();\n \n@@ -79,6 +115,10 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n     memberlist.subscribe(garbage_collector_handle.receiver());\n     let mut memberlist_handle = system.start_component(memberlist);\n \n+    health_reporter\n+        .set_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     // Keep the service running and handle shutdown signals\n     let mut sigterm = signal(SignalKind::terminate())?;\n     let mut sigint = signal(SignalKind::interrupt())?;\n@@ -112,6 +152,7 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n         .expect(\"Dispatcher should be stoppable\");\n     system.stop().await;\n     system.join().await;\n+    let _ = server_join_handle.await;\n \n     info!(\"Shutting down garbage collector service\");\n     Ok(())\n---\nrust/types/build.rs\n@@ -6,6 +6,7 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n         \"idl/chromadb/proto/coordinator.proto\",\n         \"idl/chromadb/proto/logservice.proto\",\n         \"idl/chromadb/proto/query_executor.proto\",\n+        \"idl/chromadb/proto/garbage_collector.proto\",\n     ];\n \n     // Can't use #[cfg(test)] here because a build for tests is technically a regular debug build, meaning that #[cfg(test)] is useless in build.rs.\n---\nrust/types/src/lib.rs\n@@ -47,6 +47,7 @@ pub use tenant::*;\n pub use types::*;\n pub use where_parsing::*;\n \n+#[allow(clippy::all)]\n pub mod chroma_proto {\n     tonic::include_proto!(\"chroma\");\n }\n---\n\n\n---\n\nChoice B:\n.github/workflows/_build_js_bindings.yml\n@@ -231,11 +231,17 @@ jobs:\n       - name: Download all artifacts\n         uses: actions/download-artifact@v4\n         with:\n-          path: artifacts\n+          path: rust/js_bindings/artifacts\n+      - name: List downloads\n+        run: ls -R .\n+      - name: Flatten artifact directory\n+        run: find artifacts -type f -name '*.node' -exec mv {} ./artifacts/ \\;\n+      - name: List downloads\n+        run: ls -R .\n       - name: Move artifacts\n         run: pnpm artifacts\n       - name: List packages\n-        run: ls -R ./npm\n+        run: ls -R .\n         shell: bash\n       - name: Publish\n         run: |\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.0.4\",\n+  \"version\": \"0.1.1\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\nChoice C:\nk8s/distributed-chroma/values.dev.yaml\n@@ -33,3 +33,6 @@ compactionService:\n       value: 'value: \"1\"'\n     - name: CONFIG_PATH\n       value: 'value: \"/tilt_config.yaml\"'\n+\n+rustLogService:\n+  replicaCount: 2\n---\n\n\n---\n\nChoice D:\nclients/js/packages/chromadb-core/src/ChromaFetch.ts\n@@ -9,6 +9,7 @@ import {\n   ChromaError,\n   createErrorByType,\n   ChromaUniqueError,\n+  ChromaQuotaExceededError,\n } from \"./Errors\";\n import { FetchAPI } from \"./generated\";\n \n@@ -74,6 +75,14 @@ export const chromaFetch: FetchAPI = async (\n           );\n         case 409:\n           throw new ChromaUniqueError(\"The resource already exists\");\n+        case 422:\n+          if (\n+            respBody?.message &&\n+            respBody?.message.startsWith(\"Quota exceeded\")\n+          ) {\n+            throw new ChromaQuotaExceededError(respBody?.message);\n+          }\n+          break;\n         case 500:\n           throw parseServerError(respBody?.error);\n         case 502:\n---\nclients/js/packages/chromadb-core/src/Errors.ts\n@@ -85,6 +85,13 @@ export class ChromaUniqueError extends Error {\n   }\n }\n \n+export class ChromaQuotaExceededError extends Error {\n+  name = \"ChromaQuotaExceededError\";\n+  constructor(message: string, public readonly cause?: unknown) {\n+    super(message);\n+  }\n+}\n+\n export function createErrorByType(type: string, message: string) {\n   switch (type) {\n     case \"InvalidCollection\":\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nRelease JS client with updated bindings for CLI\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -835,7 +841,10 @@ impl DataSet for ReferencingDataSet {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice B:\nrust/frontend/src/config.rs\n@@ -64,6 +64,8 @@ pub struct FrontendConfig {\n     pub executor: ExecutorConfig,\n     #[serde(default = \"default_default_knn_index\")]\n     pub default_knn_index: KnnIndex,\n+    #[serde(default = \"Default::default\")]\n+    pub tenants_to_migrate_immediately: Vec<String>,\n }\n \n impl FrontendConfig {\n@@ -80,6 +82,7 @@ impl FrontendConfig {\n             log: default_log_config(),\n             executor: default_executor_config(),\n             default_knn_index: default_default_knn_index(),\n+            tenants_to_migrate_immediately: vec![],\n         }\n     }\n }\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -66,9 +66,11 @@ pub struct ServiceBasedFrontend {\n     metrics: Arc<Metrics>,\n     default_knn_index: KnnIndex,\n     retries_builder: ExponentialBuilder,\n+    tenants_to_migrate_immediately: HashSet<String>,\n }\n \n impl ServiceBasedFrontend {\n+    #[allow(clippy::too_many_arguments)]\n     pub fn new(\n         allow_reset: bool,\n         sysdb_client: SysDb,\n@@ -77,6 +79,7 @@ impl ServiceBasedFrontend {\n         executor: Executor,\n         max_batch_size: u32,\n         default_knn_index: KnnIndex,\n+        tenants_to_migrate_immediately: HashSet<String>,\n     ) -> Self {\n         let meter = global::meter(\"chroma\");\n         let fork_retries_counter = meter.u64_counter(\"fork_retries\").build();\n@@ -119,6 +122,7 @@ impl ServiceBasedFrontend {\n             metrics,\n             default_knn_index,\n             retries_builder,\n+            tenants_to_migrate_immediately,\n         }\n     }\n \n@@ -489,7 +493,7 @@ impl ServiceBasedFrontend {\n         let collection = self\n             .sysdb_client\n             .create_collection(\n-                tenant_id,\n+                tenant_id.clone(),\n                 database_name,\n                 collection_id,\n                 name,\n@@ -505,10 +509,18 @@ impl ServiceBasedFrontend {\n             .collections_with_segments_cache\n             .remove(&collection_id)\n             .await;\n-\n+        if self.tenant_is_on_new_log_by_default(&tenant_id) {\n+            if let Err(err) = self.log_client.seal_log(&tenant_id, collection_id).await {\n+                tracing::error!(\"could not seal collection right away: {err}\");\n+            }\n+        }\n         Ok(collection)\n     }\n \n+    fn tenant_is_on_new_log_by_default(&self, tenant_id: &str) -> bool {\n+        self.tenants_to_migrate_immediately.contains(tenant_id)\n+    }\n+\n     pub async fn update_collection(\n         &mut self,\n         UpdateCollectionRequest {\n@@ -1471,6 +1483,11 @@ impl Configurable<(FrontendConfig, System)> for ServiceBasedFrontend {\n         let executor =\n             Executor::try_from_config(&(config.executor.clone(), system.clone()), registry).await?;\n \n+        let tenants_to_migrate_immediately = config\n+            .tenants_to_migrate_immediately\n+            .iter()\n+            .cloned()\n+            .collect::<HashSet<String>>();\n         Ok(ServiceBasedFrontend::new(\n             config.allow_reset,\n             sysdb,\n@@ -1479,6 +1496,7 @@ impl Configurable<(FrontendConfig, System)> for ServiceBasedFrontend {\n             executor,\n             max_batch_size,\n             config.default_knn_index,\n+            tenants_to_migrate_immediately,\n         ))\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -125,6 +125,20 @@ impl ChromaError for GrpcPurgeDirtyForCollectionError {\n     }\n }\n \n+#[derive(Error, Debug)]\n+pub enum GrpcSealLogError {\n+    #[error(\"Failed to seal collection: {0}\")]\n+    FailedToSeal(#[from] tonic::Status),\n+}\n+\n+impl ChromaError for GrpcSealLogError {\n+    fn code(&self) -> ErrorCodes {\n+        match self {\n+            GrpcSealLogError::FailedToSeal(_) => ErrorCodes::Internal,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct GrpcLog {\n     config: GrpcLogConfig,\n@@ -544,6 +558,20 @@ impl GrpcLog {\n             Ok(())\n         }\n     }\n+\n+    pub(super) async fn seal_log(\n+        &mut self,\n+        tenant: &str,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcSealLogError> {\n+        let _response = self\n+            .client_for(tenant, collection_id)\n+            .seal_log(chroma_proto::SealLogRequest {\n+                collection_id: collection_id.to_string(),\n+            })\n+            .await?;\n+        Ok(())\n+    }\n }\n \n #[cfg(test)]\n---\nrust/log/src/log.rs\n@@ -1,4 +1,4 @@\n-use crate::grpc_log::GrpcLog;\n+use crate::grpc_log::{GrpcLog, GrpcSealLogError};\n use crate::in_memory_log::InMemoryLog;\n use crate::sqlite_log::SqliteLog;\n use crate::types::CollectionInfo;\n@@ -210,4 +210,16 @@ impl Log {\n             Log::InMemory(_) => Ok(ResetResponse {}),\n         }\n     }\n+\n+    pub async fn seal_log(\n+        &mut self,\n+        tenant: &str,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcSealLogError> {\n+        match self {\n+            Log::Grpc(log) => log.seal_log(tenant, collection_id).await,\n+            Log::Sqlite(_) => unimplemented!(),\n+            Log::InMemory(_) => unimplemented!(),\n+        }\n+    }\n }\n---\nrust/python_bindings/src/bindings.rs\n@@ -122,6 +122,7 @@ impl Bindings {\n             log: log_config,\n             executor: executor_config,\n             default_knn_index: knn_index,\n+            tenants_to_migrate_immediately: vec![],\n         };\n \n         let frontend = runtime.block_on(async {\n---\n\n\n---\n\nChoice C:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.1\",\n+  \"version\": \"2.4.2\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.4\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.4\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.4\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.4\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.4\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\n\n\n---\n\nChoice D:\nrust/wal3/examples/wal3-bootstrap-reasoner.rs\n@@ -0,0 +1,182 @@\n+//! This file is not intended for public consumption, but is kept for completeness.\n+//!\n+//! In this file you will find that we reason about the bootstrap process by completely exploring\n+//! the state space and pruning known good states.  The goal is to prune every state or print a\n+//! list of states that are bad.\n+//!\n+//! This is ad-hoc machine-assisted proving without an environment or theorem prover.\n+\n+#[derive(Clone, Copy, Debug)]\n+enum FragmentState {\n+    BenignRace,\n+    Conflict,\n+    Success,\n+}\n+\n+impl FragmentState {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            FragmentState::BenignRace,\n+            FragmentState::Conflict,\n+            FragmentState::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum InitializeManifest {\n+    Uninitialized,\n+    AlreadyInitialized,\n+    Success,\n+}\n+\n+impl InitializeManifest {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            InitializeManifest::Uninitialized,\n+            InitializeManifest::AlreadyInitialized,\n+            InitializeManifest::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum RecoverManifest {\n+    Uninitialized,\n+    Failure,\n+    Success,\n+}\n+\n+impl RecoverManifest {\n+    fn all_states() -> impl Iterator<Item = Self> {\n+        vec![\n+            RecoverManifest::Uninitialized,\n+            RecoverManifest::Failure,\n+            RecoverManifest::Success,\n+        ]\n+        .into_iter()\n+    }\n+}\n+\n+enum Disposition {\n+    /// The combination of states is considered a good case.\n+    Good,\n+    /// The combination of states is not considered by the rule.\n+    Pass,\n+    /// The case can be dropped with good conscience for not mattering.  The string is the reason.\n+    Drop(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+    /// The case must lead to an error at runtime.\n+    Panic(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+    /// The case must be raised to the user for inspection.\n+    Raise(\n+        &'static str,\n+        FragmentState,\n+        InitializeManifest,\n+        RecoverManifest,\n+    ),\n+}\n+\n+fn happy_paths(fs: FragmentState, im: InitializeManifest, rm: RecoverManifest) -> Disposition {\n+    match (fs, im, rm) {\n+        (\n+            FragmentState::Success | FragmentState::BenignRace,\n+            InitializeManifest::Uninitialized | InitializeManifest::Success,\n+            RecoverManifest::Success,\n+        ) => Disposition::Good,\n+        _ => Disposition::Pass,\n+    }\n+}\n+\n+fn error_paths(fs: FragmentState, im: InitializeManifest, rm: RecoverManifest) -> Disposition {\n+    match (fs, im, rm) {\n+        (_, InitializeManifest::AlreadyInitialized, _) => {\n+            Disposition::Panic(\"cannot double-initialize manifest\", fs, im, rm)\n+        }\n+        (_, _, RecoverManifest::Uninitialized) => {\n+            Disposition::Panic(\"cannot have manifest become uninitialized\", fs, im, rm)\n+        }\n+        (_, _, RecoverManifest::Failure) => {\n+            Disposition::Panic(\"failed to install recovered manifest\", fs, im, rm)\n+        }\n+        _ => Disposition::Pass,\n+    }\n+}\n+\n+fn conflict_on_fragment(\n+    fs: FragmentState,\n+    im: InitializeManifest,\n+    rm: RecoverManifest,\n+) -> Disposition {\n+    if matches!(fs, FragmentState::Conflict) {\n+        Disposition::Drop(\n+            \"no need to touch manifest if fragment conflicts\",\n+            fs,\n+            im,\n+            rm,\n+        )\n+    } else {\n+        Disposition::Pass\n+    }\n+}\n+\n+fn unconditionally_raise(\n+    fs: FragmentState,\n+    im: InitializeManifest,\n+    rm: RecoverManifest,\n+) -> Disposition {\n+    Disposition::Raise(\"unconditional raise\", fs, im, rm)\n+}\n+\n+pub fn main() {\n+    let mut states = vec![];\n+    for fs in FragmentState::all_states() {\n+        for im in InitializeManifest::all_states() {\n+            for rm in RecoverManifest::all_states() {\n+                states.push((fs, im, rm));\n+            }\n+        }\n+    }\n+    let rules = vec![\n+        happy_paths,\n+        conflict_on_fragment,\n+        error_paths,\n+        unconditionally_raise,\n+    ];\n+    for state in states.iter() {\n+        for rule in &rules {\n+            match (rule)(state.0, state.1, state.2) {\n+                Disposition::Pass => {}\n+                Disposition::Good => {\n+                    break;\n+                }\n+                Disposition::Panic(reason, fs, im, rm) => {\n+                    println!(\"panic({fs:?}, {im:?}, {rm:?}) -> {reason}\");\n+                    break;\n+                }\n+                Disposition::Drop(reason, fs, im, rm) => {\n+                    _ = reason;\n+                    _ = fs;\n+                    _ = im;\n+                    _ = rm;\n+                    break;\n+                }\n+                Disposition::Raise(reason, fs, im, rm) => {\n+                    println!(\"raise({fs:?}, {im:?}, {rm:?}) -> {reason}\");\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nRelease JS client 2.4.1\r\n\n\n---\n\nChoice A:\nrust/blockstore/src/arrow/provider.rs\n@@ -469,6 +469,15 @@ pub struct RootManager {\n     prefetched_roots: Arc<parking_lot::Mutex<HashMap<Uuid, Duration>>>,\n }\n \n+impl std::fmt::Debug for RootManager {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"RootManager\")\n+            .field(\"cache\", &self.cache)\n+            .field(\"storage\", &self.storage)\n+            .finish()\n+    }\n+}\n+\n impl RootManager {\n     pub fn new(storage: Storage, cache: Box<dyn PersistentCache<Uuid, RootReader>>) -> Self {\n         let cache: Arc<dyn PersistentCache<Uuid, RootReader>> = cache.into();\n---\nrust/garbage_collector/src/operators/list_files_at_version.rs\n@@ -0,0 +1,160 @@\n+use async_trait::async_trait;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n+use chroma_system::{Operator, OperatorType};\n+use chroma_types::{chroma_proto::CollectionVersionFile, CollectionUuid, HNSW_PATH};\n+use std::{collections::HashSet, str::FromStr};\n+use thiserror::Error;\n+use tokio::task::{JoinError, JoinSet};\n+use uuid::Uuid;\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionInput {\n+    root_manager: RootManager,\n+    version_file: CollectionVersionFile,\n+    version: i64,\n+}\n+\n+impl ListFilesAtVersionInput {\n+    pub fn new(\n+        root_manager: RootManager,\n+        version_file: CollectionVersionFile,\n+        version: i64,\n+    ) -> Self {\n+        Self {\n+            root_manager,\n+            version_file,\n+            version,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionOutput {\n+    pub collection_id: CollectionUuid,\n+    pub version: i64,\n+    pub file_paths: HashSet<String>,\n+}\n+\n+#[derive(Debug, Error)]\n+pub enum ListFilesAtVersionError {\n+    #[error(\"Version history field missing\")]\n+    VersionHistoryMissing,\n+    #[error(\"Version {0} not found\")]\n+    VersionNotFound(i64),\n+    #[error(\"Invalid UUID: {0}\")]\n+    InvalidUuid(uuid::Error),\n+    #[error(\"Sparse index fetch task failed: {0}\")]\n+    SparseIndexTaskFailed(JoinError),\n+    #[error(\"Error fetching block IDs for sparse index: {0}\")]\n+    FetchBlockIdsError(#[from] RootManagerError),\n+    #[error(\"Version file missing collection ID\")]\n+    VersionFileMissingCollectionId,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ListFilesAtVersionsOperator {}\n+\n+#[async_trait]\n+impl Operator<ListFilesAtVersionInput, ListFilesAtVersionOutput> for ListFilesAtVersionsOperator {\n+    type Error = ListFilesAtVersionError;\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n+\n+    async fn run(\n+        &self,\n+        input: &ListFilesAtVersionInput,\n+    ) -> Result<ListFilesAtVersionOutput, Self::Error> {\n+        let collection_id = CollectionUuid::from_str(\n+            &input\n+                .version_file\n+                .collection_info_immutable\n+                .as_ref()\n+                .ok_or_else(|| ListFilesAtVersionError::VersionFileMissingCollectionId)?\n+                .collection_id,\n+        )\n+        .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+        let version_history = input\n+            .version_file\n+            .version_history\n+            .as_ref()\n+            .ok_or_else(|| ListFilesAtVersionError::VersionHistoryMissing)?;\n+\n+        let mut file_paths = HashSet::new();\n+        let mut sparse_index_ids = HashSet::new();\n+\n+        let version = version_history\n+            .versions\n+            .iter()\n+            .find(|v| v.version == input.version)\n+            .ok_or_else(|| ListFilesAtVersionError::VersionNotFound(input.version))?;\n+\n+        tracing::debug!(\n+            \"Listing files at version {} for collection {}.\",\n+            version.version,\n+            collection_id,\n+        );\n+        tracing::trace!(\n+            \"Processing version {:#?} for collection {}\",\n+            version,\n+            collection_id\n+        );\n+\n+        if let Some(segment_info) = &version.segment_info {\n+            for segment in &segment_info.segment_compaction_info {\n+                for (file_type, segment_paths) in &segment.file_paths {\n+                    if file_type == \"hnsw_index\" || file_type == HNSW_PATH {\n+                        for path in &segment_paths.paths {\n+                            for hnsw_file in [\n+                                \"header.bin\",\n+                                \"data_level0.bin\",\n+                                \"length.bin\",\n+                                \"link_lists.bin\",\n+                            ] {\n+                                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                                file_paths.insert(format!(\"hnsw/{}/{}\", path, hnsw_file));\n+                            }\n+                        }\n+                    } else {\n+                        // Must be a sparse index\n+                        for path in &segment_paths.paths {\n+                            // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                            file_paths.insert(format!(\"sparse_index/{}\", path));\n+\n+                            let sparse_index_id = Uuid::parse_str(path)\n+                                .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+                            sparse_index_ids.insert(sparse_index_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut block_id_tasks = JoinSet::new();\n+        for sparse_index_id in sparse_index_ids {\n+            let root_manager = input.root_manager.clone();\n+            block_id_tasks\n+                .spawn(async move { root_manager.get_all_block_ids(&sparse_index_id).await });\n+        }\n+\n+        while let Some(res) = block_id_tasks.join_next().await {\n+            let block_ids = res\n+                .map_err(ListFilesAtVersionError::SparseIndexTaskFailed)?\n+                .map_err(ListFilesAtVersionError::FetchBlockIdsError)?;\n+\n+            for block_id in block_ids {\n+                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                file_paths.insert(format!(\"block/{}\", block_id));\n+            }\n+        }\n+\n+        Ok(ListFilesAtVersionOutput {\n+            collection_id,\n+            version: input.version,\n+            file_paths,\n+        })\n+    }\n+}\n---\nrust/garbage_collector/src/operators/mod.rs\n@@ -8,4 +8,5 @@ pub mod fetch_lineage_file;\n pub mod fetch_sparse_index_files;\n pub mod fetch_version_file;\n pub mod get_version_file_paths;\n+pub mod list_files_at_version;\n pub mod mark_versions_at_sysdb;\n---\n\n\n---\n\nChoice B:\nrust/load/src/data_sets.rs\n@@ -1484,6 +1484,7 @@ pub fn all_data_sets() -> Vec<Arc<dyn DataSet>> {\n         ALL_MINILM_L6_V2,\n         1_000_000,\n     )));\n+    data_sets.push(Arc::clone(&reference_data_set) as _);\n     data_sets.push(Arc::new(VerifyingDataSet {\n         reference_data_set,\n         test_data_set: \"test-all-MiniLM-L6-v2\".to_string(),\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -374,7 +374,7 @@ func (tc *Catalog) createCollectionImpl(txCtx context.Context, createCollection\n \t\treturn nil, false, common.ErrConcurrentDeleteCollection\n \t}\n \tresult := convertCollectionToModel(collectionList)[0]\n-\treturn result, true, nil\n+\treturn result, created, nil\n }\n \n func (tc *Catalog) CreateCollection(ctx context.Context, createCollection *model.CreateCollection, ts types.Timestamp) (*model.Collection, bool, error) {\n@@ -1249,7 +1249,6 @@ func (tc *Catalog) CreateCollectionAndSegments(ctx context.Context, createCollec\n \t\t}\n \n \t\t// If collection already exists, then do not create segments.\n-\t\t// TODO: Should we check to see if segments does not exist? and create them?\n \t\tif !created {\n \t\t\treturn nil\n \t\t}\n---\n\n\n---\n\nChoice D:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.0\",\n+  \"version\": \"2.4.1\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nSince the JS client now uses optional dependencies that are platform specific, we can't use a checked-in lock file and `pnpm install --frozen-lockfile`, since the bindings platform-specific package installed by the test runners will not match the one generated on a dev's machine.\r\n\r\n## Test plan\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nN/A\r\n\n\n---\n\nChoice A:\nrust/load/src/bin/chroma-load-start.rs\n@@ -90,7 +90,7 @@ async fn main() {\n     let args = Args::parse();\n \n     // Read API key from environment variable.\n-    let api_key = std::env::var(\"CHROMA_API_KEY\").expect(\"CHROMA_API_KEY is not set\");\n+    let api_key = std::env::var(\"CHROMA_API_KEY\").ok();\n \n     let client = reqwest::Client::new();\n     let throughput = args.throughput();\n---\nrust/load/src/lib.rs\n@@ -180,20 +180,25 @@ impl ZipfCache {\n #[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]\n pub struct Connection {\n     pub url: String,\n-    pub api_key: String,\n+    pub api_key: Option<String>,\n     pub database: String,\n }\n \n ////////////////////////////////////////////// client //////////////////////////////////////////////\n \n /// Instantiate a new Chroma client.\n pub async fn client(connection: Connection) -> ChromaClient {\n+    let auth = if let Some(api_key) = connection.api_key.clone() {\n+        ChromaAuthMethod::TokenAuth {\n+            token: api_key,\n+            header: ChromaTokenHeader::XChromaToken,\n+        }\n+    } else {\n+        ChromaAuthMethod::None\n+    };\n     ChromaClient::new(ChromaClientOptions {\n         url: Some(connection.url.clone()),\n-        auth: ChromaAuthMethod::TokenAuth {\n-            token: connection.api_key.clone(),\n-            header: ChromaTokenHeader::XChromaToken,\n-        },\n+        auth,\n         database: connection.database.clone(),\n     })\n     .await\n@@ -1032,7 +1037,7 @@ impl LoadHarness {\n             .iter()\n             .map(|w| {\n                 let mut w = w.clone();\n-                w.connection.api_key = \"REDACTED\".to_string();\n+                w.connection.api_key = Some(\"REDACTED\".to_string());\n                 w\n             })\n             .collect()\n@@ -1744,7 +1749,7 @@ mod tests {\n             \"nop\".to_string(),\n             Connection {\n                 url: \"http://localhost:8000\".to_string(),\n-                api_key: \"\".to_string(),\n+                api_key: None,\n                 database: \"\".to_string(),\n             },\n             (chrono::Utc::now() + chrono::Duration::seconds(10)).into(),\n@@ -1856,7 +1861,7 @@ mod tests {\n             \"nop\".to_string(),\n             Connection {\n                 url: \"http://localhost:8000\".to_string(),\n-                api_key: \"\".to_string(),\n+                api_key: None,\n                 database: \"\".to_string(),\n             },\n             (chrono::Utc::now() + chrono::Duration::seconds(10)).into(),\n---\n\n\n---\n\nChoice B:\n.github/workflows/release-javascript-client.yml\n@@ -64,7 +64,7 @@ jobs:\n         cache: 'pnpm'\n         cache-dependency-path: 'clients/js/pnpm-lock.yaml'\n     - name: Install dependencies\n-      run: pnpm install --frozen-lockfile\n+      run: pnpm install --no-frozen-lockfile\n       working-directory: ./clients/js/\n     - name: Build packages\n       run: pnpm build\n---\n\n\n---\n\nChoice C:\nchromadb/__init__.py\n@@ -1,4 +1,4 @@\n-from typing import Dict, Optional\n+from typing import Dict, Optional, Union\n import logging\n from chromadb.api.client import Client as ClientCreator\n from chromadb.api.client import AdminClient as AdminClientCreator\n@@ -26,6 +26,7 @@\n     WhereDocument,\n     UpdateCollectionMetadata,\n )\n+from pathlib import Path\n \n # Re-export types from chromadb.types\n __all__ = [\n@@ -135,7 +136,7 @@ def EphemeralClient(\n \n \n def PersistentClient(\n-    path: str = \"./chroma\",\n+    path: Union[str, Path] = \"./chroma\",\n     settings: Optional[Settings] = None,\n     tenant: str = DEFAULT_TENANT,\n     database: str = DEFAULT_DATABASE,\n@@ -151,7 +152,7 @@ def PersistentClient(\n     \"\"\"\n     if settings is None:\n         settings = Settings()\n-    settings.persist_directory = path\n+    settings.persist_directory = str(path)\n     settings.is_persistent = True\n \n     # Make sure paramaters are the correct types -- users can pass anything.\n---\n\n\n---\n\nChoice D:\nchromadb/api/async_fastapi.py\n@@ -123,10 +123,12 @@ def _get_client(self) -> httpx.AsyncClient:\n                 + \" (https://github.com/chroma-core/chroma)\"\n             )\n \n+            limits = httpx.Limits(max_keepalive_connections=self.keepalive_secs)\n             self._clients[loop_hash] = httpx.AsyncClient(\n                 timeout=None,\n                 headers=headers,\n                 verify=self._settings.chroma_server_ssl_verify or False,\n+                limits=limits,\n             )\n \n         return self._clients[loop_hash]\n---\nchromadb/api/base_http_client.py\n@@ -13,6 +13,7 @@\n class BaseHTTPClient:\n     _settings: Settings\n     _max_batch_size: int = -1\n+    keepalive_secs: int = 40\n \n     @staticmethod\n     def _validate_host(host: str) -> None:\n---\nchromadb/api/fastapi.py\n@@ -69,7 +69,8 @@ def __init__(self, system: System):\n             default_api_path=system.settings.chroma_server_api_default_path,\n         )\n \n-        self._session = httpx.Client(timeout=None)\n+        limits = httpx.Limits(max_keepalive_connections=self.keepalive_secs)\n+        self._session = httpx.Client(timeout=None, limits=limits)\n \n         self._header = system.settings.chroma_server_headers or {}\n         self._header[\"Content-Type\"] = \"application/json\"\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nRelease Chroma 1.0.8\r\n\r\n## Test plan\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nN/A\n\n---\n\nChoice A:\nrust/log/src/grpc_log.rs\n@@ -383,9 +383,9 @@ impl GrpcLog {\n         match &mut self.alt_client_assigner {\n             Some(assigner) => assigner\n                 .clients(&collection_id.to_string())\n-                .unwrap_or_default()\n-                .first()\n-                .cloned(),\n+                .ok()?\n+                .drain(..)\n+                .next(),\n             None => None,\n         }\n     }\n---\n\n\n---\n\nChoice B:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.7\"\n+__version__ = \"1.0.8\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.7\"\n+      \"Default\": \"1.0.8\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice C:\ngo/pkg/log/repository/log.go\n@@ -168,6 +168,13 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\t}\n \t}()\n \n+\t// NOTE(rescrv):  Only sourceInfo.IsSealed should be used on this struct.\n+\tvar sourceInfo log.Collection\n+\tsourceInfo, err = queriesWithTx.GetCollection(ctx, sourceCollectionID)\n+\tif err != nil {\n+\t\tsourceInfo.IsSealed = false\n+\t}\n+\n \tvar sourceBounds log.GetBoundsForCollectionRow\n \tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n@@ -207,6 +214,7 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\tID:                              targetCollectionID,\n \t\tRecordCompactionOffsetPosition:  int64(compactionOffset),\n \t\tRecordEnumerationOffsetPosition: int64(enumerationOffset),\n+\t\tIsSealed:                        sourceInfo.IsSealed,\n \t})\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n---\ngo/pkg/log/repository/log_test.go\n@@ -116,17 +116,17 @@ func (suite *LogTestSuite) TestUniqueConstraintPushLogs() {\n func (suite *LogTestSuite) TestSealedLogWontPush() {\n \tctx := context.Background()\n \tcollectionId := types.NewUniqueID()\n-\tparams := log.InsertCollectionParams {\n-\t\tID: collectionId.String(),\n+\tparams := log.InsertCollectionParams{\n+\t\tID:                              collectionId.String(),\n \t\tRecordEnumerationOffsetPosition: 1,\n-\t\tRecordCompactionOffsetPosition: 0,\n+\t\tRecordCompactionOffsetPosition:  0,\n \t}\n \t_, err := suite.lr.queries.InsertCollection(ctx, params)\n \tassert.NoError(suite.t, err, \"Initializing log should not fail.\")\n \t_, err = suite.lr.queries.SealLog(ctx, collectionId.String())\n \tassert.NoError(suite.t, err, \"Sealing log should not fail.\")\n \tvar isSealed bool\n-\t_, isSealed, err = suite.lr.InsertRecords(ctx, collectionId.String(), [][]byte{{1,2,3}})\n+\t_, isSealed, err = suite.lr.InsertRecords(ctx, collectionId.String(), [][]byte{{1, 2, 3}})\n \tassert.NoError(suite.t, err, \"Failed to push logs\")\n \tassert.True(suite.t, isSealed, \"Did not report was sealed\")\n }\n---\ngo/pkg/log/store/db/queries.sql.go\n@@ -138,6 +138,24 @@ func (q *Queries) GetBoundsForCollection(ctx context.Context, id string) (GetBou\n \treturn i, err\n }\n \n+const getCollection = `-- name: GetCollection :one\n+SELECT id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+FROM collection\n+WHERE id = $1\n+`\n+\n+func (q *Queries) GetCollection(ctx context.Context, id string) (Collection, error) {\n+\trow := q.db.QueryRow(ctx, getCollection, id)\n+\tvar i Collection\n+\terr := row.Scan(\n+\t\t&i.ID,\n+\t\t&i.RecordCompactionOffsetPosition,\n+\t\t&i.RecordEnumerationOffsetPosition,\n+\t\t&i.IsSealed,\n+\t)\n+\treturn i, err\n+}\n+\n const getCollectionForUpdate = `-- name: GetCollectionForUpdate :one\n SELECT id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n FROM collection\n@@ -239,17 +257,23 @@ func (q *Queries) GetTotalUncompactedRecordsCount(ctx context.Context) (int64, e\n }\n \n const insertCollection = `-- name: InsertCollection :one\n-INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n+INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position, is_sealed) values($1, $2, $3, $4) returning id, record_compaction_offset_position, record_enumeration_offset_position, is_sealed\n `\n \n type InsertCollectionParams struct {\n \tID                              string\n \tRecordEnumerationOffsetPosition int64\n \tRecordCompactionOffsetPosition  int64\n+\tIsSealed                        bool\n }\n \n func (q *Queries) InsertCollection(ctx context.Context, arg InsertCollectionParams) (Collection, error) {\n-\trow := q.db.QueryRow(ctx, insertCollection, arg.ID, arg.RecordEnumerationOffsetPosition, arg.RecordCompactionOffsetPosition)\n+\trow := q.db.QueryRow(ctx, insertCollection,\n+\t\targ.ID,\n+\t\targ.RecordEnumerationOffsetPosition,\n+\t\targ.RecordCompactionOffsetPosition,\n+\t\targ.IsSealed,\n+\t)\n \tvar i Collection\n \terr := row.Scan(\n \t\t&i.ID,\n---\ngo/pkg/log/store/queries/queries.sql\n@@ -4,6 +4,11 @@ FROM collection\n WHERE id = $1\n FOR UPDATE;\n \n+-- name: GetCollection :one\n+SELECT *\n+FROM collection\n+WHERE id = $1;\n+\n -- name: InsertRecord :copyfrom\n INSERT INTO record_log (collection_id, \"offset\", record, timestamp) values($1, $2, $3, $4);\n \n@@ -30,7 +35,7 @@ UPDATE collection set record_compaction_offset_position = $2 where id = $1;\n UPDATE collection set record_enumeration_offset_position = $2 where id = $1;\n \n -- name: InsertCollection :one\n-INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position) values($1, $2, $3) returning *;\n+INSERT INTO collection (id, record_enumeration_offset_position, record_compaction_offset_position, is_sealed) values($1, $2, $3, $4) returning *;\n \n -- name: PurgeRecords :exec\n DELETE FROM record_log r using collection c where r.collection_id = c.id and r.offset <= c.record_compaction_offset_position;\n---\n\n\n---\n\nChoice D:\nrust/cache/src/foyer.rs\n@@ -492,6 +492,10 @@ where\n         }\n         Ok(res)\n     }\n+\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.cache.contains(key)\n+    }\n }\n \n impl<K, V> super::PersistentCache<K, V> for FoyerHybridCache<K, V>\n@@ -820,4 +824,26 @@ mod test {\n             .expect(\"Value should not be None\");\n         assert_eq!(value, \"foo\");\n     }\n+\n+    #[tokio::test]\n+    async fn test_may_contain() {\n+        let dir = tempfile::tempdir()\n+            .expect(\"To be able to create temp path\")\n+            .path()\n+            .to_str()\n+            .expect(\"To be able to parse path\")\n+            .to_string();\n+        let cache = FoyerCacheConfig {\n+            dir: Some(dir.clone()),\n+            flush: true,\n+            ..Default::default()\n+        }\n+        .build_hybrid_test::<String, String>()\n+        .await\n+        .unwrap();\n+\n+        cache.insert(\"key1\".to_string(), \"foo\".to_string()).await;\n+        assert!(cache.may_contain(&\"key1\".to_string()).await);\n+        assert!(!cache.may_contain(&\"key2\".to_string()).await);\n+    }\n }\n---\nrust/cache/src/lib.rs\n@@ -69,6 +69,11 @@ where\n {\n     async fn insert(&self, key: K, value: V);\n     async fn get(&self, key: &K) -> Result<Option<V>, CacheError>;\n+    // Returns true if the cache contains the key. This method may return a\n+    // false-positive.\n+    async fn may_contain(&self, key: &K) -> bool {\n+        self.get(key).await.map(|v| v.is_some()).unwrap_or(false)\n+    }\n     async fn remove(&self, key: &K);\n     async fn clear(&self) -> Result<(), CacheError>;\n     async fn obtain(&self, key: K) -> Result<Option<V>, CacheError>;\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nRelease JS client 2.4.0 with new CLI.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nN/A\n\n---\n\nChoice A:\nchromadb/test/distributed/test_log_failover.py\n@@ -189,3 +189,99 @@ def test_log_failover_with_compaction(\n             assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n         else:\n             assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_query_operations(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    # Add initial RECORDS records with known embeddings for querying\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Perform baseline similarity queries before failover\n+    query_embeddings = [embeddings[0], embeddings[RECORDS//2], embeddings[-1]]\n+    baseline_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        baseline_results.append(result)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Trigger log failover\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Re-run the same queries after failover and verify results consistency\n+    post_failover_results = []\n+    for query_embedding in query_embeddings:\n+        result = collection.query(\n+            query_embeddings=[query_embedding],\n+            n_results=5,\n+            include=[\"embeddings\", \"distances\"]\n+        )\n+        post_failover_results.append(result)\n+\n+    # Verify that query results are consistent before and after failover\n+    for i, (baseline, post_failover) in enumerate(zip(baseline_results, post_failover_results)):\n+        assert len(baseline[\"ids\"][0]) == len(post_failover[\"ids\"][0]), f\"Query {i} returned different number of results\"\n+        assert baseline[\"ids\"][0] == post_failover[\"ids\"][0], f\"Query {i} returned different IDs\"\n+        # Verify embeddings match (allowing for small floating point differences)\n+        for j, (base_emb, post_emb) in enumerate(zip(baseline[\"embeddings\"][0], post_failover[\"embeddings\"][0])):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(base_emb, post_emb)]), f\"Query {i} result {j} embeddings differ\"\n+\n+    # Add more data post-failover\n+    post_failover_start = RECORDS\n+    for i in range(post_failover_start, post_failover_start + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    # Query for both old and new data to ensure full functionality\n+    # Test that we can find old data\n+    old_data_query = collection.query(\n+        query_embeddings=[embeddings[0]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(old_data_query[\"ids\"][0]) == 3, \"Failed to query old data after failover\"\n+\n+    # Test that we can find new data\n+    new_data_query = collection.query(\n+        query_embeddings=[embeddings[-1]],\n+        n_results=3,\n+        include=[\"embeddings\"]\n+    )\n+    assert len(new_data_query[\"ids\"][0]) == 3, \"Failed to query new data after failover\"\n+\n+    # Verify all data is still accessible by ID\n+    for i in range(len(ids)):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        assert len(result[\"embeddings\"]) > 0, f\"Missing result for ID {i} after failover with new data\"\n+        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])]), f\"Embedding mismatch for ID {i}\"\n---\n\n\n---\n\nChoice B:\nchromadb/api/types.py\n@@ -687,9 +687,11 @@ def validate_metadata(metadata: Metadata) -> Metadata:\n                 f\"Expected metadata key to be a str, got {key} which is a {type(key).__name__}\"\n             )\n         # isinstance(True, int) evaluates to True, so we need to check for bools separately\n-        if not isinstance(value, bool) and not isinstance(value, (str, int, float)):\n+        if not isinstance(value, bool) and not isinstance(\n+            value, (str, int, float, type(None))\n+        ):\n             raise ValueError(\n-                f\"Expected metadata value to be a str, int, float or bool, got {value} which is a {type(value).__name__}\"\n+                f\"Expected metadata value to be a str, int, float, bool, or None, got {value} which is a {type(value).__name__}\"\n             )\n     return metadata\n \n---\nchromadb/base_types.py\n@@ -1,9 +1,9 @@\n-from typing import Dict, List, Mapping, Sequence, Union\n+from typing import Dict, List, Mapping, Optional, Sequence, Union\n from typing_extensions import Literal\n import numpy as np\n from numpy.typing import NDArray\n \n-Metadata = Mapping[str, Union[str, int, float, bool]]\n+Metadata = Mapping[str, Optional[Union[str, int, float, bool]]]\n UpdateMetadata = Mapping[str, Union[int, float, str, bool, None]]\n PyVector = Union[Sequence[float], Sequence[int]]\n Vector = NDArray[Union[np.int32, np.float32]]  # TODO: Specify that the vector is 1D\n---\n\n\n---\n\nChoice C:\nchromadb/test/property/test_fork.py\n@@ -8,6 +8,7 @@\n \n from chromadb.api.models.Collection import Collection\n from chromadb.test.conftest import reset, skip_if_not_cluster\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n from hypothesis.stateful import (\n     Bundle,\n     RuleBasedStateMachine,\n@@ -198,22 +199,29 @@ def test_fork_with_log_migration(\n     import grpc\n     from chromadb.proto.logservice_pb2 import SealLogRequest\n     from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+    from chromadb.proto.coordinator_pb2_grpc import SysDBStub\n \n     caplog.set_level(logging.ERROR)\n     client.reset()\n     channel = grpc.insecure_channel(\"localhost:50052\")\n     go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n \n+    channel = grpc.insecure_channel(\"localhost:50051\")\n+    sysdb_service = SysDBStub(channel)  # type: ignore[no-untyped-call]\n+\n+    NUMBER = 100\n+\n     collection = client.create_collection(\"legacy-go-collection-0\")\n-    ids = [f\"id_{i}\" for i in range(6)]\n-    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    ids = sorted([f\"id_{i}\" for i in range(NUMBER)])\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(NUMBER)])  # type: ignore[arg-type]\n     go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n     fork_collection = collection.fork(\"fork-legacy-go-collection-0\")\n     assert sorted(fork_collection.get()[\"ids\"]) == ids\n \n     collection = client.create_collection(\"legacy-go-collection-1\")\n     go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n-    ids = [f\"id_{i}\" for i in range(6)]\n-    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    ids = sorted([f\"id_{i}\" for i in range(NUMBER)])\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(NUMBER)])  # type: ignore[arg-type]\n     fork_collection = collection.fork(\"fork-legacy-go-collection-1\")\n+    wait_for_version_increase(client, fork_collection.name, 0)\n     assert sorted(fork_collection.get()[\"ids\"]) == ids\n---\nrust/log-service/src/lib.rs\n@@ -38,7 +38,7 @@ use tracing::{Instrument, Level};\n use uuid::Uuid;\n use wal3::{\n     Cursor, CursorName, CursorStore, CursorStoreOptions, Fragment, Limits, LogPosition, LogReader,\n-    LogReaderOptions, LogWriter, LogWriterOptions, Manifest, Witness,\n+    LogReaderOptions, LogWriter, LogWriterOptions, Manifest, MarkDirty as MarkDirtyTrait, Witness,\n };\n \n pub mod state_hash_table;\n@@ -1427,15 +1427,22 @@ impl LogServer {\n             );\n             // This is the next record to insert, so we'll have to adjust downwards.\n             let max_offset = log_reader.maximum_log_position().await.map_err(|err| {\n-                Status::new(err.code().into(), format!(\"Failed to copy log: {}\", err))\n+                Status::new(err.code().into(), format!(\"Failed to read copied log: {}\", err))\n             })?;\n             if max_offset < offset {\n                 return Err(Status::new(\n                     chroma_error::ErrorCodes::Internal.into(),\n                     format!(\"max_offset={:?} < offset={:?}\", max_offset, offset),\n                 ));\n             }\n-            tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n+            if offset != max_offset{\n+                let mark_dirty = MarkDirty {\n+                    collection_id: target_collection_id,\n+                    dirty_log: Arc::clone(&self.dirty_log),\n+                };\n+                let _ = mark_dirty.mark_dirty(offset, (max_offset - offset) as usize).await;\n+            }\n+            tracing::event!(Level::INFO, compaction_offset =? offset.offset() - 1, enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n                 // NOTE: The upstream service expects the last compacted offset as compaction offset\n                 compaction_offset: (offset - 1u64).offset(),\n---\n\n\n---\n\nChoice D:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.3.0\",\n+  \"version\": \"2.4.0\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nUpdate version for JS bindings and version for standalone installation scripts.\r\n\r\n## Test plan\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nN/A\n\n---\n\nChoice A:\nclients/js/packages/chromadb/package.json\n@@ -50,6 +50,13 @@\n     \"tsup\": \"^7.2.0\",\n     \"typescript\": \"^5.0.4\"\n   },\n+  \"optionalDependencies\": {\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.0.1\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.0.1\"\n+  },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n   },\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.0.0\"\n+$release = \"cli-1.1.0\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.0.0\"\n+RELEASE=\"cli-1.1.0\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\nrust/cli/src/client/collection.rs\n@@ -130,13 +130,7 @@ impl Collection {\n             self.chroma_client.tenant_id, self.chroma_client.db, self.collection_id\n         );\n \n-        let payload = AddCollectionRecordsPayload {\n-            ids,\n-            embeddings,\n-            documents,\n-            uris,\n-            metadatas,\n-        };\n+        let payload = AddCollectionRecordsPayload::new(ids, embeddings, documents, uris, metadatas);\n \n         let _response = send_request::<AddCollectionRecordsPayload, AddCollectionRecordsResponse>(\n             &self.chroma_client.host,\n---\nrust/cli/src/commands/copy.rs\n@@ -277,7 +277,7 @@ pub fn copy(args: CopyArgs) -> Result<(), CliError> {\n         if !args.all && args.collections.is_empty() {\n             return Err(CopyError::NoCollections.into());\n         }\n-        \n+\n         let (_, profile) = get_current_profile()?;\n         let (source, target) = get_target_and_destination(&args)?;\n         let (source_client, target_client, _handle) =\n---\nrust/frontend/src/server.rs\n@@ -1252,11 +1252,29 @@ async fn fork_collection(\n \n #[derive(Serialize, Deserialize, ToSchema, Debug, Clone)]\n pub struct AddCollectionRecordsPayload {\n-    pub ids: Vec<String>,\n-    pub embeddings: Option<Vec<Vec<f32>>>,\n-    pub documents: Option<Vec<Option<String>>>,\n-    pub uris: Option<Vec<Option<String>>>,\n-    pub metadatas: Option<Vec<Option<Metadata>>>,\n+    ids: Vec<String>,\n+    embeddings: Option<Vec<Vec<f32>>>,\n+    documents: Option<Vec<Option<String>>>,\n+    uris: Option<Vec<Option<String>>>,\n+    metadatas: Option<Vec<Option<Metadata>>>,\n+}\n+\n+impl AddCollectionRecordsPayload {\n+    pub fn new(\n+        ids: Vec<String>,\n+        embeddings: Option<Vec<Vec<f32>>>,\n+        documents: Option<Vec<Option<String>>>,\n+        uris: Option<Vec<Option<String>>>,\n+        metadatas: Option<Vec<Option<Metadata>>>,\n+    ) -> Self {\n+        Self {\n+            ids,\n+            embeddings,\n+            documents,\n+            uris,\n+            metadatas,\n+        }\n+    }\n }\n \n /// Adds records to a collection.\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.0.3\",\n+  \"version\": \"0.0.4\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\nChoice B:\nk8s/test/minio.yaml\n@@ -16,7 +16,9 @@ spec:\n     spec:\n       volumes:\n         - name: minio\n-          emptyDir: {}\n+          emptyDir:\n+            medium: Memory\n+            sizeLimit: 2Gi\n       containers:\n         - name: minio\n           image: minio/minio:latest\n@@ -46,7 +48,7 @@ metadata:\n spec:\n   ports:\n     - name: http\n-    # Put the lb on a different port so we can run minio locally since the port is already in use\n+      # Put the lb on a different port so we can run minio locally since the port is already in use\n       port: 9001\n       targetPort: 9000\n   selector:\n---\nrust/garbage_collector/src/operators/delete_unused_files.rs\n@@ -147,27 +147,30 @@ impl Operator<DeleteUnusedFilesInput, DeleteUnusedFilesOutput> for DeleteUnusedF\n             CleanupMode::Delete | CleanupMode::DeleteV2 => {\n                 // Hard delete - remove the file\n                 if !all_files.is_empty() {\n-                    let mut delete_stream = futures::stream::iter(all_files.clone())\n-                        .map(move |file_path| self.delete_with_path(file_path))\n-                        .buffer_unordered(100);\n-\n-                    // Process any errors that occurred\n-                    while let Some(result) = delete_stream.next().await {\n-                        if let Err(e) = result {\n-                            match e {\n-                                StorageError::NotFound { path, source } => {\n-                                    tracing::info!(\"Rename file {path} not found: {source}\")\n-                                }\n-                                err => tracing::error!(\"Failed to delete: {err}\"),\n-                            }\n-                        }\n-                    }\n+                    // let mut delete_stream = futures::stream::iter(all_files.clone())\n+                    //     .map(move |file_path| self.delete_with_path(file_path))\n+                    //     .buffer_unordered(100);\n+\n+                    // // Process any errors that occurred\n+                    // while let Some(result) = delete_stream.next().await {\n+                    //     if let Err(e) = result {\n+                    //         match e {\n+                    //             StorageError::NotFound { path, source } => {\n+                    //                 tracing::info!(\"Rename file {path} not found: {source}\")\n+                    //             }\n+                    //             err => tracing::error!(\"Failed to delete: {err}\"),\n+                    //         }\n+                    //     }\n+                    // }\n+\n+                    self.storage.delete_many(all_files).await.unwrap();\n                 }\n             }\n         }\n \n         Ok(DeleteUnusedFilesOutput {\n-            deleted_files: all_files.into_iter().collect(),\n+            // deleted_files: all_files.into_iter().collect(),\n+            deleted_files: HashSet::new(),\n         })\n     }\n }\n---\nrust/storage/src/lib.rs\n@@ -302,6 +302,15 @@ impl Storage {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        match self {\n+            Storage::ObjectStore(object_store) => object_store.delete_many(keys).await,\n+            Storage::S3(s3) => s3.delete_many(keys).await,\n+            Storage::Local(_) => unimplemented!(),\n+            Storage::AdmissionControlledS3(_) => unimplemented!(),\n+        }\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         match self {\n             Storage::ObjectStore(object_store) => object_store.rename(src_key, dst_key).await,\n---\nrust/storage/src/object_store.rs\n@@ -284,6 +284,30 @@ impl ObjectStore {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        let mut locations = Vec::new();\n+        for key in keys {\n+            locations.push(Ok(Path::from(key)));\n+        }\n+\n+        let mut stream = self\n+            .object_store\n+            .delete_stream(futures::stream::iter(locations).boxed());\n+\n+        while let Some(result) = stream.next().await {\n+            match result {\n+                Ok(_) => {\n+                    tracing::info!(\"Successfully deleted object\");\n+                }\n+                Err(e) => {\n+                    tracing::error!(error = %e, \"Failed to delete object\");\n+                    return Err(e.into());\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         tracing::info!(src = %src_key, dst = %dst_key, \"Renaming object\");\n \n---\nrust/storage/src/s3.rs\n@@ -647,6 +647,49 @@ impl S3Storage {\n         }\n     }\n \n+    pub async fn delete_many(&self, keys: Vec<String>) -> Result<(), StorageError> {\n+        tracing::debug!(keys = ?keys, \"Deleting multiple objects from S3\");\n+\n+        // batch by 1000 keys as per S3 limits\n+        let mut futures = Vec::new();\n+        for chunk in keys.chunks(1000) {\n+            let delete_req = self.client.delete_objects().bucket(&self.bucket).delete(\n+                aws_sdk_s3::types::Delete::builder()\n+                    .set_objects(Some(\n+                        chunk\n+                            .iter()\n+                            .map(|key| {\n+                                aws_sdk_s3::types::ObjectIdentifier::builder()\n+                                    .key(key)\n+                                    .build()\n+                                    .unwrap()\n+                            })\n+                            .collect::<Vec<_>>(),\n+                    ))\n+                    .build()\n+                    .unwrap(),\n+            );\n+\n+            futures.push(delete_req.send());\n+        }\n+        let results = futures::future::join_all(futures).await;\n+        for res in results {\n+            match res {\n+                Ok(_) => {\n+                    tracing::debug!(\"Successfully deleted objects from S3\");\n+                }\n+                Err(e) => {\n+                    tracing::error!(error = %e, \"Failed to delete objects from S3\");\n+                    return Err(StorageError::Generic {\n+                        source: Arc::new(e.into_service_error()),\n+                    });\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     pub async fn rename(&self, src_key: &str, dst_key: &str) -> Result<(), StorageError> {\n         tracing::info!(src = %src_key, dst = %dst_key, \"Renaming object in S3\");\n \n---\n\n\n---\n\nChoice C:\nDockerfile\n@@ -69,4 +69,3 @@ EXPOSE 8000\n \n ENTRYPOINT [\"/docker_entrypoint.sh\"]\n CMD [ \"--workers ${CHROMA_WORKERS} --host ${CHROMA_HOST_ADDR} --port ${CHROMA_HOST_PORT} --proxy-headers --reload --log-config ${CHROMA_LOG_CONFIG} --timeout-keep-alive ${CHROMA_TIMEOUT_KEEP_ALIVE}\"]\n-\n---\nDockerfile.windows\n@@ -1,14 +1,15 @@\n FROM python:3.11.9\n ARG REBUILD_HNSWLIB\n-\n SHELL [\"powershell\", \"-Command\", \"$ErrorActionPreference = 'Stop'; $ProgressPreference = 'SilentlyContinue';\"]\n RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; `Invoke-WebRequest \"https://aka.ms/vs/17/release/vc_redist.x64.exe\" -OutFile \"vc_redist.x64.exe\"; `Start-Process -filepath C:\\vc_redist.x64.exe -ArgumentList \"/install\", \"/passive\", \"/norestart\" -Passthru | Wait-Process; `Remove-Item -Force vc_redist.x64.exe;\n \n WORKDIR C:\\\\chroma\n \n COPY ./requirements.txt requirements.txt\n+COPY ./requirements_dev.txt requirements_dev.txt\n \n RUN pip install --no-cache-dir --upgrade -r requirements.txt\n+RUN pip install --no-cache-dir --upgrade -r requirements_dev.txt\n RUN if ($env:REBUILD_HNSWLIB -eq 'true') { pip install --no-binary :all: --force-reinstall --no-cache-dir chroma-hnswlib }\n \n COPY ./bin/docker_entrypoint.ps1 C:\\\\docker_entrypoint.ps1\n@@ -19,7 +20,6 @@ ENV CHROMA_HOST_PORT 8000\n ENV CHROMA_WORKERS 1\n ENV CHROMA_LOG_CONFIG \"chromadb/log_config.yml\"\n ENV CHROMA_TIMEOUT_KEEP_ALIVE 30\n-\n EXPOSE 8000\n \n ENTRYPOINT [\"powershell\", \"C:\\\\\\\\docker_entrypoint.ps1\"]\n---\nchromadb/test/utils/cross_version.py\n@@ -55,7 +55,10 @@ def install(pkg: str, path: str, dep_overrides: Dict[str, str]) -> int:\n     for dep, operator_version in dep_overrides.items():\n         command.append(f\"{dep}{operator_version}\")\n \n-    command.append(\"--no-binary=chroma-hnswlib\")\n+    # Only add --no-binary=chroma-hnswlib if it's in the dependencies\n+    if \"chroma-hnswlib\" in pkg or any(\"chroma-hnswlib\" in dep for dep in dep_overrides):\n+        command.append(\"--no-binary=chroma-hnswlib\")\n+\n     command.append(f\"--target={path}\")\n \n     print(f\"Installing chromadb version {pkg} to {path}\")\n---\npyproject.toml\n@@ -7,7 +7,10 @@ description = \"Chroma.\"\n readme = \"README.md\"\n requires-python = \">=3.9\"\n classifiers = [\"Programming Language :: Python :: 3\", \"License :: OSI Approved :: Apache Software License\", \"Operating System :: OS Independent\"]\n-dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'chroma-hnswlib==0.7.6', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+\n+[project.optional-dependencies]\n+dev = ['chroma-hnswlib==0.7.6']\n \n [tool.black]\n line-length = 88\n---\nrequirements.txt\n@@ -1,5 +1,4 @@\n bcrypt>=4.0.1\n-chroma-hnswlib==0.7.6\n fastapi==0.115.9\n graphlib_backport==1.0.3; python_version < '3.9'\n grpcio>=1.58.0\n---\nrequirements_dev.txt\n@@ -1,5 +1,6 @@\n black==23.3.0 # match what's in pyproject.toml\n build\n+chroma-hnswlib==0.7.6\n grpcio-tools==1.67.1 # Later version not compatible with protobuf 4.25.5\n httpx\n hypothesis==6.112.2 # TODO: Resolve breaking changes and bump version\n---\n\n\n---\n\nChoice D:\nclients/js/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"chromadb-root\",\n   \"private\": true,\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma\",\n   \"keywords\": [],\n   \"author\": \"\",\n---\nclients/js/packages/chromadb-client/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-client\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as peer dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n---\nclients/js/packages/chromadb-core/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"@internal/chromadb-core\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"private\": true,\n   \"description\": \"Core functionality for ChromaDB JavaScript client\",\n   \"license\": \"Apache-2.0\",\n---\nclients/js/packages/chromadb/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb\",\n-  \"version\": \"2.4.6\",\n+  \"version\": \"2.4.7\",\n   \"description\": \"A JavaScript interface for chroma with embedding functions as bundled dependencies\",\n   \"license\": \"Apache-2.0\",\n   \"type\": \"module\",\n@@ -51,11 +51,11 @@\n     \"typescript\": \"^5.0.4\"\n   },\n   \"optionalDependencies\": {\n-    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.2\",\n-    \"chromadb-js-bindings-darwin-x64\": \"^0.1.2\",\n-    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.2\",\n-    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.2\",\n-    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.2\"\n+    \"chromadb-js-bindings-darwin-arm64\": \"^0.1.3\",\n+    \"chromadb-js-bindings-darwin-x64\": \"^0.1.3\",\n+    \"chromadb-js-bindings-linux-arm64-gnu\": \"^0.1.3\",\n+    \"chromadb-js-bindings-linux-x64-gnu\": \"^0.1.3\",\n+    \"chromadb-js-bindings-win32-x64-msvc\": \"^0.1.3\"\n   },\n   \"engines\": {\n     \"node\": \">=14.17.0\"\n---\nrust/js_bindings/npm/darwin-arm64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-arm64\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/darwin-x64/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-darwin-x64\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"darwin\"\n   ],\n---\nrust/js_bindings/npm/linux-arm64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-arm64-gnu\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/linux-x64-gnu/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-linux-x64-gnu\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"linux\"\n   ],\n---\nrust/js_bindings/npm/win32-arm64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-arm64-msvc\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"win32\"\n   ],\n---\nrust/js_bindings/npm/win32-x64-msvc/package.json\n@@ -1,6 +1,6 @@\n {\n   \"name\": \"chromadb-js-bindings-win32-x64-msvc\",\n-  \"version\": \"0.1.2\",\n+  \"version\": \"0.1.3\",\n   \"os\": [\n     \"win32\"\n   ],\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nbefore:\r\n![image](https://github.com/user-attachments/assets/ac46dc39-a148-4400-8042-cdd8e5514825)\r\n\r\nafter:\r\n![image](https://github.com/user-attachments/assets/5aa15799-50cc-4b76-8ec9-a24577000f21)\r\n\r\n\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nrust/segment/src/sqlite_metadata.rs\n@@ -705,28 +705,62 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            filter_limit_query\n-                .left_join(\n+            let (references_metadata, references_document) = whr.analyze_where_references();\n+            if references_metadata {\n+                filter_limit_query.inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n-                )\n-                .left_join(\n+                );\n+            } else if metadata {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            }\n+            if references_document {\n+                filter_limit_query.inner_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n-                )\n-                .distinct()\n-                .cond_where(whr.eval());\n+                );\n+            } else if document {\n+                filter_limit_query.left_join(\n+                    EmbeddingFulltextSearch::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n+                        EmbeddingFulltextSearch::Table,\n+                        EmbeddingFulltextSearch::Rowid,\n+                    )),\n+                );\n+            }\n+            filter_limit_query.distinct().cond_where(whr.eval());\n+        } else {\n+            if metadata {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            }\n+\n+            if document {\n+                filter_limit_query.left_join(\n+                    EmbeddingFulltextSearch::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n+                        EmbeddingFulltextSearch::Table,\n+                        EmbeddingFulltextSearch::Rowid,\n+                    )),\n+                );\n+            }\n         }\n \n         filter_limit_query\n             .order_by((Embeddings::Table, Embeddings::Id), sea_query::Order::Asc)\n             .offset(skip as u64)\n             .limit(fetch.unwrap_or(u32::MAX) as u64);\n-\n         let alias = Alias::new(SUBQ_ALIAS);\n         let mut projection_query = Query::select();\n         projection_query\n---\nrust/types/src/metadata.rs\n@@ -560,6 +560,26 @@ impl Where {\n             },\n         }\n     }\n+\n+    pub fn analyze_where_references(&self) -> (bool, bool) {\n+        let mut references_metadata = false;\n+        let mut references_document = false;\n+\n+        match self {\n+            Where::Composite(expr) => {\n+                // For composite expressions, recursively check all children\n+                for child in &expr.children {\n+                    let (child_meta, child_doc) = Self::analyze_where_references(&(child.clone()));\n+                    references_metadata |= child_meta;\n+                    references_document |= child_doc;\n+                }\n+            }\n+            Where::Document(_) => references_document = true,\n+            Where::Metadata(_) => references_metadata = true,\n+        }\n+\n+        (references_metadata, references_document)\n+    }\n }\n \n impl TryFrom<chroma_proto::Where> for Where {\n---\n\n\n---\n\nChoice B:\nrust/frontend/src/server.rs\n@@ -290,14 +290,23 @@ impl FrontendServer {\n         if let Some(cors_allow_origins) = cors_allow_origins {\n             let origins = cors_allow_origins\n                 .into_iter()\n-                .map(|origin| origin.parse().unwrap())\n+                .map(|origin| {\n+                    origin\n+                        .parse()\n+                        .unwrap_or_else(|_| panic!(\"Invalid origin: {}\", origin))\n+                })\n                 .collect::<Vec<_>>();\n \n-            let cors = CorsLayer::new()\n-                .allow_origin(origins)\n+            let mut cors_builder = CorsLayer::new()\n                 .allow_headers(tower_http::cors::Any)\n                 .allow_methods(tower_http::cors::Any);\n-            app = app.layer(cors);\n+            if origins.len() == 1 && origins[0] == \"*\" {\n+                cors_builder = cors_builder.allow_origin(tower_http::cors::Any);\n+            } else {\n+                cors_builder = cors_builder.allow_origin(origins);\n+            }\n+\n+            app = app.layer(cors_builder);\n         }\n \n         // TODO: tracing\n@@ -1972,6 +1981,54 @@ mod tests {\n         assert_eq!(allow_headers.unwrap(), \"*\");\n     }\n \n+    #[tokio::test]\n+    async fn test_cors_wildcard() {\n+        let registry = Registry::new();\n+        let system = System::new();\n+\n+        let port = random_port::PortPicker::new().pick().unwrap();\n+\n+        let mut config = FrontendServerConfig::single_node_default();\n+        config.port = port;\n+        config.cors_allow_origins = Some(vec![\"*\".to_string()]);\n+\n+        let frontend = Frontend::try_from_config(&(config.clone().frontend, system), &registry)\n+            .await\n+            .unwrap();\n+        let app = FrontendServer::new(\n+            config,\n+            frontend,\n+            vec![],\n+            Arc::new(()),\n+            Arc::new(()),\n+            System::new(),\n+        );\n+        tokio::task::spawn(async move {\n+            app.run().await;\n+        });\n+\n+        let client = reqwest::Client::new();\n+        let res = client\n+            .request(\n+                reqwest::Method::OPTIONS,\n+                format!(\"http://localhost:{}/api/v2/heartbeat\", port),\n+            )\n+            .header(\"Origin\", \"http://localhost:3000\")\n+            .send()\n+            .await\n+            .unwrap();\n+        assert_eq!(res.status(), 200);\n+\n+        let allow_origin = res.headers().get(\"Access-Control-Allow-Origin\");\n+        assert_eq!(allow_origin.unwrap(), \"*\");\n+\n+        let allow_methods = res.headers().get(\"Access-Control-Allow-Methods\");\n+        assert_eq!(allow_methods.unwrap(), \"*\");\n+\n+        let allow_headers = res.headers().get(\"Access-Control-Allow-Headers\");\n+        assert_eq!(allow_headers.unwrap(), \"*\");\n+    }\n+\n     #[tokio::test]\n     async fn test_defaults_to_json_content_type() {\n         let port = test_server().await;\n---\n\n\n---\n\nChoice C:\nk8s/distributed-chroma/values.dev.yaml\n@@ -33,3 +33,6 @@ compactionService:\n       value: 'value: \"1\"'\n     - name: CONFIG_PATH\n       value: 'value: \"/tilt_config.yaml\"'\n+\n+rustLogService:\n+  replicaCount: 2\n---\n\n\n---\n\nChoice D:\ngo/pkg/log/repository/log.go\n@@ -153,17 +153,6 @@ func (r *LogRepository) PullRecords(ctx context.Context, collectionId string, of\n }\n \n func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID string, targetCollectionID string) (compactionOffset uint64, enumerationOffset uint64, err error) {\n-\tfor retries := 0; retries < 3; retries++ {\n-\t\tcompactionOffset, enumerationOffset, err = r.innerForkRecords(ctx, sourceCollectionID, targetCollectionID)\n-\t\tif err == nil {\n-\t\t\treturn\n-\t\t}\n-\t\ttime.Sleep(time.Millisecond * 100 * (1 << retries))\n-\t}\n-\treturn\n-}\n-\n-func (r *LogRepository) innerForkRecords(ctx context.Context, sourceCollectionID string, targetCollectionID string) (compactionOffset uint64, enumerationOffset uint64, err error) {\n \tvar tx pgx.Tx\n \ttx, err = r.conn.BeginTx(ctx, pgx.TxOptions{})\n \tif err != nil {\n@@ -179,8 +168,7 @@ func (r *LogRepository) innerForkRecords(ctx context.Context, sourceCollectionID\n \t\t}\n \t}()\n \n-\tvar sourceBounds log.GetBoundsForCollectionRow\n-\tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n+\tsourceBounds, err := queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in getting compaction and enumeration offset for source collection\", zap.Error(err), zap.String(\"collectionId\", sourceCollectionID))\n \t\treturn\n@@ -193,35 +181,34 @@ func (r *LogRepository) innerForkRecords(ctx context.Context, sourceCollectionID\n \t\ttrace_log.Error(\"Error forking log record\", zap.String(\"sourceCollectionID\", sourceCollectionID))\n \t\treturn\n \t}\n-\t_, err = queriesWithTx.InsertCollection(ctx, log.InsertCollectionParams{\n-\t\tID:                              targetCollectionID,\n-\t\tRecordCompactionOffsetPosition:  int64(sourceBounds.RecordCompactionOffsetPosition),\n-\t\tRecordEnumerationOffsetPosition: int64(sourceBounds.RecordEnumerationOffsetPosition),\n-\t})\n+\ttargetBounds, err := queriesWithTx.GetMinimumMaximumOffsetForCollection(ctx, targetCollectionID)\n \tif err != nil {\n-\t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n+\t\ttrace_log.Error(\"Error in deriving compaction and enumeration offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n \t\treturn\n \t}\n-\tvar targetBounds log.GetMinimumMaximumOffsetForCollectionRow\n-\ttargetBounds, err = queriesWithTx.GetMinimumMaximumOffsetForCollection(ctx, targetCollectionID)\n-\tif err != nil {\n-\t\ttrace_log.Error(\"Error in getting minimax for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n-\t\treturn\n+\n+\tif targetBounds.MinOffset == 0 {\n+\t\t// Either the source collection is not compacted yet or no log is forked\n+\t\tcompactionOffset = uint64(sourceBounds.RecordCompactionOffsetPosition)\n+\t} else {\n+\t\t// Some logs are forked, the min offset is guaranteed to be larger than source compaction offset\n+\t\tcompactionOffset = uint64(targetBounds.MinOffset - 1)\n \t}\n-\tif targetBounds.MinOffset > 0 && targetBounds.MinOffset != sourceBounds.RecordCompactionOffsetPosition + 1 {\n-\t\ttrace_log.Error(\"Race condition: Someone adjusted records during our transaction\",\n-\t\t\tzap.String(\"collectionId\", targetCollectionID),\n-\t\t\tzap.Int64(\"MinOffset\", targetBounds.MinOffset),\n-\t\t\tzap.Int64(\"CompactionOffset+1\", sourceBounds.RecordCompactionOffsetPosition + 1))\n-\t\terr = errors.New(\"concurrent updates caused fork to fail on compaction offset\")\n-\t\treturn\n+\tif targetBounds.MaxOffset == 0 {\n+\t\t// Either the source collection is empty or no log is forked\n+\t\tenumerationOffset = uint64(sourceBounds.RecordEnumerationOffsetPosition)\n+\t} else {\n+\t\t// Some logs are forked. The max offset is the enumeration offset\n+\t\tenumerationOffset = uint64(targetBounds.MaxOffset)\n \t}\n-\tif targetBounds.MaxOffset > 0 && targetBounds.MaxOffset != sourceBounds.RecordEnumerationOffsetPosition {\n-\t\ttrace_log.Error(\"Race condition: Someone adjusted records during our transaction\",\n-\t\t\tzap.String(\"collectionId\", targetCollectionID),\n-\t\t\tzap.Int64(\"MaxOffset\", targetBounds.MaxOffset),\n-\t\t\tzap.Int64(\"EnumerationOffset\", sourceBounds.RecordEnumerationOffsetPosition))\n-\t\terr = errors.New(\"concurrent updates caused fork to fail on enumeration offset\")\n+\n+\t_, err = queriesWithTx.InsertCollection(ctx, log.InsertCollectionParams{\n+\t\tID:                              targetCollectionID,\n+\t\tRecordCompactionOffsetPosition:  int64(compactionOffset),\n+\t\tRecordEnumerationOffsetPosition: int64(enumerationOffset),\n+\t})\n+\tif err != nil {\n+\t\ttrace_log.Error(\"Error in updating offset for target collection\", zap.Error(err), zap.String(\"collectionId\", targetCollectionID))\n \t\treturn\n \t}\n \treturn\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - There are valid cases for this log pull to fail, it is not an invariant violation as stated.\r\n  - If the log is failed to be updated with the latest compaction offset (Which is best-effort), but the sysdb was, the log may schedule a collection for compaction that has no records outstanding. This leads to hitting this case, which is valid. In the future we could repair the log.\r\n  - Forked collections will also run into this as the fork() call may copy the old log offset, but a compaction happens after, this leads to them disagreeing but progression is always forward, it manifests as the same issue above which is that the log is behind the sysdb.\r\n  - Keeping this as a `warn` because its worth monitoring this as it implies log service may be failing to get updated. Or that the fork race is commonly copying unnecessary data.\r\n- New functionality\r\n  - None\r\n\r\n## Test plan\r\n_How are these changes tested?_\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\nNone\r\n\n\n---\n\nChoice A:\nrust/worker/src/execution/orchestration/compact.rs\n@@ -794,10 +794,14 @@ impl Handler<TaskResult<FetchLogOutput, FetchLogError>> for CompactOrchestrator\n                 tracing::info!(\"Pulled Logs Up To Offset: {:?}\", self.pulled_log_offset);\n             }\n             None => {\n+                tracing::warn!(\"No logs were pulled from the log service, this can happen when the log compaction offset is behing the sysdb.\");\n+                // TODO(hammadb): We can repair the log service's understanding of the offset here, as this only happens\n+                // when the log service is not up to date on the latest compacted offset, which leads it to schedule an already\n+                // compacted collection.\n                 self.terminate_with_result(\n-                    Err(CompactionError::InvariantViolation(\n-                        \"Logs should be present for compaction\",\n-                    )),\n+                    Ok(CompactionResponse {\n+                        collection_id: self.collection_id,\n+                    }),\n                     ctx,\n                 )\n                 .await;\n---\n\n\n---\n\nChoice B:\nrust/frontend/src/tower_tracing.rs\n@@ -6,6 +6,7 @@ use opentelemetry::trace::TraceContextExt;\n use std::time::Duration;\n use tower::Service;\n use tower_http::trace::{MakeSpan, OnResponse, TraceLayer};\n+use tracing::Instrument;\n \n use tracing_opentelemetry::OpenTelemetrySpanExt;\n \n@@ -16,8 +17,7 @@ impl<B> MakeSpan<B> for RequestTracing {\n         let http_route = request\n             .extensions()\n             .get::<MatchedPath>()\n-            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str())\n-            .to_owned();\n+            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str());\n \n         let host = request\n             .headers()\n@@ -56,15 +56,18 @@ impl<B> OnResponse<B> for RequestTracing {\n     }\n }\n \n+/// TracingMiddleware adds trace ID to the response headers\n+/// and wraps the inner handler with a span.\n #[derive(Clone)]\n-pub struct TraceIdMiddleware<S> {\n+pub struct TracingMiddleware<S> {\n     inner: S,\n }\n \n-impl<S, Request, Rs> Service<Request> for TraceIdMiddleware<S>\n+impl<S, B, Rs> Service<Request<B>> for TracingMiddleware<S>\n where\n-    S: Service<Request, Response = Response<Rs>> + Send + 'static,\n+    S: Service<Request<B>, Response = Response<Rs>> + Send + 'static,\n     S::Future: Send + 'static,\n+    B: Send + 'static,\n {\n     type Response = S::Response;\n     type Error = S::Error;\n@@ -77,10 +80,23 @@ where\n         self.inner.poll_ready(cx)\n     }\n \n-    fn call(&mut self, req: Request) -> Self::Future {\n+    fn call(&mut self, req: Request<B>) -> Self::Future {\n+        let http_route = req\n+            .extensions()\n+            .get::<MatchedPath>()\n+            .map_or_else(|| \"(unknown route)\", |mp| mp.as_str());\n+\n+        let handler_span = tracing::span!(\n+            tracing::Level::DEBUG,\n+            \"HTTP request handler\",\n+            http.route = http_route,\n+            otel.name = format!(\"Handler {} {}\", req.method(), http_route),\n+        );\n+\n         let future = self.inner.call(req);\n+\n         Box::pin(async move {\n-            let mut response: Response<Rs> = future.await?;\n+            let mut response: Response<Rs> = future.instrument(handler_span).await?;\n             if response.status().is_client_error() || response.status().is_server_error() {\n                 let trace_id = tracing::Span::current()\n                     .context()\n@@ -109,10 +125,10 @@ impl SetTraceIdLayer {\n }\n \n impl<S> tower::layer::Layer<S> for SetTraceIdLayer {\n-    type Service = TraceIdMiddleware<S>;\n+    type Service = TracingMiddleware<S>;\n \n     fn layer(&self, inner: S) -> Self::Service {\n-        TraceIdMiddleware { inner }\n+        TracingMiddleware { inner }\n     }\n }\n \n---\n\n\n---\n\nChoice C:\nCargo.lock\n@@ -1442,7 +1442,7 @@ dependencies = [\n \n [[package]]\n name = \"chroma-cli\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n dependencies = [\n  \"arboard\",\n  \"axum 0.8.1\",\n---\nclients/js/packages/chromadb/src/cli.ts\n@@ -23,7 +23,7 @@ const update = async (): Promise<void> => {\n     const installedVersion = process.env.CHROMADB_VERSION || \"0.0.0\";\n     const latestVersion = await getLatestVersion(\"chromadb\");\n \n-    if (semver.lte(installedVersion, latestVersion)) {\n+    if (semver.lt(installedVersion, latestVersion)) {\n       console.log(`\\nA new chromadb version (${latestVersion}) is available!`);\n       console.log(\"\\n\\x1b[4mUpdat with npm\\x1b[0m\");\n       console.log(\"npm install chromadb@latest\");\n---\nrust/cli/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"chroma-cli\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n edition = \"2021\"\n \n [dependencies]\n---\nrust/cli/src/commands/install.rs\n@@ -390,7 +390,7 @@ async fn get_app(\n         Version::parse(&app.cli_version).map_err(|_| InstallError::ListingFailed)?;\n     let cli_version =\n         Version::parse(env!(\"CARGO_PKG_VERSION\")).map_err(|_| InstallError::ListingFailed)?;\n-    if app_cli_version < cli_version {\n+    if app_cli_version > cli_version {\n         return Err(\n             InstallError::VersionMismatch(app_name.clone(), app_cli_version.to_string()).into(),\n         );\n---\nrust/cli/src/commands/update.rs\n@@ -2,6 +2,7 @@ use crate::utils::CliError;\n use colored::Colorize;\n use regex::Regex;\n use semver::Version;\n+use serde::Deserialize;\n use std::error::Error;\n use thiserror::Error;\n \n@@ -19,25 +20,26 @@ pub enum UpdateError {\n     UpdateFailed,\n }\n \n+#[derive(Debug, Deserialize)]\n+struct Release {\n+    tag_name: String,\n+}\n+\n async fn version_check(current_version: Version) -> Result<(), Box<dyn Error>> {\n     let client = reqwest::Client::new();\n-    let response = client\n+    let releases = client\n         .get(GITHUB_RELEASES_URL)\n         .header(\"User-Agent\", \"reqwest\")\n         .send()\n+        .await?\n+        .json::<Vec<Release>>()\n         .await?;\n \n-    if !response.status().is_success() {\n-        return Err(UpdateError::FailedVersionFetch.into());\n-    }\n-\n-    let releases: Vec<String> = response.json().await?;\n-\n     let cli_version_pattern = Regex::new(r\"^cli-(\\d+\\.\\d+\\.\\d+)$\")?;\n     let mut cli_versions = Vec::new();\n \n     for release in releases {\n-        if let Some(caps) = cli_version_pattern.captures(&release) {\n+        if let Some(caps) = cli_version_pattern.captures(&release.tag_name) {\n             if let Some(ver_match) = caps.get(1) {\n                 let ver_str = ver_match.as_str();\n                 if let Ok(ver) = Version::parse(ver_str) {\n---\n\n\n---\n\nChoice D:\nrust/worker/src/execution/orchestration/compact.rs\n@@ -794,10 +794,14 @@ impl Handler<TaskResult<FetchLogOutput, FetchLogError>> for CompactOrchestrator\n                 tracing::info!(\"Pulled Logs Up To Offset: {:?}\", self.pulled_log_offset);\n             }\n             None => {\n+                tracing::warn!(\"No logs were pulled from the log service, this can happen when the log compaction offset is behing the sysdb.\");\n+                // TODO(hammadb): We can repair the log service's understanding of the offset here, as this only happens\n+                // when the log service is not up to date on the latest compacted offset, which leads it to schedule an already\n+                // compacted collection.\n                 self.terminate_with_result(\n-                    Err(CompactionError::InvariantViolation(\n-                        \"Logs should be present for compaction\",\n-                    )),\n+                    Ok(CompactionResponse {\n+                        collection_id: self.collection_id,\n+                    }),\n                     ctx,\n                 )\n                 .await;\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Introduces this usage type with a default of 0\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nNone\n\n\n---\n\nChoice A:\nrust/frontend/src/quota/mod.rs\n@@ -240,6 +240,7 @@ pub enum UsageType {\n     NumCollections,        // Total number of collections for a tenant\n     NumDatabases,          // Total number of databases for a tenant\n     NumQueryIDs,           // Number of IDs to filter by in a query\n+    NumRegexPredicates,    // Number of regex predicates in the where_document\n }\n \n impl fmt::Display for UsageType {\n@@ -269,6 +270,7 @@ impl fmt::Display for UsageType {\n             UsageType::NumCollections => write!(f, \"Number of collections\"),\n             UsageType::NumDatabases => write!(f, \"Number of databases\"),\n             UsageType::NumQueryIDs => write!(f, \"Number of IDs to filter by in a query\"),\n+            UsageType::NumRegexPredicates => write!(f, \"Number of regex predicates\"),\n         }\n     }\n }\n@@ -298,6 +300,7 @@ impl TryFrom<&str> for UsageType {\n             \"num_collections\" => Ok(UsageType::NumCollections),\n             \"num_databases\" => Ok(UsageType::NumDatabases),\n             \"num_query_ids\" => Ok(UsageType::NumQueryIDs),\n+            \"num_regex_predicates\" => Ok(UsageType::NumRegexPredicates),\n             _ => Err(format!(\"Invalid UsageType: {}\", value)),\n         }\n     }\n@@ -326,6 +329,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumCollections, 1_000_000);\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n+        m.insert(UsageType::NumRegexPredicates, 0);\n         m\n     };\n }\n---\n\n\n---\n\nChoice B:\nrust/garbage_collector/src/operators/compute_unused_files.rs\n@@ -1,5 +1,5 @@\n use async_trait::async_trait;\n-use chroma_blockstore::RootManager;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n use chroma_cache::nop::NopCache;\n use chroma_error::{ChromaError, ErrorCodes};\n use chroma_storage::Storage;\n@@ -145,14 +145,14 @@ impl ComputeUnusedFilesOperator {\n         for si_id in si_ids {\n             let uuid = Uuid::parse_str(&si_id).map_err(|e| {\n                 tracing::error!(error = %e, \"Failed to parse UUID\");\n-                ComputeUnusedFilesError::ParseError(si_id.clone(), e.to_string())\n+                ComputeUnusedFilesError::InvalidUuid(e, si_id.clone())\n             })?;\n \n             let block_ids = match self.root_manager.get_all_block_ids(&uuid).await {\n                 Ok(ids) => ids,\n                 Err(e) => {\n                     tracing::error!(error = %e, \"Failed to get block IDs\");\n-                    return Err(ComputeUnusedFilesError::ParseError(si_id, e.to_string()));\n+                    return Err(ComputeUnusedFilesError::FailedToFetchBlockIDs(e));\n                 }\n             };\n             tracing::debug!(\n@@ -193,8 +193,10 @@ pub struct ComputeUnusedFilesOutput {\n \n #[derive(Error, Debug)]\n pub enum ComputeUnusedFilesError {\n-    #[error(\"Error parsing sparse index file: {0}\")]\n-    ParseError(String, String),\n+    #[error(\"Error parsing UUID: {0} from {1}\")]\n+    InvalidUuid(uuid::Error, String),\n+    #[error(\"Failed to fetch block IDs: {0}\")]\n+    FailedToFetchBlockIDs(RootManagerError),\n     #[error(\"Version file has missing content\")]\n     VersionFileMissingContent(i64),\n     #[error(\"Version history is missing\")]\n---\n\n\n---\n\nChoice C:\nrust/js_bindings/Cargo.toml\n@@ -14,7 +14,3 @@ chroma-cli = { workspace = true }\n \n [build-dependencies]\n napi-build = \"2.0.1\"\n-\n-[profile.release]\n-lto = true\n-strip = \"symbols\"\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -1,4 +1,4 @@\n-from typing import Dict, Optional\n+from typing import Dict, Optional, Union\n import logging\n from chromadb.api.client import Client as ClientCreator\n from chromadb.api.client import AdminClient as AdminClientCreator\n@@ -26,6 +26,7 @@\n     WhereDocument,\n     UpdateCollectionMetadata,\n )\n+from pathlib import Path\n \n # Re-export types from chromadb.types\n __all__ = [\n@@ -135,7 +136,7 @@ def EphemeralClient(\n \n \n def PersistentClient(\n-    path: str = \"./chroma\",\n+    path: Union[str, Path] = \"./chroma\",\n     settings: Optional[Settings] = None,\n     tenant: str = DEFAULT_TENANT,\n     database: str = DEFAULT_DATABASE,\n@@ -151,7 +152,7 @@ def PersistentClient(\n     \"\"\"\n     if settings is None:\n         settings = Settings()\n-    settings.persist_directory = path\n+    settings.persist_directory = str(path)\n     settings.is_persistent = True\n \n     # Make sure paramaters are the correct types -- users can pass anything.\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nreplaces metadata group by and havign with distinct and where.\r\n\r\nbefore:\r\n![image](https://github.com/user-attachments/assets/34625ab8-b010-4108-a979-7a771eed3823)\r\nafter:\r\n![image](https://github.com/user-attachments/assets/2db7b4eb-6f34-42f0-a3bc-04aebc301c4b)\r\n\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nrust/segment/src/sqlite_metadata.rs\n@@ -381,10 +381,6 @@ trait IntoSqliteExpr {\n     /// We need to use `Min` and `Max` as a workaround\n     /// In SQLite, boolean can be implicitly treated as binary integer\n     fn eval(&self) -> SimpleExpr;\n-\n-    fn one() -> SimpleExpr {\n-        Expr::value(1)\n-    }\n }\n \n impl IntoSqliteExpr for Where {\n@@ -460,16 +456,21 @@ impl IntoSqliteExpr for Where {\n \n impl IntoSqliteExpr for CompositeExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let mut expr = Self::one();\n-        for child in &self.children {\n-            expr = expr.mul(match self.operator {\n-                BooleanOperator::And => child.eval(),\n-                BooleanOperator::Or => Self::one().sub(child.eval()),\n-            })\n-        }\n         match self.operator {\n-            BooleanOperator::And => expr,\n-            BooleanOperator::Or => Self::one().sub(expr),\n+            BooleanOperator::And => {\n+                let mut expr = SimpleExpr::Value(sea_query::Value::Bool(Some(true)));\n+                for child in &self.children {\n+                    expr = Expr::expr(expr).and(child.eval());\n+                }\n+                expr\n+            }\n+            BooleanOperator::Or => {\n+                let mut expr = SimpleExpr::Value(sea_query::Value::Bool(Some(false)));\n+                for child in &self.children {\n+                    expr = Expr::expr(expr).or(child.eval());\n+                }\n+                expr\n+            }\n         }\n     }\n }\n@@ -506,24 +507,36 @@ impl IntoSqliteExpr for MetadataExpression {\n                     MetadataValue::Str(s) => (EmbeddingMetadata::StringValue, Expr::val(s)),\n                 };\n                 let scol = Expr::col((EmbeddingMetadata::Table, col));\n+                let mut subq = Query::select()\n+                    .column(EmbeddingMetadata::Id)\n+                    .from(EmbeddingMetadata::Table)\n+                    .and_where(key_cond.clone())\n+                    .to_owned();\n+\n                 match op {\n                     PrimitiveOperator::Equal => {\n-                        Expr::expr(key_cond.and(scol.eq(sval).is(true))).max()\n+                        subq.and_where(scol.eq(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::NotEqual => {\n-                        Expr::expr(key_cond.and(scol.eq(sval).is(true)).not()).min()\n+                        subq.and_where(scol.eq(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq)\n                     }\n                     PrimitiveOperator::GreaterThan => {\n-                        Expr::expr(key_cond.and(scol.gt(sval).is(true))).max()\n+                        subq.and_where(scol.gt(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::GreaterThanOrEqual => {\n-                        Expr::expr(key_cond.and(scol.gte(sval).is(true))).max()\n+                        subq.and_where(scol.gte(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::LessThan => {\n-                        Expr::expr(key_cond.and(scol.lt(sval).is(true))).max()\n+                        subq.and_where(scol.lt(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::LessThanOrEqual => {\n-                        Expr::expr(key_cond.and(scol.lte(sval).is(true))).max()\n+                        subq.and_where(scol.lte(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                 }\n             }\n@@ -547,10 +560,20 @@ impl IntoSqliteExpr for MetadataExpression {\n                     ),\n                 };\n                 let scol = Expr::col((EmbeddingMetadata::Table, col));\n-                let val_in = key_cond.and(scol.is_in(svals).is(true));\n+                let subq = Query::select()\n+                    .column(EmbeddingMetadata::Id)\n+                    .from(EmbeddingMetadata::Table)\n+                    .and_where(key_cond.clone())\n+                    .and_where(scol.is_in(svals))\n+                    .to_owned();\n+\n                 match op {\n-                    SetOperator::In => Expr::expr(val_in).max(),\n-                    SetOperator::NotIn => Expr::expr(val_in.not()).min(),\n+                    SetOperator::In => {\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n+                    }\n+                    SetOperator::NotIn => {\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq)\n+                    }\n                 }\n             }\n         }\n@@ -658,15 +681,8 @@ impl SqliteMetadataReader {\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n                 )\n-                .add_group_by([\n-                    Expr::col((Embeddings::Table, Embeddings::Id)).into(),\n-                    Expr::col((\n-                        EmbeddingFulltextSearch::Table,\n-                        EmbeddingFulltextSearch::StringValue,\n-                    ))\n-                    .into(),\n-                ])\n-                .cond_having(whr.eval());\n+                .distinct()\n+                .cond_where(whr.eval());\n         }\n \n         filter_limit_query\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -398,9 +398,10 @@ impl DirtyMarker {\n             let num_records = rollup_pc.limit_log_position - rollup_pc.start_log_position;\n             let reinsert_count = rollup_pc.reinsert_count;\n             let initial_insertion_epoch_us = rollup_pc.initial_insertion_epoch_us;\n-            let to_compact = num_records >= record_count_threshold\n+            let to_compact = true/*\n+                || num_records >= record_count_threshold\n                 || now_us - initial_insertion_epoch_us >= timeout_us\n-                || reinsert_count >= reinsert_threshold;\n+                || reinsert_count >= reinsert_threshold*/;\n             if to_compact {\n                 compactable.push(collection_id);\n             }\n@@ -2063,6 +2064,7 @@ mod tests {\n                 },\n             ),\n         ];\n+        /*\n         assert!(DirtyMarker::rollup(\n             Arc::new(storage),\n             |storage, collection_id| async move {\n@@ -2084,6 +2086,7 @@ mod tests {\n         .await\n         .unwrap()\n         .is_none());\n+        */\n     }\n \n     #[tokio::test]\n---\n\n\n---\n\nChoice C:\nrust/cli/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"chroma-cli\"\n-version = \"1.1.1\"\n+version = \"1.1.2\"\n edition = \"2021\"\n \n [dependencies]\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.1.1\"\n+$release = \"cli-1.1.2\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.1.1\"\n+RELEASE=\"cli-1.1.2\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\n\n\n---\n\nChoice D:\ndocs/docs.trychroma.com/markdoc/content/reference/python/client.md\n@@ -272,7 +272,7 @@ List all collections.\n \n **Returns**:\n \n-- `Sequence[CollectionName]` - A list of collection names. `CollectionName` is a string.\n+- `Sequence[Collection]` - A list of collection objects.\n \n \n **Examples**:\n---\ndocs/docs.trychroma.com/markdoc/content/updates/migration.md\n@@ -26,6 +26,8 @@ In this release, we've rewritten much of Chroma in Rust. Performance has signifi\n \n Chroma no longer provides built-in authentication implementations.\n \n+`list_collections` now reverts back to returning `Collection` objects.\n+\n **Chroma in-process changes**\n \n This section is applicable to you if you use Chroma via\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nRemove sampling. Will leverage refinery for this instead.\r\n\r\n## Test plan\r\n\r\nThese changes are untested. However, it is now using (mostly) the same setup code as the other chroma services (which are working). So, we can test in staging after this is merged.\r\n\n\n---\n\nChoice A:\nk8s/test/load-service.yaml\n@@ -1,25 +1,16 @@\n----\n-\n-apiVersion: v1\n-kind: Namespace\n-metadata:\n-  name: chroma-load\n-\n----\n-\n apiVersion: apps/v1\n kind: Deployment\n metadata:\n   name: load-service\n-  namespace: chroma-load\n+  namespace: chroma\n spec:\n   replicas: 1\n   selector:\n     matchLabels:\n       app: load-service\n   template:\n     metadata:\n-      namespace: chroma-load\n+      namespace: chroma\n       labels:\n         app: load-service\n     spec:\n@@ -55,7 +46,7 @@ apiVersion: v1\n kind: ConfigMap\n metadata:\n   name: load-service-config\n-  namespace: chroma-load\n+  namespace: chroma\n data:\n   config.yaml: |\n     load_service:\n@@ -70,7 +61,7 @@ apiVersion: v1\n kind: Service\n metadata:\n   name: load-service\n-  namespace: chroma-load\n+  namespace: chroma\n spec:\n   ports:\n     - name: http\n---\n\n\n---\n\nChoice B:\nrust/load/src/opentelemetry_config.rs\n@@ -5,114 +5,41 @@\n \n use opentelemetry::global;\n use opentelemetry::trace::TracerProvider;\n-use opentelemetry_otlp::{WithExportConfig, WithHttpConfig};\n+use opentelemetry_otlp::WithExportConfig;\n use opentelemetry_sdk::propagation::TraceContextPropagator;\n use tracing_bunyan_formatter::BunyanFormattingLayer;\n use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Layer};\n \n-#[derive(Clone, Debug, Default)]\n-struct ChromaShouldSample;\n-\n-const BUSY_NS: opentelemetry::Key = opentelemetry::Key::from_static_str(\"busy_ns\");\n-const IDLE_NS: opentelemetry::Key = opentelemetry::Key::from_static_str(\"idle_ns\");\n-\n-fn is_slow(attributes: &[opentelemetry::KeyValue]) -> bool {\n-    let mut nanos = 0i64;\n-    for attr in attributes {\n-        if attr.key == BUSY_NS || attr.key == IDLE_NS {\n-            if let opentelemetry::Value::I64(ns) = attr.value {\n-                nanos += ns;\n-            }\n-        }\n-    }\n-    nanos > 20_000_000\n-}\n-\n-impl opentelemetry_sdk::trace::ShouldSample for ChromaShouldSample {\n-    fn should_sample(\n-        &self,\n-        _: Option<&opentelemetry::Context>,\n-        _: opentelemetry::trace::TraceId,\n-        name: &str,\n-        _: &opentelemetry::trace::SpanKind,\n-        attributes: &[opentelemetry::KeyValue],\n-        _: &[opentelemetry::trace::Link],\n-    ) -> opentelemetry::trace::SamplingResult {\n-        // NOTE(rescrv):  THIS IS A HACK!  If you find yourself seriously extending it, it's time\n-        // to investigate honeycomb's sampling capabilities.\n-\n-        // If the name is not get and not insert, or the request is slow, sample it.\n-        // Otherwise, drop.\n-        // This filters filters foyer calls in-process so they won't be overwhelming the tracing.\n-        if (name != \"get\" && name != \"insert\") || is_slow(attributes) {\n-            opentelemetry::trace::SamplingResult {\n-                decision: opentelemetry::trace::SamplingDecision::RecordAndSample,\n-                attributes: vec![],\n-                trace_state: opentelemetry::trace::TraceState::default(),\n-            }\n-        } else {\n-            opentelemetry::trace::SamplingResult {\n-                decision: opentelemetry::trace::SamplingDecision::Drop,\n-                attributes: vec![],\n-                trace_state: opentelemetry::trace::TraceState::default(),\n-            }\n-        }\n-    }\n-}\n-\n pub(crate) fn init_otel_tracing(service_name: &String, otel_endpoint: &String) {\n-    println!(\n+    tracing::info!(\n         \"Registering jaeger subscriber for {} at endpoint {}\",\n-        service_name, otel_endpoint\n+        service_name,\n+        otel_endpoint\n     );\n     let resource = opentelemetry_sdk::Resource::new(vec![opentelemetry::KeyValue::new(\n         \"service.name\",\n         service_name.clone(),\n     )]);\n \n     // Prepare tracer.\n-    let client = reqwest::Client::new();\n-    let span_exporter = opentelemetry_otlp::SpanExporter::builder()\n-        .with_http()\n-        .with_http_client(client)\n+    let tracing_span_exporter = opentelemetry_otlp::SpanExporter::builder()\n+        .with_tonic()\n         .with_endpoint(otel_endpoint)\n         .build()\n-        .expect(\"could not build span exporter\");\n-    let trace_config = opentelemetry_sdk::trace::Config::default()\n-        .with_sampler(ChromaShouldSample)\n-        .with_resource(resource.clone());\n+        .expect(\"could not build span exporter for tracing\");\n+    let trace_config = opentelemetry_sdk::trace::Config::default().with_resource(resource.clone());\n     let tracer_provider = opentelemetry_sdk::trace::TracerProvider::builder()\n-        .with_batch_exporter(span_exporter, opentelemetry_sdk::runtime::Tokio)\n+        .with_batch_exporter(tracing_span_exporter, opentelemetry_sdk::runtime::Tokio)\n         .with_config(trace_config)\n         .build();\n     let tracer = tracer_provider.tracer(service_name.clone());\n-    // TODO(MrCroxx): Should we the tracer provider as global?\n-    // global::set_tracer_provider(tracer_provider);\n \n     // Prepare meter.\n-    let mut headers = reqwest::header::HeaderMap::new();\n-    headers.insert(\n-        \"x-honeycomb-dataset\",\n-        reqwest::header::HeaderValue::from_static(\"chroma-load\"),\n-    );\n-    if let Ok(api_key) = std::env::var(\"OTEL_EXPORTER_OTLP_HEADERS\") {\n-        if let Some((header, value)) = api_key.split_once(\"=\") {\n-            if header == \"x-honeycomb-team\" {\n-                headers.insert(\n-                    reqwest::header::HeaderName::from_static(\"x-honeycomb-team\"),\n-                    reqwest::header::HeaderValue::from_bytes(value.trim().as_bytes()).unwrap(),\n-                );\n-            }\n-        }\n-    }\n-    let client = reqwest::ClientBuilder::new()\n-        .default_headers(headers)\n-        .build()\n-        .unwrap();\n     let metric_exporter = opentelemetry_otlp::MetricExporter::builder()\n-        .with_http()\n-        .with_http_client(client)\n-        .with_endpoint(otel_endpoint)\n+        .with_tonic()\n+        .with_endpoint(\n+            std::env::var(\"OTEL_EXPORTER_OTLP_METRICS_ENDPOINT\").unwrap_or(otel_endpoint.clone()),\n+        )\n         .build()\n         .expect(\"could not build metric exporter\");\n \n---\n\n\n---\n\nChoice C:\n.github/workflows/pr.yml\n@@ -200,7 +200,7 @@ jobs:\n         - name: Check PR Title\n           uses: Slashgear/action-check-pr-title@v4.3.0\n           with:\n-            regexp: '\\[(ENH|BUG|DOC|TST|BLD|PERF|TYP|CLN|CHORE|RELEASE|HOTFIX)\\].*'\n+            regexp: '\\[(ENH|BUG|DOC|TST|BLD|PERF|TYP|CLN|CHORE|RELEASE|HOTFIX|INST)\\].*'\n             helpMessage: \"Please tag your PR title. See https://docs.trychroma.com/contributing#contributing-code-and-ideas. You must push new code to this PR for this check to run again.\"\n         - name: Comment explaining failure\n           if: failure()\n---\n\n\n---\n\nChoice D:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.41\n+version: 0.1.42\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -35,4 +35,4 @@ compactionService:\n       value: 'value: \"/tilt_config.yaml\"'\n \n rustLogService:\n-  replicaCount: 2\n+  replicaCount: 1\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n- **[BUG] Handle duplicates in chroma-load. (#4423)**\n- **[ENH]  Restore chroma-load's random-upsert ability for Reference datasets. (#4425)**\n\n## Test plan\n\nCI\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -830,12 +836,15 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice B:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.41\n+version: 0.1.42\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -35,4 +35,4 @@ compactionService:\n       value: 'value: \"/tilt_config.yaml\"'\n \n rustLogService:\n-  replicaCount: 2\n+  replicaCount: 1\n---\n\n\n---\n\nChoice C:\nrust/log-service/src/lib.rs\n@@ -199,7 +199,9 @@ async fn get_log_from_handle<'a>(\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n     let mut active = handle.active.lock().await;\n-    active.keep_alive(Duration::from_secs(60));\n+    if active.log.is_some() {\n+        active.keep_alive(Duration::from_secs(60));\n+    }\n     if let Some(log) = active.log.as_ref() {\n         return Ok(LogRef {\n             log: Arc::clone(log),\n@@ -215,6 +217,7 @@ async fn get_log_from_handle<'a>(\n         mark_dirty.clone(),\n     )\n     .await?;\n+    active.keep_alive(Duration::from_secs(60));\n     tracing::info!(\"Opened log at {}\", prefix);\n     let opened = Arc::new(opened);\n     active.log = Some(Arc::clone(&opened));\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/quota/mod.rs\n@@ -243,7 +243,7 @@ pub enum UsageType {\n     NumCollections,        // Total number of collections for a tenant\n     NumDatabases,          // Total number of databases for a tenant\n     NumQueryIDs,           // Number of IDs to filter by in a query\n-    NumRegexPredicates,    // Number of regex predicates in the where_document\n+    RegexPatternLength,    // Length of regex pattern specified in filter\n     NumForks,              // Number of forks a root collection may have\n }\n \n@@ -274,7 +274,7 @@ impl fmt::Display for UsageType {\n             UsageType::NumCollections => write!(f, \"Number of collections\"),\n             UsageType::NumDatabases => write!(f, \"Number of databases\"),\n             UsageType::NumQueryIDs => write!(f, \"Number of IDs to filter by in a query\"),\n-            UsageType::NumRegexPredicates => write!(f, \"Number of regex predicates\"),\n+            UsageType::RegexPatternLength => write!(f, \"Length of regex pattern\"),\n             UsageType::NumForks => write!(f, \"Number of forks\"),\n         }\n     }\n@@ -305,7 +305,7 @@ impl TryFrom<&str> for UsageType {\n             \"num_collections\" => Ok(UsageType::NumCollections),\n             \"num_databases\" => Ok(UsageType::NumDatabases),\n             \"num_query_ids\" => Ok(UsageType::NumQueryIDs),\n-            \"num_regex_predicates\" => Ok(UsageType::NumRegexPredicates),\n+            \"regex_pattern_length\" => Ok(UsageType::RegexPatternLength),\n             \"num_forks\" => Ok(UsageType::NumForks),\n             _ => Err(format!(\"Invalid UsageType: {}\", value)),\n         }\n@@ -335,7 +335,7 @@ lazy_static::lazy_static! {\n         m.insert(UsageType::NumCollections, 1_000_000);\n         m.insert(UsageType::NumDatabases, 10);\n         m.insert(UsageType::NumQueryIDs, 1000);\n-        m.insert(UsageType::NumRegexPredicates, 0);\n+        m.insert(UsageType::RegexPatternLength, 0);\n         m.insert(UsageType::NumForks, 1_000_000);\n         m\n     };\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nIt was turned to be sequential-only, but this breaks wal3 testing.\n\nI previously submitted this is #4424, but that merged into a closed branch, so resubmit.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/log-service/src/lib.rs\n@@ -1219,17 +1219,16 @@ impl LogService for LogServer {\n             let witness = cursors.load(cursor_name).await.map_err(|err| {\n                 Status::new(err.code().into(), format!(\"Failed to load cursor: {}\", err))\n             })?;\n-            // This is the existing compaction_offset, which is the last record that was compacted.\n+            // This is the existing compaction_offset, which is the next record to compact.\n             let offset = witness\n                 .map(|x| x.1.position)\n-                .unwrap_or(LogPosition::from_offset(0));\n+                .unwrap_or(LogPosition::from_offset(1));\n             tracing::event!(Level::INFO, offset = ?offset);\n             wal3::copy(\n                 &storage,\n                 &options,\n                 &log_reader,\n-                // + 1 to get to the first uncompacted record.\n-                offset + 1u64,\n+                offset,\n                 target_prefix.clone(),\n             )\n             .await\n@@ -1253,7 +1252,9 @@ impl LogService for LogServer {\n             }\n             tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n-                compaction_offset: offset.offset(),\n+                // NOTE: The upstream service expects the last compacted offset as compaction offset\n+                compaction_offset: (offset - 1u64).offset(),\n+                // NOTE: The upstream service expects the last uncompacted offset as enumeration offset\n                 enumeration_offset: (max_offset - 1u64).offset(),\n             }))\n         }\n---\n\n\n---\n\nChoice B:\nrust/log/src/grpc_log.rs\n@@ -165,6 +165,26 @@ impl ChromaError for GrpcSealLogError {\n     }\n }\n \n+#[derive(Error, Debug)]\n+pub enum GrpcMigrateLogError {\n+    #[error(\"Failed to migrate collection: {0}\")]\n+    FailedToMigrate(#[from] tonic::Status),\n+    #[error(transparent)]\n+    ClientAssignerError(#[from] ClientAssignmentError),\n+    #[error(\"not supported by this service\")]\n+    NotSupported,\n+}\n+\n+impl ChromaError for GrpcMigrateLogError {\n+    fn code(&self) -> ErrorCodes {\n+        match self {\n+            GrpcMigrateLogError::FailedToMigrate(status) => status.code().into(),\n+            GrpcMigrateLogError::ClientAssignerError(e) => e.code(),\n+            GrpcMigrateLogError::NotSupported => ErrorCodes::Unimplemented,\n+        }\n+    }\n+}\n+\n type LogClient = LogServiceClient<chroma_tracing::GrpcTraceService<tonic::transport::Channel>>;\n \n #[derive(Clone, Debug)]\n@@ -176,7 +196,7 @@ pub struct GrpcLog {\n \n impl GrpcLog {\n     #[allow(clippy::type_complexity)]\n-    pub(crate) fn new(\n+    pub fn new(\n         config: GrpcLogConfig,\n         client: LogClient,\n         alt_client_assigner: Option<ClientAssigner<LogClient>>,\n@@ -190,7 +210,7 @@ impl GrpcLog {\n }\n \n #[derive(Error, Debug)]\n-pub(crate) enum GrpcLogError {\n+pub enum GrpcLogError {\n     #[error(\"Failed to connect to log service\")]\n     FailedToConnect(#[from] tonic::transport::Error),\n }\n@@ -639,19 +659,43 @@ impl GrpcLog {\n         }\n     }\n \n-    pub(super) async fn seal_log(\n+    pub async fn seal_log(\n         &mut self,\n-        tenant: &str,\n         collection_id: CollectionUuid,\n     ) -> Result<(), GrpcSealLogError> {\n+        // NOTE(rescrv):  Seal log only goes to the go log service, so use the classic connection.\n         let _response = self\n-            .client_for(tenant, collection_id)?\n+            .client\n             .seal_log(chroma_proto::SealLogRequest {\n                 collection_id: collection_id.to_string(),\n             })\n             .await?;\n         Ok(())\n     }\n+\n+    pub async fn migrate_log(\n+        &mut self,\n+        collection_id: CollectionUuid,\n+    ) -> Result<(), GrpcMigrateLogError> {\n+        // NOTE(rescrv): Migrate log only goes to the rust log service, so use alt client assigner.\n+        if let Some(client_assigner) = self.alt_client_assigner.as_mut() {\n+            let mut client = client_assigner\n+                .clients(&collection_id.to_string())?\n+                .drain(..)\n+                .next()\n+                .ok_or(ClientAssignmentError::NoClientFound(\n+                    \"Impossible state: no client found for collection\".to_string(),\n+                ))?;\n+            client\n+                .migrate_log(chroma_proto::MigrateLogRequest {\n+                    collection_id: collection_id.to_string(),\n+                })\n+                .await?;\n+            Ok(())\n+        } else {\n+            Err(GrpcMigrateLogError::NotSupported)\n+        }\n+    }\n }\n \n #[cfg(test)]\n---\nrust/log/src/log.rs\n@@ -213,11 +213,11 @@ impl Log {\n \n     pub async fn seal_log(\n         &mut self,\n-        tenant: &str,\n+        _: &str,\n         collection_id: CollectionUuid,\n     ) -> Result<(), GrpcSealLogError> {\n         match self {\n-            Log::Grpc(log) => log.seal_log(tenant, collection_id).await,\n+            Log::Grpc(log) => log.seal_log(collection_id).await,\n             Log::Sqlite(_) => unimplemented!(),\n             Log::InMemory(_) => unimplemented!(),\n         }\n---\n\n\n---\n\nChoice C:\nrust/load/src/opentelemetry_config.rs\n@@ -5,114 +5,41 @@\n \n use opentelemetry::global;\n use opentelemetry::trace::TracerProvider;\n-use opentelemetry_otlp::{WithExportConfig, WithHttpConfig};\n+use opentelemetry_otlp::WithExportConfig;\n use opentelemetry_sdk::propagation::TraceContextPropagator;\n use tracing_bunyan_formatter::BunyanFormattingLayer;\n use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Layer};\n \n-#[derive(Clone, Debug, Default)]\n-struct ChromaShouldSample;\n-\n-const BUSY_NS: opentelemetry::Key = opentelemetry::Key::from_static_str(\"busy_ns\");\n-const IDLE_NS: opentelemetry::Key = opentelemetry::Key::from_static_str(\"idle_ns\");\n-\n-fn is_slow(attributes: &[opentelemetry::KeyValue]) -> bool {\n-    let mut nanos = 0i64;\n-    for attr in attributes {\n-        if attr.key == BUSY_NS || attr.key == IDLE_NS {\n-            if let opentelemetry::Value::I64(ns) = attr.value {\n-                nanos += ns;\n-            }\n-        }\n-    }\n-    nanos > 20_000_000\n-}\n-\n-impl opentelemetry_sdk::trace::ShouldSample for ChromaShouldSample {\n-    fn should_sample(\n-        &self,\n-        _: Option<&opentelemetry::Context>,\n-        _: opentelemetry::trace::TraceId,\n-        name: &str,\n-        _: &opentelemetry::trace::SpanKind,\n-        attributes: &[opentelemetry::KeyValue],\n-        _: &[opentelemetry::trace::Link],\n-    ) -> opentelemetry::trace::SamplingResult {\n-        // NOTE(rescrv):  THIS IS A HACK!  If you find yourself seriously extending it, it's time\n-        // to investigate honeycomb's sampling capabilities.\n-\n-        // If the name is not get and not insert, or the request is slow, sample it.\n-        // Otherwise, drop.\n-        // This filters filters foyer calls in-process so they won't be overwhelming the tracing.\n-        if (name != \"get\" && name != \"insert\") || is_slow(attributes) {\n-            opentelemetry::trace::SamplingResult {\n-                decision: opentelemetry::trace::SamplingDecision::RecordAndSample,\n-                attributes: vec![],\n-                trace_state: opentelemetry::trace::TraceState::default(),\n-            }\n-        } else {\n-            opentelemetry::trace::SamplingResult {\n-                decision: opentelemetry::trace::SamplingDecision::Drop,\n-                attributes: vec![],\n-                trace_state: opentelemetry::trace::TraceState::default(),\n-            }\n-        }\n-    }\n-}\n-\n pub(crate) fn init_otel_tracing(service_name: &String, otel_endpoint: &String) {\n-    println!(\n+    tracing::info!(\n         \"Registering jaeger subscriber for {} at endpoint {}\",\n-        service_name, otel_endpoint\n+        service_name,\n+        otel_endpoint\n     );\n     let resource = opentelemetry_sdk::Resource::new(vec![opentelemetry::KeyValue::new(\n         \"service.name\",\n         service_name.clone(),\n     )]);\n \n     // Prepare tracer.\n-    let client = reqwest::Client::new();\n-    let span_exporter = opentelemetry_otlp::SpanExporter::builder()\n-        .with_http()\n-        .with_http_client(client)\n+    let tracing_span_exporter = opentelemetry_otlp::SpanExporter::builder()\n+        .with_tonic()\n         .with_endpoint(otel_endpoint)\n         .build()\n-        .expect(\"could not build span exporter\");\n-    let trace_config = opentelemetry_sdk::trace::Config::default()\n-        .with_sampler(ChromaShouldSample)\n-        .with_resource(resource.clone());\n+        .expect(\"could not build span exporter for tracing\");\n+    let trace_config = opentelemetry_sdk::trace::Config::default().with_resource(resource.clone());\n     let tracer_provider = opentelemetry_sdk::trace::TracerProvider::builder()\n-        .with_batch_exporter(span_exporter, opentelemetry_sdk::runtime::Tokio)\n+        .with_batch_exporter(tracing_span_exporter, opentelemetry_sdk::runtime::Tokio)\n         .with_config(trace_config)\n         .build();\n     let tracer = tracer_provider.tracer(service_name.clone());\n-    // TODO(MrCroxx): Should we the tracer provider as global?\n-    // global::set_tracer_provider(tracer_provider);\n \n     // Prepare meter.\n-    let mut headers = reqwest::header::HeaderMap::new();\n-    headers.insert(\n-        \"x-honeycomb-dataset\",\n-        reqwest::header::HeaderValue::from_static(\"chroma-load\"),\n-    );\n-    if let Ok(api_key) = std::env::var(\"OTEL_EXPORTER_OTLP_HEADERS\") {\n-        if let Some((header, value)) = api_key.split_once(\"=\") {\n-            if header == \"x-honeycomb-team\" {\n-                headers.insert(\n-                    reqwest::header::HeaderName::from_static(\"x-honeycomb-team\"),\n-                    reqwest::header::HeaderValue::from_bytes(value.trim().as_bytes()).unwrap(),\n-                );\n-            }\n-        }\n-    }\n-    let client = reqwest::ClientBuilder::new()\n-        .default_headers(headers)\n-        .build()\n-        .unwrap();\n     let metric_exporter = opentelemetry_otlp::MetricExporter::builder()\n-        .with_http()\n-        .with_http_client(client)\n-        .with_endpoint(otel_endpoint)\n+        .with_tonic()\n+        .with_endpoint(\n+            std::env::var(\"OTEL_EXPORTER_OTLP_METRICS_ENDPOINT\").unwrap_or(otel_endpoint.clone()),\n+        )\n         .build()\n         .expect(\"could not build metric exporter\");\n \n---\n\n\n---\n\nChoice D:\nrust/load/src/data_sets.rs\n@@ -836,12 +836,12 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            let key = uq.key.select_from_reference(self, offset);\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n             if !keys.contains(&key) {\n                 keys.push(key);\n             }\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nIt was turned to be sequential-only, but this breaks wal3 testing.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\ngo/pkg/log/server/server.go\n@@ -8,7 +8,9 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/proto/coordinatorpb\"\n \t\"github.com/chroma-core/chroma/go/pkg/proto/logservicepb\"\n \t\"github.com/chroma-core/chroma/go/pkg/types\"\n+\ttrace_log \"github.com/pingcap/log\"\n \t\"google.golang.org/protobuf/proto\"\n+\t\"go.uber.org/zap\"\n )\n \n type logServer struct {\n@@ -59,6 +61,7 @@ func (s *logServer) ScoutLogs(ctx context.Context, req *logservicepb.ScoutLogsRe\n \tres = &logservicepb.ScoutLogsResponse{\n \t\tFirstUninsertedRecordOffset: int64(limit + 1),\n \t}\n+\ttrace_log.Info(\"Scouted Logs\", zap.Int64(\"limit\", int64(limit + 1)), zap.String(\"collectionId\", req.CollectionId))\n \treturn\n }\n \n---\n\n\n---\n\nChoice B:\nchromadb/test/property/test_filtering.py\n@@ -20,7 +20,6 @@\n import chromadb.test.property.strategies as strategies\n import hypothesis.strategies as st\n import logging\n-import re\n from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n import numpy as np\n \n@@ -95,20 +94,10 @@ def _filter_where_doc_clause(clause: WhereDocument, doc: Document) -> bool:\n     if key == \"$contains\":\n         if not doc:\n             return False\n-        # SQLite FTS handles % and _ as word boundaries that are ignored so we need to\n-        # treat them as wildcards\n-        if \"%\" in expr or \"_\" in expr:\n-            expr = expr.replace(\"%\", \".\").replace(\"_\", \".\")\n-            return re.search(expr, doc) is not None\n         return expr in doc\n     elif key == \"$not_contains\":\n         if not doc:\n             return True\n-        # SQLite FTS handles % and _ as word boundaries that are ignored so we need to\n-        # treat them as wildcards\n-        if \"%\" in expr or \"_\" in expr:\n-            expr = expr.replace(\"%\", \".\").replace(\"_\", \".\")\n-            return re.search(expr, doc) is None\n         return expr not in doc\n     else:\n         raise ValueError(\"Unknown operator: {}\".format(key))\n---\n\n\n---\n\nChoice C:\nrust/load/src/data_sets.rs\n@@ -836,12 +836,12 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            let key = uq.key.select_from_reference(self, offset);\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n             if !keys.contains(&key) {\n                 keys.push(key);\n             }\n---\n\n\n---\n\nChoice D:\nTiltfile\n@@ -140,6 +140,21 @@ else:\n     target='garbage_collector'\n   )\n \n+if config.tilt_subcommand == \"ci\":\n+  custom_build(\n+    'load-service',\n+    'docker buildx build --load -t $EXPECTED_REF --target load_service -f ./rust/load/Dockerfile .',\n+    ['./rust/', './idl/', './Cargo.toml', './Cargo.lock']\n+  )\n+else:\n+  docker_build(\n+    'load-service',\n+    '.',\n+    only=[\"rust/\", \"idl/\", \"Cargo.toml\", \"Cargo.lock\"],\n+    dockerfile='./rust/load/Dockerfile',\n+    target='load_service'\n+  )\n+\n \n # First install the CRD\n k8s_yaml(\n@@ -169,6 +184,7 @@ k8s_yaml([\n   'k8s/test/grafana.yaml',\n   'k8s/test/jaeger-service.yaml',\n   'k8s/test/jaeger.yaml',\n+  'k8s/test/load-service.yaml',\n   'k8s/test/minio.yaml',\n   'k8s/test/prometheus.yaml',\n   'k8s/test/test-memberlist-cr.yaml',\n@@ -226,6 +242,7 @@ k8s_resource('sysdb', resource_deps=['sysdb-migration-latest'], labels=[\"chroma\"\n k8s_resource('rust-frontend-service', resource_deps=['sysdb', 'logservice', 'rust-log-service'], labels=[\"chroma\"], port_forwards='3000:8000')\n k8s_resource('query-service', resource_deps=['sysdb'], labels=[\"chroma\"], port_forwards='50053:50051')\n k8s_resource('compaction-service', resource_deps=['sysdb'], labels=[\"chroma\"])\n+k8s_resource('load-service', resource_deps=['k8s_setup'], labels=[\"infrastructure\"], port_forwards='3001:3001')\n k8s_resource('jaeger', resource_deps=['k8s_setup'], labels=[\"observability\"])\n k8s_resource('grafana', resource_deps=['k8s_setup'], labels=[\"observability\"])\n k8s_resource('prometheus', resource_deps=['k8s_setup'], labels=[\"observability\"])\n---\nk8s/test/load-service.yaml\n@@ -0,0 +1,81 @@\n+---\n+\n+apiVersion: v1\n+kind: Namespace\n+metadata:\n+  name: chroma-load\n+\n+---\n+\n+apiVersion: apps/v1\n+kind: Deployment\n+metadata:\n+  name: load-service\n+  namespace: chroma-load\n+spec:\n+  replicas: 1\n+  selector:\n+    matchLabels:\n+      app: load-service\n+  template:\n+    metadata:\n+      namespace: chroma-load\n+      labels:\n+        app: load-service\n+    spec:\n+      containers:\n+        - name: load-service\n+          image: load-service\n+          imagePullPolicy: IfNotPresent\n+          ports:\n+            - containerPort: 3001\n+              name: http\n+          env:\n+            - name: CONFIG_PATH\n+              value: /config/config.yaml\n+            - name: RUST_LOG\n+              value: \"info\"\n+          volumeMounts:\n+            - name: load-service-config\n+              mountPath: /config/\n+            - name: load-service-persistent-state\n+              mountPath: /state/\n+      volumes:\n+        - name: load-service-config\n+          configMap:\n+            name: load-service-config\n+        - name: load-service-persistent-state\n+          hostPath:\n+            path: /tmp/chroma/load-service\n+            type: DirectoryOrCreate\n+\n+---\n+\n+apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: load-service-config\n+  namespace: chroma-load\n+data:\n+  config.yaml: |\n+    load_service:\n+      service_name: \"chroma-load\"\n+      otel_endpoint: \"http://otel-collector.chroma:4317\"\n+      port: 3001\n+      persistent_state_path: \"/state/load-service.json\"\n+\n+---\n+\n+apiVersion: v1\n+kind: Service\n+metadata:\n+  name: load-service\n+  namespace: chroma-load\n+spec:\n+  ports:\n+    - name: http\n+      port: 3001\n+      targetPort: 3001\n+  selector:\n+    app: load-service\n+  type: ClusterIP\n---\nrust/load/src/opentelemetry_config.rs\n@@ -57,7 +57,7 @@ pub(crate) fn init_otel_tracing(service_name: &String, otel_endpoint: &String) {\n     // Layer for adding our configured tracer.\n     // Export everything at this layer. The backend i.e. honeycomb or jaeger will filter at its end.\n     let exporter_layer = tracing_opentelemetry::OpenTelemetryLayer::new(tracer)\n-        .with_filter(tracing_subscriber::filter::LevelFilter::ERROR);\n+        .with_filter(tracing_subscriber::filter::LevelFilter::INFO);\n     // Layer for printing spans to stdout. Only print INFO logs by default.\n     let stdout_layer =\n         BunyanFormattingLayer::new(service_name.clone().to_string(), std::io::stdout)\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nI'm seeing the error, \"invalid request: IDs lengths are different: got 9, expected 10\".\n\nI assume this is from the verifying data set as it's the only place this\nstring could be sprintf'd.\n\nThis de-dupes keys before fetch to avoid the service doing the deduping\nand returning a short set.  I wasn't able to repro locally, but am in\nstaging, so this will pass tests and then get debugged in staging.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -835,7 +841,10 @@ impl DataSet for ReferencingDataSet {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice B:\n.github/actions/docker/action.yaml\n@@ -17,6 +17,11 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n+    # https://github.com/docker/setup-qemu-action - for multiplatform builds\n+    - name: Set up QEMU\n+      uses: docker/setup-qemu-action@v2\n+    - name: Set up Docker Buildx\n+      uses: docker/setup-buildx-action@v3\n     - name: Log in to the Github Container registry\n       uses: docker/login-action@v2.1.0\n       if: ${{ inputs.ghcr-username != '' }}\n---\n.github/workflows/_build_release_container.yml\n@@ -33,106 +33,43 @@ permissions:\n env:\n   GHCR_IMAGE_NAME: \"ghcr.io/chroma-core/chroma\"\n   DOCKERHUB_IMAGE_NAME: \"chromadb/chroma\"\n+  PLATFORMS: linux/amd64,linux/arm64 #linux/riscv64, linux/arm/v7\n \n jobs:\n   build:\n-    name: Build image for ${{ matrix.platform }}\n+    name: Build and publish container image\n     runs-on: blacksmith-16vcpu-ubuntu-2204\n-    strategy:\n-      matrix:\n-        platform: [amd64, arm64]\n-        include:\n-          - platform: amd64\n-            runner: blacksmith-16vcpu-ubuntu-2204\n-            docker_platform: linux/amd64\n-          - platform: arm64\n-            runner: blacksmith-16vcpu-ubuntu-2204-arm\n-            docker_platform: linux/arm64\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v4\n         with:\n           fetch-depth: 0\n-\n       - name: Set up Docker\n         uses: ./.github/actions/docker\n         with:\n           ghcr-username: ${{ github.actor }}\n           ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n           dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-\n-      - name: Compute arch-specific tags\n-        id: tags\n+      - name: Compute tags\n         shell: bash\n+        id: compute_tags\n         run: |\n-          arch_tag=\"${{ inputs.tag }}-${{ matrix.platform }}\"\n-          ghcr=\"${{ env.GHCR_IMAGE_NAME }}:${arch_tag}\"\n-          dhub=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${arch_tag}\"\n-          echo \"arch_tag=$arch_tag\"      >> $GITHUB_OUTPUT\n-\n-          # expose *matrix-unique* step outputs\n-          echo \"ghcr_tag_${{ matrix.platform }}=$ghcr\"         >> $GITHUB_OUTPUT\n-          echo \"dockerhub_tag_${{ matrix.platform }}=$dhub\"    >> $GITHUB_OUTPUT\n+          tags=\"${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }},${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\"\n+          if [ \"${{ inputs.tag_as_latest }}\" = \"true\" ]; then\n+            tags=\"${tags},${{ env.GHCR_IMAGE_NAME }}:latest,${{ env.DOCKERHUB_IMAGE_NAME }}:latest\"\n+          fi\n \n-          # these two tags are what the build-push action will publish for *this* arch\n-          echo \"tags=$ghcr,$dhub\" >> $GITHUB_OUTPUT\n+          echo \"tags=${tags}\" >> $GITHUB_OUTPUT\n \n       - name: Build and push image\n         uses: useblacksmith/build-push-action@v1.1\n         with:\n           context: .\n           file: rust/Dockerfile\n           target: cli\n-          platforms: ${{ matrix.docker_platform }}\n+          platforms: ${{ env.PLATFORMS }}\n           push: true\n           build-args: |\n             RELEASE_MODE=1\n-          tags: ${{ steps.tags.outputs.tags }}\n-    outputs:\n-      ghcr_tag_amd64:      ${{ steps.tags.outputs.ghcr_tag_amd64 }}\n-      ghcr_tag_arm64:      ${{ steps.tags.outputs.ghcr_tag_arm64 }}\n-      dockerhub_tag_amd64: ${{ steps.tags.outputs.dockerhub_tag_amd64 }}\n-      dockerhub_tag_arm64: ${{ steps.tags.outputs.dockerhub_tag_arm64 }}\n-\n-  merge:\n-    name: Merge platform manifests\n-    runs-on: blacksmith-4vcpu-ubuntu-2204\n-    needs:\n-      - build\n-    steps:\n-      - name: Set up Docker\n-        uses: ./.github/actions/docker\n-        with:\n-          ghcr-username: ${{ github.actor }}\n-          ghcr-password: ${{ secrets.GITHUB_TOKEN }}\n-          dockerhub-username: ${{ secrets.DOCKERHUB_USERNAME }}\n-          dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n-\n-      - name: Create and push manifest\n-        shell: bash\n-        run: |\n-          set -euo pipefail\n-\n-          # Pull the per-arch tags from job-level outputs\n-          ghcr_amd64='${{ needs.build.outputs.ghcr_tag_amd64 }}'\n-          ghcr_arm64='${{ needs.build.outputs.ghcr_tag_arm64 }}'\n-          dhub_amd64='${{ needs.build.outputs.dockerhub_tag_amd64 }}'\n-          dhub_arm64='${{ needs.build.outputs.dockerhub_tag_arm64 }}'\n-\n-          base_tag='${{ inputs.tag }}'\n-          ghcr_base=\"${{ env.GHCR_IMAGE_NAME }}:${base_tag}\"\n-          dhub_base=\"${{ env.DOCKERHUB_IMAGE_NAME }}:${base_tag}\"\n-\n-          docker buildx imagetools create --tag \"$ghcr_base\" $ghcr_amd64 $ghcr_arm64\n-          docker buildx imagetools create --tag \"$dhub_base\"  $dhub_amd64 $dhub_arm64\n-\n-          if [[ \"${{ inputs.tag_as_latest }}\" == \"true\" ]]; then\n-            docker buildx imagetools create --tag \"${{ env.GHCR_IMAGE_NAME }}:latest\"  $ghcr_amd64 $ghcr_arm64\n-            docker buildx imagetools create --tag \"${{ env.DOCKERHUB_IMAGE_NAME }}:latest\" $dhub_amd64 $dhub_arm64\n-          fi\n-\n-      - name: Inspect image\n-        run: |\n-          docker buildx imagetools inspect ${{ env.GHCR_IMAGE_NAME }}:${{ inputs.tag }}\n-          docker buildx imagetools inspect ${{ env.DOCKERHUB_IMAGE_NAME }}:${{ inputs.tag }}\n+          tags: ${{ steps.compute_tags.outputs.tags }}\n---\n\n\n---\n\nChoice C:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.10\"\n+__version__ = \"1.0.11\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.10\"\n+      \"Default\": \"1.0.11\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice D:\ngo/pkg/log/server/server.go\n@@ -162,6 +162,15 @@ func (s *logServer) InspectDirtyLog(ctx context.Context, req *logservicepb.Inspe\n \treturn\n }\n \n+func (s *logServer) SealLog(ctx context.Context, req *logservicepb.SealLogRequest) (res *logservicepb.SealLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n+\n+func (s *logServer) MigrateLog(ctx context.Context, req *logservicepb.MigrateLogRequest) (res *logservicepb.MigrateLogResponse, err error) {\n+\t// no-op for now\n+\treturn\n+}\n \n func NewLogServer(lr *repository.LogRepository) logservicepb.LogServiceServer {\n \treturn &logServer{\n---\nidl/chromadb/proto/logservice.proto\n@@ -96,6 +96,22 @@ message InspectDirtyLogResponse {\n   repeated string markers = 1;\n }\n \n+message SealLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message SealLogResponse {\n+  // Empty\n+}\n+\n+message MigrateLogRequest {\n+  string collection_id = 1;\n+}\n+\n+message MigrateLogResponse {\n+  // Empty\n+}\n+\n service LogService {\n   rpc PushLogs(PushLogsRequest) returns (PushLogsResponse) {}\n   rpc ScoutLogs(ScoutLogsRequest) returns (ScoutLogsResponse) {}\n@@ -104,5 +120,11 @@ service LogService {\n   rpc GetAllCollectionInfoToCompact(GetAllCollectionInfoToCompactRequest) returns (GetAllCollectionInfoToCompactResponse) {}\n   rpc UpdateCollectionLogOffset(UpdateCollectionLogOffsetRequest) returns (UpdateCollectionLogOffsetResponse) {}\n   rpc PurgeDirtyForCollection(PurgeDirtyForCollectionRequest) returns (PurgeDirtyForCollectionResponse) {}\n+  // RPC endpoints to expose for operator debuggability.\n+  // This endpoint must route to the rust log service.\n   rpc InspectDirtyLog(InspectDirtyLogRequest) returns (InspectDirtyLogResponse) {}\n+  // This endpoint must route to the go log service.\n+  rpc SealLog(SealLogRequest) returns (SealLogResponse) {}\n+  // This endpoint must route to the rust log service.\n+  rpc MigrateLog(MigrateLogRequest) returns (MigrateLogResponse) {}\n }\n---\nrust/log-service/src/lib.rs\n@@ -16,9 +16,10 @@ use chroma_storage::Storage;\n use chroma_types::chroma_proto::{\n     log_service_server::LogService, CollectionInfo, GetAllCollectionInfoToCompactRequest,\n     GetAllCollectionInfoToCompactResponse, InspectDirtyLogRequest, InspectDirtyLogResponse,\n-    LogRecord, OperationRecord, PullLogsRequest, PullLogsResponse, PurgeDirtyForCollectionRequest,\n-    PurgeDirtyForCollectionResponse, PushLogsRequest, PushLogsResponse, ScoutLogsRequest,\n-    ScoutLogsResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n+    LogRecord, MigrateLogRequest, MigrateLogResponse, OperationRecord, PullLogsRequest,\n+    PullLogsResponse, PurgeDirtyForCollectionRequest, PurgeDirtyForCollectionResponse,\n+    PushLogsRequest, PushLogsResponse, ScoutLogsRequest, ScoutLogsResponse, SealLogRequest,\n+    SealLogResponse, UpdateCollectionLogOffsetRequest, UpdateCollectionLogOffsetResponse,\n };\n use chroma_types::chroma_proto::{ForkLogsRequest, ForkLogsResponse};\n use chroma_types::CollectionUuid;\n@@ -1230,6 +1231,24 @@ impl LogService for LogServer {\n         }\n         Ok(Response::new(InspectDirtyLogResponse { markers }))\n     }\n+\n+    async fn seal_log(\n+        &self,\n+        _request: Request<SealLogRequest>,\n+    ) -> Result<Response<SealLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do sealing\",\n+        ))\n+    }\n+\n+    async fn migrate_log(\n+        &self,\n+        _request: Request<MigrateLogRequest>,\n+    ) -> Result<Response<MigrateLogResponse>, Status> {\n+        Err(Status::failed_precondition(\n+            \"rust log service doesn't do migrating yet\",\n+        ))\n+    }\n }\n \n fn parquet_to_records(parquet: Arc<Vec<u8>>) -> Result<Vec<(LogPosition, Vec<u8>)>, Status> {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nIn a prior PR I refactored the code to give a strongly-consistent S3 get.\n\nI didn't use it.\n\nNow tests are flaking, but this should fix it.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nchromadb/test/ef/test_voyageai_ef.py\n@@ -0,0 +1,19 @@\n+import os\n+import pytest\n+from chromadb.utils.embedding_functions.voyageai_embedding_function import (\n+    VoyageAIEmbeddingFunction,\n+)\n+\n+voyageai = pytest.importorskip(\"voyageai\", reason=\"voyageai not installed\")\n+\n+\n+def test_with_embedding_dimensions() -> None:\n+    if os.environ.get(\"CHROMA_VOYAGE_API_KEY\") is None:\n+        pytest.skip(\"CHROMA_VOYAGE_API_KEY not set\")\n+    ef = VoyageAIEmbeddingFunction(\n+        api_key=os.environ[\"CHROMA_VOYAGE_API_KEY\"]\n+    )\n+    embeddings = ef([\"hello world\"])\n+    assert embeddings is not None\n+    assert len(embeddings) == 1\n+    assert len(embeddings[0]) == 1536\n---\nchromadb/utils/embedding_functions/voyageai_embedding_function.py\n@@ -55,7 +55,9 @@ def __call__(self, input: Documents) -> Embeddings:\n         embeddings = self._client.embed(texts=input, model=self.model_name)\n \n         # Convert to numpy arrays\n-        return [np.array(embedding, dtype=np.float32) for embedding in embeddings]\n+        return [\n+            np.array(embedding, dtype=np.float32) for embedding in embeddings.embeddings\n+        ]\n \n     @staticmethod\n     def name() -> str:\n---\n\n\n---\n\nChoice B:\ndocs/docs.trychroma.com/markdoc/content/integrations/frameworks/llamaindex.md\n@@ -6,5 +6,5 @@ name: LlamaIndex\n # LlamaIndex\n \n - `LlamaIndex` [Vector Store page](https://docs.llamaindex.ai/en/stable/examples/vector_stores/ChromaIndexDemo.html)\n-- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n-- [Chroma Loader on Llamahub](https://llamahub.ai/l/chroma)\n+- [Demo](https://github.com/jerryjliu/llama_index/blob/main/docs/docs/examples/vector_stores/ChromaIndexDemo.ipynb)\n+- [Chroma Loader on Llamahub](https://llamahub.ai/l/vector_stores/llama-index-vector-stores-chroma)\n---\n\n\n---\n\nChoice C:\nrust/wal3/src/manifest.rs\n@@ -599,7 +599,10 @@ impl Manifest {\n         let path = manifest_path(prefix);\n         loop {\n             match storage\n-                .get_with_e_tag(&path, GetOptions::new(StorageRequestPriority::P0))\n+                .get_with_e_tag(\n+                    &path,\n+                    GetOptions::new(StorageRequestPriority::P0).with_strong_consistency(),\n+                )\n                 .await\n                 .map_err(Arc::new)\n             {\n---\n\n\n---\n\nChoice D:\nchromadb/test/property/test_fork.py\n@@ -8,6 +8,7 @@\n \n from chromadb.api.models.Collection import Collection\n from chromadb.test.conftest import reset, skip_if_not_cluster\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n from hypothesis.stateful import (\n     Bundle,\n     RuleBasedStateMachine,\n@@ -198,22 +199,29 @@ def test_fork_with_log_migration(\n     import grpc\n     from chromadb.proto.logservice_pb2 import SealLogRequest\n     from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+    from chromadb.proto.coordinator_pb2_grpc import SysDBStub\n \n     caplog.set_level(logging.ERROR)\n     client.reset()\n     channel = grpc.insecure_channel(\"localhost:50052\")\n     go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n \n+    channel = grpc.insecure_channel(\"localhost:50051\")\n+    sysdb_service = SysDBStub(channel)  # type: ignore[no-untyped-call]\n+\n+    NUMBER = 100\n+\n     collection = client.create_collection(\"legacy-go-collection-0\")\n-    ids = [f\"id_{i}\" for i in range(6)]\n-    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    ids = sorted([f\"id_{i}\" for i in range(NUMBER)])\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(NUMBER)])  # type: ignore[arg-type]\n     go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n     fork_collection = collection.fork(\"fork-legacy-go-collection-0\")\n     assert sorted(fork_collection.get()[\"ids\"]) == ids\n \n     collection = client.create_collection(\"legacy-go-collection-1\")\n     go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n-    ids = [f\"id_{i}\" for i in range(6)]\n-    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    ids = sorted([f\"id_{i}\" for i in range(NUMBER)])\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(NUMBER)])  # type: ignore[arg-type]\n     fork_collection = collection.fork(\"fork-legacy-go-collection-1\")\n+    wait_for_version_increase(client, fork_collection.name, 0)\n     assert sorted(fork_collection.get()[\"ids\"]) == ids\n---\nrust/log-service/src/lib.rs\n@@ -38,7 +38,7 @@ use tracing::{Instrument, Level};\n use uuid::Uuid;\n use wal3::{\n     Cursor, CursorName, CursorStore, CursorStoreOptions, Fragment, Limits, LogPosition, LogReader,\n-    LogReaderOptions, LogWriter, LogWriterOptions, Manifest, Witness,\n+    LogReaderOptions, LogWriter, LogWriterOptions, Manifest, MarkDirty as MarkDirtyTrait, Witness,\n };\n \n pub mod state_hash_table;\n@@ -1427,15 +1427,22 @@ impl LogServer {\n             );\n             // This is the next record to insert, so we'll have to adjust downwards.\n             let max_offset = log_reader.maximum_log_position().await.map_err(|err| {\n-                Status::new(err.code().into(), format!(\"Failed to copy log: {}\", err))\n+                Status::new(err.code().into(), format!(\"Failed to read copied log: {}\", err))\n             })?;\n             if max_offset < offset {\n                 return Err(Status::new(\n                     chroma_error::ErrorCodes::Internal.into(),\n                     format!(\"max_offset={:?} < offset={:?}\", max_offset, offset),\n                 ));\n             }\n-            tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n+            if offset != max_offset{\n+                let mark_dirty = MarkDirty {\n+                    collection_id: target_collection_id,\n+                    dirty_log: Arc::clone(&self.dirty_log),\n+                };\n+                let _ = mark_dirty.mark_dirty(offset, (max_offset - offset) as usize).await;\n+            }\n+            tracing::event!(Level::INFO, compaction_offset =? offset.offset() - 1, enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n                 // NOTE: The upstream service expects the last compacted offset as compaction offset\n                 compaction_offset: (offset - 1u64).offset(),\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Auth was missing for forking. Can be enabled now after https://github.com/chroma-core/hosted-chroma/commit/f180572dc9d44e5a9d05a5b3a1f729ab55bfff86 \n- New functionality\n  - ...\n\n## Test plan\n_How are these changes tested?_\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\nNone\n\n\n---\n\nChoice A:\nrust/frontend/src/server.rs\n@@ -1209,7 +1209,7 @@ pub struct ForkCollectionPayload {\n     )\n )]\n async fn fork_collection(\n-    _headers: HeaderMap,\n+    headers: HeaderMap,\n     Path((tenant, database, collection_id)): Path<(String, String, String)>,\n     State(mut server): State<FrontendServer>,\n     Json(payload): Json<ForkCollectionPayload>,\n@@ -1224,19 +1224,17 @@ async fn fork_collection(\n     tracing::info!(\n         \"Forking collection [{collection_id}] in database [{database}] for tenant [{tenant}]\"\n     );\n-    // NOTE: The quota check if skipped for fork collection for now, and we rely on the scorecard to limit access to certain tenents\n-    // TODO: Unify the quota and scorecard\n-    // server\n-    //     .authenticate_and_authorize(\n-    //         &headers,\n-    //         AuthzAction::ForkCollection,\n-    //         AuthzResource {\n-    //             tenant: Some(tenant.clone()),\n-    //             database: Some(database.clone()),\n-    //             collection: Some(collection_id.clone()),\n-    //         },\n-    //     )\n-    //     .await?;\n+    server\n+        .authenticate_and_authorize(\n+            &headers,\n+            AuthzAction::ForkCollection,\n+            AuthzResource {\n+                tenant: Some(tenant.clone()),\n+                database: Some(database.clone()),\n+                collection: Some(collection_id.clone()),\n+            },\n+        )\n+        .await?;\n     let _guard =\n         server.scorecard_request(&[\"op:fork_collection\", format!(\"tenant:{}\", tenant).as_str()])?;\n     let collection_id =\n---\n\n\n---\n\nChoice B:\nrust/log-service/src/lib.rs\n@@ -215,7 +215,18 @@ async fn get_log_from_handle<'a>(\n     prefix: &str,\n     mark_dirty: MarkDirty,\n ) -> Result<LogRef<'a>, wal3::Error> {\n-    let mut active = handle.active.lock().await;\n+    let active = handle.active.lock().await;\n+    get_log_from_handle_with_mutex_held(handle, active, options, storage, prefix, mark_dirty).await\n+}\n+\n+async fn get_log_from_handle_with_mutex_held<'a>(\n+    handle: &'a crate::state_hash_table::Handle<LogKey, LogStub>,\n+    mut active: tokio::sync::MutexGuard<'_, ActiveLog>,\n+    options: &LogWriterOptions,\n+    storage: &Arc<Storage>,\n+    prefix: &str,\n+    mark_dirty: MarkDirty,\n+) -> Result<LogRef<'a>, wal3::Error> {\n     if active.log.is_some() {\n         active.keep_alive(Duration::from_secs(60));\n     }\n@@ -519,7 +530,12 @@ impl LogServer {\n         // Grab a lock on the state for this key, so that a racing initialize won't do anything.\n         let key = LogKey { collection_id };\n         let handle = self.open_logs.get_or_create_state(key);\n-        let mut _active = handle.active.lock().await;\n+        let active = handle.active.lock().await;\n+\n+        // Someone already initialized the log on a prior call.\n+        if active.log.is_some() {\n+            return Ok(());\n+        }\n \n         tracing::info!(\"log transfer to {collection_id}\");\n         let scout_request = Request::new(ScoutLogsRequest {\n@@ -641,6 +657,23 @@ impl LogServer {\n             log_offset: start as i64 - 1,\n         }))\n         .await?;\n+        // Set it up so that once we release the mutex, the next person won't do I/O and will\n+        // immediately be able to push logs.\n+        let storage_prefix = storage_prefix_for_log(collection_id);\n+        let mark_dirty = MarkDirty {\n+            collection_id,\n+            dirty_log: Arc::clone(&self.dirty_log),\n+        };\n+        // If this fails, the next writer will load manifest and continue unimpeded.\n+        let _ = get_log_from_handle_with_mutex_held(\n+            &handle,\n+            active,\n+            &self.config.writer,\n+            &self.storage,\n+            &storage_prefix,\n+            mark_dirty,\n+        )\n+        .await;\n         Ok(())\n     }\n \n---\n\n\n---\n\nChoice C:\nCargo.lock\n@@ -1314,9 +1314,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.2.1\"\n+version = \"1.2.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fd9de9f2205d5ef3fd67e685b0df337994ddd4495e2a28d185500d0e1edfea47\"\n+checksum = \"8691782945451c1c383942c4874dbe63814f61cb57ef773cda2972682b7bb3c0\"\n dependencies = [\n  \"jobserver\",\n  \"libc\",\n@@ -2319,9 +2319,9 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.5.12\"\n+version = \"0.5.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab3db02a9c5b5121e1e42fbdb1aeb65f5e02624cc58c43f2884c6ccac0b82f95\"\n+checksum = \"82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2\"\n dependencies = [\n  \"crossbeam-utils\",\n ]\n@@ -4502,7 +4502,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34\"\n dependencies = [\n  \"cfg-if\",\n- \"windows-targets 0.52.6\",\n+ \"windows-targets 0.48.5\",\n ]\n \n [[package]]\n@@ -5315,9 +5315,9 @@ checksum = \"0ab1bc2a289d34bd04a330323ac98a1b4bc82c9d9fcb1e66b63caa84da26b575\"\n \n [[package]]\n name = \"openssl\"\n-version = \"0.10.66\"\n+version = \"0.10.72\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9529f4786b70a3e8c61e11179af17ab6188ad8d0ded78c5529441ed39d4bd9c1\"\n+checksum = \"fedfea7d58a1f73118430a55da6a286e7b044961736ce96a16a17068ea25e5da\"\n dependencies = [\n  \"bitflags 2.9.0\",\n  \"cfg-if\",\n@@ -5347,9 +5347,9 @@ checksum = \"ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf\"\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.103\"\n+version = \"0.9.108\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7f9e8deee91df40a943c71b917e5874b951d32a802526c85721ce3b776c929d6\"\n+checksum = \"e145e1651e858e820e4860f7b9c5e169bc1d8ce1c86043be79fa7b7634821847\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -6029,9 +6029,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"57fe09249128b3173d092de9523eaa75136bf7ba85e0d69eca241c7939c933cc\"\n+checksum = \"7778bffd85cf38175ac1f545509665d0b9b92a198ca7941f131f85f7a4f9a872\"\n dependencies = [\n  \"cfg-if\",\n  \"indoc\",\n@@ -6047,29 +6047,29 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-build-config\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cd3927b5a78757a0d71aa9dff669f903b1eb64b54142a9bd9f757f8fde65fd7\"\n+checksum = \"94f6cbe86ef3bf18998d9df6e0f3fc1050a8c5efa409bf712e661a4366e010fb\"\n dependencies = [\n  \"once_cell\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"pyo3-ffi\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dab6bb2102bd8f991e7749f130a70d05dd557613e39ed2deeee8e9ca0c4d548d\"\n+checksum = \"e9f1b4c431c0bb1c8fb0a338709859eed0d030ff6daa34368d3b152a63dfdd8d\"\n dependencies = [\n  \"libc\",\n  \"pyo3-build-config\",\n ]\n \n [[package]]\n name = \"pyo3-macros\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"91871864b353fd5ffcb3f91f2f703a22a9797c91b9ab497b1acac7b07ae509c7\"\n+checksum = \"fbc2201328f63c4710f68abdf653c89d8dbc2858b88c5d88b0ff38a75288a9da\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"pyo3-macros-backend\",\n@@ -6079,9 +6079,9 @@ dependencies = [\n \n [[package]]\n name = \"pyo3-macros-backend\"\n-version = \"0.23.4\"\n+version = \"0.23.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"43abc3b80bc20f3facd86cd3c60beed58c3e2aa26213f3cda368de39c60a27e4\"\n+checksum = \"fca6726ad0f3da9c9de093d6f116a93c1a38e417ed73bf138472cf4064f72028\"\n dependencies = [\n  \"heck 0.5.0\",\n  \"proc-macro2 1.0.92\",\n@@ -6517,15 +6517,14 @@ dependencies = [\n \n [[package]]\n name = \"ring\"\n-version = \"0.17.8\"\n+version = \"0.17.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c17fa4cb658e3583423e915b9f3acc01cceaee1860e33d59ebae66adc3a2dc0d\"\n+checksum = \"a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7\"\n dependencies = [\n  \"cc\",\n  \"cfg-if\",\n  \"getrandom 0.2.15\",\n  \"libc\",\n- \"spin\",\n  \"untrusted\",\n  \"windows-sys 0.52.0\",\n ]\n@@ -7303,7 +7302,7 @@ version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"03c3c6b7927ffe7ecaa769ee0e3994da3b8cafc8f444578982c83ecb161af917\"\n dependencies = [\n- \"heck 0.5.0\",\n+ \"heck 0.4.1\",\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n  \"syn 2.0.101\",\n@@ -8058,9 +8057,9 @@ checksum = \"1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20\"\n \n [[package]]\n name = \"tokio\"\n-version = \"1.41.1\"\n+version = \"1.45.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22cfb5bee7a6a52939ca9224d6ac897bb669134078daa8735560897f69de4d33\"\n+checksum = \"2513ca694ef9ede0fb23fe71a4ee4107cb102b9dc1930f6d0fd77aae068ae165\"\n dependencies = [\n  \"backtrace\",\n  \"bytes\",\n@@ -8086,9 +8085,9 @@ dependencies = [\n \n [[package]]\n name = \"tokio-macros\"\n-version = \"2.4.0\"\n+version = \"2.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752\"\n+checksum = \"6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8\"\n dependencies = [\n  \"proc-macro2 1.0.92\",\n  \"quote 1.0.37\",\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.10\"\n+__version__ = \"1.0.11\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.10\"\n+      \"Default\": \"1.0.11\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.10\"\n+chroma_version                  = \"1.0.11\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.10\"\n+  default     = \"1.0.11\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - Adds the rust log service to be tracked by a memberlist by sysdb\r\n  - Added the new Memberlist CR, and associated roles\r\n  - Wired up the Sysdb to manage this memberlist\r\n- New functionality\r\n  - ...\r\n\r\n## Test plan\r\nI verified the new memberlist is updated, existing ML tests cover the ML\r\n<img width=\"830\" alt=\"Screenshot 2025-05-22 at 1 19 00 PM\" src=\"https://github.com/user-attachments/assets/c3c5d1e6-8051-41a7-ae75-189611c47a28\" />\r\n\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\ngo/pkg/log/repository/log.go\n@@ -168,7 +168,8 @@ func (r *LogRepository) ForkRecords(ctx context.Context, sourceCollectionID stri\n \t\t}\n \t}()\n \n-\tsourceBounds, err := queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n+\tvar sourceBounds log.GetBoundsForCollectionRow\n+\tsourceBounds, err = queriesWithTx.GetBoundsForCollection(ctx, sourceCollectionID)\n \tif err != nil {\n \t\ttrace_log.Error(\"Error in getting compaction and enumeration offset for source collection\", zap.Error(err), zap.String(\"collectionId\", sourceCollectionID))\n \t\treturn\n---\n\n\n---\n\nChoice B:\nchromadb/test/property/test_fork.py\n@@ -8,6 +8,7 @@\n \n from chromadb.api.models.Collection import Collection\n from chromadb.test.conftest import reset, skip_if_not_cluster\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n from hypothesis.stateful import (\n     Bundle,\n     RuleBasedStateMachine,\n@@ -198,22 +199,29 @@ def test_fork_with_log_migration(\n     import grpc\n     from chromadb.proto.logservice_pb2 import SealLogRequest\n     from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+    from chromadb.proto.coordinator_pb2_grpc import SysDBStub\n \n     caplog.set_level(logging.ERROR)\n     client.reset()\n     channel = grpc.insecure_channel(\"localhost:50052\")\n     go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n \n+    channel = grpc.insecure_channel(\"localhost:50051\")\n+    sysdb_service = SysDBStub(channel)  # type: ignore[no-untyped-call]\n+\n+    NUMBER = 100\n+\n     collection = client.create_collection(\"legacy-go-collection-0\")\n-    ids = [f\"id_{i}\" for i in range(6)]\n-    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    ids = sorted([f\"id_{i}\" for i in range(NUMBER)])\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(NUMBER)])  # type: ignore[arg-type]\n     go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n     fork_collection = collection.fork(\"fork-legacy-go-collection-0\")\n     assert sorted(fork_collection.get()[\"ids\"]) == ids\n \n     collection = client.create_collection(\"legacy-go-collection-1\")\n     go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n-    ids = [f\"id_{i}\" for i in range(6)]\n-    collection.add(ids=ids, embeddings=[[i, i] for i in range(6)])  # type: ignore[arg-type]\n+    ids = sorted([f\"id_{i}\" for i in range(NUMBER)])\n+    collection.add(ids=ids, embeddings=[[i, i] for i in range(NUMBER)])  # type: ignore[arg-type]\n     fork_collection = collection.fork(\"fork-legacy-go-collection-1\")\n+    wait_for_version_increase(client, fork_collection.name, 0)\n     assert sorted(fork_collection.get()[\"ids\"]) == ids\n---\nrust/log-service/src/lib.rs\n@@ -38,7 +38,7 @@ use tracing::{Instrument, Level};\n use uuid::Uuid;\n use wal3::{\n     Cursor, CursorName, CursorStore, CursorStoreOptions, Fragment, Limits, LogPosition, LogReader,\n-    LogReaderOptions, LogWriter, LogWriterOptions, Manifest, Witness,\n+    LogReaderOptions, LogWriter, LogWriterOptions, Manifest, MarkDirty as MarkDirtyTrait, Witness,\n };\n \n pub mod state_hash_table;\n@@ -1427,15 +1427,22 @@ impl LogServer {\n             );\n             // This is the next record to insert, so we'll have to adjust downwards.\n             let max_offset = log_reader.maximum_log_position().await.map_err(|err| {\n-                Status::new(err.code().into(), format!(\"Failed to copy log: {}\", err))\n+                Status::new(err.code().into(), format!(\"Failed to read copied log: {}\", err))\n             })?;\n             if max_offset < offset {\n                 return Err(Status::new(\n                     chroma_error::ErrorCodes::Internal.into(),\n                     format!(\"max_offset={:?} < offset={:?}\", max_offset, offset),\n                 ));\n             }\n-            tracing::event!(Level::INFO, compaction_offset =? offset.offset(), enumeration_offset =? (max_offset - 1u64).offset());\n+            if offset != max_offset{\n+                let mark_dirty = MarkDirty {\n+                    collection_id: target_collection_id,\n+                    dirty_log: Arc::clone(&self.dirty_log),\n+                };\n+                let _ = mark_dirty.mark_dirty(offset, (max_offset - offset) as usize).await;\n+            }\n+            tracing::event!(Level::INFO, compaction_offset =? offset.offset() - 1, enumeration_offset =? (max_offset - 1u64).offset());\n             Ok(Response::new(ForkLogsResponse {\n                 // NOTE: The upstream service expects the last compacted offset as compaction offset\n                 compaction_offset: (offset - 1u64).offset(),\n---\n\n\n---\n\nChoice C:\nTiltfile\n@@ -202,6 +202,7 @@ k8s_resource(\n     'query-service-memberlist:MemberList',\n     'compaction-service-memberlist:MemberList',\n     'garbage-collection-service-memberlist:MemberList',\n+    'rust-log-service-memberlist:MemberList',\n \n     'sysdb-serviceaccount:serviceaccount',\n     'sysdb-serviceaccount-rolebinding:RoleBinding',\n---\ngo/cmd/coordinator/cmd.go\n@@ -69,6 +69,10 @@ func init() {\n \tCmd.Flags().StringVar(&conf.GarbageCollectionServiceMemberlistName, \"garbage-collection-memberlist-name\", \"garbage-collection-service-memberlist\", \"Garbage collection memberlist name\")\n \tCmd.Flags().StringVar(&conf.GarbageCollectionServicePodLabel, \"garbage-collection-pod-label\", \"garbage-collection-service\", \"Garbage collection pod label\")\n \n+\t// Log service Memberlist\n+\tCmd.Flags().StringVar(&conf.LogServiceMemberlistName, \"log-memberlist-name\", \"rust-log-service-memberlist\", \"Log service memberlist name\")\n+\tCmd.Flags().StringVar(&conf.LogServicePodLabel, \"log-pod-label\", \"rust-log-service\", \"Log service pod label\")\n+\n \t// S3 config\n \tCmd.Flags().BoolVar(&conf.MetaStoreConfig.CreateBucketIfNotExists, \"create-bucket-if-not-exists\", false, \"Create bucket if not exists\")\n \tCmd.Flags().StringVar(&conf.MetaStoreConfig.BucketName, \"bucket-name\", \"chroma-storage\", \"Bucket name\")\n---\ngo/pkg/sysdb/grpc/server.go\n@@ -53,6 +53,10 @@ type Config struct {\n \tGarbageCollectionServiceMemberlistName string\n \tGarbageCollectionServicePodLabel       string\n \n+\t// Log service memberlist config\n+\tLogServiceMemberlistName string\n+\tLogServicePodLabel       string\n+\n \t// Config for soft deletes.\n \tSoftDeleteEnabled          bool\n \tSoftDeleteCleanupInterval  time.Duration\n@@ -136,6 +140,15 @@ func NewWithGrpcProvider(config Config, provider grpcutils.GrpcProvider) (*Serve\n \n \t\t// Create memberlist manager for garbage collection service\n \t\tgarbageCollectionMemberlistManager, err := createMemberlistManager(namespace, config.GarbageCollectionServiceMemberlistName, config.GarbageCollectionServicePodLabel, config.WatchInterval, config.ReconcileInterval, config.ReconcileCount)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\t// Create memberlist manager for log service\n+\t\tlogServiceMemberlistManager, err := createMemberlistManager(namespace, config.LogServiceMemberlistName, config.LogServicePodLabel, config.WatchInterval, config.ReconcileInterval, config.ReconcileCount)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \n \t\t// Start the memberlist manager for query service\n \t\terr = queryMemberlistManager.Start()\n@@ -154,6 +167,12 @@ func NewWithGrpcProvider(config Config, provider grpcutils.GrpcProvider) (*Serve\n \t\t\treturn nil, err\n \t\t}\n \n+\t\t// Start the memberlist manager for log service\n+\t\terr = logServiceMemberlistManager.Start()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n \t\tlog.Info(\"Starting soft delete cleaner\", zap.Duration(\"cleanup_interval\", s.softDeleteCleaner.cleanupInterval), zap.Duration(\"max_age\", s.softDeleteCleaner.maxAge), zap.Uint(\"limit_per_check\", s.softDeleteCleaner.limitPerCheck))\n \t\ts.softDeleteCleaner.Start()\n \n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.39\n+version: 0.1.40\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/rust-log-service-memberlist-cr.yaml\n@@ -0,0 +1,59 @@\n+apiVersion: chroma.cluster/v1\n+kind: MemberList\n+metadata:\n+  name: rust-log-service-memberlist\n+  namespace: {{ .Values.namespace }}\n+spec:\n+  members:\n+\n+---\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: ClusterRole\n+metadata:\n+  name: rust-log-service-memberlist-readerwriter\n+rules:\n+- apiGroups:\n+    - chroma.cluster\n+  resources:\n+    - memberlists\n+  verbs:\n+    - get\n+    - list\n+    - watch\n+    # TODO: FIX THIS LEAKY PERMISSION\n+    - create\n+    - update\n+    - patch\n+    - delete\n+\n+---\n+\n+# Allows the sysdb service to read and write to the memberlist\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: ClusterRoleBinding\n+metadata:\n+  name: sysdb-rust-log-service-memberlist-binding\n+roleRef:\n+  apiGroup: rbac.authorization.k8s.io\n+  kind: ClusterRole\n+  name: rust-log-service-memberlist-readerwriter\n+subjects:\n+- kind: ServiceAccount\n+  name: sysdb-serviceaccount\n+  namespace: {{ .Values.namespace }}\n+\n+---\n+\n+# Allows the rust-frontend-service to read and write to the memberlist\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: ClusterRoleBinding\n+metadata:\n+  name: rust-frontend-service-rust-log-service-memberlist-binding\n+roleRef:\n+  apiGroup: rbac.authorization.k8s.io\n+  kind: ClusterRole\n+  name: rust-log-service-memberlist-readerwriter\n+subjects:\n+- kind: ServiceAccount\n+  name: rust-frontend-service-serviceaccount\n+  namespace: {{ .Values.namespace }}\n---\n\n\n---\n\nChoice D:\nchromadb/test/distributed/test_log_failover.py\n@@ -65,4 +65,6 @@ def test_log_failover(\n \n     for i in range(200):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n         assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n---\nrust/frontend/sample_configs/tilt_config.yaml\n@@ -26,7 +26,7 @@ log:\n     connect_timeout_ms: 5000\n     request_timeout_ms: 60000 # 1 minute\n     alt_host: \"rust-log-service.chroma\"\n-    use_alt_host_for_everything: true\n+    alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n \n executor:\n   distributed:\n---\nrust/log/src/config.rs\n@@ -14,19 +14,20 @@ pub struct GrpcLogConfig {\n     pub max_encoding_message_size: usize,\n     #[serde(default = \"GrpcLogConfig::default_max_decoding_message_size\")]\n     pub max_decoding_message_size: usize,\n-    // NOTE(rescrv):  This is a hack to allow us to test two log services in parallel without\n-    // breaking the old service.  If alt host is specified, then the \"use_alt_host_for_everything\"\n-    // and \"use_alt_for_collections\" config parameters are consulted.  If\n-    // \"use_alt_host_for_everything\" is set (CI) or the collection being written is in the alt\n-    // collections vec (staging), then we can use the alt host.\n+    // NOTE(rescrv):  This is a hack to allow us to test migrate between two log services without\n+    // breaking things or having a hard cut-over.  If alt_host_threshold is specified, it will be\n+    // interpreted as a u128 (UUID == u128) and if the collection in question is <=\n+    // alt_host_threshold, it go to the alt-host first.\n+    //\n+    // alt tenants/collections will always initialize a new log\n     #[serde(default = \"Option::default\")]\n     pub alt_host: Option<String>,\n     #[serde(default)]\n-    pub use_alt_host_for_everything: bool,\n-    #[serde(default)]\n     pub use_alt_for_tenants: Vec<String>,\n     #[serde(default)]\n     pub use_alt_for_collections: Vec<String>,\n+    #[serde(default = \"Option::default\")]\n+    pub alt_host_threshold: Option<String>,\n }\n \n impl GrpcLogConfig {\n@@ -65,9 +66,9 @@ impl Default for GrpcLogConfig {\n             max_encoding_message_size: GrpcLogConfig::default_max_encoding_message_size(),\n             max_decoding_message_size: GrpcLogConfig::default_max_decoding_message_size(),\n             alt_host: None,\n-            use_alt_host_for_everything: false,\n             use_alt_for_tenants: vec![],\n             use_alt_for_collections: vec![],\n+            alt_host_threshold: None,\n         }\n     }\n }\n---\nrust/log/src/grpc_log.rs\n@@ -244,21 +244,41 @@ impl GrpcLog {\n         client_for_conn_str(connection_string)\n     }\n \n+    fn client_is_on_alt_log(to_evaluate: CollectionUuid, alt_host_threshold: Option<&str>) -> bool {\n+        if let Some(alt_host_threshold) = alt_host_threshold {\n+            let Ok(alt_host_threshold) = Uuid::parse_str(alt_host_threshold) else {\n+                tracing::error!(\"alt_host_threshold must be a valid UUID\");\n+                return false;\n+            };\n+            let to_evaluate = to_evaluate.0.as_u64_pair().0;\n+            let alt_host_threshold = alt_host_threshold.as_u64_pair().0;\n+            to_evaluate <= alt_host_threshold\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn client_for(\n         &mut self,\n         tenant: &str,\n         collection_id: CollectionUuid,\n     ) -> &mut LogServiceClient<chroma_tracing::GrpcTraceService<tonic::transport::Channel>> {\n-        let collection_id = collection_id.to_string();\n         if let Some(alt) = self.alt_client.as_mut() {\n-            if self.config.use_alt_host_for_everything\n-                || self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n-                || self.config.use_alt_for_collections.contains(&collection_id)\n+            if self.config.use_alt_for_tenants.iter().any(|t| t == tenant)\n+                || self\n+                    .config\n+                    .use_alt_for_collections\n+                    .contains(&collection_id.to_string())\n+                || Self::client_is_on_alt_log(\n+                    collection_id,\n+                    self.config.alt_host_threshold.as_deref(),\n+                )\n             {\n                 tracing::info!(\"using alt client for {collection_id}\");\n                 return alt;\n             }\n         }\n+        tracing::info!(\"using standard client for {collection_id}\");\n         &mut self.client\n     }\n \n@@ -413,7 +433,8 @@ impl GrpcLog {\n         let mut norm = self\n             ._get_collections_with_new_data(false, min_compaction_size)\n             .await?;\n-        if self.config.use_alt_host_for_everything\n+        if self.config.alt_host_threshold.is_some()\n+            || !self.config.use_alt_for_tenants.is_empty()\n             || !self.config.use_alt_for_collections.is_empty()\n         {\n             let alt = self\n@@ -524,3 +545,32 @@ impl GrpcLog {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn client_is_on_alt_log() {\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            None\n+        ));\n+        assert!(!GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"00088272-cfc4-419d-997a-baebfb25034a\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"00088272-cfc4-419d-997a-baebfb25034a\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"fffdb379-d592-41d1-8de6-412abc6e0b35\"),\n+        ));\n+        assert!(GrpcLog::client_is_on_alt_log(\n+            CollectionUuid(Uuid::parse_str(\"fffdb379-d592-41d1-8de6-412abc6e0b35\").unwrap()),\n+            Some(\"ffffffff-ffff-ffff-ffff-ffffffffffff\"),\n+        ));\n+    }\n+}\n---\nrust/worker/tilt_config.yaml\n@@ -42,7 +42,7 @@ query_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -122,7 +122,7 @@ compaction_service:\n             connect_timeout_ms: 5000\n             request_timeout_ms: 60000 # 1 minute\n             alt_host: \"rust-log-service.chroma\"\n-            use_alt_host_for_everything: true\n+            alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n     dispatcher:\n         num_worker_threads: 4\n         dispatcher_queue_size: 100\n@@ -197,4 +197,4 @@ log_service:\n         connect_timeout_ms: 5000\n         request_timeout_ms: 60000 # 1 minute\n         alt_host: \"rust-log-service.chroma\"\n-        use_alt_host_for_everything: true\n+        alt_host_threshold: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - Cleans up old python legacy FE from tilt file\r\n- New functionality\r\n  - None\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\nNo\n\n---\n\nChoice A:\n.github/workflows/_python-tests.yml\n@@ -291,7 +291,7 @@ jobs:\n         api_key: ${{ secrets.DD_API_KEY }}\n         site: ${{ vars.DD_SITE }}\n     - name: Integration Test\n-      run: bin/python-integration-test ${{ matrix.test-globs }}\n+      run: python -m pytest ${{ matrix.test-globs }}\n       shell: bash\n       env:\n         ENV_FILE: ${{ matrix.env-file }}\n---\nchromadb/test/test_cli.py\n@@ -1,6 +1,5 @@\n import multiprocessing\n import multiprocessing.context\n-import os\n import sys\n import time\n from multiprocessing.synchronize import Event\n@@ -10,7 +9,6 @@\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,6 +17,36 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+        host: str, port: int,\n+    max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            client = chromadb.HttpClient(host=host, port=port)\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            print(\"Heartbeat failed, trying again...\")\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n@@ -32,14 +60,10 @@ def test_app() -> None:\n     server_process.start()\n     time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    assert wait_for_server(host=\"localhost\", port=8001), \"Server failed to start within maximum retry attempts\"\n \n-    client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -124,7 +148,7 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\", \"--timeout\", \"10\"]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\nrust/cli/src/commands/vacuum.rs\n@@ -20,8 +20,10 @@ use sqlx::Row;\n use std::error::Error;\n use std::path::Path;\n use std::str::FromStr;\n+use std::time::Duration;\n use std::{fs, io};\n use thiserror::Error;\n+use tokio::time::timeout;\n \n #[derive(Debug, Error)]\n pub enum VacuumError {\n@@ -43,6 +45,8 @@ pub struct VacuumArgs {\n     path: Option<String>,\n     #[clap(long, default_value_t = false, help = \"Skip vacuum confirmation\")]\n     force: bool,\n+    #[clap(long, help = \"Maximum time (in seconds) to wait for vacuum\")]\n+    timeout: Option<u64>,\n }\n \n fn sizeof_fmt(num: u64, suffix: Option<&str>) -> String {\n@@ -195,10 +199,6 @@ pub async fn vacuum_chroma(config: FrontendConfig) -> Result<(), Box<dyn Error>>\n \n     println!(\"Vacuuming (this may take a while)...\\n\");\n \n-    sqlx::query(&format!(\"PRAGMA busy_timeout = {}\", 5000))\n-        .execute(sqlite.get_conn())\n-        .await?;\n-\n     sqlx::query(\"VACUUM\").execute(sqlite.get_conn()).await?;\n \n     sqlx::query(\n@@ -264,9 +264,19 @@ pub fn vacuum(args: VacuumArgs) -> Result<(), CliError> {\n     };\n \n     let runtime = tokio::runtime::Runtime::new().expect(\"Failed to start Chroma\");\n-    runtime\n-        .block_on(vacuum_chroma(config.frontend))\n-        .map_err(|_| VacuumError::VacuumFailed)?;\n+\n+    let res = if let Some(secs) = args.timeout {\n+        runtime.block_on(async {\n+            timeout(Duration::from_secs(secs), vacuum_chroma(config.frontend))\n+                .await\n+                .unwrap_or_else(|_elapsed| {\n+                    Err(Box::new(VacuumError::VacuumFailed) as Box<dyn std::error::Error>)\n+                })\n+        })\n+    } else {\n+        runtime.block_on(vacuum_chroma(config.frontend))\n+    };\n+    res.map_err(|_| VacuumError::VacuumFailed)?;\n \n     let post_vacuum_size =\n         get_dir_size(Path::new(&persistent_path)).map_err(|_| VacuumError::DirSizeFailed)?;\n---\n\n\n---\n\nChoice B:\nchromadb/test/property/test_fork.py\n@@ -21,6 +21,10 @@\n from overrides import overrides\n from typing import Dict, cast, Union, Tuple, Set\n \n+import grpc\n+from chromadb.proto.logservice_pb2 import SealLogRequest\n+from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+\n collection_st = hyst.shared(strategies.collections(with_hnsw_params=True), key=\"source\")\n \n \n@@ -38,6 +42,10 @@ def __init__(self, client: chromadb.api.ClientAPI):\n         self.client = client\n         self.collection_names = set()\n \n+        # Create go log service client\n+        channel = grpc.insecure_channel(\"localhost:50052\")\n+        self.go_log_service = LogServiceStub(channel)  # type: ignore[no-untyped-call]\n+\n     @initialize(collection=collection_st, target=updated_collections)\n     def initialize(\n         self, collection: strategies.Collection\n@@ -77,12 +85,14 @@ def fork(\n     @rule(\n         cursor=consumes(forked_collections),\n         delta=strategies.recordsets(collection_st),\n+        seal=hyst.booleans(),\n         target=updated_collections,\n     )\n     def upsert(\n         self,\n         cursor: Tuple[Collection, strategies.StateMachineRecordSet],\n         delta: strategies.RecordSet,\n+        seal: bool,\n     ) -> Tuple[Collection, strategies.StateMachineRecordSet]:\n         collection, record_set_state = cursor\n         normalized_delta: strategies.NormalizedRecordSet = invariants.wrap_all(delta)\n@@ -148,6 +158,8 @@ def upsert(\n                     )\n                 else:\n                     record_set_state[\"documents\"].append(None)\n+        if seal:\n+            self.go_log_service.SealLog(SealLogRequest(collection_id=collection.id.hex))\n         return collection, record_set_state\n \n     @rule(\n---\n\n\n---\n\nChoice C:\nTiltfile\n@@ -81,22 +81,6 @@ else:\n     target='sysdb-migration'\n   )\n \n-\n-if config.tilt_subcommand == \"ci\":\n-  custom_build(\n-    'frontend-service',\n-    'docker buildx build --load -t $EXPECTED_REF -f ./Dockerfile . ',\n-    ['chromadb/', 'idl/', 'requirements.txt', 'bin/']\n-  )\n-else:\n-  docker_build(\n-    'frontend-service',\n-    '.',\n-    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/'],\n-    dockerfile='./Dockerfile',\n-    ignore=['**/*.pyc', 'chromadb/test/'],\n-  )\n-\n if config.tilt_subcommand == \"ci\":\n   custom_build(\n     'rust-frontend-service',\n@@ -239,7 +223,6 @@ k8s_resource('logservice-migration-latest', resource_deps=['postgres'], labels=[\n k8s_resource('logservice', resource_deps=['sysdb-migration-latest'], labels=[\"chroma\"], port_forwards='50052:50051')\n k8s_resource('rust-log-service', labels=[\"chroma\"], port_forwards='50054:50051')\n k8s_resource('sysdb', resource_deps=['sysdb-migration-latest'], labels=[\"chroma\"], port_forwards='50051:50051')\n-k8s_resource('frontend-service', resource_deps=['sysdb', 'logservice'],labels=[\"chroma\"], port_forwards='8000:8000')\n k8s_resource('rust-frontend-service', resource_deps=['sysdb', 'logservice', 'rust-log-service'], labels=[\"chroma\"], port_forwards='3000:8000')\n k8s_resource('query-service', resource_deps=['sysdb'], labels=[\"chroma\"], port_forwards='50053:50051')\n k8s_resource('compaction-service', resource_deps=['sysdb'], labels=[\"chroma\"])\n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.36\n+version: 0.1.37\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/frontend-service.yaml\n@@ -1,92 +0,0 @@\n-apiVersion: apps/v1\n-kind: Deployment\n-metadata:\n-  name: frontend-service\n-  namespace: {{ .Values.namespace }}\n-spec:\n-  replicas: {{ .Values.frontendService.replicaCount }}\n-  selector:\n-    matchLabels:\n-      app: frontend-service\n-  template:\n-    metadata:\n-      labels:\n-        app: frontend-service\n-    spec:\n-      containers:\n-        - name: frontend-service\n-          image: \"{{ .Values.frontendService.image.repository }}:{{ .Values.frontendService.image.tag }}\"\n-          imagePullPolicy: IfNotPresent\n-          ports:\n-            - containerPort: 8000\n-          {{ if .Values.frontendService.resources }}\n-          resources:\n-            limits:\n-              cpu: {{ .Values.frontendService.resources.limits.cpu }}\n-              memory: {{ .Values.frontendService.resources.limits.memory }}\n-            requests:\n-              cpu: {{ .Values.frontendService.resources.requests.cpu }}\n-              memory: {{ .Values.frontendService.resources.requests.memory }}\n-          {{ end }}\n-          volumeMounts:\n-            - name: chroma\n-              mountPath: /test\n-          env:\n-            - name: CHROMA_API_IMPL\n-              value: \"chromadb.api.segment.SegmentAPI\"\n-            - name: IS_PERSISTENT\n-              {{ .Values.frontendService.isPersistent }}\n-            - name: CHROMA_PRODUCER_IMPL\n-              {{ .Values.frontendService.producerImpl }}\n-            - name: CHROMA_CONSUMER_IMPL\n-              {{ .Values.frontendService.consumerImpl }}\n-            - name: CHROMA_SEGMENT_MANAGER_IMPL\n-              {{ .Values.frontendService.segmentManagerImpl }}\n-            - name: CHROMA_EXECUTOR_IMPL\n-              {{ .Values.frontendService.executorImpl }}\n-            - name: ALLOW_RESET\n-              {{ .Values.frontendService.allowReset }}\n-            - name: CHROMA_SYSDB_IMPL\n-              {{ .Values.frontendService.sysdbImpl }}\n-            - name: CHROMA_SERVER_GRPC_PORT\n-              {{ .Values.frontendService.serverGrpcPort }}\n-            - name: CHROMA_COORDINATOR_HOST\n-              {{ .Values.frontendService.coordinatorHost }}\n-            - name: CHROMA_SERVER_AUTHN_PROVIDER\n-              {{ .Values.frontendService.authnProvider }}\n-            - name: CHROMA_SERVER_AUTHZ_PROVIDER\n-              {{ .Values.frontendService.authzProvider }}\n-            - name: CHROMA_MEMBERLIST_PROVIDER_IMPL\n-              {{ .Values.frontendService.memberlistProviderImpl }}\n-            - name: CHROMA_LOGSERVICE_HOST\n-              {{ .Values.frontendService.logServiceHost }}\n-            - name: CHROMA_LOGSERVICE_PORT\n-              {{ .Values.frontendService.logServicePort }}\n-{{ .Values.frontendService.otherEnvConfig | nindent 12 }}\n-      {{if .Values.frontendService.tolerations}}\n-      tolerations:\n-        {{ toYaml .Values.frontendService.tolerations | nindent 8 }}\n-      {{ end }}\n-      {{if .Values.frontendService.nodeSelector}}\n-      nodeSelector:\n-        {{ toYaml .Values.frontendService.nodeSelector | nindent 8 }}\n-      {{ end }}\n-      volumes:\n-        - name: chroma\n-          emptyDir: {}\n-\n----\n-\n-apiVersion: v1\n-kind: Service\n-metadata:\n-  name: frontend-service\n-  namespace: {{ .Values.namespace }}\n-spec:\n-  ports:\n-    - name: server-port\n-      port: 8000\n-      targetPort: 8000\n-  selector:\n-    app: frontend-service\n-  type: ClusterIP\n---\nk8s/distributed-chroma/values.dev.yaml\n@@ -20,11 +20,6 @@ rustFrontendService:\n     - name: CONFIG_PATH\n       value: \"tilt_config.yaml\"\n \n-frontendService:\n-  otherEnvConfig: |\n-    - name: CHROMA_ALLOW_RESET\n-      value: \"true\"\n-\n queryService:\n   env:\n     - name: RUST_BACKTRACE\n---\nk8s/distributed-chroma/values.yaml\n@@ -3,39 +3,6 @@\n \n namespace: 'chroma'\n \n-frontendService:\n-  image:\n-    repository: 'frontend-service'\n-    tag: 'latest'\n-\n-  # Sometimes users (and us) want to pass values directly as flags. Sometimes, these are\n-  # populated from secrets or configMaps. So we let consumers fill these directly.\n-  # TODO we could maybe have mutually exclusive pieces of config, e.g. isPersistentValue\n-  # and isPersistentFromConfigMap or something.\n-  isPersistent: 'value: \"TRUE\"'\n-  producerImpl: 'value: \"chromadb.logservice.logservice.LogService\"'\n-  consumerImpl: 'value: \"chromadb.logservice.logservice.LogService\"'\n-  segmentManagerImpl: 'value: \"chromadb.segment.impl.manager.distributed.DistributedSegmentManager\"'\n-  executorImpl: 'value: \"chromadb.execution.executor.distributed.DistributedExecutor\"'\n-  allowReset: 'value: \"TRUE\"'\n-  sysdbImpl: 'value: \"chromadb.db.impl.grpc.client.GrpcSysDB\"'\n-  serverGrpcPort: 'value: \"50051\"'\n-  coordinatorHost: 'value: \"sysdb.chroma\"'\n-  authProvider: 'value: \"\"'\n-  authCredentialsProvider: 'value: \"\"'\n-  authzProvider: 'value: \"\"'\n-  authzConfigProvider: 'value: \"\"'\n-  memberlistProviderImpl: 'value: \"chromadb.segment.impl.distributed.segment_directory.CustomResourceMemberlistProvider\"'\n-  logServiceHost: 'value: \"logservice.chroma\"'\n-  logServicePort: 'value: \"50051\"'\n-  otherEnvConfig: |\n-    - name: CHROMA_OTEL_COLLECTION_ENDPOINT\n-      value: \"http://jaeger:4317\"\n-    - name: CHROMA_OTEL_GRANULARITY\n-      value: all\n-  replicaCount: 2\n-\n-\n rustFrontendService:\n   image:\n     repository: 'rust-frontend-service'\n---\n\n\n---\n\nChoice D:\n.github/workflows/_python-tests.yml\n@@ -138,6 +138,7 @@ jobs:\n                     \"chromadb/test/property/test_collections_with_database_tenant.py\",\n                     \"chromadb/test/property/test_collections_with_database_tenant_overwrite.py\",\n                     \"chromadb/test/distributed/test_sanity.py\",\n+                    \"chromadb/test/distributed/test_log_backpressure.py\",\n                     \"chromadb/test/distributed/test_log_failover.py\"]\n     runs-on: ${{ matrix.platform }}\n     # OIDC token auth for AWS\n---\nchromadb/test/distributed/test_log_backpressure.py\n@@ -0,0 +1,53 @@\n+# Add up to 200k records until the log-is-full message is seen.\n+\n+import grpc\n+import math\n+import random\n+import time\n+\n+import numpy as np\n+\n+from chromadb.api import ClientAPI\n+from chromadb.proto.logservice_pb2 import SealLogRequest, MigrateLogRequest\n+from chromadb.proto.logservice_pb2_grpc import LogServiceStub\n+from chromadb.test.conftest import (\n+    reset,\n+    skip_if_not_cluster,\n+)\n+from chromadb.test.property import invariants\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n+\n+RECORDS = 2000000\n+BATCH_SIZE = 100\n+\n+@skip_if_not_cluster()\n+def test_log_backpressure(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('backpressuring for', collection.id)\n+\n+    excepted = False\n+    try:\n+        # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+        for i in range(0, RECORDS, BATCH_SIZE):\n+            ids = []\n+            embeddings = []\n+            ids.extend([str(x) for x in range(i, i + BATCH_SIZE)])\n+            embeddings.extend([np.random.rand(1, 3)[0] for x in range(i, i + BATCH_SIZE)])\n+            collection.add(ids=ids, embeddings=embeddings)\n+    except Exception as x:\n+        print(f\"Caught exception:\\n{x}\")\n+        if 'log needs compaction' in str(x):\n+            excepted = True\n+    assert excepted, \"Expected an exception to be thrown.\"\n---\nrust/worker/tilt_config.yaml\n@@ -169,6 +169,7 @@ compaction_service:\n             policy: \"full_rebuild\"\n \n log_service:\n+    num_records_before_backpressure: 100000\n     opentelemetry:\n         service_name: \"rust-log-service\"\n         endpoint: \"http://otel-collector:4317\"\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nUpon compaction flush for a collection, the Sysdb [creates a version file if one does not exist](https://github.com/chroma-core/chroma/pull/4284/files). To do this, it populates fields in the file using the `GetCollectionEntry` method.\r\n\r\nHowever, before this PR, the `GetCollectionEntry` method **always returned an empty string for the tenant**. This led to the field missing in the version file and version files being saved under the wrong bucket prefix.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\nValidated that the tenant ID is now correctly populated by:\r\n\r\n1. `tilt up` with version files disabled on Sysdb.\r\n2. Created a collection and added data.\r\n3. Enabled version files on Sydb.\r\n4. Added more data to the collection.\r\n5. Observed that the tenant ID was correctly populated in the created version files.\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\r\nn/a\n\n---\n\nChoice A:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.7\"\n+__version__ = \"1.0.8\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.7\"\n+      \"Default\": \"1.0.8\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.7\"\n+chroma_version                  = \"1.0.8\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.7\"\n+  default     = \"1.0.8\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice B:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1555,6 +1555,10 @@ func (tc *Catalog) FlushCollectionCompactionForVersionedCollection(ctx context.C\n \t\t\t\treturn nil, err\n \t\t\t}\n \n+\t\t\t// There was previously a bug that resulted in the tenant ID missing from some version files (https://github.com/chroma-core/chroma/pull/4408).\n+\t\t\t// This line can be removed once all corrupted version files are fixed.\n+\t\t\texistingVersionFilePb.CollectionInfoImmutable.TenantId = collectionEntry.Tenant\n+\n \t\t\t// Do a simple validation of the version file.\n \t\t\terr = tc.validateVersionFile(existingVersionFilePb, collectionEntry.ID, existingVersion)\n \t\t\tif err != nil {\n---\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionEntry(collectionID *string, databaseName *string) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, databases.tenant_id, collections.version, collections.version_file_name, collections.root_collection_id\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\nChoice C:\n.github/actions/python/action.yaml\n@@ -8,27 +8,26 @@ inputs:\n runs:\n   using: \"composite\"\n   steps:\n-\n+    - name: Install uv\n+      uses: astral-sh/setup-uv@v6\n+      with:\n+        enable-cache: true\n     - name: Set up Python 3.9 for protos\n       uses: useblacksmith/setup-python@v6\n       # NOTE(hammadb) Blacksmith does not support windows, so we use the official action for windows and\n       # skip it on other platforms\n       if: runner.os != 'Windows'\n       with:\n         python-version: \"3.9\"\n-        cache: \"pip\"\n-        cache-dependency-path: \"requirements*.txt\"\n     - name: Set up Python 3.9 for protos (Windows)\n       if: runner.os == 'Windows'\n       uses: actions/setup-python@v5\n       with:\n         python-version: \"3.9\"\n-        cache: \"pip\"\n-        cache-dependency-path: \"requirements*.txt\"\n \n     - name: Install proto dependencies\n       run: |\n-        python -m pip install grpcio==1.58.0 grpcio-tools==1.58.0\n+        uv pip install --system grpcio==1.58.0 grpcio-tools==1.58.0\n       shell: bash\n     - name: Generate Proto Files\n       if: runner.os != 'Windows'\n@@ -40,30 +39,24 @@ runs:\n       shell: cmd\n     - name: Uninstall proto dependencies\n       run: |\n-        python -m pip uninstall -y grpcio grpcio-tools\n+        uv pip uninstall --system grpcio grpcio-tools\n       shell: bash\n     - name: Set up Python ${{ inputs.python-version }}\n       uses: useblacksmith/setup-python@v6\n       with:\n         python-version: ${{ inputs.python-version }}\n-        cache: \"pip\"\n-        cache-dependency-path: \"requirements*.txt\"\n     - name: Set up Python ${{ inputs.python-version }} (Windows)\n       if: runner.os == 'Windows'\n       uses: actions/setup-python@v5\n       with:\n         python-version: ${{ inputs.python-version }}\n-        cache: \"pip\"\n-        cache-dependency-path: \"requirements*.txt\"\n     - name: Install dependencies\n       run: |\n-        python -m pip install -r requirements.txt && python -m pip install -r requirements_dev.txt\n+        uv pip install --system -r requirements.txt -r requirements_dev.txt\n       shell: bash\n     - name: Install protobuf compiler (protoc) - Linux\n       if: runner.os != 'Windows'\n       run: |\n-        sudo apt-get update\n-        sudo apt-get install -y wget unzip\n         wget https://github.com/protocolbuffers/protobuf/releases/download/v28.2/protoc-28.2-linux-x86_64.zip\n         sudo unzip protoc-28.2-linux-x86_64.zip -d /usr/local/\n         sudo rm protoc-28.2-linux-x86_64.zip\n---\n\n\n---\n\nChoice D:\n.github/workflows/_python-tests.yml\n@@ -291,7 +291,7 @@ jobs:\n         api_key: ${{ secrets.DD_API_KEY }}\n         site: ${{ vars.DD_SITE }}\n     - name: Integration Test\n-      run: bin/python-integration-test ${{ matrix.test-globs }}\n+      run: python -m pytest ${{ matrix.test-globs }}\n       shell: bash\n       env:\n         ENV_FILE: ${{ matrix.env-file }}\n---\nchromadb/test/test_cli.py\n@@ -1,6 +1,5 @@\n import multiprocessing\n import multiprocessing.context\n-import os\n import sys\n import time\n from multiprocessing.synchronize import Event\n@@ -10,7 +9,6 @@\n from chromadb.api.models.Collection import Collection\n from chromadb.cli import cli\n from chromadb.cli.cli import build_cli_args\n-from chromadb.cli.utils import set_log_file_path\n from chromadb.config import Settings, System\n from chromadb.db.base import get_sql\n from chromadb.db.impl.sqlite import SqliteDB\n@@ -19,6 +17,36 @@\n \n from chromadb.test.property import invariants\n \n+\n+def wait_for_server(\n+        host: str, port: int,\n+    max_retries: int = 5, initial_delay: float = 1.0\n+) -> bool:\n+    \"\"\"Wait for server to be ready using exponential backoff.\n+    Args:\n+        client: ChromaDB client instance\n+        max_retries: Maximum number of retry attempts\n+        initial_delay: Initial delay in seconds before first retry\n+    Returns:\n+        bool: True if server is ready, False if max retries exceeded\n+    \"\"\"\n+    delay = initial_delay\n+    for attempt in range(max_retries):\n+        try:\n+            client = chromadb.HttpClient(host=host, port=port)\n+            heartbeat = client.heartbeat()\n+            if heartbeat > 0:\n+                return True\n+        except Exception:\n+            print(\"Heartbeat failed, trying again...\")\n+            pass\n+\n+        if attempt < max_retries - 1:\n+            time.sleep(delay)\n+            delay *= 2\n+\n+    return False\n+\n def start_app(args: list[str]) -> None:\n     sys.argv = args\n     cli.app()\n@@ -32,14 +60,10 @@ def test_app() -> None:\n     server_process.start()\n     time.sleep(5)\n \n-    host = os.getenv(\"CHROMA_SERVER_HOST\", kwargs.get(\"host\", \"localhost\"))\n-    port = os.getenv(\"CHROMA_SERVER_HTTP_PORT\", kwargs.get(\"port\", 8000))\n+    assert wait_for_server(host=\"localhost\", port=8001), \"Server failed to start within maximum retry attempts\"\n \n-    client = chromadb.HttpClient(host=host, port=port)\n-    heartbeat = client.heartbeat()\n     server_process.terminate()\n     server_process.join()\n-    assert heartbeat > 0\n \n \n def test_vacuum(sqlite_persistent: System) -> None:\n@@ -124,7 +148,7 @@ def test_vacuum_errors_if_locked(sqlite_persistent: System, capfd) -> None:\n     ready_event.wait()\n \n     try:\n-        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\"]\n+        sys.argv = [\"chroma\", \"vacuum\", \"--path\", sqlite_persistent.settings.persist_directory, \"--force\", \"--timeout\", \"10\"]\n         cli.app()\n         captured = capfd.readouterr()\n         assert \"Failed to vacuum Chroma\" in captured.err.strip()\n---\nrust/cli/src/commands/vacuum.rs\n@@ -20,8 +20,10 @@ use sqlx::Row;\n use std::error::Error;\n use std::path::Path;\n use std::str::FromStr;\n+use std::time::Duration;\n use std::{fs, io};\n use thiserror::Error;\n+use tokio::time::timeout;\n \n #[derive(Debug, Error)]\n pub enum VacuumError {\n@@ -43,6 +45,8 @@ pub struct VacuumArgs {\n     path: Option<String>,\n     #[clap(long, default_value_t = false, help = \"Skip vacuum confirmation\")]\n     force: bool,\n+    #[clap(long, help = \"Maximum time (in seconds) to wait for vacuum\")]\n+    timeout: Option<u64>,\n }\n \n fn sizeof_fmt(num: u64, suffix: Option<&str>) -> String {\n@@ -195,10 +199,6 @@ pub async fn vacuum_chroma(config: FrontendConfig) -> Result<(), Box<dyn Error>>\n \n     println!(\"Vacuuming (this may take a while)...\\n\");\n \n-    sqlx::query(&format!(\"PRAGMA busy_timeout = {}\", 5000))\n-        .execute(sqlite.get_conn())\n-        .await?;\n-\n     sqlx::query(\"VACUUM\").execute(sqlite.get_conn()).await?;\n \n     sqlx::query(\n@@ -264,9 +264,19 @@ pub fn vacuum(args: VacuumArgs) -> Result<(), CliError> {\n     };\n \n     let runtime = tokio::runtime::Runtime::new().expect(\"Failed to start Chroma\");\n-    runtime\n-        .block_on(vacuum_chroma(config.frontend))\n-        .map_err(|_| VacuumError::VacuumFailed)?;\n+\n+    let res = if let Some(secs) = args.timeout {\n+        runtime.block_on(async {\n+            timeout(Duration::from_secs(secs), vacuum_chroma(config.frontend))\n+                .await\n+                .unwrap_or_else(|_elapsed| {\n+                    Err(Box::new(VacuumError::VacuumFailed) as Box<dyn std::error::Error>)\n+                })\n+        })\n+    } else {\n+        runtime.block_on(vacuum_chroma(config.frontend))\n+    };\n+    res.map_err(|_| VacuumError::VacuumFailed)?;\n \n     let post_vacuum_size =\n         get_dir_size(Path::new(&persistent_path)).map_err(|_| VacuumError::DirSizeFailed)?;\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\nBecause of the deduping process for shared futures, it was possible to\nget into the following situtation:\n\n1. thread1 calls get_with_etag\n2. thread1's request hits s3 and bounces back, but the outstanding read\n   request persists because the read isn't effectuated in-process\n3. thread2 installs a new manifest and tells thread3 about it\n4. thread3 calls get_with_etag\n5. thread3 sees manifest from the past, reading from the dedupe of 1\n   that's still pending.\n\n## Test plan\n\n- [X] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\nN/A\n\n\n---\n\nChoice A:\nclients/js/packages/chromadb-core/src/ChromaFetch.ts\n@@ -9,6 +9,7 @@ import {\n   ChromaError,\n   createErrorByType,\n   ChromaUniqueError,\n+  ChromaQuotaExceededError,\n } from \"./Errors\";\n import { FetchAPI } from \"./generated\";\n \n@@ -74,6 +75,14 @@ export const chromaFetch: FetchAPI = async (\n           );\n         case 409:\n           throw new ChromaUniqueError(\"The resource already exists\");\n+        case 422:\n+          if (\n+            respBody?.message &&\n+            respBody?.message.startsWith(\"Quota exceeded\")\n+          ) {\n+            throw new ChromaQuotaExceededError(respBody?.message);\n+          }\n+          break;\n         case 500:\n           throw parseServerError(respBody?.error);\n         case 502:\n---\nclients/js/packages/chromadb-core/src/Errors.ts\n@@ -85,6 +85,13 @@ export class ChromaUniqueError extends Error {\n   }\n }\n \n+export class ChromaQuotaExceededError extends Error {\n+  name = \"ChromaQuotaExceededError\";\n+  constructor(message: string, public readonly cause?: unknown) {\n+    super(message);\n+  }\n+}\n+\n export function createErrorByType(type: string, message: string) {\n   switch (type) {\n     case \"InvalidCollection\":\n---\n\n\n---\n\nChoice B:\nrust/types/src/api_types.rs\n@@ -82,7 +82,7 @@ impl ChromaError for GetCollectionWithSegmentsError {\n             GetCollectionWithSegmentsError::CollectionConversionError(\n                 collection_conversion_error,\n             ) => collection_conversion_error.code(),\n-            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::Internal,\n             GetCollectionWithSegmentsError::Field(_) => ErrorCodes::FailedPrecondition,\n             GetCollectionWithSegmentsError::SegmentConversionError(segment_conversion_error) => {\n                 segment_conversion_error.code()\n@@ -832,7 +832,7 @@ impl ChromaError for ForkCollectionError {\n             ForkCollectionError::CollectionConversionError(collection_conversion_error) => {\n                 collection_conversion_error.code()\n             }\n-            ForkCollectionError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            ForkCollectionError::DuplicateSegment => ErrorCodes::Internal,\n             ForkCollectionError::Field(_) => ErrorCodes::FailedPrecondition,\n             ForkCollectionError::Local => ErrorCodes::Unimplemented,\n             ForkCollectionError::Internal(chroma_error) => chroma_error.code(),\n---\n\n\n---\n\nChoice C:\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -374,7 +374,7 @@ func (tc *Catalog) createCollectionImpl(txCtx context.Context, createCollection\n \t\treturn nil, false, common.ErrConcurrentDeleteCollection\n \t}\n \tresult := convertCollectionToModel(collectionList)[0]\n-\treturn result, true, nil\n+\treturn result, created, nil\n }\n \n func (tc *Catalog) CreateCollection(ctx context.Context, createCollection *model.CreateCollection, ts types.Timestamp) (*model.Collection, bool, error) {\n@@ -1251,7 +1251,6 @@ func (tc *Catalog) CreateCollectionAndSegments(ctx context.Context, createCollec\n \t\t}\n \n \t\t// If collection already exists, then do not create segments.\n-\t\t// TODO: Should we check to see if segments does not exist? and create them?\n \t\tif !created {\n \t\t\treturn nil\n \t\t}\n---\n\n\n---\n\nChoice D:\nrust/storage/src/admissioncontrolleds3.rs\n@@ -206,10 +206,10 @@ impl AdmissionControlledS3Storage {\n         rate_limiter: Arc<RateLimitPolicy>,\n         key: String,\n         priority: Arc<AtomicUsize>,\n-        channel_receiver: tokio::sync::mpsc::Receiver<()>,\n+        channel_receiver: Option<tokio::sync::mpsc::Receiver<()>>,\n     ) -> Result<(Arc<Vec<u8>>, Option<ETag>), StorageError> {\n         // Acquire permit.\n-        let _permit = rate_limiter.enter(priority, Some(channel_receiver)).await;\n+        let _permit = rate_limiter.enter(priority, channel_receiver).await;\n         storage\n             .get_with_e_tag(&key)\n             .instrument(tracing::trace_span!(parent: Span::current(), \"S3 get\"))\n@@ -277,6 +277,9 @@ impl AdmissionControlledS3Storage {\n         key: &str,\n         options: GetOptions,\n     ) -> Result<(Arc<Vec<u8>>, Option<ETag>), StorageError> {\n+        if options.requires_strong_consistency {\n+            return self.strongly_consistent_get_with_e_tag(key, options).await;\n+        }\n         // If there is a duplicate request and the original request finishes\n         // before we look it up in the map below then we will end up with another\n         // request to S3.\n@@ -298,7 +301,7 @@ impl AdmissionControlledS3Storage {\n                         self.rate_limiter.clone(),\n                         key.to_string(),\n                         atomic_priority.clone(),\n-                        rx,\n+                        Some(rx),\n                     )\n                     .boxed()\n                     .shared();\n@@ -323,6 +326,22 @@ impl AdmissionControlledS3Storage {\n         res\n     }\n \n+    pub async fn strongly_consistent_get_with_e_tag(\n+        &self,\n+        key: &str,\n+        options: GetOptions,\n+    ) -> Result<(Arc<Vec<u8>>, Option<ETag>), StorageError> {\n+        let atomic_priority = Arc::new(AtomicUsize::new(options.priority.as_usize()));\n+        AdmissionControlledS3Storage::read_from_storage(\n+            self.storage.clone(),\n+            self.rate_limiter.clone(),\n+            key.to_string(),\n+            atomic_priority,\n+            None,\n+        )\n+        .await\n+    }\n+\n     async fn oneshot_upload(\n         &self,\n         key: &str,\n---\nrust/storage/src/lib.rs\n@@ -400,11 +400,20 @@ impl PutOptions {\n #[derive(Clone, Debug, Default)]\n pub struct GetOptions {\n     priority: StorageRequestPriority,\n+    requires_strong_consistency: bool,\n }\n \n impl GetOptions {\n     pub fn new(priority: StorageRequestPriority) -> Self {\n-        Self { priority }\n+        Self {\n+            priority,\n+            requires_strong_consistency: false,\n+        }\n+    }\n+\n+    pub fn with_strong_consistency(mut self) -> Self {\n+        self.requires_strong_consistency = true;\n+        self\n     }\n }\n \n---\nrust/storage/src/s3.rs\n@@ -310,6 +310,7 @@ impl S3Storage {\n         self.get_with_e_tag(key).await.map(|(buf, _)| buf)\n     }\n \n+    /// Perform a strongly consistent get and return the e_tag.\n     #[tracing::instrument(skip(self))]\n     pub async fn get_with_e_tag(\n         &self,\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n- Improvements & Bug fixes\r\n  - Tags the prefetch record segment operator as IO\r\n  - Fixes a potential spinloop in the admission controller where .recv() returns None on sender drop. It is unclear why the sender could drop, and that needs to be investigated. But this change makes sense defensively at the function level. This could alternatively use `tokio::sync::Notify`\r\n- New functionality\r\n  - /\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\nNone\r\n\n\n---\n\nChoice A:\nrust/blockstore/src/arrow/provider.rs\n@@ -469,6 +469,15 @@ pub struct RootManager {\n     prefetched_roots: Arc<parking_lot::Mutex<HashMap<Uuid, Duration>>>,\n }\n \n+impl std::fmt::Debug for RootManager {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"RootManager\")\n+            .field(\"cache\", &self.cache)\n+            .field(\"storage\", &self.storage)\n+            .finish()\n+    }\n+}\n+\n impl RootManager {\n     pub fn new(storage: Storage, cache: Box<dyn PersistentCache<Uuid, RootReader>>) -> Self {\n         let cache: Arc<dyn PersistentCache<Uuid, RootReader>> = cache.into();\n---\nrust/garbage_collector/src/operators/list_files_at_version.rs\n@@ -0,0 +1,160 @@\n+use async_trait::async_trait;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n+use chroma_system::{Operator, OperatorType};\n+use chroma_types::{chroma_proto::CollectionVersionFile, CollectionUuid, HNSW_PATH};\n+use std::{collections::HashSet, str::FromStr};\n+use thiserror::Error;\n+use tokio::task::{JoinError, JoinSet};\n+use uuid::Uuid;\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionInput {\n+    root_manager: RootManager,\n+    version_file: CollectionVersionFile,\n+    version: i64,\n+}\n+\n+impl ListFilesAtVersionInput {\n+    pub fn new(\n+        root_manager: RootManager,\n+        version_file: CollectionVersionFile,\n+        version: i64,\n+    ) -> Self {\n+        Self {\n+            root_manager,\n+            version_file,\n+            version,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ListFilesAtVersionOutput {\n+    pub collection_id: CollectionUuid,\n+    pub version: i64,\n+    pub file_paths: HashSet<String>,\n+}\n+\n+#[derive(Debug, Error)]\n+pub enum ListFilesAtVersionError {\n+    #[error(\"Version history field missing\")]\n+    VersionHistoryMissing,\n+    #[error(\"Version {0} not found\")]\n+    VersionNotFound(i64),\n+    #[error(\"Invalid UUID: {0}\")]\n+    InvalidUuid(uuid::Error),\n+    #[error(\"Sparse index fetch task failed: {0}\")]\n+    SparseIndexTaskFailed(JoinError),\n+    #[error(\"Error fetching block IDs for sparse index: {0}\")]\n+    FetchBlockIdsError(#[from] RootManagerError),\n+    #[error(\"Version file missing collection ID\")]\n+    VersionFileMissingCollectionId,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ListFilesAtVersionsOperator {}\n+\n+#[async_trait]\n+impl Operator<ListFilesAtVersionInput, ListFilesAtVersionOutput> for ListFilesAtVersionsOperator {\n+    type Error = ListFilesAtVersionError;\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n+\n+    async fn run(\n+        &self,\n+        input: &ListFilesAtVersionInput,\n+    ) -> Result<ListFilesAtVersionOutput, Self::Error> {\n+        let collection_id = CollectionUuid::from_str(\n+            &input\n+                .version_file\n+                .collection_info_immutable\n+                .as_ref()\n+                .ok_or_else(|| ListFilesAtVersionError::VersionFileMissingCollectionId)?\n+                .collection_id,\n+        )\n+        .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+        let version_history = input\n+            .version_file\n+            .version_history\n+            .as_ref()\n+            .ok_or_else(|| ListFilesAtVersionError::VersionHistoryMissing)?;\n+\n+        let mut file_paths = HashSet::new();\n+        let mut sparse_index_ids = HashSet::new();\n+\n+        let version = version_history\n+            .versions\n+            .iter()\n+            .find(|v| v.version == input.version)\n+            .ok_or_else(|| ListFilesAtVersionError::VersionNotFound(input.version))?;\n+\n+        tracing::debug!(\n+            \"Listing files at version {} for collection {}.\",\n+            version.version,\n+            collection_id,\n+        );\n+        tracing::trace!(\n+            \"Processing version {:#?} for collection {}\",\n+            version,\n+            collection_id\n+        );\n+\n+        if let Some(segment_info) = &version.segment_info {\n+            for segment in &segment_info.segment_compaction_info {\n+                for (file_type, segment_paths) in &segment.file_paths {\n+                    if file_type == \"hnsw_index\" || file_type == HNSW_PATH {\n+                        for path in &segment_paths.paths {\n+                            for hnsw_file in [\n+                                \"header.bin\",\n+                                \"data_level0.bin\",\n+                                \"length.bin\",\n+                                \"link_lists.bin\",\n+                            ] {\n+                                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                                file_paths.insert(format!(\"hnsw/{}/{}\", path, hnsw_file));\n+                            }\n+                        }\n+                    } else {\n+                        // Must be a sparse index\n+                        for path in &segment_paths.paths {\n+                            // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                            file_paths.insert(format!(\"sparse_index/{}\", path));\n+\n+                            let sparse_index_id = Uuid::parse_str(path)\n+                                .map_err(ListFilesAtVersionError::InvalidUuid)?;\n+\n+                            sparse_index_ids.insert(sparse_index_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut block_id_tasks = JoinSet::new();\n+        for sparse_index_id in sparse_index_ids {\n+            let root_manager = input.root_manager.clone();\n+            block_id_tasks\n+                .spawn(async move { root_manager.get_all_block_ids(&sparse_index_id).await });\n+        }\n+\n+        while let Some(res) = block_id_tasks.join_next().await {\n+            let block_ids = res\n+                .map_err(ListFilesAtVersionError::SparseIndexTaskFailed)?\n+                .map_err(ListFilesAtVersionError::FetchBlockIdsError)?;\n+\n+            for block_id in block_ids {\n+                // Path construction here will need to be updated after the upcoming collection file prefix changes.\n+                file_paths.insert(format!(\"block/{}\", block_id));\n+            }\n+        }\n+\n+        Ok(ListFilesAtVersionOutput {\n+            collection_id,\n+            version: input.version,\n+            file_paths,\n+        })\n+    }\n+}\n---\nrust/garbage_collector/src/operators/mod.rs\n@@ -8,4 +8,5 @@ pub mod fetch_lineage_file;\n pub mod fetch_sparse_index_files;\n pub mod fetch_version_file;\n pub mod get_version_file_paths;\n+pub mod list_files_at_version;\n pub mod mark_versions_at_sysdb;\n---\n\n\n---\n\nChoice B:\nrust/storage/src/admissioncontrolleds3.rs\n@@ -548,9 +548,19 @@ impl CountBasedPolicy {\n             match &mut channel_receiver {\n                 Some(rx) => {\n                     select! {\n-                        _ = rx.recv() => {\n+                        did_recv = rx.recv() => {\n                             // Reevaluate priority if we got a notification.\n-                            continue;\n+                            match did_recv {\n+                                Some(_) => {\n+                                    // If we got a notification, continue to acquire.\n+                                    continue;\n+                                }\n+                                None => {\n+                                    // If the channel was closed, break out of the loop.\n+                                    channel_receiver = None;\n+                                    continue;\n+                                }\n+                            }\n                         }\n                         token = self.remaining_tokens[current_priority.as_usize()].acquire() => {\n                             match token {\n---\nrust/worker/src/execution/operators/prefetch_record.rs\n@@ -6,7 +6,7 @@ use chroma_segment::{\n     blockfile_record::{RecordSegmentReader, RecordSegmentReaderCreationError},\n     types::{materialize_logs, LogMaterializerError},\n };\n-use chroma_system::Operator;\n+use chroma_system::{Operator, OperatorType};\n use thiserror::Error;\n use tracing::{trace, Instrument, Span};\n \n@@ -94,4 +94,8 @@ impl Operator<PrefetchRecordInput, PrefetchRecordOutput> for PrefetchRecordOpera\n     fn errors_when_sender_dropped(&self) -> bool {\n         false\n     }\n+\n+    fn get_type(&self) -> OperatorType {\n+        OperatorType::IO\n+    }\n }\n---\n\n\n---\n\nChoice C:\nrust/worker/src/execution/operators/filter.rs\n@@ -498,6 +498,11 @@ impl Operator<FilterInput, FilterOutput> for FilterOperator {\n     async fn run(&self, input: &FilterInput) -> Result<FilterOutput, FilterError> {\n         tracing::debug!(\"[{}]: {:?}\", self.get_name(), input);\n \n+        // NOTE: This is temporary traces to capture filter arguments\n+        //       We suspect certain filters break the FTS algorithm\n+        // TODO: Remove this after the bug is found\n+        tracing::debug!(\"[DEBUG FILTER OPERATOR]: {:?}\", self);\n+\n         let record_segment_reader = match RecordSegmentReader::from_segment(\n             &input.record_segment,\n             &input.blockfile_provider,\n---\nrust/worker/src/execution/operators/projection.rs\n@@ -71,6 +71,8 @@ pub enum ProjectionError {\n     RecordSegment(#[from] Box<dyn ChromaError>),\n     #[error(\"Error reading unitialized record segment\")]\n     RecordSegmentUninitialized,\n+    #[error(\"Error reading phantom record: {0}\")]\n+    RecordSegmentPhantomRecord(u32),\n }\n \n impl ChromaError for ProjectionError {\n@@ -80,6 +82,7 @@ impl ChromaError for ProjectionError {\n             ProjectionError::RecordReader(e) => e.code(),\n             ProjectionError::RecordSegment(e) => e.code(),\n             ProjectionError::RecordSegmentUninitialized => ErrorCodes::Internal,\n+            ProjectionError::RecordSegmentPhantomRecord(_) => ErrorCodes::Internal,\n         }\n     }\n }\n@@ -153,7 +156,7 @@ impl Operator<ProjectionInput, ProjectionOutput> for ProjectionOperator {\n                         let record = reader\n                             .get_data_for_offset_id(*offset_id)\n                             .await?\n-                            .ok_or(ProjectionError::RecordSegmentUninitialized)?;\n+                            .ok_or(ProjectionError::RecordSegmentPhantomRecord(*offset_id))?;\n                         ProjectionRecord {\n                             id: record.id.to_string(),\n                             document: record\n---\n\n\n---\n\nChoice D:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -830,12 +836,15 @@ impl DataSet for ReferencingDataSet {\n         &self,\n         client: &ChromaClient,\n         uq: UpsertQuery,\n-        _: &mut Guacamole,\n+        guac: &mut Guacamole,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n-        for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+        for _ in 0..uq.batch_size {\n+            let key = uq.key.select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nPreviously, the frontend was unconditionally attempting to unwrap the collection config, even if it was None. This wasn't caught before because all of the popular clients are actually passing in a collection config. However, it should be optional.\r\n\r\n## Test plan\r\n\r\nNot tested yet, will check in staging after it merges.\r\n\r\n## Documentation Changes\r\n\r\nn/a\r\n\n\n---\n\nChoice A:\nrust/segment/src/sqlite_metadata.rs\n@@ -482,8 +482,9 @@ impl IntoSqliteExpr for DocumentExpression {\n             EmbeddingFulltextSearch::StringValue,\n         ));\n         let doc_contains = doc_col\n+            .clone()\n             .like(format!(\"%{}%\", self.pattern.replace(\"%\", \"\")))\n-            .is(true);\n+            .and(doc_col.is_not_null());\n         match self.operator {\n             DocumentOperator::Contains => doc_contains,\n             DocumentOperator::NotContains => doc_contains.not(),\n@@ -495,9 +496,11 @@ impl IntoSqliteExpr for DocumentExpression {\n \n impl IntoSqliteExpr for MetadataExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let key_cond = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key))\n+        let key_col = Expr::col((EmbeddingMetadata::Table, EmbeddingMetadata::Key));\n+        let key_cond = key_col\n+            .clone()\n             .eq(self.key.to_string())\n-            .is(true);\n+            .and(key_col.is_not_null());\n         match &self.comparison {\n             MetadataComparison::Primitive(op, val) => {\n                 let (col, sval) = match val {\n---\n\n\n---\n\nChoice B:\nrust/load/src/data_sets.rs\n@@ -1212,13 +1212,6 @@ impl DataSet for VerifyingDataSet {\n             }\n         };\n \n-        event!(\n-            Level::INFO,\n-            \"Upserting {} keys, new cardinality: {}\",\n-            uq.batch_size,\n-            key_start_index + uq.batch_size\n-        );\n-\n         for offset in 0..uq.batch_size {\n             let key = uq.key.select_from_reference(self, offset);\n             if !keys.contains(&key) {\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/server.rs\n@@ -915,57 +915,67 @@ async fn create_collection(\n     let payload_clone = payload.clone();\n \n     let configuration = if !server.config.enable_set_index_params {\n-        let mut new_configuration = payload.configuration.clone().unwrap();\n-        let hnsw_config = new_configuration.hnsw.clone();\n-        let spann_config = new_configuration.spann.clone();\n-\n-        if let Some(hnsw) = &hnsw_config {\n-            let space = hnsw.space.clone();\n-            if hnsw.ef_construction.is_some()\n-                || hnsw.ef_search.is_some()\n-                || hnsw.max_neighbors.is_some()\n-                || hnsw.num_threads.is_some()\n-                || hnsw.resize_factor.is_some()\n-                || hnsw.sync_threshold.is_some()\n-                || hnsw.batch_size.is_some()\n-            {\n-                return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n-                    \"HNSW\".to_string(),\n-                )\n-                .into());\n+        if let Some(mut new_configuration) = payload.configuration.clone() {\n+            let hnsw_config = new_configuration.hnsw.clone();\n+            let spann_config = new_configuration.spann.clone();\n+\n+            if let Some(hnsw) = &hnsw_config {\n+                let space = hnsw.space.clone();\n+                if hnsw.ef_construction.is_some()\n+                    || hnsw.ef_search.is_some()\n+                    || hnsw.max_neighbors.is_some()\n+                    || hnsw.num_threads.is_some()\n+                    || hnsw.resize_factor.is_some()\n+                    || hnsw.sync_threshold.is_some()\n+                    || hnsw.batch_size.is_some()\n+                {\n+                    return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n+                        \"HNSW\".to_string(),\n+                    )\n+                    .into());\n+                }\n+                let new_hnsw = HnswConfiguration {\n+                    space,\n+                    ..Default::default()\n+                };\n+                new_configuration.hnsw = Some(new_hnsw);\n+            } else if let Some(spann) = &spann_config {\n+                let space = spann.space.clone();\n+                if spann.search_nprobe.is_some()\n+                    || spann.write_nprobe.is_some()\n+                    || spann.ef_construction.is_some()\n+                    || spann.ef_search.is_some()\n+                    || spann.max_neighbors.is_some()\n+                    || spann.reassign_neighbor_count.is_some()\n+                    || spann.split_threshold.is_some()\n+                    || spann.merge_threshold.is_some()\n+                {\n+                    return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n+                        \"SPANN\".to_string(),\n+                    )\n+                    .into());\n+                }\n+                let new_spann = SpannConfiguration {\n+                    space,\n+                    ..Default::default()\n+                };\n+                new_configuration.spann = Some(new_spann);\n             }\n-            let new_hnsw = HnswConfiguration {\n-                space,\n-                ..Default::default()\n-            };\n-            new_configuration.hnsw = Some(new_hnsw);\n-        } else if let Some(spann) = &spann_config {\n-            let space = spann.space.clone();\n-            if spann.search_nprobe.is_some()\n-                || spann.write_nprobe.is_some()\n-                || spann.ef_construction.is_some()\n-                || spann.ef_search.is_some()\n-                || spann.max_neighbors.is_some()\n-                || spann.reassign_neighbor_count.is_some()\n-                || spann.split_threshold.is_some()\n-                || spann.merge_threshold.is_some()\n-            {\n-                return Err(ValidationError::SpaceConfigurationForVectorIndexType(\n-                    \"SPANN\".to_string(),\n-                )\n-                .into());\n-            }\n-            let new_spann = SpannConfiguration {\n-                space,\n-                ..Default::default()\n-            };\n-            new_configuration.spann = Some(new_spann);\n-        }\n \n-        Some(InternalCollectionConfiguration::try_from_config(\n-            new_configuration,\n-            server.config.frontend.default_knn_index,\n-        )?)\n+            Some(InternalCollectionConfiguration::try_from_config(\n+                new_configuration,\n+                server.config.frontend.default_knn_index,\n+            )?)\n+        } else {\n+            Some(InternalCollectionConfiguration::try_from_config(\n+                CollectionConfiguration {\n+                    hnsw: None,\n+                    spann: None,\n+                    embedding_function: None,\n+                },\n+                server.config.frontend.default_knn_index,\n+            )?)\n+        }\n     } else {\n         match payload_clone.configuration {\n             Some(c) => Some(InternalCollectionConfiguration::try_from_config(\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/auth/mod.rs\n@@ -70,12 +70,40 @@ pub struct AuthzResource {\n }\n \n #[derive(thiserror::Error, Debug)]\n-#[error(\"Permission denied.\")]\n-pub struct AuthError(pub StatusCode);\n+pub struct AuthError {\n+    pub status_code: StatusCode,\n+    pub message: Option<String>,\n+}\n+\n+impl Display for AuthError {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(\n+            f,\n+            \"{}\",\n+            self.message.as_deref().unwrap_or(\"Permission denied.\")\n+        )\n+    }\n+}\n+\n+impl AuthError {\n+    pub fn new(status_code: StatusCode) -> Self {\n+        Self {\n+            status_code,\n+            message: None,\n+        }\n+    }\n+\n+    pub fn with_message(status_code: StatusCode, message: impl Into<String>) -> Self {\n+        Self {\n+            status_code,\n+            message: Some(message.into()),\n+        }\n+    }\n+}\n \n impl chroma_error::ChromaError for AuthError {\n     fn code(&self) -> chroma_error::ErrorCodes {\n-        match self.0 {\n+        match self.status_code {\n             StatusCode::UNAUTHORIZED => chroma_error::ErrorCodes::Unauthenticated,\n             StatusCode::FORBIDDEN => chroma_error::ErrorCodes::PermissionDenied,\n             _ => chroma_error::ErrorCodes::Internal,\n---\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -235,6 +235,22 @@ impl ServiceBasedFrontend {\n         }\n     }\n \n+    fn _parse_universal_collection_identifier(input: String) -> Option<(String, String, String)> {\n+        let parts: Vec<&str> = input.split('/').collect();\n+        match parts.as_slice() {\n+            [tenant, database, collection]\n+                if !tenant.is_empty() && !database.is_empty() && !collection.is_empty() =>\n+            {\n+                Some((\n+                    tenant.to_string(),\n+                    database.to_string(),\n+                    collection.to_string(),\n+                ))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub async fn reset(&mut self) -> Result<ResetResponse, ResetError> {\n         if !self.allow_reset {\n             return Err(ResetError::NotAllowed);\n@@ -362,12 +378,19 @@ impl ServiceBasedFrontend {\n             ..\n         }: GetCollectionRequest,\n     ) -> Result<GetCollectionResponse, GetCollectionError> {\n+        let (resolved_tenant_id, resolved_database_name, resolved_collection_name) =\n+            Self::_parse_universal_collection_identifier(collection_name.clone()).unwrap_or((\n+                tenant_id.clone(),\n+                database_name.clone(),\n+                collection_name.clone(),\n+            ));\n+\n         let mut collections = self\n             .sysdb_client\n             .get_collections(GetCollectionsOptions {\n-                name: Some(collection_name.clone()),\n-                tenant: Some(tenant_id.clone()),\n-                database: Some(database_name.clone()),\n+                name: Some(resolved_collection_name.clone()),\n+                tenant: Some(resolved_tenant_id.clone()),\n+                database: Some(resolved_database_name.clone()),\n                 limit: Some(1),\n                 ..Default::default()\n             })\n---\n\n\n---\n\n"}], "ideal": "C"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nThis operator was previously swallowing error details.\n\n---\n\nChoice A:\nrust/types/src/api_types.rs\n@@ -82,7 +82,7 @@ impl ChromaError for GetCollectionWithSegmentsError {\n             GetCollectionWithSegmentsError::CollectionConversionError(\n                 collection_conversion_error,\n             ) => collection_conversion_error.code(),\n-            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            GetCollectionWithSegmentsError::DuplicateSegment => ErrorCodes::Internal,\n             GetCollectionWithSegmentsError::Field(_) => ErrorCodes::FailedPrecondition,\n             GetCollectionWithSegmentsError::SegmentConversionError(segment_conversion_error) => {\n                 segment_conversion_error.code()\n@@ -832,7 +832,7 @@ impl ChromaError for ForkCollectionError {\n             ForkCollectionError::CollectionConversionError(collection_conversion_error) => {\n                 collection_conversion_error.code()\n             }\n-            ForkCollectionError::DuplicateSegment => ErrorCodes::FailedPrecondition,\n+            ForkCollectionError::DuplicateSegment => ErrorCodes::Internal,\n             ForkCollectionError::Field(_) => ErrorCodes::FailedPrecondition,\n             ForkCollectionError::Local => ErrorCodes::Unimplemented,\n             ForkCollectionError::Internal(chroma_error) => chroma_error.code(),\n---\n\n\n---\n\nChoice B:\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -140,21 +140,20 @@ impl GarbageCollector {\n             .as_ref()\n             .ok_or(GarbageCollectCollectionError::Uninitialized)?;\n \n-        let use_v1_orchestrator = match cleanup_mode {\n-            CleanupMode::DryRun | CleanupMode::Rename | CleanupMode::Delete => true,\n-            CleanupMode::DryRunV2 | CleanupMode::DeleteV2 => false,\n-        };\n-\n-        if use_v1_orchestrator {\n+        if cleanup_mode.is_v2() {\n             let orchestrator =\n-                crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+                crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n                     collection.id,\n                     collection.version_file_path,\n+                    collection.lineage_file_path,\n                     absolute_cutoff_time,\n                     self.sysdb_client.clone(),\n                     dispatcher.clone(),\n+                    system.clone(),\n                     self.storage.clone(),\n+                    self.root_manager.clone(),\n                     cleanup_mode,\n+                    2,\n                 );\n \n             let started_at = SystemTime::now();\n@@ -178,23 +177,19 @@ impl GarbageCollector {\n                     format!(\"{:?}\", cleanup_mode),\n                 )],\n             );\n+\n             return Ok(result);\n         }\n \n-        let orchestrator =\n-            crate::garbage_collector_orchestrator_v2::GarbageCollectorOrchestrator::new(\n-                collection.id,\n-                collection.version_file_path,\n-                collection.lineage_file_path,\n-                absolute_cutoff_time,\n-                self.sysdb_client.clone(),\n-                dispatcher.clone(),\n-                system.clone(),\n-                self.storage.clone(),\n-                self.root_manager.clone(),\n-                cleanup_mode,\n-                2,\n-            );\n+        let orchestrator = crate::garbage_collector_orchestrator::GarbageCollectorOrchestrator::new(\n+            collection.id,\n+            collection.version_file_path,\n+            absolute_cutoff_time,\n+            self.sysdb_client.clone(),\n+            dispatcher.clone(),\n+            self.storage.clone(),\n+            cleanup_mode,\n+        );\n \n         let started_at = SystemTime::now();\n         let result = orchestrator.run(system.clone()).await?;\n@@ -217,7 +212,6 @@ impl GarbageCollector {\n                 format!(\"{:?}\", cleanup_mode),\n             )],\n         );\n-\n         Ok(result)\n     }\n }\n@@ -360,9 +354,18 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 continue;\n             }\n \n-            if collection.lineage_file_path.is_some() {\n+            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n+                tenant_mode_overrides\n+                    .get(&collection.tenant)\n+                    .cloned()\n+                    .unwrap_or(self.default_cleanup_mode)\n+            } else {\n+                self.default_cleanup_mode\n+            };\n+\n+            if collection.lineage_file_path.is_some() && !cleanup_mode.is_v2() {\n                 tracing::debug!(\n-                    \"Skipping garbage collection for root of fork tree: {}\",\n+                    \"Skipping garbage collection for root of fork tree because GC v1 cannot handle fork trees: {}\",\n                     collection.id\n                 );\n                 num_skipped_jobs += 1;\n@@ -376,17 +379,6 @@ impl Handler<GarbageCollectMessage> for GarbageCollector {\n                 collection.version_file_path\n             );\n \n-            let cleanup_mode = if let Some(tenant_mode_overrides) = &self.tenant_mode_overrides {\n-                tenant_mode_overrides\n-                    .get(&collection.tenant)\n-                    .cloned()\n-                    .unwrap_or(self.default_cleanup_mode)\n-            } else {\n-                self.default_cleanup_mode\n-            };\n-\n-            tracing::info!(\"Creating gc orchestrator for collection: {}\", collection.id);\n-\n             let instrumented_span = span!(parent: None, tracing::Level::INFO, \"Garbage collection job\", collection_id = ?collection.id, tenant_id = %collection.tenant, cleanup_mode = ?cleanup_mode);\n             instrumented_span.follows_from(Span::current());\n \n@@ -1011,6 +1003,26 @@ mod tests {\n         let (collection_in_delete_mode, database_name_in_delete_mode) =\n             collection_in_delete_mode_handle.await.unwrap();\n \n+        // Fork collection in delete mode to give it a lineage file (only GC v2 can handle fork trees)\n+        {\n+            let source_collection = sysdb\n+                .get_collections(Some(collection_in_delete_mode), None, None, None, None, 0)\n+                .await\n+                .unwrap();\n+            let source_collection = source_collection.first().unwrap();\n+\n+            sysdb\n+                .fork_collection(\n+                    collection_in_delete_mode,\n+                    source_collection.total_records_post_compaction,\n+                    source_collection.total_records_post_compaction,\n+                    CollectionUuid::new(),\n+                    \"test-fork\".to_string(),\n+                )\n+                .await\n+                .unwrap();\n+        }\n+\n         // Wait 1 second for cutoff time\n         tokio::time::sleep(Duration::from_secs(1)).await;\n \n---\nrust/garbage_collector/src/types.rs\n@@ -19,6 +19,12 @@ pub enum CleanupMode {\n     DeleteV2,\n }\n \n+impl CleanupMode {\n+    pub fn is_v2(&self) -> bool {\n+        matches!(self, CleanupMode::DryRunV2 | CleanupMode::DeleteV2)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub enum VersionStatus {\n     #[allow(dead_code)]\n---\n\n\n---\n\nChoice C:\nrust/types/src/lib.rs\n@@ -23,6 +23,7 @@ mod tenant;\n mod validators;\n mod where_parsing;\n \n+pub mod optional_u128;\n pub mod regex;\n \n // Re-export the types module, so that we can use it as a single import in other modules.\n---\nrust/types/src/optional_u128.rs\n@@ -0,0 +1,74 @@\n+pub mod optional_u128_as_hex {\n+    use serde::de::Error;\n+    use serde::{Deserialize, Deserializer, Serializer};\n+\n+    /// Serializes `Option<u128>` as lowercase hex string if Some, skips if None.\n+    pub fn serialize<S>(val: &Option<u128>, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        match val {\n+            Some(v) => serializer.serialize_str(&format!(\"{:x}\", v)),\n+            None => serializer.serialize_none(),\n+        }\n+    }\n+\n+    /// Deserializes a lowercase hex string into `Option<u128>`.\n+    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<u128>, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let opt: Option<String> = Option::deserialize(deserializer)?;\n+        match opt {\n+            Some(s) => {\n+                let val = u128::from_str_radix(&s, 16).map_err(D::Error::custom)?;\n+                Ok(Some(val))\n+            }\n+            None => Ok(None),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::optional_u128_as_hex;\n+    use serde::{Deserialize, Serialize};\n+\n+    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n+    struct TestStruct {\n+        #[serde(\n+            with = \"optional_u128_as_hex\",\n+            default,\n+            skip_serializing_if = \"Option::is_none\"\n+        )]\n+        value: Option<u128>,\n+    }\n+\n+    #[test]\n+    fn test_serialize_some_u128() {\n+        let s = TestStruct { value: Some(255) };\n+        let json = serde_json::to_string(&s).unwrap();\n+        assert_eq!(json, r#\"{\"value\":\"ff\"}\"#);\n+    }\n+\n+    #[test]\n+    fn test_serialize_none() {\n+        let s = TestStruct { value: None };\n+        let json = serde_json::to_string(&s).unwrap();\n+        assert_eq!(json, r#\"{}\"#);\n+    }\n+\n+    #[test]\n+    fn test_deserialize_some_u128() {\n+        let json = r#\"{\"value\":\"ff\"}\"#;\n+        let s: TestStruct = serde_json::from_str(json).unwrap();\n+        assert_eq!(s, TestStruct { value: Some(255) });\n+    }\n+\n+    #[test]\n+    fn test_deserialize_none() {\n+        let json = r#\"{}\"#;\n+        let s: TestStruct = serde_json::from_str(json).unwrap();\n+        assert_eq!(s, TestStruct { value: None });\n+    }\n+}\n---\n\n\n---\n\nChoice D:\nrust/garbage_collector/src/operators/compute_unused_files.rs\n@@ -1,5 +1,5 @@\n use async_trait::async_trait;\n-use chroma_blockstore::RootManager;\n+use chroma_blockstore::{arrow::provider::RootManagerError, RootManager};\n use chroma_cache::nop::NopCache;\n use chroma_error::{ChromaError, ErrorCodes};\n use chroma_storage::Storage;\n@@ -145,14 +145,14 @@ impl ComputeUnusedFilesOperator {\n         for si_id in si_ids {\n             let uuid = Uuid::parse_str(&si_id).map_err(|e| {\n                 tracing::error!(error = %e, \"Failed to parse UUID\");\n-                ComputeUnusedFilesError::ParseError(si_id.clone(), e.to_string())\n+                ComputeUnusedFilesError::InvalidUuid(e, si_id.clone())\n             })?;\n \n             let block_ids = match self.root_manager.get_all_block_ids(&uuid).await {\n                 Ok(ids) => ids,\n                 Err(e) => {\n                     tracing::error!(error = %e, \"Failed to get block IDs\");\n-                    return Err(ComputeUnusedFilesError::ParseError(si_id, e.to_string()));\n+                    return Err(ComputeUnusedFilesError::FailedToFetchBlockIDs(e));\n                 }\n             };\n             tracing::debug!(\n@@ -193,8 +193,10 @@ pub struct ComputeUnusedFilesOutput {\n \n #[derive(Error, Debug)]\n pub enum ComputeUnusedFilesError {\n-    #[error(\"Error parsing sparse index file: {0}\")]\n-    ParseError(String, String),\n+    #[error(\"Error parsing UUID: {0} from {1}\")]\n+    InvalidUuid(uuid::Error, String),\n+    #[error(\"Failed to fetch block IDs: {0}\")]\n+    FailedToFetchBlockIDs(RootManagerError),\n     #[error(\"Version file has missing content\")]\n     VersionFileMissingContent(i64),\n     #[error(\"Version history is missing\")]\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\n_Summarize the changes made by this PR._\r\n\r\n- Improvements & Bug fixes\r\n  - I just updated my local branch and pruned the docker build cache, found the frontend service tilt build failed on my MacOS. Fix it in this PR.\r\n\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nTiltfile\n@@ -92,7 +92,7 @@ else:\n   docker_build(\n     'frontend-service',\n     '.',\n-    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/'],\n+    only=['chromadb/', 'idl/', 'requirements.txt', 'bin/', 'Cargo.toml', 'Cargo.lock', 'rust/', 'pyproject.toml', 'README.md'],\n     dockerfile='./Dockerfile',\n     ignore=['**/*.pyc', 'chromadb/test/'],\n   )\n---\n\n\n---\n\nChoice B:\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.37\n+version: 0.1.38\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/rust-log-service.yaml\n@@ -11,12 +11,30 @@ data:\n \n ---\n \n+apiVersion: v1\n+kind: Service\n+metadata:\n+  name: rust-log-service\n+  namespace: {{ .Values.namespace }}\n+spec:\n+  ports:\n+    - name: server-port\n+      port: 50051\n+      targetPort: 50051\n+  clusterIP: None\n+  selector:\n+    app: rust-log-service\n+  type: ClusterIP\n+\n+---\n+\n apiVersion: apps/v1\n-kind: Deployment\n+kind: StatefulSet\n metadata:\n   name: rust-log-service\n   namespace: {{ .Values.namespace }}\n spec:\n+  serviceName: rust-log-service\n   replicas: {{ .Values.rustLogService.replicaCount }}\n   selector:\n     matchLabels:\n@@ -25,20 +43,48 @@ spec:\n     metadata:\n       labels:\n         app: rust-log-service\n+        member-type: rust-log-service\n     spec:\n       serviceAccountName: rust-log-service-serviceaccount\n+      volumes:\n+        {{if .Values.rustLogService.configuration}}\n+        - name: rust-log-service-config\n+          configMap:\n+            name: rust-log-service-config\n+        {{ end }}\n+        {{if .Values.rustLogService.cache}}\n+        - name: rust-log-service-cache\n+          hostPath:\n+            path: {{ .Values.rustLogService.cache.hostPath }}\n+            type: DirectoryOrCreate\n+        {{ end }}\n       containers:\n         - name: rust-log-service\n           {{ if .Values.rustLogService.command }}\n           command: {{ .Values.rustLogService.command }}\n           {{ end }}\n           image: \"{{ .Values.rustLogService.image.repository }}:{{ .Values.rustLogService.image.tag }}\"\n           imagePullPolicy: IfNotPresent\n-          ports:\n-            - containerPort: 50051\n           readinessProbe:\n             grpc:\n               port: 50051\n+          volumeMounts:\n+            {{if .Values.rustLogService.configuration}}\n+            - name: rust-log-service-config\n+              mountPath: /config/\n+            {{ end }}\n+            {{if .Values.rustLogService.cache}}\n+            - name: rust-log-service-cache\n+              mountPath: {{ .Values.rustLogService.cache.mountPath }}\n+            {{ end }}\n+          ports:\n+            - containerPort: 50051\n+          env:\n+            - name: CONFIG_PATH\n+              value: \"/config/config.yaml\"\n+            {{ if .Values.rustLogService.otherEnvConfig }}\n+              {{ .Values.rustLogService.otherEnvConfig | nindent 12 }}\n+            {{ end }}\n           {{ if .Values.rustLogService.resources }}\n           resources:\n             limits:\n@@ -48,18 +94,6 @@ spec:\n               cpu: {{ .Values.rustLogService.resources.requests.cpu }}\n               memory: {{ .Values.rustLogService.resources.requests.memory }}\n           {{ end }}\n-          env:\n-            - name: CONFIG_PATH\n-              value: \"/config/config.yaml\"\n-            {{ if .Values.rustLogService.otherEnvConfig }}\n-              {{ .Values.rustLogService.otherEnvConfig | nindent 12 }}\n-            {{ end }}\n-          {{if .Values.rustLogService.configuration}}\n-          volumeMounts:\n-            - name: rust-log-service-config\n-              mountPath: /config/\n-          {{ end }}\n-\n       {{if .Values.rustLogService.tolerations}}\n       tolerations:\n         {{ toYaml .Values.rustLogService.tolerations | nindent 8 }}\n@@ -68,29 +102,13 @@ spec:\n       nodeSelector:\n         {{ toYaml .Values.rustLogService.nodeSelector | nindent 8 }}\n       {{ end }}\n-      {{if .Values.rustLogService.configuration}}\n-      volumes:\n-        - name: rust-log-service-config\n-          configMap:\n-            name: rust-log-service-config\n-      {{ end }}\n-\n----\n-\n-apiVersion: v1\n-kind: Service\n-metadata:\n-  name: rust-log-service\n-  namespace: {{ .Values.namespace }}\n-spec:\n-  ports:\n-    - name: server-port\n-      port: 50051\n-      targetPort: 50051\n-  selector:\n-    app: rust-log-service\n-  type: ClusterIP\n-\n+      topologySpreadConstraints:\n+        - maxSkew: 1\n+          topologyKey: \"kubernetes.io/hostname\"\n+          whenUnsatisfiable: ScheduleAnyway\n+          labelSelector:\n+            matchLabels:\n+              member-type: rust-log-service\n \n ---\n \n---\n\n\n---\n\nChoice C:\nrust/wal3/src/manifest.rs\n@@ -599,7 +599,10 @@ impl Manifest {\n         let path = manifest_path(prefix);\n         loop {\n             match storage\n-                .get_with_e_tag(&path, GetOptions::new(StorageRequestPriority::P0))\n+                .get_with_e_tag(\n+                    &path,\n+                    GetOptions::new(StorageRequestPriority::P0).with_strong_consistency(),\n+                )\n                 .await\n                 .map_err(Arc::new)\n             {\n---\n\n\n---\n\nChoice D:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.11\"\n+__version__ = \"1.0.12\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.11\"\n+      \"Default\": \"1.0.12\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.11\"\n+chroma_version                  = \"1.0.12\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.11\"\n+  default     = \"1.0.12\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nMake the trace exporter to export all INFO and above traces (not just ERROR).\r\n\r\nAlso, update load service tracing to use GRPC (to match our other services).\r\n\r\n## Test plan\r\n\r\nRan locally via `tilt up`. Verified traces appear under `chroma-load` service in jaeger.\r\n\r\n## Documentation Changes\r\n\r\nn/a\r\n\n\n---\n\nChoice A:\nTiltfile\n@@ -140,6 +140,21 @@ else:\n     target='garbage_collector'\n   )\n \n+if config.tilt_subcommand == \"ci\":\n+  custom_build(\n+    'load-service',\n+    'docker buildx build --load -t $EXPECTED_REF --target load_service -f ./rust/load/Dockerfile .',\n+    ['./rust/', './idl/', './Cargo.toml', './Cargo.lock']\n+  )\n+else:\n+  docker_build(\n+    'load-service',\n+    '.',\n+    only=[\"rust/\", \"idl/\", \"Cargo.toml\", \"Cargo.lock\"],\n+    dockerfile='./rust/load/Dockerfile',\n+    target='load_service'\n+  )\n+\n \n # First install the CRD\n k8s_yaml(\n@@ -169,6 +184,7 @@ k8s_yaml([\n   'k8s/test/grafana.yaml',\n   'k8s/test/jaeger-service.yaml',\n   'k8s/test/jaeger.yaml',\n+  'k8s/test/load-service.yaml',\n   'k8s/test/minio.yaml',\n   'k8s/test/prometheus.yaml',\n   'k8s/test/test-memberlist-cr.yaml',\n@@ -226,6 +242,7 @@ k8s_resource('sysdb', resource_deps=['sysdb-migration-latest'], labels=[\"chroma\"\n k8s_resource('rust-frontend-service', resource_deps=['sysdb', 'logservice', 'rust-log-service'], labels=[\"chroma\"], port_forwards='3000:8000')\n k8s_resource('query-service', resource_deps=['sysdb'], labels=[\"chroma\"], port_forwards='50053:50051')\n k8s_resource('compaction-service', resource_deps=['sysdb'], labels=[\"chroma\"])\n+k8s_resource('load-service', resource_deps=['k8s_setup'], labels=[\"infrastructure\"], port_forwards='3001:3001')\n k8s_resource('jaeger', resource_deps=['k8s_setup'], labels=[\"observability\"])\n k8s_resource('grafana', resource_deps=['k8s_setup'], labels=[\"observability\"])\n k8s_resource('prometheus', resource_deps=['k8s_setup'], labels=[\"observability\"])\n---\nk8s/test/load-service.yaml\n@@ -0,0 +1,81 @@\n+---\n+\n+apiVersion: v1\n+kind: Namespace\n+metadata:\n+  name: chroma-load\n+\n+---\n+\n+apiVersion: apps/v1\n+kind: Deployment\n+metadata:\n+  name: load-service\n+  namespace: chroma-load\n+spec:\n+  replicas: 1\n+  selector:\n+    matchLabels:\n+      app: load-service\n+  template:\n+    metadata:\n+      namespace: chroma-load\n+      labels:\n+        app: load-service\n+    spec:\n+      containers:\n+        - name: load-service\n+          image: load-service\n+          imagePullPolicy: IfNotPresent\n+          ports:\n+            - containerPort: 3001\n+              name: http\n+          env:\n+            - name: CONFIG_PATH\n+              value: /config/config.yaml\n+            - name: RUST_LOG\n+              value: \"info\"\n+          volumeMounts:\n+            - name: load-service-config\n+              mountPath: /config/\n+            - name: load-service-persistent-state\n+              mountPath: /state/\n+      volumes:\n+        - name: load-service-config\n+          configMap:\n+            name: load-service-config\n+        - name: load-service-persistent-state\n+          hostPath:\n+            path: /tmp/chroma/load-service\n+            type: DirectoryOrCreate\n+\n+---\n+\n+apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: load-service-config\n+  namespace: chroma-load\n+data:\n+  config.yaml: |\n+    load_service:\n+      service_name: \"chroma-load\"\n+      otel_endpoint: \"http://otel-collector.chroma:4317\"\n+      port: 3001\n+      persistent_state_path: \"/state/load-service.json\"\n+\n+---\n+\n+apiVersion: v1\n+kind: Service\n+metadata:\n+  name: load-service\n+  namespace: chroma-load\n+spec:\n+  ports:\n+    - name: http\n+      port: 3001\n+      targetPort: 3001\n+  selector:\n+    app: load-service\n+  type: ClusterIP\n---\nrust/load/src/opentelemetry_config.rs\n@@ -57,7 +57,7 @@ pub(crate) fn init_otel_tracing(service_name: &String, otel_endpoint: &String) {\n     // Layer for adding our configured tracer.\n     // Export everything at this layer. The backend i.e. honeycomb or jaeger will filter at its end.\n     let exporter_layer = tracing_opentelemetry::OpenTelemetryLayer::new(tracer)\n-        .with_filter(tracing_subscriber::filter::LevelFilter::ERROR);\n+        .with_filter(tracing_subscriber::filter::LevelFilter::INFO);\n     // Layer for printing spans to stdout. Only print INFO logs by default.\n     let stdout_layer =\n         BunyanFormattingLayer::new(service_name.clone().to_string(), std::io::stdout)\n---\n\n\n---\n\nChoice B:\nrust/cli/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"chroma-cli\"\n-version = \"1.1.1\"\n+version = \"1.1.2\"\n edition = \"2021\"\n \n [dependencies]\n---\nrust/cli/install/install.ps1\n@@ -13,7 +13,7 @@ if ($isAdmin) {\n $expectedInstallPath = Join-Path $expectedInstallDir \"chroma.exe\"\n \n $repo    = \"chroma-core/chroma\"\n-$release = \"cli-1.1.1\"\n+$release = \"cli-1.1.2\"\n $asset   = \"chroma-windows.exe\"\n \n $downloadUrl = \"https://github.com/$repo/releases/download/$release/$asset\"\n---\nrust/cli/install/install.sh\n@@ -7,7 +7,7 @@ set -e\n #   curl -sSL https://raw.githubusercontent.com/chroma-core/chroma/main/rust/cli/install/install.sh | bash\n # ----------------------------------------------\n REPO=\"chroma-core/chroma\"\n-RELEASE=\"cli-1.1.1\"\n+RELEASE=\"cli-1.1.2\"\n \n OS=$(uname -s)\n ARCH=$(uname -m)\n---\n\n\n---\n\nChoice C:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -835,7 +841,10 @@ impl DataSet for ReferencingDataSet {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice D:\ngo/pkg/sysdb/metastore/db/dao/collection.go\n@@ -30,7 +30,7 @@ func (s *collectionDb) DeleteAll() error {\n func (s *collectionDb) GetCollectionWithoutMetadata(collectionID *string, databaseName *string, softDeletedFlag *bool) (*dbmodel.Collection, error) {\n \tvar collections []*dbmodel.Collection\n \tquery := s.db.Table(\"collections\").\n-\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, collections.root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n+\t\tSelect(\"collections.id, collections.name, collections.database_id, collections.is_deleted, collections.tenant, collections.version, collections.version_file_name, NULLIF(collections.root_collection_id, '') AS root_collection_id, NULLIF(collections.lineage_file_name, '') AS lineage_file_name\").\n \t\tJoins(\"INNER JOIN databases ON collections.database_id = databases.id\").\n \t\tWhere(\"collections.id = ?\", collectionID)\n \n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - ...\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nCargo.lock\n@@ -3340,6 +3340,7 @@ dependencies = [\n  \"tokio\",\n  \"tokio-test\",\n  \"tonic\",\n+ \"tonic-health\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-test\",\n---\nidl/chromadb/proto/garbage_collector.proto\n@@ -0,0 +1,6 @@\n+syntax = \"proto3\";\n+\n+package chroma;\n+\n+// This is a placeholder service. The garbage collector currently only exposes a health service.\n+service GarbageCollector {}\n---\nk8s/distributed-chroma/Chart.yaml\n@@ -16,7 +16,7 @@ apiVersion: v2\n name: distributed-chroma\n description: A helm chart for distributed Chroma\n type: application\n-version: 0.1.43\n+version: 0.1.44\n appVersion: \"0.4.24\"\n keywords:\n   - chroma\n---\nk8s/distributed-chroma/templates/garbage-collector.yaml\n@@ -40,6 +40,9 @@ spec:\n       - name: garbage-collector\n         image: \"{{ .Values.garbageCollector.image.repository }}:{{ .Values.garbageCollector.image.tag }}\"\n         imagePullPolicy: IfNotPresent\n+        readinessProbe:\n+          grpc:\n+            port: 50055\n         {{ if .Values.garbageCollector.resources }}\n         resources:\n           limits:\n---\nrust/garbage_collector/Cargo.toml\n@@ -27,6 +27,7 @@ tokio = { workspace = true }\n uuid = { workspace = true }\n futures = { workspace = true }\n tonic = { workspace = true }\n+tonic-health = { workspace = true }\n tempfile = { workspace = true }\n tracing = { workspace = true }\n thiserror = { workspace = true }\n---\nrust/garbage_collector/src/config.rs\n@@ -38,6 +38,8 @@ pub(super) struct GarbageCollectorConfig {\n     pub(super) assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig,\n     pub(super) memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig,\n     pub my_member_id: String,\n+    #[serde(default = \"GarbageCollectorConfig::default_port\")]\n+    pub port: u16,\n }\n \n impl GarbageCollectorConfig {\n@@ -61,6 +63,10 @@ impl GarbageCollectorConfig {\n             Err(e) => panic!(\"Error loading config: {}\", e),\n         }\n     }\n+\n+    fn default_port() -> u16 {\n+        50055\n+    }\n }\n \n #[cfg(test)]\n---\nrust/garbage_collector/src/garbage_collector_component.rs\n@@ -633,6 +633,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n@@ -753,6 +754,7 @@ mod tests {\n             assignment_policy: chroma_config::assignment::config::AssignmentPolicyConfig::default(),\n             my_member_id: \"test-gc\".to_string(),\n             memberlist_provider: chroma_memberlist::config::MemberlistProviderConfig::default(),\n+            port: 50055,\n         };\n         let registry = Registry::new();\n \n---\nrust/garbage_collector/src/lib.rs\n@@ -6,9 +6,11 @@ use chroma_tracing::{\n     init_global_filter_layer, init_otel_layer, init_panic_tracing_hook, init_stdout_layer,\n     init_tracing,\n };\n+use chroma_types::chroma_proto::garbage_collector_server::GarbageCollectorServer;\n use config::GarbageCollectorConfig;\n use garbage_collector_component::GarbageCollector;\n use tokio::signal::unix::{signal, SignalKind};\n+use tonic::transport::Server;\n use tracing::{debug, error, info};\n \n mod config;\n@@ -24,7 +26,20 @@ pub mod types;\n \n const CONFIG_PATH_ENV_VAR: &str = \"CONFIG_PATH\";\n \n+// This is a placeholder service so that we can expose a health service\n+struct GarbageCollectorService {}\n+\n+impl chroma_types::chroma_proto::garbage_collector_server::GarbageCollector\n+    for GarbageCollectorService\n+{\n+}\n+\n pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::error::Error>> {\n+    let (mut health_reporter, health_service) = tonic_health::server::health_reporter();\n+    health_reporter\n+        .set_not_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     debug!(\"Loading configuration from environment\");\n     // Parse configuration. Configuration includes sysdb connection details, and\n     // gc run details amongst others.\n@@ -49,6 +64,27 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n \n     info!(\"Loaded configuration successfully: {:#?}\", config);\n \n+    let addr = format!(\"[::]:{}\", config.port)\n+        .parse()\n+        .expect(\"Invalid address format\");\n+    let server_join_handle = tokio::spawn(async move {\n+        let server = Server::builder().add_service(health_service);\n+        server\n+            .serve_with_shutdown(addr, async {\n+                match signal(SignalKind::terminate()) {\n+                    Ok(mut sigterm) => {\n+                        sigterm.recv().await;\n+                        tracing::info!(\"Received SIGTERM, shutting down gRPC server\");\n+                    }\n+                    Err(err) => {\n+                        tracing::error!(\"Failed to create SIGTERM handler: {err}\")\n+                    }\n+                }\n+            })\n+            .await\n+            .expect(\"Failed to start gRPC server\");\n+    });\n+\n     let registry = chroma_config::registry::Registry::new();\n     let system = System::new();\n \n@@ -79,6 +115,10 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n     memberlist.subscribe(garbage_collector_handle.receiver());\n     let mut memberlist_handle = system.start_component(memberlist);\n \n+    health_reporter\n+        .set_serving::<GarbageCollectorServer<GarbageCollectorService>>()\n+        .await;\n+\n     // Keep the service running and handle shutdown signals\n     let mut sigterm = signal(SignalKind::terminate())?;\n     let mut sigint = signal(SignalKind::interrupt())?;\n@@ -112,6 +152,7 @@ pub async fn garbage_collector_service_entrypoint() -> Result<(), Box<dyn std::e\n         .expect(\"Dispatcher should be stoppable\");\n     system.stop().await;\n     system.join().await;\n+    let _ = server_join_handle.await;\n \n     info!(\"Shutting down garbage collector service\");\n     Ok(())\n---\nrust/types/build.rs\n@@ -6,6 +6,7 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n         \"idl/chromadb/proto/coordinator.proto\",\n         \"idl/chromadb/proto/logservice.proto\",\n         \"idl/chromadb/proto/query_executor.proto\",\n+        \"idl/chromadb/proto/garbage_collector.proto\",\n     ];\n \n     // Can't use #[cfg(test)] here because a build for tests is technically a regular debug build, meaning that #[cfg(test)] is useless in build.rs.\n---\nrust/types/src/lib.rs\n@@ -47,6 +47,7 @@ pub use tenant::*;\n pub use types::*;\n pub use where_parsing::*;\n \n+#[allow(clippy::all)]\n pub mod chroma_proto {\n     tonic::include_proto!(\"chroma\");\n }\n---\n\n\n---\n\nChoice B:\nchromadb/test/distributed/test_log_failover.py\n@@ -19,6 +19,9 @@\n     skip_if_not_cluster,\n )\n from chromadb.test.property import invariants\n+from chromadb.test.utils.wait_for_version_increase import wait_for_version_increase\n+\n+RECORDS = 100\n \n @skip_if_not_cluster()\n def test_log_failover(\n@@ -39,32 +42,106 @@ def test_log_failover(\n     channel = grpc.insecure_channel('localhost:50052')\n     log_service_stub = LogServiceStub(channel)\n \n-    # Add 100 records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n+    ids = []\n+    embeddings = []\n+    for i in range(RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    request = SealLogRequest(collection_id=str(collection.id))\n+    response = log_service_stub.SealLog(request, timeout=60)\n+\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n+    # and 1\n+    for i in range(RECORDS, RECORDS + RECORDS):\n+        ids.append(str(i))\n+        embeddings.append(np.random.rand(1, 3)[0])\n+        collection.add(\n+            ids=[str(i)],\n+            embeddings=[embeddings[-1]],\n+        )\n+\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n+        result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n+        if len(result[\"embeddings\"]) == 0:\n+            print(\"missing result\", i)\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n+\n+@skip_if_not_cluster()\n+def test_log_failover_with_compaction(\n+    client: ClientAPI,\n+) -> None:\n+    seed = time.time()\n+    random.seed(seed)\n+    print(\"Generating data with seed \", seed)\n+    reset(client)\n+    collection = client.create_collection(\n+        name=\"test\",\n+        metadata={\"hnsw:construction_ef\": 128, \"hnsw:search_ef\": 128, \"hnsw:M\": 128},\n+    )\n+\n+    time.sleep(1)\n+\n+    print('failing over for', collection.id)\n+    channel = grpc.insecure_channel('localhost:50052')\n+    log_service_stub = LogServiceStub(channel)\n+\n+    # Add RECORDS records, where each embedding has 3 dimensions randomly generated between 0 and 1\n     ids = []\n     embeddings = []\n-    for i in range(100):\n+    for i in range(RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n+        if i == RECORDS / 2:\n+            # NOTE(rescrv):  This compaction tests a very particular race when migrating logs.\n+            # Imagine this sequence:\n+            # 1. Write 51 records to the go log.\n+            # 2. Compact all 51 records.\n+            # 3. Write 49 more records to the go log.\n+            # 4. Seal the go log.\n+            # 5. Log migration moves the remaining 49 records to the rust service.\n+            # 6. Cached frontend tries to read from a timestamp that includes all 100 records, using\n+            #    the initial compaction, but from a log that only has 49 records.\n+            # The fix is to make sure the log returns not found when a prefix of the log is\n+            # compacted.  This forces a fallback to repopulate the cache of the sysdb.\n+            wait_for_version_increase(client, collection.name, 0)\n \n     request = SealLogRequest(collection_id=str(collection.id))\n     response = log_service_stub.SealLog(request, timeout=60)\n \n-    # Add another 100 records, where each embedding has 3 dimensions randomly generated between 0\n+    # Add another RECORDS records, where each embedding has 3 dimensions randomly generated between 0\n     # and 1\n-    for i in range(100, 200):\n+    for i in range(RECORDS, RECORDS + RECORDS):\n         ids.append(str(i))\n         embeddings.append(np.random.rand(1, 3)[0])\n         collection.add(\n             ids=[str(i)],\n             embeddings=[embeddings[-1]],\n         )\n \n-    for i in range(200):\n+    results = []\n+    for i in range(RECORDS + RECORDS):\n         result = collection.get(ids=[str(i)], include=[\"embeddings\"])\n         if len(result[\"embeddings\"]) == 0:\n             print(\"missing result\", i)\n-        assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        results.append(result)\n+    for (i, result) in enumerate(results):\n+        if len(result[\"embeddings\"]):\n+            assert all([math.fabs(x - y) < 0.001 for (x, y) in zip(result[\"embeddings\"][0], embeddings[i])])\n+        else:\n+            assert False, \"missing a result\"\n---\ngo/pkg/sysdb/coordinator/table_catalog.go\n@@ -1545,14 +1545,15 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \tif tc.versionFileEnabled {\n \t\treturn tc.FlushCollectionCompactionForVersionedCollection(ctx, flushCollectionCompaction)\n \t}\n+\tcollectionID := types.FromUniqueID(flushCollectionCompaction.ID)\n \n \tflushCollectionInfo := &model.FlushCollectionInfo{\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n \terr := tc.txImpl.Transaction(ctx, func(txCtx context.Context) error {\n \t\t// Check if collection exists.\n-\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(types.FromUniqueID(flushCollectionCompaction.ID), nil, nil)\n+\t\tcollection, err := tc.metaDomain.CollectionDb(txCtx).GetCollectionWithoutMetadata(collectionID, nil, nil)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1589,6 +1590,7 @@ func (tc *Catalog) FlushCollectionCompaction(ctx context.Context, flushCollectio\n \t\t// return nil will commit the transaction\n \t\treturn nil\n \t})\n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", *collectionID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1641,6 +1643,8 @@ func (tc *Catalog) FlushCollectionCompactionForVersionedCollection(ctx context.C\n \t\tID: flushCollectionCompaction.ID.String(),\n \t}\n \n+\tlog.Info(\"FlushCollectionCompaction\", zap.String(\"collection_id\", flushCollectionInfo.ID), zap.Int64(\"log_position\", flushCollectionCompaction.LogPosition))\n+\n \t// Do the operation in a loop until the CollectionEntry is updated,\n \t// \t\tOR FAIL the operation if the version is stale\n \t//      OR other DB error.\n---\nrust/log-service/src/lib.rs\n@@ -1080,6 +1080,9 @@ impl LogService for LogServer {\n                     });\n                 }\n             }\n+            if !records.is_empty() && records[0].log_offset != pull_logs.start_from_offset {\n+                return Err(Status::not_found(\"Some entries have been purged\"));\n+            }\n             tracing::info!(\"pulled {} records\", records.len());\n             Ok(Response::new(PullLogsResponse { records }))\n         }\n---\n\n\n---\n\nChoice C:\nrust/wal3/src/manifest.rs\n@@ -599,7 +599,10 @@ impl Manifest {\n         let path = manifest_path(prefix);\n         loop {\n             match storage\n-                .get_with_e_tag(&path, GetOptions::new(StorageRequestPriority::P0))\n+                .get_with_e_tag(\n+                    &path,\n+                    GetOptions::new(StorageRequestPriority::P0).with_strong_consistency(),\n+                )\n                 .await\n                 .map_err(Arc::new)\n             {\n---\n\n\n---\n\nChoice D:\nrust/segment/src/sqlite_metadata.rs\n@@ -644,12 +644,12 @@ impl SqliteMetadataReader {\n \n         if let Some(whr) = &where_clause {\n             filter_limit_query\n-                .left_join(\n+                .inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n                 )\n-                .left_join(\n+                .inner_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n@@ -683,7 +683,7 @@ impl SqliteMetadataReader {\n \n         if document || metadata {\n             projection_query\n-                .left_join(\n+                .inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((alias.clone(), Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - N/A\n- New functionality\n  - Track collection fork in meter event\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\ngo/cmd/logservice/main.go\n@@ -2,8 +2,8 @@ package main\n \n import (\n \t\"context\"\n+\t\"net\"\n \n-\t\"github.com/chroma-core/chroma/go/pkg/grpcutils\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/configuration\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/leader\"\n \t\"github.com/chroma-core/chroma/go/pkg/log/metrics\"\n@@ -15,6 +15,7 @@ import (\n \t\"github.com/chroma-core/chroma/go/pkg/utils\"\n \tlibs \"github.com/chroma-core/chroma/go/shared/libs\"\n \t\"github.com/chroma-core/chroma/go/shared/otel\"\n+\tsharedOtel \"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"github.com/pingcap/log\"\n \t\"github.com/rs/zerolog\"\n \t\"go.uber.org/automaxprocs/maxprocs\"\n@@ -49,21 +50,22 @@ func main() {\n \tsysDb := sysdb.NewSysDB(config.SYSDB_CONN)\n \tlr := repository.NewLogRepository(conn, sysDb)\n \tserver := server.NewLogServer(lr)\n-\n-\t_, err = grpcutils.Default.StartGrpcServer(\"log-service\", &grpcutils.GrpcConfig{\n-\t\tBindAddress: \":\" + config.PORT,\n-\t}, func(registrar grpc.ServiceRegistrar) {\n-\t\thealthcheck := health.NewServer()\n-\t\thealthgrpc.RegisterHealthServer(registrar, healthcheck)\n-\t\tlogservicepb.RegisterLogServiceServer(registrar, server)\n-\t})\n+\tvar listener net.Listener\n+\tlistener, err = net.Listen(\"tcp\", \":\"+config.PORT)\n \tif err != nil {\n-\t\tlog.Fatal(\"failed to create grpc server\", zap.Error(err))\n+\t\tlog.Fatal(\"failed to listen\", zap.Error(err))\n \t}\n+\ts := grpc.NewServer(grpc.UnaryInterceptor(sharedOtel.ServerGrpcInterceptor))\n+\thealthcheck := health.NewServer()\n+\thealthgrpc.RegisterHealthServer(s, healthcheck)\n \n-\tlog.Info(\"log service started\")\n+\tlogservicepb.RegisterLogServiceServer(s, server)\n+\tlog.Info(\"log service started\", zap.String(\"address\", listener.Addr().String()))\n \tgo leader.AcquireLeaderLock(ctx, func(ctx context.Context) {\n \t\tgo purging.PerformPurgingLoop(ctx, lr)\n \t\tgo metrics.PerformMetricsLoop(ctx, lr)\n \t})\n+\tif err := s.Serve(listener); err != nil {\n+\t\tlog.Fatal(\"failed to serve\", zap.Error(err))\n+\t}\n }\n---\ngo/pkg/grpcutils/service.go\n@@ -4,12 +4,11 @@ import (\n \t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n+\t\"github.com/chroma-core/chroma/go/shared/otel\"\n \t\"io\"\n \t\"net\"\n \t\"os\"\n \n-\t\"github.com/chroma-core/chroma/go/shared/otel\"\n-\n \t\"github.com/pingcap/log\"\n \t\"go.uber.org/zap\"\n \t\"google.golang.org/grpc\"\n@@ -83,7 +82,7 @@ func newDefaultGrpcProvider(name string, grpcConfig *GrpcConfig, registerFunc fu\n \tOPTL_TRACING_ENDPOINT := os.Getenv(\"OPTL_TRACING_ENDPOINT\")\n \tif OPTL_TRACING_ENDPOINT != \"\" {\n \t\totel.InitTracing(context.Background(), &otel.TracingConfig{\n-\t\t\tService:  name,\n+\t\t\tService:  \"sysdb-service\",\n \t\t\tEndpoint: OPTL_TRACING_ENDPOINT,\n \t\t})\n \t}\n---\ngo/pkg/sysdb/grpc/server.go\n@@ -158,7 +158,7 @@ func NewWithGrpcProvider(config Config, provider grpcutils.GrpcProvider) (*Serve\n \t\ts.softDeleteCleaner.Start()\n \n \t\tlog.Info(\"Starting GRPC server\")\n-\t\ts.grpcServer, err = provider.StartGrpcServer(\"sysdb-service\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n+\t\ts.grpcServer, err = provider.StartGrpcServer(\"coordinator\", config.GrpcConfig, func(registrar grpc.ServiceRegistrar) {\n \t\t\tcoordinatorpb.RegisterSysDBServer(registrar, s)\n \t\t\thealthgrpc.RegisterHealthServer(registrar, s.healthServer)\n \t\t})\n---\n\n\n---\n\nChoice B:\nrust/segment/src/sqlite_metadata.rs\n@@ -381,10 +381,6 @@ trait IntoSqliteExpr {\n     /// We need to use `Min` and `Max` as a workaround\n     /// In SQLite, boolean can be implicitly treated as binary integer\n     fn eval(&self) -> SimpleExpr;\n-\n-    fn one() -> SimpleExpr {\n-        Expr::value(1)\n-    }\n }\n \n impl IntoSqliteExpr for Where {\n@@ -460,16 +456,21 @@ impl IntoSqliteExpr for Where {\n \n impl IntoSqliteExpr for CompositeExpression {\n     fn eval(&self) -> SimpleExpr {\n-        let mut expr = Self::one();\n-        for child in &self.children {\n-            expr = expr.mul(match self.operator {\n-                BooleanOperator::And => child.eval(),\n-                BooleanOperator::Or => Self::one().sub(child.eval()),\n-            })\n-        }\n         match self.operator {\n-            BooleanOperator::And => expr,\n-            BooleanOperator::Or => Self::one().sub(expr),\n+            BooleanOperator::And => {\n+                let mut expr = SimpleExpr::Value(sea_query::Value::Bool(Some(true)));\n+                for child in &self.children {\n+                    expr = Expr::expr(expr).and(child.eval());\n+                }\n+                expr\n+            }\n+            BooleanOperator::Or => {\n+                let mut expr = SimpleExpr::Value(sea_query::Value::Bool(Some(false)));\n+                for child in &self.children {\n+                    expr = Expr::expr(expr).or(child.eval());\n+                }\n+                expr\n+            }\n         }\n     }\n }\n@@ -506,24 +507,36 @@ impl IntoSqliteExpr for MetadataExpression {\n                     MetadataValue::Str(s) => (EmbeddingMetadata::StringValue, Expr::val(s)),\n                 };\n                 let scol = Expr::col((EmbeddingMetadata::Table, col));\n+                let mut subq = Query::select()\n+                    .column(EmbeddingMetadata::Id)\n+                    .from(EmbeddingMetadata::Table)\n+                    .and_where(key_cond.clone())\n+                    .to_owned();\n+\n                 match op {\n                     PrimitiveOperator::Equal => {\n-                        Expr::expr(key_cond.and(scol.eq(sval).is(true))).max()\n+                        subq.and_where(scol.eq(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::NotEqual => {\n-                        Expr::expr(key_cond.and(scol.eq(sval).is(true)).not()).min()\n+                        subq.and_where(scol.eq(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq)\n                     }\n                     PrimitiveOperator::GreaterThan => {\n-                        Expr::expr(key_cond.and(scol.gt(sval).is(true))).max()\n+                        subq.and_where(scol.gt(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::GreaterThanOrEqual => {\n-                        Expr::expr(key_cond.and(scol.gte(sval).is(true))).max()\n+                        subq.and_where(scol.gte(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::LessThan => {\n-                        Expr::expr(key_cond.and(scol.lt(sval).is(true))).max()\n+                        subq.and_where(scol.lt(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                     PrimitiveOperator::LessThanOrEqual => {\n-                        Expr::expr(key_cond.and(scol.lte(sval).is(true))).max()\n+                        subq.and_where(scol.lte(sval));\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n                     }\n                 }\n             }\n@@ -547,10 +560,20 @@ impl IntoSqliteExpr for MetadataExpression {\n                     ),\n                 };\n                 let scol = Expr::col((EmbeddingMetadata::Table, col));\n-                let val_in = key_cond.and(scol.is_in(svals).is(true));\n+                let subq = Query::select()\n+                    .column(EmbeddingMetadata::Id)\n+                    .from(EmbeddingMetadata::Table)\n+                    .and_where(key_cond.clone())\n+                    .and_where(scol.is_in(svals))\n+                    .to_owned();\n+\n                 match op {\n-                    SetOperator::In => Expr::expr(val_in).max(),\n-                    SetOperator::NotIn => Expr::expr(val_in.not()).min(),\n+                    SetOperator::In => {\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).in_subquery(subq)\n+                    }\n+                    SetOperator::NotIn => {\n+                        Expr::col((Embeddings::Table, Embeddings::Id)).not_in_subquery(subq)\n+                    }\n                 }\n             }\n         }\n@@ -658,15 +681,8 @@ impl SqliteMetadataReader {\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n                 )\n-                .add_group_by([\n-                    Expr::col((Embeddings::Table, Embeddings::Id)).into(),\n-                    Expr::col((\n-                        EmbeddingFulltextSearch::Table,\n-                        EmbeddingFulltextSearch::StringValue,\n-                    ))\n-                    .into(),\n-                ])\n-                .cond_having(whr.eval());\n+                .distinct()\n+                .cond_where(whr.eval());\n         }\n \n         filter_limit_query\n---\n\n\n---\n\nChoice C:\nchromadb/__init__.py\n@@ -53,7 +53,7 @@\n \n __settings = Settings()\n \n-__version__ = \"1.0.9\"\n+__version__ = \"1.0.10\"\n \n \n # Workaround to deal with Colab's old sqlite3 version\n---\ndeployments/aws/chroma.cf.json\n@@ -16,7 +16,7 @@\n     \"ChromaVersion\": {\n       \"Description\": \"Chroma version to install\",\n       \"Type\": \"String\",\n-      \"Default\": \"1.0.8\"\n+      \"Default\": \"1.0.10\"\n     },\n     \"ChromaOtelCollectionEndpoint\": {\n       \"Description\": \"Chroma OTEL endpoint\",\n---\ndeployments/azure/chroma.tfvars.tf\n@@ -4,7 +4,7 @@ machine_type        = \"Standard_B1s\"      # Azure VM size\n ssh_public_key_path = \"~/.ssh/id_rsa.pub\" # Path to your SSH public key\n \n instance_name                   = \"chroma-instance\"\n-chroma_version                  = \"1.0.8\"\n+chroma_version                  = \"1.0.10\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"{}\"\n---\ndeployments/azure/main.tf\n@@ -17,7 +17,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.8\"\n+  default     = \"1.0.10\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\ndeployments/gcp/chroma.tfvars\n@@ -2,7 +2,7 @@ project_id                      = \"your-gcp-project-id\"\n region                          = \"your-region\" # e.g., \"us-central1\"\n zone                            = \"your-zone\"\n machine_type                    = \"\"\n-chroma_version                  = \"1.0.8\"\n+chroma_version                  = \"1.0.10\"\n chroma_otel_collection_endpoint = \"\"\n chroma_otel_service_name        = \"\"\n chroma_otel_collection_headers  = \"\"\n---\ndeployments/gcp/main.tf\n@@ -23,7 +23,7 @@ variable \"machine_type\" {\n \n variable \"chroma_version\" {\n   description = \"Chroma version to install\"\n-  default     = \"1.0.8\"\n+  default     = \"1.0.10\"\n }\n \n variable \"chroma_server_auth_credentials\" {\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/impls/service_based_frontend.rs\n@@ -549,6 +549,8 @@ impl ServiceBasedFrontend {\n     pub async fn retryable_fork(\n         &mut self,\n         ForkCollectionRequest {\n+            tenant_id,\n+            database_name,\n             source_collection_id,\n             target_collection_name,\n             ..\n@@ -570,12 +572,25 @@ impl ServiceBasedFrontend {\n             )\n             .await?;\n         let collection = collection_and_segments.collection.clone();\n+        let latest_collection_logical_size_bytes = collection_and_segments\n+            .collection\n+            .size_bytes_post_compaction;\n \n         // Update the cache.\n         self.collections_with_segments_provider\n             .set_collection_with_segments(collection_and_segments)\n             .await;\n \n+        // TODO: Submit event after the response is sent\n+        MeterEvent::CollectionFork {\n+            tenant: tenant_id,\n+            database: database_name,\n+            collection_id: source_collection_id.0,\n+            latest_collection_logical_size_bytes,\n+        }\n+        .submit()\n+        .await;\n+\n         Ok(collection)\n     }\n \n---\nrust/tracing/src/meter_event.rs\n@@ -26,6 +26,12 @@ pub enum WriteAction {\n #[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]\n #[serde(rename_all = \"snake_case\", tag = \"event_name\")]\n pub enum MeterEvent {\n+    CollectionFork {\n+        tenant: String,\n+        database: String,\n+        collection_id: Uuid,\n+        latest_collection_logical_size_bytes: u64,\n+    },\n     CollectionRead {\n         tenant: String,\n         database: String,\n---\n\n\n---\n\n"}], "ideal": "D"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - ...\n- New functionality\n  - ...\n\n## Test plan\n\n_How are these changes tested?_\n\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nrust/load/src/data_sets.rs\n@@ -760,7 +760,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = gq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let collection = client.get_collection(&self.operates_on).await?;\n         // TODO(rescrv):  from the reference collection, pull the documents and embeddings and\n@@ -787,7 +790,10 @@ impl DataSet for ReferencingDataSet {\n         let mut keys = vec![];\n         let num_keys = qq.limit.sample(guac);\n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(qq.skew).select(guac, self));\n+            let key = KeySelector::Random(qq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -835,7 +841,10 @@ impl DataSet for ReferencingDataSet {\n         let collection = client.get_collection(&self.operates_on).await?;\n         let mut keys = vec![];\n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.references.get_by_key(client, &keys).await? {\n@@ -1019,7 +1028,10 @@ impl DataSet for VerifyingDataSet {\n         }\n \n         for _ in 0..num_keys {\n-            keys.push(KeySelector::Random(gq.skew).select(guac, self));\n+            let key = KeySelector::Random(gq.skew).select(guac, self);\n+            if !keys.contains(&key) {\n+                keys.push(key);\n+            }\n         }\n \n         let reference_collection = client\n@@ -1208,7 +1220,10 @@ impl DataSet for VerifyingDataSet {\n         );\n \n         for offset in 0..uq.batch_size {\n-            keys.push(uq.key.select_from_reference(self, offset));\n+            let key = uq.key.select_from_reference(self, offset);\n+            if !keys.contains(&key) {\n+                keys.push(key)\n+            }\n         }\n         let keys = keys.iter().map(|k| k.as_str()).collect::<Vec<_>>();\n         if let Some(res) = self.reference_data_set.get_by_key(client, &keys).await? {\n---\n\n\n---\n\nChoice B:\ndocs/docs.trychroma.com/markdoc/content/docs/collections/configure.md\n@@ -40,7 +40,7 @@ Here's how to configure the Cohere embedding function:\n import os\n assert os.environ.get(\"CHROMA_COHERE_API_KEY\"), \"CHROMA_COHERE_API_KEY environment variable not set\"\n \n-from chromadb.utils.embedding_functions import CohereEmbeddingFunction\n+from chromadb.utils.embedding_functions.cohere_embedding_function import CohereEmbeddingFunction\n \n # Create the Cohere embedding function (API key is read from environment variable)\n # By default, it reads from 'CHROMA_COHERE_API_KEY'\n@@ -109,7 +109,7 @@ Here is an example showing how to configure both the HNSW index and embedding fu\n import os\n assert os.environ.get(\"COHERE_API_KEY\"), \"COHERE_API_KEY environment variable not set\"\n \n-from chromadb.utils.embedding_functions import CohereEmbeddingFunction\n+from chromadb.utils.embedding_functions.cohere_embedding_function import CohereEmbeddingFunction\n \n # Create the Cohere embedding function\n cohere_ef = CohereEmbeddingFunction(model_name=\"embed-english-light-v2.0\")\n---\n\n\n---\n\nChoice C:\nrust/frontend/src/impls/utils.rs\n@@ -8,6 +8,8 @@ use chroma_types::{\n pub(crate) enum ToRecordsError {\n     #[error(\"Inconsistent number of IDs, embeddings, documents, URIs and metadatas\")]\n     InconsistentLength,\n+    #[error(\"Empty ID, ID must have at least one character\")]\n+    EmptyId,\n }\n \n impl ChromaError for ToRecordsError {\n@@ -47,6 +49,9 @@ pub(crate) fn to_records<\n     let mut records = Vec::with_capacity(len);\n \n     for id in ids {\n+        if id.is_empty() {\n+            return Err(ToRecordsError::EmptyId);\n+        }\n         let embedding = embeddings_iter.next().flatten();\n         let document = documents_iter.next().flatten();\n         let uri = uris_iter.next().flatten();\n@@ -87,3 +92,59 @@ pub(crate) fn to_records<\n \n     Ok((records, total_bytes))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use chroma_types::Operation;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_to_records_empty_id() {\n+        let ids = vec![String::from(\"\")];\n+        let embeddings = vec![Some(vec![1.0, 2.0, 3.0])];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(ids, Some(embeddings), None, None, None, Operation::Add);\n+        assert!(matches!(result, Err(ToRecordsError::EmptyId)));\n+    }\n+\n+    #[test]\n+    fn test_normal_ids() {\n+        let ids = vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\")];\n+        let embeddings = vec![\n+            Some(vec![1.0, 2.0, 3.0]),\n+            Some(vec![4.0, 5.0, 6.0]),\n+            Some(vec![7.0, 8.0, 9.0]),\n+        ];\n+        let documents = vec![\n+            Some(String::from(\"document 1\")),\n+            Some(String::from(\"document 2\")),\n+            Some(String::from(\"document 3\")),\n+        ];\n+        let result = to_records::<\n+            chroma_types::UpdateMetadataValue,\n+            Vec<(String, chroma_types::UpdateMetadataValue)>,\n+        >(\n+            ids,\n+            Some(embeddings),\n+            Some(documents),\n+            None,\n+            None,\n+            Operation::Add,\n+        );\n+        assert!(result.is_ok());\n+        let records = result.unwrap().0;\n+        assert_eq!(records.len(), 3);\n+        assert_eq!(records[0].id, \"1\");\n+        assert_eq!(records[1].id, \"2\");\n+        assert_eq!(records[2].id, \"3\");\n+        assert_eq!(records[0].embedding, Some(vec![1.0, 2.0, 3.0]));\n+        assert_eq!(records[1].embedding, Some(vec![4.0, 5.0, 6.0]));\n+        assert_eq!(records[2].embedding, Some(vec![7.0, 8.0, 9.0]));\n+        assert_eq!(records[0].document, Some(String::from(\"document 1\")));\n+        assert_eq!(records[1].document, Some(String::from(\"document 2\")));\n+        assert_eq!(records[2].document, Some(String::from(\"document 3\")));\n+    }\n+}\n---\n\n\n---\n\nChoice D:\nrust/frontend/src/quota/mod.rs\n@@ -7,6 +7,7 @@ use std::{\n use chroma_error::ChromaError;\n use chroma_types::{CollectionUuid, Metadata, UpdateMetadata, Where};\n use thiserror::Error;\n+use validator::Validate;\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash)]\n pub enum Action {\n@@ -334,12 +335,14 @@ lazy_static::lazy_static! {\n     };\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Validate)]\n pub struct QuotaExceededError {\n     pub usage_type: UsageType,\n     pub action: Action,\n     pub usage: usize,\n     pub limit: usize,\n+    #[validate(length(min = 1))]\n+    pub message: Option<String>,\n }\n \n impl fmt::Display for QuotaExceededError {\n@@ -348,7 +351,11 @@ impl fmt::Display for QuotaExceededError {\n             f,\n             \"'{}' exceeded quota limit for action '{}': current usage of {} exceeds limit of {}\",\n             self.usage_type, self.action, self.usage, self.limit\n-        )\n+        )?;\n+        if let Some(msg) = self.message.as_ref() {\n+            write!(f, \". {}\", msg)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -393,3 +400,63 @@ impl QuotaEnforcer for () {\n         Box::pin(ready(Ok(())))\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{Action, QuotaExceededError, UsageType};\n+    use validator::Validate;\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_none() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: None,\n+        };\n+        assert!(error.validate().is_ok());\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_empty() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: Some(\"\".to_string()),\n+        };\n+        assert!(error.validate().is_err());\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_message_valid() {\n+        let custom_message = \"This is a valid message.\";\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: Some(custom_message.to_string()),\n+        };\n+        assert!(error.validate().is_ok());\n+        let error_string = format!(\"{}\", error);\n+        let expected_error_string = \"'Number of records' exceeded quota limit for action 'Add': current usage of 100 exceeds limit of 50. This is a valid message.\";\n+        assert_eq!(error_string, expected_error_string);\n+    }\n+\n+    #[test]\n+    fn test_quota_exceeded_error_display_no_message() {\n+        let error = QuotaExceededError {\n+            usage_type: UsageType::NumRecords,\n+            action: Action::Add,\n+            usage: 100,\n+            limit: 50,\n+            message: None,\n+        };\n+        assert!(error.validate().is_ok());\n+        let error_string = format!(\"{}\", error);\n+        assert_eq!(error_string, \"'Number of records' exceeded quota limit for action 'Add': current usage of 100 exceeds limit of 50\");\n+    }\n+}\n---\n\n\n---\n\n"}], "ideal": "B"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\nCloses #4378\n\n## Description of changes\n\n_Summarize the changes made by this PR._\n\n- Improvements & Bug fixes\n  - Voyage AI client API seems to have changed and now returns [EmbeddingsObject](https://github.com/voyage-ai/voyageai-python/blob/012d16bd708c797766beb26555e56b10db8d09fd/voyageai/object/embeddings.py#L5-L16)\n  - Added skippable Voyage AI EF basic test\n\n## Test plan\n\n_How are these changes tested?_\n\n- [x] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\n\n## Documentation Changes\n\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\n\n\n---\n\nChoice A:\nchromadb/test/ef/test_voyageai_ef.py\n@@ -0,0 +1,19 @@\n+import os\n+import pytest\n+from chromadb.utils.embedding_functions.voyageai_embedding_function import (\n+    VoyageAIEmbeddingFunction,\n+)\n+\n+voyageai = pytest.importorskip(\"voyageai\", reason=\"voyageai not installed\")\n+\n+\n+def test_with_embedding_dimensions() -> None:\n+    if os.environ.get(\"CHROMA_VOYAGE_API_KEY\") is None:\n+        pytest.skip(\"CHROMA_VOYAGE_API_KEY not set\")\n+    ef = VoyageAIEmbeddingFunction(\n+        api_key=os.environ[\"CHROMA_VOYAGE_API_KEY\"]\n+    )\n+    embeddings = ef([\"hello world\"])\n+    assert embeddings is not None\n+    assert len(embeddings) == 1\n+    assert len(embeddings[0]) == 1536\n---\nchromadb/utils/embedding_functions/voyageai_embedding_function.py\n@@ -55,7 +55,9 @@ def __call__(self, input: Documents) -> Embeddings:\n         embeddings = self._client.embed(texts=input, model=self.model_name)\n \n         # Convert to numpy arrays\n-        return [np.array(embedding, dtype=np.float32) for embedding in embeddings]\n+        return [\n+            np.array(embedding, dtype=np.float32) for embedding in embeddings.embeddings\n+        ]\n \n     @staticmethod\n     def name() -> str:\n---\n\n\n---\n\nChoice B:\nrust/worker/src/execution/operators/filter.rs\n@@ -498,6 +498,11 @@ impl Operator<FilterInput, FilterOutput> for FilterOperator {\n     async fn run(&self, input: &FilterInput) -> Result<FilterOutput, FilterError> {\n         tracing::debug!(\"[{}]: {:?}\", self.get_name(), input);\n \n+        // NOTE: This is temporary traces to capture filter arguments\n+        //       We suspect certain filters break the FTS algorithm\n+        // TODO: Remove this after the bug is found\n+        tracing::debug!(\"[DEBUG FILTER OPERATOR]: {:?}\", self);\n+\n         let record_segment_reader = match RecordSegmentReader::from_segment(\n             &input.record_segment,\n             &input.blockfile_provider,\n---\nrust/worker/src/execution/operators/projection.rs\n@@ -71,6 +71,8 @@ pub enum ProjectionError {\n     RecordSegment(#[from] Box<dyn ChromaError>),\n     #[error(\"Error reading unitialized record segment\")]\n     RecordSegmentUninitialized,\n+    #[error(\"Error reading phantom record: {0}\")]\n+    RecordSegmentPhantomRecord(u32),\n }\n \n impl ChromaError for ProjectionError {\n@@ -80,6 +82,7 @@ impl ChromaError for ProjectionError {\n             ProjectionError::RecordReader(e) => e.code(),\n             ProjectionError::RecordSegment(e) => e.code(),\n             ProjectionError::RecordSegmentUninitialized => ErrorCodes::Internal,\n+            ProjectionError::RecordSegmentPhantomRecord(_) => ErrorCodes::Internal,\n         }\n     }\n }\n@@ -153,7 +156,7 @@ impl Operator<ProjectionInput, ProjectionOutput> for ProjectionOperator {\n                         let record = reader\n                             .get_data_for_offset_id(*offset_id)\n                             .await?\n-                            .ok_or(ProjectionError::RecordSegmentUninitialized)?;\n+                            .ok_or(ProjectionError::RecordSegmentPhantomRecord(*offset_id))?;\n                         ProjectionRecord {\n                             id: record.id.to_string(),\n                             document: record\n---\n\n\n---\n\nChoice C:\nrust/segment/src/sqlite_metadata.rs\n@@ -644,12 +644,12 @@ impl SqliteMetadataReader {\n \n         if let Some(whr) = &where_clause {\n             filter_limit_query\n-                .left_join(\n+                .inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n                 )\n-                .left_join(\n+                .inner_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n@@ -683,7 +683,7 @@ impl SqliteMetadataReader {\n \n         if document || metadata {\n             projection_query\n-                .left_join(\n+                .inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((alias.clone(), Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n---\n\n\n---\n\nChoice D:\nrust/log-service/src/lib.rs\n@@ -376,6 +376,8 @@ impl DirtyMarker {\n         timeout_us: u64,\n         metrics: &Metrics,\n     ) -> Result<Option<Rollup>, wal3::Error> {\n+        let cpu_span = tracing::info_span!(\"cpu computation\");\n+        let cpu_span_guard = cpu_span.enter();\n         // NOTE(rescrv);  This is complicated code because it's a hard problem to do efficiently.\n         // To cut complexity, I've chosen to do it in a way that is not the most efficient but is\n         // readable and maintainable.  The most efficient way would be to do this in a single pass.\n@@ -420,6 +422,7 @@ impl DirtyMarker {\n         if compactable.is_empty() {\n             return Ok(None);\n         }\n+        drop(cpu_span_guard);\n         // Now fetch the compaction cursor for each collection.\n         let retrieve_manifest = Arc::new(retrieve_manifest);\n         let retrieve_cursor = Arc::new(retrieve_cursor);\n@@ -435,8 +438,10 @@ impl DirtyMarker {\n             })\n             .map(\n                 |(collection_id, storage, retrieve_manifest, retrieve_cursor)| async move {\n-                    let cursor = (*retrieve_cursor)(Arc::clone(&storage), collection_id);\n-                    let manifest = (*retrieve_manifest)(Arc::clone(&storage), collection_id);\n+                    let cursor = (*retrieve_cursor)(Arc::clone(&storage), collection_id)\n+                        .instrument(tracing::info_span!(\"fetching cursor\"));\n+                    let manifest = (*retrieve_manifest)(Arc::clone(&storage), collection_id)\n+                        .instrument(tracing::info_span!(\"fetching manifest\"));\n                     let (cursor, manifest) = futures::future::join(cursor, manifest).await;\n                     // NOTE(rescrv):  We silence the error so we log it instead.\n                     let cursor = match cursor {\n@@ -458,7 +463,12 @@ impl DirtyMarker {\n                 },\n             )\n             .collect::<Vec<_>>();\n-        let cursors = futures::future::join_all(futs).await;\n+        let rollup_span = tracing::info_span!(\"fetching cursors and manifests\");\n+        let cursors = futures::future::join_all(futs)\n+            .instrument(rollup_span)\n+            .await;\n+        let reprise_cpu_span = tracing::info_span!(\"cpu computation reprise\");\n+        let _reprise_cpu_span_guard = reprise_cpu_span.enter();\n         let cursors = cursors\n             .into_iter()\n             .flat_map(Result::ok)\n@@ -1361,6 +1371,7 @@ impl LogService for LogServer {\n                 );\n                 cursor_store.load(cursor).await\n             };\n+            let rollup_span = tracing::info_span!(\"DirtyMarker::rollup\");\n             let rollup = DirtyMarker::rollup(\n                 Arc::clone(&self.storage),\n                 load_manifest,\n@@ -1375,6 +1386,7 @@ impl LogService for LogServer {\n                 self.config.timeout_us,\n                 &self.metrics,\n             )\n+            .instrument(rollup_span)\n             .await\n             .map_err(|err| Status::unavailable(err.to_string()))?;\n             let Some(rollup) = rollup else {\n---\n\n\n---\n\n"}], "ideal": "A"}
{"input": [{"role": "system", "content": "The user will ask which of the following 4 choices (A, B, C or D) is the best solution to the following GitHub pull request. Even the correct answer may have some irrelevant code inside of it. Only respond with a single letter A, B, C or D in uppercase. "}, {"role": "user", "content": "Task Description:\n## Description of changes\r\n\r\nhttps://github.com/chroma-core/chroma/issues/4382#issue-3020402184\r\n\r\nthis PR removes hnsw-lib from core dependencies, removes it from the dockerfile, and moves it to dev dependencies in pyproject\r\n## Test plan\r\n\r\n_How are these changes tested?_\r\n\r\n- [ ] Tests pass locally with `pytest` for python, `yarn test` for js, `cargo test` for rust\r\n\r\n## Documentation Changes\r\n\r\n_Are all docstrings for user-facing APIs updated if required? Do we need to make documentation changes in the [docs section](https://github.com/chroma-core/chroma/tree/main/docs/docs.trychroma.com)?_\r\n\n\n---\n\nChoice A:\nrust/segment/src/sqlite_metadata.rs\n@@ -705,28 +705,62 @@ impl SqliteMetadataReader {\n         }\n \n         if let Some(whr) = &where_clause {\n-            filter_limit_query\n-                .left_join(\n+            let (references_metadata, references_document) = whr.analyze_where_references();\n+            if references_metadata {\n+                filter_limit_query.inner_join(\n                     EmbeddingMetadata::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id))\n                         .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n-                )\n-                .left_join(\n+                );\n+            } else if metadata {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            }\n+            if references_document {\n+                filter_limit_query.inner_join(\n                     EmbeddingFulltextSearch::Table,\n                     Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n                         EmbeddingFulltextSearch::Table,\n                         EmbeddingFulltextSearch::Rowid,\n                     )),\n-                )\n-                .distinct()\n-                .cond_where(whr.eval());\n+                );\n+            } else if document {\n+                filter_limit_query.left_join(\n+                    EmbeddingFulltextSearch::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n+                        EmbeddingFulltextSearch::Table,\n+                        EmbeddingFulltextSearch::Rowid,\n+                    )),\n+                );\n+            }\n+            filter_limit_query.distinct().cond_where(whr.eval());\n+        } else {\n+            if metadata {\n+                filter_limit_query.left_join(\n+                    EmbeddingMetadata::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id))\n+                        .equals((EmbeddingMetadata::Table, EmbeddingMetadata::Id)),\n+                );\n+            }\n+\n+            if document {\n+                filter_limit_query.left_join(\n+                    EmbeddingFulltextSearch::Table,\n+                    Expr::col((Embeddings::Table, Embeddings::Id)).equals((\n+                        EmbeddingFulltextSearch::Table,\n+                        EmbeddingFulltextSearch::Rowid,\n+                    )),\n+                );\n+            }\n         }\n \n         filter_limit_query\n             .order_by((Embeddings::Table, Embeddings::Id), sea_query::Order::Asc)\n             .offset(skip as u64)\n             .limit(fetch.unwrap_or(u32::MAX) as u64);\n-\n         let alias = Alias::new(SUBQ_ALIAS);\n         let mut projection_query = Query::select();\n         projection_query\n---\nrust/types/src/metadata.rs\n@@ -560,6 +560,26 @@ impl Where {\n             },\n         }\n     }\n+\n+    pub fn analyze_where_references(&self) -> (bool, bool) {\n+        let mut references_metadata = false;\n+        let mut references_document = false;\n+\n+        match self {\n+            Where::Composite(expr) => {\n+                // For composite expressions, recursively check all children\n+                for child in &expr.children {\n+                    let (child_meta, child_doc) = Self::analyze_where_references(&(child.clone()));\n+                    references_metadata |= child_meta;\n+                    references_document |= child_doc;\n+                }\n+            }\n+            Where::Document(_) => references_document = true,\n+            Where::Metadata(_) => references_metadata = true,\n+        }\n+\n+        (references_metadata, references_document)\n+    }\n }\n \n impl TryFrom<chroma_proto::Where> for Where {\n---\n\n\n---\n\nChoice B:\n.github/workflows/_python-tests.yml\n@@ -155,7 +155,7 @@ jobs:\n           dockerhub-password: ${{ secrets.DOCKERHUB_TOKEN }}\n       - uses: ./.github/actions/tilt\n       - name: Test\n-        run: bin/cluster-test.sh bash -c 'python -m pytest \"${{ matrix.test-globs }}\"' --durations 10\n+        run: bin/cluster-test.sh bash -c 'python -m pytest \"${{ matrix.test-globs }}\" --durations 10'\n         shell: bash\n         env:\n           PROPERTY_TESTING_PRESET: ${{ inputs.property_testing_preset }}\n---\n\n\n---\n\nChoice C:\nDockerfile\n@@ -69,4 +69,3 @@ EXPOSE 8000\n \n ENTRYPOINT [\"/docker_entrypoint.sh\"]\n CMD [ \"--workers ${CHROMA_WORKERS} --host ${CHROMA_HOST_ADDR} --port ${CHROMA_HOST_PORT} --proxy-headers --reload --log-config ${CHROMA_LOG_CONFIG} --timeout-keep-alive ${CHROMA_TIMEOUT_KEEP_ALIVE}\"]\n-\n---\nDockerfile.windows\n@@ -1,14 +1,15 @@\n FROM python:3.11.9\n ARG REBUILD_HNSWLIB\n-\n SHELL [\"powershell\", \"-Command\", \"$ErrorActionPreference = 'Stop'; $ProgressPreference = 'SilentlyContinue';\"]\n RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; `Invoke-WebRequest \"https://aka.ms/vs/17/release/vc_redist.x64.exe\" -OutFile \"vc_redist.x64.exe\"; `Start-Process -filepath C:\\vc_redist.x64.exe -ArgumentList \"/install\", \"/passive\", \"/norestart\" -Passthru | Wait-Process; `Remove-Item -Force vc_redist.x64.exe;\n \n WORKDIR C:\\\\chroma\n \n COPY ./requirements.txt requirements.txt\n+COPY ./requirements_dev.txt requirements_dev.txt\n \n RUN pip install --no-cache-dir --upgrade -r requirements.txt\n+RUN pip install --no-cache-dir --upgrade -r requirements_dev.txt\n RUN if ($env:REBUILD_HNSWLIB -eq 'true') { pip install --no-binary :all: --force-reinstall --no-cache-dir chroma-hnswlib }\n \n COPY ./bin/docker_entrypoint.ps1 C:\\\\docker_entrypoint.ps1\n@@ -19,7 +20,6 @@ ENV CHROMA_HOST_PORT 8000\n ENV CHROMA_WORKERS 1\n ENV CHROMA_LOG_CONFIG \"chromadb/log_config.yml\"\n ENV CHROMA_TIMEOUT_KEEP_ALIVE 30\n-\n EXPOSE 8000\n \n ENTRYPOINT [\"powershell\", \"C:\\\\\\\\docker_entrypoint.ps1\"]\n---\nchromadb/test/utils/cross_version.py\n@@ -55,7 +55,10 @@ def install(pkg: str, path: str, dep_overrides: Dict[str, str]) -> int:\n     for dep, operator_version in dep_overrides.items():\n         command.append(f\"{dep}{operator_version}\")\n \n-    command.append(\"--no-binary=chroma-hnswlib\")\n+    # Only add --no-binary=chroma-hnswlib if it's in the dependencies\n+    if \"chroma-hnswlib\" in pkg or any(\"chroma-hnswlib\" in dep for dep in dep_overrides):\n+        command.append(\"--no-binary=chroma-hnswlib\")\n+\n     command.append(f\"--target={path}\")\n \n     print(f\"Installing chromadb version {pkg} to {path}\")\n---\npyproject.toml\n@@ -7,7 +7,10 @@ description = \"Chroma.\"\n readme = \"README.md\"\n requires-python = \">=3.9\"\n classifiers = [\"Programming Language :: Python :: 3\", \"License :: OSI Approved :: Apache Software License\", \"Operating System :: OS Independent\"]\n-dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'chroma-hnswlib==0.7.6', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+dependencies = ['build >= 1.0.3', 'pydantic >= 1.9', 'fastapi==0.115.9', 'uvicorn[standard] >= 0.18.3', 'numpy >= 1.22.5', 'posthog >= 2.4.0', 'typing_extensions >= 4.5.0', 'onnxruntime >= 1.14.1', 'opentelemetry-api>=1.2.0', 'opentelemetry-exporter-otlp-proto-grpc>=1.2.0', 'opentelemetry-instrumentation-fastapi>=0.41b0', 'opentelemetry-sdk>=1.2.0', 'tokenizers >= 0.13.2', 'pypika >= 0.48.9', 'tqdm >= 4.65.0', 'overrides >= 7.3.1', 'importlib-resources', 'graphlib_backport >= 1.0.3; python_version < \"3.9\"', 'grpcio >= 1.58.0', 'bcrypt >= 4.0.1', 'typer >= 0.9.0', 'kubernetes>=28.1.0', 'tenacity>=8.2.3', 'PyYAML>=6.0.0', 'mmh3>=4.0.1', 'orjson>=3.9.12', 'httpx>=0.27.0', 'rich>=10.11.0', 'jsonschema>=4.19.0']\n+\n+[project.optional-dependencies]\n+dev = ['chroma-hnswlib==0.7.6']\n \n [tool.black]\n line-length = 88\n---\nrequirements.txt\n@@ -1,5 +1,4 @@\n bcrypt>=4.0.1\n-chroma-hnswlib==0.7.6\n fastapi==0.115.9\n graphlib_backport==1.0.3; python_version < '3.9'\n grpcio>=1.58.0\n---\nrequirements_dev.txt\n@@ -1,5 +1,6 @@\n black==23.3.0 # match what's in pyproject.toml\n build\n+chroma-hnswlib==0.7.6\n grpcio-tools==1.67.1 # Later version not compatible with protobuf 4.25.5\n httpx\n hypothesis==6.112.2 # TODO: Resolve breaking changes and bump version\n---\n\n\n---\n\nChoice D:\nCargo.lock\n@@ -1618,6 +1618,7 @@ dependencies = [\n  \"opentelemetry-http\",\n  \"opentelemetry-otlp\",\n  \"opentelemetry_sdk\",\n+ \"rand 0.8.5\",\n  \"reqwest 0.12.9\",\n  \"serde\",\n  \"serde_json\",\n---\nrust/load/Cargo.toml\n@@ -8,6 +8,7 @@ async-trait = { workspace = true }\n chrono = { workspace = true }\n clap = { workspace = true }\n figment = { workspace = true }\n+rand = { workspace = true }\n serde = { workspace = true }\n serde_json = { workspace = true }\n tokio = { workspace = true }\n---\nrust/load/src/data_sets.rs\n@@ -986,6 +986,11 @@ impl DataSet for VerifyingDataSet {\n         &self,\n         client: &ChromaClient,\n     ) -> Result<(), Box<dyn std::error::Error + Send>> {\n+        // Reset the cardinality and cardinality heap.\n+        self.cardinality\n+            .store(0, std::sync::atomic::Ordering::Relaxed);\n+        self.cardinality_heap.lock().await.clear();\n+\n         // Attempt to delete the collection. If it doesn't exist, ignore the error.\n         match client.delete_collection(&self.test_data_set).await {\n             Ok(_) => (),\n@@ -1255,13 +1260,50 @@ impl DataSet for VerifyingDataSet {\n             } else {\n                 return Err(Box::new(Error::InvalidRequest(\"No documents\".into())));\n             }\n-            let entries = CollectionEntries {\n-                ids: keys,\n-                metadatas: res.metadatas,\n-                documents: Some(documents),\n-                embeddings: Some(embeddings),\n-            };\n-            collection.upsert(entries, None).await?;\n+\n+            let max_retries = 10;\n+            let base_delay = std::time::Duration::from_millis(10);\n+            let max_delay = std::time::Duration::from_secs(10);\n+            let mut retry_count = 0;\n+            let mut delay = base_delay;\n+\n+            loop {\n+                let entries = CollectionEntries {\n+                    ids: keys.clone(),\n+                    metadatas: res.metadatas.clone(),\n+                    documents: Some(documents.clone()),\n+                    embeddings: Some(embeddings.clone()),\n+                };\n+                let result = collection.upsert(entries, None).await;\n+                if let Err(err) = result {\n+                    if format!(\"{err:?}\").contains(\"429\") {\n+                        if retry_count >= max_retries {\n+                            return Err(Box::new(Error::InvalidRequest(format!(\n+                                \"UPSERT for {} failed after {} retries: RATE LIMITED {err:?}\",\n+                                key_start_index, max_retries\n+                            ))));\n+                        }\n+\n+                        tracing::warn!(\n+                            \"UPSERT for {} failed: RATE LIMITED {err:?}, retry {}/{}, sleeping for {:?}\",\n+                            key_start_index, retry_count + 1, max_retries, delay\n+                        );\n+\n+                        tokio::time::sleep(delay).await;\n+\n+                        // Exponential backoff with max delay\n+                        delay = std::cmp::min(delay * 2, max_delay);\n+                        retry_count += 1;\n+                        continue;\n+                    } else {\n+                        return Err(Box::new(Error::InvalidRequest(format!(\n+                            \"UPSERT failed: {err:?}\"\n+                        ))));\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n             self.record_load(key_start_index, uq.batch_size).await;\n         } else {\n             return Err(Box::new(Error::InvalidRequest(\"No results\".into())));\n---\n\n\n---\n\n"}], "ideal": "C"}
