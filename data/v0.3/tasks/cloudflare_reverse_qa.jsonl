{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".teamcity/install-cloudflare-go.sh\n@@ -3,6 +3,6 @@\n cd /tmp\n git clone -q https://github.com/cloudflare/go\n cd go/src\n-# https://github.com/cloudflare/go/tree/af19da5605ca11f85776ef7af3384a02a315a52b is version go1.22.5-devel-cf\n-git checkout -q af19da5605ca11f85776ef7af3384a02a315a52b\n+# https://github.com/cloudflare/go/tree/37bc41c6ff79507200a315b72834fce6ca427a7e is version go1.22.12-devel-cf\n+git checkout -q 37bc41c6ff79507200a315b72834fce6ca427a7e\n ./make.bash\n---\nMakefile\n@@ -42,7 +42,7 @@ ifeq ($(FIPS), true)\n \tVERSION_FLAGS := $(VERSION_FLAGS) -X \"main.BuildType=FIPS\"\n endif\n \n-LDFLAGS := -ldflags='$(VERSION_FLAGS) $(LINK_FLAGS)'\n+LDFLAGS := -ldflags='$(VERSION_FLAGS) $(LINK_FLAGS) -B gobuildid'\n ifneq ($(GO_BUILD_TAGS),)\n \tGO_BUILD_TAGS := -tags \"$(GO_BUILD_TAGS)\"\n endif\n---\n"}], "ideal": "Title: Add build UUID\n\nBody: Recent macOS versions require user permissions to access the local network. This can only be granted for binaries which have a LC_UUID load command. Go 1.24 adds the UUID by default, but the fix was backported to Go 1.22.9 and 1.23 where it requires passing `-B gobuildid` to the linker.\r\n\r\ncloudflared uses Cloudflare's Go fork which is based on Go 1.22.5 and doesn't have the backport. Because of this, cloudflared can't talk to any machine on the local network (no route to host) when it's runnning as a non-root user.\r\n\r\nThis workaround updates the Go fork to go1.22.12-devel-cf and adds `-B gobuildid` so that the binary now has a UUID:\r\n\r\n```\r\n\u276f dwarfdump --uuid /opt/homebrew/bin/cloudflared\r\nUUID: F2088E17-03A1-34B1-F12C-0DF01F00BA32 (arm64) /opt/homebrew/bin/cloudflared\r\n```\r\n\r\nFixes #1460"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/subcommands.go\n@@ -761,7 +761,7 @@ func runCommand(c *cli.Context) error {\n \t\tif tokenFile := c.String(TunnelTokenFileFlag); tokenFile != \"\" {\n \t\t\tdata, err := os.ReadFile(tokenFile)\n \t\t\tif err != nil {\n-\t\t\t\treturn cliutil.UsageError(\"Failed to read token file: \" + err.Error())\n+\t\t\t\treturn cliutil.UsageError(\"Failed to read token file: %s\", err.Error())\n \t\t\t}\n \t\t\ttokenStr = strings.TrimSpace(string(data))\n \t\t}\n---\ngo.mod\n@@ -1,6 +1,6 @@\n module github.com/cloudflare/cloudflared\n \n-go 1.22\n+go 1.24.2\n \n require (\n \tgithub.com/coredns/coredns v1.11.3\n---\ningress/ingress.go\n@@ -113,7 +113,7 @@ func ParseIngressFromConfigAndCLI(conf *config.Configuration, c *cli.Context, lo\n \t\t// If no token is provided, the probability of NOT being a remotely managed tunnel is higher.\n \t\t// So, we should warn the user that no ingress rules were found, because remote configuration will most likely not exist.\n \t\tif !c.IsSet(\"token\") {\n-\t\t\tlog.Warn().Msgf(ErrNoIngressRulesCLI.Error())\n+\t\t\tlog.Warn().Msg(ErrNoIngressRulesCLI.Error())\n \t\t}\n \t\treturn newDefaultOrigin(c, log), nil\n \t}\n---\ningress/origin_proxy.go\n@@ -74,7 +74,7 @@ func (o *httpService) SetOriginServerName(req *http.Request) {\n \n func (o *statusCode) RoundTrip(_ *http.Request) (*http.Response, error) {\n \tif o.defaultResp {\n-\t\to.log.Warn().Msgf(ErrNoIngressRulesCLI.Error())\n+\t\to.log.Warn().Msg(ErrNoIngressRulesCLI.Error())\n \t}\n \tresp := &http.Response{\n \t\tStatusCode: o.code,\n---\ntunnelrpc/pogs/configuration_manager.go\n@@ -2,7 +2,7 @@ package pogs\n \n import (\n \t\"context\"\n-\t\"fmt\"\n+\t\"errors\"\n \n \tcapnp \"zombiezen.com/go/capnproto2\"\n \t\"zombiezen.com/go/capnproto2/rpc\"\n@@ -96,7 +96,7 @@ func (p *UpdateConfigurationResponse) Unmarshal(s proto.UpdateConfigurationRespo\n \t\treturn err\n \t}\n \tif respErr != \"\" {\n-\t\tp.Err = fmt.Errorf(respErr)\n+\t\tp.Err = errors.New(respErr)\n \t}\n \treturn nil\n }\n---\ntunnelrpc/pogs/session_manager.go\n@@ -2,6 +2,7 @@ package pogs\n \n import (\n \t\"context\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"net\"\n \t\"time\"\n@@ -127,7 +128,7 @@ func (p *RegisterUdpSessionResponse) Unmarshal(s proto.RegisterUdpSessionRespons\n \t\treturn err\n \t}\n \tif respErr != \"\" {\n-\t\tp.Err = fmt.Errorf(respErr)\n+\t\tp.Err = errors.New(respErr)\n \t}\n \tp.Spans, err = s.Spans()\n \tif err != nil {\n---\n"}], "ideal": "Title: Bump to Go 1.24.2\n\nBody: Fixes https://github.com/cloudflare/cloudflared/issues/1460.\r\n\r\nThis required fixing new `go vet` findings:\r\n\r\n```\r\ntunnelrpc/pogs/configuration_manager.go:99:22: non-constant format string in call to fmt.Errorf\r\ntunnelrpc/pogs/session_manager.go:130:22: non-constant format string in call to fmt.Errorf\r\ningress/ingress.go:116:20: non-constant format string in call to (*github.com/rs/zerolog.Event).Msgf\r\ningress/origin_proxy.go:77:21: non-constant format string in call to (*github.com/rs/zerolog.Event).Msgf\r\ncmd/cloudflared/tunnel/subcommands.go:764:31: non-constant format string in call to github.com/cloudflare/cloudflared/cmd/cloudflared/cliutil.UsageError\r\n```"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/subcommand_context.go\n@@ -9,6 +9,7 @@ import (\n \t\"strings\"\n \n \t\"github.com/google/uuid\"\n+\t\"github.com/mitchellh/go-homedir\"\n \t\"github.com/pkg/errors\"\n \t\"github.com/rs/zerolog\"\n \t\"github.com/urfave/cli/v2\"\n@@ -54,7 +55,12 @@ func newSubcommandContext(c *cli.Context) (*subcommandContext, error) {\n // Returns something that can find the given tunnel's credentials file.\n func (sc *subcommandContext) credentialFinder(tunnelID uuid.UUID) CredFinder {\n \tif path := sc.c.String(CredFileFlag); path != \"\" {\n-\t\treturn newStaticPath(path, sc.fs)\n+\t\t// Expand path if CredFileFlag contains `~`\n+\t\tabsPath, err := homedir.Expand(path)\n+\t\tif err != nil {\n+\t\t\treturn newStaticPath(path, sc.fs)\n+\t\t}\n+\t\treturn newStaticPath(absPath, sc.fs)\n \t}\n \treturn newSearchByID(tunnelID, sc.c, sc.log, sc.fs)\n }\n---\n"}], "ideal": "Title: fix: expand home directory for credentials file\n\nBody: ## Issue\r\n\r\nThe [documentation for creating a tunnel's configuration file](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/get-started/create-local-tunnel/#4-create-a-configuration-file) does not specify that the `credentials-file` field in `config.yml` needs to be an absolute path.\r\n\r\nA user (E.G. me \ud83e\udd26) might add a path like `~/.cloudflared/<uuid>.json` and wonder why the `cloudflared tunnel run` command is throwing a credentials file not found error. Although one might consider it intuitive, it's not a fair assumption as a lot of CLI tools allow file paths with `~` for specifying files.\r\n\r\nP.S. The tunnel ID in the following snippet is not a real tunnel ID, I just generated it.\r\n```\r\nurl: http://localhost:8000\r\ntunnel: 958a1ef6-ff8c-4455-825a-5aed91242135\r\ncredentials-file: ~/.cloudflared/958a1ef6-ff8c-4455-825a-5aed91242135.json\r\n```\r\n\r\nFurthermore, the error has a confusing message for the user as the file at the logged path actually exists, it is just that `os.Stat` failed because it could not expand the `~`.\r\n\r\n## Solution\r\n\r\nThis commit fixes the above issue by running a `homedir.Expand` on the `credentials-file` path in the `credentialFinder` function."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -119,6 +119,11 @@ else\n \tPACKAGE_ARCH := $(TARGET_ARCH)\n endif\n \n+#basically for GOMIPS=softfloat\n+ifneq ($(TARGET_MIPS), )\n+\tMIPS_COMMAND := GOMIPS=$(TARGET_MIPS)\n+endif\n+\n #for FIPS compliance, FPM defaults to MD5.\n RPM_DIGEST := --rpm-digest sha256\n \n@@ -134,7 +139,7 @@ cloudflared:\n ifeq ($(FIPS), true)\n \t$(info Building cloudflared with go-fips)\n endif\n-\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) $(ARM_COMMAND) go build -mod=vendor $(GO_BUILD_TAGS) $(LDFLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) $(ARM_COMMAND) $(MIPS_COMMAND) go build -mod=vendor $(GO_BUILD_TAGS) $(LDFLAGS) $(IMPORT_PATH)/cmd/cloudflared\n ifeq ($(FIPS), true)\n \t./check-fips.sh cloudflared\n endif\n---\nbuild-packages.sh\n@@ -10,7 +10,7 @@ export CGO_ENABLED=0\n export ARTIFACT_DIR=artifacts/\n mkdir -p $ARTIFACT_DIR\n \n-linuxArchs=(\"386\" \"amd64\" \"arm\" \"armhf\" \"arm64\")\n+linuxArchs=(\"386\" \"amd64\" \"arm\" \"armhf\" \"arm64\" \"mipsle\")\n export TARGET_OS=linux\n for arch in ${linuxArchs[@]}; do\n     unset TARGET_ARM\n@@ -27,6 +27,11 @@ for arch in ${linuxArchs[@]}; do\n         export TARGET_ARCH=arm\n         export TARGET_ARM=7 \n     fi\n+\n+    ## Support for softmips builds \n+    if [[ $arch == mipsle ]] ; then\n+        export GOMIPS=softfloat\n+    fi\n     \n     make cloudflared-deb\n     mv cloudflared\\_$VERSION\\_$arch.deb $ARTIFACT_DIR/cloudflared-linux-$arch.deb\n---\n"}], "ideal": "Title: feat(Makefile): add support for arch mips\n\nBody: Usage:\r\n```sh\r\nTARGET_OS=linux GOARCH=mipsle TARGET_MIPS=softfloat make cloudflared\r\n```"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/service_template.go\n@@ -7,7 +7,7 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"os/exec\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"text/template\"\n \n \thomedir \"github.com/mitchellh/go-homedir\"\n@@ -57,7 +57,7 @@ func (st *ServiceTemplate) Generate(args *ServiceTemplateArgs) error {\n \t\tfileMode = st.FileMode\n \t}\n \n-\tplistFolder := path.Dir(resolvedPath)\n+\tplistFolder := filepath.Dir(resolvedPath)\n \terr = os.MkdirAll(plistFolder, 0o755)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"error creating %s: %v\", plistFolder, err)\n---\ncmd/cloudflared/tunnel/subcommand_context.go\n@@ -112,7 +112,7 @@ func (sc *subcommandContext) readTunnelCredentials(credFinder CredFinder) (conne\n \n \tvar credentials connection.Credentials\n \tif err = json.Unmarshal(body, &credentials); err != nil {\n-\t\tif strings.HasSuffix(filePath, \".pem\") {\n+\t\tif filepath.Ext(filePath) == \".pem\" {\n \t\t\treturn connection.Credentials{}, fmt.Errorf(\"The tunnel credentials file should be .json but you gave a .pem. \" +\n \t\t\t\t\"The tunnel credentials file was originally created by `cloudflared tunnel create`. \" +\n \t\t\t\t\"You may have accidentally used the filepath to cert.pem, which is generated by `cloudflared tunnel \" +\n---\ncmd/cloudflared/updater/workers_update.go\n@@ -10,9 +10,9 @@ import (\n \t\"net/url\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n-\t\"strings\"\n \t\"text/template\"\n \t\"time\"\n \n@@ -198,15 +198,15 @@ func download(url, filepath string, isCompressed bool) error {\n \n // isCompressedFile is a really simple file extension check to see if this is a macos tar and gzipped\n func isCompressedFile(urlstring string) bool {\n-\tif strings.HasSuffix(urlstring, \".tgz\") {\n+\tif path.Ext(urlstring) == \".tgz\" {\n \t\treturn true\n \t}\n \n \tu, err := url.Parse(urlstring)\n \tif err != nil {\n \t\treturn false\n \t}\n-\treturn strings.HasSuffix(u.Path, \".tgz\")\n+\treturn path.Ext(u.Path) == \".tgz\"\n }\n \n // writeBatchFile writes a batch file out to disk\n---\ncredentials/credentials_test.go\n@@ -3,7 +3,7 @@ package credentials\n import (\n \t\"io/fs\"\n \t\"os\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"testing\"\n \n \t\"github.com/stretchr/testify/require\"\n@@ -13,7 +13,7 @@ func TestCredentialsRead(t *testing.T) {\n \tfile, err := os.ReadFile(\"test-cloudflare-tunnel-cert-json.pem\")\n \trequire.NoError(t, err)\n \tdir := t.TempDir()\n-\tcertPath := path.Join(dir, originCertFile)\n+\tcertPath := filepath.Join(dir, originCertFile)\n \tos.WriteFile(certPath, file, fs.ModePerm)\n \tuser, err := Read(certPath, &nopLog)\n \trequire.NoError(t, err)\n---\ncredentials/origin_cert_test.go\n@@ -4,7 +4,7 @@ import (\n \t\"fmt\"\n \t\"io/fs\"\n \t\"os\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"testing\"\n \n \t\"github.com/rs/zerolog\"\n@@ -63,7 +63,7 @@ func TestFindOriginCert_Valid(t *testing.T) {\n \tfile, err := os.ReadFile(\"test-cloudflare-tunnel-cert-json.pem\")\n \trequire.NoError(t, err)\n \tdir := t.TempDir()\n-\tcertPath := path.Join(dir, originCertFile)\n+\tcertPath := filepath.Join(dir, originCertFile)\n \t_ = os.WriteFile(certPath, file, fs.ModePerm)\n \tpath, err := FindOriginCert(certPath, &nopLog)\n \trequire.NoError(t, err)\n@@ -72,7 +72,7 @@ func TestFindOriginCert_Valid(t *testing.T) {\n \n func TestFindOriginCert_Missing(t *testing.T) {\n \tdir := t.TempDir()\n-\tcertPath := path.Join(dir, originCertFile)\n+\tcertPath := filepath.Join(dir, originCertFile)\n \t_, err := FindOriginCert(certPath, &nopLog)\n \trequire.Error(t, err)\n }\n---\nlogger/create.go\n@@ -4,7 +4,6 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n-\t\"path\"\n \t\"path/filepath\"\n \t\"sync\"\n \t\"time\"\n@@ -249,7 +248,7 @@ func createRollingLogger(config RollingConfig) (io.Writer, error) {\n \t\t}\n \n \t\trotatingFileInit.writer = &lumberjack.Logger{\n-\t\t\tFilename:   path.Join(config.Dirname, config.Filename),\n+\t\t\tFilename:   filepath.Join(config.Dirname, config.Filename),\n \t\t\tMaxBackups: config.maxBackups,\n \t\t\tMaxSize:    config.maxSize,\n \t\t\tMaxAge:     config.maxAge,\n---\n"}], "ideal": "Title: Use path and filepath operation appropriately.\n\nBody: Using path package methods can cause errors on windows machines.\r\n\r\npath methods are used for url operations and unix specific operation.\r\n\r\nfilepath methods are used for file system paths and its cross platform. \r\n\r\nRemove strings.HasSuffix and use filepath.Ext and path.Ext for file and url extenstions respectively.\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/generic_service.go\n@@ -3,11 +3,38 @@\n package main\n \n import (\n+\t\"fmt\"\n \t\"os\"\n \n \tcli \"github.com/urfave/cli/v2\"\n+\n+\t\"github.com/cloudflare/cloudflared/cmd/cloudflared/cliutil\"\n )\n \n func runApp(app *cli.App, graceShutdownC chan struct{}) {\n+\tapp.Commands = append(app.Commands, &cli.Command{\n+\t\tName:  \"service\",\n+\t\tUsage: \"Manages the cloudflared system service (not supported on this operating system)\",\n+\t\tSubcommands: []*cli.Command{\n+\t\t\t{\n+\t\t\t\tName:   \"install\",\n+\t\t\t\tUsage:  \"Install cloudflared as a system service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(installGenericService),\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:   \"uninstall\",\n+\t\t\t\tUsage:  \"Uninstall the cloudflared service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(uninstallGenericService),\n+\t\t\t},\n+\t\t},\n+\t})\n \tapp.Run(os.Args)\n }\n+\n+func installGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service installation is not supported on this operating system\")\n+}\n+\n+func uninstallGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service uninstallation is not supported on this operating system\")\n+}\n\\ No newline at end of file\n---\ndiagnostic/network/collector_unix.go\n@@ -1,4 +1,4 @@\n-//go:build darwin || linux\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n \n package diagnostic\n \n---\ndiagnostic/network/collector_unix_test.go\n@@ -1,4 +1,4 @@\n-//go:build darwin || linux\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n \n package diagnostic_test\n \n---\ndiagnostic/system_collector_unix.go\n@@ -0,0 +1,168 @@\n+//go:build !windows && !darwin && !linux\n+\n+package diagnostic\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+type SystemCollectorImpl struct {\n+\tversion string\n+}\n+\n+func NewSystemCollectorImpl(\n+\tversion string,\n+) *SystemCollectorImpl {\n+\treturn &SystemCollectorImpl{\n+\t\tversion,\n+\t}\n+}\n+\n+func (collector *SystemCollectorImpl) Collect(ctx context.Context) (*SystemInformation, error) {\n+\tmemoryInfo, memoryInfoRaw, memoryInfoErr := collectMemoryInformation(ctx)\n+\tfdInfo, fdInfoRaw, fdInfoErr := collectFileDescriptorInformation(ctx)\n+\tdisks, disksRaw, diskErr := collectDiskVolumeInformationUnix(ctx)\n+\tosInfo, osInfoRaw, osInfoErr := collectOSInformationUnix(ctx)\n+\n+\tvar memoryMaximum, memoryCurrent, fileDescriptorMaximum, fileDescriptorCurrent uint64\n+\tvar osSystem, name, osVersion, osRelease, architecture string\n+\tgerror := SystemInformationGeneralError{}\n+\n+\tif memoryInfoErr != nil {\n+\t\tgerror.MemoryInformationError = SystemInformationError{\n+\t\t\tErr:     memoryInfoErr,\n+\t\t\tRawInfo: memoryInfoRaw,\n+\t\t}\n+\t} else {\n+\t\tmemoryMaximum = memoryInfo.MemoryMaximum\n+\t\tmemoryCurrent = memoryInfo.MemoryCurrent\n+\t}\n+\n+\tif fdInfoErr != nil {\n+\t\tgerror.FileDescriptorsInformationError = SystemInformationError{\n+\t\t\tErr:     fdInfoErr,\n+\t\t\tRawInfo: fdInfoRaw,\n+\t\t}\n+\t} else {\n+\t\tfileDescriptorMaximum = fdInfo.FileDescriptorMaximum\n+\t\tfileDescriptorCurrent = fdInfo.FileDescriptorCurrent\n+\t}\n+\n+\tif diskErr != nil {\n+\t\tgerror.DiskVolumeInformationError = SystemInformationError{\n+\t\t\tErr:     diskErr,\n+\t\t\tRawInfo: disksRaw,\n+\t\t}\n+\t}\n+\n+\tif osInfoErr != nil {\n+\t\tgerror.OperatingSystemInformationError = SystemInformationError{\n+\t\t\tErr:     osInfoErr,\n+\t\t\tRawInfo: osInfoRaw,\n+\t\t}\n+\t} else {\n+\t\tosSystem = osInfo.OsSystem\n+\t\tname = osInfo.Name\n+\t\tosVersion = osInfo.OsVersion\n+\t\tosRelease = osInfo.OsRelease\n+\t\tarchitecture = osInfo.Architecture\n+\t}\n+\n+\tcloudflaredVersion := collector.version\n+\tinfo := NewSystemInformation(\n+\t\tmemoryMaximum,\n+\t\tmemoryCurrent,\n+\t\tfileDescriptorMaximum,\n+\t\tfileDescriptorCurrent,\n+\t\tosSystem,\n+\t\tname,\n+\t\tosVersion,\n+\t\tosRelease,\n+\t\tarchitecture,\n+\t\tcloudflaredVersion,\n+\t\truntime.Version(),\n+\t\truntime.GOARCH,\n+\t\tdisks,\n+\t)\n+\n+\treturn info, gerror\n+}\n+\n+func collectMemoryInformation(ctx context.Context) (*MemoryInformation, string, error) {\n+\t// FreeBSD uses `sysctl` to retrieve memory information.\n+\tconst (\n+\t\tmemTotalKey     = \"hw.physmem\"\n+\t\tmemAvailableKey = \"vm.stats.vm.v_free_count\"\n+\t)\n+\n+\tcommand := exec.CommandContext(ctx, \"sysctl\", \"-n\", memTotalKey)\n+\ttotalOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\tcommand = exec.CommandContext(ctx, \"sysctl\", \"-n\", memAvailableKey)\n+\tavailableOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\ttotal, err := strconv.ParseUint(strings.TrimSpace(string(totalOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(totalOutput), fmt.Errorf(\"error parsing memory total: %w\", err)\n+\t}\n+\n+\tavailable, err := strconv.ParseUint(strings.TrimSpace(string(availableOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(availableOutput), fmt.Errorf(\"error parsing memory available: %w\", err)\n+\t}\n+\n+\tmemoryInfo := &MemoryInformation{\n+\t\tMemoryMaximum: total,\n+\t\tMemoryCurrent: available * 4096, // FreeBSD reports pages; multiply by page size (4K).\n+\t}\n+\n+\treturn memoryInfo, fmt.Sprintf(\"Total: %s, Available: %s\", totalOutput, availableOutput), nil\n+}\n+\n+func collectFileDescriptorInformation(ctx context.Context) (*FileDescriptorInformation, string, error) {\n+\t// FreeBSD uses `sysctl` for file descriptor limits.\n+\tconst (\n+\t\tfdMaxKey = \"kern.maxfiles\"\n+\t\tfdCurrentKey = \"kern.openfiles\"\n+\t)\n+\n+\tcommand := exec.CommandContext(ctx, \"sysctl\", \"-n\", fdMaxKey)\n+\tmaxOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\tcommand = exec.CommandContext(ctx, \"sysctl\", \"-n\", fdCurrentKey)\n+\tcurrentOutput, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"error retrieving output from command '%s': %w\", command.String(), err)\n+\t}\n+\n+\tmax, err := strconv.ParseUint(strings.TrimSpace(string(maxOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(maxOutput), fmt.Errorf(\"error parsing max file descriptors: %w\", err)\n+\t}\n+\n+\tcurrent, err := strconv.ParseUint(strings.TrimSpace(string(currentOutput)), 10, 64)\n+\tif err != nil {\n+\t\treturn nil, string(currentOutput), fmt.Errorf(\"error parsing current file descriptors: %w\", err)\n+\t}\n+\n+\tfdInfo := &FileDescriptorInformation{\n+\t\tFileDescriptorMaximum: max,\n+\t\tFileDescriptorCurrent: current,\n+\t}\n+\n+\treturn fdInfo, fmt.Sprintf(\"Max: %s, Current: %s\", maxOutput, currentOutput), nil\n+}\n---\ningress/icmp_posix.go\n@@ -1,5 +1,4 @@\n-//go:build darwin || linux\n-\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n package ingress\n \n // This file extracts logic shared by Linux and Darwin implementation if ICMPProxy.\n---\ningress/icmp_posix_test.go\n@@ -1,4 +1,4 @@\n-//go:build darwin || linux\n+//go:build darwin || linux || freebsd || openbsd || netbsd\n \n package ingress\n \n---\n"}], "ideal": "Title: Fix FreeBSD Compile Problems\n\nBody: Since a new network diagnostic was introduced at the end of November 2024, it has not been possible to build `cloudflared` for FreeBSD.\r\n\r\nThe changes included here correct this oversight while also including a FreeBSD-centric change from https://github.com/cloudflare/cloudflared/pull/1291, correcting an issue in its proposed change (forgetting to import \"github.com/cloudflare/cloudflared/cmd/cloudflared/cliutil\").\r\n\r\nThis likely fixes other *bsd flavors, but testing was only carried out on FreeBSD 14.1, amd64.\r\nA nearly final build is available for testing, attached to the last commit that still included the workflow definition. \r\n\r\nhttps://github.com/kjake/cloudflared/actions/runs/12876426294"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "ingress/ingress.go\n@@ -3,6 +3,7 @@ package ingress\n import (\n \t\"fmt\"\n \t\"net\"\n+\t\"net/http\"\n \t\"net/url\"\n \t\"regexp\"\n \t\"strconv\"\n@@ -260,7 +261,7 @@ func validateIngress(ingress []config.UnvalidatedIngressRule, defaults OriginReq\n \t\t\tif err != nil {\n \t\t\t\treturn Ingress{}, errors.Wrap(err, \"invalid HTTP status code\")\n \t\t\t}\n-\t\t\tif statusCode < 100 || statusCode > 999 {\n+\t\t\tif http.StatusText(statusCode) == \"\" {\n \t\t\t\treturn Ingress{}, fmt.Errorf(\"invalid HTTP status code: %d\", statusCode)\n \t\t\t}\n \t\t\tsrv := newStatusCode(statusCode)\n---\ningress/ingress_test.go\n@@ -247,10 +247,18 @@ ingress:\n \t\t\twantErr: true,\n \t\t},\n \t\t{\n-\t\t\tname: \"Invalid HTTP status code\",\n+\t\t\tname: \"Invalid HTTP status code(8080)\",\n \t\t\targs: args{rawYAML: `\n ingress:\n  - service: http_status:8080\n+`},\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Invalid HTTP status code(666)\",\n+\t\t\targs: args{rawYAML: `\n+ingress:\n+ - service: http_status:666\n `},\n \t\t\twantErr: true,\n \t\t},\n---\n"}], "ideal": "Title: Improve `http_status` validation\n\nBody: Currently, the validation of the http status input is a numeric range, so an invalid status code can be entered. Change to check if the http status code exists or not.\r\nrelated to https://github.com/cloudflare/cloudflared/issues/1389 .\r\n\r\n![2024-12-24-11 09 30@2x](https://github.com/user-attachments/assets/38cbe955-0aae-4abb-a53b-bc0807f3b502)\r\n\r\nEven if this validation were added, it is still possible to set it from the Web UI( https://one.dash.cloudflare.com/ ), so that needs to be modified as well.\r\n\r\nThose that exist as http status but are not normally used can be registered, but I think this should be handled by the web UI. \r\n(Personally, I don't see a problem with using the joke status code because it's funny.)\r\n![image(1)](https://github.com/user-attachments/assets/5f0551fd-a6a9-45f8-bb4f-42d2506a83e4)\r\n![2024-12-24-11 03 22](https://github.com/user-attachments/assets/9a0c6885-4089-4c64-bb5d-bd36c64da4b0)\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "connection/connection.go\n@@ -29,6 +29,8 @@ const (\n \tcontentTypeHeader = \"content-type\"\n \tsseContentType    = \"text/event-stream\"\n \tgrpcContentType   = \"application/grpc\"\n+\n+\tFlushResponseHeader  = \"cf-cloudflared-flush-response\"\n )\n \n var (\n@@ -270,6 +272,10 @@ type ConnectedFuse interface {\n // Helper method to let the caller know what content-types should require a flush on every\n // write to a ResponseWriter.\n func shouldFlush(headers http.Header) bool {\n+\tif headers.Get(FlushResponseHeader) == \"yes\" {\n+\t\treturn true\n+\t}\n+\n \tif contentType := headers.Get(contentTypeHeader); contentType != \"\" {\n \t\tcontentType = strings.ToLower(contentType)\n \t\tfor _, c := range flushableContentTypes {\n---\n"}], "ideal": "Title: Introduce a custom header which servers can return to request cloudflared to not buffer the response.\n\nBody: cloudflared currently only supports bypassing its response buffering through the Content-Type. This PR adds support for a custom header `cf-cloudflared-flush-response` which when present and having a value of `yes`, disables response buffering as well."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -165,6 +165,18 @@ cover:\n \t# Generate the HTML report that can be viewed from the browser in CI.\n \t$Q go tool cover -html \".cover/c.out\" -o .cover/all.html\n \n+.PHONY: fuzz\n+fuzz:\n+\t@go test -fuzz=FuzzIPDecoder -fuzztime=600s ./packet\n+\t@go test -fuzz=FuzzICMPDecoder -fuzztime=600s ./packet\n+\t@go test -fuzz=FuzzSessionWrite -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzSessionServe -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzRegistrationDatagram -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzPayloadDatagram -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzRegistrationResponseDatagram -fuzztime=600s ./quic/v3\n+\t@go test -fuzz=FuzzNewIdentity -fuzztime=600s ./tracing\n+\t@go test -fuzz=FuzzNewAccessValidator -fuzztime=600s ./validation\n+\n .PHONY: install-go\n install-go:\n \trm -rf ${CF_GO_PATH}\n---\npacket/decoder_test.go\n@@ -254,3 +254,18 @@ func (u *UDP) EncodeLayers() ([]gopacket.SerializableLayer, error) {\n \tudpLayer.SetNetworkLayerForChecksum(ipLayers[0].(gopacket.NetworkLayer))\n \treturn append(ipLayers, &udpLayer), nil\n }\n+\n+func FuzzIPDecoder(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tipDecoder := NewIPDecoder()\n+\t\tipDecoder.Decode(RawPacket{Data: data})\n+\n+\t})\n+}\n+\n+func FuzzICMPDecoder(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\ticmpDecoder := NewICMPDecoder()\n+\t\ticmpDecoder.Decode(RawPacket{Data: data})\n+\t})\n+}\n---\nquic/v3/datagram_test.go\n@@ -350,3 +350,30 @@ func compareRegistrationDatagrams(t *testing.T, l *v3.UDPSessionRegistrationData\n \t\tl.IdleDurationHint == r.IdleDurationHint &&\n \t\tl.Traced == r.Traced\n }\n+\n+func FuzzRegistrationDatagram(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tunmarshaled := v3.UDPSessionRegistrationDatagram{}\n+\t\terr := unmarshaled.UnmarshalBinary(data)\n+\t\tif err == nil {\n+\t\t\t_, _ = unmarshaled.MarshalBinary()\n+\t\t}\n+\t})\n+}\n+\n+func FuzzPayloadDatagram(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tunmarshaled := v3.UDPSessionPayloadDatagram{}\n+\t\t_ = unmarshaled.UnmarshalBinary(data)\n+\t})\n+}\n+\n+func FuzzRegistrationResponseDatagram(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tunmarshaled := v3.UDPSessionRegistrationResponseDatagram{}\n+\t\terr := unmarshaled.UnmarshalBinary(data)\n+\t\tif err == nil {\n+\t\t\t_, _ = unmarshaled.MarshalBinary()\n+\t\t}\n+\t})\n+}\n---\ntracing/tracing_test.go\n@@ -72,3 +72,9 @@ func TestAddingSpansWithNilMap(t *testing.T) {\n \t// a panic shouldn't occur\n \ttr.AddSpans(nil)\n }\n+\n+func FuzzNewIdentity(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, trace string) {\n+\t\t_, _ = NewIdentity(trace)\n+\t})\n+}\n---\nvalidation/validation_test.go\n@@ -197,3 +197,10 @@ func createSecureMockServerAndClient(handler http.Handler) (*httptest.Server, *h\n \n \treturn server, client, nil\n }\n+\n+func FuzzNewAccessValidator(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, domain string, issuer string, applicationAUD string) {\n+\t\tctx := context.Background()\n+\t\t_, _ = NewAccessValidator(ctx, domain, issuer, applicationAUD)\n+\t})\n+}\n---\n"}], "ideal": "Title: add: new go-fuzz targets\n\nBody: Some new go-fuzz targets.\r\n\r\nThese are the same test targets that I used for my HackerOne report."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "connection/quic.go\n@@ -550,15 +550,6 @@ func isTransferEncodingChunked(req *http.Request) bool {\n \treturn strings.Contains(strings.ToLower(transferEncodingVal), \"chunked\")\n }\n \n-// Borrowed from https://github.com/golang/go/blob/go1.22.6/src/net/http/request.go#L1541\n-func requestMethodUsuallyLacksBody(req *http.Request) bool {\n-\tswitch strings.ToUpper(req.Method) {\n-\tcase \"GET\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"PROPFIND\", \"SEARCH\":\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n func shouldSetRequestBodyToEmpty(connectRequest *pogs.ConnectRequest, metadata map[string]string, req *http.Request) bool {\n \tswitch metadata[HTTPRequestBodyHintKey] {\n \tcase RequestBodyHintEmpty.String():\n@@ -576,7 +567,7 @@ func shouldSetRequestBodyToEmpty(connectRequest *pogs.ConnectRequest, metadata m\n \t//   * there is no transfer-encoding=chunked already set.\n \t// So, if transfer cannot be chunked and content length is 0, we dont set a request body.\n \t// Reference: https://github.com/golang/go/blob/go1.22.2/src/net/http/transfer.go#L192-L206\n-\treturn !isWebsocket && requestMethodUsuallyLacksBody(req) && !isTransferEncodingChunked(req) && req.ContentLength == 0\n+\treturn !isWebsocket && !isTransferEncodingChunked(req) && req.ContentLength == 0\n }\n \n // A helper struct that guarantees a call to close only affects read side, but not write side.\n---\nconnection/quic_test.go\n@@ -566,43 +566,6 @@ func TestBuildHTTPRequest(t *testing.T) {\n \t\t\t},\n \t\t\tbody: io.NopCloser(&bytes.Buffer{}),\n \t\t},\n-\t\t{\n-\t\t\tname: \"if the http method usually has body, don't set body to empty\",\n-\t\t\tconnectRequest: &pogs.ConnectRequest{\n-\t\t\t\tDest: \"http://test.com\",\n-\t\t\t\tMetadata: []pogs.Metadata{\n-\t\t\t\t\t{\n-\t\t\t\t\t\tKey: \"HttpHeader:Another-Header\",\n-\t\t\t\t\t\tVal: \"Misc\",\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tKey: \"HttpHost\",\n-\t\t\t\t\t\tVal: \"cf.host\",\n-\t\t\t\t\t},\n-\t\t\t\t\t{\n-\t\t\t\t\t\tKey: \"HttpMethod\",\n-\t\t\t\t\t\tVal: \"post\",\n-\t\t\t\t\t},\n-\t\t\t\t},\n-\t\t\t},\n-\t\t\treq: &http.Request{\n-\t\t\t\tMethod: \"post\",\n-\t\t\t\tURL: &url.URL{\n-\t\t\t\t\tScheme: \"http\",\n-\t\t\t\t\tHost:   \"test.com\",\n-\t\t\t\t},\n-\t\t\t\tProto:      \"HTTP/1.1\",\n-\t\t\t\tProtoMajor: 1,\n-\t\t\t\tProtoMinor: 1,\n-\t\t\t\tHeader: http.Header{\n-\t\t\t\t\t\"Another-Header\": []string{\"Misc\"},\n-\t\t\t\t},\n-\t\t\t\tContentLength: 0,\n-\t\t\t\tHost:          \"cf.host\",\n-\t\t\t\tBody:          io.NopCloser(&bytes.Buffer{}),\n-\t\t\t},\n-\t\t\tbody: io.NopCloser(&bytes.Buffer{}),\n-\t\t},\n \t}\n \n \tlog := zerolog.Nop()\n---\n"}], "ideal": "Title: Restore ability to relay POST requests with empty bodies\n\nBody: It appears that the commit in the latest release (https://github.com/cloudflare/cloudflared/commit/e2064c820f32802f58baa027903043fe0ed052e0) was designed to check for specific request methods: `\"GET\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"PROPFIND\", \"SEARCH\"`. If the request matched one of these methods, the request body would be set to empty. If it didn\u2019t match, the body wouldn\u2019t be modified. However, it seems the commit didn\u2019t account for requests like POST, which can also have an empty body. Since POST wasn\u2019t included in the predefined list, the request body wasn\u2019t being set to empty when necessary.\r\n\r\nCloses: https://github.com/cloudflare/cloudflared/issues/1337"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".github/workflows/semgrep.yml\n@@ -1,4 +1,3 @@\n-\n on:\n   pull_request: {}\n   workflow_dispatch: {}\n@@ -12,14 +11,14 @@ name: Semgrep config\n jobs:\n   semgrep:\n     name: semgrep/ci\n-    runs-on: ubuntu-20.04\n+    runs-on: ubuntu-latest\n     env:\n       SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}\n       SEMGREP_URL: https://cloudflare.semgrep.dev\n       SEMGREP_APP_URL: https://cloudflare.semgrep.dev\n       SEMGREP_VERSION_CHECK_URL: https://cloudflare.semgrep.dev/api/check-version\n     container:\n-      image: returntocorp/semgrep\n+      image: semgrep/semgrep\n     steps:\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n       - run: semgrep ci\n---\n"}], "ideal": "Title: Update semgrep.yml\n\nBody: Updating Semgrep.yml file - Semgrep is a tool that will be used to scan Cloudflare's public repos for Supply chain, code and secrets. This work is part of Application & Product Security team's initiative to onboard Semgrep onto all of Cloudflare's public repos.\r\n\r\nIn case of any questions, please reach out to \"Hrushikesh Deshpande\" on cf internal chat."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -18,7 +18,7 @@ RUN .teamcity/install-cloudflare-go.sh\n RUN PATH=\"/tmp/go/bin:$PATH\" make cloudflared\n \n # use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian11:nonroot\n+FROM gcr.io/distroless/base-debian12:nonroot\n \n LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n \n---\nDockerfile.amd64\n@@ -14,7 +14,7 @@ RUN .teamcity/install-cloudflare-go.sh\n RUN GOOS=linux GOARCH=amd64 PATH=\"/tmp/go/bin:$PATH\" make cloudflared\n \n # use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian11:nonroot\n+FROM gcr.io/distroless/base-debian12:nonroot\n \n LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n \n---\nDockerfile.arm64\n@@ -14,7 +14,7 @@ RUN .teamcity/install-cloudflare-go.sh\n RUN GOOS=linux GOARCH=arm64 PATH=\"/tmp/go/bin:$PATH\" make cloudflared\n \n # use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian11:nonroot-arm64\n+FROM gcr.io/distroless/base-debian12:nonroot-arm64\n \n LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n \n---\n"}], "ideal": "Title: Bumped distroless/base-debian12\n\nBody: Needed to fix bug related to glibc - see https://github.com/GoogleContainerTools/distroless/issues/1342"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/subcommand_context.go\n@@ -261,7 +261,7 @@ func (sc *subcommandContext) runWithCredentials(credentials connection.Credentia\n \treturn StartServer(\n \t\tsc.c,\n \t\tbuildInfo,\n-\t\t&connection.TunnelProperties{Credentials: credentials},\n+\t\t&connection.TunnelProperties{Credentials: credentials, QuickTunnelUrl: credentials.Hostname},\n \t\tsc.log,\n \t)\n }\n---\nconnection/connection.go\n@@ -53,6 +53,7 @@ type Credentials struct {\n \tAccountTag   string\n \tTunnelSecret []byte\n \tTunnelID     uuid.UUID\n+\tHostname     string\n }\n \n func (c *Credentials) Auth() pogs.TunnelAuth {\n---\n"}], "ideal": "Title: persistent cfd quick tunnel\n\nBody: This PR introduces functionality to allow users to create and manage persistent Cloudflare quick tunnels. While quick tunnels are typically ephemeral, this feature enables users to set up long-lasting tunnels for ongoing projects or applications.\r\n\r\nCreate a new tunnel:\r\n```curl -XPOST https://api.trycloudflare.com/tunnel -H \"Content-Type: application/json\"```\r\n\r\nThis generates a credential file (cred.json) containing tunnel details:\r\n```json\r\n{\r\n  \"TunnelID\": \"6eed86e6-3359-4439-8561-e7e8c16730b7\",\r\n  \"name\": \"qt-iG1nZiARKhXjEkIQ2hfCzKesBCwEKeXq\",\r\n  \"Hostname\": \"ill-indoor-global-price.trycloudflare.com\",\r\n  \"AccountTag\": \"5ab4e9dfbd435d24068829fda0077963\",\r\n  \"TunnelSecret\": \"ruHGVAUTEAXTdAhOMTCJ0o/+EY3kzcsukMC7ktSQ+SQ=\"\r\n}\r\n```\r\n\r\nCreate a configuration file (config.yml):\r\n```yaml\r\nurl: localhost:8080\r\ntunnel: 6eed86e6-3359-4439-8561-e7e8c16730b7\r\ncredential-file: /Users/0verflow/cred.json\r\n```\r\n\r\nRun the tunnel:\r\n`./cloudflared tunnel --config /Users/0verflow/config.yml run --cred-file /Users/0verflow/cred.json`"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/subcommands.go\n@@ -39,6 +39,7 @@ const (\n \tCredFileFlag            = \"credentials-file\"\n \tCredContentsFlag        = \"credentials-contents\"\n \tTunnelTokenFlag         = \"token\"\n+\tTunnelTokenFileFlag     = \"token-file\"\n \toverwriteDNSFlagName    = \"overwrite-dns\"\n \tnoDiagLogsFlagName      = \"no-diag-logs\"\n \tnoDiagMetricsFlagName   = \"no-diag-metrics\"\n@@ -125,9 +126,14 @@ var (\n \t})\n \ttunnelTokenFlag = altsrc.NewStringFlag(&cli.StringFlag{\n \t\tName:    TunnelTokenFlag,\n-\t\tUsage:   \"The Tunnel token. When provided along with credentials, this will take precedence.\",\n+\t\tUsage:   \"The Tunnel token. When provided along with credentials, this will take precedence. Also takes precedence over token-file\",\n \t\tEnvVars: []string{\"TUNNEL_TOKEN\"},\n \t})\n+\ttunnelTokenFileFlag = altsrc.NewStringFlag(&cli.StringFlag{\n+\t\tName:    TunnelTokenFileFlag,\n+\t\tUsage:   \"Filepath at which to read the tunnel token. When provided along with credentials, this will take precedence.\",\n+\t\tEnvVars: []string{\"TUNNEL_TOKEN_FILE\"},\n+\t})\n \tforceDeleteFlag = &cli.BoolFlag{\n \t\tName:    \"force\",\n \t\tAliases: []string{\"f\"},\n@@ -697,6 +703,7 @@ func buildRunCommand() *cli.Command {\n \t\tselectProtocolFlag,\n \t\tfeaturesFlag,\n \t\ttunnelTokenFlag,\n+\t\ttunnelTokenFileFlag,\n \t\ticmpv4SrcFlag,\n \t\ticmpv6SrcFlag,\n \t}\n@@ -736,12 +743,22 @@ func runCommand(c *cli.Context) error {\n \t\t\t\"your origin will not be reachable. You should remove the `hostname` property to avoid this warning.\")\n \t}\n \n+\ttokenStr := c.String(TunnelTokenFlag)\n+\t// Check if tokenStr is blank before checking for tokenFile\n+\tif tokenStr == \"\" {\n+\t\tif tokenFile := c.String(TunnelTokenFileFlag); tokenFile != \"\" {\n+\t\t\tdata, err := os.ReadFile(tokenFile)\n+\t\t\tif err != nil {\n+\t\t\t\treturn cliutil.UsageError(\"Failed to read token file: \" + err.Error())\n+\t\t\t}\n+\t\t\ttokenStr = strings.TrimSpace(string(data))\n+\t\t}\n+\t}\n \t// Check if token is provided and if not use default tunnelID flag method\n-\tif tokenStr := c.String(TunnelTokenFlag); tokenStr != \"\" {\n+\tif tokenStr != \"\" {\n \t\tif token, err := ParseToken(tokenStr); err == nil {\n \t\t\treturn sc.runWithCredentials(token.Credentials())\n \t\t}\n-\n \t\treturn cliutil.UsageError(\"Provided Tunnel token is not valid.\")\n \t} else {\n \t\ttunnelRef := c.Args().First()\n---\n"}], "ideal": "Title: Adds a new command line for tunnel run for token file\n\nBody: Adds a new command line flag for `tunnel run` which allows a file to be read for the token. I've left the token command line argument with priority. \r\n\r\nWould resolve #645 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "token/token.go\n@@ -63,6 +63,10 @@ type jwtPayload struct {\n \tSubt  string   `json:\"sub\"`\n }\n \n+type lockFile struct {\n+\tPid int `json:\"pid\"`\n+}\n+\n type transferServiceResponse struct {\n \tAppToken string `json:\"app_token\"`\n \tOrgToken string `json:\"org_token\"`\n@@ -125,14 +129,36 @@ func (l *lock) Acquire() error {\n \t\t}\n \t}\n \n+\t// Create a lock file with the process ID\n+\tlockInfo := lockFile{\n+\t\tPid: os.Getpid(),\n+\t}\n+\n+\tlockData, err := json.Marshal(lockInfo)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \t// Create a lock file so other processes won't also try to get the token at\n \t// the same time\n-\tif err := os.WriteFile(l.lockFilePath, []byte{}, 0600); err != nil {\n+\tif err := os.WriteFile(l.lockFilePath, lockData, 0600); err != nil {\n \t\treturn err\n \t}\n+\n \treturn nil\n }\n \n+// processExists checks if a process with a given PID is still running\n+func processExists(pid int) bool {\n+\tprocess, err := os.FindProcess(pid)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\n+\terr = process.Signal(syscall.Signal(0))\n+\treturn err == nil\n+}\n+\n func (l *lock) deleteLockFile() error {\n \tif err := os.Remove(l.lockFilePath); err != nil && !os.IsNotExist(err) {\n \t\treturn errDeleteTokenFailed(l.lockFilePath)\n@@ -148,6 +174,29 @@ func (l *lock) Release() error {\n // isTokenLocked checks to see if there is another process attempting to get the token already\n func isTokenLocked(lockFilePath string) bool {\n \texists, err := config.FileExists(lockFilePath)\n+\tif exists && err == nil {\n+\t\tcontent, err := os.ReadFile(lockFilePath)\n+\t\tif err != nil {\n+\t\t\treturn true\n+\t\t}\n+\n+\t\tvar payload lockFile\n+\t\terr = json.Unmarshal(content, &payload)\n+\t\tif err != nil {\n+\t\t\t// if the lockfile did not contain a payload that means it was issued by an older version of cloudflared and should be deleted\n+\t\t\treturn false\n+\t\t}\n+\n+\t\t// Check if the process that created the lock is still running\n+\t\tif processExists(payload.Pid) {\n+\t\t\treturn true\n+\t\t}\n+\n+\t\t// If the process is not running, delete the stale lock file\n+\t\t_ = os.Remove(lockFilePath)\n+\t\treturn false\n+\t}\n+\n \treturn exists && err == nil\n }\n \n---\n"}], "ideal": "Title: AUTH-4699 adds an iat to the lockfile for orgs and apps to know if th\u2026\n\nBody: \u2026ey are stale or not"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "README.md\n@@ -1,10 +1,10 @@\n # Cloudflare Tunnel client\n \n Contains the command-line client for Cloudflare Tunnel, a tunneling daemon that proxies traffic from the Cloudflare network to your origins.\n-This daemon sits between Cloudflare network and your origin (e.g. a webserver). Cloudflare attracts client requests and sends them to you\n-via this daemon, without requiring you to poke holes on your firewall --- your origin can remain as closed as possible.\n+This daemon sits between Cloudflared network and your origin (e.g. a webserver). Cloudflare attracts client requests and sends them to you\n+via this daemon, without requiring you to poke holes in your firewall --- your origin can remain as closed as possible.\n Extensive documentation can be found in the [Cloudflare Tunnel section](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps) of the Cloudflare Docs.\n-All usages related with proxying to your origins are available under `cloudflared tunnel help`.\n+All usages related to proxying to your origins are available under `cloudflared tunnel help`.\n \n You can also use `cloudflared` to access Tunnel origins (that are protected with `cloudflared tunnel`) for TCP traffic\n at Layer 4 (i.e., not HTTP/websocket), which is relevant for use cases such as SSH, RDP, etc.\n@@ -18,7 +18,7 @@ to access private origins behind Tunnels for Layer 4 traffic without requiring `\n \n Before you use Cloudflare Tunnel, you'll need to complete a few steps in the Cloudflare dashboard: you need to add a\n website to your Cloudflare account. Note that today it is possible to use Tunnel without a website (e.g. for private\n-routing), but for legacy reasons this requirement is still necessary:\n+routing), but for legacy reasons, this requirement is still necessary:\n 1. [Add a website to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/201720164-Creating-a-Cloudflare-account-and-adding-a-website)\n 2. [Change your domain nameservers to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/205195708)\n \n---\n"}], "ideal": "Title: Update README.md\n\nBody: minor fixes to readme"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "tunneldns/tunnel.go\n@@ -4,6 +4,7 @@ import (\n \t\"net\"\n \t\"strconv\"\n \t\"sync\"\n+\t\"os\"\n \n \t\"github.com/coredns/coredns/core/dnsserver\"\n \t\"github.com/coredns/coredns/plugin\"\n@@ -90,20 +91,37 @@ func CreateListener(address string, port uint16, upstreams []string, bootstraps\n \t\tupstreamList = append(upstreamList, upstream)\n \t}\n \n-\t// Create a local cache with HTTPS proxy plugin\n-\tchain := cache.New()\n-\tchain.Next = ProxyPlugin{\n-\t\tUpstreams: upstreamList,\n-\t}\n-\n \t// Format an endpoint\n \tendpoint := \"dns://\" + net.JoinHostPort(address, strconv.FormatUint(uint64(port), 10))\n \n+\t// get middlewares for DNS Server\n+\tmiddlewares := getMiddlewares(upstreamList)\n+\tchain := NewMetricsPlugin(middlewares)\n+\n \t// Create the actual middleware server\n-\tserver, err := dnsserver.NewServer(endpoint, []*dnsserver.Config{createConfig(address, port, NewMetricsPlugin(chain))})\n+\tserver, err := dnsserver.NewServer(endpoint, []*dnsserver.Config{createConfig(address, port, chain)})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\t\n \n \treturn &Listener{server: server, log: log}, nil\n }\n+\n+// getMiddlewares() returns the middleware chain for DNS Server\n+// \n+// Middleware includes features like...\n+// * Response Cache\n+// * HTTP Proxy Settings\n+func getMiddlewares(upstreamList []Upstream) plugin.Handler { \n+\tproxyPlugin := ProxyPlugin{\n+\t\tUpstreams: upstreamList,\n+\t}\n+\tcachePlugin := cache.New()\n+\tcachePlugin.Next = proxyPlugin\n+\n+\tif os.Getenv(\"DISABLE_TUNNELDNS_CACHE\") == \"true\" { \n+\t\treturn cachePlugin \n+\t} \n+\treturn proxyPlugin\n+}\n\\ No newline at end of file\n---\n"}], "ideal": "Title: Refactor tunneldns dnsserver configuration\n\nBody: Refactored the tunneldns package's dnsserver listener configuration.  This provides a path to disabling response caching as needed to fix #745 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/generic_service.go\n@@ -3,11 +3,36 @@\n package main\n \n import (\n+\t\"fmt\"\n \t\"os\"\n \n \tcli \"github.com/urfave/cli/v2\"\n )\n \n func runApp(app *cli.App, graceShutdownC chan struct{}) {\n+\tapp.Commands = append(app.Commands, &cli.Command{\n+\t\tName:  \"service\",\n+\t\tUsage: \"Manages the cloudflared system service (not supported on this operating system)\",\n+\t\tSubcommands: []*cli.Command{\n+\t\t\t{\n+\t\t\t\tName:   \"install\",\n+\t\t\t\tUsage:  \"Install cloudflared as a system service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(installGenericService),\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:   \"uninstall\",\n+\t\t\t\tUsage:  \"Uninstall the cloudflared service (not supported on this operating system)\",\n+\t\t\t\tAction: cliutil.ConfiguredAction(uninstallGenericService),\n+\t\t\t},\n+\t\t},\n+\t})\n \tapp.Run(os.Args)\n }\n+\n+func installGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service installation is not supported on this operating system\")\n+}\n+\n+func uninstallGenericService(c *cli.Context) error {\n+\treturn fmt.Errorf(\"service uninstallation is not supported on this operating system\")\n+}\n---\n"}], "ideal": "Title: feat: emit explicit errors for the `service` command on unsupported OSes\n\nBody: Per the contribution guidelines, this seemed to me like a small enough change to not warrant an issue before creating this pull request. Let me know if you'd like me to create one anyway.\r\n\r\n## Background\r\n\r\nWhile working with `cloudflared` on FreeBSD recently, I noticed that there's an inconsistency with the available CLI commands on that OS versus others \u2014 namely that the `service` command doesn't exist at all for operating systems other than Linux, macOS, and Windows.\r\n\r\nContrast `cloudflared --help` output on macOS versus FreeBSD (truncated to focus on the `COMMANDS` section):\r\n\r\n- Current help output on macOS:\r\n\r\n  ```text\r\n  COMMANDS:\r\n     update     Update the agent if a new version exists\r\n     version    Print the version\r\n     proxy-dns  Run a DNS over HTTPS proxy server.\r\n     tail       Stream logs from a remote cloudflared\r\n     service    Manages the cloudflared launch agent\r\n     help, h    Shows a list of commands or help for one command\r\n     Access:\r\n       access, forward  access <subcommand>\r\n     Tunnel:\r\n       tunnel  Use Cloudflare Tunnel to expose private services to the Internet or to   Cloudflare connected private users.\r\n  ```\r\n- Current help output on FreeBSD:\r\n  ```text\r\n  COMMANDS:\r\n     update     Update the agent if a new version exists\r\n     version    Print the version\r\n     proxy-dns  Run a DNS over HTTPS proxy server.\r\n     tail       Stream logs from a remote cloudflared\r\n     help, h    Shows a list of commands or help for one command\r\n     Access:\r\n       access, forward  access <subcommand>\r\n     Tunnel:\r\n       tunnel  Use Cloudflare Tunnel to expose private services to the Internet or to   Cloudflare connected private users.\r\n  ```\r\n\r\nThis omission has caused confusion for users (including me), especially since the provided command in the Cloudflare Zero Trust dashboard returns a seemingly-unrelated error message:\r\n\r\n```console\r\n$ sudo cloudflared service install ...\r\nYou did not specify any valid additional argument to the cloudflared tunnel command.\r\n\r\nIf you are trying to run a Quick Tunnel then you need to explicitly pass the --url flag.\r\nEg. cloudflared tunnel --url localhost:8080/.\r\n\r\nPlease note that Quick Tunnels are meant to be ephemeral and should only be used for testing purposes.\r\nFor production usage, we recommend creating Named Tunnels. (https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/)\r\n```\r\n\r\n## Contribution\r\n\r\nThis pull request adds a \"stub\" `service` command (including the usual subcommands available on other OSes) to explicitly declare it as unsupported on the operating system.\r\n\r\nNew help output on FreeBSD (and other operating systems where service management is unsupported):\r\n\r\n```text\r\nCOMMANDS:\r\n   update     Update the agent if a new version exists\r\n   version    Print the version\r\n   proxy-dns  Run a DNS over HTTPS proxy server.\r\n   tail       Stream logs from a remote cloudflared\r\n   service    Manages the cloudflared system service (not supported on this operating system)\r\n   help, h    Shows a list of commands or help for one command\r\n   Access:\r\n     access, forward  access <subcommand>\r\n   Tunnel:\r\n     tunnel  Use Cloudflare Tunnel to expose private services to the Internet or to   Cloudflare connected private users.\r\n```\r\n\r\nNew outputs when running the service management subcommands:\r\n\r\n```console\r\n$ sudo cloudflared service install ...\r\nservice installation is not supported on this operating system\r\n```\r\n\r\n```console\r\n$ sudo cloudflared service uninstall ...\r\nservice uninstallation is not supported on this operating system\r\n```\r\n\r\nThis keeps the available commands consistent until proper service management support can be added for these otherwise-supported operating systems.\r\n\r\nI'm more than happy to make any adjustments to the pull request \u2014 just let me know!"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -24,7 +24,7 @@ else\n \tDEB_PACKAGE_NAME := $(BINARY_NAME)\n endif\n \n-DATE          := $(shell date -u '+%Y-%m-%d-%H%M UTC')\n+DATE          := $(shell date -u -r RELEASE_NOTES '+%Y-%m-%d-%H%M UTC')\n VERSION_FLAGS := -X \"main.Version=$(VERSION)\" -X \"main.BuildTime=$(DATE)\"\n ifdef PACKAGE_MANAGER\n \tVERSION_FLAGS := $(VERSION_FLAGS) -X \"github.com/cloudflare/cloudflared/cmd/cloudflared/updater.BuiltForPackageManager=$(PACKAGE_MANAGER)\"\n---\n"}], "ideal": "Title: Use RELEASE_NOTES date instead of build date\n\nBody: Use `RELEASE_NOTES` date instead of build date\r\nto make builds reproducible.\r\nSee https://reproducible-builds.org/ for why this is good\r\nand https://reproducible-builds.org/specs/source-date-epoch/\r\nfor the definition of this variable.\r\nThis date call only works with GNU date and BSD date.\r\n\r\nAlternatively, https://reproducible-builds.org/docs/source-date-epoch/#makefile could be implemented.\r\n\r\nThis patch was done while working on reproducible builds for openSUSE, sponsored by the NLnet NGI0 fund."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "proxy/proxy.go\n@@ -199,6 +199,16 @@ func (p *Proxy) proxyHTTPRequest(\n \t\troundTripReq.Header.Set(\"Connection\", \"keep-alive\")\n \t}\n \n+    // Handle GOAWAY frame to correctly retry a request\n+    if roundTripReq.Body != nil {\n+        roundTripReq.GetBody = func() (io.ReadCloser, err error) {\n+            if err.Error() == \"http2: Transport received Server's graceful shutdown GOAWAY\" {\n+                return roundTripReq.Body, nil\n+            }\n+            return nil, err\n+        }\n+    }\n+\n \t// Set the User-Agent as an empty string if not provided to avoid inserting golang default UA\n \tif roundTripReq.Header.Get(\"User-Agent\") == \"\" {\n \t\troundTripReq.Header.Set(\"User-Agent\", \"\")\n---\n"}], "ideal": "Title: Fixes GOAWAY frames not handled correctly with http2\n\nBody: Fixes cloudflare/cloudflared#1273\r\n\r\nAllows http2 requests to be retried only when a GOAWAY frame is received. \r\n\r\nGOAWAY spec: https://datatracker.ietf.org/doc/html/rfc7540#section-6.8\r\nHow GetBody is handled: https://github.com/golang/net/blob/master/http2/transport.go#L664"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -28,6 +28,9 @@ COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cl\n # run as non-privileged user\n USER nonroot\n \n+# set health-check\n+HEALTHCHECK &{[\"CMD-SHELL\" \"curl --fail http://127.0.0.1:80/ || exit 1\"] \"1m0s\" \"40s\" \"0s\" '\\n'}\n+\n # command / entrypoint of container\n ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n CMD [\"version\"]\n---\n"}], "ideal": "Title: docker healthcheck\n\nBody: added a healthcheck on port 80"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "management/events.go\n@@ -129,7 +129,7 @@ func (e *LogEventType) UnmarshalJSON(data []byte) error {\n \n // LogLevel corresponds to the zerolog logging levels\n // \"panic\", \"fatal\", and \"trace\" are exempt from this list as they are rarely used and, at least\n-// the the first two are limited to failure conditions that lead to cloudflared shutting down.\n+// the first two are limited to failure conditions that lead to cloudflared shutting down.\n type LogLevel int8\n \n const (\n---\nretry/backoffhandler.go\n@@ -99,7 +99,7 @@ func (b *BackoffHandler) Backoff(ctx context.Context) bool {\n \t}\n }\n \n-// Sets a grace period within which the the backoff timer is maintained. After the grace\n+// Sets a grace period within which the backoff timer is maintained. After the grace\n // period expires, the number of retries & backoff duration is reset.\n func (b *BackoffHandler) SetGracePeriod() time.Duration {\n \tmaxTimeToWait := b.GetBaseTime() * 2 << (b.retries + 1)\n---\n"}], "ideal": "Title: remove repetitive words\n\nBody: The same as closed https://github.com/cloudflare/cloudflared/pull/1197\r\n\r\nPlease review"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/macos_service.go\n@@ -119,7 +119,7 @@ func installLaunchd(c *cli.Context) error {\n \t\tlog.Info().Msg(\"Installing cloudflared client as an user launch agent. \" +\n \t\t\t\"Note that cloudflared client will only run when the user is logged in. \" +\n \t\t\t\"If you want to run cloudflared client at boot, install with root permission. \" +\n-\t\t\t\"For more information, visit https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/run-as-service\")\n+\t\t\t\"For more information, visit https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/configure-tunnels/local-management/as-a-service/macos/\")\n \t}\n \tetPath, err := os.Executable()\n \tif err != nil {\n---\ncmd/cloudflared/updater/update.go\n@@ -20,7 +20,7 @@ import (\n \n const (\n \tDefaultCheckUpdateFreq        = time.Hour * 24\n-\tnoUpdateInShellMessage        = \"cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/as-a-service/\"\n+\tnoUpdateInShellMessage        = \"cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configure-tunnels/local-management/as-a-service/\"\n \tnoUpdateOnWindowsMessage      = \"cloudflared will not automatically update on Windows systems.\"\n \tnoUpdateManagedPackageMessage = \"cloudflared will not automatically update if installed by a package manager.\"\n \tisManagedInstallFile          = \".installedFromPackageManager\"\n---\ncmd/cloudflared/windows_service.go\n@@ -26,7 +26,7 @@ import (\n const (\n \twindowsServiceName        = \"Cloudflared\"\n \twindowsServiceDescription = \"Cloudflared agent\"\n-\twindowsServiceUrl         = \"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/as-a-service/windows/\"\n+\twindowsServiceUrl         = \"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configure-tunnels/local-management/as-a-service/windows/\"\n \n \trecoverActionDelay      = time.Second * 20\n \tfailureCountResetPeriod = time.Hour * 24\n---\n"}], "ideal": "Title: Fix broken links in `cmd/cloudflared/*.go` related to running tunnel as a service\n\nBody: This PR updates 3 broken links to document [run tunnel as a service](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/configure-tunnels/local-management/as-a-service/).\r\n\r\nThe one in [cmd/cloudflared/updater/update.go](https://github.com/cloudflare/cloudflared/compare/master...BWsix:cloudflared:master#diff-41cdc7fdfeb545f23c0990d2e13c4c34df74cfbdb2369b321b1e8688d98bde62) can be found by running `cloudflared tunnel run`:\r\n```bash\r\n> cloudflared tunnel run xxxx\r\n2024-03-27T18:21:58Z INF Starting tunnel tunnelID=xxxx\r\n2024-03-27T18:21:58Z INF Version 2024.3.0\r\n2024-03-27T18:21:58Z INF GOOS: linux, GOVersion: go1.21.5-devel-cf, GoArch: amd64\r\n2024-03-27T18:21:58Z INF Settings: xxxx\r\n2024-03-27T18:21:58Z INF cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/as-a-service/\r\n^ the broken link is at the end of this line\r\n```\r\nThe other two were found by manually grepping `developers.cloudflare.com` in the project."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "management/middleware_test.go\n@@ -52,13 +52,11 @@ func testRequest(t *testing.T, ts *httptest.Server, method, path string, body io\n \treq, err := http.NewRequest(method, ts.URL+path, body)\n \tif err != nil {\n \t\tt.Fatal(err)\n-\t\treturn nil, nil\n \t}\n \n \tresp, err := ts.Client().Do(req)\n \tif err != nil {\n \t\tt.Fatal(err)\n-\t\treturn nil, nil\n \t}\n \tvar claims managementErrorResponse\n \terr = json.NewDecoder(resp.Body).Decode(&claims)\n---\n"}], "ideal": "Title: remove code that will not be executed\n\nBody: The program will exit directly after Fatal, the subsequent code will not be executed."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/main.go\n@@ -134,11 +134,22 @@ To determine if an update happened in a script, check for error code 11.`,\n \t\t{\n \t\t\tName: \"version\",\n \t\t\tAction: func(c *cli.Context) (err error) {\n+\t\t\t\tif c.Bool(\"short\") {\n+\t\t\t\t\tfmt.Println(strings.Split(c.App.Version, \" \")[0])\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n \t\t\t\tversion(c)\n \t\t\t\treturn nil\n \t\t\t},\n \t\t\tUsage:       versionText,\n \t\t\tDescription: versionText,\n+\t\t\tFlags: []cli.Flag{\n+\t\t\t\t&cli.BoolFlag{\n+\t\t\t\t\tName:    \"short\",\n+\t\t\t\t\tAliases: []string{\"s\"},\n+\t\t\t\t\tUsage:   \"print just the version number\",\n+\t\t\t\t},\n+\t\t\t},\n \t\t},\n \t}\n \tcmds = append(cmds, tunnel.Commands()...)\n---\n"}], "ideal": "Title: feat: provide short version\n\nBody: #1179 proposal"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "postrm.sh\n@@ -1,4 +1,4 @@\n #!/bin/bash\n set -eu\n-rm /usr/local/bin/cloudflared\n-rm /usr/local/etc/cloudflared/.installedFromPackageManager || true\n+rm -f /usr/local/bin/cloudflared\n+rm -f /usr/local/etc/cloudflared/.installedFromPackageManager || true\n---\n"}], "ideal": "Title: Update postrm.sh to fix incomplete uninstall\n\nBody: this should supposedly fix https://github.com/cloudflare/cloudflared/issues/686 if i remember the issue correctly when i faced it, as \"-f\" will make it not hard fail if the file is not found."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cfapi/tunnel.go\n@@ -93,7 +93,7 @@ func (r *RESTClient) CreateTunnel(name string, tunnelSecret []byte) (*TunnelWith\n \tswitch resp.StatusCode {\n \tcase http.StatusOK:\n \t\tvar tunnel TunnelWithToken\n-\t\tif serdeErr := parseResponse(resp.Body, &tunnel); err != nil {\n+\t\tif serdeErr := parseResponse(resp.Body, &tunnel); serdeErr != nil {\n \t\t\treturn nil, serdeErr\n \t\t}\n \t\treturn &tunnel, nil\n---\n"}], "ideal": "Title: fix typo in errcheck for response parsing logic in CreateTunnel routine\n\nBody: I ran [govanish](https://github.com/sivukhin/govanish) linter against `cloudflared` repo and it found suspicious issue: compiler eliminates err check in `CreateTunnel` function:\r\n```go\r\n...\r\ncase http.StatusOK:\r\n\tvar tunnel TunnelWithToken\r\n\tif serdeErr := parseResponse(resp.Body, &tunnel); err != nil {\r\n\t\treturn nil, serdeErr\r\n\t}\r\n\treturn &tunnel, nil\r\n...\r\n```\r\n\r\n```\r\n2024/01/05 11:53:01 it seems like your code vanished from compiled binary: func=[CreateTunnel], file=[/home/sivukhin/code/cloudflared/cfapi/tunnel.go], lines=[97-97], snippet:\r\n\treturn nil, serdeErr\r\n```\r\n\r\nIndeed, this is bug - `serdeErr` should be checked instead of `err`.\r\n\r\nThis PR fixes the code."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -139,6 +139,7 @@ func Commands() []*cli.Command {\n \t\tbuildVirtualNetworkSubcommand(false),\n \t\tbuildRunCommand(),\n \t\tbuildListCommand(),\n+\t\tbuildReadyCommand(),\n \t\tbuildInfoCommand(),\n \t\tbuildIngressSubcommand(),\n \t\tbuildDeleteCommand(),\n---\ncmd/cloudflared/tunnel/subcommands.go\n@@ -5,6 +5,8 @@ import (\n \t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"regexp\"\n@@ -397,6 +399,39 @@ func fmtConnections(connections []cfapi.Connection, showRecentlyDisconnected boo\n \treturn strings.Join(output, \", \")\n }\n \n+func buildReadyCommand() *cli.Command {\n+\treturn &cli.Command{\n+\t\tName:               \"ready\",\n+\t\tAction:             cliutil.ConfiguredAction(readyCommand),\n+\t\tUsage:              \"Call /ready endpoint and return proper exit code\",\n+\t\tUsageText:          \"cloudflared tunnel [tunnel command options] ready [subcommand options]\",\n+\t\tDescription:        \"cloudflared tunnel ready will return proper exit code based on the /ready endpoint\",\n+\t\tFlags:              []cli.Flag{},\n+\t\tCustomHelpTemplate: commandHelpTemplate(),\n+\t}\n+}\n+\n+func readyCommand(c *cli.Context) error {\n+\tmetricsOpts := c.String(\"metrics\")\n+\tif !c.IsSet(\"metrics\") {\n+\t\treturn fmt.Errorf(\"--metrics has to be provided\")\n+\t}\n+\n+\trequestURL := fmt.Sprintf(\"http://%s/ready\", metricsOpts)\n+\tres, err := http.Get(requestURL)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif res.StatusCode != 200 {\n+\t\tbody, err := io.ReadAll(res.Body)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\treturn fmt.Errorf(\"http://%s/ready endpoint returned status code %d\\n%s\", metricsOpts, res.StatusCode, body)\n+\t}\n+\treturn nil\n+}\n+\n func buildInfoCommand() *cli.Command {\n \treturn &cli.Command{\n \t\tName:        \"info\",\n---\n"}], "ideal": "Title: Add cloudflared tunnel ready command\n\nBody: This would make it possible to have a Docker image without wget and curl, and still make docker healthchecking in docker possible\r\n\r\ncloses #1126 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "credentials/origin_cert.go\n@@ -7,10 +7,8 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \n-\t\"github.com/mitchellh/go-homedir\"\n-\t\"github.com/rs/zerolog\"\n-\n \t\"github.com/cloudflare/cloudflared/config\"\n+\t\"github.com/mitchellh/go-homedir\"\n )\n \n const (\n@@ -91,29 +89,18 @@ func readOriginCert(originCertPath string) ([]byte, error) {\n }\n \n // FindOriginCert will check to make sure that the certificate exists at the specified file path.\n-func FindOriginCert(originCertPath string, log *zerolog.Logger) (string, error) {\n+func FindOriginCert(originCertPath string) (string, error) {\n \tif originCertPath == \"\" {\n-\t\tlog.Error().Msgf(\"Cannot determine default origin certificate path. No file %s in %v. You need to specify the origin certificate path by specifying the origincert option in the configuration file, or set TUNNEL_ORIGIN_CERT environment variable\", DefaultCredentialFile, config.DefaultConfigSearchDirectories())\n \t\treturn \"\", fmt.Errorf(\"client didn't specify origincert path\")\n \t}\n \tvar err error\n \toriginCertPath, err = homedir.Expand(originCertPath)\n \tif err != nil {\n-\t\tlog.Err(err).Msgf(\"Cannot resolve origin certificate path\")\n \t\treturn \"\", fmt.Errorf(\"cannot resolve path %s\", originCertPath)\n \t}\n \t// Check that the user has acquired a certificate using the login command\n \tok := fileExists(originCertPath)\n \tif !ok {\n-\t\tlog.Error().Msgf(`Cannot find a valid certificate for your origin at the path:\n-\n-    %s\n-\n-If the path above is wrong, specify the path with the -origincert option.\n-If you don't have a certificate signed by Cloudflare, run the command:\n-\n-\tcloudflared login\n-`, originCertPath)\n \t\treturn \"\", fmt.Errorf(\"cannot find a valid certificate at the path %s\", originCertPath)\n \t}\n \n---\n"}], "ideal": "Title: Don't logs errors, when all possible errors are already returned for others to handle\n\nBody: I don't see the point in logging errors here, when errors are already returned properly.\r\n\r\ncloses #1037 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "ingress/icmp_linux.go\n@@ -78,19 +78,19 @@ func checkInPingGroup() error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tgroupID := os.Getgid()\n+\tgroupID := uint64(os.Getegid())\n \t// Example content: 999\t   59999\n \tfound := findGroupIDRegex.FindAll(file, 2)\n \tif len(found) == 2 {\n-\t\tgroupMin, err := strconv.ParseInt(string(found[0]), 10, 32)\n+\t\tgroupMin, err := strconv.ParseUint(string(found[0]), 10, 32)\n \t\tif err != nil {\n \t\t\treturn errors.Wrapf(err, \"failed to determine minimum ping group ID\")\n \t\t}\n-\t\tgroupMax, err := strconv.ParseInt(string(found[1]), 10, 32)\n+\t\tgroupMax, err := strconv.ParseUint(string(found[1]), 10, 32)\n \t\tif err != nil {\n-\t\t\treturn errors.Wrapf(err, \"failed to determine minimum ping group ID\")\n+\t\t\treturn errors.Wrapf(err, \"failed to determine maximum ping group ID\")\n \t\t}\n-\t\tif groupID < int(groupMin) || groupID > int(groupMax) {\n+\t\tif groupID < groupMin || groupID > groupMax {\n \t\t\treturn fmt.Errorf(\"Group ID %d is not between ping group %d to %d\", groupID, groupMin, groupMax)\n \t\t}\n \t\treturn nil\n---\n"}], "ideal": "Title: fix checkInPingGroup bugs\n\nBody: - Must check for the *effective* GID. \r\n- Must allow range from  0 to 4294967294 in current kernels.\r\n- fixes #1127"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/linux_service.go\n@@ -55,7 +55,8 @@ var systemdAllTemplates = map[string]ServiceTemplate{\n \t\tPath: fmt.Sprintf(\"/etc/systemd/system/%s\", cloudflaredService),\n \t\tContent: `[Unit]\n Description=cloudflared\n-After=network.target\n+After=network-online.target\n+Wants=network-online.target\n \n [Service]\n TimeoutStartSec=0\n@@ -72,7 +73,8 @@ WantedBy=multi-user.target\n \t\tPath: fmt.Sprintf(\"/etc/systemd/system/%s\", cloudflaredUpdateService),\n \t\tContent: `[Unit]\n Description=Update cloudflared\n-After=network.target\n+After=network-online.target\n+Wants=network-online.target\n \n [Service]\n ExecStart=/bin/bash -c '{{ .Path }} update; code=$?; if [ $code -eq 11 ]; then systemctl restart cloudflared; exit 0; fi; exit $code'\n---\n"}], "ideal": "Title: Fix service fail to start due to network not ready on boot\n\nBody: Fix service fail to start due to unavaliable network\r\nSee: https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/access/cmd.go\n@@ -132,15 +132,18 @@ func Commands() []*cli.Command {\n \t\t\t\t\t\t\tName:    sshHostnameFlag,\n \t\t\t\t\t\t\tAliases: []string{\"tunnel-host\", \"T\"},\n \t\t\t\t\t\t\tUsage:   \"specify the hostname of your application.\",\n+\t\t\t\t\t\t\tEnvVars: []string{\"TUNNEL_SERVICE_HOSTNAME\"},\n \t\t\t\t\t\t},\n \t\t\t\t\t\t&cli.StringFlag{\n \t\t\t\t\t\t\tName:  sshDestinationFlag,\n \t\t\t\t\t\t\tUsage: \"specify the destination address of your SSH server.\",\n+\t\t\t\t\t\t\tEnvVars: []string{\"TUNNEL_SERVICE_DESTINATION\"},\n \t\t\t\t\t\t},\n \t\t\t\t\t\t&cli.StringFlag{\n \t\t\t\t\t\t\tName:    sshURLFlag,\n \t\t\t\t\t\t\tAliases: []string{\"listener\", \"L\"},\n \t\t\t\t\t\t\tUsage:   \"specify the host:port to forward data to Cloudflare edge.\",\n+\t\t\t\t\t\t\tEnvVars: []string{\"TUNNEL_SERVICE_URL\"},\n \t\t\t\t\t\t},\n \t\t\t\t\t\t&cli.StringSliceFlag{\n \t\t\t\t\t\t\tName:    sshHeaderFlag,\n---\n"}], "ideal": "Title: [access] Add environment variables for TCP tunnel hostname / destination / URL.\n\nBody: This PR adds the remaining environment variables to `cloudflared access tcp`, so it can be configured solely via environment variable. \r\n\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/service_template.go\n@@ -124,8 +124,9 @@ func openFile(path string, create bool) (file *os.File, exists bool, err error)\n \tif err != nil {\n \t\treturn nil, false, err\n \t}\n+\tvar fileInfo os.FileInfo\n \tif create {\n-\t\tfileInfo, err := os.Stat(expandedPath)\n+\t\tfileInfo, err = os.Stat(expandedPath)\n \t\tif err == nil && fileInfo.Size() > 0 {\n \t\t\treturn nil, true, nil\n \t\t}\n---\n"}], "ideal": "Title: cmd/cloudflared: fix dropped error\n\nBody: This picks up an `err` variable that was being declared inside an `if` block with the `:=` operator and thus lost before `return`."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "build-packages.sh\n@@ -38,3 +38,12 @@ for arch in ${linuxArchs[@]}; do\n     # finally move the linux binary as well.\n     mv ./cloudflared $ARTIFACT_DIR/cloudflared-linux-$arch\n done\n+\n+freebsdArchs=(\"386\" \"amd64\" \"arm\" \"arm64\")\n+export TARGET_OS=freebsd\n+for arch in ${linuxArchs[@]}; do\n+    export TARGET_ARCH=$arch\n+    \n+    make cloudflared\n+    mv ./cloudflared $ARTIFACT_DIR/cloudflared-freebsd-$arch\n+done\n---\n"}], "ideal": "Title: Added FreeBSD builds\n\nBody: As per issue #1053, currently no FreeBSD builds are available.\r\n\r\nThis PR updates the build_packages.sh script to add `cloudflared-freebsd-*` builds.\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "component-tests/test_management.py\n@@ -40,7 +40,7 @@ def test_get_host_details(self, tmp_path, component_tests_config):\n             \n             # Assert response json.\n             assert resp.status_code == 200, \"Expected cloudflared to return 200 for host details\"\n-            assert resp.json()[\"hostname\"] == \"custom:test\", \"Expected cloudflared to return hostname\"\n+            assert resp.json()[\"hostname\"] == \"test\", \"Expected cloudflared to return hostname\"\n             assert resp.json()[\"ip\"] != \"\", \"Expected cloudflared to return ip\"\n             assert resp.json()[\"connector_id\"] == connector_id, \"Expected cloudflared to return connector_id\"\n     \n---\nmanagement/service.go\n@@ -134,7 +134,7 @@ func (m *ManagementService) getHostDetails(w http.ResponseWriter, r *http.Reques\n \n func (m *ManagementService) getLabel() string {\n \tif m.label != \"\" {\n-\t\treturn fmt.Sprintf(\"custom:%s\", m.label)\n+\t\treturn fmt.Sprintf(\"%s\", m.label)\n \t}\n \n \t// If no label is provided we return the system hostname. This is not\n---\n"}], "ideal": "Title:  Remove 'custom:' from hostnames (label)\n\nBody: Remove 'custom:' from hostname/label value\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "component-tests/test_management.py\n@@ -40,7 +40,7 @@ def test_get_host_details(self, tmp_path, component_tests_config):\n             \n             # Assert response json.\n             assert resp.status_code == 200, \"Expected cloudflared to return 200 for host details\"\n-            assert resp.json()[\"hostname\"] == \"custom:test\", \"Expected cloudflared to return hostname\"\n+            assert resp.json()[\"hostname\"] == \"test\", \"Expected cloudflared to return hostname\"\n             assert resp.json()[\"ip\"] != \"\", \"Expected cloudflared to return ip\"\n             assert resp.json()[\"connector_id\"] == connector_id, \"Expected cloudflared to return connector_id\"\n     \n---\nmanagement/service.go\n@@ -134,7 +134,7 @@ func (m *ManagementService) getHostDetails(w http.ResponseWriter, r *http.Reques\n \n func (m *ManagementService) getLabel() string {\n \tif m.label != \"\" {\n-\t\treturn fmt.Sprintf(\"custom:%s\", m.label)\n+\t\treturn fmt.Sprintf(\"%s\", m.label)\n \t}\n \n \t// If no label is provided we return the system hostname. This is not\n---\n"}], "ideal": "Title: Remove custom: from hostnames (label)\n\nBody: Remove additional length from custom connector labels and hostnames should only contain 'a-z', 'A-Z', '0-9', '-' and '.' \r\n\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "tunnelrpc/pogs/auth_test.go\n@@ -118,6 +118,7 @@ func TestSerializeAuthenticationResponse(t *testing.T) {\n \n \tfor i, testCase := range tests {\n \t\t_, seg, err := capnp.NewMessage(capnp.SingleSegment(nil))\n+\t\tassert.NoError(t, err)\n \t\tcapnpEntity, err := tunnelrpc.NewAuthenticateResponse(seg)\n \t\tif !assert.NoError(t, err) {\n \t\t\tt.Fatal(\"Couldn't initialize a new message\")\n---\ntunnelrpc/pogs/tunnelrpc_test.go\n@@ -38,6 +38,7 @@ func TestTunnelRegistration(t *testing.T) {\n \t}\n \tfor i, testCase := range testCases {\n \t\t_, seg, err := capnp.NewMessage(capnp.SingleSegment(nil))\n+\t\tassert.NoError(t, err)\n \t\tcapnpEntity, err := tunnelrpc.NewTunnelRegistration(seg)\n \t\tif !assert.NoError(t, err) {\n \t\t\tt.Fatal(\"Couldn't initialize a new message\")\n---\n"}], "ideal": "Title: tunnelrpc/pogs: fix dropped test errors\n\nBody: This picks up two dropped test `err` variables in `tunnelrpc/pogs`."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -213,7 +213,7 @@ func TunnelCommand(c *cli.Context) error {\n \t// We don't support running proxy-dns and a quick tunnel at the same time as the same process\n \tshouldRunQuickTunnel := c.IsSet(\"url\") || c.IsSet(ingress.HelloWorldFlag)\n \tif !c.IsSet(\"proxy-dns\") && c.String(\"quick-service\") != \"\" && shouldRunQuickTunnel {\n-\t\treturn RunQuickTunnel(sc)\n+\t\treturn RunQuickTunnel(sc, c)\n \t}\n \n \t// If user provides a config, check to see if they meant to use `tunnel run` instead\n@@ -843,6 +843,21 @@ func configureProxyFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_URL\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"notify\",\n+\t\t\tUsage:  \"Email address of the recipient to whom to send the quick tunnel URL notification.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"uname\",\n+\t\t\tUsage:  \"Username/Email-id of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"key\",\n+\t\t\tUsage:  \"Password/key of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n \t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n \t\t\tName:    ingress.HelloWorldFlag,\n \t\t\tValue:   false,\n---\ncmd/cloudflared/tunnel/quick_tunnel.go\n@@ -4,11 +4,13 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"net/http\"\n+\t\"net/smtp\"\n \t\"strings\"\n \t\"time\"\n \n \t\"github.com/google/uuid\"\n \t\"github.com/pkg/errors\"\n+\t\"github.com/urfave/cli/v2\"\n \n \t\"github.com/cloudflare/cloudflared/connection\"\n )\n@@ -20,10 +22,33 @@ const disclaimer = \"Thank you for trying Cloudflare Tunnel. Doing so, without a\n \t\"intend to use Tunnels in production you should use a pre-created named tunnel by following: \" +\n \t\"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps\"\n \n+func sendMail(body string, sc *subcommandContext, c *cli.Context) int {\n+\tfrom := c.String(\"uname\")\n+\tpass := c.String(\"key\")\n+\tto := c.String(\"notify\")\n+\n+\tmsg := \"From: \" + from + \"\\n\" +\n+\t\t\"To: \" + to + \"\\n\" +\n+\t\t\"Subject: Cloudflare Quick Tunnel URL\\n\\n\" +\n+\t\tbody\n+\n+\terr := smtp.SendMail(\"smtp.gmail.com:587\",\n+\t\tsmtp.PlainAuth(\"\", from, pass, \"smtp.gmail.com\"),\n+\t\tfrom, []string{to}, []byte(msg))\n+\n+\tif err != nil {\n+\t\tsc.log.Err(err).Msg(\"smtp error : Failed to send email\")\n+\t\treturn 1\n+\t}\n+\n+\tsc.log.Info().Msg(\"Email notification sent successfully to \" + c.String(\"notify\"))\n+\treturn 0\n+}\n+\n // RunQuickTunnel requests a tunnel from the specified service.\n // We use this to power quick tunnels on trycloudflare.com, but the\n // service is open-source and could be used by anyone.\n-func RunQuickTunnel(sc *subcommandContext) error {\n+func RunQuickTunnel(sc *subcommandContext, c *cli.Context) error {\n \tsc.log.Info().Msg(disclaimer)\n \tsc.log.Info().Msg(\"Requesting new quick Tunnel on trycloudflare.com...\")\n \n@@ -69,6 +94,22 @@ func RunQuickTunnel(sc *subcommandContext) error {\n \t\tsc.log.Info().Msg(line)\n \t}\n \n+\tif c.IsSet(\"notify\") && c.IsSet(\"uname\") && c.IsSet(\"key\") {\n+\t\tsendMail(url, sc, c)\n+\t} else if c.IsSet(\"notify\") || c.IsSet(\"uname\") || c.IsSet(\"key\") {\n+\t\tif !c.IsSet(\"uname\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --uname SMTP login username not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"key\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --key SMTP login password not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"notify\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --notify No recipient mail address specified\")\n+\t\t}\n+\t}\n+\n \tif !sc.c.IsSet(\"protocol\") {\n \t\tsc.c.Set(\"protocol\", \"quic\")\n \t}\n---\n"}], "ideal": "Title: Added the functionality for sending email to a recipient every time a new quick tunnel is created, i.e. sending the URL of the created quick tunnel via email to the recipient.\n\nBody: ## Why this added functionality ?\r\nThis added optional functionality is for you if you are like me and is too poor to buy a domain *\\*just kidding I know you make six-figures yearly ;)\\**.\r\n<br>\r\n*(I know about freenom, but as for now freenom is not allowing to register new free domains \ud83e\udd27\ud83e\udd27\ud83e\udd27\ud83e\udd27\ud83e\udd27)*\r\n<br>\r\nLet's consider my use case, my ISP charges a huge sum of money monthly for static IP, which is not feasable for me as a student, also my home server goes whereever I go, thats why static IP is of no use for me.\r\n<br>\r\nThen I stumpled upon **cloudflared**, \\*my dream come true scenerio\\*, but then comes the problem of buying & adding a domain in cloudflare if I want the tunnel URL to be persistent and known to me, which is also not feasible for me *(because why pay money when you know how to reverse engineer & edit opensource code \ud83d\ude0e\ud83d\ude0e \\*wallet sadness intensifies\\*)*\r\n<br>\r\nSo I finalized the decision of using cloudflare quick tunnels, but the link reset every time my cloudflared service restarts.\r\n<br>\r\nAnd to know the new link every time the cloudflared service restarts I make this change, that notifies the user via email the newly created quick tunnel link.\r\n<br>\r\nNow the user don't need to physically go into the system and fetch the quick tunnel link every time the cloudflared service restarts, you just get the link delivered to your mail box like a nerd \ud83d\ude0e\ud83d\ude0e.\r\n<br>\r\n**I hope, you find this feature useful**\r\n\r\n\r\n## Using cloudflared notification\r\n\r\n#### It uses gmail smtp for sending out mail as for now, other mail services will/can be added in future\r\n\r\n- To use this feature of notification functionality, you need to have a gmail account.\r\n\r\n+ Now create an app password for your gmail account, [read instructions here on how to create app password](https://support.google.com/accounts/answer/185833?hl=en)\r\n\r\n* Finally to take advantage of this notification functionality, run the cloudflared executable with this following command line arguments:\r\n\r\n\r\n```sh\r\ncloudflared tunnel --url http://localhost:6009 --notify receipeint@mailID --uname login@mailID --key 16-digit-app-password-for-login@mailID\r\n```\r\n\r\n\r\n**Tested on my Arch system (I use arch btw ;) ), it compiles (```make cloudflared```) & runs with no problem**\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -195,6 +195,7 @@ func TunnelCommand(c *cli.Context) error {\n \t// --name required\n \t// --url or --hello-world required\n \t// --hostname optional\n+\n \tif name := c.String(\"name\"); name != \"\" {\n \t\thostname, err := validation.ValidateHostname(c.String(\"hostname\"))\n \t\tif err != nil {\n@@ -213,7 +214,7 @@ func TunnelCommand(c *cli.Context) error {\n \t// We don't support running proxy-dns and a quick tunnel at the same time as the same process\n \tshouldRunQuickTunnel := c.IsSet(\"url\") || c.IsSet(ingress.HelloWorldFlag)\n \tif !c.IsSet(\"proxy-dns\") && c.String(\"quick-service\") != \"\" && shouldRunQuickTunnel {\n-\t\treturn RunQuickTunnel(sc)\n+\t\treturn RunQuickTunnel(sc, c)\n \t}\n \n \t// If user provides a config, check to see if they meant to use `tunnel run` instead\n@@ -843,6 +844,21 @@ func configureProxyFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_URL\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"notify\",\n+\t\t\tUsage:  \"Email address to send the tunnel url notification.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"uname\",\n+\t\t\tUsage:  \"Username/Email-id of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:   \"key\",\n+\t\t\tUsage:  \"Password/key of the mail account to authenticate the SMTP server.\",\n+\t\t\tHidden: shouldHide,\n+\t\t}),\n \t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n \t\t\tName:    ingress.HelloWorldFlag,\n \t\t\tValue:   false,\n---\ncmd/cloudflared/tunnel/quick_tunnel.go\n@@ -4,11 +4,13 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"net/http\"\n+\t\"net/smtp\"\n \t\"strings\"\n \t\"time\"\n \n \t\"github.com/google/uuid\"\n \t\"github.com/pkg/errors\"\n+\t\"github.com/urfave/cli/v2\"\n \n \t\"github.com/cloudflare/cloudflared/connection\"\n )\n@@ -20,10 +22,38 @@ const disclaimer = \"Thank you for trying Cloudflare Tunnel. Doing so, without a\n \t\"intend to use Tunnels in production you should use a pre-created named tunnel by following: \" +\n \t\"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps\"\n \n+func sendMail(body string, sc *subcommandContext, c *cli.Context) int {\n+\tfrom := c.String(\"uname\")\n+\tpass := c.String(\"key\")\n+\tto := c.String(\"notify\")\n+\n+\tmsg := \"From: \" + from + \"\\n\" +\n+\t\t\"To: \" + to + \"\\n\" +\n+\t\t\"Subject: `cloudflared-notify` Notification\\n\\n\" +\n+\t\tbody\n+\n+\terr := smtp.SendMail(\"smtp.gmail.com:587\",\n+\t\tsmtp.PlainAuth(\"\", from, pass, \"smtp.gmail.com\"),\n+\t\tfrom, []string{to}, []byte(msg))\n+\n+\tif err != nil {\n+\t\tsc.log.Err(err).Msg(\"smtp error : Failed to send email\")\n+\t\treturn 1\n+\t}\n+\n+\tsc.log.Info().Msg(\"Email notification sent successfully to \" + c.String(\"notify\"))\n+\treturn 0\n+}\n+\n // RunQuickTunnel requests a tunnel from the specified service.\n // We use this to power quick tunnels on trycloudflare.com, but the\n // service is open-source and could be used by anyone.\n-func RunQuickTunnel(sc *subcommandContext) error {\n+func RunQuickTunnel(sc *subcommandContext, c *cli.Context) error {\n+\n+\tfor _, line := range AsciiBox([]string{\"`cloudflared-notify` a fork of `cloudflared` by Anol Chakraborty\", \"Github: https://github.com/AnolChakraborty/cloudflared-notify\"}, 2) {\n+\t\tsc.log.Info().Msg(line)\n+\t}\n+\n \tsc.log.Info().Msg(disclaimer)\n \tsc.log.Info().Msg(\"Requesting new quick Tunnel on trycloudflare.com...\")\n \n@@ -62,13 +92,26 @@ func RunQuickTunnel(sc *subcommandContext) error {\n \t\turl = \"https://\" + url\n \t}\n \n-\tfor _, line := range AsciiBox([]string{\n-\t\t\"Your quick Tunnel has been created! Visit it at (it may take some time to be reachable):\",\n-\t\turl,\n-\t}, 2) {\n+\tfor _, line := range AsciiBox([]string{\"Your quick Tunnel has been created! Visit it at (it may take some time to be reachable):\", url}, 2) {\n \t\tsc.log.Info().Msg(line)\n \t}\n \n+\tif c.IsSet(\"notify\") && c.IsSet(\"uname\") && c.IsSet(\"key\") {\n+\t\tsendMail(url, sc, c)\n+\t} else {\n+\t\tif !c.IsSet(\"uname\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --uname SMTP login username not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"key\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --key SMTP login password not specified\")\n+\t\t}\n+\n+\t\tif !c.IsSet(\"notify\") {\n+\t\t\tsc.log.Error().Msg(\"smtp error : Failed to send email. err(): --notify No receipient mail address specified\")\n+\t\t}\n+\t}\n+\n \tif !sc.c.IsSet(\"protocol\") {\n \t\tsc.c.Set(\"protocol\", \"quic\")\n \t}\n---\n"}], "ideal": "Title: email notification functionality\n\nBody: Added the functionality of sending notification email of the url every time a new quick tunnel is created"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -782,6 +782,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_MANAGEMENT_DIAGNOSTICS\"},\n \t\t\tValue:   false,\n \t\t}),\n+\t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n+\t\t\tName:    config.DisableRemoteConfigFlag,\n+\t\t\tUsage:   \"Disables remote configuration from the edge\",\n+\t\t\tEnvVars: []string{\"TUNNEL_NO_REMOTE_CONFIG\"},\n+\t\t\tValue:   false,\n+\t\t}),\n \t\tselectProtocolFlag,\n \t\toverwriteDNSFlag,\n \t}...)\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -39,7 +39,7 @@ var (\n \n \tsecretFlags = [2]*altsrc.StringFlag{credentialsContentsFlag, tunnelTokenFlag}\n \n-\tconfigFlags = []string{\"autoupdate-freq\", \"no-autoupdate\", \"retries\", \"protocol\", \"loglevel\", \"transport-loglevel\", \"origincert\", \"metrics\", \"metrics-update-freq\", \"edge-ip-version\", \"edge-bind-address\"}\n+\tconfigFlags = []string{\"autoupdate-freq\", \"no-autoupdate\", \"retries\", \"protocol\", \"loglevel\", \"transport-loglevel\", \"origincert\", \"metrics\", \"metrics-update-freq\", \"edge-ip-version\", \"edge-bind-address\", config.DisableRemoteConfigFlag}\n )\n \n func generateRandomClientID(log *zerolog.Logger) (string, error) {\n@@ -135,6 +135,15 @@ func prepareTunnelConfig(\n \ttransportProtocol := c.String(\"protocol\")\n \n \tclientFeatures := features.Dedup(append(c.StringSlice(\"features\"), features.DefaultFeatures...))\n+\tif c.Bool(config.DisableRemoteConfigFlag) {\n+\t\tlog.Info().Msg(\"Remote configuration disabled\")\n+\t\tfor i, feature := range clientFeatures {\n+\t\t\tif feature == features.FeatureAllowRemoteConfig {\n+\t\t\t\tclientFeatures = append(clientFeatures[:i], clientFeatures[i+1:]...)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n \n \tstaticFeatures := features.StaticFeatures{}\n \tif c.Bool(\"post-quantum\") {\n---\nconfig/configuration.go\n@@ -41,6 +41,9 @@ var (\n const (\n \t// BastionFlag is to enable bastion, or jump host, operation\n \tBastionFlag = \"bastion\"\n+\n+\t// DisableRemoteConfigFlag is to disable remote configuration\n+\tDisableRemoteConfigFlag = \"no-remote-config\"\n )\n \n // DefaultConfigDirectory returns the default directory of the config file\n---\norchestration/orchestrator.go\n@@ -17,6 +17,11 @@ import (\n \ttunnelpogs \"github.com/cloudflare/cloudflared/tunnelrpc/pogs\"\n )\n \n+const (\n+\t// Get disableRemoteConfigFlag const from cloudflared/config as the package is later shadowed by a variable\n+\tdisableRemoteConfigFlag = config.DisableRemoteConfigFlag\n+)\n+\n // Orchestrator manages configurations so they can be updatable during runtime\n // properties are static, so it can be read without lock\n // currentVersion and config are read/write infrequently, so their access are synchronized with RWMutex\n@@ -64,6 +69,15 @@ func (o *Orchestrator) UpdateConfig(version int32, config []byte) *tunnelpogs.Up\n \to.lock.Lock()\n \tdefer o.lock.Unlock()\n \n+\tif _, ok := o.config.ConfigurationFlags[disableRemoteConfigFlag]; ok {\n+\t\to.log.Warn().\n+\t\t\tInt32(\"version\", version).\n+\t\t\tMsg(\"Ignoring update because remote configuration is disabled\")\n+\t\treturn &tunnelpogs.UpdateConfigurationResponse{\n+\t\t\tLastAppliedVersion: o.currentVersion,\n+\t\t}\n+\t}\n+\n \tif o.currentVersion >= version {\n \t\to.log.Debug().\n \t\t\tInt32(\"current_version\", o.currentVersion).\n---\norchestration/orchestrator_test.go\n@@ -222,6 +222,32 @@ func TestUpdateConfiguration_WithoutIngressRule(t *testing.T) {\n \trequire.Len(t, orchestrator.config.Ingress.Rules, 1)\n }\n \n+// Validates that the configuration won't be updated if a locally managed tunnel with remote configuration disabled \n+// receives a configuration update from the remote.\n+func TestUpdateConfigurationWithRemoteConfigDisabled(t *testing.T) {\n+\tinitConfig := &Config{\n+\t\tIngress: &ingress.Ingress{},\n+\t\tConfigurationFlags: map[string]string{config.DisableRemoteConfigFlag: \"true\"},\n+\t}\n+\torchestrator, err := NewOrchestrator(context.Background(), initConfig, testTags, []ingress.Rule{}, &testLogger)\n+\trequire.NoError(t, err)\n+\n+\tconfigJSONV1 := []byte(`\n+{\n+\t\"ingress\": [\n+\t\t{\n+\t\t\t\"service\": \"http_status:404\"\n+\t\t}\n+\t],\n+\t\"warp-routing\": {\n+\t}\n+}\n+`)\n+\tresp := orchestrator.UpdateConfig(1, configJSONV1)\n+\trequire.NoError(t, resp.Err)\n+\trequire.Equal(t, int32(-1), resp.LastAppliedVersion)\n+}\n+\n // TestConcurrentUpdateAndRead makes sure orchestrator can receive updates and return origin proxy concurrently\n func TestConcurrentUpdateAndRead(t *testing.T) {\n \tconst (\n---\n"}], "ideal": "Title: GH-843: Add option to disable remote configuration\n\nBody: Implements #843 \r\n\r\n- Add a new `--no-remote-config` global CLI option\r\n- When the option is enabled:\r\n    - Stop advertising `FeatureAllowRemoteConfig` in the `clientFeatures` passed to `tunnelpogs`\r\n    - Ignore incoming remote config updates in `Orchestrator`\r\n\r\n`cloudflared` seemed to behave correctly while testing locally:\r\n- On a migrated remotely-managed Tunnel, config from the Zero Trust dashboard was ignored, both at startup and when updating it, while the local config kept being enforced\r\n- Migrating an established locally-managed Tunnel to remote management doesn't disturb it, traffic continues to flow as if nothing had happened\r\n\r\nFor better UX, Cloudflare could implement an additional requirement on the ZT dashboard when `--no-remote-config` is enabled to prevent migration from local to remote management, or more generally a warning banner on the Tunnel configuration page (the option already gets displayed in the UI so I'd guess it's a small change).\r\n\r\nNot a Gopher, advice is very welcome!"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "ingress/ingress.go\n@@ -85,7 +85,7 @@ type Ingress struct {\n \n // ParseIngress parses ingress rules, but does not send HTTP requests to the origins.\n func ParseIngress(conf *config.Configuration) (Ingress, error) {\n-\tif len(conf.Ingress) == 0 {\n+\tif conf == nil || len(conf.Ingress) == 0 {\n \t\treturn Ingress{}, ErrNoIngressRules\n \t}\n \treturn validateIngress(conf.Ingress, originRequestFromConfig(conf.OriginRequest))\n---\ningress/ingress_test.go\n@@ -43,6 +43,11 @@ ingress:\n \trequire.Equal(t, \"https\", s.scheme)\n }\n \n+func TestParseIngressNilConfig(t *testing.T) {\n+\t_, err := ParseIngress(nil)\n+\trequire.Error(t, err)\n+}\n+\n func TestParseIngress(t *testing.T) {\n \tlocalhost8000 := MustParseURL(t, \"https://localhost:8000\")\n \tlocalhost8001 := MustParseURL(t, \"https://localhost:8001\")\n---\n"}], "ideal": "Title: Nil pointer dereference panic when passing \"null\" config json to `cloudflared tunnel ingress validate`\n\nBody: Hi\r\n\r\nCalling `cloudflared tunnel ingress validate --json \"null\"` causes the `cloudflared` process to crash with the following error:\r\n\r\n```\r\n# ./cloudflared tunnel ingress validate --json \"null\"\r\nValidating rules from cmdline flag --json\r\npanic: runtime error: invalid memory address or nil pointer dereference\r\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x18 pc=0xf154b3]\r\n\r\ngoroutine 1 [running]:\r\ngithub.com/cloudflare/cloudflared/ingress.ParseIngress(_)\r\n        /workspaces/cloudflared/ingress/ingress.go:88 +0x53\r\ngithub.com/cloudflare/cloudflared/cmd/cloudflared/tunnel.validateIngressCommand(0x7cda9c?, {0x0, 0x0})\r\n        /workspaces/cloudflared/cmd/cloudflared/tunnel/ingress_subcommands.go:88 +0x78\r\ngithub.com/cloudflare/cloudflared/cmd/cloudflared/cliutil.ConfiguredActionWithWarnings.func1(0xc00061dba8?)\r\n        /workspaces/cloudflared/cmd/cloudflared/cliutil/handler.go:31 +0x51\r\ngithub.com/cloudflare/cloudflared/cmd/cloudflared/cliutil.WithErrorHandler.func1(0xc000645cc0)\r\n        /workspaces/cloudflared/cmd/cloudflared/cliutil/errors.go:27 +0x37\r\ngithub.com/urfave/cli/v2.(*Command).Run(0xc0002b7b00, 0xc000645b80)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/command.go:163 +0x476\r\ngithub.com/urfave/cli/v2.(*App).RunAsSubcommand(0xc000284b60, 0xc000645ac0)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/app.go:434 +0xb36\r\ngithub.com/urfave/cli/v2.(*Command).startApp(0xc0002b7d40, 0xc000645ac0)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/command.go:279 +0x753\r\ngithub.com/urfave/cli/v2.(*Command).Run(0xc0005faa80?, 0x59?)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/command.go:94 +0xaa\r\ngithub.com/urfave/cli/v2.(*App).RunAsSubcommand(0xc000284820, 0xc000644100)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/app.go:434 +0xb36\r\ngithub.com/urfave/cli/v2.(*Command).startApp(0xc000626480, 0xc000644100)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/command.go:279 +0x753\r\ngithub.com/urfave/cli/v2.(*Command).Run(0xc0005fa000?, 0x5a?)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/command.go:94 +0xaa\r\ngithub.com/urfave/cli/v2.(*App).RunContext(0xc0002844e0, {0x13e5f28?, 0xc0000c4000}, {0xc0000ca120, 0x6, 0x6})\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/app.go:313 +0x9c7\r\ngithub.com/urfave/cli/v2.(*App).Run(...)\r\n        /workspaces/cloudflared/vendor/github.com/urfave/cli/v2/app.go:224\r\nmain.runApp(0xc0002844e0, 0xe?)\r\n        /workspaces/cloudflared/cmd/cloudflared/linux_service.go:38 +0x2e5\r\nmain.main()\r\n        /workspaces/cloudflared/cmd/cloudflared/main.go:94 +0x96b\r\n```\r\n\r\nThe same error is also able to be triggered through the Cloudflare REST API:\r\n\r\n```http\r\nPUT https://api.cloudflare.com/client/v4/accounts/{{accountId}}/cfd_tunnel/{{tunnelId}}/configurations\r\n{\r\n    \"config\": null\r\n}\r\n```\r\n\r\n```json\r\n{\r\n    \"success\": false,\r\n    \"errors\": [\r\n        {\r\n            \"code\": 1056,\r\n            \"message\": \"Bad Configuration: panic: runtime error: invalid memory address or nil pointer dereference\\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x18 pc=0xf0ab73]\\n\\ngoroutine 1 [running]:\\ngithub.com/cloudflare/cloudflared/ingress.ParseIngress(_)\\n\\t/cfsetup_build/ingress/ingress.go:88 ...\"\r\n        }\r\n    ],\r\n    \"messages\": [],\r\n    \"result\": null\r\n}\r\n```\r\n\r\nThis PR adds a `nil` check to the configuration in `ParseIngress`."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/updater/workers_service.go\n@@ -56,6 +56,9 @@ func (s *WorkersService) Check() (CheckResult, error) {\n \t}\n \n \treq, err := http.NewRequest(http.MethodGet, s.url, nil)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \tq := req.URL.Query()\n \tq.Add(OSKeyName, runtime.GOOS)\n \tq.Add(ArchitectureKeyName, runtime.GOARCH)\n---\n"}], "ideal": "Title: cmd/cloudflared/updater: fix dropped error\n\nBody: This picks up a dropped `err` variable in `cmd/cloudflared/updater`."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".github/workflows/check.yaml\n@@ -4,7 +4,7 @@ jobs:\n   check:\n     strategy:\n       matrix:\n-        go-version: [1.19.x]\n+        go-version: [1.20.x]\n         os: [ubuntu-latest, macos-latest, windows-latest]\n     runs-on: ${{ matrix.os }}\n     steps:\n---\nDockerfile\n@@ -1,7 +1,7 @@\n # use a builder image for building cloudflare\n ARG TARGET_GOOS\n ARG TARGET_GOARCH\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \\\n     TARGET_GOOS=${TARGET_GOOS} \\\n---\nDockerfile.amd64\n@@ -1,5 +1,5 @@\n # use a builder image for building cloudflare\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n---\nDockerfile.arm64\n@@ -1,5 +1,5 @@\n # use a builder image for building cloudflare\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n---\ncfsetup.yaml\n@@ -1,5 +1,5 @@\n-pinned_go: &pinned_go go=1.19.6-1\n-pinned_go_fips: &pinned_go_fips go-boring=1.19.6-1\n+pinned_go: &pinned_go go=1.20.7-1\n+pinned_go_fips: &pinned_go_fips go-boring=1.20.7-1\n \n build_dir: &build_dir /cfsetup_build\n default-flavor: bullseye\n---\ndev.Dockerfile\n@@ -1,4 +1,4 @@\n-FROM golang:1.19 as builder\n+FROM golang:1.20 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n---\ngo.mod\n@@ -1,6 +1,6 @@\n module github.com/cloudflare/cloudflared\n \n-go 1.19\n+go 1.20\n \n require (\n \tgithub.com/cloudflare/brotli-go v0.0.0-20191101163834-d34379f7ff93\n---\n"}], "ideal": "Title: Build with still supported Go 1.20\n\nBody: Minimal changes to migrate everything from unsupported Go 1.19 to 1.20\r\n\r\nGo 1.20 compatibility was fixed since v2023.5.1 via [TUN-7227: Migrate to devincarr/quic-go](https://github.com/cloudflare/cloudflared/commit/9426b603082905d0af8a07bdac866bc1d9c37cba)\r\n\r\nRelated issues & PRs:\r\n* Fixes #1047\r\n* Closes #1027 (that one just bumps running checks to Go 1.20 and 0e0c286 is included in this PR )\r\n* Further work will be needed to support Go 1.21: #1043"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/access/cmd.go\n@@ -466,6 +466,11 @@ func processURL(s string) (*url.URL, error) {\n \n // cloudflaredPath pulls the full path of cloudflared on disk\n func cloudflaredPath() string {\n+\tpath, err := os.Executable()\n+\tif err == nil && isFileThere(path) {\n+\t\treturn path\n+\t}\n+\n \tfor _, p := range strings.Split(os.Getenv(\"PATH\"), \":\") {\n \t\tpath := fmt.Sprintf(\"%s/%s\", p, \"cloudflared\")\n \t\tif isFileThere(path) {\n---\n"}], "ideal": "Title: [access] use os.Executable to discover the path to cloudflared when generating ssh config\n\nBody: Uses os.Executable to discover the path to cloudflared when generating ssh config. If os.Executable is unavailable, falls back to the previous method.\r\n\r\nThis allows for more accurate generation of the ssh config. Previously, if cloudflared was installed in the PATH, an incorrect config could be generated. This also allows for inclusion of the subcommand in other `cli/v2` apps that are not named `cloudflared`.\r\n\r\n<img width=\"1059\" alt=\"image\" src=\"https://github.com/cloudflare/cloudflared/assets/553597/1f9b35d2-d2af-45ab-b773-ab62e54afe52\">\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "orchestration/orchestrator.go\n@@ -74,6 +74,15 @@ func (o *Orchestrator) UpdateConfig(version int32, config []byte) *tunnelpogs.Up\n \t\t\tLastAppliedVersion: o.currentVersion,\n \t\t}\n \t}\n+\n+\tif string(config) == \"null\" {\n+\t\to.log.Info().Msg(\"Ignore null config from server\")\n+\t\to.currentVersion = version\n+\t\treturn &tunnelpogs.UpdateConfigurationResponse{\n+\t\t\tLastAppliedVersion: o.currentVersion,\n+\t\t}\n+\t}\n+\n \tvar newConf newRemoteConfig\n \tif err := json.Unmarshal(config, &newConf); err != nil {\n \t\to.log.Err(err).\n---\n"}], "ideal": "Title: Fix config update when config is \"null\"\n\nBody: When the tunnel reads the config from the server and it is \"null\" then ignore it.\r\n\r\nFixes #1029"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".github/workflows/check.yaml\n@@ -4,7 +4,7 @@ jobs:\n   check:\n     strategy:\n       matrix:\n-        go-version: [1.19.x]\n+        go-version: [1.20.x]\n         os: [ubuntu-latest, macos-latest, windows-latest]\n     runs-on: ${{ matrix.os }}\n     steps:\n---\n"}], "ideal": "Title: Run checks with Go 1.20\n\nBody: Go 1.19 is unmaintained since Go 1.21 was released.\r\n\r\nGo 1.20 compatibility was added since v2023.5.1 via [TUN-7227: Migrate to devincarr/quic-go](https://github.com/cloudflare/cloudflared/commit/9426b603082905d0af8a07bdac866bc1d9c37cba)\r\n\r\nSee also \r\n* #1047\r\n* #888 \r\n* a more thorough replacement PR: #1052\r\n* needs further work for Go 1.21: #1043"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "edgediscovery/dial.go\n@@ -7,6 +7,7 @@ import (\n \t\"time\"\n \n \t\"github.com/pkg/errors\"\n+\t\"golang.org/x/net/proxy\"\n )\n \n // DialEdgeWithH2Mux makes a TLS connection to a Cloudflare edge node\n@@ -17,15 +18,26 @@ func DialEdge(\n \tedgeTCPAddr *net.TCPAddr,\n \tlocalIP net.IP,\n ) (net.Conn, error) {\n-\t// Inherit from parent context so we can cancel (Ctrl-C) while dialing\n-\tdialCtx, dialCancel := context.WithTimeout(ctx, timeout)\n-\tdefer dialCancel()\n-\n \tdialer := net.Dialer{}\n \tif localIP != nil {\n \t\tdialer.LocalAddr = &net.TCPAddr{IP: localIP, Port: 0}\n \t}\n-\tedgeConn, err := dialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\tproxyDialer := proxy.FromEnvironmentUsing(&dialer)\n+\n+\tvar edgeConn net.Conn\n+\tvar err error\n+\n+\tctxDialer, ok := proxyDialer.(interface {\n+\t\tDialContext(context.Context, string, string) (net.Conn, error)\n+\t})\n+\tif ok {\n+\t\t// Inherit from parent context so we can cancel (Ctrl-C) while dialing\n+\t\tdialCtx, dialCancel := context.WithTimeout(ctx, timeout)\n+\t\tdefer dialCancel()\n+\t\tedgeConn, err = ctxDialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\t} else {\n+\t\tedgeConn, err = proxyDialer.Dial(\"tcp\", edgeTCPAddr.String())\n+\t}\n \tif err != nil {\n \t\treturn nil, newDialError(err, \"DialContext error\")\n \t}\n---\n"}], "ideal": "Title: http2 tunnel support socks5 proxy from env all_proxy\n\nBody: close #350 #1025"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -776,6 +776,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_POST_QUANTUM\"},\n \t\t\tHidden:  FipsEnabled,\n \t\t}),\n+\t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n+\t\t\tName:    \"warp-routing\",\n+\t\t\tUsage:   \"Enable WARP routing\",\n+\t\t\tEnvVars: []string{\"TUNNEL_WARP_ROUTING\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewBoolFlag(&cli.BoolFlag{\n \t\t\tName:    \"management-diagnostics\",\n \t\t\tUsage:   \"Enables the in-depth diagnostic routes to be made available over the management service (/debug/pprof, /metrics, etc.)\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -253,6 +253,9 @@ func prepareTunnelConfig(\n \t\tWarpRouting:        ingress.NewWarpRoutingConfig(&cfg.WarpRouting),\n \t\tConfigurationFlags: parseConfigFlags(c),\n \t}\n+\tif c.Bool(\"warp-routing\") {\n+\t\torchestratorConfig.WarpRouting.Enabled = true\n+\t}\n \treturn tunnelConfig, orchestratorConfig, nil\n }\n \n---\n"}], "ideal": "Title: Add WARP routing flag\n\nBody: Closes https://github.com/cloudflare/cloudflared/issues/1010."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "ingress/ingress.go\n@@ -24,6 +24,7 @@ var (\n \terrLastRuleNotCatchAll        = errors.New(\"The last ingress rule must match all URLs (i.e. it should not have a hostname or path filter)\")\n \terrBadWildcard                = errors.New(\"Hostname patterns can have at most one wildcard character (\\\"*\\\") and it can only be used for subdomains, e.g. \\\"*.example.com\\\"\")\n \terrHostnameContainsPort       = errors.New(\"Hostname cannot contain a port\")\n+\terrHostnameContainsScheme     = errors.New(\"Hostname cannot contain a scheme (e.g. http://, https://, etc.)\")\n \tErrURLIncompatibleWithIngress = errors.New(\"You can't set the --url flag (or $TUNNEL_URL) when using multiple-origin ingress rules\")\n )\n \n@@ -359,6 +360,10 @@ func validateIngress(ingress []config.UnvalidatedIngressRule, defaults OriginReq\n }\n \n func validateHostname(r config.UnvalidatedIngressRule, ruleIndex, totalRules int) error {\n+\t// Ensure the hostname doesn't contain a scheme so a less confusing error is returned.\n+\tif u, e := url.Parse(r.Hostname); e == nil && isHTTPService(u) {\n+\t\treturn errHostnameContainsScheme\n+\t}\n \t// Ensure that the hostname doesn't contain port\n \t_, _, err := net.SplitHostPort(r.Hostname)\n \tif err == nil {\n---\n"}], "ideal": "Title: fix: erroneous error message for host validation\n\nBody: when crafting an ingress YAML file by hand its easy to write the following by mistake:\r\n```yaml\r\ningress:\r\n  - hostname: https://example.com\r\n    service: http://localhost:50100\r\n  - service: http_status:404\r\n```\r\n\r\n`cloudflared` would report the error: `Hostname cannot contain a port`\r\n\r\nthis confused me for a few minutes before i compared two configs and saw my mistake. this change introduces a check prior to port splitting to see if the hostname contains a protocol and reports a relevant error"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/access/cmd.go\n@@ -525,6 +525,11 @@ func isTokenValid(options *carrier.StartOptions, log *zerolog.Logger) (bool, err\n \t\treturn false, errors.Wrap(err, \"Could not create access request\")\n \t}\n \treq.Header.Set(\"User-Agent\", userAgent)\n+\n+\tquery := req.URL.Query()\n+\tquery.Set(\"cloudflared_token_check\", \"true\")\n+\treq.URL.RawQuery = query.Encode()\n+\n \t// Do not follow redirects\n \tclient := &http.Client{\n \t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n---\n"}], "ideal": "Title: Pass cloudflared_token_check param when running cloudflared access login\n\nBody: The back-end is already set to handle this query arg. This fixes timeouts validating access tokens if the origin is not ready to handle the http request.\r\n\r\nInternal tracking ticket: AUTH-5328"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".docker-images\n@@ -10,3 +10,4 @@ images:\n     architectures:\n     - amd64\n     - arm64\n+    - arm\n---\nDockerfile.arm\n@@ -0,0 +1,27 @@\n+# use a builder image for building cloudflare\n+FROM golang:1.20.6 as builder\n+ENV GO111MODULE=on \\\n+    CGO_ENABLED=0 \n+    \n+WORKDIR /go/src/github.com/cloudflare/cloudflared/\n+\n+# copy our sources into the builder image\n+COPY . .\n+\n+# compile cloudflared\n+RUN GOOS=linux GOARCH=arm make cloudflared\n+\n+# use a distroless base image with glibc\n+FROM gcr.io/distroless/base-debian11:nonroot-arm\n+\n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n+# copy our compiled binary\n+COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+\n+# run as non-privileged user\n+USER nonroot\n+\n+# command / entrypoint of container\n+ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n+CMD [\"version\"]\n---\n"}], "ideal": "Title: \u2795 Dockerfile.arm to support arm 32bit\n\nBody: - [x] had to build it on my AllWinner H2 SoC which is running arm 32bit \r\n- [x] it is working with no issues\r\n- [x] it took some time to build dependencies \u2013 would be nice to have it accessible from docker registry cause it will require some effort when new version of cloudflared is out to rebuild...."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "ingress/origin_service.go\n@@ -376,6 +376,13 @@ func newHTTPTransport(service OriginService, cfg OriginRequestConfig, log *zerol\n \t\t\treturn dialContext(ctx, \"unix\", service.path)\n \t\t}\n \n+\t// If this origin is a http service, configure the sni from the host header, if possible.\n+\tcase *httpService:\n+\t\tif httpTransport.TLSClientConfig.ServerName == \"\" && service.hostHeader != \"\" {\n+\t\t\thttpTransport.TLSClientConfig.ServerName = service.hostHeader\n+\t\t}\n+\t\thttpTransport.DialContext = dialContext\n+\n \t// Otherwise, use the regular network config.\n \tdefault:\n \t\thttpTransport.DialContext = dialContext\n---\n"}], "ideal": "Title: [wip] pass sni to http origins automatically\n\nBody: Fixes https://github.com/cloudflare/cloudflared/issues/541"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/configuration.go\n@@ -33,9 +33,9 @@ import (\n const secretValue = \"*****\"\n \n var (\n-\tdeveloperPortal = \"https://developers.cloudflare.com/argo-tunnel\"\n-\tserviceUrl      = developerPortal + \"/reference/service/\"\n-\targumentsUrl    = developerPortal + \"/reference/arguments/\"\n+\tdeveloperPortal = \"https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup\"\n+\tserviceUrl      = developerPortal + \"/tunnel-guide/local/as-a-service/\"\n+\targumentsUrl    = developerPortal + \"/tunnel-guide/local/local-management/arguments/\"\n \n \tsecretFlags = [2]*altsrc.StringFlag{credentialsContentsFlag, tunnelTokenFlag}\n \n---\n"}], "ideal": "Title: Update developerPortal URL in configuration.go\n\nBody: Hello,\r\n\r\nI would like to propose the following change in this pull request:\r\n\r\nUpdate developerPortal URL in configuration.go: I have updated the developerPortal URL within the configuration.go file to point to the new correct location.\r\nAdditionally, I noticed an issue with the Cloudflare documentation redirect, which I wanted to bring to your attention. Here are the URLs in question:\r\n\r\nCurrent URL:\r\nhttps://developers.cloudflare.com/argo-tunnel/reference/service/\r\nIncorrect redirect:\r\nhttps://cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/as-a-service/\r\nCorrect URL:\r\nhttps://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/as-a-service/\r\n\r\nPlease review my proposed changes and let me know if any further adjustments are required.\r\nThank you for your time and consideration.\r\n\r\nBest regards,"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".github/workflows/check.yaml\n@@ -9,10 +9,10 @@ jobs:\n     runs-on: ${{ matrix.os }}\n     steps:\n     - name: Install Go\n-      uses: actions/setup-go@v3\n+      uses: actions/setup-go@v5\n       with:\n         go-version: ${{ matrix.go-version }}\n     - name: Checkout code\n-      uses: actions/checkout@v3\n+      uses: actions/checkout@v4\n     - name: Test\n       run: make test\n---\n"}], "ideal": "Title: ci/check: bump actions/checkout to v4, actions/setup-go to v5\n\nBody: ## Changes\r\n\r\n- Bump `actions/checkout` from `v3` (Node 16) to `v4` (Node 20).\r\n- Bump `actions/setup-go` from `v3` (Node 16) to `v5` (Node 20)."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/login.go\n@@ -52,6 +52,7 @@ func login(c *cli.Context) error {\n \n \tresourceData, err := token.RunTransfer(\n \t\tloginURL,\n+\t\t\"\",\n \t\t\"cert\",\n \t\t\"callback\",\n \t\tcallbackStoreURL,\n---\ntoken/token.go\n@@ -214,19 +214,19 @@ func getToken(appURL *url.URL, appInfo *AppInfo, useHostOnly bool, log *zerolog.\n \t\t\treturn appToken, nil\n \t\t}\n \t}\n-\treturn getTokensFromEdge(appURL, appTokenPath, orgTokenPath, useHostOnly, log)\n+\treturn getTokensFromEdge(appURL, appInfo.AppAUD, appTokenPath, orgTokenPath, useHostOnly, log)\n \n }\n \n // getTokensFromEdge will attempt to use the transfer service to retrieve an app and org token, save them to disk,\n // and return the app token.\n-func getTokensFromEdge(appURL *url.URL, appTokenPath, orgTokenPath string, useHostOnly bool, log *zerolog.Logger) (string, error) {\n+func getTokensFromEdge(appURL *url.URL, appAUD, appTokenPath, orgTokenPath string, useHostOnly bool, log *zerolog.Logger) (string, error) {\n \t// If no org token exists or if it couldn't be exchanged for an app token, then run the transfer service flow.\n \n \t// this weird parameter is the resource name (token) and the key/value\n \t// we want to send to the transfer service. the key is token and the value\n \t// is blank (basically just the id generated in the transfer service)\n-\tresourceData, err := RunTransfer(appURL, keyName, keyName, \"\", true, useHostOnly, log)\n+\tresourceData, err := RunTransfer(appURL, appAUD, keyName, keyName, \"\", true, useHostOnly, log)\n \tif err != nil {\n \t\treturn \"\", errors.Wrap(err, \"failed to run transfer service\")\n \t}\n---\ntoken/transfer.go\n@@ -25,12 +25,12 @@ const (\n // The \"dance\" we refer to is building a HTTP request, opening that in a browser waiting for\n // the user to complete an action, while it long polls in the background waiting for an\n // action to be completed to download the resource.\n-func RunTransfer(transferURL *url.URL, resourceName, key, value string, shouldEncrypt bool, useHostOnly bool, log *zerolog.Logger) ([]byte, error) {\n+func RunTransfer(transferURL *url.URL, appAUD, resourceName, key, value string, shouldEncrypt bool, useHostOnly bool, log *zerolog.Logger) ([]byte, error) {\n \tencrypterClient, err := NewEncrypter(\"cloudflared_priv.pem\", \"cloudflared_pub.pem\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\trequestURL, err := buildRequestURL(transferURL, key, value+encrypterClient.PublicKey(), shouldEncrypt, useHostOnly)\n+\trequestURL, err := buildRequestURL(transferURL, appAUD, key, value+encrypterClient.PublicKey(), shouldEncrypt, useHostOnly)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -76,9 +76,10 @@ func RunTransfer(transferURL *url.URL, resourceName, key, value string, shouldEn\n // BuildRequestURL creates a request suitable for a resource transfer.\n // it will return a constructed url based off the base url and query key/value provided.\n // cli will build a url for cli transfer request.\n-func buildRequestURL(baseURL *url.URL, key, value string, cli, useHostOnly bool) (string, error) {\n+func buildRequestURL(baseURL *url.URL, appAUD string, key, value string, cli, useHostOnly bool) (string, error) {\n \tq := baseURL.Query()\n \tq.Set(key, value)\n+\tq.Set(\"aud\", appAUD)\n \tbaseURL.RawQuery = q.Encode()\n \tif useHostOnly {\n \t\tbaseURL.Path = \"\"\n---\n"}], "ideal": "Title: AUTH-4887 Add aud parameter to token transfer url\n\nBody: This is an optional parameter that helps the /cdn-cgi/access/cli endpoint save some work figuring out which app it's doing the token transfer for. If not provided, it can figure that out on its own, like it currently does today."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/subcommands.go\n@@ -632,7 +632,7 @@ func buildRunCommand() *cli.Command {\n \t\tAction:    cliutil.ConfiguredAction(runCommand),\n \t\tUsage:     \"Proxy a local web server by running the given tunnel\",\n \t\tUsageText: \"cloudflared tunnel [tunnel command options] run [subcommand options] [TUNNEL]\",\n-\t\tDescription: `Runs the tunnel identified by name or UUUD, creating highly available connections\n+\t\tDescription: `Runs the tunnel identified by name or UUID, creating highly available connections\n   between your server and the Cloudflare edge. You can provide name or UUID of tunnel to run either as the\n   last command line argument or in the configuration file using \"tunnel: TUNNEL\".\n \n---\n"}], "ideal": "Title: Fix typo\n\nBody: UUID not UUUD"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -82,6 +82,8 @@ else ifeq ($(LOCAL_OS),windows)\n     TARGET_OS ?= windows\n else ifeq ($(LOCAL_OS),freebsd)\n     TARGET_OS ?= freebsd\n+else ifeq ($(LOCAL_OS),openbsd)\n+    TARGET_OS ?= openbsd\n else\n     $(error This system's OS $(LOCAL_OS) isn't supported)\n endif\n---\n"}], "ideal": "Title: Add suport for OpenBSD\n\nBody: I've tested this on my OpenBSD 7.2 machine and this simple fix makes it compile and run flawlessly."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "proxy/proxy.go\n@@ -33,6 +33,10 @@ const (\n \ttrailerHeaderName = \"Trailer\"\n )\n \n+var (\n+\tErrRequestEndedAbruptly = errors.New(\"Incoming request ended abruptly\")\n+)\n+\n // Proxy represents a means to Proxy between cloudflared and the origin services.\n type Proxy struct {\n \tingressRules ingress.Ingress\n@@ -123,7 +127,11 @@ func (p *Proxy) ProxyHTTP(\n \t\t\tlogFields,\n \t\t); err != nil {\n \t\t\trule, srv := ruleField(p.ingressRules, ruleNum)\n-\t\t\tp.logRequestError(err, cfRay, \"\", rule, srv)\n+\t\t\tif errors.Is(err, ErrRequestEndedAbruptly) {\n+\t\t\t\tp.log.Debug().Msg(err.Error())\n+\t\t\t} else {\n+\t\t\t\tp.logRequestError(err, cfRay, \"\", rule, srv)\n+\t\t\t}\n \t\t\treturn err\n \t\t}\n \t\treturn nil\n@@ -225,7 +233,7 @@ func (p *Proxy) proxyHTTPRequest(\n \tif err != nil {\n \t\ttracing.EndWithErrorStatus(ttfbSpan, err)\n \t\tif err := roundTripReq.Context().Err(); err != nil {\n-\t\t\treturn errors.Wrap(err, \"Incoming request ended abruptly\")\n+\t\t\treturn ErrRequestEndedAbruptly\n \t\t}\n \t\treturn errors.Wrap(err, \"Unable to reach the origin service. The service may be down or it may not be responding to traffic from cloudflared\")\n \t}\n---\n"}], "ideal": "Title: Incoming request ended abruptly as debug message\n\nBody: closes #908"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".devcontainer/devcontainer.json\n@@ -0,0 +1,7 @@\n+{\n+  \"image\": \"mcr.microsoft.com/devcontainers/universal:2\",\n+  \"features\": {\n+  }\n+}\n+\n+#Not sure\n---\n"}], "ideal": "Title: New split\n\nBody: Can the local IP address be used instead."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".github/workflows/check.yaml\n@@ -9,10 +9,10 @@ jobs:\n     runs-on: ${{ matrix.os }}\n     steps:\n     - name: Install Go\n-      uses: actions/setup-go@v2\n+      uses: actions/setup-go@v3\n       with:\n         go-version: ${{ matrix.go-version }}\n     - name: Checkout code\n-      uses: actions/checkout@v2\n+      uses: actions/checkout@v3\n     - name: Test\n       run: make test\n---\n"}], "ideal": "Title: check: update checkout and setup go to v3\n\nBody: Updates checkout and setup go from v2 to v3"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cloudflared.wxs\n@@ -2,61 +2,63 @@\n \n <?if $(var.Platform)=\"x86\"?>\n     <?define Program_Files=\"ProgramFilesFolder\"?>\n-<?else?>\n+<?else ?>\n     <?define Program_Files=\"ProgramFiles64Folder\"?>\n-<?endif?>\n+<?endif ?>\n <?ifndef var.Version?>\n     <?error Undefined Version variable?>\n-<?endif?>\n+<?endif ?>\n <?ifndef var.Path?>\n     <?error Undefined Path variable?>\n-<?endif?>\n+<?endif ?>\n \n <Wix xmlns=\"http://schemas.microsoft.com/wix/2006/wi\">\n-    <Product Id=\"35e5e858-9372-4449-bf73-1cd6f7267128\" \n+    <Product Id=\"*\"\n         UpgradeCode=\"23f90fdd-9328-47ea-ab52-5380855a4b12\"\n         Name=\"cloudflared\"\n         Version=\"$(var.Version)\"\n         Manufacturer=\"cloudflare\"\n         Language=\"1033\">\n \n-      <Package InstallerVersion=\"200\" Compressed=\"yes\" Comments=\"Windows Installer Package\" InstallScope=\"perMachine\"/>\n+        <Package InstallerVersion=\"200\" Compressed=\"yes\" Comments=\"Windows Installer Package\" InstallScope=\"perMachine\" />\n \n-      <Media Id=\"1\" Cabinet=\"product.cab\" EmbedCab=\"yes\"/>\n+        <Media Id=\"1\" Cabinet=\"product.cab\" EmbedCab=\"yes\" />\n \n-      <Upgrade Id=\"23f90fdd-9328-47ea-ab52-5380855a4b12\">\n-         <UpgradeVersion Minimum=\"$(var.Version)\" OnlyDetect=\"yes\" Property=\"NEWERVERSIONDETECTED\"/>\n-         <UpgradeVersion Minimum=\"2020.8.0\" Maximum=\"$(var.Version)\" IncludeMinimum=\"yes\" IncludeMaximum=\"no\"\n-                         Property=\"OLDERVERSIONBEINGUPGRADED\"/>\n-      </Upgrade>\n-      <Condition Message=\"A newer version of this software is already installed.\">NOT NEWERVERSIONDETECTED</Condition>\n+        <MajorUpgrade DowngradeErrorMessage=\"A later version of [ProductName] is already installed. Setup will now exit.\" />\n \n-    <Directory Id=\"TARGETDIR\" Name=\"SourceDir\">\n-        <!--This specifies where the cloudflared.exe is moved to in the windows Operation System-->\n-        <Directory Id=\"$(var.Program_Files)\">\n-            <Directory Id=\"INSTALLDIR\" Name=\"cloudflared\">\n-                <Component Id=\"ApplicationFiles\" Guid=\"35e5e858-9372-4449-bf73-1cd6f7267128\">\n-                    <File Id=\"ApplicationFile0\" Source=\"$(var.Path)\"/>\n-                </Component>\n+        <Upgrade Id=\"23f90fdd-9328-47ea-ab52-5380855a4b12\">\n+            <UpgradeVersion Minimum=\"$(var.Version)\" OnlyDetect=\"yes\" Property=\"NEWERVERSIONDETECTED\" />\n+            <UpgradeVersion Minimum=\"2020.8.0\" Maximum=\"$(var.Version)\" IncludeMinimum=\"yes\" IncludeMaximum=\"no\"\n+                Property=\"OLDERVERSIONBEINGUPGRADED\" />\n+        </Upgrade>\n+        <Condition Message=\"A newer version of this software is already installed.\">NOT NEWERVERSIONDETECTED</Condition>\n+\n+        <Directory Id=\"TARGETDIR\" Name=\"SourceDir\">\n+            <!--This specifies where the cloudflared.exe is moved to in the windows Operation System-->\n+            <Directory Id=\"$(var.Program_Files)\">\n+                <Directory Id=\"INSTALLDIR\" Name=\"cloudflared\">\n+                    <Component Id=\"ApplicationFiles\" Guid=\"35e5e858-9372-4449-bf73-1cd6f7267128\">\n+                        <File Id=\"ApplicationFile0\" Source=\"$(var.Path)\" />\n+                    </Component>\n+                </Directory>\n             </Directory>\n+            <Component Id=\"ENVS\" Guid=\"6bb74449-d10d-4f4a-933e-6fc9fa006eae\">\n+                <!--Set the cloudflared bin location to the Path Environment Variable-->\n+                <Environment Id=\"ENV0\"\n+                    Name=\"PATH\"\n+                    Value=\"[INSTALLDIR].\"\n+                    Permanent=\"no\"\n+                    Part=\"last\"\n+                    Action=\"create\"\n+                    System=\"yes\" />\n+            </Component>\n         </Directory>\n-        <Component Id=\"ENVS\" Guid=\"6bb74449-d10d-4f4a-933e-6fc9fa006eae\">\n-        <!--Set the cloudflared bin location to the Path Environment Variable-->\n-         <Environment Id=\"ENV0\"\n-           Name=\"PATH\"\n-           Value=\"[INSTALLDIR].\"\n-           Permanent=\"no\"\n-           Part=\"last\"\n-           Action=\"create\"\n-           System=\"yes\" />\n-        </Component>\n-    </Directory>\n-\n-\n-    <Feature Id='Complete' Level='1'>\n-      <ComponentRef Id=\"ENVS\"/>\n-      <ComponentRef Id='ApplicationFiles' />\n-    </Feature>\n+\n+\n+        <Feature Id='Complete' Level='1'>\n+            <ComponentRef Id=\"ENVS\" />\n+            <ComponentRef Id='ApplicationFiles' />\n+        </Feature>\n \n     </Product>\n </Wix>\n---\n"}], "ideal": "Title: GH-484: Add MajorUpgrade element to msi build definition\n\nBody: One commit is only whitespace, so please see changes in commit https://github.com/cloudflare/cloudflared/commit/28294be470aeb39aa7c58d776494d7aed9b6ff3c\r\n\r\nI also tried to build things but the build instructions link is dead on readme.md. So untested \ud83d\ude05 \r\n\r\n#484\r\n\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/linux_service.go\n@@ -71,7 +71,7 @@ Description=Update cloudflared\n After=network.target\n \n [Service]\n-ExecStart=/bin/bash -c '{{ .Path }} update; code=$?; if [ $code -eq 11 ]; then systemctl restart cloudflared; exit 0; fi; exit $code'\n+ExecStart=/bin/bash -c '{{ .Path }} update'\n `,\n \t},\n \t{\n@@ -84,6 +84,22 @@ OnCalendar=daily\n \n [Install]\n WantedBy=timers.target\n+`,\n+\t},\n+\t{\n+\t\tPath: \"/etc/systemd/system/cloudflared-restart.path\",\n+\t\tContent: `[Path]\n+PathChanged=/usr/bin/cloudflared\n+\n+[Install]\n+WantedBy=multi-user.target\n+`,\n+\t},\n+\t{\n+\t\tPath: \"/etc/systemd/system/cloudflared-restart.service\",\n+\t\tContent: `[Service]\n+Type=oneshot\n+ExecStart=/usr/bin/systemctl restart cloudflared\n `,\n \t},\n }\n@@ -273,6 +289,14 @@ func installSystemd(templateArgs *ServiceTemplateArgs, log *zerolog.Logger) erro\n \t\tlog.Err(err).Msgf(\"systemctl enable %s error\", cloudflaredService)\n \t\treturn err\n \t}\n+\tif err := runCommand(\"systemctl\", \"enable\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl enable cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n+\tif err := runCommand(\"systemctl\", \"start\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl start cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n \tif err := runCommand(\"systemctl\", \"start\", \"cloudflared-update.timer\"); err != nil {\n \t\tlog.Err(err).Msg(\"systemctl start cloudflared-update.timer error\")\n \t\treturn err\n@@ -335,6 +359,14 @@ func uninstallSystemd(log *zerolog.Logger) error {\n \t\tlog.Err(err).Msgf(\"systemctl stop %s error\", cloudflaredService)\n \t\treturn err\n \t}\n+\tif err := runCommand(\"systemctl\", \"disable\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl disable cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n+\tif err := runCommand(\"systemctl\", \"stop\", \"cloudflared-restart.path\"); err != nil {\n+\t\tlog.Err(err).Msg(\"systemctl stop cloudflared-restart.path error\")\n+\t\treturn err\n+\t}\n \tif err := runCommand(\"systemctl\", \"stop\", \"cloudflared-update.timer\"); err != nil {\n \t\tlog.Err(err).Msg(\"systemctl stop cloudflared-update.timer error\")\n \t\treturn err\n---\n"}], "ideal": "Title: Added automatic systemd restart given binary changes\n\nBody: Added a systemd [Path](https://www.freedesktop.org/software/systemd/man/systemd.path.html) that observes changes in the binary and restarts the cloudflared systemd service in that case.\r\n\r\nCloses #799 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/access/cmd.go\n@@ -7,6 +7,7 @@ import (\n \t\"net/url\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"runtime\"\n \t\"strings\"\n \t\"text/template\"\n \t\"time\"\n@@ -38,10 +39,21 @@ const (\n Add to your {{.Home}}/.ssh/config:\n \n {{- if .ShortLivedCerts}}\n-Match host {{.Hostname}} exec \"{{.Cloudflared}} access ssh-gen --hostname %h\"\n+Host cfpipe-{{.Hostname}}\n+{{- if eq .OS \"windows\"}}\n+  ProxyCommand {{.Cloudflared}} access ssh-gen --hostname %h && ssh -tt %r@cfpipe-{{.Hostname}} >&2 <&1\n+{{- else}}\n+  ProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt %r@cfpipe-{{.Hostname}} >&2 <&1'\n+{{end}}\n+\n+Host cfpipe-{{.Hostname}}\n+  HostName {{.Hostname}}\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n-  IdentityFile ~/.cloudflared/%h-cf_key\n-  CertificateFile ~/.cloudflared/%h-cf_key-cert.pub\n+{{- if eq .OS \"windows\"}} IdentityFile {{.CurrWorkingDir}}/{{.Hostname}}-cf_key\n+  CertificateFile {{.CurrWorkingDir}}/{{.Hostname}}-cf_key-cert.pub\n+{{- else}} IdentityFile ~/.cloudflared/{{.Hostname}}-cf_key\n+  CertificateFile ~/.cloudflared/{{.Hostname}}-cf_key-cert.pub\n+{{end}}\n {{- else}}\n Host {{.Hostname}}\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n@@ -361,6 +373,10 @@ func generateToken(c *cli.Context) error {\n \n // sshConfig prints an example SSH config to stdout\n func sshConfig(c *cli.Context) error {\n+\tcurrWorkingDirectory, err := os.Getwd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tgenCertBool := c.Bool(sshGenCertFlag)\n \thostname := c.String(sshHostnameFlag)\n \tif hostname == \"\" {\n@@ -372,10 +388,23 @@ func sshConfig(c *cli.Context) error {\n \t\tShortLivedCerts bool\n \t\tHostname        string\n \t\tCloudflared     string\n+\t\tCurrWorkingDir  string\n+\t\tOS              string\n \t}\n \n \tt := template.Must(template.New(\"sshConfig\").Parse(sshConfigTemplate))\n-\treturn t.Execute(os.Stdout, config{Home: os.Getenv(\"HOME\"), ShortLivedCerts: genCertBool, Hostname: hostname, Cloudflared: cloudflaredPath()})\n+\n+\treturn t.Execute(\n+\t\tos.Stdout,\n+\t\tconfig{\n+\t\t\tHome:            os.Getenv(\"HOME\"),\n+\t\t\tShortLivedCerts: genCertBool,\n+\t\t\tHostname:        hostname,\n+\t\t\tCloudflared:     cloudflaredPath(),\n+\t\t\tCurrWorkingDir:  currWorkingDirectory,\n+\t\t\tOS:              runtime.GOOS,\n+\t\t},\n+\t)\n }\n \n // sshGen generates a short lived certificate for provided hostname\n@@ -468,6 +497,10 @@ func processURL(s string) (*url.URL, error) {\n \n // cloudflaredPath pulls the full path of cloudflared on disk\n func cloudflaredPath() string {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tabsPath, _ := os.Executable()\n+\t\treturn absPath\n+\t}\n \tfor _, p := range strings.Split(os.Getenv(\"PATH\"), \":\") {\n \t\tpath := fmt.Sprintf(\"%s/%s\", p, \"cloudflared\")\n \t\tif isFileThere(path) {\n---\n"}], "ideal": "Title: fix: add windows specific ssh-config\n\nBody: This attempts to fix https://github.com/cloudflare/cloudflared/issues/753\r\n\r\nThe bug occurs because windows executable uses the current working directory to do its operations while the ssh-config being generated assumes that:\r\n\r\n1. the user uses a nix machine\r\n2. the nix executable follows a different installation directory than windows. Windows uses the relative path, the nix binary gets stored in `~/.cloudflared`"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "go.mod\n@@ -37,7 +37,7 @@ require (\n \tgo.uber.org/automaxprocs v1.4.0\n \tgolang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa\n \tgolang.org/x/net v0.0.0-20220909164309-bea034e7d591\n-\tgolang.org/x/sync v0.0.0-20220601150217-0de741cfad7f\n+\tgolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4\n \tgolang.org/x/sys v0.0.0-20220808155132-1c4a2a72c664\n \tgolang.org/x/term v0.0.0-20210927222741-03fcf44c2211\n \tgoogle.golang.org/protobuf v1.28.0\n@@ -89,11 +89,10 @@ require (\n \tgithub.com/prometheus/common v0.32.1 // indirect\n \tgithub.com/prometheus/procfs v0.7.3 // indirect\n \tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n-\tgolang.org/x/mod v0.4.2 // indirect\n+\tgolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4 // indirect\n \tgolang.org/x/oauth2 v0.0.0-20220822191816-0ebed06d0094 // indirect\n-\tgolang.org/x/text v0.3.7 // indirect\n-\tgolang.org/x/tools v0.1.6-0.20210726203631-07bc1bf47fb2 // indirect\n-\tgolang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f // indirect\n+\tgolang.org/x/text v0.3.8 // indirect\n+\tgolang.org/x/tools v0.1.12 // indirect\n \tgoogle.golang.org/appengine v1.6.7 // indirect\n \tgoogle.golang.org/genproto v0.0.0-20220616135557-88e70c0c3a90 // indirect\n \tgoogle.golang.org/grpc v1.47.0 // indirect\n---\ngo.sum\n@@ -681,8 +681,9 @@ golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.4.1/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n-golang.org/x/mod v0.4.2 h1:Gz96sIWK3OalVv/I/qNygP42zyoKp3xptRVCWRFEBvo=\n golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n+golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4 h1:6zppjxzCulZykYSLyVDYbneBfbaBIQPYMevg0bEwv2s=\n+golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\n golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n golang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n@@ -780,8 +781,9 @@ golang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJ\n golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n-golang.org/x/sync v0.0.0-20220601150217-0de741cfad7f h1:Ax0t5p6N38Ga0dThY21weqDEyz2oklo4IvDkpigvkD8=\n golang.org/x/sync v0.0.0-20220601150217-0de741cfad7f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4 h1:uVc8UZUe6tr40fFVnUP5Oj+veunVezqYl9z7DYw9xzw=\n+golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n golang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n@@ -879,8 +881,9 @@ golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n golang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n golang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n-golang.org/x/text v0.3.7 h1:olpwvP2KacW1ZWvsR7uQhoyTYvKAupfQrRGBFM352Gk=\n golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\n+golang.org/x/text v0.3.8 h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=\n+golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=\n golang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n@@ -945,15 +948,15 @@ golang.org/x/tools v0.1.2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n golang.org/x/tools v0.1.3/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n golang.org/x/tools v0.1.4/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n golang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n-golang.org/x/tools v0.1.6-0.20210726203631-07bc1bf47fb2 h1:BonxutuHCTL0rBDnZlKjpGIQFTjyUVTexFOdWkB6Fg0=\n golang.org/x/tools v0.1.6-0.20210726203631-07bc1bf47fb2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n+golang.org/x/tools v0.1.12 h1:VveCTK38A2rkS8ZqFY25HIDFscX5X9OoEhJd3quQmXU=\n+golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\n golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20220411194840-2f41105eb62f/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20220517211312-f3a8303e98df/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\n-golang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f h1:uF6paiQQebLeSXkrTqHqz0MXhXXS1KgF41eUdBNvxK0=\n golang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\n google.golang.org/api v0.0.0-20180910000450-7ca32eb868bf/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\n google.golang.org/api v0.0.0-20181030000543-1d582fd0359e/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\n---\nvendor/modules.txt\n@@ -412,7 +412,7 @@ golang.org/x/sys/windows/svc/mgr\n # golang.org/x/term v0.0.0-20210927222741-03fcf44c2211\n ## explicit; go 1.17\n golang.org/x/term\n-# golang.org/x/text v0.3.7\n+# golang.org/x/text v0.3.8\n ## explicit; go 1.17\n golang.org/x/text/secure/bidirule\n golang.org/x/text/transform\n---\n"}], "ideal": "Title: Update golang.org/x/text\n\nBody: Related to #786 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -170,7 +170,7 @@ func TunnelCommand(c *cli.Context) error {\n \t\treturn runAdhocNamedTunnel(sc, name, c.String(CredFileFlag))\n \t}\n \tif ref := config.GetConfiguration().TunnelID; ref != \"\" {\n-\t\treturn fmt.Errorf(\"Use `cloudflared tunnel run` to start tunnel %s\", ref)\n+\t\treturn fmt.Errorf(\"Use `cloudflared tunnel run` to start tunnel %s. If you are trying to start a TryCloudflare quick tunnel, the `config.yaml` file must not be present (consider temporarily renaming it).\", ref)\n \t}\n \n \t// Unauthenticated named tunnel on <random>.<quick-tunnels-service>.com\n---\n"}], "ideal": "Title: Add hint why a quick tunnel isn't working if config.yaml is present\n\nBody: Since I just spent half an hour being confused why the documented `cloudflared tunnel --url http://localhost:8080` TryCloudflare quick tunnel would not work, I am proposing this hint be given to the user explaining the limitation and suggesting a workaround. I also added a couple sentences to the documentation to make note of this limitation:\r\n\r\nhttps://github.com/cloudflare/cloudflare-docs/pull/6324\r\n\r\nIt would be better to eliminate the limitation entirely, I proposed how in that issue linked above."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/access/cmd.go\n@@ -37,16 +37,13 @@ const (\n \tsshConfigTemplate  = `\n Add to your {{.Home}}/.ssh/config:\n \n-Host {{.Hostname}}\n {{- if .ShortLivedCerts}}\n-  ProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt %r@cfpipe-{{.Hostname}} >&2 <&1'\n-\n-Host cfpipe-{{.Hostname}}\n-  HostName {{.Hostname}}\n+Match host {{.Hostname}} exec \"{{.Cloudflared}} access ssh-gen --hostname %h\"\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n-  IdentityFile ~/.cloudflared/{{.Hostname}}-cf_key\n-  CertificateFile ~/.cloudflared/{{.Hostname}}-cf_key-cert.pub\n+  IdentityFile ~/.cloudflared/%h-cf_key\n+  CertificateFile ~/.cloudflared/%h-cf_key-cert.pub\n {{- else}}\n+Host {{.Hostname}}\n   ProxyCommand {{.Cloudflared}} access ssh --hostname %h\n {{end}}\n `\n---\n"}], "ideal": "Title: Issue #574: Better ssh config for short-lived cert\n\nBody: This PR is made using suggestion from #574. The pros for this config is that it will work both Windows and Linux (tested), as well as in VSCode, which normally can't be done with the current generated ssh config (refers to #734)"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/linux_service.go\n@@ -44,6 +44,7 @@ const (\n \tserviceCredentialFile = \"cert.pem\"\n \tserviceConfigPath     = serviceConfigDir + \"/\" + serviceConfigFile\n \tcloudflaredService    = \"cloudflared.service\"\n+\tcloudflaredUser       = \"cloudflared\"\n )\n \n var systemdTemplates = []ServiceTemplate{\n@@ -59,6 +60,7 @@ Type=notify\n ExecStart={{ .Path }} --no-autoupdate{{ range .ExtraArgs }} {{ . }}{{ end }}\n Restart=on-failure\n RestartSec=5s\n+User={{ .User }}\n \n [Install]\n WantedBy=multi-user.target\n@@ -194,6 +196,7 @@ func installLinuxService(c *cli.Context) error {\n \t}\n \ttemplateArgs := ServiceTemplateArgs{\n \t\tPath: etPath,\n+\t\tUser: cloudflaredUser,\n \t}\n \n \tvar extraArgsFunc func(c *cli.Context, log *zerolog.Logger) ([]string, error)\n@@ -269,6 +272,13 @@ func installSystemd(templateArgs *ServiceTemplateArgs, log *zerolog.Logger) erro\n \t\t\treturn err\n \t\t}\n \t}\n+\t// Create the cloudflared user if it does not exist\n+\tif err := runCommand(\"id\", cloudflaredUser); err != nil {\n+\t\tif err := runCommand(\"useradd\", \"--system\", \"--no-create-home\", \"--home-dir=/nonexistent\", \"--shell=/usr/sbin/nologin\", cloudflaredUser); err != nil {\n+\t\t\tlog.Err(err).Msgf(\"useradd %s error\", cloudflaredUser)\n+\t\t\treturn err\n+\t\t}\n+\t}\n \tif err := runCommand(\"systemctl\", \"enable\", cloudflaredService); err != nil {\n \t\tlog.Err(err).Msgf(\"systemctl enable %s error\", cloudflaredService)\n \t\treturn err\n@@ -339,6 +349,13 @@ func uninstallSystemd(log *zerolog.Logger) error {\n \t\tlog.Err(err).Msg(\"systemctl stop cloudflared-update.timer error\")\n \t\treturn err\n \t}\n+\t// Delete the cloudflared user if it exists\n+\tif err := runCommand(\"id\", cloudflaredUser); err == nil {\n+\t\tif err := runCommand(\"userdel\", cloudflaredUser); err != nil {\n+\t\t\tlog.Err(err).Msgf(\"userdel %s error\", cloudflaredUser)\n+\t\t\treturn err\n+\t\t}\n+\t}\n \tfor _, serviceTemplate := range systemdTemplates {\n \t\tif err := serviceTemplate.Remove(); err != nil {\n \t\t\tlog.Err(err).Msg(\"error removing service template\")\n---\ncmd/cloudflared/service_template.go\n@@ -25,6 +25,7 @@ type ServiceTemplate struct {\n type ServiceTemplateArgs struct {\n \tPath      string\n \tExtraArgs []string\n+\tUser string\n }\n \n func (st *ServiceTemplate) ResolvePath() (string, error) {\n---\n"}], "ideal": "Title: Issue #672: Run cloudflared service without root\n\nBody: Run the cloudflared service with `cloudflared` user\r\n\r\n* Create user `cloudflared` if it does not exist in `cloudflared service install`\r\n* Remove user `cloudflared` in `cloudflared service uninstall`\r\n* Add `User=cloudflared` in `/etc/systemd/system/cloudflared.service`\r\n\r\nNote: this only works for systemd.\r\n\r\nI tested it in our environment and it worked :)\r\n\r\n![cloudflared-service-up](https://user-images.githubusercontent.com/4235177/191044789-14e34ffc-bc2f-4b04-986e-b0a2804f5ac8.png)\r\n\r\nCloses #672 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -7,8 +7,6 @@ ENV GO111MODULE=on \\\n     TARGET_GOOS=${TARGET_GOOS} \\\n     TARGET_GOARCH=${TARGET_GOARCH}\n     \n-LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n-\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n # copy our sources into the builder image\n@@ -20,6 +18,8 @@ RUN make cloudflared\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian11:nonroot\n \n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n # copy our compiled binary\n COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n---\nDockerfile.amd64\n@@ -3,8 +3,6 @@ FROM golang:1.19 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n-LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n-\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n # copy our sources into the builder image\n@@ -16,6 +14,8 @@ RUN GOOS=linux GOARCH=amd64 make cloudflared\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian11:nonroot\n \n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n # copy our compiled binary\n COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n---\nDockerfile.arm64\n@@ -3,8 +3,6 @@ FROM golang:1.19 as builder\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \n     \n-LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n-\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n # copy our sources into the builder image\n@@ -16,6 +14,8 @@ RUN GOOS=linux GOARCH=arm64 make cloudflared\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian11:nonroot-arm64\n \n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n+\n # copy our compiled binary\n COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n---\n"}], "ideal": "Title: Label correct container\n\nBody: Previous PR #655 added label to the build container, not the final container."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "config/configuration.go\n@@ -30,6 +30,17 @@ var (\n \t// DefaultUnixLogLocation is the primary location to find log files\n \tDefaultUnixLogLocation = \"/var/log/cloudflared\"\n \n+\t// Default paths and env to determin the correct user config dir\n+\tLinuxUserConfigDirEnv   = \"XDG_CONFIG_HOME\"\n+\tLinuxUserConfigDir      = \"~/.config\"\n+\tWindowsUserConfigDirEnv = \"%LOCALAPPDATA%\"\n+\tWindowsUserConfigDir    = \"~/AppData/Local\"\n+\tDarwinUserConfigDir     = \"~/Library/Application Support\"\n+\n+\t// App and Vendor ID used in the filepath\n+\tAppID    = \"cloudflared\"\n+\tVendorID = \"cloudflare\"\n+\n \t// Launchd doesn't set root env variables, so there is default\n \t// Windows default config dir was ~/cloudflare-warp in documentation; let's keep it compatible\n \tdefaultUserConfigDirs = []string{\"~/.cloudflared\", \"~/.cloudflare-warp\", \"~/cloudflare-warp\"}\n@@ -79,8 +90,31 @@ func DefaultConfigPath() string {\n \n // DefaultConfigSearchDirectories returns the default folder locations of the config\n func DefaultConfigSearchDirectories() []string {\n+\tvar defaultDir string\n+\t// Build the default filepath\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\tdefaultDir = os.Getenv(WindowsUserConfigDirEnv)\n+\t\tif defaultDir == \"\" {\n+\t\t\tdefaultDir = WindowsUserConfigDir\n+\t\t}\n+\t\tdefaultDir = filepath.Join(defaultDir, VendorID, AppID)\n+\tcase \"linux\":\n+\t\tdefaultDir = os.Getenv(LinuxUserConfigDirEnv)\n+\t\tif defaultDir == \"\" {\n+\t\t\tdefaultDir = LinuxUserConfigDir\n+\t\t}\n+\t\tdefaultDir = filepath.Join(defaultDir, AppID)\n+\tcase \"darwin\":\n+\t\tdefaultDir = filepath.Join(DarwinUserConfigDir, \"com.\"+VendorID+\".\"+AppID)\n+\t}\n+\n \tdirs := make([]string, len(defaultUserConfigDirs))\n \tcopy(dirs, defaultUserConfigDirs)\n+\tif defaultDir != \"\" {\n+\t\tdirs = append([]string{defaultDir}, dirs...)\n+\t}\n+\n \tif runtime.GOOS != \"windows\" {\n \t\tdirs = append(dirs, defaultNixConfigDirs...)\n \t}\n---\n"}], "ideal": "Title: configuration: Follow XDG Base Directory standard for appropriate environments\n\nBody: imlements: #119\r\n\r\n### What it does:\r\nFollows the XDG Base Directory standard for the user config dir.\r\nIt uses [github.com/adrg/xdg](https://github.com/adrg/xdg) to find the right dir. It will try to resolve the `$XDG_CONFIG_HOME` and revert to the platform specific default ones.\r\n\r\nPrior directories will still work (similar to the old windows `~/cloudflare-warp`).\r\nI've implemented it on all Platforms but don't know how used they are on OSX or Windows so if desired I'll only enable it on Linux.\r\n\r\n### What it doesn't:\r\nIt does not implement the xdg spec regarding `/etc/xdg/cloudflared` as It isn't commonly used, with the only big software using it on my system being systemd which symlinks back to /etc/systemd. Further the dir isn't used at all on any of my servers which I guess is the primary client of `/etc/cloudfalre`.\r\nAlso the issue did mention the cleanup of `$HOME`and not the full implementation of the spec ;)\r\n\r\n#### Links\r\n- https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/subcommands.go\n@@ -801,7 +801,7 @@ Further information about managing Cloudflare WARP traffic to your tunnel is ava\n \t\t\t\tName:        \"lb\",\n \t\t\t\tAction:      cliutil.ConfiguredAction(routeLbCommand),\n \t\t\t\tUsage:       \"Use this tunnel as a load balancer origin, creating pool and load balancer if necessary\",\n-\t\t\t\tUsageText:   \"cloudflared tunnel route dns [TUNNEL] [HOSTNAME] [LB-POOL]\",\n+\t\t\t\tUsageText:   \"cloudflared tunnel route lb [TUNNEL] [HOSTNAME] [LB-POOL]\",\n \t\t\t\tDescription: `Creates Load Balancer with an origin pool that points to the tunnel.`,\n \t\t\t},\n \t\t\tbuildRouteIPSubcommand(),\n---\n"}], "ideal": "Title: Fix typo in help text for `cloudflared tunnel route lb`\n\nBody: Fixes #729 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -27,3 +27,6 @@ USER nonroot\n # command / entrypoint of container\n ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n CMD [\"version\"]\n+\n+# expose metrics server\n+EXPOSE 2000\n---\nconfig/configuration.go\n@@ -177,10 +177,11 @@ func ValidateUrl(c *cli.Context, allowURLFromArgs bool) (*url.URL, error) {\n }\n \n type UnvalidatedIngressRule struct {\n-\tHostname      string              `json:\"hostname,omitempty\"`\n-\tPath          string              `json:\"path,omitempty\"`\n-\tService       string              `json:\"service,omitempty\"`\n-\tOriginRequest OriginRequestConfig `yaml:\"originRequest\" json:\"originRequest\"`\n+\tHostname      string              `yaml:\"hostname,omitempty\" json:\"hostname,omitempty\"`\n+\tPath          string              `yaml:\"path,omitempty\" json:\"path,omitempty\"`\n+\tService       string              `yaml:\"service,omitempty\" json:\"service,omitempty\"`\n+\tLocation      string              `yaml:\"location,omitempty\" json:\"location,omitempty\"`\n+\tOriginRequest OriginRequestConfig `yaml:\"originRequest,omitempty\" yaml:\"originRequest\" json:\"originRequest\"`\n }\n \n // OriginRequestConfig is a set of optional fields that users may set to\n@@ -192,41 +193,41 @@ type UnvalidatedIngressRule struct {\n // - To specify a time.Duration in json, use int64 of the nanoseconds\n type OriginRequestConfig struct {\n \t// HTTP proxy timeout for establishing a new connection\n-\tConnectTimeout *CustomDuration `yaml:\"connectTimeout\" json:\"connectTimeout,omitempty\"`\n+\tConnectTimeout *CustomDuration `yaml:\"connectTimeout,omitempty\" json:\"connectTimeout,omitempty\"`\n \t// HTTP proxy timeout for completing a TLS handshake\n-\tTLSTimeout *CustomDuration `yaml:\"tlsTimeout\" json:\"tlsTimeout,omitempty\"`\n+\tTLSTimeout *CustomDuration `yaml:\"tlsTimeout,omitempty\" json:\"tlsTimeout,omitempty\"`\n \t// HTTP proxy TCP keepalive duration\n-\tTCPKeepAlive *CustomDuration `yaml:\"tcpKeepAlive\" json:\"tcpKeepAlive,omitempty\"`\n+\tTCPKeepAlive *CustomDuration `yaml:\"tcpKeepAlive,omitempty\" json:\"tcpKeepAlive,omitempty\"`\n \t// HTTP proxy should disable \"happy eyeballs\" for IPv4/v6 fallback\n-\tNoHappyEyeballs *bool `yaml:\"noHappyEyeballs\" json:\"noHappyEyeballs,omitempty\"`\n+\tNoHappyEyeballs *bool `yaml:\"noHappyEyeballs,omitempty\" json:\"noHappyEyeballs,omitempty\"`\n \t// HTTP proxy maximum keepalive connection pool size\n-\tKeepAliveConnections *int `yaml:\"keepAliveConnections\" json:\"keepAliveConnections,omitempty\"`\n+\tKeepAliveConnections *int `yaml:\"keepAliveConnections,omitempty\" json:\"keepAliveConnections,omitempty\"`\n \t// HTTP proxy timeout for closing an idle connection\n-\tKeepAliveTimeout *CustomDuration `yaml:\"keepAliveTimeout\" json:\"keepAliveTimeout,omitempty\"`\n+\tKeepAliveTimeout *CustomDuration `yaml:\"keepAliveTimeout,omitempty\" json:\"keepAliveTimeout,omitempty\"`\n \t// Sets the HTTP Host header for the local webserver.\n-\tHTTPHostHeader *string `yaml:\"httpHostHeader\" json:\"httpHostHeader,omitempty\"`\n+\tHTTPHostHeader *string `yaml:\"httpHostHeader,omitempty\" json:\"httpHostHeader,omitempty\"`\n \t// Hostname on the origin server certificate.\n-\tOriginServerName *string `yaml:\"originServerName\" json:\"originServerName,omitempty\"`\n+\tOriginServerName *string `yaml:\"originServerName,omitempty\" json:\"originServerName,omitempty\"`\n \t// Path to the CA for the certificate of your origin.\n \t// This option should be used only if your certificate is not signed by Cloudflare.\n-\tCAPool *string `yaml:\"caPool\" json:\"caPool,omitempty\"`\n+\tCAPool *string `yaml:\"caPool,omitempty\" json:\"caPool,omitempty\"`\n \t// Disables TLS verification of the certificate presented by your origin.\n \t// Will allow any certificate from the origin to be accepted.\n \t// Note: The connection from your machine to Cloudflare's Edge is still encrypted.\n-\tNoTLSVerify *bool `yaml:\"noTLSVerify\" json:\"noTLSVerify,omitempty\"`\n+\tNoTLSVerify *bool `yaml:\"noTLSVerify,omitempty\" json:\"noTLSVerify,omitempty\"`\n \t// Disables chunked transfer encoding.\n \t// Useful if you are running a WSGI server.\n-\tDisableChunkedEncoding *bool `yaml:\"disableChunkedEncoding\" json:\"disableChunkedEncoding,omitempty\"`\n+\tDisableChunkedEncoding *bool `yaml:\"disableChunkedEncoding,omitempty\" json:\"disableChunkedEncoding,omitempty\"`\n \t// Runs as jump host\n-\tBastionMode *bool `yaml:\"bastionMode\" json:\"bastionMode,omitempty\"`\n+\tBastionMode *bool `yaml:\"bastionMode,omitempty\" json:\"bastionMode,omitempty\"`\n \t// Listen address for the proxy.\n-\tProxyAddress *string `yaml:\"proxyAddress\" json:\"proxyAddress,omitempty\"`\n+\tProxyAddress *string `yaml:\"proxyAddress,omitempty\" json:\"proxyAddress,omitempty\"`\n \t// Listen port for the proxy.\n-\tProxyPort *uint `yaml:\"proxyPort\" json:\"proxyPort,omitempty\"`\n+\tProxyPort *uint `yaml:\"proxyPort,omitempty\" json:\"proxyPort,omitempty\"`\n \t// Valid options are 'socks' or empty.\n-\tProxyType *string `yaml:\"proxyType\" json:\"proxyType,omitempty\"`\n+\tProxyType *string `yaml:\"proxyType,omitempty\" json:\"proxyType,omitempty\"`\n \t// IP rules for the proxy service\n-\tIPRules []IngressIPRule `yaml:\"ipRules\" json:\"ipRules,omitempty\"`\n+\tIPRules []IngressIPRule `yaml:\"ipRules,omitempty\" json:\"ipRules,omitempty\"`\n }\n \n type IngressIPRule struct {\n@@ -238,8 +239,8 @@ type IngressIPRule struct {\n type Configuration struct {\n \tTunnelID      string `yaml:\"tunnel\"`\n \tIngress       []UnvalidatedIngressRule\n-\tWarpRouting   WarpRoutingConfig   `yaml:\"warp-routing\"`\n-\tOriginRequest OriginRequestConfig `yaml:\"originRequest\"`\n+\tWarpRouting   WarpRoutingConfig   `yaml:\"warp-routing,omitempty\"`\n+\tOriginRequest OriginRequestConfig `yaml:\"originRequest,omitempty\"`\n \tsourceFile    string\n }\n \n---\ningress/ingress.go\n@@ -244,6 +244,7 @@ func validateIngress(ingress []config.UnvalidatedIngressRule, defaults OriginReq\n \t\t\tHostname: r.Hostname,\n \t\t\tService:  service,\n \t\t\tPath:     pathRegexp,\n+\t\t\tLocation: r.Location,\n \t\t\tConfig:   cfg,\n \t\t}\n \t}\n---\ningress/rule.go\n@@ -20,6 +20,10 @@ type Rule struct {\n \t// address.\n \tService OriginService `json:\"service\"`\n \n+\t// Location is an optional string specifying the Service path, which\n+\t// replaces the first subdirectory of the Hostname path\n+\tLocation string `json:\"location\"`\n+\n \t// Configure the request cloudflared sends to this specific origin.\n \tConfig OriginRequestConfig `json:\"originRequest\"`\n }\n---\nproxy/proxy.go\n@@ -6,7 +6,9 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n+\t\"path\"\n \t\"strconv\"\n+\t\"strings\"\n \n \t\"github.com/pkg/errors\"\n \t\"github.com/rs/zerolog\"\n@@ -86,6 +88,20 @@ func (p *Proxy) ProxyHTTP(\n \truleSpan.SetAttributes(attribute.Int(\"rule-num\", ruleNum))\n \truleSpan.End()\n \n+\tif rule.Location != \"\" {\n+\t\tfmt.Println(fmt.Sprintf(\"before: req.URL.Path: %s\", req.URL.Path))\n+\n+\t\tparts := strings.Split(req.URL.Path, \"/\")\n+\t\t// fmt.Println(\"parts:\", parts)\n+\n+\t\tif len(parts) > 1 {\n+\t\t\tparts[1] = rule.Location\n+\t\t}\n+\n+\t\treq.URL.Path = path.Clean(strings.Join(parts, \"/\"))\n+\t\tfmt.Println(fmt.Sprintf(\"after: req.URL.Path: %s\", req.URL.Path))\n+\t}\n+\n \tswitch originProxy := rule.Service.(type) {\n \tcase ingress.HTTPOriginProxy:\n \t\tif err := p.proxyHTTPRequest(\n---\n"}], "ideal": "Title: Regnaio/location\n\nBody: as"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -2,10 +2,12 @@\n ARG TARGET_GOOS\n ARG TARGET_GOARCH\n FROM golang:1.17.1 as builder\n+ARG TARGET_GOOS\n+ARG TARGET_GOARCH\n ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \\\n-    TARGET_GOOS=${TARGET_GOOS} \\\n-    TARGET_GOARCH=${TARGET_GOARCH}\n+    TARGET_OS=${TARGET_GOOS} \\\n+    TARGET_ARCH=${TARGET_GOARCH}\n     \n LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n \n---\n"}], "ideal": "Title: Fix: Replace TARGET_GOOS and TARGET_GOARCH with TARGET_OS and TARGET_ARCH\n\nBody: There is a mismatch between the environment name in the docker file and what the makefile is expecting:\r\n* https://github.com/cloudflare/cloudflared/blob/master/Makefile#L78\r\n* https://github.com/cloudflare/cloudflared/blob/master/Makefile#L69\r\n\r\nYou also need to declare the `ARG` inside the `FROM` if you intend to use it in the build stage. See https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -6,6 +6,8 @@ ENV GO111MODULE=on \\\n     CGO_ENABLED=0 \\\n     TARGET_GOOS=${TARGET_GOOS} \\\n     TARGET_GOARCH=${TARGET_GOARCH}\n+    \n+LABEL org.opencontainers.image.source=\"https://github.com/cloudflare/cloudflared\"\n \n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n---\n"}], "ideal": "Title: Add image source label to docker container.\n\nBody: This label allows tools like [whitesource renovate](https://docs.renovatebot.com/modules/datasource/#docker-datasource) to find changelogs."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "README.md\n@@ -43,7 +43,7 @@ Once installed, you can authenticate `cloudflared` into your Cloudflare account\n * Route traffic to that Tunnel:\n   * Via public [DNS records in Cloudflare](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/routing-to-tunnel/dns)\n   * Or via a public hostname guided by a [Cloudflare Load Balancer](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/routing-to-tunnel/lb)\n-  * Or from [WARP client private traffic](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configuration/private-networks)\n+  * Or from [WARP client private traffic](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/private-net/)\n \n \n ## TryCloudflare\n---\n"}], "ideal": "Title: Warp Private Network link updated\n\nBody: The old one was returning 404"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "ingress/origin_service.go\n@@ -284,6 +284,7 @@ func newHTTPTransport(service OriginService, cfg OriginRequestConfig, log *zerol\n \t\tTLSHandshakeTimeout:   cfg.TLSTimeout.Duration,\n \t\tExpectContinueTimeout: 1 * time.Second,\n \t\tTLSClientConfig:       &tls.Config{RootCAs: originCertPool, InsecureSkipVerify: cfg.NoTLSVerify},\n+\t\tForceAttemptHTTP2:     true,\n \t}\n \tif _, isHelloWorld := service.(*helloWorld); !isHelloWorld && cfg.OriginServerName != \"\" {\n \t\thttpTransport.TLSClientConfig.ServerName = cfg.OriginServerName\n---\ntunneldns/https_upstream.go\n@@ -135,6 +135,7 @@ func configureClient(hostname string, maxUpstreamConnections int) *http.Client {\n \t\tMaxIdleConns:       1,\n \t\tMaxConnsPerHost:    maxUpstreamConnections,\n \t\tProxy:              http.ProxyFromEnvironment,\n+\t\tForceAttemptHTTP2:  true,\n \t}\n \t_ = http2.ConfigureTransport(transport)\n \n---\n"}], "ideal": "Title: Set ForceAttemptHTTP2 on http.Transport to auto support HTTP/2\n\nBody: [`ForceAttempHTTP2` doc](https://github.com/golang/go/blob/go1.17.9/src/net/http/transport.go#L278-L283):\r\n```go\r\n    ...\r\n    // ForceAttemptHTTP2 controls whether HTTP/2 is enabled when a non-zero\r\n    // Dial, DialTLS, or DialContext func or TLSClientConfig is provided.\r\n    // By default, use of any those fields conservatively disables HTTP/2.\r\n    // To use a custom dialer or TLS config and still attempt HTTP/2\r\n    // upgrades, set this to true.\r\n    ForceAttemptHTTP2 bool\r\n    ...\r\n```\r\n\r\nFound two instances of `http.Transport` instantiations where it needed to set `ForceAttemptHTTP2` boolean, in order to automatically enable HTTP/2 support; others are not needy, according to docs.\r\n\r\n> Just to mention, there is also the [`http2.ConfigureTransport`](https://pkg.go.dev/golang.org/x/net/http2#ConfigureTransport) function that enables HTTP/2 support for an `http.Transport` instance, the **manual** way; it's used once in the [Cloudflare API base client](https://github.com/cloudflare/cloudflared/blob/8a07a900fde36efe48fd27ad5f974273015e8270/cfapi/base_client.go#L71).\r\n\r\nCloses #625."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".github/workflows/docker-ci-test.yml\n@@ -0,0 +1,37 @@\n+name: push-images-test\n+\n+on:\n+  schedule:\n+      - cron: \"0 0 */3 * *\"\n+  workflow_dispatch:\n+\n+env:\n+  REGISTRY: docker.io\n+  IMAGE_NAME: initdc/cloudflared\n+\n+jobs:\n+  buildx:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout\n+        uses: actions/checkout@v2\n+      - name: Set up QEMU\n+        uses: docker/setup-qemu-action@v1\n+      - name: Set up Docker Buildx\n+        uses: docker/setup-buildx-action@v1\n+      - name: Login to DockerHub\n+        uses: docker/login-action@v1\n+        with:\n+          username: ${{ secrets.DOCKER_USERNAME }}\n+          password: ${{ secrets.DOCKER_TOKEN }}\n+      - name: Extract Docker metadata\n+        id: meta\n+        uses: docker/metadata-action@v3\n+        with:\n+          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n+      - name: Build and push Docker image\n+        run: |\n+          set -e\n+          docker buildx ls\n+          docker buildx build --platform linux/amd64,linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/386,linux/arm/v7,linux/arm/v6 -t initdc/cloudflared:v$(TZ=Asia/Shanghai date +%Y.%m.%d) . --push\n+          docker buildx build --platform linux/amd64,linux/arm64,linux/riscv64,linux/ppc64le,linux/s390x,linux/386,linux/arm/v7,linux/arm/v6 -t initdc/cloudflared:latest . --push\n---\n.github/workflows/docker-ci.yml\n@@ -0,0 +1,47 @@\n+name: push-images\n+\n+on:\n+  workflow_dispatch:\n+\n+env:\n+  REGISTRY: docker.io\n+  IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/cloudflared\n+\n+jobs:\n+  buildx:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout\n+        uses: actions/checkout@v2\n+      - name: Set up QEMU\n+        uses: docker/setup-qemu-action@v1\n+      - name: Set up Docker Buildx\n+        uses: docker/setup-buildx-action@v1\n+      - name: Login to DockerHub\n+        uses: docker/login-action@v1\n+        with:\n+          username: ${{ secrets.DOCKER_USERNAME }}\n+          password: ${{ secrets.DOCKER_TOKEN }}\n+      - name: Extract Docker metadata\n+        id: meta\n+        uses: docker/metadata-action@v3\n+        with:\n+          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n+      - name: Build and push Docker image\n+        uses: docker/build-push-action@v2\n+        with:\n+          context: .\n+          platforms: |\n+            linux/amd64\n+            linux/arm64\n+            linux/riscv64\n+            linux/ppc64le\n+            linux/s390x\n+            linux/386\n+            linux/mips64le\n+            linux/mips64\n+            linux/arm/v7\n+            linux/arm/v6\n+          tags: |\n+            ${{ env.IMAGE_NAME }}:latest\n+          labels: ${{ steps.meta.outputs.labels }}\n---\nDockerfile\n@@ -1,29 +1,51 @@\n-# use a builder image for building cloudflare\n-ARG TARGET_GOOS\n-ARG TARGET_GOARCH\n-FROM golang:1.17.1 as builder\n+# syntax=docker/dockerfile:1\n+FROM --platform=$BUILDPLATFORM golang:1.17.5 as build\n+ARG TARGETPLATFORM\n+ARG BUILDPLATFORM\n+\n ENV GO111MODULE=on \\\n-    CGO_ENABLED=0 \\\n-    TARGET_GOOS=${TARGET_GOOS} \\\n-    TARGET_GOARCH=${TARGET_GOARCH}\n+    CGO_ENABLED=0 \n+\n+ENV FIPS=false\n \n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n-# copy our sources into the builder image\n+# build with github tags\n+#ADD https://github.com/cloudflare/cloudflared/archive/refs/tags/2022.4.0.zip\n+\n COPY . .\n \n # compile cloudflared\n-RUN make cloudflared\n+RUN set -e \\\n+    && echo \"Running on $BUILDPLATFORM, building for $TARGETPLATFORM\" \\\n+    && apt-get update \\\n+    && apt-get install --no-install-recommends -y ruby \\\n+    && ruby docker-env.rb\n+\n+FROM --platform=$TARGETPLATFORM alpine:edge\n+\n+# ref: https://github.com/crazy-max/docker-cloudflared/blob/master/Dockerfile#L25\n+ENV TUNNEL_METRICS=\"0.0.0.0:49312\" \n+    # TUNNEL_DNS_ADDRESS=\"0.0.0.0\" \\\n+    # TUNNEL_DNS_PORT=\"53\" \\\n+    # TUNNEL_DNS_UPSTREAM=\"https://1.1.1.1/dns-query,https://1.0.0.1/dns-query\"\n+\n+COPY --from=build /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/cloudflared\n+\n+# ref: https://pkgs.alpinelinux.org/contents?file=dig\n+RUN set -e \\\n+    && apk add --no-cache ca-certificates nano curl bind-tools\n \n-# use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian10:nonroot\n+WORKDIR /root\n \n-# copy our compiled binary\n-COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+# ref: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/dns-over-https-client/\n+EXPOSE 53/udp\n+# ref: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configuration/ports-and-ips/\n+EXPOSE 443\n+EXPOSE 7844\n+EXPOSE 7844/udp\n \n-# run as non-privileged user\n-USER nonroot\n+# Don't set entrypoint, user need edit config file\n+CMD [\"/bin/sh\"]\n \n-# command / entrypoint of container\n-ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n-CMD [\"version\"]\n+HEALTHCHECK CMD (curl --fail http://127.0.0.1:49312/ready || dig +short @127.0.0.1 -p 53 cloudflare.com A) || exit 1\n\\ No newline at end of file\n---\ndocker-env.rb\n@@ -0,0 +1,17 @@\n+#!/usr/bin/ruby -w\n+\n+TargetPlatform = ENV.fetch('TARGETPLATFORM')\n+TPArray = TargetPlatform.split('/')\n+\n+# ref: https://github.com/containerd/containerd/blob/v1.4.3/platforms/defaults.go\n+OS = TPArray[0]\n+Architecture = TPArray[1]\n+Variant = TPArray[2].to_s[1]\n+\n+puts \"GOOS=#{OS} GOARCH=#{Architecture} GOARM=#{Variant}\"\n+\n+if Variant == ''\n+    `GOOS=#{OS} GOARCH=#{Architecture} make cloudflared`\n+else\n+    `GOOS=#{OS} GOARCH=#{Architecture} GOARM=#{Variant}  make cloudflared`\n+end\n---\n"}], "ideal": "Title: feat(docker): build docker images with buildkit, add actions\n\nBody: hello, I add docker build workflow for cloudflared. I am learning buildx near time, and I feel good.\r\n\r\nIt may also helpful in your bin distro.\r\n\r\nEdit docker `tags`, actions `user` `token` by your own.\r\n\r\nI found a problem, user can't run docker with `-it`, because image `FROM scratch`\r\nbut it's useful for cross-compiling.\r\n\r\nIt may need two kind Dockerfile\r\n\r\ncheck more usage from: \r\n- https://github.com/initdc/ssh-proxy-by-caddy-l4\r\n- https://hub.docker.com/r/initdc/cloudflared"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "carrier/websocket.go\n@@ -55,6 +55,9 @@ func createWebsocketStream(options *StartOptions, log *zerolog.Logger) (*cfwebso\n \t}\n \n \tdump, err := httputil.DumpRequest(req, false)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \tlog.Debug().Msgf(\"Websocket request: %s\", string(dump))\n \n \tdialer := &websocket.Dialer{\n@@ -182,6 +185,9 @@ func createAccessWebSocketStream(options *StartOptions, log *zerolog.Logger) (*w\n \t}\n \n \tdump, err := httputil.DumpRequest(req, false)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n \tlog.Debug().Msgf(\"Access Websocket request: %s\", string(dump))\n \n \tconn, resp, err := clientConnect(req, nil)\n---\n"}], "ideal": "Title: carrier: fix dropped errors\n\nBody: This fixes two dropped websocket errors in the `carrier` package."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "datagramsession/session_test.go\n@@ -111,8 +111,8 @@ func TestReadFromDstSessionPreventClosed(t *testing.T) {\n }\n \n func testActiveSessionNotClosed(t *testing.T, readFromDst bool, writeToDst bool) {\n-\tconst closeAfterIdle = time.Millisecond * 100\n-\tconst activeTime = time.Millisecond * 500\n+\tconst closeAfterIdle = time.Millisecond * 500\n+\tconst activeTime = time.Millisecond * 1000\n \n \tsessionID := uuid.New()\n \tcfdConn, originConn := net.Pipe()\n@@ -129,8 +129,10 @@ func testActiveSessionNotClosed(t *testing.T, readFromDst bool, writeToDst bool)\n \tctx, cancel := context.WithCancel(context.Background())\n \terrGroup, ctx := errgroup.WithContext(ctx)\n \terrGroup.Go(func() error {\n-\t\tsession.Serve(ctx, closeAfterIdle)\n-\t\tif time.Now().Before(startTime.Add(activeTime)) {\n+\t\tclosed, err := session.Serve(ctx, closeAfterIdle)\n+\t\trequire.False(t, closed) // session not closed by remote\n+\t\trequire.EqualError(t, err, SessionIdleErr(closeAfterIdle).Error())\n+\t\tif time.Now().Before(activeUntil) {\n \t\t\treturn fmt.Errorf(\"session closed while it's still active\")\n \t\t}\n \t\treturn nil\n---\nh2mux/h2mux_test.go\n@@ -823,7 +823,7 @@ func TestMultipleStreamsWithDictionaries(t *testing.T) {\n \t\t}\n \n \t\toriginMuxMetrics := muxPair.OriginMux.Metrics()\n-\t\tif q > CompressionNone && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n+\t\tif q > CompressionNone && CompressionIsSupported() && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n \t\t\tt.Fatalf(\"Cross-stream compression is expected to give a better compression ratio\")\n \t\t}\n \t}\n@@ -952,7 +952,7 @@ func TestSampleSiteWithDictionaries(t *testing.T) {\n \t\t}\n \n \t\toriginMuxMetrics := muxPair.OriginMux.Metrics()\n-\t\tif q > CompressionNone && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n+\t\tif q > CompressionNone && CompressionIsSupported() && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n \t\t\tt.Fatalf(\"Cross-stream compression is expected to give a better compression ratio\")\n \t\t}\n \t}\n@@ -985,7 +985,7 @@ func TestLongSiteWithDictionaries(t *testing.T) {\n \t\tassert.NoError(t, errGroup.Wait())\n \n \t\toriginMuxMetrics := muxPair.OriginMux.Metrics()\n-\t\tif q > CompressionNone && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n+\t\tif q > CompressionNone && CompressionIsSupported() && originMuxMetrics.CompBytesBefore.Value() <= 10*originMuxMetrics.CompBytesAfter.Value() {\n \t\t\tt.Fatalf(\"Cross-stream compression is expected to give a better compression ratio\")\n \t\t}\n \t}\n---\n"}], "ideal": "Title: Addressing h2mux and session flaky tests\n\nBody: Updating some tests to try and appease CI flaky tests.\r\n\r\n- Correct some h2mux tests on windows without CGO_ENABLED: Compression isn't supported without cgo on windows environments so the h2mux tests need to ignore compression.\r\n   - TestMultipleStreamsWithDictionaries, TestSampleSiteWithDictionaries, TestLongSiteWithDictionaries\r\n- TestReadFromDstSessionPreventClosed occasionally will fail because the session closes in the idle time. This might be because of all the tests running in parallel in separate goroutines and the 100ms time limit is exceeded. Bumping this idle time and execution window up may help reduce the flaky failures for these tests"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -274,7 +274,7 @@ func StartServer(\n \tlogClientOptions(c, log)\n \n \t// this context drives the server, when it's cancelled tunnel and all other components (origins, dns, etc...) should stop\n-\tctx, cancel := context.WithCancel(context.Background())\n+\tctx, cancel := context.WithCancel(c.Context)\n \tdefer cancel()\n \n \tgo waitForSignal(graceShutdownC, log)\n---\n"}], "ideal": "Title: Use CLI context when running tunnel\n\nBody: When embedding the tunnel command inside another CLI, it\r\nbecame difficult to test shutdown behavior due to this leaking\r\ntunnel. By using the command context, we're able to shutdown\r\ngracefully."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "supervisor/tunnel.go\n@@ -254,8 +254,9 @@ func (e *EdgeTunnelServer) Serve(ctx context.Context, connIndex uint8, protocolF\n \t\tif !ok {\n \t\t\treturn err\n \t\t}\n+\n \t\te.config.Observer.SendReconnect(connIndex)\n-\t\tconnLog.Logger().Info().Msgf(\"Retrying connection in up to %s seconds\", duration)\n+\t\tconnLog.Logger().Info().Msgf(\"Retrying connection in up to %s\", duration)\n \t}\n \n \t// Check if the connection error was from an IP issue with the host or\n---\n"}], "ideal": "Title: Fix log message\n\nBody: printing `seconds` is superfluous since time.Duration already adds the `s` suffix\r\n\r\nInvalid log message would be\r\n```\r\nRetrying connection in up to 1s seconds\r\n```"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/service_template.go\n@@ -8,6 +8,7 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"path\"\n \t\"text/template\"\n \n \thomedir \"github.com/mitchellh/go-homedir\"\n@@ -52,10 +53,17 @@ func (st *ServiceTemplate) Generate(args *ServiceTemplateArgs) error {\n \tif err != nil {\n \t\treturn fmt.Errorf(\"error generating %s: %v\", st.Path, err)\n \t}\n-\tfileMode := os.FileMode(0644)\n+\tfileMode := os.FileMode(0o644)\n \tif st.FileMode != 0 {\n \t\tfileMode = st.FileMode\n \t}\n+\n+\tplistFolder := path.Dir(resolvedPath)\n+\terr = os.MkdirAll(plistFolder, 0o755)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"error creating %s: %v\", plistFolder, err)\n+\t}\n+\n \terr = ioutil.WriteFile(resolvedPath, buffer.Bytes(), fileMode)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"error writing %s: %v\", resolvedPath, err)\n---\n"}], "ideal": "Title: Ensure service install directories are created before writing file\n\nBody: Service install fails on a fresh macOS install"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "origin/proxy.go\n@@ -177,6 +177,11 @@ func (p *Proxy) proxyHTTPRequest(\n \t\troundTripReq.Header.Set(\"Connection\", \"keep-alive\")\n \t}\n \n+\t// Set the User-Agent as an empty string if not provided to avoid inserting golang default UA\n+\tif roundTripReq.Header.Get(\"User-Agent\") == \"\" {\n+\t\troundTripReq.Header.Set(\"User-Agent\", \"\")\n+\t}\n+\n \tresp, err := httpService.RoundTrip(roundTripReq)\n \tif err != nil {\n \t\treturn errors.Wrap(err, \"Unable to reach the origin service. The service may be down or it may not be responding to traffic from cloudflared\")\n---\n"}], "ideal": "Title: Fix for Issue #501: Unexpected User-agent insertion when tunneling http request\n\nBody: When forwarding an UA-less request to the origin server cloudflared insert the default golang http User-Agent, this is unexpected and so can lead to issue.\r\n\r\nThis simple fix force setting the UA to the empty string when it isn't originaly provided."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "ingress/origin_proxy.go\n@@ -40,6 +40,8 @@ func (o *httpService) RoundTrip(req *http.Request) (*http.Response, error) {\n \n \tif o.hostHeader != \"\" {\n \t\t// For incoming requests, the Host header is promoted to the Request.Host field and removed from the Header map.\n+\t\t// Pass the original Host header as X-Forwarded-Host.\n+\t\treq.Header.Set(\"X-Forwarded-Host\", req.Host)\n \t\treq.Host = o.hostHeader\n \t}\n \treturn o.transport.RoundTrip(req)\n---\ningress/origin_proxy_test.go\n@@ -3,6 +3,7 @@ package ingress\n import (\n \t\"context\"\n \t\"fmt\"\n+\t\"io/ioutil\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n@@ -118,7 +119,9 @@ func TestHTTPServiceHostHeaderOverride(t *testing.T) {\n \t\t\tw.WriteHeader(http.StatusSwitchingProtocols)\n \t\t\treturn\n \t\t}\n-\t\tw.Write([]byte(\"ok\"))\n+\t\t// return the X-Forwarded-Host header for assertions\n+\t\t// as the httptest Server URL isn't available here yet\n+\t\tw.Write([]byte(r.Header.Get(\"X-Forwarded-Host\")))\n \t}\n \torigin := httptest.NewServer(http.HandlerFunc(handler))\n \tdefer origin.Close()\n@@ -141,6 +144,10 @@ func TestHTTPServiceHostHeaderOverride(t *testing.T) {\n \trequire.NoError(t, err)\n \trequire.Equal(t, http.StatusOK, resp.StatusCode)\n \n+\trespBody, err := ioutil.ReadAll(resp.Body)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, respBody, []byte(originURL.Host))\n+\n }\n \n func tcpListenRoutine(listener net.Listener, closeChan chan struct{}) {\n---\n"}], "ideal": "Title: Add X-Forwarded-Host for http proxy\n\nBody: Adding [`X-Forwarded-Host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host) header to the http proxy.\r\n\r\nThis can be helpful in the case when the service in the ingress rule is another reverse proxy(call this 2nd reverse proxy), and the 2nd reverse proxy wants to pass original host to the backend application. So it becomes:\r\n\r\nOriginal request:\r\n\r\n```\r\nmydns.on.cloudflare <---- customer request\r\n        |\r\n        |\r\ncloudflared\r\n  - hostname: mydns.on.cloudflare\r\n    service: 2nd-proxy.some.internal\r\n```\r\n\r\nSo in the `2nd-proxy.some.internal`, it listens ` 2nd-proxy.some.internal` and can read `$http_x_forwarded_host` and pass it to the application.\r\n\r\nIf the idea makes sense, maybe we want to add a new config option, as well as tests/docs update."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -181,7 +181,8 @@ func Init(ver string, gracefulShutdown chan struct{}) {\n func runAdhocNamedTunnel(sc *subcommandContext, name, credentialsOutputPath string) error {\n \ttunnel, ok, err := sc.tunnelActive(name)\n \tif err != nil || !ok {\n-\t\ttunnel, err = sc.create(name, credentialsOutputPath)\n+\t\t// pass empty string as secret to generate one\n+\t\ttunnel, err = sc.create(name, credentialsOutputPath, \"\")\n \t\tif err != nil {\n \t\t\treturn errors.Wrap(err, \"failed to create tunnel\")\n \t\t}\n---\ncmd/cloudflared/tunnel/subcommand_context.go\n@@ -1,6 +1,7 @@\n package tunnel\n \n import (\n+\t\"encoding/base64\"\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"os\"\n@@ -148,15 +149,27 @@ func (sc *subcommandContext) readTunnelCredentials(credFinder CredFinder) (conne\n \treturn credentials, nil\n }\n \n-func (sc *subcommandContext) create(name string, credentialsFilePath string) (*tunnelstore.Tunnel, error) {\n+func (sc *subcommandContext) create(name string, credentialsFilePath string, secret string) (*tunnelstore.Tunnel, error) {\n \tclient, err := sc.client()\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"couldn't create client to talk to Cloudflare Tunnel backend\")\n \t}\n \n-\ttunnelSecret, err := generateTunnelSecret()\n-\tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"couldn't generate the secret for your new tunnel\")\n+\tvar tunnelSecret []byte\n+\tif secret == \"\" {\n+\t\ttunnelSecret, err = generateTunnelSecret()\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrap(err, \"couldn't generate the secret for your new tunnel\")\n+\t\t}\n+\t} else {\n+\t\tdecodedSecret, err := base64.StdEncoding.DecodeString(secret)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrap(err, \"Couldn't decode tunnel secret from base64\")\n+\t\t}\n+\t\ttunnelSecret = []byte(decodedSecret)\n+\t\tif len(tunnelSecret) < 32 {\n+\t\t\treturn nil, errors.New(\"Decoded tunnel secret must be at least 32 bytes long\")\n+\t\t}\n \t}\n \n \ttunnel, err := client.CreateTunnel(name, tunnelSecret)\n---\ncmd/cloudflared/tunnel/subcommands.go\n@@ -156,6 +156,12 @@ var (\n \t\tUsage:   `Overwrites existing DNS records with this hostname`,\n \t\tEnvVars: []string{\"TUNNEL_FORCE_PROVISIONING_DNS\"},\n \t}\n+\tcreateSecretFlag = &cli.StringFlag{\n+\t\tName:    \"secret\",\n+\t\tAliases: []string{\"s\"},\n+\t\tUsage:   \"Base64 encoded secret to set for the tunnel. The decoded secret must be at least 32 bytes long. If not specified, a random 32-byte secret will be generated.\",\n+\t\tEnvVars: []string{\"TUNNEL_CREATE_SECRET\"},\n+\t}\n )\n \n func buildCreateCommand() *cli.Command {\n@@ -170,7 +176,7 @@ func buildCreateCommand() *cli.Command {\n   For example, to create a tunnel named 'my-tunnel' run:\n \n   $ cloudflared tunnel create my-tunnel`,\n-\t\tFlags:              []cli.Flag{outputFormatFlag, credentialsFileFlagCLIOnly},\n+\t\tFlags:              []cli.Flag{outputFormatFlag, credentialsFileFlagCLIOnly, createSecretFlag},\n \t\tCustomHelpTemplate: commandHelpTemplate(),\n \t}\n }\n@@ -196,7 +202,7 @@ func createCommand(c *cli.Context) error {\n \twarningChecker := updater.StartWarningCheck(c)\n \tdefer warningChecker.LogWarningIfAny(sc.log)\n \n-\t_, err = sc.create(name, c.String(CredFileFlag))\n+\t_, err = sc.create(name, c.String(CredFileFlag), c.String(createSecretFlag.Name))\n \treturn errors.Wrap(err, \"failed to create tunnel\")\n }\n \n---\n"}], "ideal": "Title: Add flag to 'tunnel create' subcommand to specify a base64-encoded secret\n\nBody: This will help workflows where secrets are pre-provisioned. Running \"tunnel create\" manually and storing the generated secret isn't always practical. My use case is for automated tunnel provisioning without resorting to the API, which permits specifying a secret.\r\n\r\nhttps://api.cloudflare.com/#argo-tunnel-create-argo-tunnel"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".github/workflows/docker-publish.yml\n@@ -0,0 +1,76 @@\n+name: Docker\n+\n+on:\n+  release:\n+    types: [published]\n+env:\n+  BUILD_VERSION: ${{ github.ref }}\n+  IMAGE_NAME: cloudflared\n+  DOCKER_CLI_EXPERIMENTAL: enabled\n+  REPOSITORY: ${{ github.repository }}\n+\n+jobs:\n+  # Push image to GitHub Packages.\n+  # See also https://docs.docker.com/docker-hub/builds/\n+  push:\n+    runs-on: ubuntu-latest\n+    if: ${{ github.event_name != 'pull_request' }}\n+    steps:\n+      - name: Source checkout\n+        uses: actions/checkout@v2.3.4 \n+ \n+      - name: Setup QEMU\n+        id: qemu\n+        uses: docker/setup-qemu-action@v1.2.0\n+      \n+      - name: Setup Buildx\n+        id: buildx\n+        uses: docker/setup-buildx-action@v1\n+\n+      - name: set version\n+        run : |\n+            VERSION=$(echo \"${{ github.ref }}\" | sed -e 's,.*/\\(.*\\),\\1,') #Get the tag or branch name (eg master or 2021.9.0)\n+            REPOSITORY=$(echo $REPOSITORY | tr '[A-Z]' '[a-z]') #make all lowercase\n+            # Strip \"v\" prefix from tag name or use short sha \n+            [[ \"${{ github.ref }}\" == \"refs/tags/\"* ]] && VERSION=$(echo $VERSION | sed -e 's/^v//') || VERSION=$(git rev-parse --short \"$GITHUB_SHA\")\n+            #Create a GA variable to use in other steps\n+            echo \"app_version=$VERSION\" >> $GITHUB_ENV\n+            echo \"REPOSITORY=$REPOSITORY\" >> $GITHUB_ENV\n+\n+      - name: Set Docker metadata\n+        id: docker_meta\n+        uses: docker/metadata-action@v3\n+        with:\n+          images: ${{ env.REPOSITORY }}\n+          labels: |\n+            org.opencontainers.image.version=${{env.app_version }}\n+            org.opencontainers.image.revision=${{ github.sha }}\n+            org.opencontainers.image.title=${{ env.REPOSITORY }}\n+\n+      - name: GitHub login\n+        if: ${{ github.event_name != 'pull_request' }}\n+        uses: docker/login-action@v1.10.0\n+        with:\n+          registry: ghcr.io\n+          username: ${{ github.actor }}\n+          password: ${{ secrets.GITHUB_TOKEN }}\n+      - name: DockerHub login\n+        if: ${{ github.event_name != 'pull_request' }}\n+        uses: docker/login-action@v1.10.0\n+        with:\n+          username: ${{ secrets.DOCKERHUB_USERNAME }}\n+          password: ${{ secrets.DOCKERHUB_PASSWORD }}      \n+      - name: Build and push\n+        uses: docker/build-push-action@v2.7.0\n+        with:\n+          push: ${{ github.event_name != 'pull_request' }}\n+          platforms: linux/amd64\n+          build-args: ${{ env.app_version }}\n+          cache-from: type=gha, scope=${{ github.workflow }}\n+          cache-to: type=gha, scope=${{ github.workflow }}\n+          labels: ${{ steps.docker_meta.outputs.labels }}\n+          tags: |\n+            ${{env.REPOSITORY}}:${{ env.app_version }}\n+            ${{env.REPOSITORY}}:latest\n+            ghcr.io/${{ env.REPOSITORY }}:${{ env.app_version }}\n+            ghcr.io/${{ env.REPOSITORY }}:latest\n---\n"}], "ideal": "Title: Add Docker Workflow\n\nBody: This adds a docker workflow that will build and push the images to GHCR and DockerHub. There are a few things to consider\r\n\r\n1.  You will need to add `DOCKERHUB_USERNAME` and `DOCKERHUB_PASSWORD` consisting of your docker username and an authentication token to this repository's secrets\r\n2.  This will only run when pushes are to master branch or a release is made (this includes pre-releases)\r\n3. For docker tags, it uses either the tag (2021.9.0) or the git short sha. \r\n    a. This appears to be what's happening in the docker repo, so I tried replicating it. \r\n4. It will push to` ghcr.io/cloudflare/cloudflared` and `docker.io/cloudflare/cloudflared`\r\n     \r\n\r\n This Fixes #422 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "README.md\n@@ -29,7 +29,7 @@ Once installed, you can authenticate `cloudflared` into your Cloudflare account\n \n ## TryCloudflare\n \n-Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/do-more-with-tunnels/trycloudflare).\n+Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/trycloudflare).\n \n ## Deprecated versions\n \n---\n"}], "ideal": "Title: Fix TryCloudflare link\n\nBody: Hi, I have updated the link to the [TryCloudflare](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/run-tunnel/trycloudflare) docs in this readme that seems to be broken.\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/subcommand_context.go\n@@ -261,8 +261,16 @@ func (sc *subcommandContext) delete(tunnelIDs []uuid.UUID) error {\n // and add the TunnelID into any old credentials (generated before TUN-3581 added the `TunnelID`\n // field to credentials files)\n func (sc *subcommandContext) findCredentials(tunnelID uuid.UUID) (connection.Credentials, error) {\n-\tcredFinder := sc.credentialFinder(tunnelID)\n-\tcredentials, err := sc.readTunnelCredentials(credFinder)\n+\tvar credentials connection.Credentials\n+\tvar err error\n+\tif credentialsContents := sc.c.String(CredContentsFlag); credentialsContents != \"\" {\n+\t\tif err = json.Unmarshal([]byte(credentialsContents), &credentials); err != nil {\n+\t\t\terr = errInvalidJSONCredential{path: \"TUNNEL_CRED_CONTENTS\", err: err}\n+\t\t}\n+\t} else {\n+\t\tcredFinder := sc.credentialFinder(tunnelID)\n+\t\tcredentials, err = sc.readTunnelCredentials(credFinder)\n+\t}\n \t// This line ensures backwards compatibility with credentials files generated before\n \t// TUN-3581. Those old credentials files don't have a TunnelID field, so we enrich the struct\n \t// with the ID, which we have already resolved from the user input.\n---\ncmd/cloudflared/tunnel/subcommand_context_test.go\n@@ -191,6 +191,51 @@ func Test_subcommandContext_findCredentials(t *testing.T) {\n \t\t\t\tTunnelName:   name,\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname: \"TUNNEL_CRED_CONTENTS given contains old credentials contents\",\n+\t\t\tfields: fields{\n+\t\t\t\tlog: &log,\n+\t\t\t\tfs:  fs,\n+\t\t\t\tc: func() *cli.Context {\n+\t\t\t\t\tflagSet := flag.NewFlagSet(\"test0\", flag.PanicOnError)\n+\t\t\t\t\tflagSet.String(CredContentsFlag, \"\", \"\")\n+\t\t\t\t\tc := cli.NewContext(cli.NewApp(), flagSet, nil)\n+\t\t\t\t\t_ = c.Set(CredContentsFlag, fmt.Sprintf(`{\"AccountTag\":\"%s\",\"TunnelSecret\":\"%s\"}`, accountTag, secretB64))\n+\t\t\t\t\treturn c\n+\t\t\t\t}(),\n+\t\t\t},\n+\t\t\targs: args{\n+\t\t\t\ttunnelID: tunnelID,\n+\t\t\t},\n+\t\t\twant: connection.Credentials{\n+\t\t\t\tAccountTag:   accountTag,\n+\t\t\t\tTunnelID:     tunnelID,\n+\t\t\t\tTunnelSecret: secret,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"TUNNEL_CRED_CONTENTS given contains new credentials contents\",\n+\t\t\tfields: fields{\n+\t\t\t\tlog: &log,\n+\t\t\t\tfs:  fs,\n+\t\t\t\tc: func() *cli.Context {\n+\t\t\t\t\tflagSet := flag.NewFlagSet(\"test0\", flag.PanicOnError)\n+\t\t\t\t\tflagSet.String(CredContentsFlag, \"\", \"\")\n+\t\t\t\t\tc := cli.NewContext(cli.NewApp(), flagSet, nil)\n+\t\t\t\t\t_ = c.Set(CredContentsFlag, fmt.Sprintf(`{\"AccountTag\":\"%s\",\"TunnelSecret\":\"%s\",\"TunnelID\":\"%s\",\"TunnelName\":\"%s\"}`, accountTag, secretB64, tunnelID, name))\n+\t\t\t\t\treturn c\n+\t\t\t\t}(),\n+\t\t\t},\n+\t\t\targs: args{\n+\t\t\t\ttunnelID: tunnelID,\n+\t\t\t},\n+\t\t\twant: connection.Credentials{\n+\t\t\t\tAccountTag:   accountTag,\n+\t\t\t\tTunnelID:     tunnelID,\n+\t\t\t\tTunnelSecret: secret,\n+\t\t\t\tTunnelName:   name,\n+\t\t\t},\n+\t\t},\n \t}\n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n---\ncmd/cloudflared/tunnel/subcommands.go\n@@ -33,6 +33,7 @@ const (\n \tconnsSortByOptions   = \"id, startedAt, numConnections, version\"\n \tCredFileFlagAlias    = \"cred-file\"\n \tCredFileFlag         = \"credentials-file\"\n+\tCredContentsFlag     = \"credentials-contents\"\n \toverwriteDNSFlagName = \"overwrite-dns\"\n \n \tLogFieldTunnelID = \"tunnelID\"\n@@ -111,8 +112,13 @@ var (\n \t\tUsage:   \"Filepath at which to read/write the tunnel credentials\",\n \t\tEnvVars: []string{\"TUNNEL_CRED_FILE\"},\n \t}\n-\tcredentialsFileFlag = altsrc.NewStringFlag(credentialsFileFlagCLIOnly)\n-\tforceDeleteFlag     = &cli.BoolFlag{\n+\tcredentialsFileFlag     = altsrc.NewStringFlag(credentialsFileFlagCLIOnly)\n+\tcredentialsContentsFlag = altsrc.NewStringFlag(&cli.StringFlag{\n+\t\tName:    CredContentsFlag,\n+\t\tUsage:   \"Contents of the tunnel credentials JSON file to use. When provided along with credentials-file, this will take precedence.\",\n+\t\tEnvVars: []string{\"TUNNEL_CRED_CONTENTS\"},\n+\t})\n+\tforceDeleteFlag = &cli.BoolFlag{\n \t\tName:    \"force\",\n \t\tAliases: []string{\"f\"},\n \t\tUsage: \"Cleans up any stale connections before the tunnel is deleted. cloudflared will not \" +\n@@ -579,6 +585,7 @@ func buildRunCommand() *cli.Command {\n \tflags := []cli.Flag{\n \t\tforceFlag,\n \t\tcredentialsFileFlag,\n+\t\tcredentialsContentsFlag,\n \t\tselectProtocolFlag,\n \t\tfeaturesFlag,\n \t}\n---\n"}], "ideal": "Title: Add support for taking named tunnel credentials from an environment var\n\nBody: # Description\r\nResolves #457.\r\n\r\nAdds a new flag, `credentials-contents`, to act as an alternative to `credentials-file`. This flag has an environment variable of `TUNNEL_CRED_CONTENTS` attached, allowing providing of named tunnel credentials via an environment variable. This flag, if provided, causes `subcommandContext.findCredentials` to load the credentials from the value of the flag, rather than trying to find a file on disk to load from.\r\n\r\n# Testing\r\n- I have added unit tests for the behaviour I implemented\r\n- I have tested locally by running the following:\r\n```bash\r\nmake cloudflared\r\nexport TUNNEL_CRED_CONTENTS=$(cat ~/.cloudflared/TUNNEL_UUID.json)\r\n./cloudflared tunnel run --url http://localhost:5000 TUNNEL_UUID\r\n``` \r\n- I have successfully gotten `cloudflared` running on Fargate in AWS ECS, and ensured it is functioning properly\r\n\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "README.md\n@@ -29,7 +29,7 @@ Once installed, you can authenticate `cloudflared` into your Cloudflare account\n \n ## TryCloudflare\n \n-Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/trycloudflare).\n+Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/do-more-with-tunnels/trycloudflare).\n \n ## Deprecated versions\n \n---\n"}], "ideal": "Title: Fix broken TryCloudflare link\n\nBody: Updates the link to TryCloudflare in README.md to point to the current documentation page."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "edgediscovery/dial.go\n@@ -3,6 +3,7 @@ package edgediscovery\n import (\n \t\"context\"\n \t\"crypto/tls\"\n+\t\"golang.org/x/net/proxy\"\n \t\"net\"\n \t\"time\"\n \n@@ -20,8 +21,9 @@ func DialEdge(\n \tdialCtx, dialCancel := context.WithTimeout(ctx, timeout)\n \tdefer dialCancel()\n \n-\tdialer := net.Dialer{}\n-\tedgeConn, err := dialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\t//dialer := net.Dialer{}\n+\t//edgeConn, err := dialer.DialContext(dialCtx, \"tcp\", edgeTCPAddr.String())\n+\tedgeConn, err := proxy.Dial(dialCtx, \"tcp\", edgeTCPAddr.String())\n \tif err != nil {\n \t\treturn nil, newDialError(err, \"DialContext error\")\n \t}\n---\n"}], "ideal": "Title: connect via proxy\n\nBody: Fixes #350\r\nSigned-off-by: David J. M. Karlsen <david@davidkarlsen.com>"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -39,6 +39,8 @@ else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 5),armv8)\n     TARGET_ARCH ?= arm64\n else ifeq ($(LOCAL_ARCH),aarch64)\n     TARGET_ARCH ?= arm64\n+else ifeq ($(LOCAL_ARCH),arm64)\n+    TARGET_ARCH ?= arm64\n else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 4),armv)\n     TARGET_ARCH ?= arm\n else\n---\n"}], "ideal": "Title: Allow building on arm64 platforms\n\nBody: e.g. M1 MacBook Pro"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "SECURITY.md\n@@ -0,0 +1,21 @@\n+# Security Policy\n+\n+## Supported Versions\n+\n+Use this section to tell people about which versions of your project are\n+currently being supported with security updates.\n+\n+| Version | Supported          |\n+| ------- | ------------------ |\n+| 5.1.x   | :white_check_mark: |\n+| 5.0.x   | :x:                |\n+| 4.0.x   | :white_check_mark: |\n+| < 4.0   | :x:                |\n+\n+## Reporting a Vulnerability\n+\n+Use this section to tell people how to report a vulnerability.\n+\n+Tell them where to go, how often they can expect to get an update on a\n+reported vulnerability, what to expect if the vulnerability is accepted or\n+declined, etc.\n---\n"}], "ideal": "Title: 1.1.1.1File downloard\n\nBody: Your states"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "README.md\n@@ -33,11 +33,9 @@ Want to test Argo Tunnel before adding a website to Cloudflare? You can do so wi\n \n ## Deprecated versions\n \n-Cloudflare currently supports all versions of `cloudflared`. Starting on March 20, 2021, Cloudflare will no longer support versions released prior to 2020.5.1.\n-\n-All features available in versions released prior to 2020.5.1 are available in current versions. Breaking changes unrelated to feature availability may be introduced that will impact versions released prior to 2020.5.1. You can read more about upgrading `cloudflared` in our [developer documentation](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#updating-cloudflared).\n+Cloudflare currently supports versions of `cloudflared` 2020.5.1 and later. Breaking changes unrelated to feature availability may be introduced that will impact versions released prior to 2020.5.1. You can read more about upgrading `cloudflared` in our [developer documentation](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#updating-cloudflared).\n \n | Version(s) | Deprecation status |\n |---|---|\n | 2020.5.1 and later | Supported |\n-| Versions prior to 2020.5.1 | Will no longer be supported starting March 20, 2021 |\n+| Versions prior to 2020.5.1 | No longer supported |\n---\n"}], "ideal": "Title: Update README.md\n\nBody: Updated our README.md to reflect the supported versions of cloudflared."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".github/dependabot.yml\n@@ -0,0 +1,14 @@\n+version: 2\n+\n+updates:\n+  # Maintain dependencies for GitHub Actions\n+  - package-ecosystem: \"github-actions\"\n+    directory: \"/\"\n+    schedule:\n+      interval: \"daily\"\n+      \n+  # Maintain dependencies for Go\n+  - package-ecosystem: \"gomod\"\n+    directory: \"/\"\n+    schedule:\n+      interval: \"daily\"\n---\n.github/workflows/codeql-analysis.yml\n@@ -0,0 +1,72 @@\n+# For most projects, this workflow file will not need changing; you simply need\n+# to commit it to your repository.\n+#\n+# You may wish to alter this file to override the set of languages analyzed,\n+# or to provide custom queries or build logic.\n+#\n+# ******** NOTE ********\n+# We have attempted to detect the languages in your repository. Please check\n+# the `language` matrix defined below to confirm you have the correct set of\n+# supported CodeQL languages.\n+#\n+name: \"CodeQL\"\n+\n+on:\n+  push:\n+    branches: [ master ]\n+  pull_request:\n+    # The branches below must be a subset of the branches above\n+    branches: [ master ]\n+  schedule:\n+    - cron: '19 9 * * 4'\n+\n+jobs:\n+  analyze:\n+    name: Analyze\n+    runs-on: ubuntu-latest\n+    permissions:\n+      actions: read\n+      contents: read\n+      security-events: write\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        language: [ 'go', 'javascript', 'python' ]\n+        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python' ]\n+        # Learn more:\n+        # https://docs.github.com/en/free-pro-team@latest/github/finding-security-vulnerabilities-and-errors-in-your-code/configuring-code-scanning#changing-the-languages-that-are-analyzed\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v2\n+\n+    # Initializes the CodeQL tools for scanning.\n+    - name: Initialize CodeQL\n+      uses: github/codeql-action/init@v1\n+      with:\n+        languages: ${{ matrix.language }}\n+        # If you wish to specify custom queries, you can do so here or in a config file.\n+        # By default, queries listed here will override any specified in a config file.\n+        # Prefix the list here with \"+\" to use these queries and those in the config file.\n+        # queries: ./path/to/local/query, your-org/your-repo/queries@main\n+        queries: security-and-quality\n+\n+    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).\n+    # If this step fails, then you should remove it and run the build manually (see below)\n+    - name: Autobuild\n+      uses: github/codeql-action/autobuild@v1\n+\n+    # \u2139\ufe0f Command-line programs to run using the OS shell.\n+    # \ud83d\udcda https://git.io/JvXDl\n+\n+    # \u270f\ufe0f If the Autobuild fails above, remove it and uncomment the following three lines\n+    #    and modify them (or add more) to build your code if your project\n+    #    uses a compiled language\n+\n+    #- run: |\n+    #   make bootstrap\n+    #   make release\n+\n+    - name: Perform CodeQL Analysis\n+      uses: github/codeql-action/analyze@v1\n---\n"}], "ideal": "Title: Add Dependabot and CodeQL scanning\n\nBody: This helps keeps dependencies up to date as well as identify any potential code issues."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -88,7 +88,7 @@ ifeq ($(FIPS), true)\n \tmv fips/fips.go.linux-amd64 fips/fips.go\n endif\n \n-\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) go build -v -mod=vendor $(GO_BUILD_TAGS) $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tCGO_ENABLED=0 GOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) go build -v -mod=vendor $(GO_BUILD_TAGS) $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n \n ifeq ($(FIPS), true)\n \tmv fips/fips.go fips/fips.go.linux-amd64\n---\n"}], "ideal": "Title: add CGO_ENABLED=0 in Makefile\n\nBody: Disable cgo to independent of the system glibc could avoid `TLS handshake timeout` in old glibc platform (eg: debian8 on openvz7)  and work better in alpine based docker image."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/access/cmd.go\n@@ -143,11 +143,13 @@ func Commands() []*cli.Command {\n \t\t\t\t\t\t\tName:    sshTokenIDFlag,\n \t\t\t\t\t\t\tAliases: []string{\"id\"},\n \t\t\t\t\t\t\tUsage:   \"specify an Access service token ID you wish to use.\",\n+\t\t\t\t\t\t\tEnvVars: []string{\"TUNNEL_SERVICE_TOKEN_ID\"},\n \t\t\t\t\t\t},\n \t\t\t\t\t\t&cli.StringFlag{\n \t\t\t\t\t\t\tName:    sshTokenSecretFlag,\n \t\t\t\t\t\t\tAliases: []string{\"secret\"},\n \t\t\t\t\t\t\tUsage:   \"specify an Access service token secret you wish to use.\",\n+\t\t\t\t\t\t\tEnvVars: []string{\"TUNNEL_SERVICE_TOKEN_SECRET\"},\n \t\t\t\t\t\t},\n \t\t\t\t\t\t&cli.StringFlag{\n \t\t\t\t\t\t\tName:    logger.LogSSHDirectoryFlag,\n---\n"}], "ideal": "Title: Allow TokenID and TokenSecret as env vars for cloudflares access\n\nBody: resolves #232\r\n\r\nFeel free to ask for anything!"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "origin/proxy.go\n@@ -238,8 +238,13 @@ func (p *proxy) logRequest(r *http.Request, fields logFields) {\n \t} else {\n \t\tp.log.Debug().Msgf(\"All requests should have a CF-RAY header. Please open a support ticket with Cloudflare. %s %s %s \", r.Method, r.URL, r.Proto)\n \t}\n-\tp.log.Debug().Msgf(\"CF-RAY: %s Request Headers %+v\", fields.cfRay, r.Header)\n-\tp.log.Debug().Msgf(\"CF-RAY: %s Serving with ingress rule %v\", fields.cfRay, fields.rule)\n+\tp.log.Debug().\n+\t\tStr(\"CF-RAY\", fields.cfRay).\n+\t\tFields(r.Header).\n+\t\tStr(\"host\", r.Host).\n+\t\tStr(\"path\", r.URL.Path).\n+\t\tInterface(\"rule\", fields.rule).\n+\t\tMsg(\"Inbound request\")\n \n \tif contentLen := r.ContentLength; contentLen == -1 {\n \t\tp.log.Debug().Msgf(\"CF-RAY: %s Request Content length unknown\", fields.cfRay)\n---\n"}], "ideal": "Title: debug: log host / path\n\nBody: to help understand why the ingress rule logged is being selected.\r\n\r\nto debug https://github.com/cloudflare/cloudflared/issues/364."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/macos_service.go\n@@ -49,6 +49,8 @@ func newLaunchdTemplate(installPath, stdoutPath, stderrPath string) *ServiceTemp\n \t\t<key>ProgramArguments</key>\n \t\t<array>\n \t\t\t<string>{{ .Path }}</string>\n+\t\t\t<string>tunnel</string>\n+\t\t\t<string>run</string>\n \t\t</array>\n \t\t<key>RunAtLoad</key>\n \t\t<true/>\n---\n"}], "ideal": "Title: Fix macOS service installation launch template\n\nBody: The current version of cloudflared (2021.3.2 at time of commit)\r\nrequires additional arguments to start a tunnel. Running 'cloudflared'\r\non its own does not run a tunnel with the default configuration.\r\n\r\nThis is behavior that has changed from previous versions of cloudflared,\r\nwhere no arguments were required for starting/running a tunnel with the\r\ndefault configuration behavior.\r\n\r\nThis fixes https://github.com/cloudflare/cloudflared/issues/327."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "websocket/connection.go\n@@ -1,15 +1,16 @@\n package websocket\n \n import (\n+\t\"bytes\"\n \t\"context\"\n+\t\"fmt\"\n \t\"io\"\n \t\"time\"\n \n-\t\"github.com/rs/zerolog\"\n-\n \tgobwas \"github.com/gobwas/ws\"\n \t\"github.com/gobwas/ws/wsutil\"\n \t\"github.com/gorilla/websocket\"\n+\t\"github.com/rs/zerolog\"\n )\n \n const (\n@@ -27,17 +28,29 @@ const (\n // This is still used by access carrier\n type GorillaConn struct {\n \t*websocket.Conn\n-\tlog *zerolog.Logger\n+\tlog     *zerolog.Logger\n+\treadBuf bytes.Buffer\n }\n \n // Read will read messages from the websocket connection\n func (c *GorillaConn) Read(p []byte) (int, error) {\n+\t// Intermediate buffer may contain unread bytes from the last read, start there before blocking on a new frame\n+\tif c.readBuf.Len() > 0 {\n+\t\treturn c.readBuf.Read(p)\n+\t}\n+\n \t_, message, err := c.Conn.ReadMessage()\n \tif err != nil {\n \t\treturn 0, err\n \t}\n-\treturn copy(p, message), nil\n \n+\tcopied := copy(p, message)\n+\n+\t// Write unread bytes to readBuf; if everything was read this is a no-op\n+\t// Write returns a nil error always and grows the buffer; everything is always written or panic\n+\tc.readBuf.Write(message[copied:])\n+\n+\treturn copied, nil\n }\n \n // Write will write messages to the websocket connection\n@@ -49,6 +62,19 @@ func (c *GorillaConn) Write(p []byte) (int, error) {\n \treturn len(p), nil\n }\n \n+// SetDeadline sets both read and write deadlines, as per net.Conn interface docs:\n+// \"It is equivalent to calling both SetReadDeadline and SetWriteDeadline.\"\n+// Note there is no synchronization here, but the gorilla implementation isn't thread safe anyway\n+func (c *GorillaConn) SetDeadline(t time.Time) error {\n+\tif err := c.Conn.SetReadDeadline(t); err != nil {\n+\t\treturn fmt.Errorf(\"error setting read deadline: %w\", err)\n+\t}\n+\tif err := c.Conn.SetWriteDeadline(t); err != nil {\n+\t\treturn fmt.Errorf(\"error setting write deadline: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n // pinger simulates the websocket connection to keep it alive\n func (c *GorillaConn) pinger(ctx context.Context) {\n \tticker := time.NewTicker(pingPeriod)\n---\nwebsocket/websocket.go\n@@ -114,7 +114,7 @@ func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n \t}\n \t_ = conn.SetReadDeadline(time.Now().Add(pongWait))\n \tconn.SetPongHandler(func(string) error { _ = conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })\n-\tgorillaConn := &GorillaConn{conn, h.log}\n+\tgorillaConn := &GorillaConn{Conn: conn, log: h.log}\n \tgo gorillaConn.pinger(r.Context())\n \tdefer conn.Close()\n \n---\nwebsocket/websocket_test.go\n@@ -1,18 +1,23 @@\n package websocket\n \n import (\n+\t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n-\t\"github.com/rs/zerolog\"\n+\t\"fmt\"\n \t\"io\"\n \t\"math/rand\"\n \t\"net/http\"\n \t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog\"\n \n \t\"github.com/cloudflare/cloudflared/hello\"\n \t\"github.com/cloudflare/cloudflared/tlsconfig\"\n \tgws \"github.com/gorilla/websocket\"\n \t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n \t\"golang.org/x/net/websocket\"\n )\n \n@@ -102,6 +107,51 @@ func TestServe(t *testing.T) {\n \t<-errC\n }\n \n+func TestWebsocketWrapper(t *testing.T) {\n+\n+\tlistener, err := hello.CreateTLSListener(\"localhost:0\")\n+\trequire.NoError(t, err)\n+\n+\tserverErrorChan := make(chan error)\n+\thelloSvrCtx, cancelHelloSvr := context.WithCancel(context.Background())\n+\tdefer func() { <-serverErrorChan }()\n+\tdefer cancelHelloSvr()\n+\tgo func() {\n+\t\tlog := zerolog.Nop()\n+\t\tserverErrorChan <- hello.StartHelloWorldServer(&log, listener, helloSvrCtx.Done())\n+\t}()\n+\n+\ttlsConfig := websocketClientTLSConfig(t)\n+\td := gws.Dialer{TLSClientConfig: tlsConfig, HandshakeTimeout: time.Minute}\n+\ttestAddr := fmt.Sprintf(\"https://%s/ws\", listener.Addr().String())\n+\treq := testRequest(t, testAddr, nil)\n+\tconn, resp, err := ClientConnect(req, &d)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, testSecWebsocketAccept, resp.Header.Get(\"Sec-WebSocket-Accept\"))\n+\n+\t// Websocket now connected to test server so lets check our wrapper\n+\twrapper := GorillaConn{Conn: conn}\n+\tbuf := make([]byte, 100)\n+\twrapper.Write([]byte(\"abc\"))\n+\tn, err := wrapper.Read(buf)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, n, 3)\n+\trequire.Equal(t, \"abc\", string(buf[:n]))\n+\n+\t// Test partial read, read 1 of 3 bytes in one read and the other 2 in another read\n+\twrapper.Write([]byte(\"abc\"))\n+\tbuf = buf[:1]\n+\tn, err = wrapper.Read(buf)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, n, 1)\n+\trequire.Equal(t, \"a\", string(buf[:n]))\n+\tbuf = buf[:cap(buf)]\n+\tn, err = wrapper.Read(buf)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, n, 2)\n+\trequire.Equal(t, \"bc\", string(buf[:n]))\n+}\n+\n // func TestStartProxyServer(t *testing.T) {\n // \tvar wg sync.WaitGroup\n // \tremoteAddress := \"localhost:1113\"\n---\n"}], "ideal": "Title: Allow partial reads from a GorillaConn; add SetDeadline (from net.Conn)\n\nBody: The current implementation of GorillaConn will drop data if the\r\nwebsocket frame isn't read 100%. For example, if a websocket frame is\r\nsize=3, and Read() is called with a []byte of len=1, the 2 other bytes\r\nin the frame are lost forever.\r\n\r\nThis is currently masked by the fact that this is used primarily in\r\nio.Copy to another socket (in ingress.Stream) - as long as the read buffer\r\nused by io.Copy is big enough (it is 32*1024, so in theory we could see\r\nthis today?) then data is copied over to the other socket.\r\n\r\nThe client then can do partial reads just fine as the kernel will take\r\ncare of the buffer from here on out.\r\n\r\nI hit this by trying to create my own tunnel and avoiding\r\ningress.Stream, but this could be a real bug today I think if a\r\nwebsocket frame bigger than 32*1024 was received, although it is also\r\npossible that we are lucky and the upstream size which I haven't checked\r\nuses a smaller buffer than that always.\r\n\r\nThe test I added hangs before my change, succeeds after.\r\n\r\nAlso add SetDeadline so that GorillaConn fully implements net.Conn"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -34,6 +34,8 @@ ifneq ($(GOARCH),)\n     TARGET_ARCH ?= $(GOARCH)\n else ifeq ($(LOCAL_ARCH),x86_64)\n     TARGET_ARCH ?= amd64\n+else ifeq ($(LOCAL_ARCH),amd64)\n+    TARGET_ARCH ?= amd64\n else ifeq ($(LOCAL_ARCH),i686)\n     TARGET_ARCH ?= amd64\n else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 5),armv8)\n@@ -236,7 +238,7 @@ tunnelrpc/tunnelrpc.capnp.go: tunnelrpc/tunnelrpc.capnp\n .PHONY: vet\n vet:\n \tgo vet -mod=vendor ./...\n-\twhich go-sumtype  # go get github.com/BurntSushi/go-sumtype\n+\twhich go-sumtype  # go get github.com/BurntSushi/go-sumtype (don't do this in build directory or this will cause vendor issues)\n \tgo-sumtype $$(go list -mod=vendor ./...)\n \n .PHONY: msi\n---\n"}], "ideal": "Title: Issue #285 - Makefile does not detect TARGET_ARCH correctly on FreeBSD \n\nBody: Simple Makefile fix for Issue #285 (Makefile does not detect TARGET_ARCH correctly on FreeBSD )\r\n\r\nBuild / runs tests cleanly on FreeBSD 12.2 (see [gmake.log](https://github.com/cloudflare/cloudflared/files/6055307/gmake.log))\r\n\r\n(Note I added a note to the comment to the `make vet` target not to run `go get github.com/BurntSushi/go-sumtype` in the build dir as this causes a bunch of vendoring issues)\r\n \r\n(Note - Issue discussion suggested @Michael9127 as reviewer but don't think I have permissions to assign this)"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "websocket/websocket.go\n@@ -76,7 +76,10 @@ type defaultDialler struct {\n }\n \n func (dd *defaultDialler) Dial(url *url.URL, header http.Header) (*websocket.Conn, *http.Response, error) {\n-\td := &websocket.Dialer{TLSClientConfig: dd.tlsConfig}\n+\td := &websocket.Dialer{\n+\t\tTLSClientConfig: dd.tlsConfig,\n+\t\tProxy:           http.ProxyFromEnvironment,\n+\t}\n \treturn d.Dial(url.String(), header)\n }\n \n---\n"}], "ideal": "Title: Added support for proxy with websockets in arbitrary TCP connections\n\nBody: Provides a fix for #317 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "README.md\n@@ -1,6 +1,6 @@\n # Argo Tunnel client\n \n-Contains the command-line client for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network. Extensive documentation can be found in the [Argo Tunnel section](https://developers.cloudflare.com/argo-tunnel/) of the Cloudflare Docs.\n+Contains the command-line client for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network. Extensive documentation can be found in the [Argo Tunnel section](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps) of the Cloudflare Docs.\n \n ## Before you get started\n \n@@ -13,29 +13,29 @@ Before you use Argo Tunnel, you'll need to complete a few steps in the Cloudflar\n \n Downloads are available as standalone binaries, a Docker image, and Debian, RPM, and Homebrew packages. You can also find releases here on the `cloudflared` GitHub repository.\n \n-* You can [install on macOS](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#macos) via Homebrew or by downloading the [latest Darwin amd64 release](https://github.com/cloudflare/cloudflared/releases)\n-* Binaries, Debian, and RPM packages for Linux [can be found here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#linux)\n+* You can [install on macOS](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#macos) via Homebrew or by downloading the [latest Darwin amd64 release](https://github.com/cloudflare/cloudflared/releases)\n+* Binaries, Debian, and RPM packages for Linux [can be found here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#linux)\n * A Docker image of `cloudflared` is [available on DockerHub](https://hub.docker.com/r/cloudflare/cloudflared)\n-* You can install on Windows machines with the [steps here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#windows)\n+* You can install on Windows machines with the [steps here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#windows)\n \n-User documentation for Argo Tunnel can be found at https://developers.cloudflare.com/argo-tunnel/\n+User documentation for Argo Tunnel can be found at https://developers.cloudflare.com/cloudflare-one/connections/connect-apps\n \n ## Creating Tunnels and routing traffic\n \n Once installed, you can authenticate `cloudflared` into your Cloudflare account and begin creating Tunnels that serve traffic for hostnames in your account.\n \n-* Create a Tunnel with [these instructions](https://developers.cloudflare.com/argo-tunnel/create-tunnel)\n-* Route traffic to that Tunnel with [DNS records in Cloudflare](https://developers.cloudflare.com/argo-tunnel/routing-to-tunnel/dns) or with a [Cloudflare Load Balancer](https://developers.cloudflare.com/argo-tunnel/routing-to-tunnel/lb)\n+* Create a Tunnel with [these instructions](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/create-tunnel)\n+* Route traffic to that Tunnel with [DNS records in Cloudflare](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/routing-to-tunnel/dns) or with a [Cloudflare Load Balancer](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/routing-to-tunnel/lb)\n \n ## TryCloudflare\n \n-Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/argo-tunnel/learning/trycloudflare).\n+Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/trycloudflare).\n \n ## Deprecated versions\n \n Cloudflare currently supports all versions of `cloudflared`. Starting on March 20, 2021, Cloudflare will no longer support versions released prior to 2020.5.1.\n \n-All features available in versions released prior to 2020.5.1 are available in current versions. Breaking changes unrelated to feature availability may be introduced that will impact versions released prior to 2020.5.1. You can read more about upgrading `cloudflared` in our [developer documentation](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#updating-cloudflared).\n+All features available in versions released prior to 2020.5.1 are available in current versions. Breaking changes unrelated to feature availability may be introduced that will impact versions released prior to 2020.5.1. You can read more about upgrading `cloudflared` in our [developer documentation](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation#updating-cloudflared).\n \n | Version(s) | Deprecation status |\n |---|---|\n---\n"}], "ideal": "Title: Update README.md links\n\nBody: Updates to the new Cloudflare documentation links"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".github/FUNDING.yml\n@@ -0,0 +1,12 @@\n+# These are supported funding model platforms\n+\n+github: # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]\n+patreon: # Replace with a single Patreon username\n+open_collective: # Replace with a single Open Collective username\n+ko_fi: # Replace with a single Ko-fi username\n+tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel\n+community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry\n+liberapay: # Replace with a single Liberapay username\n+issuehunt: # Replace with a single IssueHunt username\n+otechie: # Replace with a single Otechie username\n+custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']\n---\n"}], "ideal": "Title: Funding.yml\n\nBody: Sponsor"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/configuration.go\n@@ -2,6 +2,7 @@ package tunnel\n \n import (\n \t\"crypto/tls\"\n+\t\"encoding/base64\"\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -35,6 +36,11 @@ var (\n \targumentsUrl    = developerPortal + \"/reference/arguments/\"\n )\n \n+const (\n+\t// name of the environment variable that contains the base64 encoded origin cert\n+\tencodedOriginCert = \"TUNNEL_ORIGIN_CERT_CONTENT\"\n+)\n+\n // returns the first path that contains a cert.pem file. If none of the DefaultConfigSearchDirectories\n // contains a cert.pem file, return empty string\n func findDefaultOriginCertPath() string {\n@@ -95,7 +101,7 @@ func dnsProxyStandAlone(c *cli.Context) bool {\n \n func findOriginCert(c *cli.Context, logger logger.Service) (string, error) {\n \toriginCertPath := c.String(\"origincert\")\n-\tif originCertPath == \"\" {\n+\tif originCertPath == \"\" && os.Getenv(encodedOriginCert) == \"\" {\n \t\tlogger.Infof(\"Cannot determine default origin certificate path. No file %s in %v\", config.DefaultCredentialFile, config.DefaultConfigSearchDirectories())\n \t\tif isRunningFromTerminal() {\n \t\t\tlogger.Errorf(\"You need to specify the origin certificate path with --origincert option, or set TUNNEL_ORIGIN_CERT environment variable. See %s for more information.\", argumentsUrl)\n@@ -146,6 +152,11 @@ func readOriginCert(originCertPath string, logger logger.Service) ([]byte, error\n }\n \n func getOriginCert(c *cli.Context, logger logger.Service) ([]byte, error) {\n+\t// check if cert is present as a base64 encoded ENV\n+\tcertContent := os.Getenv(encodedOriginCert)\n+\tif certContent != \"\" {\n+\t\treturn base64.StdEncoding.DecodeString(certContent)\n+\t}\n \tif originCertPath, err := findOriginCert(c, logger); err != nil {\n \t\treturn nil, err\n \t} else {\n---\n"}], "ideal": "Title: feat(tunnel): add TUNNEL_ORIGIN_CERT_CONTENT env\n\nBody: This PR adds support for specifying the origin certificate content\r\nas an environment variable.\r\nThis is useful when deploying cloudflared in environments where writing\r\na file is not possible, ex: Heroku\r\n\r\nThe cert must be base64 encoded."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/access/cmd.go\n@@ -299,7 +299,7 @@ func generateToken(c *cli.Context) error {\n \t}\n \ttok, err := token.GetTokenIfExists(appURL)\n \tif err != nil || tok == \"\" {\n-\t\tfmt.Fprintln(os.Stderr, \"Unable to find token for provided application. Please run token command to generate token.\")\n+\t\tfmt.Fprintln(os.Stderr, \"Unable to find token for provided application. Please run login command to generate token.\")\n \t\treturn err\n \t}\n \n---\n"}], "ideal": "Title: Update error message to use login command\n\nBody: Unless I'm mistaken, when there is no existing token for an app, the `login` command needs to be run to obtain a token (not the `token` command, which itself doesn't generate a token)."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "README.md\n@@ -1,9 +1,32 @@\n # Argo Tunnel client\n \n-Contains the command-line client and its libraries for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network.\n+Contains the command-line client for Argo Tunnel, a tunneling daemon that proxies any local webserver through the Cloudflare network. Extensive documentation can be found in the [Argo Tunnel section](https://developers.cloudflare.com/argo-tunnel/) of the Cloudflare Docs.\n \n-## Getting started\n+## Before you get started\n \n-    go install github.com/cloudflare/cloudflared/cmd/cloudflared\n+Before you use Argo Tunnel, you'll need to complete a few steps in the Cloudflare dashboard. The website you add to Cloudflare will be used to route traffic to your Tunnel.\n+\n+1. [Add a website to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/201720164-Creating-a-Cloudflare-account-and-adding-a-website)\n+2. [Change your domain nameservers to Cloudflare](https://support.cloudflare.com/hc/en-us/articles/205195708)\n+\n+## Installing `cloudflared`\n+\n+Downloads are available as standalone binaries, a Docker image, and Debian, RPM, and Homebrew packages. You can also find releases here on the `cloudflared` GitHub repository.\n+\n+* You can [install on macOS](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#macos) via Homebrew or by downloading the [latest Darwin amd64 release](https://github.com/cloudflare/cloudflared/releases)\n+* Binaries, Debian, and RPM packages for Linux [can be found here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#linux)\n+* A Docker image of `cloudflared` is [available on DockerHub](https://hub.docker.com/r/cloudflare/cloudflared)\n+* You can install on Windows machines with the [steps here](https://developers.cloudflare.com/argo-tunnel/getting-started/installation#windows)\n \n User documentation for Argo Tunnel can be found at https://developers.cloudflare.com/argo-tunnel/\n+\n+## Creating Tunnels and routing traffic\n+\n+Once installed, you can authenticate `cloudflared` into your Cloudflare account and begin creating Tunnels that serve traffic for hostnames in your account.\n+\n+* Create a Tunnel with [these instructions](https://developers.cloudflare.com/argo-tunnel/create-tunnel)\n+* Route traffic to that Tunnel with [DNS records in Cloudflare](https://developers.cloudflare.com/argo-tunnel/routing-to-tunnel/dns) or with a [Cloudflare Load Balancer](https://developers.cloudflare.com/argo-tunnel/routing-to-tunnel/lb)\n+\n+## TryCloudflare\n+\n+Want to test Argo Tunnel before adding a website to Cloudflare? You can do so with TryCloudflare using the documentation [available here](https://developers.cloudflare.com/argo-tunnel/learning/trycloudflare).\n---\ncmd/cloudflared/macos_service.go\n@@ -119,7 +119,7 @@ func installLaunchd(c *cli.Context) error {\n \t\tlogger.Infof(\"Installing Argo Tunnel client as an user launch agent. \" +\n \t\t\t\"Note that Argo Tunnel client will only run when the user is logged in. \" +\n \t\t\t\"If you want to run Argo Tunnel client at boot, install with root permission. \" +\n-\t\t\t\"For more information, visit https://developers.cloudflare.com/argo-tunnel/reference/service/\")\n+\t\t\t\"For more information, visit https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service\")\n \t}\n \tetPath, err := os.Executable()\n \tif err != nil {\n---\ncmd/cloudflared/updater/update.go\n@@ -20,7 +20,7 @@ import (\n const (\n \tDefaultCheckUpdateFreq        = time.Hour * 24\n \tappID                         = \"app_idCzgxYerVD\"\n-\tnoUpdateInShellMessage        = \"cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/argo-tunnel/reference/service/\"\n+\tnoUpdateInShellMessage        = \"cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service\"\n \tnoUpdateOnWindowsMessage      = \"cloudflared will not automatically update on Windows systems.\"\n \tnoUpdateManagedPackageMessage = \"cloudflared will not automatically update if installed by a package manager.\"\n \tisManagedInstallFile          = \".installedFromPackageManager\"\n---\ncmd/cloudflared/windows_service.go\n@@ -25,7 +25,7 @@ import (\n const (\n \twindowsServiceName        = \"Cloudflared\"\n \twindowsServiceDescription = \"Argo Tunnel agent\"\n-\twindowsServiceUrl         = \"https://developers.cloudflare.com/argo-tunnel/reference/service/\"\n+\twindowsServiceUrl         = \"https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service\"\n \n \trecoverActionDelay      = time.Second * 20\n \tfailureCountResetPeriod = time.Hour * 24\n---\n"}], "ideal": "Title: Update link to documentation for running as a service.\n\nBody: When you run cloudflared in Linux, it'll say:\r\n\r\n```\r\ncloudflared will not automatically update when run from the shell.\r\nTo enable auto-updates, run cloudflared as a service:\r\nhttps://developers.cloudflare.com/argo-tunnel/reference/service/\r\n```\r\n\r\nThis documentation seems to be out of date, however, and [causing some confusion](https://github.com/cloudflare/cloudflared/issues/251).  There also doesn't seem to be a way to actually navigate to this page from the [Argo Tunnel docs](https://developers.cloudflare.com/argo-tunnel/).  Note that when you visit the link above, none of the sections in the table of contents on the left side of the page are expanded.\r\n\r\nSo, this PR replaces this link with what seems to be more up-to-date documentation at https://developers.cloudflare.com/argo-tunnel/create-tunnel/run-as-service.\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -75,7 +75,7 @@ cloudflared: tunnel-deps\n \n .PHONY: container\n container:\n-\tdocker build --build-arg=TARGET_ARCH=$(TARGET_ARCH) --build-arg=TARGET_OS=$(TARGET_OS) -t cloudflare/cloudflared-$(TARGET_OS)-$(TARGET_ARCH):\"$(VERSION)\" .\n+\tdocker build --build-arg=TARGET_ARCH=$(TARGET_ARCH) --build-arg=TARGET_OS=$(TARGET_OS) -t cloudflare/cloudflared-$(TARGET_OS)-$(TARGET_ARCH):latest -t cloudflare/cloudflared-$(TARGET_OS)-$(TARGET_ARCH):\"$(VERSION)\" .\n \n .PHONY: test\n test: vet\n---\n"}], "ideal": "Title: tag cloudflared docker image with latest\n\nBody: This updates the docker build to also include the `latest` tag which should default to the latest version available (Fixes #242).\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/linux_service.go\n@@ -67,7 +67,7 @@ Description=Update Argo Tunnel\n After=network.target\n \n [Service]\n-ExecStart=/bin/bash -c '{{ .Path }} update; code=$?; if [ $code -eq 64 ]; then systemctl restart cloudflared; exit 0; fi; exit $code'\n+ExecStart=/bin/bash -c '{{ .Path }} update; code=$?; if [ $code -eq 11 ]; then systemctl restart cloudflared; exit 0; fi; exit $code'\n `,\n \t},\n \t{\n---\n"}], "ideal": "Title: Updater service exit code should be 11\n\nBody: Updater service should have exit code of 11 and not 64;\r\n\r\nSee: https://github.com/cloudflare/cloudflared/blob/a7562dff68d92210e9bb774916e5fe9198724918/cmd/cloudflared/updater/update.go#L51\r\n\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -422,7 +422,7 @@ func StartServer(c *cli.Context, version string, shutdownC, graceShutdownC chan\n \t\treturn fmt.Errorf(errText)\n \t}\n \n-\tif staticHost := hostnameFromURI(c.String(\"url\")); isProxyDestinationConfigured(staticHost, c) {\n+\tif staticHost := hostFromURI(url); isProxyDestinationConfigured(staticHost, c) {\n \t\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:\")\n \t\tif err != nil {\n \t\t\tlogger.Errorf(\"Cannot start Websocket Proxy Server: %s\", err)\n@@ -570,7 +570,7 @@ func writePidFile(waitForSignal *signal.Signal, pidFile string, logger logger.Se\n \tfmt.Fprintf(file, \"%d\", os.Getpid())\n }\n \n-func hostnameFromURI(uri string) string {\n+func hostFromURI(uri string) string {\n \tu, err := url.Parse(uri)\n \tif err != nil {\n \t\treturn \"\"\n---\ncmd/cloudflared/tunnel/cmd_test.go\n@@ -6,12 +6,12 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n )\n \n-func TestHostnameFromURI(t *testing.T) {\n-\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostnameFromURI(\"ssh://awesome.warptunnels.horse:22\"))\n-\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostnameFromURI(\"ssh://awesome.warptunnels.horse\"))\n-\tassert.Equal(t, \"awesome.warptunnels.horse:2222\", hostnameFromURI(\"ssh://awesome.warptunnels.horse:2222\"))\n-\tassert.Equal(t, \"localhost:3389\", hostnameFromURI(\"rdp://localhost\"))\n-\tassert.Equal(t, \"localhost:3390\", hostnameFromURI(\"rdp://localhost:3390\"))\n-\tassert.Equal(t, \"\", hostnameFromURI(\"trash\"))\n-\tassert.Equal(t, \"\", hostnameFromURI(\"https://awesomesauce.com\"))\n+func TestHostFromURI(t *testing.T) {\n+\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostFromURI(\"ssh://awesome.warptunnels.horse:22\"))\n+\tassert.Equal(t, \"awesome.warptunnels.horse:22\", hostFromURI(\"ssh://awesome.warptunnels.horse\"))\n+\tassert.Equal(t, \"awesome.warptunnels.horse:2222\", hostFromURI(\"ssh://awesome.warptunnels.horse:2222\"))\n+\tassert.Equal(t, \"localhost:3389\", hostFromURI(\"rdp://localhost\"))\n+\tassert.Equal(t, \"localhost:3390\", hostFromURI(\"rdp://localhost:3390\"))\n+\tassert.Equal(t, \"\", hostFromURI(\"trash\"))\n+\tassert.Equal(t, \"\", hostFromURI(\"https://awesomesauce.com\"))\n }\n---\n"}], "ideal": "Title: refactor: rename hostnameFromURI to hostFromURI\n\nBody: since host=hostname+port\r\n\r\nreuse the url variable"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/shell/launch_browser_unix.go\n@@ -3,9 +3,15 @@\n package shell\n \n import (\n+\t\"os\"\n \t\"os/exec\"\n )\n \n func getBrowserCmd(url string) *exec.Cmd {\n+\t// Check if wslview is available (Windows Subsystem for Linux).\n+\tif _, err := os.Stat(\"/usr/bin/wslview\"); err == nil {\n+\t\treturn exec.Command(\"wslview\", url)\n+\t}\n+\n \treturn exec.Command(\"xdg-open\", url)\n }\n---\n"}], "ideal": "Title: Cloudflared open Windows default browser when ran in WSL2\n\nBody: * Added check for WSL-specific env variable.\r\n* Added generic method of running default browser in Windows.\r\n\r\n**Todo:**\r\n* Get the token pickup mechanics working."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -162,7 +162,7 @@ publish-rpm: cloudflared-rpm\n \t$(call publish_package,rpm,yum)\n \n cloudflared.1: cloudflared_man_template\n-\tcat cloudflared_man_template | sed -e 's/\\$${VERSION}/$(VERSION)/; s/\\$${DATE}/$(DATE)/' > cloudflared.1\n+\tsed -e 's/\\$${VERSION}/$(VERSION)/; s/\\$${DATE}/$(DATE)/' cloudflared_man_template > cloudflared.1\n \n install: cloudflared cloudflared.1\n \tmkdir -p $(DESTDIR)$(INSTALL_BINDIR) $(DESTDIR)$(INSTALL_MANDIR)\n---\n"}], "ideal": "Title: drop usage of cat when sed is already invoked\n\nBody: ymmv :)"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -92,6 +92,11 @@ define build_package\n \tcp cloudflared $(PACKAGE_DIR)/cloudflared\n \tcat cloudflared_man_template | sed -e 's/\\$${VERSION}/$(VERSION)/; s/\\$${DATE}/$(DATE)/' > $(PACKAGE_DIR)/cloudflared.1\n \tfakeroot fpm -C $(PACKAGE_DIR) -s dir -t $(1) --$(1)-compression bzip2 \\\n+\t\t--description 'Cloudflare Argo tunnel daemon' \\\n+\t\t--vendor 'Cloudflare' \\\n+\t\t--license 'Cloudflare Service Agreement' \\\n+\t\t--url 'https://github.com/cloudflare/cloudflared' \\\n+\t\t-m 'Cloudflare <support@cloudflare.com>' \\\n \t\t-a $(TARGET_ARCH) -v $(VERSION) -n cloudflared --after-install postinst.sh --after-remove postrm.sh \\\n \t\tcloudflared=$(INSTALL_BINDIR) cloudflared.1=$(MAN_DIR)\n endef\n---\n"}], "ideal": "Title: beautify package meta information generated by fpm\n\nBody: Current Debian and RPM meta information are very generic, e.g.\r\n$ apt-cache show cloudflared\r\nPackage: cloudflared\r\nVersion: 2020.7.0\r\nLicense: unknown\r\nVendor: @k8s-managed-krwtk.teamcity-agents.svc.cluster.local\r\nArchitecture: amd64\r\nMaintainer: <@k8s-managed-krwtk.teamcity-agents.svc.cluster.local>\r\nInstalled-Size: 42883\r\nSection: default\r\nPriority: extra\r\nHomepage: http://example.com/no-uri-given\r\nDescription: no description given\r\n\r\nMove those generic settings to `FPM_COMMONG_FLAGS` and pass those\r\nto fpm when building the package."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -768,6 +768,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_HOSTNAME\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringSliceFlag(&cli.StringSliceFlag{\n+\t\t\tName:    \"host-to-origin\",\n+\t\t\tUsage:   \"Decalre a direct host to origin mapping i.e. host1.example.com=http://localhost:8080. This takes precedence over the single url mapping.\",\n+\t\t\tEnvVars: []string{\"HOST_TO_ORIGIN\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewStringFlag(&cli.StringFlag{\n \t\t\tName:    \"http-host-header\",\n \t\t\tUsage:   \"Sets the HTTP Host header for the local webserver.\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -71,7 +71,7 @@ func logClientOptions(c *cli.Context) {\n \t\tflags[flag] = c.Generic(flag)\n \t}\n \n-\tsliceFlags := []string{\"header\", \"tag\", \"proxy-dns-upstream\", \"upstream\", \"edge\"}\n+\tsliceFlags := []string{\"header\", \"tag\", \"proxy-dns-upstream\", \"upstream\", \"edge\", \"host-to-origin\"}\n \tfor _, sliceFlag := range sliceFlags {\n \t\tif len(c.StringSlice(sliceFlag)) > 0 {\n \t\t\tflags[sliceFlag] = strings.Join(c.StringSlice(sliceFlag), \", \")\n@@ -179,6 +179,15 @@ func prepareTunnelConfig(\n \t\treturn nil, errors.Wrap(err, \"Error validating origin URL\")\n \t}\n \n+\thostToOriginUrls := make(map[string]string)\n+\thostToOrigins := c.StringSlice(\"host-to-origin\")\n+\tfor _, hostToOrigin := range hostToOrigins {\n+\t\thostToOriginArr := strings.Split(hostToOrigin, \"=\")\n+\t\tif len(hostToOriginArr) == 2 {\n+\t\t\thostToOriginUrls[hostToOriginArr[0]] = hostToOriginArr[1]\n+\t\t}\n+\t}\n+\n \tvar originCert []byte\n \tif !isFreeTunnel {\n \t\toriginCert, err = getOriginCert(c)\n@@ -268,6 +277,7 @@ func prepareTunnelConfig(\n \t\tNoChunkedEncoding:    c.Bool(\"no-chunked-encoding\"),\n \t\tOriginCert:           originCert,\n \t\tOriginUrl:            originURL,\n+\t\tHostToOriginUrls:     hostToOriginUrls,\n \t\tReportedVersion:      version,\n \t\tRetries:              c.Uint(\"retries\"),\n \t\tRunFromTerminal:      isRunningFromTerminal(),\n---\norigin/tunnel.go\n@@ -85,6 +85,8 @@ type TunnelConfig struct {\n \t// OriginUrl may not be used if a user specifies a unix socket.\n \tOriginUrl string\n \n+\t// Optional mapping to enable routing to multiple OriginUrls based on Host header.\n+\tHostToOriginUrls map[string]string\n \t// feature-flag to use new edge reconnect tokens\n \tUseReconnectToken bool\n \t// feature-flag for using ConnectionDigest\n@@ -540,6 +542,7 @@ func LogServerInfo(\n \n type TunnelHandler struct {\n \toriginUrl      string\n+\thostToOriginUrls map[string]string\n \thttpHostHeader string\n \tmuxer          *h2mux.Muxer\n \thttpClient     http.RoundTripper\n@@ -565,8 +568,16 @@ func NewTunnelHandler(ctx context.Context,\n \tif err != nil {\n \t\treturn nil, \"\", fmt.Errorf(\"unable to parse origin URL %#v\", originURL)\n \t}\n+\tfor k, _ := range config.HostToOriginUrls {\n+\t\thostOriginURL, err := validation.ValidateUrl(config.HostToOriginUrls[k])\n+\t\tif err != nil {\n+\t\t\treturn nil, \"\", fmt.Errorf(\"unable to parse origin URL %#v\", hostOriginURL)\n+\t\t}\n+\t\tconfig.HostToOriginUrls[k] = hostOriginURL\n+\t}\n \th := &TunnelHandler{\n \t\toriginUrl:         originURL,\n+\t\thostToOriginUrls:  config.HostToOriginUrls,\n \t\thttpHostHeader:    config.HTTPHostHeader,\n \t\thttpClient:        config.HTTPTransport,\n \t\ttlsConfig:         config.ClientTlsConfig,\n@@ -629,8 +640,27 @@ func (h *TunnelHandler) ServeStream(stream *h2mux.MuxedStream) error {\n \treturn nil\n }\n \n+func getOriginUrlForHost(h2 []h2mux.Header, hostToOriginUrls map[string]string) (string, string) {\n+\thost := \"\"\n+\tfor _, header := range h2 {\n+\t\tswitch strings.ToLower(header.Name) {\n+\t\tcase \":authority\":\n+\t\t\thost := header.Value\n+\t\t\tif val, ok := hostToOriginUrls[header.Value]; ok {\n+\t\t\t    return host, val\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn host, \"\"\n+}\n+\n func (h *TunnelHandler) createRequest(stream *h2mux.MuxedStream) (*http.Request, error) {\n-\treq, err := http.NewRequest(\"GET\", h.originUrl, h2mux.MuxedStreamReader{MuxedStream: stream})\n+\thost, origin := getOriginUrlForHost(stream.Headers, h.hostToOriginUrls)\n+\n+\tif host == \"\" {\n+\t\torigin = h.originUrl\n+\t}\n+\treq, err := http.NewRequest(\"GET\", origin, h2mux.MuxedStreamReader{MuxedStream: stream})\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"Unexpected error from http.NewRequest\")\n \t}\n---\n"}], "ideal": "Title: added option to map multiple cname hosts to multiple local origins\n\nBody: This add support for multiple local origin through a single cloudflared process.\r\nConfig file example to use it is as follows:\r\n\r\n```\r\nhostname: public.opus.ai\r\n # default url that will use any requests not coming through cname hosts\r\nurl: http://192.168.3.10:8080\r\nlogfile: ./cloudflared.log\r\norigincert: ./cert.pem\r\nno-autoupdate: true\r\nhost-to-origin:\r\n    # first service cnamed to public.example.com\r\n    - service1.opus.ai=http://localhost:8080\r\n    # second service cnamed to public.example.com\r\n    - service2.opus.ai=http://192.168.3.10:8080\r\n   .... # and so on\r\n```\r\n\r\n\r\nNote that each service still needs to be cnamed manually in cloudflare panel. It should be possible to use the api through the service itself but I haven't explored it yet.\r\n"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -1,8 +1,11 @@\n # use a builder image for building cloudflare\n+ARG TARGET_GOOS\n+ARG TARGET_GOARCH\n FROM golang:1.13.3 as builder\n-ENV GO111MODULE=on\n-ENV CGO_ENABLED=0\n-ENV GOOS=linux\n+ENV GO111MODULE=on \\\n+    CGO_ENABLED=0 \\\n+    TARGET_GOOS=${TARGET_GOOS} \\\n+    TARGET_GOARCH=${TARGET_GOARCH}\n \n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n@@ -12,8 +15,6 @@ COPY . .\n # compile cloudflared\n RUN make cloudflared\n \n-# ---\n-\n # use a distroless base image with glibc\n FROM gcr.io/distroless/base-debian10:nonroot\n \n---\nMakefile\n@@ -7,17 +7,35 @@ PACKAGE_DIR   := $(CURDIR)/packaging\n INSTALL_BINDIR := usr/local/bin\n \n EQUINOX_FLAGS = --version=\"$(VERSION)\" \\\n-\t\t\t\t --platforms=\"$(EQUINOX_BUILD_PLATFORMS)\" \\\n-\t\t\t\t --app=\"$(EQUINOX_APP_ID)\" \\\n-\t\t\t\t --token=\"$(EQUINOX_TOKEN)\" \\\n-\t\t\t\t --channel=\"$(EQUINOX_CHANNEL)\"\n+\t--platforms=\"$(EQUINOX_BUILD_PLATFORMS)\" \\\n+\t--app=\"$(EQUINOX_APP_ID)\" \\\n+\t--token=\"$(EQUINOX_TOKEN)\" \\\n+\t--channel=\"$(EQUINOX_CHANNEL)\"\n \n ifeq ($(EQUINOX_IS_DRAFT), true)\n \tEQUINOX_FLAGS := --draft $(EQUINOX_FLAGS)\n endif\n \n-ifeq ($(GOARCH),)\n-\tGOARCH := amd64\n+LOCAL_ARCH ?= $(shell uname -m)\n+ifeq ($(LOCAL_ARCH),x86_64)\n+    TARGET_ARCH ?= amd64\n+else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 5),armv8)\n+    TARGET_ARCH ?= arm64\n+else ifeq ($(LOCAL_ARCH),aarch64)\n+    TARGET_ARCH ?= arm64\n+else ifeq ($(shell echo $(LOCAL_ARCH) | head -c 4),armv)\n+    TARGET_ARCH ?= arm\n+else\n+    $(error This system's architecture $(LOCAL_ARCH) isn't supported)\n+endif\n+\n+LOCAL_OS ?= $(shell go env GOOS)\n+ifeq ($(LOCAL_OS),linux)\n+    TARGET_OS ?= linux\n+else ifeq ($(LOCAL_OS),darwin)\n+    TARGET_OS ?= darwin\n+else\n+    $(error This system's OS $(LOCAL_OS) isn't supported)\n endif\n \n .PHONY: all\n@@ -29,11 +47,11 @@ clean:\n \n .PHONY: cloudflared\n cloudflared: tunnel-deps\n-\tgo build -v -mod=vendor $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) go build -v -mod=vendor $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n \n .PHONY: container\n container:\n-\tdocker build -t cloudflare/cloudflared:\"$(VERSION)\" .\n+\tdocker build --build-arg=TARGET_ARCH=$(TARGET_ARCH) --build-arg=TARGET_OS=$(TARGET_OS) -t cloudflare/cloudflared-$(TARGET_OS)-$(TARGET_ARCH):\"$(VERSION)\" .\n \n .PHONY: test\n test: vet\n@@ -48,7 +66,7 @@ cloudflared-deb: cloudflared\n \tmkdir -p $(PACKAGE_DIR)\n \tcp cloudflared $(PACKAGE_DIR)/cloudflared\n \tfakeroot fpm -C $(PACKAGE_DIR) -s dir -t deb --deb-compression bzip2 \\\n-\t\t-a $(GOARCH) -v $(VERSION) -n cloudflared cloudflared=/usr/local/bin/\n+\t\t-a $(TARGET_ARCH) -v $(VERSION) -n cloudflared cloudflared=/usr/local/bin/\n \n .PHONY: cloudflared-darwin-amd64.tgz\n cloudflared-darwin-amd64.tgz: cloudflared\n---\ncmd/cloudflared/windows_service.go\n@@ -16,7 +16,6 @@ import (\n \t\"github.com/pkg/errors\"\n \tcli \"gopkg.in/urfave/cli.v2\"\n \n-\t\"github.com/pkg/errors\"\n \t\"golang.org/x/sys/windows\"\n \t\"golang.org/x/sys/windows/svc\"\n \t\"golang.org/x/sys/windows/svc/eventlog\"\n---\n"}], "ideal": "Title: Adding support for multi-architecture images and binaries\n\nBody: Fixes: \r\n- #140 \r\n- #115 \r\n- #60 \r\n\r\nNote: Should also consider consolidating the following pull request if you wish to support releasing the binary.\r\n- #173 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -129,8 +129,8 @@ func Commands() []*cli.Command {\n \t\t\t\t},\n \t\t\t\t&cli.StringSliceFlag{\n \t\t\t\t\tName:    \"upstream\",\n-\t\t\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy.\",\n-\t\t\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://1.0.0.1/dns-query\"),\n+\t\t\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy. If required, the Host header can be manually set by appending a hash to the URL.\",\n+\t\t\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://[2606:4700:4700::1111]/dns-query\", \"https://1.0.0.1/dns-query\", \"https://[2606:4700:4700::1001]/dns-query\"),\n \t\t\t\t\tEnvVars: []string{\"TUNNEL_DNS_UPSTREAM\"},\n \t\t\t\t},\n \t\t\t},\n@@ -934,8 +934,8 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t}),\n \t\taltsrc.NewStringSliceFlag(&cli.StringSliceFlag{\n \t\t\tName:    \"proxy-dns-upstream\",\n-\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy.\",\n-\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://1.0.0.1/dns-query\"),\n+\t\t\tUsage:   \"Upstream endpoint URL, you can specify multiple endpoints for redundancy. If required, the Host header can be manually set by appending a hash to the URL.\",\n+\t\t\tValue:   cli.NewStringSlice(\"https://1.1.1.1/dns-query\", \"https://[2606:4700:4700::1111]/dns-query\", \"https://1.0.0.1/dns-query\", \"https://[2606:4700:4700::1001]/dns-query\"),\n \t\t\tEnvVars: []string{\"TUNNEL_DNS_UPSTREAM\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n---\ntunneldns/https_upstream.go\n@@ -35,6 +35,10 @@ func NewUpstreamHTTPS(endpoint string) (Upstream, error) {\n \n \t// Update TLS and HTTP client configuration\n \ttls := &tls.Config{ServerName: u.Hostname()}\n+\tif u.Fragment != \"\" {\n+\t\t// Allow server name override via anchor on the url\n+\t\ttls.ServerName = u.Fragment\n+\t}\n \ttransport := &http.Transport{\n \t\tTLSClientConfig:    tls,\n \t\tDisableCompression: true,\n@@ -84,6 +88,10 @@ func (u *UpstreamHTTPS) exchangeWireformat(msg []byte) ([]byte, error) {\n \n \treq.Header.Add(\"Content-Type\", \"application/dns-message\")\n \treq.Host = u.endpoint.Host\n+\tif u.endpoint.Fragment != \"\" {\n+\t\t// Allow server name override via anchor on the url\n+\t\treq.Host = u.endpoint.Fragment\n+\t}\n \n \tresp, err := u.client.Do(req)\n \tif err != nil {\n---\n"}], "ideal": "Title: proxy-dns: Allow setting the Host header via url hash\n\nBody: Some DoH providers (namely Google) won't accept IP addresses in the Host header of DoH requests.\r\n\r\nAs I mentioned in #113, using dns.google with cloudflared currently requires using the url `https://dns.google/dns-query`. This however causes a bootstrapping issue if cloudflared has been set as the system's only resolver, as dns.google can't be resolved. dns.google therefore needs to be added to the system's host file. Even then, this solution is not ideal, as the host file can only define one IP address per hostname.\r\n\r\nThis PR allows the HTTP Host header and TLS verification name to be overridden by adding a hash/anchor/fragment to the end of the URL. In normal HTTP implementations, the segment of the URL after the hash is not sent to the server, and in DoH specifically, it serves no purpose.\r\n\r\nAfter the implementation of this change, services that require a specific Host header like dns.google could be used with upstream settings like this:\r\n\r\n```\r\nproxy-dns-upstream:\r\n - https://8.8.8.8/dns-query#dns.google\r\n - https://8.8.4.4/dns-query#dns.google\r\n - https://[2001:4860:4860::8888]/dns-query#dns.google\r\n - https://[2001:4860:4860::8844]/dns-query#dns.google\r\n```\r\n\r\nI also added Cloudflare DNS's IPv6 addresses to the default DoH configuration while I was editing the argument list, as IPv6 support was fixed in #168.\r\n\r\nFixes #113 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "origin/supervisor.go\n@@ -103,6 +103,7 @@ func NewSupervisor(config *TunnelConfig, u uuid.UUID) (*Supervisor, error) {\n \t\tlogger:            config.Logger.WithField(\"subsystem\", \"supervisor\"),\n \t\tjwtLock:           &sync.RWMutex{},\n \t\teventDigestLock:   &sync.RWMutex{},\n+\t\tconnDigestLock:    &sync.RWMutex{},\n \t\tbufferPool:        buffer.NewPool(512 * 1024),\n \t}, nil\n }\n---\n"}], "ideal": "Title: Fix supervisor segfault due to nil pointer access\n\nBody: The code was trying to access `connDigestLock.Lock()` causing a panic, because it wasn't intialized in `NewSupervisor`:\r\n\r\n```\r\npanic: runtime error: invalid memory address or nil pointer dereference\r\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x48a70d]\r\n\r\ngoroutine 80 [running]:\r\nsync.(*RWMutex).Lock(0x0)\r\n\t/usr/local/go/src/sync/rwmutex.go:98 +0x2d\r\ngithub.com/cloudflare/cloudflared/origin.(*Supervisor).SetConnDigest(0xc00007a0d0, 0x0, 0x0, 0x0)\r\n\t/app/origin/supervisor.go:349 +0x43\r\ngithub.com/cloudflare/cloudflared/origin.RegisterTunnel(0x1640d80, 0xc00079a780, 0x1644240, 0xc00007a0d0, 0xc00031a1e0, 0xc0000b09a0, 0xc00020ce00, 0x1239300, 0xc00078e4b0, 0x10, ...)\r\n\t/app/origin/tunnel.go:385 +0x4c4\r\ngithub.com/cloudflare/cloudflared/origin.ServeTunnel.func2(0x0, 0x0)\r\n\t/app/origin/tunnel.go:293 +0x17a\r\ngolang.org/x/sync/errgroup.(*Group).Go.func1(0xc00016d020, 0xc00091b680)\r\n\t/app/vendor/golang.org/x/sync/errgroup/errgroup.go:57 +0x59\r\ncreated by golang.org/x/sync/errgroup.(*Group).Go\r\n\t/app/vendor/golang.org/x/sync/errgroup/errgroup.go:54 +0x66\r\n```"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/configuration.go\n@@ -237,7 +237,6 @@ func prepareTunnelConfig(\n \terr = validation.ValidateHTTPService(originURL, hostname, httpTransport)\n \tif err != nil {\n \t\tlogger.WithError(err).Error(\"unable to connect to the origin\")\n-\t\treturn nil, errors.Wrap(err, \"unable to connect to the origin\")\n \t}\n \n \ttoEdgeTLSConfig, err := tlsconfig.CreateTunnelConfig(c)\n---\n"}], "ideal": "Title: do not terminate tunnel if origin is not reachable on start-up\n\nBody: fixes: https://github.com/cloudflare/cloudflared/issues/175\r\n\r\nHaving this termination on startup phase makes it hard to use cloudflared tunnel in a dynamic environments such as k8s, tunnel has already logic to retry to connect to origin so this is a safe change.\r\nI've tested it locally with nginx container like this:\r\n\r\n\r\n1. `$  ./cloudflared tunnel  --url=localhost:8888`:\r\n```\r\nWARN[0000] Cannot determine default configuration path. No file [config.yml config.yaml] in [~/.cloudflared ~/.cloudflare-warp ~/cloudflare-warp /usr/local/etc/cloudflared /etc/cloudflared] \r\nINFO[0000] Version 2020.2.0-5-g52ab2c8-dev              \r\nINFO[0000] GOOS: darwin, GOVersion: go1.13.6, GoArch: amd64 \r\nINFO[0000] Flags                                         proxy-dns-upstream=\"https://1.1.1.1/dns-query, https://1.0.0.1/dns-query\" url=\"localhost:8888\"\r\nINFO[0000] Starting metrics server                       addr=\"127.0.0.1:51871\"\r\nINFO[0000] cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/argo-tunnel/reference/service/ \r\nINFO[0000] Proxying tunnel requests to http://localhost:8888 \r\nERRO[0000] unable to connect to the origin               error=\"Get http://localhost:8888: dial tcp [::1]:8888: connect: connection refused\"\r\nINFO[0000] Connected to WAW                              connectionID=0\r\nINFO[0003] Each HA connection's tunnel IDs: map[0:z2yglkx1959ufvzhhfk3ulqx62r5lyith8itg5hsxsnd065nucd0]  connectionID=0\r\nINFO[0003] +-----------------------------------------------------------+  connectionID=0\r\nINFO[0003] |  Your free tunnel has started! Visit it:                  |  connectionID=0\r\nINFO[0003] |    https://diane-pizza-output-performs.trycloudflare.com  |  connectionID=0\r\nINFO[0003] +-----------------------------------------------------------+  connectionID=0\r\nINFO[0003] Route propagating, it may take up to 1 minute for your new route to become functional  connectionID=0\r\nINFO[0003] Connected to KBP                              connectionID=1\r\nINFO[0004] Connected to WAW                              connectionID=2\r\nINFO[0005] Connected to KBP                              connectionID=3\r\nINFO[0005] Each HA connection's tunnel IDs: map[0:z2yglkx1959ufvzhhfk3ulqx62r5lyith8itg5hsxsnd065nucd0 1:z2yglkx1959ufvzhhfk3ulqx62r5lyith8itg5hsxsnd065nucd0]  connectionID=1\r\nINFO[0005] +-----------------------------------------------------------+  connectionID=1\r\nINFO[0005] |  Your free tunnel has started! Visit it:                  |  connectionID=1\r\nINFO[0005] |    https://diane-pizza-output-performs.trycloudflare.com  |  connectionID=1\r\nINFO[0005] +-----------------------------------------------------------+  connectionID=1\r\nINFO[0005] Route propagating, it may take up to 1 minute for your new route to become functional  connectionID=1\r\nINFO[0006] Each HA connection's tunnel IDs: map[0:z2yglkx1959ufvzhhfk3ulqx62r5lyith8itg5hsxsnd065nucd0 1:z2yglkx1959ufvzhhfk3ulqx62r5lyith8itg5hsxsnd065nucd0 2:z2yglkx1959ufvzhhfk3ulqx62r5lyith8itg5hsxsnd065nucd0]  connectionID=2\r\nINFO[0006] +-----------------------------------------------------------+  connectionID=2\r\nINFO[0006] |  Your free tunnel has started! Visit it:                  |  connectionID=2\r\nINFO[0006] |    https://diane-pizza-output-performs.trycloudflare.com  |  connectionID=2\r\nINFO[0006] +-----------------------------------------------------------+  connectionID=2\r\nINFO[0006] Route propagating, it may take up to 1 minute for your new route to become functional  connectionID=2\r\nINFO[0007] Each HA connection's tunnel IDs: map[0:z2yglkx1959ufvzhhfk3ulqx62r5lyith8itg5hsxsnd065nucd0 1:z2yglkx1959ufvzhhfk3ulqx62r5lyith8itg5hsxsnd065nucd0 2:z2yglkx1959ufvzhhfk3ulqx62r5lyith8itg5hsxsnd065nucd0 3:z2yglkx1959ufvzhhfk3ulqx62r5lyith8itg5hsxsnd065nucd0]  connectionID=3\r\nINFO[0007] +-----------------------------------------------------------+  connectionID=3\r\nINFO[0007] |  Your free tunnel has started! Visit it:                  |  connectionID=3\r\nINFO[0007] |    https://diane-pizza-output-performs.trycloudflare.com  |  connectionID=3\r\nINFO[0007] +-----------------------------------------------------------+  connectionID=3\r\nINFO[0007] Route propagating, it may take up to 1 minute for your new route to become functional  connectionID=3\r\nERRO[0038] HTTP request error                            error=\"Error proxying request to origin: dial tcp [::1]:8888: connect: connection refused\"\r\nERRO[0038] HTTP request error                            error=\"Error proxying request to origin: dial tcp [::1]:8888: connect: connection refused\"\r\nERRO[0038] HTTP request error                            error=\"Error proxying request to origin: dial tcp [::1]:8888: connect: connection refused\"\r\nERRO[0038] HTTP request error                            error=\"Error proxying request to origin: dial tcp [::1]:8888: connect: connection refused\"\r\n```\r\n\r\n2. `docker run -ti -p 8888:8080 nginx` once nginx container is running tunnel picks it up and everything  just works."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "RELEASE_NOTES\n@@ -112,7 +112,7 @@\n 2019.9.0\n - 2019-09-05 TUN-2279: Revert path encoding fix\n - 2019-08-30 AUTH-2021 - check error for failing tests\n-- 2019-08-29 AUTH-2030: Support both authorized_key and short lived cert authentication simultaniously without specifiying at start time\n+- 2019-08-29 AUTH-2030: Support both authorized_key and short lived cert authentication simultaneously without specifying at start time\n - 2019-08-29 AUTH-2026: Adds support for non-pty sessions and inline command exec\n - 2019-08-26 AUTH-1943: Adds session logging\n - 2019-08-26 TUN-2162: Decomplect OpenStream to allow finer-grained timeouts\n---\ncmd/cloudflared/config/configuration.go\n@@ -67,7 +67,7 @@ func FindDefaultConfigPath() string {\n // i.e. it fails if a user specifies both --url and --unix-socket\n func ValidateUnixSocket(c *cli.Context) (string, error) {\n \tif c.IsSet(\"unix-socket\") && (c.IsSet(\"url\") || c.NArg() > 0) {\n-\t\treturn \"\", errors.New(\"--unix-socket must be used exclusivly.\")\n+\t\treturn \"\", errors.New(\"--unix-socket must be used exclusively.\")\n \t}\n \treturn c.String(\"unix-socket\"), nil\n }\n---\ncmd/cloudflared/tunnel/signal.go\n@@ -28,7 +28,7 @@ func waitForSignal(errC chan error, shutdownC chan struct{}) error {\n \n // waitForSignalWithGraceShutdown notifies all routines to shutdown immediately\n // by closing the shutdownC when one of the routines in main exits.\n-// When this process recieves SIGTERM/SIGINT, it closes the graceShutdownC to\n+// When this process receives SIGTERM/SIGINT, it closes the graceShutdownC to\n // notify certain routines to start graceful shutdown. When grace period is over,\n // or when some routine exits, it notifies the rest of the routines to shutdown\n // immediately by closing shutdownC.\n---\ndbconnect/cmd.go\n@@ -149,7 +149,7 @@ func CmdAction(c *cli.Context) error {\n \t\t}\n \t}()\n \n-\t// Block until the the Proxy is online, retreive its address, and change the url to point to it.\n+\t// Block until the the Proxy is online, retrieve its address, and change the url to point to it.\n \t// This is effectively \"handing over\" control to the tunnel package so it can run the tunnel daemon.\n \tc.Set(\"url\", \"https://\"+(<-listenerC).Addr().String())\n \n---\ndbconnect/proxy.go\n@@ -98,7 +98,7 @@ func (proxy *Proxy) IsAllowed(r *http.Request, verbose ...bool) bool {\n \n // Start the Proxy at a given address and notify the listener channel when the server is online.\n func (proxy *Proxy) Start(ctx context.Context, addr string, listenerC chan<- net.Listener) error {\n-\t// STOR-611: use a seperate listener and consider web socket support.\n+\t// STOR-611: use a separate listener and consider web socket support.\n \thttpListener, err := hello.CreateTLSListener(addr)\n \tif err != nil {\n \t\treturn errors.Wrapf(err, \"could not create listener at %s\", addr)\n@@ -217,7 +217,7 @@ func (proxy *Proxy) httpSubmit() http.HandlerFunc {\n func (proxy *Proxy) httpRespond(w http.ResponseWriter, r *http.Request, status int, message string) {\n \tw.WriteHeader(status)\n \n-\t// Only expose the message detail of the reponse if the request is not HEAD\n+\t// Only expose the message detail of the response if the request is not HEAD\n \t// and the user is authenticated. For example, this prevents an unauthenticated\n \t// failed health check from accidentally leaking sensitive information about the Client.\n \tif r.Method != http.MethodHead && proxy.IsAllowed(r) {\n---\ndbconnect/sql.go\n@@ -278,10 +278,10 @@ func sqlRows(rows *sql.Rows) ([]map[string]interface{}, error) {\n func sqlValue(val interface{}, col *sql.ColumnType) interface{} {\n \tbytes, ok := val.([]byte)\n \tif ok {\n-\t\t// Opportunistically check for embeded JSON and convert it to a first-class object.\n-\t\tvar embeded interface{}\n-\t\tif json.Unmarshal(bytes, &embeded) == nil {\n-\t\t\treturn embeded\n+\t\t// Opportunistically check for embedded JSON and convert it to a first-class object.\n+\t\tvar embedded interface{}\n+\t\tif json.Unmarshal(bytes, &embedded) == nil {\n+\t\t\treturn embedded\n \t\t}\n \n \t\t// STOR-604: investigate a way to coerce PostgreSQL arrays '{a, b, ...}' into JSON.\n---\nh2mux/h2_dictionaries.go\n@@ -468,7 +468,7 @@ func assignDictToStream(s *MuxedStream, p []byte) bool {\n \t\t}\n \t} else {\n \t\t// Use the overflow dictionary as last resort\n-\t\t// If slots are availabe generate new dictioanries for path and content-type\n+\t\t// If slots are available generate new dictionaries for path and content-type\n \t\tuseID, _ = h2d.getGenericDictID()\n \t\tpathID, pathFound = h2d.getNextDictID()\n \t\tif pathFound {\n---\nh2mux/h2mux.go\n@@ -273,7 +273,7 @@ func (m *Muxer) readPeerSettings(magic uint32) error {\n \t\tm.compressionQuality = compressionPresets[CompressionNone]\n \t\treturn nil\n \t}\n-\t// Values used for compression are the mimimum between the two peers\n+\t// Values used for compression are the minimum between the two peers\n \tif sz < m.compressionQuality.dictSize {\n \t\tm.compressionQuality.dictSize = sz\n \t}\n---\noriginservice/originservice_test.go\n@@ -39,7 +39,7 @@ func TestIsEventStream(t *testing.T) {\n \t\t\t// Content-Type and text/event-stream are case-insensitive. text/event-stream can be followed by OWS parameter\n \t\t\tresp: &http.Response{\n \t\t\t\tHeader: http.Header{\n-\t\t\t\t\t\"content-type\": []string{\"appication/json\", \"text/html\", \"Text/event-stream;charset=utf-8\"},\n+\t\t\t\t\t\"content-type\": []string{\"application/json\", \"text/html\", \"Text/event-stream;charset=utf-8\"},\n \t\t\t\t},\n \t\t\t},\n \t\t\tisEventStream: true,\n---\ntunnelrpc/tunnelrpc.capnp\n@@ -100,7 +100,7 @@ struct ClientConfig {\n     # supervisorConfig  is configuration for supervisor, the component that manages connection manager,\n     # autoupdater and metrics server\n     supervisorConfig @1 :SupervisorConfig;\n-    # edgeConnectionConfig is configuration for connection manager, the componenet that manages connections with the edge\n+    # edgeConnectionConfig is the configuration for the connection manager, the component that manages connections with the edge\n     edgeConnectionConfig @2 :EdgeConnectionConfig;\n     # Configuration for cloudflared to run as a DNS-over-HTTPS proxy.\n     # cloudflared CLI option: `proxy-dns`\n---\nvalidation/validation.go\n@@ -74,7 +74,7 @@ func ValidateUrl(originUrl string) (string, error) {\n \tif net.ParseIP(originUrl) != nil {\n \t\treturn validateIP(\"\", originUrl, \"\")\n \t} else if strings.HasPrefix(originUrl, \"[\") && strings.HasSuffix(originUrl, \"]\") {\n-\t\t// ParseIP doesn't recoginze [::1]\n+\t\t// ParseIP doesn't recognize [::1]\n \t\treturn validateIP(\"\", originUrl[1:len(originUrl)-1], \"\")\n \t}\n \n---\n"}], "ideal": "Title: Assorted typo fixes\n\nBody: BTW I left the vendor folder untouched since I assume that's third-party code."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cfsetup.yaml\n@@ -54,6 +54,17 @@ stretch: &stretch\n       - export GOARCH=arm\n       - export CC=arm-linux-gnueabihf-gcc\n       - make release\n+  release-linux-arm64:\n+    build_dir: *build_dir\n+    builddeps:\n+      - *pinned_go\n+      - build-essential\n+      - gcc-aarch64-linux-gnu\n+    post-cache:\n+      - export GOOS=linux\n+      - export GOARCH=arm64\n+      - export CC=gcc-aarch64-linux-gnu\n+      - make release\n   github-release-linux-armv6:\n     build_dir: *build_dir\n     builddeps:\n---\n"}], "ideal": "Title: add arm64 support\n\nBody: ubuntu official supports Raspberry Pi\r\n\r\nhttps://ubuntu.com/download/raspberry-pi\r\nhttps://wiki.ubuntu.com/ARM/RaspberryPi\r\n> Note that the information on this page currently only applies to the (ARMv7 and ARMv8) Raspberry Pis: 2B, 3B, 3A+, 3B+, 4B, Compute Module 3, and Compute Module 3+. The original (ARMv6) based Raspberry Pis, including the A, B, B+, 0 and 0W, are not supported under Ubuntu.\r\n\r\nit will be nice to have an arm64 build\r\n\r\ntry to fix #60  #115  #140  "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "tunneldns/https_upstream.go\n@@ -83,7 +83,7 @@ func (u *UpstreamHTTPS) exchangeWireformat(msg []byte) ([]byte, error) {\n \t}\n \n \treq.Header.Add(\"Content-Type\", \"application/dns-message\")\n-\treq.Host = u.endpoint.Hostname()\n+\treq.Host = u.endpoint.Host\n \n \tresp, err := u.client.Do(req)\n \tif err != nil {\n---\n"}], "ideal": "Title: Tweak HTTP host header. Fixes #107\n\nBody: I finally got the the root cause of the odd behaviour in #107.\r\n\r\nIt's to do with the HTTP Host headers accepted by 1.1.1.1.\r\n\r\nWith this working example, you can see that curl automatically sets the Host request header to `[2606:4700:4700::1111]`:\r\n\r\n    $ echo -n 'q80BAAABAAAAAAAAA3d3dwdleGFtcGxlA2NvbQAAAQAB' | base64 -D | curl -v -H 'content-type: application/dns-message' --data-binary @- https://[2606:4700:4700::1111]/dns-query -o -\r\n    ...\r\n    > Host: [2606:4700:4700::1111]\r\n    ...\r\n    < HTTP/2 200\r\n    ...\r\n\r\nIn this non-working example, the Host header is force-set to `2606:4700:4700::1111` (without brackets, as cloudflared does) and the server returns the 403 error seen when trying to use the IPv6 server in cloudflared:\r\n\r\n    $ echo -n 'q80BAAABAAAAAAAAA3d3dwdleGFtcGxlA2NvbQAAAQAB' | base64 -D | curl -v -H 'content-type: application/dns-message' --data-binary @- https://[2606:4700:4700::1111]/dns-query -o - -H 'Host: 2606:4700:4700::1111'\r\n    ...\r\n    > Host: 2606:4700:4700::1111\r\n    ...\r\n    < HTTP/2 403\r\n    ...\r\n\r\nThe simple way I found to fix this was using `u.endpoint.Host` instead of `u.endpoint.Hostname()` to set the Host header, which doesn't strip out the brackets. I'm new to Go, so I don't know if that'll have any side effects, but at least the root cause is now known and some other solution can be found."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "buffer/pool.go\n@@ -0,0 +1,29 @@\n+package buffer\n+\n+import (\n+\t\"sync\"\n+)\n+\n+type Pool struct {\n+\t// A Pool must not be copied after first use.\n+\t// https://golang.org/pkg/sync/#Pool\n+\tbuffers sync.Pool\n+}\n+\n+func NewPool(bufferSize int) *Pool {\n+\treturn &Pool{\n+\t\tbuffers: sync.Pool{\n+\t\t\tNew: func() interface{} {\n+\t\t\t\treturn make([]byte, bufferSize)\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func (p *Pool) Get() []byte {\n+\treturn p.buffers.Get().([]byte)\n+}\n+\n+func (p *Pool) Put(buf []byte) {\n+\tp.buffers.Put(buf)\n+}\n---\norigin/supervisor.go\n@@ -11,6 +11,7 @@ import (\n \t\"github.com/google/uuid\"\n \t\"github.com/sirupsen/logrus\"\n \n+\t\"github.com/cloudflare/cloudflared/buffer\"\n \t\"github.com/cloudflare/cloudflared/connection\"\n \t\"github.com/cloudflare/cloudflared/edgediscovery\"\n \t\"github.com/cloudflare/cloudflared/h2mux\"\n@@ -62,6 +63,8 @@ type Supervisor struct {\n \n \teventDigestLock *sync.RWMutex\n \teventDigest     []byte\n+\n+\tbufferPool *buffer.Pool\n }\n \n type resolveResult struct {\n@@ -96,6 +99,7 @@ func NewSupervisor(config *TunnelConfig, u uuid.UUID) (*Supervisor, error) {\n \t\tlogger:            config.Logger.WithField(\"subsystem\", \"supervisor\"),\n \t\tjwtLock:           &sync.RWMutex{},\n \t\teventDigestLock:   &sync.RWMutex{},\n+\t\tbufferPool:        buffer.NewPool(512 * 1024),\n \t}, nil\n }\n \n@@ -230,7 +234,7 @@ func (s *Supervisor) startFirstTunnel(ctx context.Context, connectedSignal *sign\n \t\treturn\n \t}\n \n-\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID)\n+\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID, s.bufferPool)\n \t// If the first tunnel disconnects, keep restarting it.\n \tedgeErrors := 0\n \tfor s.unusedIPs() {\n@@ -253,7 +257,7 @@ func (s *Supervisor) startFirstTunnel(ctx context.Context, connectedSignal *sign\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n-\t\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID)\n+\t\terr = ServeTunnelLoop(ctx, s, s.config, addr, thisConnID, connectedSignal, s.cloudflaredUUID, s.bufferPool)\n \t}\n }\n \n@@ -272,7 +276,7 @@ func (s *Supervisor) startTunnel(ctx context.Context, index int, connectedSignal\n \tif err != nil {\n \t\treturn\n \t}\n-\terr = ServeTunnelLoop(ctx, s, s.config, addr, uint8(index), connectedSignal, s.cloudflaredUUID)\n+\terr = ServeTunnelLoop(ctx, s, s.config, addr, uint8(index), connectedSignal, s.cloudflaredUUID, s.bufferPool)\n }\n \n func (s *Supervisor) newConnectedTunnelSignal(index int) *signal.Signal {\n---\norigin/tunnel.go\n@@ -20,6 +20,7 @@ import (\n \tlog \"github.com/sirupsen/logrus\"\n \t\"golang.org/x/sync/errgroup\"\n \n+\t\"github.com/cloudflare/cloudflared/buffer\"\n \t\"github.com/cloudflare/cloudflared/cmd/cloudflared/buildinfo\"\n \t\"github.com/cloudflare/cloudflared/connection\"\n \t\"github.com/cloudflare/cloudflared/h2mux\"\n@@ -178,6 +179,7 @@ func ServeTunnelLoop(ctx context.Context,\n \tconnectionID uint8,\n \tconnectedSignal *signal.Signal,\n \tu uuid.UUID,\n+\tbufferPool *buffer.Pool,\n ) error {\n \tconnectionLogger := config.Logger.WithField(\"connectionID\", connectionID)\n \tconfig.Metrics.incrementHaConnections()\n@@ -201,6 +203,7 @@ func ServeTunnelLoop(ctx context.Context,\n \t\t\tconnectedFuse,\n \t\t\t&backoff,\n \t\t\tu,\n+\t\t\tbufferPool,\n \t\t)\n \t\tif recoverable {\n \t\t\tif duration, ok := backoff.GetBackoffDuration(ctx); ok {\n@@ -223,6 +226,7 @@ func ServeTunnel(\n \tconnectedFuse *h2mux.BooleanFuse,\n \tbackoff *BackoffHandler,\n \tu uuid.UUID,\n+\tbufferPool *buffer.Pool,\n ) (err error, recoverable bool) {\n \t// Treat panics as recoverable errors\n \tdefer func() {\n@@ -243,7 +247,7 @@ func ServeTunnel(\n \ttags[\"ha\"] = connectionTag\n \n \t// Returns error from parsing the origin URL or handshake errors\n-\thandler, originLocalIP, err := NewTunnelHandler(ctx, config, addr, connectionID)\n+\thandler, originLocalIP, err := NewTunnelHandler(ctx, config, addr, connectionID, bufferPool)\n \tif err != nil {\n \t\terrLog := logger.WithError(err)\n \t\tswitch err.(type) {\n@@ -500,13 +504,16 @@ type TunnelHandler struct {\n \tconnectionID      string\n \tlogger            *log.Logger\n \tnoChunkedEncoding bool\n+\n+\tbufferPool *buffer.Pool\n }\n \n // NewTunnelHandler returns a TunnelHandler, origin LAN IP and error\n func NewTunnelHandler(ctx context.Context,\n \tconfig *TunnelConfig,\n \taddr *net.TCPAddr,\n \tconnectionID uint8,\n+\tbufferPool *buffer.Pool,\n ) (*TunnelHandler, string, error) {\n \toriginURL, err := validation.ValidateUrl(config.OriginUrl)\n \tif err != nil {\n@@ -522,6 +529,7 @@ func NewTunnelHandler(ctx context.Context,\n \t\tconnectionID:      uint8ToString(connectionID),\n \t\tlogger:            config.Logger,\n \t\tnoChunkedEncoding: config.NoChunkedEncoding,\n+\t\tbufferPool:        bufferPool,\n \t}\n \tif h.httpClient == nil {\n \t\th.httpClient = http.DefaultTransport\n@@ -642,7 +650,9 @@ func (h *TunnelHandler) serveHTTP(stream *h2mux.MuxedStream, req *http.Request)\n \t} else {\n \t\t// Use CopyBuffer, because Copy only allocates a 32KiB buffer, and cross-stream\n \t\t// compression generates dictionary on first write\n-\t\tio.CopyBuffer(stream, response.Body, make([]byte, 512*1024))\n+\t\tbuf := h.bufferPool.Get()\n+\t\tdefer h.bufferPool.Put(buf)\n+\t\tio.CopyBuffer(stream, response.Body, buf)\n \t}\n \treturn response, nil\n }\n---\noriginservice/originservice.go\n@@ -12,6 +12,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \n+\t\"github.com/cloudflare/cloudflared/buffer\"\n \t\"github.com/cloudflare/cloudflared/h2mux\"\n \t\"github.com/cloudflare/cloudflared/hello\"\n \t\"github.com/cloudflare/cloudflared/log\"\n@@ -33,13 +34,15 @@ type HTTPService struct {\n \tclient          http.RoundTripper\n \toriginURL       *url.URL\n \tchunkedEncoding bool\n+\tbufferPool      *buffer.Pool\n }\n \n func NewHTTPService(transport http.RoundTripper, url *url.URL, chunkedEncoding bool) OriginService {\n \treturn &HTTPService{\n \t\tclient:          transport,\n \t\toriginURL:       url,\n \t\tchunkedEncoding: chunkedEncoding,\n+\t\tbufferPool:      buffer.NewPool(512 * 1024),\n \t}\n }\n \n@@ -71,7 +74,9 @@ func (hc *HTTPService) Proxy(stream *h2mux.MuxedStream, req *http.Request) (*htt\n \t} else {\n \t\t// Use CopyBuffer, because Copy only allocates a 32KiB buffer, and cross-stream\n \t\t// compression generates dictionary on first write\n-\t\tio.CopyBuffer(stream, resp.Body, make([]byte, 512*1024))\n+\t\tbuf := hc.bufferPool.Get()\n+\t\tdefer hc.bufferPool.Put(buf)\n+\t\tio.CopyBuffer(stream, resp.Body, buf)\n \t}\n \treturn resp, nil\n }\n@@ -142,10 +147,11 @@ func (wsc *WebsocketService) Shutdown() {\n \n // HelloWorldService talks to the hello world example origin\n type HelloWorldService struct {\n-\tclient    http.RoundTripper\n-\tlistener  net.Listener\n-\toriginURL *url.URL\n-\tshutdownC chan struct{}\n+\tclient     http.RoundTripper\n+\tlistener   net.Listener\n+\toriginURL  *url.URL\n+\tshutdownC  chan struct{}\n+\tbufferPool *buffer.Pool\n }\n \n func NewHelloWorldService(transport http.RoundTripper) (OriginService, error) {\n@@ -164,7 +170,8 @@ func NewHelloWorldService(transport http.RoundTripper) (OriginService, error) {\n \t\t\tScheme: \"https\",\n \t\t\tHost:   listener.Addr().String(),\n \t\t},\n-\t\tshutdownC: shutdownC,\n+\t\tshutdownC:  shutdownC,\n+\t\tbufferPool: buffer.NewPool(512 * 1024),\n \t}, nil\n }\n \n@@ -184,7 +191,9 @@ func (hwc *HelloWorldService) Proxy(stream *h2mux.MuxedStream, req *http.Request\n \n \t// Use CopyBuffer, because Copy only allocates a 32KiB buffer, and cross-stream\n \t// compression generates dictionary on first write\n-\tio.CopyBuffer(stream, resp.Body, make([]byte, 512*1024))\n+\tbuf := hwc.bufferPool.Get()\n+\tdefer hwc.bufferPool.Put(buf)\n+\tio.CopyBuffer(stream, resp.Body, buf)\n \n \treturn resp, nil\n }\n---\n"}], "ideal": "Title: perf(cloudflared): reuse memory from buffer pool to get better throughput\n\nBody: There are three lines of code using `io.CopyBuffer()` with `make([]byte, 512*1024)` directly.\r\nAnd they will make the cloudflared be very busy on allocating and releasing memory and will threshold the tunnel throughput by increasing latency.\r\n\r\nThis PR try to replace these `make([]byte, 512*1024)` with a `sync.Pool` to avoid allocating the buffer on every requests.\r\n\r\nRef: https://github.com/cloudflare/cloudflared/issues/160"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/linux_service.go\n@@ -73,7 +73,7 @@ ExecStart=/bin/bash -c '{{ .Path }} update; code=$?; if [ $code -eq 64 ]; then s\n Description=Update Argo Tunnel\n \n [Timer]\n-OnUnitActiveSec=1d\n+OnCalendar=daily\n \n [Install]\n WantedBy=timers.target\n---\n"}], "ideal": "Title: Fix timer scheduling for systemd update service (#133)\n\nBody: The `cloudflared-update.timer` is now scheduled correctly instead of displaying \"n/a\" for the next runtime in `systemctl list-timers cloudflared-update.timer`.\r\n\r\nIt may also be desirable to `enable` this service as mentioned in #133, but I didn't want to make that decision."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": ".dependabot/config.yml\n@@ -0,0 +1,9 @@\n+version: 1\n+update_configs:\n+  - package_manager: \"docker\"\n+    directory: \"/\"\n+    update_schedule: \"daily\"\n+  \n+  - package_manager: \"go:modules\"\n+    directory: \"/\"\n+    update_schedule: \"daily\"\n---\n"}], "ideal": "Title: chore(dependabot): add config.yml\n\nBody: This adds dependabot integration which is integrated in GitHub.\r\nDoing so will automatically create pull requests (including changelog/commits) whenever a go dependency is updated or the golang Docker image is updated."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "carrier/carrier.go\n@@ -37,13 +37,6 @@ func (c *StdinoutStream) Write(p []byte) (int, error) {\n \treturn os.Stdout.Write(p)\n }\n \n-// Helper to allow defering the response close with a check that the resp is not nil\n-func closeRespBody(resp *http.Response) {\n-\tif resp != nil {\n-\t\tresp.Body.Close()\n-\t}\n-}\n-\n // StartClient will copy the data from stdin/stdout over a WebSocket connection\n // to the edge (originURL)\n func StartClient(logger *logrus.Logger, stream io.ReadWriter, options *StartOptions) error {\n@@ -92,7 +85,7 @@ func serveConnection(logger *logrus.Logger, c net.Conn, options *StartOptions) {\n func serveStream(logger *logrus.Logger, conn io.ReadWriter, options *StartOptions) error {\n \twsConn, err := createWebsocketStream(options)\n \tif err != nil {\n-\t\tlogger.WithError(err).Errorf(\"failed to connect to %s\\n\", options.OriginURL)\n+\t\tlogger.WithError(err).Errorf(\"failed to connect to %s. Are WebSockets allowed to your origin server?\", options.OriginURL)\n \t\treturn err\n \t}\n \tdefer wsConn.Close()\n@@ -113,7 +106,6 @@ func createWebsocketStream(options *StartOptions) (*cloudflaredWebsocket.Conn, e\n \treq.Header = options.Headers\n \n \twsConn, resp, err := cloudflaredWebsocket.ClientConnect(req, nil)\n-\tdefer closeRespBody(resp)\n \tif err != nil && IsAccessResponse(resp) {\n \t\twsConn, err = createAccessAuthenticatedStream(options)\n \t\tif err != nil {\n@@ -151,7 +143,6 @@ func IsAccessResponse(resp *http.Response) bool {\n // login again and generate a new one.\n func createAccessAuthenticatedStream(options *StartOptions) (*websocket.Conn, error) {\n \twsConn, resp, err := createAccessWebSocketStream(options)\n-\tdefer closeRespBody(resp)\n \tif err == nil {\n \t\treturn wsConn, nil\n \t}\n@@ -169,7 +160,6 @@ func createAccessAuthenticatedStream(options *StartOptions) (*websocket.Conn, er\n \t\treturn nil, err\n \t}\n \twsConn, resp, err = createAccessWebSocketStream(options)\n-\tdefer closeRespBody(resp)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n---\n"}], "ideal": "Title: Warn users about websockets being a requirement for SSH access\n\nBody: If WebSockets are disabled to the origin the WebSocket headers will be silently stripped and any attempt to access resources over SSH will fail with `websocket: bad handshake`. This PR improves that error message.\r\n\r\nThis is not mentioned anywhere in any documentation that I could find. \r\n\r\nThis PR also removes closing the response body as it is not necessary as per https://github.com/cloudflare/cloudflared/blob/master/websocket/websocket.go#L72-L73"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/configuration.go\n@@ -197,6 +197,7 @@ func prepareTunnelConfig(\n \thttpTransport := &http.Transport{\n \t\tProxy:                 http.ProxyFromEnvironment,\n \t\tMaxIdleConns:          c.Int(\"proxy-keepalive-connections\"),\n+\t\tMaxIdleConnsPerHost:   c.Int(\"proxy-keepalive-connections\"),\n \t\tIdleConnTimeout:       c.Duration(\"proxy-keepalive-timeout\"),\n \t\tTLSHandshakeTimeout:   c.Duration(\"proxy-tls-timeout\"),\n \t\tExpectContinueTimeout: 1 * time.Second,\n---\n"}], "ideal": "Title: Fix the http connection pool of tunnel\n\nBody: Set the `MaxIdleConnsPerHost` of `http.Transport` to `proxy-keepalive-connections`.\r\n\r\nSetting only the `MaxIdleConns` is not enough, the `MaxIdleConnsPerHost` must be set as well.\r\n\r\nOtherwise, `http.Transport` will use the `DefaultMaxIdleConnsPerHost`, which is 2,\r\nand then the connection pool will have only 2 connections hold."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "h2mux/h2_dictionaries.go\n@@ -542,7 +542,10 @@ func (w *h2DictWriter) Write(p []byte) (n int, err error) {\n }\n \n func (w *h2DictWriter) Close() error {\n-\treturn w.comp.Close()\n+\tif w.comp != nil {\n+\t\treturn w.comp.Close()\n+\t}\n+\treturn nil\n }\n \n // From http2/hpack\n---\n"}], "ideal": "Title: bug(cloudflared): nil pointer deference on h2DictWriter Close()\n\nBody: Unlike other h2DictWriter methods, the Close() method does check whether\r\nw.comp is nil.\r\n\r\nThis PR adds a check for non nil compressor before attempting to close\r\n\r\nBug: #141"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -1,28 +1,23 @@\n-# use a builder image for building cloudflare\n-FROM golang:1.13.3 as builder\n-ENV GO111MODULE=on\n-ENV CGO_ENABLED=0\n-ENV GOOS=linux\n+\n+FROM golang:1.12-alpine as builder\n \n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n \n-# copy our sources into the builder image\n COPY . .\n \n-# compile cloudflared\n-RUN make cloudflared\n-\n-# ---\n+ENV GO111MODULE on\n+ENV CGO_ENABLED 0\n \n-# use a distroless base image with glibc\n-FROM gcr.io/distroless/base-debian10:nonroot\n+RUN apk add --no-cache build-base=0.5-r1 git=2.22.0-r0 upx=3.95-r2 \\\n+    && make cloudflared \\\n+    && upx --no-progress cloudflared\n \n-# copy our compiled binary\n-COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+FROM scratch\n \n-# run as non-privileged user\n-USER nonroot\n+COPY --from=builder /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n \n-# command / entrypoint of container\n ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n+\n CMD [\"version\"]\n+\n+RUN [\"cloudflared\", \"--version\"]\n---\nMakefile\n@@ -6,6 +6,8 @@ IMPORT_PATH   := github.com/cloudflare/cloudflared\n PACKAGE_DIR   := $(CURDIR)/packaging\n INSTALL_BINDIR := usr/local/bin\n \n+DOCKER_CLI_EXPERIMENTAL := enabled\n+\n EQUINOX_FLAGS = --version=\"$(VERSION)\" \\\n \t\t\t\t --platforms=\"$(EQUINOX_BUILD_PLATFORMS)\" \\\n \t\t\t\t --app=\"$(EQUINOX_APP_ID)\" \\\n@@ -35,6 +37,17 @@ cloudflared: tunnel-deps\n container:\n \tdocker build -t cloudflare/cloudflared:\"$(VERSION)\" .\n \n+.PHONY: manifest\n+manifest:\n+\tdocker run --rm --privileged aptman/qus -s -- -r\n+\tdocker run --rm --privileged aptman/qus -s -- -p\n+\t-docker buildx create --use --name cloudflared\n+\tdocker buildx inspect --bootstrap\n+\tdocker buildx build . \\\n+\t\t-t cloudflare/cloudflared:\"$(VERSION)\" \\\n+\t\t--platform=linux/amd64,linux/arm64,linux/386,linux/arm/v7,linux/arm/v6 \\\n+\t\t--pull --push\n+\n .PHONY: test\n test: vet\n \tgo test -v -mod=vendor -race $(VERSION_FLAGS) ./...\n---\n"}], "ideal": "Title: support for multiarch docker manifest\n\nBody: merged from https://github.com/klutchell/cloudflared\r\nrequires 'docker login' prior to 'make manifest' so the image can be pushed"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -1,4 +1,7 @@\n FROM golang:1.12 as builder\n+ENV GO111MODULE=on\n+ENV CGO_ENABLED=0\n+ENV GOOS=linux\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n RUN apt-get update && apt-get install -y --no-install-recommends upx\n # Run after `apt-get update` to improve rebuild scenarios\n---\n"}], "ideal": "Title: Fix Docker build failure\n\nBody: Currently Docker containers fail to build on version 2019.11.0, this merge request makes the following changes to the Dockerfile:\r\n\r\n- Sets `GO111MODULE=on` which ensures that Go module support is activated. This resolves the following errors during Docker builds:\r\n\r\n> build flag -mod=vendor only valid when using modules\r\nmake: *** [Makefile:32: cloudflared] Error 1\r\n\r\n- Disables cgo by setting `CGO_ENABLED=0` which gives us a static binary, this resolves dependency issues which resulted in following error during runtime:\r\n\r\n> cloudflared: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.28' not found (required by cloudflared)\r\n\r\n- Ensures target OS `GOOS` is set to Linux for Docker builds."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "h2mux/h2mux.go\n@@ -19,7 +19,7 @@ const (\n \tmaxWindowSize            uint32        = (1 << 31) - 1 // 2^31-1 = 2147483647, max window size in http2 spec\n \tdefaultTimeout           time.Duration = 5 * time.Second\n \tdefaultRetries           uint64        = 5\n-\tdefaultWriteBufferMaxLen int           = 1024 * 1024 * 512 // 500mb\n+\tdefaultWriteBufferMaxLen int           = 1024 * 1024 // 1mb\n \n \tSettingMuxerMagic http2.SettingID = 0x42db\n \tMuxerMagicOrigin  uint32          = 0xa2e43c8b\n---\n"}], "ideal": "Title: Fix excessive memory usage streaming large files\n\nBody: This drops the default size auf the h2mux write buffer from 512 MB to 1 MB.\r\nThis massively reduces memory usage, since each stream has its own buffer.\r\n\r\nFixes #129"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "tunneldns/https_upstream.go\n@@ -34,7 +34,7 @@ func NewUpstreamHTTPS(endpoint string) (Upstream, error) {\n \t}\n \n \t// Update TLS and HTTP client configuration\n-\ttls := &tls.Config{ServerName: u.Hostname()}\n+\ttls := &tls.Config{ServerName: u.Hostname(), MinVersion: tls.VersionTLS12}\n \ttransport := &http.Transport{\n \t\tTLSClientConfig:    tls,\n \t\tDisableCompression: true,\n---\n"}], "ideal": "Title: Do not allow TLS versions less than 1.2 in DoH client\n\nBody: Added explicit MinVersion for TLS configuration."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -1,15 +1,28 @@\n-FROM golang:1.12 as builder\n+# use a builder image for building cloudflare\n+FROM golang:1.13.3 as builder\n ENV GO111MODULE=on\n ENV CGO_ENABLED=0\n ENV GOOS=linux\n+\n WORKDIR /go/src/github.com/cloudflare/cloudflared/\n-RUN apt-get update && apt-get install -y --no-install-recommends upx\n-# Run after `apt-get update` to improve rebuild scenarios\n+\n+# copy our sources into the builder image\n COPY . .\n+\n+# compile cloudflared\n RUN make cloudflared\n-RUN upx --no-progress cloudflared\n \n-FROM gcr.io/distroless/base\n-COPY --from=builder /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+# ---\n+\n+# use a distroless base image with glibc\n+FROM gcr.io/distroless/base-debian10:nonroot\n+\n+# copy our compiled binary\n+COPY --from=builder --chown=nonroot /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+\n+# run as non-privileged user\n+USER nonroot\n+\n+# command / entrypoint of container\n ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n CMD [\"version\"]\n---\n"}], "ideal": "Title: refactor(docker): optimize Dockerfile\n\nBody: Remove obsolete upx binary compression\r\nRun as unprivileged user\r\nUse debian10 rootless base image for latest glibc libraries"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/tunnel/cmd.go\n@@ -618,6 +618,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_HOSTNAME\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:    \"http-host-header\",\n+\t\t\tUsage:   \"Sets the HTTP Host header for the local webserver.\",\n+\t\t\tEnvVars: []string{\"TUNNEL_HTTP_HOST_HEADER\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewStringFlag(&cli.StringFlag{\n \t\t\tName:    \"origin-server-name\",\n \t\t\tUsage:   \"Hostname on the origin server certificate.\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -253,6 +253,7 @@ func prepareTunnelConfig(\n \t\tHTTPTransport:        httpTransport,\n \t\tHeartbeatInterval:    c.Duration(\"heartbeat-interval\"),\n \t\tHostname:             hostname,\n+\t\tHTTPHostHeader:       c.String(\"http-host-header\"),\n \t\tIncidentLookup:       origin.NewIncidentLookup(),\n \t\tIsAutoupdated:        c.Bool(\"is-autoupdated\"),\n \t\tIsFreeTunnel:         isFreeTunnel,\n---\norigin/tunnel.go\n@@ -53,6 +53,7 @@ type TunnelConfig struct {\n \tHTTPTransport        http.RoundTripper\n \tHeartbeatInterval    time.Duration\n \tHostname             string\n+\tHTTPHostHeader       string\n \tIncidentLookup       IncidentLookup\n \tIsAutoupdated        bool\n \tIsFreeTunnel         bool\n@@ -447,12 +448,13 @@ func H1ResponseToH2Response(h1 *http.Response) (h2 []h2mux.Header) {\n }\n \n type TunnelHandler struct {\n-\toriginUrl  string\n-\tmuxer      *h2mux.Muxer\n-\thttpClient http.RoundTripper\n-\ttlsConfig  *tls.Config\n-\ttags       []tunnelpogs.Tag\n-\tmetrics    *TunnelMetrics\n+\toriginUrl      string\n+\thttpHostHeader string\n+\tmuxer          *h2mux.Muxer\n+\thttpClient     http.RoundTripper\n+\ttlsConfig      *tls.Config\n+\ttags           []tunnelpogs.Tag\n+\tmetrics        *TunnelMetrics\n \t// connectionID is only used by metrics, and prometheus requires labels to be string\n \tconnectionID      string\n \tlogger            *log.Logger\n@@ -473,6 +475,7 @@ func NewTunnelHandler(ctx context.Context,\n \t}\n \th := &TunnelHandler{\n \t\toriginUrl:         originURL,\n+\t\thttpHostHeader:    config.HTTPHostHeader,\n \t\thttpClient:        config.HTTPTransport,\n \t\ttlsConfig:         config.ClientTlsConfig,\n \t\ttags:              config.Tags,\n@@ -566,6 +569,11 @@ func (h *TunnelHandler) createRequest(stream *h2mux.MuxedStream) (*http.Request,\n }\n \n func (h *TunnelHandler) serveWebsocket(stream *h2mux.MuxedStream, req *http.Request) (*http.Response, error) {\n+\tif h.httpHostHeader != \"\" {\n+\t\treq.Header.Set(\"Host\", h.httpHostHeader)\n+\t\treq.Host = h.httpHostHeader\n+\t}\n+\n \tconn, response, err := websocket.ClientConnect(req, h.tlsConfig)\n \tif err != nil {\n \t\treturn nil, err\n@@ -594,6 +602,11 @@ func (h *TunnelHandler) serveHTTP(stream *h2mux.MuxedStream, req *http.Request)\n \t// Request origin to keep connection alive to improve performance\n \treq.Header.Set(\"Connection\", \"keep-alive\")\n \n+\tif h.httpHostHeader != \"\" {\n+\t\treq.Header.Set(\"Host\", h.httpHostHeader)\n+\t\treq.Host = h.httpHostHeader\n+\t}\n+\n \tresponse, err := h.httpClient.RoundTrip(req)\n \tif err != nil {\n \t\treturn nil, errors.Wrap(err, \"Error proxying request to origin\")\n---\n"}], "ideal": "Title: Add support for specifying a specific HTTP Host: header on the origin.\n\nBody: Potentially resolves #111 \r\n\r\nVery quick implementation, didn't test everything, but what I did test worked for me.\r\n\r\nUsage: cloudflared tunnel -url http://localhost -httphost example.test\r\n\r\nCan someone please check it?"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "tunneldns/https_upstream.go\n@@ -82,7 +82,7 @@ func (u *UpstreamHTTPS) exchangeWireformat(msg []byte) ([]byte, error) {\n \t\treturn nil, errors.Wrap(err, \"failed to create an HTTPS request\")\n \t}\n \n-\treq.Header.Add(\"Content-Type\", \"application/dns-udpwireformat\")\n+\treq.Header.Add(\"Content-Type\", \"application/dns-message\")\n \treq.Host = u.endpoint.Hostname()\n \n \tresp, err := u.client.Do(req)\n---\n"}], "ideal": "Title: DoH: change the media type to application/dns-message\n\nBody: The media type for DoH was changed from `application/dns-udpwireformat` to `application/dns-message` in May 2018.\r\n\r\nRef: RFC8484 section 6."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/access/cmd.go\n@@ -3,10 +3,10 @@ package access\n import (\n \t\"errors\"\n \t\"fmt\"\n-\t\"html/template\"\n \t\"net/url\"\n \t\"os\"\n \t\"strings\"\n+\t\"text/template\"\n \n \t\"github.com/cloudflare/cloudflared/cmd/cloudflared/shell\"\n \t\"github.com/cloudflare/cloudflared/cmd/cloudflared/token\"\n@@ -31,12 +31,12 @@ Add this configuration block to your {{.Home}}/.ssh/config:\n \n Host {{.Hostname}}\n {{- if .ShortLivedCerts}}\n-\tProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt cfpipe >&2 <&1' \n+\tProxyCommand bash -c '{{.Cloudflared}} access ssh-gen --hostname %h; ssh -tt cfpipe-{{.Hostname}} >&2 <&1'\n \n Host cfpipe-{{.Hostname}}\n \tHostName {{.Hostname}}\n \tProxyCommand {{.Cloudflared}} access ssh --hostname %h\n-\tIdentityFile ~/.cloudflared/{{.Hostname}}.me-cf_key\n+\tIdentityFile ~/.cloudflared/{{.Hostname}}-cf_key\n \tCertificateFile ~/.cloudflared/{{.Hostname}}-cf_key-cert.pub\n {{- else}}\n \tProxyCommand {{.Cloudflared}} access ssh --hostname %h\n---\n"}], "ideal": "Title: Access/ssh-config: generate consistent ssh_config\n\nBody: * Prefer text/template over html/template to avoid unwanted HTML encoding\r\n* Use templated \"cfpipe-{{.Hostname}}\"\r\n* Fix IdentityFile suffix in \"cfpipe\" to use key generated by \"ssh-gen\""}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Makefile\n@@ -1,6 +1,6 @@\n VERSION       := $(shell git describe --tags --always --dirty=\"-dev\" --match \"[0-9][0-9][0-9][0-9].*.*\")\n DATE          := $(shell date -u '+%Y-%m-%d-%H%M UTC')\n-VERSION_FLAGS := -ldflags='-X \"main.Version=$(VERSION)\" -X \"main.BuildTime=$(DATE)\"'\n+LD_FLAGS      := -X \"main.Version=$(VERSION)\" -X \"main.BuildTime=$(DATE)\"\n MSI_VERSION   := $(shell git tag -l --sort=v:refname | grep \"w\" | tail -1 | cut -c2-)\n #MSI_VERSION expects the format of the tag to be: (wX.X.X). Starts with the w character to not break cfsetup.\n #e.g. w3.0.1 or w4.2.10. It trims off the w character when creating the MSI.\n@@ -62,6 +62,10 @@ else\n \tTARGET_PUBLIC_REPO ?= $(FLAVOR)\n endif\n \n+ifneq ($(DEBUG), true)\n+\tLD_FLAGS += -w -s\n+endif\n+\n .PHONY: all\n all: cloudflared test\n \n@@ -71,15 +75,15 @@ clean:\n \n .PHONY: cloudflared\n cloudflared: tunnel-deps\n-\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) go build -v -mod=vendor $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tGOOS=$(TARGET_OS) GOARCH=$(TARGET_ARCH) go build -v -mod=vendor -ldflags='$(LD_FLAGS)' $(IMPORT_PATH)/cmd/cloudflared\n \n .PHONY: container\n container:\n \tdocker build --build-arg=TARGET_ARCH=$(TARGET_ARCH) --build-arg=TARGET_OS=$(TARGET_OS) -t cloudflare/cloudflared-$(TARGET_OS)-$(TARGET_ARCH):\"$(VERSION)\" .\n \n .PHONY: test\n test: vet\n-\tgo test -v -mod=vendor -race $(VERSION_FLAGS) ./...\n+\tgo test -v -mod=vendor -race -ldflags='$(LD_FLAGS)' ./...\n \n .PHONY: test-ssh-server\n test-ssh-server:\n@@ -190,7 +194,7 @@ homebrew-release: homebrew-upload\n \n .PHONY: release\n release: bin/equinox\n-\tbin/equinox release $(EQUINOX_FLAGS) -- $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n+\tbin/equinox release $(EQUINOX_FLAGS) -- -ldflags='$(LD_FLAGS)' $(IMPORT_PATH)/cmd/cloudflared\n \n .PHONY: github-release\n github-release: cloudflared\n@@ -225,4 +229,4 @@ vet:\n \n .PHONY: msi\n msi: cloudflared\n-\tgo-msi make --msi cloudflared.msi --version $(MSI_VERSION)\n\\ No newline at end of file\n+\tgo-msi make --msi cloudflared.msi --version $(MSI_VERSION)\n---\n"}], "ideal": "Title: Add -w -s to ldflags when compiling for release\n\nBody: By default, when compiling cloudflared via make, we can strip the symbol\r\ntable and DWARF debugging information from the binary. This results in\r\nan approximately 10Mb reduction in file size, with no impact on\r\nexecution.\r\n\r\nIf you need to run cloudflared through a debugger and need the\r\nDWARF/symbol table information, you can run `make cloudflared DEBUG=true` to\r\nuse the previous behaviour."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/macos_service.go\n@@ -47,6 +47,7 @@ func newLaunchdTemplate(installPath, stdoutPath, stderrPath string) *ServiceTemp\n \t\t<key>ProgramArguments</key>\n \t\t<array>\n \t\t\t<string>{{ .Path }}</string>\n+\t\t\t<string>proxy-dns</string>\n \t\t</array>\n \t\t<key>RunAtLoad</key>\n \t\t<true/>\n---\n"}], "ideal": "Title: Fix macOS launch daemon\n\nBody: On macOS you'd start the proxy with '[sudo] cloudflared proxy-dns'. This launch daemon didn't start the proxy since the argument 'proxy-dns' was missing. This commit adds the argument to the launch daemon and now starting the proxy on system startup works as expected."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/main.go\n@@ -127,10 +127,14 @@ func action(version string, shutdownC, graceShutdownC chan struct{}) cli.ActionF\n \t\ttags[\"hostname\"] = c.String(\"hostname\")\n \t\traven.SetTagsContext(tags)\n \t\traven.CapturePanic(func() { err = tunnel.StartServer(c, version, shutdownC, graceShutdownC) }, nil)\n+\t\texitCode := 0\n \t\tif err != nil {\n \t\t\thandleError(err)\n+\t\t\texitCode = 1\n \t\t}\n-\t\treturn err\n+\t\t// we already handle error printing, so we pass an empty string so we\n+\t\t// don't have to print again.\n+\t\treturn cli.Exit(\"\", exitCode)\n \t}\n }\n \n---\n"}], "ideal": "Title: Handle exit code on err\n\nBody: fixes #96.\r\n\r\nI've tested this locally, and it seems to fix the issue described on #96.\r\n\r\ncc: @nickvollmar"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "tunneldns/metrics.go\n@@ -4,6 +4,7 @@ import (\n \t\"context\"\n \n \t\"github.com/coredns/coredns/plugin\"\n+\t\"github.com/coredns/coredns/plugin/metrics\"\n \t\"github.com/coredns/coredns/plugin/metrics/vars\"\n \t\"github.com/coredns/coredns/plugin/pkg/dnstest\"\n \t\"github.com/coredns/coredns/plugin/pkg/rcode\"\n@@ -37,7 +38,7 @@ func (p MetricsPlugin) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dn\n \tstatus, err := plugin.NextOrFailure(p.Name(), p.Next, ctx, rw, r)\n \n \t// Update built-in metrics\n-\tvars.Report(ctx, state, \".\", rcode.ToString(rw.Rcode), rw.Len, rw.Start)\n+\tvars.Report(metrics.WithServer(ctx), state, \".\", rcode.ToString(rw.Rcode), rw.Len, rw.Start)\n \n \treturn status, err\n }\n---\n"}], "ideal": "Title: tunneldns: Update reporting metrics for API breakage in CoreDNS.\n\nBody: Use the new metrics.WithServer(ctx) method to get a server name, as the vars.Report emethod name takes this as its first param.\r\n\r\nAPI was broken by upstream PR: https://github.com/coredns/coredns/pull/2722 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -0,0 +1,12 @@\n+FROM golang:1.12 as builder\n+WORKDIR /go/src/github.com/cloudflare/cloudflared/\n+RUN apt-get update && apt-get install -y --no-install-recommends upx\n+# Run after `apt-get update` to improve rebuild scenarios\n+COPY . .\n+RUN make cloudflared\n+RUN upx --no-progress cloudflared\n+\n+FROM gcr.io/distroless/base\n+COPY --from=builder /go/src/github.com/cloudflare/cloudflared/cloudflared /usr/local/bin/\n+ENTRYPOINT [\"cloudflared\", \"--no-autoupdate\"]\n+CMD [\"version\"]\n---\nMakefile\n@@ -31,6 +31,10 @@ clean:\n cloudflared: tunnel-deps\n \tgo build -v $(VERSION_FLAGS) $(IMPORT_PATH)/cmd/cloudflared\n \n+.PHONY: container\n+container:\n+\tdocker build -t cloudflare/cloudflared:\"$(VERSION)\" .\n+\n .PHONY: test\n test: vet\n \tgo test -v -race $(VERSION_FLAGS) ./...\n---\n"}], "ideal": "Title: Build a docker container\n\nBody: The build phase makes the assumption that any capnproto-files are pre-processed before building in-docker. I personally prefer \"add-on-change\" for protos over add-on-compile since that may lead to a dirty build.\r\n\r\nChose to add this as a PR even though there's already an open one. Feel free to close if we should focus on one PR with a slightly different direction instead.\r\n\r\nFinally, my comment in the previous PR (#89) set out to clone inside the container which likely is a safer approach for release builds, but copying tree allows us to do \"developer\"/in-transit builds."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "Dockerfile\n@@ -0,0 +1,6 @@\n+FROM golang:1.12 as builder\n+WORKDIR /go/src/github.com/cloudflare/cloudflared/\n+ADD . .\n+RUN GOOS=linux go build -a -o cloudflared ./cmd/cloudflared\n+\n+CMD [\"./cloudflared\"]  \n\\ No newline at end of file\n---\n"}], "ideal": "Title: Add dockerfile to make an official image\n\nBody: Closes #62"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/access/cmd.go\n@@ -72,6 +72,14 @@ func Commands() []*cli.Command {\n \t\t\t\t\tArgsUsage:       \"allow-request will allow the curl request to continue even if the jwt is not present.\",\n \t\t\t\t\tSkipFlagParsing: true,\n \t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tName:   \"gitConfig\",\n+\t\t\t\t\tAction: gitConfig,\n+\t\t\t\t\tUsage:  \"gitConfig <repo_url>\",\n+\t\t\t\t\tDescription: `The gitConfig subcommand configures your git to injects the JWT into a cf-access-token\n+\t\t\t\t\theader when using git to reach an application behind Access.`,\n+\t\t\t\t\tSkipFlagParsing: true,\n+\t\t\t\t},\n \t\t\t\t{\n \t\t\t\t\tName:        \"token\",\n \t\t\t\t\tAction:      generateToken,\n@@ -182,6 +190,41 @@ func curl(c *cli.Context) error {\n \treturn shell.Run(\"curl\", cmdArgs...)\n }\n \n+/* gitConfig modifies your ~/.gitconfig file to\n+pass Access JWT along in request\n+*/\n+func gitConfig(c *cli.Context) error {\n+\traven.SetDSN(sentryDSN)\n+\tlogger := log.CreateLogger()\n+\targs := c.Args()\n+\tif args.Len() < 1 {\n+\t\tlogger.Error(\"Please provide the access app and command you wish to run.\")\n+\t\treturn errors.New(\"incorrect args\")\n+\t}\n+\n+\tcmdArgs := args.Slice()\n+\tappURL, err := getAppURL(cmdArgs)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\ttok, err := token.GetTokenIfExists(appURL)\n+\tif err != nil || tok == \"\" {\n+\t\ttok, err = token.FetchToken(appURL)\n+\t\tif err != nil {\n+\t\t\tlogger.Error(\"Failed to refresh token: \", err)\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tgitArgs := []string{\n+\t\t\"config\",\n+\t\t\"--global\",\n+\t\tfmt.Sprintf(\"http.https://%s.extraheader\", appURL.Hostname()),\n+\t\tfmt.Sprintf(\"cf-access-token:%s\", tok),\n+\t}\n+\treturn shell.Run(\"git\", gitArgs...)\n+}\n+\n // token dumps provided token to stdout\n func generateToken(c *cli.Context) error {\n \traven.SetDSN(sentryDSN)\n---\n"}], "ideal": "Title: configure git to access to http(s) based repos behind CloudFlare Access\n\nBody:  example command: `cloudflared access gitConfig https://git.site.com`"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/macos_service.go\n@@ -55,10 +55,7 @@ func newLaunchdTemplate(installPath, stdoutPath, stderrPath string) *ServiceTemp\n \t\t<key>StandardErrorPath</key>\n \t\t<string>%s</string>\n \t\t<key>KeepAlive</key>\n-\t\t<dict>\n-\t\t\t<key>SuccessfulExit</key>\n-\t\t\t<false/>\n-\t\t</dict>\n+\t\t<true/>\n \t\t<key>ThrottleInterval</key>\n \t\t<integer>20</integer>\n \t</dict>\n---\n"}], "ideal": "Title: adjust macOS launchctl to auto-restart/keepalive\n\nBody: I would like cloudflared to auto restart as i find the process often crashes with no error logs reported. Here is a PR for this simple change."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/config/configuration.go\n@@ -63,7 +63,17 @@ func FindDefaultConfigPath() string {\n \treturn \"\"\n }\n \n+// ValidateUnixSocket ensures --unix-socket param is used exclusively\n+// i.e. it fails if a user specifies both --url and --unix-socket\n+func ValidateUnixSocket(c *cli.Context) (string, error) {\n+\tif c.IsSet(\"unix-socket\") && (c.IsSet(\"url\") || c.NArg() > 0) {\n+\t\treturn \"\", errors.New(\"--unix-socket must be used exclusivly.\")\n+\t}\n+\treturn c.String(\"unix-socket\"), nil\n+}\n+\n // ValidateUrl will validate url flag correctness. It can be either from --url or argument\n+// Notice ValidateUnixSocket, it will enforce --unix-socket is not used with --url or argument\n func ValidateUrl(c *cli.Context) (string, error) {\n \tvar url = c.String(\"url\")\n \tif c.NArg() > 0 {\n---\ncmd/cloudflared/tunnel/cmd.go\n@@ -474,6 +474,12 @@ func tunnelFlags(shouldHide bool) []cli.Flag {\n \t\t\tEnvVars: []string{\"TUNNEL_URL\"},\n \t\t\tHidden:  shouldHide,\n \t\t}),\n+\t\taltsrc.NewStringFlag(&cli.StringFlag{\n+\t\t\tName:    \"unix-socket\",\n+\t\t\tUsage:   \"Path to unix socket to use instead of --url\",\n+\t\t\tEnvVars: []string{\"TUNNEL_UNIX_SOCKET\"},\n+\t\t\tHidden:  shouldHide,\n+\t\t}),\n \t\taltsrc.NewStringFlag(&cli.StringFlag{\n \t\t\tName:    \"hostname\",\n \t\t\tUsage:   \"Set a hostname on a Cloudflare zone to route traffic through this tunnel.\",\n---\ncmd/cloudflared/tunnel/configuration.go\n@@ -1,6 +1,7 @@\n package tunnel\n \n import (\n+\t\"context\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n \t\"encoding/hex\"\n@@ -160,7 +161,6 @@ func prepareTunnelConfig(c *cli.Context, buildInfo *origin.BuildInfo, version st\n \t\tlogger.WithError(err).Error(\"Error validating origin URL\")\n \t\treturn nil, errors.Wrap(err, \"Error validating origin URL\")\n \t}\n-\tlogger.Infof(\"Proxying tunnel requests to %s\", originURL)\n \n \toriginCert, err := getOriginCert(c)\n \tif err != nil {\n@@ -175,19 +175,37 @@ func prepareTunnelConfig(c *cli.Context, buildInfo *origin.BuildInfo, version st\n \n \ttunnelMetrics := origin.NewTunnelMetrics()\n \thttpTransport := &http.Transport{\n-\t\tProxy: http.ProxyFromEnvironment,\n-\t\tDialContext: (&net.Dialer{\n-\t\t\tTimeout:   c.Duration(\"proxy-connect-timeout\"),\n-\t\t\tKeepAlive: c.Duration(\"proxy-tcp-keepalive\"),\n-\t\t\tDualStack: !c.Bool(\"proxy-no-happy-eyeballs\"),\n-\t\t}).DialContext,\n+\t\tProxy:                 http.ProxyFromEnvironment,\n \t\tMaxIdleConns:          c.Int(\"proxy-keepalive-connections\"),\n \t\tIdleConnTimeout:       c.Duration(\"proxy-keepalive-timeout\"),\n \t\tTLSHandshakeTimeout:   c.Duration(\"proxy-tls-timeout\"),\n \t\tExpectContinueTimeout: 1 * time.Second,\n \t\tTLSClientConfig:       &tls.Config{RootCAs: originCertPool, InsecureSkipVerify: c.IsSet(\"no-tls-verify\")},\n \t}\n \n+\tdialContext := (&net.Dialer{\n+\t\tTimeout:   c.Duration(\"proxy-connect-timeout\"),\n+\t\tKeepAlive: c.Duration(\"proxy-tcp-keepalive\"),\n+\t\tDualStack: !c.Bool(\"proxy-no-happy-eyeballs\"),\n+\t}).DialContext\n+\n+\tif c.IsSet(\"unix-socket\") {\n+\t\tunixSocket, err := config.ValidateUnixSocket(c)\n+\t\tif err != nil {\n+\t\t\tlogger.WithError(err).Error(\"Error validating --unix-socket\")\n+\t\t\treturn nil, errors.Wrap(err, \"Error validating --unix-socket\")\n+\t\t}\n+\n+\t\tlogger.Infof(\"Proxying tunnel requests to unix:%s\", unixSocket)\n+\t\thttpTransport.DialContext = func(ctx context.Context, _, _ string) (net.Conn, error) {\n+\t\t\t// if --unix-socket specified, enforce network type \"unix\"\n+\t\t\treturn dialContext(ctx, \"unix\", unixSocket)\n+\t\t}\n+\t} else {\n+\t\tlogger.Infof(\"Proxying tunnel requests to %s\", originURL)\n+\t\thttpTransport.DialContext = dialContext\n+\t}\n+\n \tif !c.IsSet(\"hello-world\") && c.IsSet(\"origin-server-name\") {\n \t\thttpTransport.TLSClientConfig.ServerName = c.String(\"origin-server-name\")\n \t}\n---\norigin/tunnel.go\n@@ -37,8 +37,10 @@ const (\n )\n \n type TunnelConfig struct {\n+\t// OriginUrl may not be used if a user specifies a unix socket.\n+\tOriginUrl string\n+\n \tEdgeAddrs          []string\n-\tOriginUrl          string\n \tHostname           string\n \tOriginCert         []byte\n \tTlsConfig          *tls.Config\n---\n"}], "ideal": "Title: Support UNIX sockets\n\nBody: This pull requests adds support for unix socket upstreams."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/linux_service.go\n@@ -84,7 +84,8 @@ WantedBy=timers.target\n var sysvTemplate = ServiceTemplate{\n \tPath:     \"/etc/init.d/cloudflared\",\n \tFileMode: 0755,\n-\tContent: `# For RedHat and cousins:\n+\tContent: `#!/bin/sh\n+# For RedHat and cousins:\n # chkconfig: 2345 99 01\n # description: Argo Tunnel agent\n # processname: {{.Path}}\n---\n"}], "ideal": "Title: cloudflared/linux_service: Add missing /etc/init.d shebang\n\nBody: When using sysv init scripts, `cloudflared` fails to start due to the\r\nmissing shebang interpreter line.\r\n\r\nThis patch adds the missing shebang."}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "origin/tunnel.go\n@@ -431,6 +431,12 @@ func H2RequestHeadersToH1Request(h2 []h2mux.Header, h1 *http.Request) error {\n \t\t\t\treturn fmt.Errorf(\"invalid path\")\n \t\t\t}\n \t\t\th1.URL = resolved\n+\t\tcase \"content-length\":\n+\t\t\tcontentLength, err := strconv.ParseInt(header.Value, 10, 64)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"unparseable content length\")\n+\t\t\t}\n+\t\t\th1.ContentLength = contentLength\n \t\tdefault:\n \t\t\th1.Header.Add(http.CanonicalHeaderKey(header.Name), header.Value)\n \t\t}\n---\n"}], "ideal": "Title: Fix on Content-Length header for HTTP2->HTTP1 to make POSTs work\n\nBody: https://github.com/cloudflare/cloudflared/issues/30"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "origin/tunnel.go\n@@ -378,6 +378,12 @@ func H2RequestHeadersToH1Request(h2 []h2mux.Header, h1 *http.Request) error {\n \t\t\t\treturn fmt.Errorf(\"invalid path\")\n \t\t\t}\n \t\t\th1.URL = resolved\n+\t\tcase \"content-length\":\n+\t\t\tl, err := strconv.ParseInt(header.Value, 10, 64)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"unparseable content length\")\n+\t\t\t}\n+\t\t\th1.ContentLength = l\n \t\tdefault:\n \t\t\th1.Header.Add(http.CanonicalHeaderKey(header.Name), header.Value)\n \t\t}\n---\n"}], "ideal": "Title: Fix POST requests\n\nBody: Fixes #5 "}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "tunneldns/https_upstream.go\n@@ -43,7 +43,7 @@ func NewUpstreamHTTPS(endpoint string) (Upstream, error) {\n \thttp2.ConfigureTransport(transport)\n \n \tclient := &http.Client{\n-\t\tTimeout:   time.Second * defaultTimeout,\n+\t\tTimeout:   defaultTimeout,\n \t\tTransport: transport,\n \t}\n \n---\n"}], "ideal": "Title: HTTP timeout set to wrong value.\n\nBody: Because the defaultTimeout is defined as a constant you do not need to multiply it by time.Second again otherwise you end up with some stupid timeout as seen here. https://play.golang.org/p/Dl7rU_n_8Ej"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "cmd/cloudflared/linux_service.go\n@@ -90,8 +90,8 @@ var sysvTemplate = ServiceTemplate{\n # Short-Description: Argo Tunnel\n # Description:       Argo Tunnel agent\n ### END INIT INFO\n-cmd=\"{{.Path}} --config /etc/cloudflared/config.yml --origincert /etc/cloudflared/cert.pem --pidfile /var/run/$name.pid --autoupdate-freq 24h0m0s\"\n name=$(basename $(readlink -f $0))\n+cmd=\"{{.Path}} --config /etc/cloudflared/config.yml --origincert /etc/cloudflared/cert.pem --pidfile /var/run/$name.pid --autoupdate-freq 24h0m0s\"\n pid_file=\"/var/run/$name.pid\"\n stdout_log=\"/var/log/$name.log\"\n stderr_log=\"/var/log/$name.err\"\n---\n"}], "ideal": "Title: Fix order of values for init script\n\nBody: Fixes #17"}
{"input": [{"role": "system", "content": "Given the following code diff, generate a title and a description of a GitHub pull request that best represents this code diff.\n\nWrite your answer in the following format:\n\nTitle: [[Title of the GitHub Pull Request]]\n\nBody:  [[Description of the GitHub Pull Request]]"}, {"role": "user", "content": "origin/metrics.go\n@@ -27,7 +27,7 @@ type muxerMetrics struct {\n \toutBoundRateMax  *prometheus.GaugeVec\n }\n \n-type tunnelMetrics struct {\n+type TunnelMetrics struct {\n \thaConnections     prometheus.Gauge\n \ttotalRequests     prometheus.Counter\n \trequestsPerTunnel *prometheus.CounterVec\n@@ -229,7 +229,7 @@ func convertRTTMilliSec(t time.Duration) float64 {\n }\n \n // Metrics that can be collected without asking the edge\n-func NewTunnelMetrics() *tunnelMetrics {\n+func NewTunnelMetrics() *TunnelMetrics {\n \thaConnections := prometheus.NewGauge(\n \t\tprometheus.GaugeOpts{\n \t\t\tName: \"ha_connections\",\n@@ -305,7 +305,7 @@ func NewTunnelMetrics() *tunnelMetrics {\n \t)\n \tprometheus.MustRegister(serverLocations)\n \n-\treturn &tunnelMetrics{\n+\treturn &TunnelMetrics{\n \t\thaConnections:                  haConnections,\n \t\ttotalRequests:                  totalRequests,\n \t\trequestsPerTunnel:              requestsPerTunnel,\n@@ -322,19 +322,19 @@ func NewTunnelMetrics() *tunnelMetrics {\n \t}\n }\n \n-func (t *tunnelMetrics) incrementHaConnections() {\n+func (t *TunnelMetrics) incrementHaConnections() {\n \tt.haConnections.Inc()\n }\n \n-func (t *tunnelMetrics) decrementHaConnections() {\n+func (t *TunnelMetrics) decrementHaConnections() {\n \tt.haConnections.Dec()\n }\n \n-func (t *tunnelMetrics) updateMuxerMetrics(connectionID string, metrics *h2mux.MuxerMetrics) {\n+func (t *TunnelMetrics) updateMuxerMetrics(connectionID string, metrics *h2mux.MuxerMetrics) {\n \tt.muxerMetrics.update(connectionID, metrics)\n }\n \n-func (t *tunnelMetrics) incrementRequests(connectionID string) {\n+func (t *TunnelMetrics) incrementRequests(connectionID string) {\n \tt.concurrentRequestsLock.Lock()\n \tvar concurrentRequests uint64\n \tvar ok bool\n@@ -356,7 +356,7 @@ func (t *tunnelMetrics) incrementRequests(connectionID string) {\n \tt.concurrentRequestsPerTunnel.WithLabelValues(connectionID).Inc()\n }\n \n-func (t *tunnelMetrics) decrementConcurrentRequests(connectionID string) {\n+func (t *TunnelMetrics) decrementConcurrentRequests(connectionID string) {\n \tt.concurrentRequestsLock.Lock()\n \tif _, ok := t.concurrentRequests[connectionID]; ok {\n \t\tt.concurrentRequests[connectionID] -= 1\n@@ -368,13 +368,13 @@ func (t *tunnelMetrics) decrementConcurrentRequests(connectionID string) {\n \tt.concurrentRequestsPerTunnel.WithLabelValues(connectionID).Dec()\n }\n \n-func (t *tunnelMetrics) incrementResponses(connectionID, code string) {\n+func (t *TunnelMetrics) incrementResponses(connectionID, code string) {\n \tt.responseByCode.WithLabelValues(code).Inc()\n \tt.responseCodePerTunnel.WithLabelValues(connectionID, code).Inc()\n \n }\n \n-func (t *tunnelMetrics) registerServerLocation(connectionID, loc string) {\n+func (t *TunnelMetrics) registerServerLocation(connectionID, loc string) {\n \tt.locationLock.Lock()\n \tdefer t.locationLock.Unlock()\n \tif oldLoc, ok := t.oldServerLocations[connectionID]; ok && oldLoc == loc {\n---\norigin/tunnel.go\n@@ -53,7 +53,7 @@ type TunnelConfig struct {\n \tTags              []tunnelpogs.Tag\n \tHAConnections     int\n \tHTTPTransport     http.RoundTripper\n-\tMetrics           *tunnelMetrics\n+\tMetrics           *TunnelMetrics\n \tMetricsUpdateFreq time.Duration\n \tProtocolLogger    *logrus.Logger\n \tLogger            *logrus.Logger\n@@ -335,7 +335,7 @@ func UnregisterTunnel(muxer *h2mux.Muxer, gracePeriod time.Duration) error {\n func LogServerInfo(logger *logrus.Entry,\n \tpromise tunnelrpc.ServerInfo_Promise,\n \tconnectionID uint8,\n-\tmetrics *tunnelMetrics,\n+\tmetrics *TunnelMetrics,\n ) {\n \tserverInfoMessage, err := promise.Struct()\n \tif err != nil {\n@@ -398,7 +398,7 @@ type TunnelHandler struct {\n \thttpClient http.RoundTripper\n \ttlsConfig  *tls.Config\n \ttags       []tunnelpogs.Tag\n-\tmetrics    *tunnelMetrics\n+\tmetrics    *TunnelMetrics\n \t// connectionID is only used by metrics, and prometheus requires labels to be string\n \tconnectionID string\n }\n---\n"}], "ideal": "Title: Makes origin.TunnelMetrics public again\n\nBody: Test code must avoid the prometheus static initialization, and\r\ncan do this by creating a dummy TunnelMetrics object, provided\r\nit is public."}
